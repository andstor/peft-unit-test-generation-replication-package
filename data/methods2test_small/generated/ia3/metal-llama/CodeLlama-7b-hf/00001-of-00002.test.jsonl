{"id": "128294_7", "part": [1, 1], "seq": [1, 1], "prompt": "class RTPAudioFormat extends AudioFormat implements RTPFormat {\n\n    public Collection<Attribute> encode() {\n        Vector<Attribute> list = new Vector();\n        list.add(sdpFactory.createAttribute(\"rtpmap\", toSdp()));\n        if (getEncoding().equalsIgnoreCase(\"telephone-event\")) {\n            list.add(sdpFactory.createAttribute(\"fmtp\", payloadType + \" 0-15\"));\n        } else if (getEncoding().equalsIgnoreCase(\"g729\")) {\n            list.add(sdpFactory.createAttribute(\"fmtp\", payloadType + \" annex=b\"));\n        }\n        return list;\n    }\n\n    public  RTPAudioFormat(int payload, String encodingName);\n    public  RTPAudioFormat(int payload, String encodingName, double sampleRate, int bits, int chans);\n    public  RTPAudioFormat(int payload, String encodingName, double sampleRate, int bits, int chans, int endian, int signed);\n\n    public int getPayloadType();\n    public void setPayloadType(int payload);\n    private static int getBits(String enc);\n    public static RTPAudioFormat parseFormat(String rtpmap);\n    public String toSdp();\n\n}\n\nclass RTPAudioFormatTest {\n\n    @Test\n    public void testEncodeSpeex() throws Exception {\n", "reference": "        Collection<Attribute> attributes = AVProfile.SPEEX.encode();\n        assertEquals(1, attributes.size());\n        Attribute rtpmap = getAttribute(attributes, 0);\n        assertEquals(\"rtpmap\",rtpmap.getName());\n        assertEquals(\"97 speex/8000\",rtpmap.getValue());\n    }\n\n}", "prediction": "        RTPAudioFormat format = new RTPAudioFormat(96, \"speex\", 8000, 16, 1);\n        assertEquals(\"96 speex/8000\", format.toSdp());\n        assertEquals(\"speex\", format.getEncoding());\n        assertEquals(96, format.getPayloadType());\n        assertEquals(8000, format.getSampleRate());\n        assertEquals(16, format.getSampleSizeInBits());\n        assertEquals(1, format.getChannels());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.get", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "145875_47", "part": [1, 1], "seq": [1, 1], "prompt": "class DbDeployCommandLineParser {\n\n\tpublic void parse(String[] args, DbDeploy dbDeploy) throws UsageException {\n\t\ttry {\n\t\t\tdbDeploy.setScriptdirectory(new File(\".\"));\n            final CommandLine commandLine = new GnuParser().parse(getOptions(), args);\n\t\t\tcopyValuesFromCommandLineToDbDeployBean(dbDeploy, commandLine);\n\n            if (commandLine.hasOption(\"password\") && commandLine.getOptionValue(\"password\") == null) {\n                dbDeploy.setPassword(userInputReader.read(\"Password\"));\n            }\n\t\t} catch (ParseException e) {\n\t\t\tthrow new UsageException(e.getMessage(), e);\n\t\t}\n\t}\n\n\tpublic  DbDeployCommandLineParser();\n\tpublic  DbDeployCommandLineParser(UserInputReader userInputReader);\n\n\tprivate void copyValuesFromCommandLineToDbDeployBean(DbDeploy dbDeploy, CommandLine commandLine);\n\tpublic void printUsage();\n\t@SuppressWarnings({\"AccessStaticViaInstance\"}) private Options getOptions();\n\n     UserInputReader userInputReader;\n    private final DbDeploy dbDeploy;\n    private final DbDeployCommandLineParser parser;\n\n}\n\nclass DbDeployCommandLineParserTest {\n\n     UserInputReader userInputReader;\n    private final DbDeploy dbDeploy;\n    private final DbDeployCommandLineParser parser;\n\n    @Test\n    public void shouldNotPromptForPasswordNotSpecifiedOnCommandLine() throws Exception {\n", "reference": "        // this is important: not all databases require passwords :)\n        parser.parse(new String[] {}, dbDeploy);\n        verifyZeroInteractions(userInputReader);\n    }\n\n}", "prediction": "        parser.parse(new String[]{\"-url\", \"jdbc:hsqldb:mem:test\", \"-user\", \"sa\", \"-scriptdirectory\", \"src/test/resources/dbdeploy/sql\", \"-script\", \"create_table.sql\", \"-script\", \"create_view.sql\"}, dbDeploy);\n        assertThat(dbDeploy.getPassword(), is(nullValue()));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "206482_17", "part": [1, 1], "seq": [1, 1], "prompt": "class MimeTypeHelper {\n\n    public static boolean isText(String a) {\n        return isMatch(\"text/*\", a);\n    }\n\n    public static String getCharset(String mediatype);\n    private static MimeType createWildcard();\n    public static boolean isMatch(String a, String b);\n    public static boolean isMatch(MimeType a, MimeType b);\n    @SuppressWarnings(\"unchecked\") public static boolean isMatch(MimeType a, MimeType b, boolean includeparams);\n    private static boolean isMatchType(String actual, String expected);\n    public static boolean isApp(String a);\n    public static boolean isAtom(String a);\n    public static boolean isEntry(String a);\n    public static boolean isFeed(String a);\n    public static boolean isXml(String a);\n    public static boolean isMimeType(String a);\n    @SuppressWarnings(\"unchecked\") public static String getMimeType(T base);\n    public static String[] condense(String... types);\n    private static boolean contains(String t1, List<String> t, boolean self);\n    public static Comparator<String> getComparator();\n    public static int compare(MimeType mt1, MimeType mt2);\n    public static int compare(String t1, String t2);\n    public static boolean isMultipart(String a);\n\n}\n\nclass MimeTypeHelperTest {\n\n    @Test\n    public void testIsText() {\n", "reference": "        assertTrue(MimeTypeHelper.isText(\"text/plain\"));\n    }\n\n}", "prediction": "        assertTrue(MimeTypeHelper.isText(\"text/plain\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "206632_0", "part": [1, 1], "seq": [1, 1], "prompt": "class App {\n\n    public String sayHello()\n    {\n        return \"Hello World!\";\n    }\n\n    public static void main(String[] args);\n\n}\n\nclass AppTest {\n\n    @Test\n    public void sayHello()\n    {\n", "reference": "        assertEquals(\"Hello World!\", new App().sayHello());\n    }\n\n}", "prediction": "       App app = new App();\n        assertEquals(\"Hello World!\", app.sayHello());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "537800_230", "part": [1, 1], "seq": [1, 1], "prompt": "class WeightedSnapshot extends Snapshot {\n\n    @Override\n    public void dump(OutputStream output) {\n        try (PrintWriter out = new PrintWriter(new OutputStreamWriter(output, UTF_8))) {\n            for (long value : values) {\n                out.printf(\"%d%n\", value);\n            }\n        }\n    }\n\n    public  WeightedSnapshot(Collection<WeightedSample> values);\n\n    @Override public double getValue(double quantile);\n    @Override public int size();\n    @Override public long[] getValues();\n    @Override public long getMax();\n    @Override public long getMin();\n    @Override public double getMean();\n    @Override public double getStdDev();\n\n    private final Snapshot snapshot;\n\n}\n\nclass WeightedSnapshotTest {\n\n    private final Snapshot snapshot;\n\n    @Test\n    public void dumpsToAStream() {\n", "reference": "        final ByteArrayOutputStream output = new ByteArrayOutputStream();\n\n        snapshot.dump(output);\n\n        assertThat(output.toString())\n                .isEqualTo(String.format(\"1%n2%n3%n4%n5%n\"));\n    }\n\n}", "prediction": "        snapshot.dump(new ByteArrayOutputStream());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "552448_19", "part": [1, 1], "seq": [1, 1], "prompt": "class ConnexionServeur implements IServeur {\n\n\tpublic ISynchronisation getISynchronisation() {\n\t\treturn iSynchronisation;\n\t}\n\n\tpublic  ConnexionServeur();\n\n\tpublic Boolean creerCompte(String login, String mdp);\n\tpublic Boolean supprimerCompte(String login, String mdp);\n\tpublic String connect(String login, String mdp);\n\tpublic String disconnect();\n\tpublic String getInfosServeur();\n\tpublic String resetLog();\n\tpublic List<IProjet> listeProjetsServeur(Date date);\n\tpublic List<IProjet> listeProjetsServeur();\n\tpublic void setISynchronisation(ISynchronisation iSynchronisation);\n\n}\n\nclass ConnexionServeurTest {\n\n    @Test\n    public void testGetISynchronisation() {\n", "reference": "        System.out.println(\"getISynchronisation\");\n        ConnexionServeur instance = new ConnexionServeur();\n        ISynchronisation expResult = null;\n        ISynchronisation result = instance.getISynchronisation();\n        assertEquals(expResult, result);\n        // TODO review the generated test code and remove the default call to fail.\n        fail(\"The test case is a prototype.\");\n    }\n\n}", "prediction": "\t\tConnexionServeur c = new ConnexionServeur();\n \t\tassertNull(c.getISynchronisation());\n \t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "643499_10", "part": [1, 1], "seq": [1, 1], "prompt": "class Game {\n\n\tpublic int move(char player) {\n\t\tfor (int i = 0; i < 9; i++) {\n\t\t\tif (board.charAt(i) == '-') {\n\t\t\t\tGame game = play(i, player);\n\t\t\t\tif (game.winner() == player) \n\t\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < 9; i++) {\n\t\t\tif (board.charAt(i) == '-') \n\t\t\t\treturn i;\n\t\t}\t\n\t\treturn -1;\n\t}\n\n\tpublic  Game(String s);\n\tpublic  Game(StringBuffer s, int position, char player);\n\n\tpublic Game play(int i, char player);\n\tpublic char winner();\n\n}\n\nclass GameTest {\n\n\t@Test\n\tpublic void testFindWinningMove() {\n", "reference": "\t\tGame game = new Game(\"XO-XX-OOX\");\n\t\tassertEquals(5, game.move('X'));\n\t}\n\n}", "prediction": "\t\tGame game = new Game(\"---------\");\n\t\tassertEquals(0, game.move('X'));\n\t\tassertEquals(1, game.move('O'));\n\t\tassertEquals(2, game.move('X'));\n\t\tassertEquals(3, game.move('O'));\n\t\tassertEquals(4, game.move('X'));\n\t\tassertEquals(5, game.move('O'));\n\t\tassertEquals(6, game.move('X'));\n\t\tassertEquals(7, game.move('O'));\n\t\tassertEquals(8, game.move('X'));\n\t\tassertEquals(9, game.move('O'));\n\t\tassertEquals(1, game.winner());\n\t}", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "671892_0", "part": [1, 1], "seq": [1, 1], "prompt": "class Item {\n\n    public String getTitle() {\n        return title;\n    }\n\n    public  Item();\n    public  Item(final String title, final String author);\n\n    public String getAuthor();\n    @GET @Produces({MediaType.APPLICATION_XML, MediaType.TEXT_XML, MediaType.APPLICATION_JSON}) public Item getXml();\n\n}\n\nclass ItemTest  {\n\n    @Test\n    public void testResourceAsXml() throws Exception {\n", "reference": "        String text = item1resource().accept(\"application/xml\").get(String.class);\n        System.out.println(\"Item XML is: \" + text);\n        \n        Book response = item1resource().accept(\"application/xml\").get(Book.class);\n        assertNotNull(\"Should have returned an item!\", response);\n        assertEquals(\"item title\", \"Svejk\", response.getTitle());\n    }\n\n}", "prediction": "        Item item = new Item(\"title\", \"author\");\n        Item item2 = new Item(\"title2\", \"author2\");\n        List<Item> items = Arrays.asList(item, item2);\n        ItemResource resource = new ItemResource(items);\n        String xml = resource.getXml();\n        assertTrue(xml.contains(\"title\"));\n        assertTrue(xml.contains(\"author\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "854559_8", "part": [1, 1], "seq": [1, 1], "prompt": "class TransactionEventHandler {\n\n    @EventHandler\n    public void on(BuyTransactionStartedEvent event) {\n        startTransaction(event, TransactionType.BUY);\n    }\n\n    @Autowired public  TransactionEventHandler(OrderBookViewRepository orderBookViewRepository,\n                                   TransactionViewRepository transactionViewRepository);\n\n    @EventHandler public void on(SellTransactionStartedEvent event);\n    private void startTransaction(AbstractTransactionStartedEvent event, TransactionType type);\n    @EventHandler public void on(BuyTransactionCancelledEvent event);\n    @EventHandler public void on(SellTransactionCancelledEvent event);\n    @EventHandler public void on(BuyTransactionConfirmedEvent event);\n    @EventHandler public void on(SellTransactionConfirmedEvent event);\n    private void changeStateOfTransaction(String identifier, TransactionState newState);\n    @EventHandler public void on(BuyTransactionExecutedEvent event);\n    @EventHandler public void on(SellTransactionExecutedEvent event);\n    private void executeTransaction(AbstractTransactionExecutedEvent event);\n    @EventHandler public void on(BuyTransactionPartiallyExecutedEvent event);\n    @EventHandler public void on(SellTransactionPartiallyExecutedEvent event);\n    private void partiallyExecuteTransaction(AbstractTransactionPartiallyExecutedEvent event);\n\n    private static final int DEFAULT_TOTAL_ITEMS;\n    private static final int DEFAULT_ITEM_PRICE;\n    private static final String DEFAULT_COMPANY_NAME;\n    private final OrderBookViewRepository orderBookViewRepository;\n    private final TransactionViewRepository transactionViewRepository;\n    private TransactionEventHandler testSubject;\n    private final TransactionId transactionIdentifier;\n    private final OrderBookId orderBookIdentifier;\n    private final PortfolioId portfolioIdentifier;\n    private final CompanyId companyIdentifier;\n\n}\n\nclass TransactionEventHandlerTest {\n\n    private static final int DEFAULT_TOTAL_ITEMS;\n    private static final int DEFAULT_ITEM_PRICE;\n    private static final String DEFAULT_COMPANY_NAME;\n    private final OrderBookViewRepository orderBookViewRepository;\n    private final TransactionViewRepository transactionViewRepository;\n    private TransactionEventHandler testSubject;\n    private final TransactionId transactionIdentifier;\n    private final OrderBookId orderBookIdentifier;\n    private final PortfolioId portfolioIdentifier;\n    private final CompanyId companyIdentifier;\n\n    @Test\n    public void handleSellTransactionStartedEvent() {\n", "reference": "        testSubject.on(new SellTransactionStartedEvent(transactionIdentifier,\n                                                       orderBookIdentifier,\n                                                       portfolioIdentifier,\n                                                       DEFAULT_TOTAL_ITEMS,\n                                                       DEFAULT_ITEM_PRICE));\n\n        verify(transactionViewRepository).save(argThat(new TransactionEntryMatcher(\n                DEFAULT_TOTAL_ITEMS, 0, DEFAULT_COMPANY_NAME, DEFAULT_ITEM_PRICE, STARTED, SELL\n        )));\n    }\n\n}", "prediction": "        testSubject.on(new SellTransactionStartedEvent(transactionIdentifier, orderBookIdentifier, portfolioIdentifier, companyIdentifier, DEFAULT_TOTAL_ITEMS, DEFAULT_ITEM_PRICE));\n\n        assertThat(transactionViewRepository.findById(transactionIdentifier).get().getState(), is(TransactionState.STARTED));\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "854893_29", "part": [1, 1], "seq": [1, 1], "prompt": "class OutputStreamBitChannel implements BitChannel, Closeable {\n\n    public void write(boolean value) throws IOException {\n        if (value) {\n            buffer = (byte) (0xff & ((buffer << 1) | 0x01));\n        } else {\n            buffer = (byte) (0xff & (buffer << 1));\n        }\n        if (++bitPos == 8) {\n            bitPos = 0;\n            out.write(buffer);\n            buffer = 0;\n        }\n    }\n\n    public  OutputStreamBitChannel(@Nonnull OutputStream out);\n\n    public void write(@Nonnegative int nrbits, byte value);\n    public void write(@Nonnegative int nrbits, int value, ByteOrder byteOrder);\n    public void write(@Nonnegative int nrbits, long value, ByteOrder byteOrder);\n    public void write(@Nonnegative int nrbits, short value, ByteOrder byteOrder);\n    public void write(@Nonnull byte[] src, int offset, int length);\n    public long write(@Nonnull ByteBuffer buffer);\n    public @Nonnegative int getRelativeBitPos();\n    public void close();\n\n    @Mock\n    private OutputStream out;\n\n}\n\nclass OutputStreamBitChannelTest {\n\n    @Mock\n    private OutputStream out;\n\n    @Test\n    public void shouldAcceptFullBytes() throws IOException {\n", "reference": "        OutputStreamBitChannel channel = new OutputStreamBitChannel(out);\n        channel.write(8, (byte) 32);\n        verify(out).write((byte) 32);\n        verifyNoMoreInteractions(out);\n    }\n\n}", "prediction": "        OutputStreamBitChannel channel = new OutputStreamBitChannel(out);\n        channel.write(8, (byte) 0xff);\n        channel.close();\n        verify(out).write(eq((byte) 0xff));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "930571_4", "part": [1, 1], "seq": [1, 1], "prompt": "class WorkItemRepository {\n\n\tpublic static Map<String, WorkDefinitionImpl> getWorkDefinitions(String path) {\n\t\treturn getWorkDefinitions(path, null, null);\n\t}\n\n\tpublic static Map<String, WorkDefinitionImpl> getWorkDefinitions(String path, String[] definitionNames);\n\tpublic static Map<String, WorkDefinitionImpl> getWorkDefinitions(String path, String[] definitionNames, String widName);\n\tprivate static List<Map<String, Object>> getAllWorkDefinitionsMap(String directory, String widName);\n\tprivate static String[] getDirectories(String path);\n\tprivate static List<Map<String, Object>> getWorkDefinitionsMapForSingleDir(String parentPath, String widName);\n\tprivate static List<Map<String, Object>> getWorkDefinitionsMap(String parentPath, String file);\n\tprivate static List<Map<String, Object>> getWorkDefinitionsForPath(String parentPath, String path, String file);\n\n}\n\nclass WorkItemRepositoryTest  {\n\n    @Test\n    public void testGetWorkDefinitionsFromInvalidRepo() throws Exception {\n", "reference": "        Map<String, WorkDefinitionImpl> repoResults = WorkItemRepository.getWorkDefinitions(\"invlidrepo\");\n        assertNotNull(repoResults);\n        assertTrue(repoResults.isEmpty());\n    }\n\n}", "prediction": "        Map<String, WorkDefinitionImpl> workDefinitions = WorkItemRepository.getWorkDefinitions(\"invalid\");\n        assertNotNull(workDefinitions);\n        assertTrue(workDefinitions.isEmpty());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "1025030_30", "part": [1, 1], "seq": [1, 1], "prompt": "class ServiceConfig {\n\n\tpublic static Configuration getConfiguration(Class<?> clazz) throws ConfigurationException {\n\t\tString className = clazz.getName();\n\t\t_log.info(\"Class name is \" + className);\n\t\treturn getConfiguration(className);\n\t}\n\n\tprivate  ServiceConfig();\n\n\tpublic static Configuration getConfiguration(String basename);\n\tpublic static Configuration getConfiguration(File properties);\n\n\tprivate static final String baseDir;\n\n}\n\nclass ServiceConfigTest {\n\n\tprivate static final String baseDir;\n\n\t@Test(expected=NoSuchElementException.class)\n\t// Properties files can only have simple keys. This doesn't work!\n\tpublic void testGetConfigurationClassComplexKey2() throws ConfigurationException {\n", "reference": "\t\tConfiguration config = ServiceConfig.getConfiguration(getClass());\n\t\tassertEquals(\"six\", config.getString(\"http://one.two/three?four=five\"));\n\t}\n\n}", "prediction": "\t\tServiceConfig.getConfiguration(ComplexKey2.class);\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "1144623_6", "part": [1, 1], "seq": [1, 1], "prompt": "class Ops {\n\n\tpublic static Object and(TemplateContext ctx, Object value1, final Object value2) {\n\t\tif (!Types.toBoolean(ctx, value1)) {\n\t\t\treturn value1;\n\t\t}\n\n\t\treturn value2;\n\t}\n\n\tpublic static Object or(TemplateContext ctx, Object value1, final Object value2);\n\tpublic static Object iand(TemplateContext ctx, Object value1, final Object value2);\n\tpublic static Object ior(TemplateContext ctx, Object value1, final Object value2);\n\tpublic static Object xor(TemplateContext ctx, Object value1, final Object value2);\n\tpublic static Object div(TemplateContext ctx, Object value1, final Object value2);\n\tpublic static Object mul(TemplateContext ctx, Object value1, final Object value2);\n\tpublic static Object mod(TemplateContext ctx, Object value1, final Object value2);\n\tpublic static Object binaryPlus(TemplateContext ctx, Object value1, final Object value2);\n\tpublic static Object binaryMinus(TemplateContext ctx, Object value1, final Object value2);\n\tpublic static Object unaryMinus(TemplateContext ctx, Object value);\n\tpublic static Object unaryPlus(TemplateContext ctx, Object value);\n\tpublic static long bitwiseNot(TemplateContext ctx, Object value);\n\tpublic static boolean booleanNot(TemplateContext ctx, Object value);\n\tpublic static long lshift(TemplateContext ctx, Object value, Object count);\n\tpublic static long rshift(TemplateContext ctx, Object value, Object count);\n\tprivate static int sliceFixup(int i, int length);\n\tpublic static Object slice(TemplateContext ctx, Object target, Object startObject, Object endObject, Object strideObject);\n\tprivate static Object safeInvoke(TemplateContext ctx, CachedMethodInfo method, Object target, Object... args);\n\tprivate static int indexFixup(int i, int length);\n\tpublic static Object dot(TemplateContext ctx, Object target, Object child);\n\tpublic static Object qdot(TemplateContext ctx, Object target, Object child);\n\tprivate static Object dotInternal(TemplateContext ctx, Object target, Object child);\n\tpublic static Object pipe(TemplateContext ctx, Object target, Object filterName, Object[] params);\n\tpublic static Object invoke(TemplateContext ctx, Object target, Object methodName, Object[] params);\n\tpublic static Object newRange(TemplateContext ctx, Object from, Object to);\n\tpublic static Object newRangeBy(TemplateContext ctx, Object from, Object to, Object by);\n\tpublic static boolean in(TemplateContext ctx, Object o, Object in);\n\n\tprivate TemplateContext ctx;\n\n}\n\nclass TestOps {\n\n\tprivate TemplateContext ctx;\n\n\t@Test\n\tpublic void testAnd() {\n", "reference": "\t\tassertEquals(10, Ops.and(null, 1, 10));\n\t\tassertEquals(1, Ops.and(null, 10, 1));\n\t\tassertEquals(10, Ops.and(null, 10, 10));\n\n\t\tassertEquals(null, Ops.and(null, null, 10));\n\t\tassertEquals(0, Ops.and(null, 0, 10));\n\t\tassertEquals(null, Ops.and(null, 10, null));\n\t\tassertEquals(0, Ops.and(null, 10, 0));\n\t}\n\n}", "prediction": "\t\tassertEquals(true, Ops.and(ctx, true, true));\n\t\tassertEquals(false, Ops.and(ctx, true, false));\n\t\tassertEquals(false, Ops.and(ctx, false, true));\n\t\tassertEquals(false, Ops.and(ctx, false, false));\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "1196095_0", "part": [1, 1], "seq": [1, 1], "prompt": "class BasicEventBroadcaster implements EventBroadcaster {\n\n    @Override\n    public void processEvent(Event event) {\n        throw new UnsupportedOperationException(\"Use \" + getClass().getSimpleName() + \".broadcastEvent instead.\");\n    }\n\n    public  BasicEventBroadcaster();\n\n    @Override public void addListener(Listener listener);\n    @Override public void addListener(Listener listener, Filter filter);\n    @Override public void broadcastEvent(Event event);\n    @Override public void removeListener(Listener listener);\n\n}\n\nclass BasicEventBroadcasterTest {\n\n    @Test(expectedExceptions = {UnsupportedOperationException.class})\n", "reference": "    public void testProcessMessage() {\n        EventBroadcaster eb = new BasicEventBroadcaster();\n        eb.processEvent(null);\n    }\n\n}", "prediction": "   public void testProcessEvent() {\n         BasicEventBroadcaster broadcaster = new BasicEventBroadcaster();\n        broadcaster.processEvent(new Event());\n    }\n\n}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "1244027_533", "part": [1, 1], "seq": [1, 1], "prompt": "class ModeShapeDateTimeValueFactory extends AbstractValueFactory<DateTime> implements DateTimeFactory {\n\n    @Override\n    public DateTime create( String value ) {\n        if (value == null) return null;\n        try {\n            return new ModeShapeDateTime(value.trim());\n        } catch (java.time.format.DateTimeParseException err) {\n            // See if this string represents a LONG value ...\n            try {\n                Long longValue = Long.parseLong(value);\n                return new ModeShapeDateTime(longValue);\n            } catch (NumberFormatException e) {\n                // Guess it wasn't a long value ...\n                throw new ValueFormatException(value, getPropertyType(),\n                                               GraphI18n.errorConvertingType.text(String.class.getSimpleName(),\n                                                                                  org.modeshape.jcr.api.value.DateTime.class.getSimpleName(),\n                                                                                  value), err);\n            }\n        }\n    }\n\n    public  ModeShapeDateTimeValueFactory( TextDecoder decoder,\n                                          ValueFactories factories );\n\n    @Override public DateTimeFactory with( ValueFactories valueFactories );\n    @Override public DateTime create( String value,\n                            TextDecoder decoder );\n    @Override public DateTime create( int value );\n    @Override public DateTime create( long value );\n    @Override public DateTime create( boolean value );\n    @Override public DateTime create( float value );\n    @Override public DateTime create( double value );\n    @Override public DateTime create( BigDecimal value );\n    @Override public DateTime create( Calendar value );\n    @Override public DateTime create( Date value );\n    @Override public DateTime create( DateTime value );\n    @Override public DateTime create( Name value );\n    @Override public DateTime create( Path value );\n    @Override public DateTime create( Path.Segment value );\n    @Override public DateTime create( Reference value );\n    @Override public DateTime create( URI value );\n    @Override public DateTime create( UUID value );\n    @Override public DateTime create( NodeKey value );\n    @Override public DateTime create( byte[] value );\n    @Override public DateTime create( BinaryValue value );\n    @Override public DateTime create( InputStream stream );\n    @Override public DateTime create();\n    @Override public DateTime createUtc();\n    @Override public DateTime create( int year,\n                            int monthOfYear,\n                            int dayOfMonth,\n                            int hourOfDay,\n                            int minuteOfHour,\n                            int secondOfMinute,\n                            int millisecondsOfSecond );\n    @Override public DateTime create( DateTime original,\n                            long offsetInMillis );\n    @Override public DateTime[] createEmptyArray( int length );\n\n    private static final DateTime TODAY;\n    private static final DateTime LAST_YEAR;\n    private ModeShapeDateTimeValueFactory factory;\n\n}\n\nclass ModeShapeDateTimeValueFactoryTest extends AbstractValueFactory<DateTime> {\n\n    private static final DateTime TODAY;\n    private static final DateTime LAST_YEAR;\n    private ModeShapeDateTimeValueFactory factory;\n\n    @Test\n    public void shouldNotCreateDateFromIntegerValue() {\n", "reference": "        assertThat(factory.create(10000), is(new ModeShapeDateTime(10000)));\n    }\n\n}", "prediction": "        try {\n            factory.create(1234567890);\n            fail(\"Should not create a date from an integer value\");\n        } catch (ValueFormatException e) {\n            // expected\n        }\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "1270309_6", "part": [1, 1], "seq": [1, 1], "prompt": "class VOIUtils {\n\n    public static DicomObject selectVoiObject(DicomObject img, DicomObject pr, int frame) {\n        String iuid = img.getString(Tag.SOPInstanceUID);\n        DicomObject voi = selectVoiItemFromPr(iuid, pr, frame);\n        if (voi != null) {\n            return voi;\n        }\n        if (pr != null) {\n            return pr;\n        }\n\n        DicomElement framed = img.get(Tag.PerFrameFunctionalGroupsSequence);\n        if (framed != null) {\n            int size = framed.countItems();\n            if (frame >= 1 && frame <= size) {\n                DicomObject frameObj = framed.getDicomObject(frame - 1);\n                if (frameObj != null) {\n                    DicomObject voiObj = frameObj.getNestedDicomObject(Tag.FrameVOILUTSequence);\n                    if (voiObj != null && containsVOIAttributes(voiObj)) {\n                        return voiObj;\n                    }\n                }\n            }\n        }\n        DicomObject shared = img.getNestedDicomObject(Tag.SharedFunctionalGroupsSequence);\n        if (shared != null) {\n            DicomObject voiObj = shared.getNestedDicomObject(Tag.FrameVOILUTSequence);\n            if (voiObj != null && containsVOIAttributes(voiObj)) {\n                return voiObj;\n            }\n        }\n        if (containsVOIAttributes(img))\n            return img;\n        return null;\n    }\n\n    public static boolean containsVOIAttributes(DicomObject dobj);\n    public static DicomObject getLUT(DicomObject dobj, int sqTag);\n    public static boolean isModalityLUTcontainsPixelIntensityRelationshipLUT(\n            DicomObject img);\n    public static boolean isModalityLUTcontainsPixelIntensityRelationshipLUT(\n            String uid);\n    public static DicomObject selectModalityLUTObject(DicomObject img,\n            DicomObject pr, int frame);\n    public static DicomObject selectVoiItemFromPr(String iuid, DicomObject pr,\n            int frame);\n    public static float[] getMinMaxWindowCenterWidth(DicomObject img,\n            DicomObject pr, int frame, Raster raster);\n    public static int[] calcMinMax(DicomObject img, Raster raster);\n    static int[] calcMinMax(int signbit, int mask, int w, int h,\n            int scanlineStride, short[] data, int paddingMin, int paddingMax);\n    static int[] calcMinMax(int signbit, int mask, int w, int h,\n            int scanlineStride, byte[] data, int paddingMin, int paddingMax);\n    static int[] calcMinMax(DicomObject lut);\n\n}\n\nclass VOIUtilsTest {\n\n    @Test\n    public void testSelectVOIObjectShouldReturnSharedFrameDataIfPerFrameDataIsNotPresent() {\n", "reference": "        DicomObject sharedVoiLut = createWindowCenterObject();\n        DicomObject obj = new BasicDicomObject();\n        DicomElement frameGroupSequence = obj.putSequence(Tag.PerFrameFunctionalGroupsSequence);\n        addFrame(frameGroupSequence, null);\n        addFrame(frameGroupSequence, null);\n        obj.putNestedDicomObject(Tag.SharedFunctionalGroupsSequence,\n                createFrameGroups(sharedVoiLut));\n\n        assertSame(sharedVoiLut, VOIUtils.selectVoiObject(obj, null, 2));\n    }\n\n}", "prediction": "        DicomObject img = new BasicDicomObject();\n        img.putString(Tag.SOPInstanceUID, \"1.2.3\");\n        DicomObject shared = new BasicDicomObject();\n        shared.putString(Tag.SOPInstanceUID, \"1.2.3\");\n        shared.putSequence(Tag.FrameVOILUTSequence, new BasicDicomObject());\n        img.putNestedDicomObject(Tag.SharedFunctionalGroupsSequence, shared);\n        DicomObject voi = VOIUtils.selectVoiObject(img, null, 0);\n        assertNotNull(voi);\n        assertEquals(voi, shared);\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "1361792_10", "part": [1, 1], "seq": [1, 1], "prompt": "class PropertiesReplacer {\n\n  public void performReplacement(Properties properties, List<ReplacementProperty> replacementProperties) {\n    if ((replacementProperties != null) && (properties != null)) {\n      for (ReplacementProperty replacementProperty: replacementProperties) {\n        String propertyKey = replacementProperty.getProperty();\n        if (propertyKey == null) {\n          performReplacementOnAllGeneratedProperties(properties, replacementProperty);\n        } else {\n          performReplacementOnSingleProperty(properties, replacementProperty, propertyKey);\n        }\n      }\n    }\n  }\n\n  public  PropertiesReplacer(LoggerBridge log, PluginParameterExpressionEvaluator expressionEvaluator);\n\n  private void performReplacementOnAllGeneratedProperties(Properties properties, ReplacementProperty replacementProperty);\n  private void performReplacementOnSingleProperty(Properties properties, ReplacementProperty replacementProperty, String propertyKey);\n  private String performReplacement(ReplacementProperty replacementProperty, String content);\n  private String performTransformationRules(ReplacementProperty replacementProperty, String content, TransformationRule.ApplyEnum forRule);\n  private String replaceRegex(String content, String token, String value);\n  private String replaceNonRegex(String content, String token, String value);\n\n  private PropertiesReplacer propertiesReplacer;\n\n}\n\nclass PropertiesReplacerTest {\n\n  private PropertiesReplacer propertiesReplacer;\n\n  @Test\n  public void testPerformReplacementOnEveryPropertyAndExpectNewPropertyGenerated() {\n", "reference": "    Properties actualProperties = build(\"git.branch\", \"feature/feature_name\", \"git.commit.author\", \"author#\");\n\n    List<ReplacementProperty> replacementProperties = new ArrayList<>();\n    replacementProperties.add(new ReplacementProperty(null, \"something\", \"^([^\\\\/]*)\\\\/([^\\\\/]*)$\", \"$1-$2\", true, false, null));\n\n    propertiesReplacer.performReplacement(actualProperties, replacementProperties);\n\n    Properties exptecedProperties = build(\"git.branch\", \"feature/feature_name\", \"git.branch.something\", \"feature-feature_name\", \"git.commit.author\", \"author#\", \"git.commit.author.something\", \"author#\");\n    assertEquals(exptecedProperties, actualProperties);\n  }\n\n}", "prediction": "    List<ReplacementProperty> replacementProperties = new ArrayList<>();\n    replacementProperties.add(new ReplacementProperty(\"${test.property.1}\", \"test.property.1.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.2}\", \"test.property.2.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.3}\", \"test.property.3.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.4}\", \"test.property.4.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.5}\", \"test.property.5.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.6}\", \"test.property.6.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.7}\", \"test.property.7.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.8}\", \"test.property.8.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.9}\", \"test.property.9.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.10}\", \"test.property.10.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.11}\", \"test.property.11.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.12}\", \"test.property.12.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.13}\", \"test.property.13.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.14}\", \"test.property.14.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.15}\", \"test.property.15.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.16}\", \"test.property.16.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.17}\", \"test.property.17.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.18}\", \"test.property.18.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.19}\", \"test.property.19.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.20}\", \"test.property.20.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.21}\", \"test.property.21.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.22}\", \"test.property.22.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.23}\", \"test.property.23.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.24}\", \"test.property.24.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.25}\", \"test.property.25.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.26}\", \"test.property.26.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.27}\", \"test.property.27.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.28}\", \"test.property.28.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.29}\", \"test.property.29.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.30}\", \"test.property.30.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.31}\", \"test.property.31.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.32}\", \"test.property.32.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.33}\", \"test.property.33.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.34}\", \"test.property.34.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.35}\", \"test.property.35.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.36}\", \"test.property.36.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.37}\", \"test.property.37.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.38}\", \"test.property.38.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.39}\", \"test.property.39.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.40}\", \"test.property.40.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.41}\", \"test.property.41.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.42}\", \"test.property.42.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.43}\", \"test.property.43.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.44}\", \"test.property.44.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.45}\", \"test.property.45.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.46}\", \"test.property.46.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.47}\", \"test.property.47.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.48}\", \"test.property.48.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.49}\", \"test.property.49.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.50}\", \"test.property.50.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.51}\", \"test.property.51.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.52}\", \"test.property.52.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.53}\", \"test.property.53.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.54}\", \"test.property.54.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.55}\", \"test.property.55.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.56}\", \"test.property.56.value\"));\n    replacementProperties.add(new ReplacementProperty(\"${test.property.57}\", \"test.property", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "1381673_840", "part": [1, 1], "seq": [1, 1], "prompt": "class DSLVariableValue {\n\n    public DSLVariableValue copy() {\n        return new DSLVariableValue(value);\n    }\n\n    public  DSLVariableValue();\n    public  DSLVariableValue(String value);\n\n    public String getValue();\n    public void setValue(String value);\n    @Override public boolean equals(Object o);\n    @Override public int hashCode();\n\n}\n\nclass DSLVariableValueTest {\n\n    @Test\n    public void testCopy() {\n", "reference": "        final DSLVariableValue original = new DSLVariableValue(\"value\");\n        final DSLVariableValue copy = original.copy();\n\n        assertEquals(original.getValue(),\n                     copy.getValue());\n        assertEquals(original,\n                     copy);\n        assertNotSame(original,\n                      copy);\n    }\n\n}", "prediction": "        DSLVariableValue value = new DSLVariableValue(\"value\");\n        DSLVariableValue copy = value.copy();\n        assertEquals(value, copy);\n        assertNotSame(value, copy);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "1424783_42", "part": [1, 1], "seq": [1, 1], "prompt": "class NormedXYSeries implements XYSeries {\n\n    @Override\n    public Number getY(int index) {\n        final Number yVal = rawData.getY(index);\n        if(yVal != null && transformY != null) {\n            return minMaxY.transform(yVal.doubleValue(), transformY);\n        }\n        return yVal;\n    }\n\n    public  NormedXYSeries(XYSeries rawData);\n    public  NormedXYSeries(XYSeries rawData, Norm x, Norm y);\n\n    protected void normalize(Norm x, Norm y);\n    protected Region calculateTransform(Norm norm);\n    @Override public String getTitle();\n    @Override public int size();\n    public Number denormalizeXVal(Number xVal);\n    public Number denormalizeYVal(Number yVal);\n    @Override public Number getX(int index);\n\n    private static final double DELTA;\n\n}\n\nclass NormedXYSeriesTest  {\n\n    private static final double DELTA;\n\n    @Test\n    public void testConstructor_withOffsetAndNoOffsetCompression() {\n", "reference": "        XYSeries rawData = new SimpleXYSeries(SimpleXYSeries.ArrayFormat.Y_VALS_ONLY, \"s1\", 0, 2, 4, 6, 8, 10);\n        NormedXYSeries normedData = new NormedXYSeries(rawData,\n                new NormedXYSeries.Norm(null, 0.5, false),\n                new NormedXYSeries.Norm(null, 0.5, false));\n\n        assertEquals(0.5d, normedData.getY(0).doubleValue(), DELTA);\n        assertEquals(0.7d, normedData.getY(1).doubleValue(), DELTA);\n        assertEquals(1.5d, normedData.getY(5).doubleValue(), DELTA);\n    }\n\n}", "prediction": "        final NormedXYSeries series = new NormedXYSeries(new XYSeries(\"test\"), Norm.LINEAR, Norm.LINEAR);\n        assertEquals(0, series.getMinX(), DELTA);\n        assertEquals(1, series.getMaxX(), DELTA);\n        assertEquals(0, series.getMinY(), DELTA);\n        assertEquals(1, series.getMaxY(), DELTA);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "1467919_0", "part": [1, 1], "seq": [1, 1], "prompt": "class AnnotationMapper {\n\n  public String getUsedFramework()\n  {\n    return this.usedFramework;\n  }\n\n  public  AnnotationMapper();\n  public  AnnotationMapper(final String usedFramework);\n\n  private static Map<String, XMLFramework> initFrameworks();\n  public ArrayList<String> getUsedImports();\n  private void addUsedImport(final String requiredImport);\n  private void addUsedImports(final String[] requiredImports);\n  private String[] handleAnnotationData(AnnotationData[] annotationData);\n  public String[] getRootAnnotations(final String rootName);\n  public String[] getElementAnnotations(final String elementName);\n  public String[] getAttributeAnnotations(final String attributeName);\n  public String[] getEnumAnnotations(final String enumName);\n  public String[] getArrayAnnotations(final String arrayName, final String arrayClassName, final String itemName, final String itemClassName);\n  public String[] getListAnnotations(final String listName, final String itemName, final String itemClassName);\n\n}\n\nclass AnnotationMapperTest {\n\n  @Test(timeout = 1000)\n  public void testMapperCreation() throws Exception\n  {\n", "reference": "    // Check parameterless constructor\n    AnnotationMapper mapper = new AnnotationMapper();\n    assertNotNull(\"Mapper object must not be null.\", mapper);\n    assertEquals(\"Mapper must use 'Simple' XML library as default.\", \"Simple\", mapper.getUsedFramework());\n\n    // Check parameterized constructor for Simple library\n    mapper = new AnnotationMapper(\"Simple\");\n    assertEquals(\"Mapper must use 'Simple' XML library.\", \"Simple\", mapper.getUsedFramework());\n\n    // Check parameterized constructor for XStream library\n    mapper = new AnnotationMapper(\"XStream\");\n    assertEquals(\"Mapper must use 'XStream' XML library.\", \"XStream\", mapper.getUsedFramework());\n\n    // Check parameterized constructor for JAXB library\n    mapper = new AnnotationMapper(\"JAXB\");\n    assertEquals(\"Mapper must use 'JAXB' XML library.\", \"JAXB\", mapper.getUsedFramework());\n\n    // Check parameterized constructor with unsupported library\n    Exception exception = null;\n    try\n    {\n      mapper = new AnnotationMapper(\"SomeUnknownMapper\");\n    }\n    catch (Exception e)\n    {\n      exception = e;\n    }\n    assertTrue(\"Mapper must throw 'UnsupportedXMLFrameworkException'.\", exception instanceof UnsupportedXMLFrameworkException);\n  }\n\n}", "prediction": "    AnnotationMapper mapper = new AnnotationMapper();\n    assertNotNull(mapper);\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "1556938_0", "part": [1, 1], "seq": [1, 1], "prompt": "class Erector {\n\n\tpublic BlueprintTemplate getTemplate() {\n\t\treturn blueprintTemplate;\n\t}\n\n\tpublic  Erector();\n\n\tpublic Object createNewInstance();\n\tpublic void addCommands(ModelField modelField, Set<Command> commands);\n\tpublic void addCommand( ModelField modelField, Command command );\n\tpublic Set<Command> getCommands( ModelField modelField );\n\tpublic void clearCommands();\n\tpublic Object getBlueprint();\n\tpublic void setBlueprint(Object blueprint);\n\tpublic Collection<ModelField> getModelFields();\n\tpublic ModelField getModelField(String name);\n\tpublic void setModelFields(Collection<ModelField> modelFields);\n\tpublic void addModelField(ModelField modelField);\n\tpublic void setTemplate(BlueprintTemplate blueprintTemplate);\n\tpublic Class getTarget();\n\tpublic void setTarget(Class target);\n\tpublic Object getReference();\n\tpublic void setReference(Object reference);\n\tpublic Constructable getNewInstance();\n\tpublic void setNewInstance(Constructable newInstance);\n\tpublic void setCallbacks(String type, List<Callback> callbacks);\n\tpublic List<Callback> getCallbacks(String type);\n\tpublic String toString();\n\n    public Erector erector;\n    public DefaultField defaultField;\n    public CarBlueprint carBlueprint;\n\n}\n\nclass ErectorTest {\n\n    public Erector erector;\n    public DefaultField defaultField;\n    public CarBlueprint carBlueprint;\n\n    @Test\n    public void testGet() throws BlueprintTemplateException {\n", "reference": "        Car car = new Car();\n        car.setMileage(new Float(123.456));\n        Float val = (Float) erector.getTemplate().get(car, \"mileage\");\n        assertEquals(new Float(123.456), val);\n    }\n\n}", "prediction": "        erector.getTemplate();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "1579610_0", "part": [1, 1], "seq": [1, 1], "prompt": "class ComponentBundlerUtil {\n\n    public static Map<String, TileSet> parseActionTileSets (File file)\n        throws IOException, SAXException\n    {\n        return parseActionTileSets(new BufferedInputStream(new FileInputStream(file)));\n    }\n\n    public static Map<String, TileSet> parseActionTileSets(InputStream in);\n    protected static void addTileSetRuleSet(Digester digester, TileSetRuleSet ruleSet);\n\n    protected static final String ACTION_DATA;\n\n}\n\nclass ComponentBundlerUtilTest {\n\n    protected static final String ACTION_DATA;\n\n    @Test\n    public void testParseActionTileSets ()\n        throws Exception\n    {\n", "reference": "        Map<String, TileSet> map = ComponentBundlerUtil.parseActionTileSets(\n            new ByteArrayInputStream(ACTION_DATA.getBytes()));\n\n        SwissArmyTileSet defset = (SwissArmyTileSet)map.get(\"default\");\n        assertNotNull(defset);\n        assertEquals(\"default\", defset.getName());\n        assertEquals(1, defset.getTileCount());\n        assertArrayEquals(new int[] { 1 }, defset.getTileCounts());\n        assertEquals(new Rectangle(0, 0, 540, 640), defset.computeTileBounds(0, new Rectangle()));\n\n        SwissArmyTileSet statset = (SwissArmyTileSet)map.get(\"static\");\n        assertNotNull(statset);\n        assertEquals(\"static\", statset.getName());\n        assertEquals(1, statset.getTileCount());\n        assertArrayEquals(new int[] { 1 }, statset.getTileCounts());\n        assertEquals(new Rectangle(0, 0, 312, 240), statset.computeTileBounds(0, new Rectangle()));\n    }\n\n}", "prediction": "        Map<String, TileSet> tileSets = ComponentBundlerUtil.parseActionTileSets(\n            new ByteArrayInputStream(ACTION_DATA.getBytes()));\n        assertEquals(2, tileSets.size());\n        assertTrue(tileSets.containsKey(\"tile1\"));\n        assertTrue(tileSets.containsKey(\"tile2\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "1601209_87", "part": [1, 1], "seq": [1, 1], "prompt": "class GsonObjectMapper implements ObjectMapper {\n\n    @Override\n    public String writeValue(Object value) {\n        return om.toJson(value);\n    }\n\n    public  GsonObjectMapper();\n    public  GsonObjectMapper(Gson om);\n\n    @Override public T readValue(String value, Class<T> valueType);\n    @Override public T readValue(String value, GenericType<T> genericType);\n\n    private GsonObjectMapper om;\n\n}\n\nclass GsonObjectMapperTest {\n\n    private GsonObjectMapper om;\n\n    @Test\n    public void canWrite() throws Exception {\n", "reference": "        TestMe test = new TestMe(\"foo\", 42, new TestMe(\"bar\", 666, null));\n\n        String json = om.writeValue(test);\n\n        JSONAssert.assertEquals(\n                \"{\\\"text\\\":\\\"foo\\\",\\\"nmbr\\\":42,\\\"another\\\":{\\\"text\\\":\\\"bar\\\",\\\"nmbr\\\":666}}\"\n                , json\n                , true\n        );\n    }\n\n}", "prediction": "        String json = om.writeValue(new TestObject(\"test\"));\n        assertThat(json).isEqualTo(\"{\\\"name\\\":\\\"test\\\"}\");\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "1603277_6", "part": [1, 1], "seq": [1, 1], "prompt": "class PaginationBuilderService {\n\n    public Map<String, Object> buildPages(\n            Integer selectedPage,\n            int totalPages,\n            int depthSize\n    ){\n\n\n        logger.trace(\"Map<String,Object> buildPages(selectedPage= {},totalPages={},depthSize={})\",new Object[]{selectedPage,totalPages,depthSize});\n        Map<String,Object> pagination = new HashMap<String, Object>();\n\n\n        // depthSize*2 = Left an right number of pages\n        // +1 The selected page\n        //protect the return size\n        int returnSize = Math.min(((depthSize*2)+1),totalPages);\n\n        Integer[] pages = new Integer[returnSize];\n\n        /*\n          * If the selected page is less that the depthSize,\n          * there is no need to scroll the bottom results\n         */\n        if(selectedPage <= depthSize+1){\n            logger.trace(\"Map<String,Object> buildPages(pages) Keeping to left side no need to scroll \");\n            //no need to scroll the results\n            for(int i =1; i <= returnSize ; i++){\n                pages[i-1]=i;\n            }\n        }else if( selectedPage > totalPages - (depthSize*2)){\n\n            logger.trace(\"Map<String,Object> buildPages(pages) Working from right <- left, not enough spaces on the right {}\",returnSize);\n\n            //from right to left\n            for(int i =0 ; i < returnSize; i++){\n                pages[i] = (totalPages-returnSize+1)+i;\n            }\n\n\n        }else{\n            //it is in the middle\n            //get the previous four numbers and the next four numbers\n\n            pages[depthSize]=selectedPage;\n            for(int i=0; i< depthSize; i++){\n\n                pages[i]= selectedPage-(depthSize-i);\n                pages[depthSize+1+i] = selectedPage+1+i;\n            }\n\n\n\n        }\n\n\n        pagination.put(\"first\",1);\n        pagination.put(\"pages\",pages);\n        pagination.put(\"last\",totalPages);\n        pagination.put(\"selected\",selectedPage);\n\n        return pagination;\n    }\n\n    private Logger logger;\n    private PaginationBuilderService paginationBuilderService;\n\n}\n\nclass PaginationBuilderServiceTest {\n\n    private Logger logger;\n    private PaginationBuilderService paginationBuilderService;\n\n    @Test\n    public void testProductionCase(){\n", "reference": "\n        Map<String,Object> stringObjectMap = paginationBuilderService.buildPages(19, 166, 4);\n\n        Integer[] pages = (Integer[]) stringObjectMap.get(\"pages\");\n        Integer selected = (Integer) stringObjectMap.get(\"selected\");\n\n\n        Assert.assertEquals(19,selected, 0);\n        Assert.assertEquals(9, pages.length);\n\n        testPages(pages,\n                new Integer[]{\n                      15,16,17,18,19,20,21,22,23\n                });\n\n    }\n\n}", "prediction": "\n        Map<String,Object> pagination = paginationBuilderService.buildPages(1,10,5);\n        assertEquals(1,pagination.get(\"first\"));\n        assertEquals(10,pagination.get(\"last\"));\n        assertEquals(1,pagination.get(\"selected\"));\n        assertEquals(1,((Integer[])pagination.get(\"pages\"))[0]);\n        assertEquals(2,((Integer[])pagination.get(\"pages\"))[1]);\n        assertEquals(3,((Integer[])pagination.get(\"pages\"))[2]);\n        assertEquals(4,((Integer[])pagination.get(\"pages\"))[3]);\n        assertEquals(5,((Integer[])pagination.get(\"pages\"))[4]);\n        assertEquals(6,((Integer[])pagination.get(\"pages\"))[5]);\n        assertEquals(7,((Integer[])pagination.get(\"pages\"))[6]);\n        assertEquals(8,((Integer[])pagination.get(\"pages\"))[7]);\n        assertEquals(9,((Integer[])pagination.get(\"pages\"))[8]);\n        assertEquals(10,((Integer[])pagination.get(\"pages\"))[9]);\n\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "1767898_29", "part": [1, 1], "seq": [1, 1], "prompt": "class CompanyTemplate extends AbstractTemplate implements CompanyOperations {\n\n\tpublic Company getCompany(int id) {\n\t\treturn restOperations.getForObject(COMPANY_URL, Company.class, \"/\" + id, \"\");\n\t}\n\n\tpublic  CompanyTemplate(RestOperations RestOperations, ObjectMapper objectMapper);\n\n\tpublic Company getCompanyByUniversalName(String name);\n\tpublic List<Company> getCompaniesByEmailDomain(String domain);\n\tpublic Companies search(String keywords);\n\tpublic List<Company> getFollowing();\n\tpublic List<Company> getSuggestionsToFollow();\n\tpublic void startFollowingCompany(int id);\n\tpublic void stopFollowingCompany(int id);\n\tpublic Products getProducts(int companyId, int start, int count);\n\n}\n\nclass CompanyTemplateTest extends AbstractTemplate {\n\n\t@Test\n\t@Ignore(\"Ignoring to get a quick snapshot build out...fix later\")\n\tpublic void getCompany() {\n", "reference": "\t\tmockServer.expect(requestTo(CompanyTemplate.COMPANY_URL.replaceFirst(\"\\\\{id\\\\}\", \"/1337\").replaceFirst(\"\\\\{filter\\\\}\", \"\") + \"&oauth2_access_token=ACCESS_TOKEN\")).andExpect(method(GET))\n\t\t\t.andRespond(withSuccess(new ClassPathResource(\"company.json\", getClass()), MediaType.APPLICATION_JSON));\n\t\tCompany company = linkedIn.companyOperations().getCompany(1337);\n\t\t\n\t\tassertEquals(1337, company.getId());\n\t\tassertEquals(\"https://feeds.feedburner.com/LinkedInBlog\", company.getBlogRssUrl());\n\t\tassertEquals(\"C\", company.getCompanyType().getCode());\n\t\tassertEquals(\"Public Company\", company.getCompanyType().getName());\n\t\tassertEquals(\"LinkedIn takes your professional network online, giving you access to people, jobs and opportunities like never before. Built upon trusted connections and relationships, LinkedIn has established the world\\u2019s largest and most powerful professional network. Currently, more than 135 million professionals are on LinkedIn, including executives from all five hundred of the Fortune 500 companies, as well as a wide range of household names in technology, financial services, media, consumer packaged goods, entertainment, and numerous other industries. The company is publicly held and has a diversified business model with revenues coming from user subscriptions, advertising sales and hiring solutions.\", company.getDescription());\n\t\tassertEquals(1, company.getEmailDomains().size());\n\t\tassertEquals(\"linkedin.com\", company.getEmailDomains().get(0));\n\t\tassertEquals(\"G\", company.getEmployeeCountRange().getCode());\n\t\tassertEquals(\"1001-5000\", company.getEmployeeCountRange().getName());\n\t\tassertEquals(2003, company.getFoundedYear());\n\t\tassertEquals(\"Internet\", company.getIndustry());\n\t\tassertEquals(5, company.getLocations().size());\n\t\tassertEquals(\"Mountain View\", company.getLocations().get(0).getAddress().getCity());\n\t\tassertEquals(\"94043\", company.getLocations().get(0).getAddress().getPostalCode());\n\t\tassertEquals(\"2029 Stierlin Court\", company.getLocations().get(0).getAddress().getStreet1());\n\t\tassertEquals(\"(402) 452-2320\", company.getLocations().get(1).getContactInfo().getPhone1());\n\t\tassertEquals(\"https://media.linkedin.com/mpr/mpr/p/3/000/0c2/1d7/1894403.png\", company.getLogoUrl());\n\t\tassertEquals(\"LinkedIn\", company.getName());\n\t\tassertEquals(90110, company.getNumFollowers());\n\t\tassertEquals(8, company.getSpecialties().size());\n\t\tassertEquals(\"Online Professional Network\", company.getSpecialties().get(0));\n\t\tassertEquals(\"https://media.linkedin.com/mpr/mpr/p/2/000/0fe/1b9/26acf51.png\", company.getSquareLogoUrl());\n\t\tassertEquals(\"OPR\", company.getStatus().getCode());\n\t\tassertEquals(\"Operating\", company.getStatus().getName());\n\t\tassertEquals(\"NYS\", company.getStockExchange().getCode());\n\t\tassertEquals(\"New York Stock Exchange\", company.getStockExchange().getName());\n\t\tassertEquals(\"LNKD\", company.getTicker());\n\t\tassertEquals(\"linkedin\", company.getTwitterId());\n\t\tassertEquals(\"linkedin\", company.getUniversalName());\n\t\tassertEquals(\"https://www.linkedin.com\", company.getWebsiteUrl());\n\t}\n\n}", "prediction": "\n\t\tCompany company = companyOperations.getCompany(1);\n \n\t\tassertNotNull(company);\n\t\tassertEquals(1, company.getId());\n\t\tassertEquals(\"Apple\", company.getName());\n\t\tassertEquals(\"http://www.apple.com\", company.getUrl());\n\t\tassertEquals(\"http://www.apple.com/favicon.ico\", company.getFaviconUrl());\n\t\tassertEquals(\"http://www.apple.com/favicon.ico\", company.getFaviconUrl());\n\t\tassertEquals(\"http://www.apple.com/favicon.ico\", company.getFaviconUrl());\n\t\tassertEquals(\"http://www.apple.com/favicon.ico\", company.getFaviconUrl());\n\t\tassertEquals(\"http://www.apple.com/favicon.ico\", company.getFaviconUrl());\n\t\tassertEquals(\"http://www.apple.com/favicon.ico\", company.getFaviconUrl());\n\t\tassertEquals(\"http://www.apple.com/favicon.ico\", company.getFaviconUrl());\n\t\tassertEquals(\"http://www.apple.com/favicon.ico\", company.getFaviconUrl());\n\t\tassertEquals(\"http://www.apple.com/favicon.ico\", company.getFaviconUrl());\n\t\tassertEquals(\"http://www.apple.com/favicon.ico\", company.getFaviconUrl());\n\t\tassertEquals(\"http://www.apple.com/favicon.ico\", company.getFaviconUrl());\n\t\tassertEquals(\"http://www.apple.com/favicon.ico\", company.getFaviconUrl());\n\t\tassertEquals(\"http://www.apple.com/favicon.ico\", company.getFaviconUrl());\n\t\tassertEquals(\"http://www.apple.com/favicon.ico\", company.getFaviconUrl());\n\t\tassertEquals(\"http://www.apple.com/favicon.ico\", company.getFaviconUrl());\n\t\tassertEquals(\"http://www.apple.com/favicon.ico\", company.getFaviconUrl());\n\t\tassertEquals(\"http://www.apple.com/favicon.ico\", company.getFaviconUrl());\n\t\tassertEquals(\"http://www.apple.com/favicon.ico\", company.getFaviconUrl());\n\t\tassertEquals(\"http://www.apple.com/favicon.ico\", company.getFaviconUrl());\n\t\tassertEquals(\"http://www.apple.com/favicon.ico\", company.getFaviconUrl());\n\t\tassertEquals(\"http://www.apple.com/favicon.ico\", company.getFaviconUrl());\n\t\tassertEquals(\"http://www.apple.com/favicon.ico\", company.getFaviconUrl());\n\t\tassertEquals(\"http://www.apple.com/favicon.ico\", company.getFaviconUrl());\n\t\tassertEquals(\"http://www.apple.com/favicon.ico\", company.getFaviconUrl());\n\t\tassertEquals(\"http://www.apple.com/favicon.ico\", company.getFaviconUrl());\n\t\tassertEquals(\"http://www.apple.com/favicon.ico\", company.getFaviconUrl());\n\t\tassertEquals(\"http://www.apple.com/favicon.ico\", company.getFaviconUrl());\n\t\tassertEquals(\"http://www.apple.com/favicon.ico\", company.getFaviconUrl());\n\t\tassertEquals(\"http://www.apple.com/favicon.ico\", company.getFaviconUrl());\n\t\tassertEquals(\"http://www.apple.com/favicon.ico\", company.getFaviconUrl());\n\t\tassertEquals(\"http://www.apple.com/favicon.ico\", company.getFaviconUrl());\n\t\tassertEquals(\"http://www.apple.com/favicon.ico\", company.getFaviconUrl());\n\t\tassertEquals(\"http://www.apple.com/favicon", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "1830414_3", "part": [1, 1], "seq": [1, 1], "prompt": "class I18n {\n\n\tpublic String getString(Locale locale, String key) {\n\t\ttry {\n\t\t\tif (locale == null)\n\t\t\t\treturn getString(key);\n\t\t\treturn getResourceBundle(locale).getString(key);\n\t\t} catch (Throwable e) {\n\t\t\treturn key;\n\t\t}\n\t}\n\n\tpublic  I18n();\n\tpublic  I18n(String bundle);\n\n\tpublic void setConfiguration(\n\t\t\torg.gofleet.configuration.Configuration configuration);\n\tpublic String getString(String key);\n\tpublic String getString(Locale locale, String key, Object... params);\n\tprivate ResourceBundle getResourceBundle(Locale locale);\n\n}\n\nclass I18nTest {\n\n\t@Test\n\tpublic void testGetStringLocaleString() {\n", "reference": "\t\tfinal String path = \"resourceBundles/i18n_string\";\n\t\t\n\t\tI18n i18n = new I18n(path);\n\t\t\n\t\tassertEquals(\"Esto es el valor 1\", i18n.getString(new Locale(\"es\", \"ES\"), \"value1\"));\n\t\tassertEquals(\"Esto es el valor 2\", i18n.getString(new Locale(\"es\", \"ES\"), \"value2\"));\n\t\tassertEquals(\"Esto es el valor 3\",i18n.getString(new Locale(\"es\", \"ES\"), \"value 3\"));\n\n\t\tassertEquals(\"This is value 1\", i18n.getString(\"value1\"));\n\t\tassertEquals(\"This is value 2\",i18n.getString(\"value2\"));\n\t\tassertEquals(\"This is value 3\", i18n.getString(\"value 3\"));\n\t}\n\n}", "prediction": "\t\tI18n i18n = new I18n();\n\t\tassertEquals(\"test\", i18n.getString(Locale.ENGLISH, \"test\"));\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "1889544_26", "part": [1, 1], "seq": [1, 1], "prompt": "class TypeUtils {\n\n    public static short castToShort(@Nonnull Object value) {\n        requireNonNull(value, ERROR_VALUE_NULL);\n        if (value instanceof Number) {\n            return ((Number) value).shortValue();\n        }\n        return Short.valueOf(String.valueOf(value));\n    }\n\n    private  TypeUtils();\n\n    public static boolean castToBoolean(@Nonnull Object value);\n    public static char castToChar(@Nonnull Object value);\n    public static byte castToByte(@Nonnull Object value);\n    public static int castToInt(@Nonnull Object value);\n    public static long castToLong(@Nonnull Object value);\n    public static float castToFloat(@Nonnull Object value);\n    public static double castToDouble(@Nonnull Object value);\n    public static BigInteger castToBigInteger(@Nonnull Object value);\n    public static BigDecimal castToBigDecimal(@Nonnull Object value);\n    @Nullable public static Number castToNumber(@Nonnull Object value);\n    public static boolean castToBoolean(@Nullable Object value, boolean defaultValue);\n    public static char castToChar(@Nullable Object value, char defaultValue);\n    public static byte castToByte(@Nullable Object value, byte defaultValue);\n    public static short castToShort(@Nullable Object value, short defaultValue);\n    public static int castToInt(@Nullable Object value, int defaultValue);\n    public static long castToLong(@Nullable Object value, long defaultValue);\n    public static float castToFloat(@Nullable Object value, float defaultValue);\n    public static double castToDouble(@Nullable Object value, double defaultValue);\n    @Nullable public static Number castToNumber(@Nullable Object value, @Nullable Number defaultValue);\n    @Nullable public static BigInteger castToBigInteger(@Nullable Object value, @Nullable BigInteger defaultValue);\n    @Nullable public static BigDecimal castToBigDecimal(@Nullable Object value, @Nullable BigDecimal defaultValue);\n    @Nonnull public static T convertValue(@Nonnull Class<T> targetType, @Nonnull Object value);\n    @Nonnull @SuppressWarnings(\"unchecked\") public static T convertValue(@Nonnull Class<T> targetType, @Nonnull Object value, @Nullable String format);\n    public static boolean isBoolean(@Nonnull Class<?> type);\n    public static boolean isCharacter(@Nonnull Class<?> type);\n    public static boolean isByte(@Nonnull Class<?> type);\n    public static boolean isShort(@Nonnull Class<?> type);\n    public static boolean isInteger(@Nonnull Class<?> type);\n    public static boolean isLong(@Nonnull Class<?> type);\n    public static boolean isFloat(@Nonnull Class<?> type);\n    public static boolean isDouble(@Nonnull Class<?> type);\n    public static boolean isBigInteger(@Nonnull Class<?> type);\n    public static boolean isBigDecimal(@Nonnull Class<?> type);\n    public static boolean isNumber(@Nonnull Class<?> type);\n    public static boolean equals(@Nullable Object left, @Nullable Object right);\n    public static boolean arrayEqual(@Nullable Object left, @Nullable Object right);\n    public static boolean equals(int[] left, int[] right);\n    public static boolean equals(Object[] left, List right);\n    public static boolean equals(List left, Object[] right);\n    private static boolean doEquals(Object[] left, List<?> right);\n    public static boolean equals(List<T> left, List<T> right);\n    public static boolean equals(Set<T> left, Set<T> right);\n    public static boolean equals(Map<K, V> left, Map<K, V> right);\n    public static List primitiveArrayToList(Object array);\n    private static boolean isValidCharacterString(Object value);\n    @SuppressWarnings(\"unchecked\") public static int compareTo(Object left, Object right);\n    public static int compareTo(Character left, Number right);\n    public static int compareTo(Number left, Character right);\n    public static int compareTo(Character left, Character right);\n    public static int compareTo(Number left, Number right);\n    public static boolean isFloatingPoint(Number number);\n    public static boolean isInteger(Number number);\n    public static boolean isLong(Number number);\n    public static boolean isBigDecimal(Number number);\n    public static boolean isBigInteger(Number number);\n\n}\n\nclass TypeUtilsTest {\n\n    @Test\n    public void castToShort() {\n", "reference": "        assertEquals((short) 10, TypeUtils.castToShort(Short.valueOf(\"10\")));\n        assertEquals((short) 10, TypeUtils.castToShort(Integer.valueOf(\"10\")));\n        assertEquals((short) 10, TypeUtils.castToShort(\"10\"));\n        assertEquals((short) 10, TypeUtils.castToShort(\"10\", (short) 10));\n        assertEquals((short) 10, TypeUtils.castToShort(null, (short) 10));\n    }\n\n}", "prediction": "        assertEquals(Short.valueOf(\"1\"), TypeUtils.castToShort(\"1\"));\n        assertEquals(Short.valueOf(\"1\"), TypeUtils.castToShort(1));\n        assertEquals(Short.valueOf(\"1\"), TypeUtils.castToShort(1L));\n        assertEquals(Short.valueOf(\"1\"), TypeUtils.castToShort(1.0F));\n        assertEquals(Short.valueOf(\"1\"), TypeUtils.castToShort(1.0));\n        assertEquals(Short.valueOf(\"1\"), TypeUtils.castToShort(BigInteger.ONE));\n        assertEquals(Short.valueOf(\"1\"), TypeUtils.castToShort(BigDecimal.ONE));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "1906557_2", "part": [1, 1], "seq": [1, 1], "prompt": "class ExtremeStartup {\n\n    public String answer(String question) {\n        if (question == null)\n            return teamName;\n        Matcher sumMatcher = Pattern.compile(\".*what is the sum of (\\\\d+) and (\\\\d+)\").matcher(question);\n        if (sumMatcher.matches()) {\n            return String.valueOf(Integer.parseInt(sumMatcher.group(1)) + Integer.parseInt(sumMatcher.group(2)));\n        }\n        return teamName;\n    }\n\n    public  ExtremeStartup(String teamName);\n\n    public static void main(String[] args);\n\n    private final ExtremeStartup server;\n\n}\n\nclass ExtremeStartupTest {\n\n    private final ExtremeStartup server;\n\n    @Test\n    public void should_add_numbers() {\n", "reference": "        assertEquals(server.answer(\"what is the sum of 4 and 12\"), \"16\");\n    }\n\n}", "prediction": "        assertEquals(\"10\", server.answer(\"what is the sum of 5 and 5\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "2119234_0", "part": [1, 1], "seq": [1, 1], "prompt": "class Notification {\n\n\tpublic void newMessage(String app, String user, String level, String text) {\n\t\ttry {\n\t\t\tconn = DBusConnection.getConnection(DBusConnection.SYSTEM);\n\t\t\tMessageConnection c = (MessageConnection) conn.getRemoteObject(ServiceBusName, ObjectPath, MessageConnection.class);\n\t\t\tc.new_message(app, user, level, text);\n\t\t} catch(DBusException ex) {\n\t\t\tex.printStackTrace();\n\t\t}\n\t}\n\n}\n\nclass NotificationTest {\n\n\t@Test\n\tpublic void testNewMessage() {\n", "reference": "\t\tNotification n = new Notification();\n\t\tn.newMessage(\"appJava\",\"\",\"Some thing appened\", \"NOTICE\");\n\t\t\n\t}\n\n}", "prediction": "\t\tNotification n = new Notification();\n\t\tn.newMessage(\"app\", \"user\", \"info\", \"text\");\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "2155214_44", "part": [1, 1], "seq": [1, 1], "prompt": "class SimpleManagedResource extends AbstractManagedResource {\n\n   @Override\n   public Registration registerSubResource(String name, ManagedDescription description)\n   {\n      if (name == null) throw new IllegalArgumentException(\"name is null\");\n      if (description == null) throw new IllegalArgumentException(\"description is null\");\n\n      if (name.charAt(0) == '/') name = name.substring(1, name.length());\n\n      PathElement element;\n      try\n      {\n         element = PathElement.pathElement(name);\n      }\n      catch (PatternSyntaxException e)\n      {\n         throw new ManagementException(\"Could not parse path template \" + name, e);\n      }\n\n      SimpleManagedResource resource = new SimpleManagedResource(element, this, description);\n      if (children.putIfAbsent(element.getValue(), resource) != null)\n      {\n         throw new IllegalArgumentException(\"Resource \" + name + \" already exists for path \" + getPath());\n      }\n\n      return resource;\n   }\n\n   public  SimpleManagedResource(PathElement pathElement, AbstractManagedResource parent, ManagedDescription description);\n\n   @Override public void registerOperationHandler(String operationName, OperationHandler operationHandler, ManagedDescription description);\n   @Override public void registerOperationHandler(String operationName, OperationHandler operationHandler, ManagedDescription description, boolean inherited);\n   @Override protected ManagedDescription getResourceDescription(PathAddressIterator iterator);\n   @Override protected OperationEntry getOperationEntry(PathAddressIterator iterator, String operationName);\n   @Override protected void getOperationEntries(PathAddressIterator iterator, Map<String, OperationEntry> entries);\n   @Override protected AbstractManagedResource getSubResource(PathAddressIterator iterator);\n   @Override public ManagedResource getSubResource(String childName);\n   @Override protected Set<String> getChildNames(PathAddressIterator iterator);\n   private AbstractManagedResource findDescendant(PathAddressIterator iterator, String childName, StringBuilder path);\n   private AbstractManagedResource findMatch(PathAddressIterator iterator, final StringBuilder path);\n\n   private static final ManagedDescription ROOT_DESC;\n   private static final ManagedDescription A_DESC;\n   private static final ManagedDescription A_1_DESC;\n   private static final ManagedDescription A_1_1_DESC;\n   private static final ManagedDescription A_2_DESC;\n   private static final ManagedDescription B_DESC;\n   private static final ManagedDescription C_DESC;\n   private static final ManagedDescription C_1_DESC;\n   private static final ManagedDescription C_1_1_DESC;\n   private static final ManagedDescription WILDCARD_DESC;\n\n}\n\nclass SimpleManagedResourceTest {\n\n   private static final ManagedDescription ROOT_DESC;\n   private static final ManagedDescription A_DESC;\n   private static final ManagedDescription A_1_DESC;\n   private static final ManagedDescription A_1_1_DESC;\n   private static final ManagedDescription A_2_DESC;\n   private static final ManagedDescription B_DESC;\n   private static final ManagedDescription C_DESC;\n   private static final ManagedDescription C_1_DESC;\n   private static final ManagedDescription C_1_1_DESC;\n   private static final ManagedDescription WILDCARD_DESC;\n\n   @Test\n   public void testLocationString()\n   {\n", "reference": "      SimpleManagedResource root = createRootResource();\n\n      SimpleManagedResource a = (SimpleManagedResource) root.registerSubResource(\"a\", A_DESC);\n      SimpleManagedResource a_1 = (SimpleManagedResource) a.registerSubResource(\"a-1\", A_1_DESC);\n      SimpleManagedResource a_1_1 = (SimpleManagedResource) a_1.registerSubResource(\"a-1-1\", A_1_1_DESC);\n\n      assertEquals(\"/a\", a.getPath());\n      assertEquals(\"/a/a-1\", a_1.getPath());\n      assertEquals(\"/a/a-1/a-1-1\", a_1_1.getPath());\n   }\n\n}", "prediction": "     SimpleManagedResource root = new SimpleManagedResource(PathElement.pathElement(\"root\"), null, ROOT_DESC);\n      SimpleManagedResource a = root.registerSubResource(\"a\", A_DESC);\n      SimpleManagedResource a1 = a.registerSubResource(\"a1\", A_1_DESC);\n      SimpleManagedResource a11 = a1.registerSubResource(\"a11\", A_1_1_DESC);\n      SimpleManagedResource a2 = a.registerSubResource(\"a2\", A_2_DESC);\n      SimpleManagedResource b = root.registerSubResource(\"b\", B_DESC);\n      SimpleManagedResource c = b.registerSubResource(\"c\", C_DESC);\n      SimpleManagedResource c1 = c.registerSubResource(\"c1\", C_1_DESC);\n      SimpleManagedResource c11 = c1.registerSubResource(\"c11\", C_1_1_DESC);\n\n      assertEquals(\"root\", root.getLocationString());\n      assertEquals(\"root/a\", a.getLocationString());\n      assertEquals(\"root/a/a1\", a1.getLocationString());\n      assertEquals(\"root/a/a1/a11\", a11.getLocationString());\n      assertEquals(\"root/a/a2\", a2.getLocationString());\n      assertEquals(\"root/b\", b.getLocationString());\n      assertEquals(\"root/b/c\", c.getLocationString());\n      assertEquals(\"root/b/c/c1\", c1.getLocationString());\n      assertEquals(\"root/b/c/c1/c11\", c11.getLocationString());\n   }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "2193717_3", "part": [1, 1], "seq": [1, 1], "prompt": "class ConvertObjectToClass implements Converter<Object, Class<?>> {\n\n    @Override\n    public Class<?> convert(final Object from) {\n        if (from == null) {\n            return null;\n        }\n        return from.getClass();\n    }\n\n}\n\nclass TestConvertObjectToClass {\n\n    @Test\n    public void objectIsConvertedToClass() throws Exception {\n", "reference": "        assertThat(new ConvertObjectToClass().convert(new ExampleClass()), equalTo((Object) ExampleClass.class));\n    }\n\n}", "prediction": "        final Object object = new Object();\n        final Class<?> result = new ConvertObjectToClass().convert(object);\n        assertThat(result, is(equalTo(Object.class)));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "2198510_161", "part": [1, 1], "seq": [1, 1], "prompt": "class BucketPath {\n\n  public static String escapeString(String in, Map<String, String> headers) {\n    return escapeString(in, headers, false, 0, 0);\n  }\n\n  @VisibleForTesting @Deprecated public static boolean containsTag(String in);\n  @VisibleForTesting @Deprecated public static String expandShorthand(char c);\n  @VisibleForTesting @Deprecated public static String replaceShorthand(char c, Map<String, String> headers);\n  @VisibleForTesting @Deprecated public static String replaceShorthand(char c, Map<String, String> headers,\n      boolean needRounding, int unit, int roundDown);\n  @VisibleForTesting @Deprecated public static String replaceShorthand(char c, Map<String, String> headers,\n      TimeZone timeZone, boolean needRounding, int unit, int roundDown,\n      boolean useLocalTimestamp);\n  protected static SimpleDateFormat getSimpleDateFormat(String string);\n  @VisibleForTesting protected static String replaceStaticString(String key);\n  @VisibleForTesting protected static String replaceShorthand(char c, Map<String, String> headers,\n      TimeZone timeZone, boolean needRounding, int unit, int roundDown,\n      boolean useLocalTimestamp, long ts);\n  private static long roundDown(int roundDown, int unit, long ts, TimeZone timeZone);\n  public static String escapeString(String in, Map<String, String> headers,\n      boolean needRounding, int unit, int roundDown);\n  public static String escapeString(String in, Map<String, String> headers,\n      TimeZone timeZone, boolean needRounding, int unit, int roundDown,\n      boolean useLocalTimeStamp);\n  @VisibleForTesting @Deprecated public static Map<String, String> getEscapeMapping(String in,\n      Map<String, String> headers);\n  @VisibleForTesting @Deprecated public static Map<String, String> getEscapeMapping(String in,\n      Map<String, String> headers, boolean needRounding,\n      int unit, int roundDown);\n  @VisibleForTesting public static void setClock(Clock clk);\n  @VisibleForTesting public static Clock getClock();\n\n  private static final TimeZone CUSTOM_TIMEZONE;\n  private Calendar cal;\n  private Map<String, String> headers;\n  private Map<String, String> headersWithTimeZone;\n\n}\n\nclass TestBucketPath {\n\n  private static final TimeZone CUSTOM_TIMEZONE;\n  private Calendar cal;\n  private Map<String, String> headers;\n  private Map<String, String> headersWithTimeZone;\n\n  @Test\n  public void testNoPadding() {\n", "reference": "    Calendar calender;\n    Map<String, String> calender_timestamp;\n    calender = Calendar.getInstance();\n\n    //Check single digit dates\n    calender.set(2014, (5 - 1), 3, 13, 46, 33);\n    calender_timestamp = new HashMap<String, String>();\n    calender_timestamp.put(\"timestamp\", String.valueOf(calender.getTimeInMillis()));\n    SimpleDateFormat format = new SimpleDateFormat(\"M-d\");\n    \n    String test = \"%n-%e\"; // eg 5-3\n    String escapedString = BucketPath.escapeString(\n        test, calender_timestamp, false, Calendar.HOUR_OF_DAY, 12);\n    Date d = new Date(calender.getTimeInMillis());\n    String expectedString = format.format(d);\n    \n    //Check two digit dates\n    calender.set(2014, (11 - 1), 13, 13, 46, 33);\n    calender_timestamp.put(\"timestamp\", String.valueOf(calender.getTimeInMillis()));\n    escapedString += \" \" + BucketPath.escapeString(\n        test, calender_timestamp, false, Calendar.HOUR_OF_DAY, 12);\n    System.out.println(\"Escaped String: \" + escapedString);\n    d = new Date(calender.getTimeInMillis());\n    expectedString += \" \" + format.format(d);\n    System.out.println(\"Expected String: \" + expectedString);\n    Assert.assertEquals(expectedString, escapedString);\n  }\n\n}", "prediction": "    assertEquals(\"2012-01-01\", BucketPath.escapeString(\"2012-01-01\", headers));\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "2329961_32", "part": [1, 1], "seq": [1, 1], "prompt": "class Flags {\n\n    public void printHelp(OutputStream out) {\n        PrintWriter w = new PrintWriter(out);\n\n        Map<String, List<OptionHolder>> holdersByClass = new TreeMap<String, List<OptionHolder>>();\n\n        // Iterate over all the options we have gathered and stash them by class.\n        for (OptionHolder holder : options.values()) {\n            // Fetch list corresponding to source class name\n            final String className;\n            if (holder.isInstanced()) {\n                className = holder.getObjectSource().getClass().getName();\n            } else {\n                className = holder.getClassSource().getName();\n            }\n            List<OptionHolder> holderList = holdersByClass.get(className);\n            if (null == holderList) {\n                // The list did not exist.  Create it.\n                holderList = new LinkedList<OptionHolder>();\n                holdersByClass.put(className, holderList);\n            }\n\n            holderList.add(holder);\n        }\n\n        // Output options by class\n        for (Map.Entry<String, List<OptionHolder>> ent : holdersByClass.entrySet()) {\n            String className = ent.getKey();\n            List<OptionHolder> holderList = ent.getValue();\n\n            // Sort the options. In Java, sorting collections is worse\n            // than watching Pandas fuck.\n            Collections.sort(holderList, new Comparator<OptionHolder>() {\n                @Override\n                public int compare(OptionHolder a, OptionHolder b) {\n                    return a.getFlag().name().toLowerCase().compareTo(b.getFlag().name().toLowerCase());\n                }\n            });\n\n            StringBuffer buff = new StringBuffer();\n\n            buff.append(\"\\n\\n\")\n            .append(className)\n            .append(\"\\n\")\n            .append(\"------------------------------------------------------------------------\")\n            .append(\"\\n\");\n\n            for (OptionHolder holder : holderList) {\n                // Mark required flags with a \"*\"\n                buff.append(holder.getFlag().required() ? \"* \" : \"  \");\n\n                String s;\n                try {\n                    s = \"  --\" + holder.getFlag().name() + \" <\" + holder.getType() + \"> default: \"\n                            + (holder.isInstanced()\n                                ? holder.getField().get(holder.getObjectSource())\n                                : holder.getField().get(holder.getClassSource()));\n                } catch (IllegalAccessException e) {\n                    throw new RuntimeException(e);\n                }\n\n                //TODO: handle enum options\n                if (holder.getFlag().options() != NoOption.class) {\n                    s = s + \" options: \"+enumOptions.get(holder.getFlag().options()).toString();\n                }\n\n                // Avert your eyes.\n                int spaces = 50 - s.length();\n                spaces = spaces < 0 ? 0 : spaces;\n                buff.append(s)\n                .append(\"  . . . . . . . . . . . . . . . . . . . . . . . . \".substring(0, spaces))\n                .append(\"| \" + holder.getFlag().description())\n                .append(\"\\n\");\n            }\n            w.println(buff.toString());\n        }\n        w.flush();\n    }\n\n    public Flags loadOpts(Class<?> c);\n    public Flags loadOpts(final Object o);\n    private Flags loadOpts(Object o, boolean instanced);\n    public void setVersionString(final String versionString);\n    public List<String> getNonOptionArguments();\n    private void addEnumOption(Class<? extends Enum<?>> enumClass, String validOption);\n    private void addOption(FieldType type, Flag flag, Field field, OptionSpec<?> option, Class<?> c);\n    private void addInstancedOption(FieldType type, Flag flag, Field field, OptionSpec<?> option, Object c);\n    public Flags parse(String[] args);\n    private void callPostConstructMethods();\n    private List<Method> findPostConstructMethod(final Class<?> type, final boolean instanced);\n    private void checkNoMethodArguments(final Method method);\n    public void printVersion(final OutputStream out);\n    public boolean helpFlagged();\n    public boolean versionFlagged();\n    public boolean propertiesFlagged();\n    public void printFlags();\n    private static FieldType fieldTypeOf(Field field, Flag flag);\n    public List<Flag> getFlagsAsList();\n\n    @Rule\n    public ExpectedException exception;\n    @Rule\n    public ExpectedException expectedException;\n\n}\n\nclass FlagsTest {\n\n    @Rule\n    public ExpectedException exception;\n    @Rule\n    public ExpectedException expectedException;\n\n    @Test\n    public void testPrintHelp() {\n", "reference": "        try {\n            Flags flags = new Flags()\n            .loadOpts(FlagsHelpTest.class);\n            flags.printHelp(System.out);\n        } catch (Exception e) {\n            assertFalse(\"Cought exception.\", true);\n        }\n    }\n\n}", "prediction": "        exception.expect(UnsupportedOperationException.class);\n        Flags flags = new Flags();\n        flags.printHelp(System.out);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "2408807_4", "part": [1, 1], "seq": [1, 1], "prompt": "class Math {\n\n    public int add(int a, int b) {\n    \treturn a + b + 0 + 0 + 0;\n    }\n\n    public int subtract(int a, int b);\n    public int multiply(int a, int b);\n    public int divide(int a, int b);\n\n\t Math math;\n\n}\n\nclass MathTest {\n\n\t Math math;\n\n\t@Test\n\tpublic void addTest() {\n", "reference": "\t\tSystem.out.println(\"@Test Inside addTest\");\n\t\t\n\t\tassertEquals(5 + 0 + 0, math.add(2, 3));\n\t}\n\n}", "prediction": "\t\tassertEquals(10, math.add(5, 5));\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "2424377_25", "part": [1, 1], "seq": [1, 1], "prompt": "class MatrixUtils {\n\n  public static int[] minInColumns(DoubleMatrix2D A, int[] indices, double[] minValues) {\n    return inColumns(A, indices, minValues, DoubleComparators.REVERSED_ORDER, Functions.IDENTITY);\n  }\n\n  public static DoubleMatrix2D normalizeColumnL2(DoubleMatrix2D A, double[] work);\n  public static DoubleMatrix2D normalizeSparseColumnL2(\n      final DoubleMatrix2D A, final double[] work);\n  public static DoubleMatrix2D normalizeColumnL1(DoubleMatrix2D A, double[] work);\n  private static double[] prepareWork(DoubleMatrix2D A, double[] work);\n  private static void normalizeColumns(DoubleMatrix2D A, double[] work);\n  public static double computeOrthogonality(DoubleMatrix2D A);\n  public static double computeSparseness(DoubleMatrix2D A);\n  public static int[] maxInColumns(DoubleMatrix2D A, int[] indices, double[] maxValues);\n  public static int[] maxInColumns(\n      DoubleMatrix2D A, int[] indices, double[] maxValues, DoubleFunction transform);\n  private static int[] inColumns(\n      DoubleMatrix2D A,\n      int[] indices,\n      double[] extValues,\n      DoubleComparator doubleComparator,\n      DoubleFunction transform);\n  public static int maxInRow(DoubleMatrix2D A, int row);\n  public static double[] sumRows(DoubleMatrix2D A, double[] sums);\n  public static double frobeniusNorm(DoubleMatrix2D matrix);\n  public static DoubleMatrix2D sortedRowsView(\n      DoubleMatrix2D matrix, IndirectComparator comparator);\n\n}\n\nclass MatrixUtilsTest  {\n\n  @Test\n  public void testMinInColumns() {\n", "reference": "    final double[] expectedMinValues = new double[] {-1.00, 0, 0.50, -7.00};\n\n    final int[] expectedMinIndices = new int[] {0, 0, 1, 2};\n\n    final double[] actualMinValues = new double[4];\n    final int[] actualMinColumnIndices =\n        MatrixUtils.minInColumns(nonZeroColumnMatrix(), null, actualMinValues);\n\n    assertThat(actualMinColumnIndices).isEqualTo(expectedMinIndices);\n    assertThat(actualMinValues).isEqualTo(expectedMinValues);\n  }\n\n}", "prediction": "    DoubleMatrix2D A = new DenseDoubleMatrix2D(new double[][] {{1, 2, 3}, {4, 5, 6}});\n    int[] indices = new int[] {0, 1};\n    double[] minValues = new double[] {1, 2};\n    int[] result = MatrixUtils.minInColumns(A, indices, minValues);\n    assertArrayEquals(new int[] {0, 1}, result);\n  }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "2480222_0", "part": [1, 1], "seq": [1, 1], "prompt": "class LogReadServiceImpl implements LogReadService {\n\n\t@Override\n\t@RemoteMethod\n\tpublic List<String> read_log(String log_name, int line) {\n\n\t\ttry {\n\t\t\tList<String> lines = Files.readLines(new File(log_folder + File.separator + log_name + \".txt\"), Charset.defaultCharset());\n\t\t\treturn lines.subList(line, lines.size());\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic void setLog_folder(String log_folder);\n\t@Override @RemoteMethod public String sayHello(String abc);\n\n}\n\nclass LogReadServiceImplTest {\n\n\t@Test\n\tpublic void testRead_log() throws Exception {\n", "reference": "\n\t\tLogReadServiceImpl logReadService = new LogReadServiceImpl();\n\t\tlogReadService.setLog_folder(\"/iflytek/temp\");\n\t\tList<String> contents = logReadService.read_log(\"jenkins-test\", 199000);\n\t\tSystem.out.println(contents.size());\n\t}\n\n}", "prediction": "\t\tLogReadServiceImpl impl = new LogReadServiceImpl();\n\t\timpl.setLog_folder(\"src/test/resources/log\");\n\t\tList<String> lines = impl.read_log(\"log.txt\", 0);\n\t\tassertEquals(lines.get(0), \"2014-01-01 00:00:00.000 INFO  - Hello World\");\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "2684727_358", "part": [1, 1], "seq": [1, 1], "prompt": "class CurrencyListEditorPresenter extends BasePresenter<CurrencyListEditorView> {\n\n    @Override\n    @CallSuper\n    public void subscribe() {\n        // A ConnectableObservable resembles an ordinary Observable, but it does not begin emitting until #connect is called\n        final ConnectableObservable<List<CharSequence>> currenciesConnectableObservable = Observable.fromCallable(this.databaseHelper::getCurrenciesList)\n                .subscribeOn(subscribeOnScheduler)\n                .observeOn(observeOnScheduler)\n                .publish();\n\n        // Display the full list of currencies\n        this.compositeDisposable.add(currenciesConnectableObservable\n                .subscribe(view.displayCurrencies()));\n\n        // Ensure we always restore the \"last\" currency\n        //noinspection Convert2MethodRef\n        this.compositeDisposable.add(currenciesConnectableObservable\n                .map(currenciesList -> {\n                    final String currencyCode;\n                    if (savedInstanceState != null && savedInstanceState.containsKey(OUT_STATE_SELECTED_CURRENCY_POSITION)) {\n                        currencyCode = currenciesList.get(savedInstanceState.getInt(OUT_STATE_SELECTED_CURRENCY_POSITION)).toString();\n                    } else if (lastSelectedCurrencyCodeIndex >= 0) {\n                        currencyCode = currenciesList.get(lastSelectedCurrencyCodeIndex).toString();\n                    } else {\n                        currencyCode = defaultCurrencyCodeSupplier.get();\n                    }\n\n                    final int currencyPosition = currenciesList.indexOf(currencyCode);\n                    if (currencyPosition >= 0) {\n                        return currencyPosition;\n                    } else {\n                        return 0;\n                    }\n                })\n                .subscribe(view.displayCurrencySelection()));\n\n        // Handle selections\n        this.compositeDisposable.add(currenciesConnectableObservable\n                    .flatMap(currenciesList -> {\n                        //noinspection ConstantConditions\n                        return view.currencyClicks()\n                                .filter(currencyIndex -> currencyIndex >= 0);\n                    })\n                    .doOnNext(currencyIndex -> lastSelectedCurrencyCodeIndex = currencyIndex)\n                    .subscribe(view.displayCurrencySelection()));\n\n        // Call #connect to start out emissions\n        this.compositeDisposable.add(currenciesConnectableObservable.connect());\n    }\n\n    public  CurrencyListEditorPresenter(@NonNull CurrencyListEditorView view,\n                                       @NonNull DatabaseHelper databaseHelper,\n                                       @NonNull CurrencyCodeSupplier defaultCurrencyCodeSupplier,\n                                       @Nullable Bundle savedInstanceState);\n    @VisibleForTesting  CurrencyListEditorPresenter(@NonNull CurrencyListEditorView view,\n                                @NonNull DatabaseHelper databaseHelper,\n                                @NonNull CurrencyCodeSupplier defaultCurrencyCodeSupplier,\n                                @Nullable Bundle savedInstanceState,\n                                @NonNull Scheduler subscribeOnScheduler,\n                                @NonNull Scheduler observeOnScheduler);\n\n    public void onSaveInstanceState(@NonNull Bundle outState);\n\n    private static final List<CharSequence> CURRENCIES;\n     CurrencyListEditorPresenter nullSavedStatePresenter;\n     CurrencyListEditorPresenter savedStatePresenter;\n    @Mock CurrencyListEditorView view;\n    @Mock DatabaseHelper database;\n    @Mock CurrencyCodeSupplier currencyCodeSupplier;\n    @Mock Consumer<List<CharSequence>> displayCurrenciesConsumer;\n    @Mock Consumer<Integer> displayCurrencySelectionConsumer;\n     PublishSubject<Integer> currencyClicks;\n     Bundle savedInstanceState;\n\n}\n\nclass CurrencyListEditorPresenterTest {\n\n    private static final List<CharSequence> CURRENCIES;\n     CurrencyListEditorPresenter nullSavedStatePresenter;\n     CurrencyListEditorPresenter savedStatePresenter;\n    @Mock CurrencyListEditorView view;\n    @Mock DatabaseHelper database;\n    @Mock CurrencyCodeSupplier currencyCodeSupplier;\n    @Mock Consumer<List<CharSequence>> displayCurrenciesConsumer;\n    @Mock Consumer<Integer> displayCurrencySelectionConsumer;\n     PublishSubject<Integer> currencyClicks;\n     Bundle savedInstanceState;\n\n    @Test\n    public void subscribeDisplaysCurrencySelectionNonNullStateWithoutExtra() throws Exception {\n", "reference": "        savedStatePresenter.subscribe();\n        verify(displayCurrencySelectionConsumer).accept(0);\n    }\n\n}", "prediction": "        savedInstanceState = null;\n\n        nullSavedStatePresenter.subscribe();\n\n        verify(view).displayCurrencySelection(0);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "2693213_5", "part": [1, 1], "seq": [1, 1], "prompt": "class SoapCallFactory {\n\n  @SuppressWarnings(\"unchecked\")\n  public OMElement createCall(String sessionId, String methodPath, Object arg) {\n    OMElement method = fac.createOMElement(CORE_CALL, mag);\n\n    // Register XML namespaces in method\n    method.declareNamespace(soapEnc);\n    method.declareNamespace(soapXml);\n    method.declareNamespace(xsi);\n    method.declareNamespace(xsd);\n\n    OMElement paramSession = fac.createOMElement(SESSION_ID, noNs);\n    paramSession.addChild(fac.createOMText(paramSession, sessionId));\n    method.addChild(paramSession);\n\n    OMElement resourcePath = fac.createOMElement(RESOURCE_PATH, noNs);\n    resourcePath.addChild(fac.createOMText(resourcePath, methodPath));\n    method.addChild(resourcePath);\n\n    OMElement paramArgs;\n    if (arg instanceof Iterable) {\n      Iterable<Object> args = (Iterable<Object>) arg;\n      paramArgs = fac.createOMElement(ARGUMENTS, noNs);\n      paramArgs.addAttribute(\"arrayType\", xsd.getPrefix() + \":ur-type[\" + Iterables.size(args) + \"]\", soapEnc);\n      paramArgs.addAttribute(\"type\", soapEnc.getPrefix() + \":Array\", xsi);\n\n      for (Object argument : args) {\n        paramArgs.addChild(typedElement(noNs, \"item\", argument));\n      }\n    } else if (arg instanceof Map) {\n      Map<String, Object> args = (Map<String, Object>) arg;\n      paramArgs = typedElement(noNs, ARGUMENTS, arg);\n      paramArgs.addAttribute(\"arrayType\", xsd.getPrefix() + \":Map[\" + args.size() + \"]\", soapEnc);\n      paramArgs.addAttribute(\"type\", soapEnc.getPrefix() + \":Array\", xsi);\n    } else if (arg != null && (arg.getClass().isArray() || arg.getClass().getName().equals(\"sun.org.mozilla.javascript.internal.NativeArray\"))) {\n      Object[] args = (Object[]) arg;\n      paramArgs = fac.createOMElement(ARGUMENTS, noNs);\n      paramArgs.addAttribute(\"arrayType\", xsd.getPrefix() + \":ur-type[\" + args.length + \"]\", soapEnc);\n      paramArgs.addAttribute(\"type\", soapEnc.getPrefix() + \":Array\", xsi);\n\n      for (Object argument : args) {\n        paramArgs.addChild(typedElement(noNs, \"item\", argument));\n      }\n    } else {\n      paramArgs = typedElement(noNs, ARGUMENTS, arg);\n    }\n    method.addChild(paramArgs);\n\n    return method;\n  }\n\n  public  SoapCallFactory(OMMetaFactory omMetaFactory);\n  public  SoapCallFactory();\n\n  public OMElement createLoginCall(String user, String password);\n  public OMElement createLogoutCall(String sessionId);\n  @SuppressWarnings(\"unchecked\") private OMElement typedElement(OMNamespace elementNs, String name, Object value);\n  private OMElement typedElement(OMNamespace elementNs, String name, String value, String valueType);\n  private OMElement keyValue(Object key, Object value);\n\n  private final static Logger log;\n  private SoapCallFactory soapCallFactory;\n\n}\n\nclass SoapCallFactoryTest {\n\n  private final static Logger log;\n  private SoapCallFactory soapCallFactory;\n\n  @Test\n  @Ignore(\"Assertion failing\")\n  public void createCallProductUpdatePrice() throws ScriptException {\n", "reference": "    ImmutableList<ProductUpdatePrice> products = ImmutableList.of(new ProductUpdatePrice(\"ajah_a\", new BigDecimal(500000), new BigDecimal(600000)),\n        new ProductUpdatePrice(\"zibalabel_b_06\", new BigDecimal(500000), new BigDecimal(600000)));\n    OMElement element = soapCallFactory.createCall(\"abc\", ResourcePath.ProductUpdatePrice.getPath(), new Object[] { products });\n    log.info(\"createCallProductUpdatePrice {}\", element);\n    assertNotNull(element);\n    assertEquals(1, Iterators.size(element.getChildElements()));\n  }\n\n}", "prediction": "    OMElement call = soapCallFactory.createCall(\"1234567890\", \"product/updatePrice\",\n        ImmutableMap.of(\"id\", \"1234567890\", \"price\", 1000));\n    assertThat(call.toStringWithConsume(), isSimilarTo(\n        \"<ns1:coreCall xmlns:ns1=\\\"http://www.w3.org/2003/05/soap-envelope\\\">\"\n            + \"<ns1:body>\"\n            + \"<ns2:sessionId xmlns:ns2=\\\"http://www.w3.org/2003/05/soap-envelope\\\">1234567890</ns2:sessionId>\"\n            + \"<ns2:resourcePath xmlns:ns2=\\\"http://www.w3.org/2003/05/soap-envelope\\\">product/updatePrice</ns2:resourcePath>\"\n            + \"<ns2:arguments xmlns:ns2=\\\"http://www.w3.org/2003/05/soap-envelope\\\" type=\\\"ns2:Array\\\" arrayType=\\\"ns2:ur-type[1]\\\">\"\n            + \"<item xsi:type=\\\"ns2:Map\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xmlns:ns2=\\\"http://www.w3.org/2003/05/soap-envelope\\\">\"\n            + \"<key xsi:type=\\\"xsd:string\\\">id</key>\"\n            + \"<value xsi:type=\\\"xsd:string\\\">1234567890</value>\"\n            + \"</item>\"\n            + \"<item xsi:type=\\\"ns2:Map\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xmlns:ns2=\\\"http://www.w3.org/2003/05/soap-envelope\\\">\"\n            + \"<key xsi:type=\\\"xsd:string\\\">price</key>\"\n            + \"<value xsi:type=\\\"xsd:double\\\">1000.0</value>\"\n            + \"</item>\"\n            + \"</ns2:arguments>\"\n            + \"</ns1:body>\"\n            + \"</ns1:coreCall>\"));\n  }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "2776400_0", "part": [1, 1], "seq": [1, 1], "prompt": "class HomePage extends Page {\n\n\tpublic String getH1() {\n\t\treturn h1Element.getText();\n\t}\n\n\tpublic  HomePage(WebDriver webDriver);\n\n\t HomePage homepage;\n\n}\n\nclass HomePageTest extends Page {\n\n\t HomePage homepage;\n\n\t@Test\n\tpublic void testH1Existing() throws InterruptedException {\n", "reference": "\t\tAssert.assertTrue(homepage.getH1() != null);\n\t}\n\n}", "prediction": "\t\thomepage.open();\n\t\tAssert.assertEquals(\"Welcome to the home page\", homepage.getH1());\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "2792886_1", "part": [1, 1], "seq": [1, 1], "prompt": "class Protected {\n\n  public static <J extends JsonDdlObject<J>> J object(J value) {\n    if (value instanceof JsonDdlObject.Builder) {\n      return ((JsonDdlObject.Builder<J>) value).build();\n    }\n    return value;\n  }\n\n  public static List<T> object(List<T> values);\n  public static Map<K, V> object(Map<K, V> values);\n  @SuppressWarnings(\"unchecked\") public static T object(T value);\n\n}\n\nclass ProtectedTest {\n\n  @Test\n  @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n", "reference": "  public void testJsonDdlObject() {\n    JsonDdlObject<?> obj = createStrictMock(JsonDdlObject.class);\n    JsonDdlObject.Builder builder = createStrictMock(JsonDdlObject.Builder.class);\n    expect(builder.build()).andReturn(obj).times(2);\n    replay(obj, builder);\n\n    assertSame(obj, Protected.object((Object) obj));\n    assertSame(obj, Protected.object((Object) builder));\n    assertSame(obj, Protected.object((JsonDdlObject) obj));\n    assertSame(obj, Protected.object((JsonDdlObject) builder));\n\n    verify(obj, builder);\n  }\n\n}", "prediction": " public void test() {\n     Protected.object(new ArrayList());\n  }\n\n}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "2911132_0", "part": [1, 1], "seq": [1, 1], "prompt": "class Splitter {\n\n\tpublic static List<String> getParts(String string, int partitionSize) {\n\t\tList<String> parts = new ArrayList<String>();\n\t\tint len = string.length();\n\t\tfor (int i = 0; i < len; i += partitionSize) {\n\t\t\tparts.add(string.substring(i, Math.min(len, i + partitionSize)));\n\t\t}\n\t\treturn parts;\n\t}\n\n}\n\nclass SplitterTest {\n\n\t@Test\n\tpublic void testGetParts() {\n", "reference": "\t\tString s = \"abcdefg\";\n\t\tList<String> parts = Splitter.getParts(s, 3);\n\n\t\tassertEquals(parts.get(0), \"abc\");\n\t\tassertEquals(parts.get(1), \"def\");\n\t\tassertEquals(parts.get(2), \"g\");\n\n\t}\n\n}", "prediction": "\t\tassertEquals(Arrays.asList(\"1234567890\", \"1234567890\", \"1234567890\"), Splitter.getParts(\"1234567890\", 10));\n\t\tassertEquals(Arrays.asList(\"1234567890\", \"1234567890\", \"1234567890\"), Splitter.getParts(\"1234567890\", 11));\n\t\tassertEquals(Arrays.asList(\"1234567890\", \"1234567890\", \"1234567890\"), Splitter.getParts(\"1234567890\", 12));\n\t\tassertEquals(Arrays.asList(\"1234567890\", \"1234567890\", \"1234567890\"), Splitter.getParts(\"1234567890\", 13));\n\t\tassertEquals(Arrays.asList(\"1234567890\", \"1234567890\", \"1234567890\"), Splitter.getParts(\"1234567890\", 14));\n\t\tassertEquals(Arrays.asList(\"1234567890\", \"1234567890\", \"1234567890\"), Splitter.getParts(\"1234567890\", 15));\n\t\tassertEquals(Arrays.asList(\"1234567890\", \"1234567890\", \"1234567890\"), Splitter.getParts(\"1234567890\", 16));\n\t\tassertEquals(Arrays.asList(\"1234567890\", \"1234567890\", \"1234567890\"), Splitter.getParts(\"1234567890\", 17));\n\t\tassertEquals(Arrays.asList(\"1234567890\", \"1234567890\", \"1234567890\"), Splitter.getParts(\"1234567890\", 18));\n\t\tassertEquals(Arrays.asList(\"1234567890\", \"1234567890\", \"1234567890\"), Splitter.getParts(\"1234567890\", 19));\n\t\tassertEquals(Arrays.asList(\"1234567890\", \"1234567890\", \"1234567890\"), Splitter.getParts(\"1234567890\", 20));\n\t\tassertEquals(Arrays.asList(\"1234567890\", \"1234567890\", \"1234567890\"), Splitter.getParts(\"1234567890\", 21));\n\t\tassertEquals(Arrays.asList(\"1234567890\", \"1234567890\", \"1234567890\"), Splitter.getParts(\"1234567890\", 22));\n\t\tassertEquals(Arrays.asList(\"1234567890\", \"1234567890\", \"1234567890\"), Splitter.getParts(\"1234567890\", 23));\n\t\tassertEquals(Arrays.asList(\"1234567890\", \"1234567890\", \"1234567890\"), Splitter.getParts(\"1234567890\", 24));\n\t\tassertEquals(Arrays.asList(\"1234567890\", \"1234567890\", \"1234567890\"), Splitter.getParts(\"1234567890\", 25));\n\t\tassertEquals(Arrays.asList(\"1234567890\", \"1234567890\", \"1234567890\"), Splitter.getParts(\"1234567890\", 26));\n\t\tassertEquals(Arrays.asList(\"1234567890\", \"1234567890\", \"1234567890\"), Splitter.getParts(\"1234567890\", 27));\n\t\tassertEquals(Arrays.asList(\"1234567890\", \"1234567890\", \"1234567890\"), Splitter.getParts(\"1234567890\", 28));\n\t\tassertEquals(Arrays.asList(\"1234567890\", \"1234567890\", \"1234567890\"), Splitter.getParts(\"1234567890\", 29));\n\t\tassertEquals(Arrays.asList(\"1234567890\", \"1234567890\", \"1234567890\"), Splitter.getParts(\"1234567890\", 30));\n\t\tassertEquals(Arrays.asList(\"1234567890\", \"1234567890\", \"1234567890\"), Splitter.getParts(\"1234567890\", 31));\n\t\tassertEquals(Arrays.asList(\"1234567890\", \"1234567890\", \"1234567890\"), Splitter.getParts(\"1234567890\", 32));\n\t\tassertEquals(Arrays.asList(\"1234567890\", \"1234567", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "2916228_22", "part": [1, 1], "seq": [1, 1], "prompt": "class Update extends Operation {\n\n\tpublic Update(Repository repository) {\n\t\tsuper(repository);\n\t}\n\n\tpublic  Update(Repository repository);\n\n\tpublic void now(Propoid propoid);\n\t@Override protected void beforeBind(Property<?> property, Mapper<?> mapper);\n\n\tprivate Repository repository;\n\n}\n\nclass UpdateTest {\n\n\tprivate Repository repository;\n\n\t@Test\n\tpublic void testFoo() throws Exception {\n", "reference": "\n\t\tFoo foo = repository.query(new Foo()).single();\n\n\t\trepository.update(foo);\n\n\t\tassertEquals(1, repository.query(new Foo()).count());\n\t\tassertEquals(0, repository.query(new Bar()).count());\n\t}\n\n}", "prediction": "\t\tUpdate update = new Update(repository);\n\t\tupdate.now(new Foo());\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "3005042_25", "part": [1, 1], "seq": [1, 1], "prompt": "class Pcaps {\n\n  public static String strError(int error) {\n    return NativeMappings.pcap_strerror(error).getString(0);\n  }\n\n  private  Pcaps();\n\n  public static List<PcapNetworkInterface> findAllDevs();\n  public static PcapNetworkInterface getDevByAddress(InetAddress addr);\n  public static PcapNetworkInterface getDevByName(String name);\n  public static String lookupDev();\n  public static Inet4NetworkAddress lookupNet(String devName);\n  public static PcapHandle openOffline(String filePath);\n  public static PcapHandle openOffline(String filePath, TimestampPrecision precision);\n  public static PcapHandle openDead(DataLinkType dlt, int snaplen);\n  public static PcapHandle openDead(DataLinkType dlt, int snaplen, TimestampPrecision precision);\n  public static BpfProgram compileFilter(\n      int snaplen,\n      DataLinkType dlt,\n      String bpfExpression,\n      BpfCompileMode mode,\n      Inet4Address netmask);\n  public static DataLinkType dataLinkNameToVal(String name);\n  public static String dataLinkTypeToName(DataLinkType dlt);\n  public static String dataLinkValToName(int dataLinkVal);\n  public static String dataLinkTypeToDescription(DataLinkType dlt);\n  public static String dataLinkValToDescription(int dataLinkVal);\n  public static String libVersion();\n  public static String toBpfString(InetAddress inetAddr);\n  public static String toBpfString(MacAddress macAddr);\n\n  private static final Logger logger;\n\n}\n\nclass PcapsTest {\n\n  private static final Logger logger;\n\n  @Test\n  public void testStrError() throws Exception {\n", "reference": "    String err = Pcaps.strError(1);\n    logger.info(\"err: \" + err);\n    assertNotNull(err);\n    assertFalse(err.length() == 0);\n  }\n\n}", "prediction": "    assertEquals(\"No such file or directory\", Pcaps.strError(1));\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "3052688_0", "part": [1, 1], "seq": [1, 1], "prompt": "class DateUtils {\n\n  public static Date yearStart() {\n    final GregorianCalendar calendar = new GregorianCalendar(US);\n    calendar.set(DAY_OF_YEAR, 1);\n    return calendar.getTime();\n  }\n\n  public static Date today();\n  public static Date yesterday();\n  public static Date addDays(final int days, final Calendar from);\n  public static Date addDays(final int days, final Date from);\n  public static Date addDays(final int days, final long from);\n  public static Date addMonths(final int months, final Calendar from);\n  public static Date addMonths(final int months, final Date from);\n  public static Date addMonths(final int months, final long from);\n  public static Date addYears(final int years, final Calendar from);\n  public static Date addYears(final int years, final Date from);\n  public static Date addYears(final int years, final long from);\n  public static Date addWeeks(final int weeks, final Calendar from);\n  public static Date addWeeks(final int weeks, final Date from);\n  public static Date addWeeks(final int weeks, final long from);\n  public static Date yearEnd();\n\n}\n\nclass DateUtilsTest {\n\n  @Test\n  public void yearStart() {\n", "reference": "    Date date = DateUtils.yearStart();\n    assertNotNull(date);\n    GregorianCalendar calendar = new GregorianCalendar();\n    calendar.setTime(date);\n    assertEquals(1, calendar.get(DAY_OF_YEAR));\n  }\n\n}", "prediction": "    final Date date = DateUtils.yearStart();\n    assertThat(date).isEqualTo(new GregorianCalendar(US).getTime());\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "3415463_22", "part": [1, 1], "seq": [1, 1], "prompt": "class JcrTemplate extends JcrAccessor implements JcrOperations {\n\n    @Override\n    public QueryResult query(final Node node) {\n\n        if (node == null)\n            throw new IllegalArgumentException(\"node can't be null\");\n\n        return execute(new JcrCallback<QueryResult>() {\n            /**\n             * @see JcrCallback#doInJcr(javax.jcr.Session)\n             */\n            @Override\n            public QueryResult doInJcr(Session session) throws RepositoryException {\n                boolean debug = LOG.isDebugEnabled();\n\n                // get query manager\n                QueryManager manager = session.getWorkspace().getQueryManager();\n                if (debug)\n                    LOG.debug(\"retrieved manager \" + manager);\n\n                Query query = manager.getQuery(node);\n                if (debug)\n                    LOG.debug(\"created query \" + query);\n\n                return query.execute();\n            }\n        }, true);\n    }\n\n    public  JcrTemplate();\n    public  JcrTemplate(SessionFactory sessionFactory);\n\n    @Override public T execute(JcrCallback<T> action, boolean exposeNativeSession);\n    @Override public T execute(JcrCallback<T> callback);\n    protected Session getSession();\n    @Override public void addLockToken(final String lock);\n    @Override public Object getAttribute(final String name);\n    @Override public String[] getAttributeNames();\n    @Override public ContentHandler getImportContentHandler(final String parentAbsPath, final int uuidBehavior);\n    @Override public Item getItem(final String absPath);\n    @Override public String[] getLockTokens();\n    @Override public String getNamespacePrefix(final String uri);\n    @Override public String[] getNamespacePrefixes();\n    @Override public String getNamespaceURI(final String prefix);\n    @Override @Deprecated public Node getNodeByUUID(final String uuid);\n    @Override public Node getNodeByIdentifier(final String id);\n    @Override public Node getRootNode();\n    @Override public String getUserID();\n    @Override public ValueFactory getValueFactory();\n    @Override public boolean hasPendingChanges();\n    @Override public void importXML(final String parentAbsPath, final InputStream in, final int uuidBehavior);\n    @Override public void refresh(final boolean keepChanges);\n    @Override public void removeLockToken(final String lt);\n    @Override public void rename(final Node node, final String newName);\n    @Override public void setNamespacePrefix(final String prefix, final String uri);\n    @Override public boolean isLive();\n    @Override public boolean itemExists(final String absPath);\n    @Override public void move(final String srcAbsPath, final String destAbsPath);\n    @Override public void save();\n    @Override public String dump(final Node node);\n    protected String dumpNode(Node node);\n    @Override public QueryResult query(final String statement);\n    @Override public QueryResult query(final String statement, final String language);\n    @Override public Map<String, QueryResult> query(final List<String> list);\n    @Override public Map<String, QueryResult> query(final List<String> list, final String language, final boolean ignoreErrors);\n    public boolean isAllowCreate();\n    public void setAllowCreate(boolean allowCreate);\n    protected Session createSessionProxy(Session session);\n    protected boolean isVersionable(Node node);\n    public boolean isExposeNativeSession();\n    public void setExposeNativeSession(boolean exposeNativeSession);\n\n    private SessionFactory sessionFactory;\n    private Repository repository;\n    private Session session;\n    private JcrTemplate jcrTemplate;\n\n}\n\nclass JcrTemplateTest {\n\n    private SessionFactory sessionFactory;\n    private Repository repository;\n    private Session session;\n    private JcrTemplate jcrTemplate;\n\n    @Test\n    public void testExecuteQuerySimple() throws RepositoryException {\n", "reference": "        try {\n            jcrTemplate.query((String) null);\n            fail(\"should have thrown exception\");\n        } catch (IllegalArgumentException e) {\n            // it's okay\n        }\n        // the rest of the test is covered by testExecuteQuery\n\n    }\n\n}", "prediction": "        QueryResult result = jcrTemplate.query(session.getRootNode());\n        assertNotNull(result);\n        assertEquals(1, result.getNodes().getSize());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "3458429_56", "part": [1, 1], "seq": [1, 1], "prompt": "class HpackContext {\n\n    public Entry get(HttpField field) {\n        Entry entry = fieldMap.get(field);\n        if (entry == null)\n            entry = STATIC_FIELD_MAP.get(field);\n        return entry;\n    }\n\n    public  HpackContext(int maxDynamicTableSize);\n\n    public void resize(int newMaxDynamicTableSize);\n    public Entry get(String name);\n    public Entry get(int index);\n    public Entry get(HttpHeader header);\n    public static Entry getStatic(HttpHeader header);\n    public Entry add(HttpField field);\n    public int size();\n    public int getDynamicTableSize();\n    public int getMaxDynamicTableSize();\n    public int index(Entry entry);\n    public static int staticIndex(HttpHeader header);\n    @Override public String toString();\n\n}\n\nclass HpackContextTest {\n\n    @Test\n    void testStaticHuffmanValues() throws Exception {\n", "reference": "        HpackContext ctx = new HpackContext(4096);\n        for (int i = 2; i <= 14; i++) {\n            Entry entry = ctx.get(i);\n            assertTrue(entry.isStatic());\n\n            ByteBuffer buffer = ByteBuffer.wrap(entry.getStaticHuffmanValue());\n            int huff = 0xff & buffer.get();\n            assertEquals(0x80, (0x80 & huff));\n\n            int len = NBitInteger.decode(buffer, 7);\n\n            assertEquals(len, buffer.remaining());\n            String value = Huffman.decode(buffer);\n\n            assertEquals(entry.getHttpField().getValue(), value);\n\n        }\n    }\n\n}", "prediction": "        HpackContext context = new HpackContext(1024);\n        assertEquals(0, context.getDynamicTableSize());\n        assertEquals(0, context.size());\n        assertEquals(0, context.getMaxDynamicTableSize());\n\n        assertEquals(0, context.index(context.get(HttpHeader.ACCEPT)));\n        assertEquals(1, context.index(context.get(HttpHeader.ACCEPT_CHARSET)));\n        assertEquals(2, context.index(context.get(HttpHeader.ACCEPT_ENCODING)));\n        assertEquals(3, context.index(context.get(HttpHeader.ACCEPT_LANGUAGE)));\n        assertEquals(4, context.index(context.get(HttpHeader.ACCEPT_RANGES)));\n        assertEquals(5, context.index(context.get(HttpHeader.AGE)));\n        assertEquals(6, context.index(context.get(HttpHeader.ALLOW)));\n        assertEquals(7, context.index(context.get(HttpHeader.AUTHORIZATION)));\n        assertEquals(8, context.index(context.get(HttpHeader.CACHE_CONTROL)));\n        assertEquals(9, context.index(context.get(HttpHeader.CONNECTION)));\n        assertEquals(10, context.index(context.get(HttpHeader.CONTENT_DISPOSITION)));\n        assertEquals(11, context.index(context.get(HttpHeader.CONTENT_ENCODING)));\n        assertEquals(12, context.index(context.get(HttpHeader.CONTENT_LANGUAGE)));\n        assertEquals(13, context.index(context.get(HttpHeader.CONTENT_LENGTH)));\n        assertEquals(14, context.index(context.get(HttpHeader.CONTENT_LOCATION)));\n        assertEquals(15, context.index(context.get(HttpHeader.CONTENT_MD5)));\n        assertEquals(16, context.index(context.get(HttpHeader.CONTENT_RANGE)));\n        assertEquals(17, context.index(context.get(HttpHeader.CONTENT_TYPE)));\n        assertEquals(18, context.index(context.get(HttpHeader.COOKIE)));\n        assertEquals(19, context.index(context.get(HttpHeader.DATE)));\n        assertEquals(20, context.index(context.get(HttpHeader.ETAG)));\n        assertEquals(21, context.index(context.get(HttpHeader.EXPECT)));\n        assertEquals(22, context.index(context.get(HttpHeader.EXPIRES)));\n        assertEquals(23, context.index(context.get(HttpHeader.FROM)));\n        assertEquals(24, context.index(context.get(HttpHeader.HOST)));\n        assertEquals(25, context.index(context.get(HttpHeader.IF_MATCH)));\n        assertEquals(26, context.index(context.get(HttpHeader.IF_MODIFIED_SINCE)));\n        assertEquals(27, context.index(context.get(HttpHeader.IF_NONE_MATCH)));\n        assertEquals(28, context.index(context.get(HttpHeader.IF_RANGE)));\n        assertEquals(29, context.index(context.get(HttpHeader.IF_UNMODIFIED_SINCE)));\n        assertEquals(30, context.index(context.get(HttpHeader.LAST_MODIFIED)));\n        assertEquals(31, context.index(context.get(HttpHeader.LOCATION)));\n        assertEquals(32, context.index(context.get(HttpHeader.MAX_FORWARDS)));\n        assertEquals(33, context.index(context.get(HttpHeader.PRAGMA)));\n        assertEquals(34, context.index(context.get(HttpHeader.PROXY_AUTHENTICATE)));\n        assertEquals(35, context.index(context.get(HttpHeader.PROXY_AUTHORIZATION)));\n        assertEquals(36, context.index(context.get(HttpHeader.RANGE)));\n        assertEquals(37, context.index(context.get(HttpHeader.REFERER)));\n        assertEquals(38, context.index(context.get(HttpHeader.RETRY_AFTER)));\n        assertEquals(39, context.index(context.get(HttpHeader.SERVER)));\n        assertEquals(40, context.index(context.get(HttpHeader.SET_COOKIE)));\n        assertEquals(41, context.index(", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "3480699_31", "part": [1, 1], "seq": [1, 1], "prompt": "class Message extends FieldMap {\n\n    @Override\n    public String toString() {\n        header.setField(new BodyLength(bodyLength()));\n        trailer.setField(new CheckSum(checkSum()));\n\n        final StringBuffer sb = new StringBuffer();\n        header.calculateString(sb, null, null);\n        calculateString(sb, null, null);\n        trailer.calculateString(sb, null, null);\n\n        return sb.toString();\n    }\n\n    public  Message();\n    protected  Message(int[] fieldOrder);\n    public  Message(String string);\n    public  Message(String string, boolean validate);\n    public  Message(String string, DataDictionary dd);\n    public  Message(String string, DataDictionary dd, boolean validate);\n\n    public static boolean InitializeXML(String url);\n    @Override public Object clone();\n    private Object cloneTo(Message message);\n    public int bodyLength();\n    private int checkSum(String s);\n    private String checkSum();\n    public void headerAddGroup(Group group);\n    public void headerReplaceGroup(int num, Group group);\n    public Group headerGetGroup(int num, Group group);\n    public void headerRemoveGroup(Group group);\n    public boolean headerHasGroup(int field);\n    public boolean headerHasGroup(int num, int field);\n    public boolean headerHasGroup(int num, Group group);\n    public boolean headerHasGroup(Group group);\n    public void trailerAddGroup(Group group);\n    public Group trailerGetGroup(int num, Group group);\n    public void trailerReplaceGroup(int num, Group group);\n    public void trailerRemoveGroup(Group group);\n    public boolean trailerHasGroup(int field);\n    public boolean trailerHasGroup(int num, int field);\n    public boolean trailerHasGroup(int num, Group group);\n    public boolean trailerHasGroup(Group group);\n    public String toXML();\n    public String toXML(DataDictionary dataDictionary);\n    private void toXMLFields(Element message, String section, FieldMap fieldMap,\n            DataDictionary dataDictionary);\n    public final Header getHeader();\n    public final Trailer getTrailer();\n    public boolean isAdmin();\n    public boolean isApp();\n    @Override public boolean isEmpty();\n    @Override public void clear();\n    public void reverseRoute(Header header);\n    private void copyField(Header header, int fromField, int toField);\n     void setSessionID(SessionID sessionID);\n    private void optionallySetID(Header header, int field, String value);\n    public void fromString(String messageData, DataDictionary dd, boolean doValidation);\n    public void fromString(String messageData, DataDictionary sessionDictionary,\n            DataDictionary applicationDictionary, boolean doValidation);\n     void parse(String messageData, DataDictionary sessionDataDictionary,\n            DataDictionary applicationDataDictionary, boolean doValidation);\n    private void validateCheckSum(String messageData);\n    private void parseHeader(DataDictionary dd, boolean doValidation);\n    private boolean isNextField(DataDictionary dd, Header fields, int tag);\n    private String getMsgType();\n    private void parseBody(DataDictionary dd, boolean doValidation);\n    private void setField(FieldMap fields, StringField field);\n    private void parseGroup(String msgType, StringField field, DataDictionary dd, FieldMap parent);\n    private int index(int[] fieldOrder, int tag);\n    private void parseTrailer(DataDictionary dd);\n    static boolean isHeaderField(Field<?> field, DataDictionary dd);\n    static boolean isHeaderField(int field);\n    static boolean isTrailerField(Field<?> field, DataDictionary dd);\n    static boolean isTrailerField(int field);\n    public void pushBack(StringField field);\n    private StringField extractField(DataDictionary dataDictionary, FieldMap fields);\n    private StringField extractField(Group group, DataDictionary dataDictionary, FieldMap fields);\n    synchronized boolean hasValidStructure();\n    public synchronized FieldException getException();\n    synchronized int getInvalidTag();\n    public static MsgType identifyType(String message);\n\n}\n\nclass MessageTest {\n\n    @Test\n    public void testEmbeddedMessage() throws Exception {\n", "reference": "        final NewOrderSingle order = createNewOrderSingle();\n\n        final ExecutionReport report = new ExecutionReport(new OrderID(\"ORDER\"),\n                new ExecID(\"EXEC\"), new ExecType(ExecType.FILL), new OrdStatus(OrdStatus.FILLED),\n                new Side(Side.BUY), new LeavesQty(100), new CumQty(100), new AvgPx(50));\n\n        report.set(new EncodedTextLen(order.toString().length()));\n        report.set(new EncodedText(order.toString()));\n\n        final Message msg = new Message(report.toString(), DataDictionaryTest.getDictionary());\n        assertEquals(\"embedded order\", order.toString(), msg.getString(EncodedText.FIELD));\n    }\n\n}", "prediction": "        String message = \"8=FIX.4.2\\u00019=100\\u000135=A\\u000149=TEST\\u000156=TEST\\u000134=1\\u000152=20110103-10:15:16\\u00011128=10\\u000110=096\\u0001\";\n        Message msg = new Message(message);\n        assertEquals(msg.getHeader().getField(new MsgType()), \"A\");\n        assertEquals(msg.getHeader().getField(new SenderCompID()), \"TEST\");\n        assertEquals(msg.getHeader().getField(new TargetCompID()), \"TEST\");\n        assertEquals(msg.getHeader().getField(new MsgSeqNum()), 1);\n        assertEquals(msg.getHeader().getField(new SendingTime()), \"20110103-10:15:16\");\n        assertEquals(msg.getHeader().getField(new EncryptMethod()), 0);\n        assertEquals(msg.getHeader().getField(new HeartBtInt()), 10);\n        assertEquals(msg.getHeader().getField(new TestReqID()), \"\");\n        assertEquals(msg.getHeader().getField(new ResetSeqNumFlag()), false);\n        assertEquals(msg.getHeader().getField(new PossDupFlag()), false);\n        assertEquals(msg.getHeader().getField(new PossResend()), false);\n        assertEquals(msg.getHeader().getField(new SenderSubID()), \"\");\n        assertEquals(msg.getHeader().getField(new SenderLocationID()), \"\");\n        assertEquals(msg.getHeader().getField(new TargetSubID()), \"\");\n        assertEquals(msg.getHeader().getField(new TargetLocationID()), \"\");\n        assertEquals(msg.getHeader().getField(new OnBehalfOfSubID()), \"\");\n        assertEquals(msg.getHeader().getField(new OnBehalfOfLocationID()), \"\");\n        assertEquals(msg.getHeader().getField(new DeliverToCompID()), \"\");\n        assertEquals(msg.getHeader().getField(new DeliverToSubID()), \"\");\n        assertEquals(msg.getHeader().getField(new DeliverToLocationID()), \"\");\n        assertEquals(msg.getHeader().getField(new PossResend()), false);\n        assertEquals(msg.getHeader().getField(new OrigSendingTime()), \"\");\n        assertEquals(msg.getHeader().getField(new PossDupFlag()), false);\n        assertEquals(msg.getHeader().getField(new PossDupFlag()), false);\n        assertEquals(msg.getHeader().getField(new PossResend()), false);\n        assertEquals(msg.getHeader().getField(new SendingTime()), \"20110103-10:15:16\");\n        assertEquals(msg.getHeader().getField(new TestReqID()), \"\");\n        assertEquals(msg.getHeader().getField(new EncryptMethod()), 0);\n        assertEquals(msg.getHeader().getField(new HeartBtInt()), 10);\n        assertEquals(msg.getHeader().getField(new SenderCompID()), \"TEST\");\n        assertEquals(msg.getHeader().getField(new SenderSubID()), \"\");\n        assertEquals(msg.getHeader().getField(new SenderLocationID()), \"\");\n        assertEquals(msg.getHeader().getField(new TargetCompID()), \"TEST\");\n        assertEquals(msg.getHeader().getField(new TargetSubID()), \"\");\n        assertEquals(msg.getHeader().getField(new TargetLocationID()), \"\");\n        assertEquals(msg.getHeader().getField(new OnBehalfOfCompID()), \"\");\n        assertEquals(msg.getHeader().getField(new OnBehalfOfSubID()), \"\");\n        assertEquals(msg.getHeader().getField(new OnBehalfOfLocationID()), \"\");\n        assertEquals(msg.getHeader().getField(new DeliverToCompID()), \"\");\n        assertEquals(msg.getHeader().getField(new DeliverToSubID()), \"\");\n        assertEquals(msg.getHeader().getField(new DeliverToLocationID()), \"\");\n        assertEquals(msg.getHeader().getField(new PossResend()), false);\n        assertEquals(msg.getHeader().getField(new Orig", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "3604591_7", "part": [1, 1], "seq": [1, 1], "prompt": "class PackageNameMatcher {\n\n    public static PackageNameMatcher compile(final List<String> specs) {\n        if (specs == null) {\n            throw new IllegalArgumentException(\"null package name specifications\");\n        }\n\n        final List<Pattern> list = new ArrayList<>();\n\n        for (String part : specs) {\n            list.add(buildPattern(part));\n        }\n\n        return new PackageNameMatcher(list);\n    }\n\n    private  PackageNameMatcher(List<Pattern> patterns);\n\n    private static Pattern buildPattern(final String spec);\n    private String buildDescription();\n    public boolean matches(String packageName);\n    @Override public String toString();\n\n}\n\nclass PackageNameMatcherTest {\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testPattern07() {\n", "reference": "        final List<String> specs = new ArrayList<>();\n        specs.add(\"com.example.*\");\n        specs.add(\"org.example.!\");\n        PackageNameMatcher.compile(specs);\n    }\n\n}", "prediction": "        PackageNameMatcher.compile(Arrays.asList(\"*\", \"**\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "3986627_52", "part": [1, 1], "seq": [1, 1], "prompt": "class JavaPropertyScanner extends AbstractPropertyScanner implements PropertyScanner {\n\n    @Override\n    public Locale getLocale(File propertyFile) {\n        Matcher matcher = LOCALE_PATTERN.matcher(propertyFile.getName());\n        if (matcher.matches()) {\n            String actualLocale = matcher.group(2);\n            if(actualLocale==null || actualLocale.isEmpty())\n                return null;\n            actualLocale = actualLocale.substring(1);\n            return (Locale) PropertiesFactory.eINSTANCE.createFromString(PropertiesPackage.Literals.LOCALE, actualLocale);\n        }\n        return null;\n    }\n\n    @Override public File findTemplate(File propertyFile, ScanConfiguration config);\n    private Pattern buildPatternFrom(String fileName);\n    @Override public Map<Locale, File> findTranslations(File template, ScanConfiguration config);\n    @Override public File computeTranslationPath(File template, Locale templateLocale, Locale translationLocale);\n    @Override public boolean isBilingual();\n    @Override public PropertyConverter createConverter(URI resource);\n    @Override public String[] getDefaultIncludes();\n    @Override public String[] getDefaultExcludes();\n    @Override public String getEncoding();\n\n\tprivate JavaPropertyScanner fixture;\n\n}\n\nclass JavaPropertyScannerTest {\n\n\tprivate JavaPropertyScanner fixture;\n\n\t@Test\n\tpublic void testGetLocale() {\n", "reference": "\t\tassertEquals(new Locale(\"de\",\"DE\"),getFixture().getLocale(new File(\"test_de_DE.properties\")));\n\t\tassertEquals(new Locale(\"de\",\"DE\"),getFixture().getLocale(new File(\"tes_en_USt_de_DE.properties\")));\n\t}\n\n}", "prediction": "\t\t// given\n\t\tFile file = new File(\"src/test/resources/properties/messages_en.properties\");\n\t\t// when\n\t\tLocale locale = fixture.getLocale(file);\n\t\t// then\n\t\tassertEquals(Locale.ENGLISH, locale);\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "4084995_0", "part": [1, 1], "seq": [1, 1], "prompt": "class CommandHandlerProvider implements ApplicationContextAware {\n\n    @Nonnull\n    public NewCommandSourceHandler getHandler (@Nonnull final String entity, @Nonnull final String action) {\n        Preconditions.checkArgument(StringUtils.isNoneEmpty(entity), \"An entity must be given!\");\n        Preconditions.checkArgument(StringUtils.isNoneEmpty(action), \"An action must be given!\");\n\n        final String key =  entity + \"|\" + action;\n        if (!this.registeredHandlers.containsKey(key)) {\n            throw new UnsupportedCommandException(key);\n        }\n        return (NewCommandSourceHandler)this.applicationContext.getBean(this.registeredHandlers.get(key));\n    }\n\n      CommandHandlerProvider();\n\n    private void initializeHandlerRegistry();\n    @Override public void setApplicationContext(ApplicationContext applicationContext);\n\n    @Autowired\n    private CommandHandlerProvider commandHandlerProvider;\n\n}\n\nclass CommandHandlerProviderTest {\n\n    @Autowired\n    private CommandHandlerProvider commandHandlerProvider;\n\n    @Test\n    public void shouldRegisterHandler() {\n", "reference": "        try {\n            final Long testCommandId = 815L;\n\n            final NewCommandSourceHandler registeredHandler = this.commandHandlerProvider.getHandler(\"HUMAN\", \"UPDATE\");\n\n            final CommandProcessingResult result =\n                    registeredHandler.processCommand(\n                            JsonCommand.fromExistingCommand(testCommandId, null, null, null, null, null, null, null, null));\n            Assert.assertEquals(testCommandId, result.commandId());\n        } catch (UnsupportedCommandException ucex) {\n            Assert.fail();\n        }\n    }\n\n}", "prediction": "        assertThat(commandHandlerProvider.getHandler(\"entity\", \"action\")).isNotNull();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "4085998_299", "part": [1, 1], "seq": [1, 1], "prompt": "class urn_perun_facility_attribute_def_def_homeMountPoint_passwd_scp extends FacilityAttributesModuleAbstract implements FacilityAttributesModuleImplApi {\n\n\t@Override\n\tpublic void checkAttributeSemantics(PerunSessionImpl perunSession, Facility facility, Attribute attribute) throws WrongReferenceAttributeValueException {\n\t\tif (attribute.getValue() == null) throw new WrongReferenceAttributeValueException(attribute, null, facility, null, \"Value can't be null\");\n\t}\n\n\t@Override public void checkAttributeSyntax(PerunSessionImpl perunSession, Facility facility, Attribute attribute);\n\t@Override public Attribute fillAttribute(PerunSessionImpl session, Facility facility, AttributeDefinition attribute);\n\t@Override public AttributeDefinition getAttributeDefinition();\n\n\tprivate static urn_perun_facility_attribute_def_def_homeMountPoint_passwd_scp classInstance;\n\tprivate static PerunSessionImpl session;\n\tprivate static Facility facility;\n\tprivate static Attribute attributeToCheck;\n\n}\n\nclass urn_perun_facility_attribute_def_def_homeMountPoint_passwd_scpTest {\n\n\tprivate static urn_perun_facility_attribute_def_def_homeMountPoint_passwd_scp classInstance;\n\tprivate static PerunSessionImpl session;\n\tprivate static Facility facility;\n\tprivate static Attribute attributeToCheck;\n\n\t@Test(expected = WrongReferenceAttributeValueException.class)\n\tpublic void testCheckAttributeSemanticsWithoutReqAttribute() throws Exception {\n", "reference": "\t\tSystem.out.println(\"testCheckAttributeSemanticsWithoutReqAttribute()\");\n\t\tattributeToCheck.setValue(null);\n\n\t\tclassInstance.checkAttributeSemantics(session, facility, attributeToCheck);\n\t}\n\n}", "prediction": "\t\tSystem.out.println(\"testCheckAttributeSemanticsWithoutReqAttribute()\");\n\n\t\tclassInstance.checkAttributeSemantics(session, facility, attributeToCheck);\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "4086423_8", "part": [1, 1], "seq": [1, 1], "prompt": "class AssessmentPackageFileImporter {\n\n    public AssessmentPackage importAssessmentPackageData(final File importSandboxDirectory,\n            final MultipartFile multipartFile)\n            throws AssessmentPackageDataImportException {\n        Assert.notNull(importSandboxDirectory, \"importSandboxDirectory\");\n        Assert.notNull(multipartFile, \"multipartFile\");\n        AssessmentPackage assessmentPackage = null;\n\n        final String contentType = ServiceUtilities.computeContentType(multipartFile);\n        if (\"application/xml\".equals(contentType) || \"text/xml\".equals(contentType) || contentType.endsWith(\"+xml\")) {\n            /* Looks like an XML content type */\n            logger.debug(\"Import data uses a known XML MIME type {} so saving to {} and treating as XML\", contentType, importSandboxDirectory);\n            assessmentPackage = importStandaloneXml(importSandboxDirectory, multipartFile);\n        }\n        else {\n            /* Try to treat as a ZIP */\n            final boolean zipSuccess = tryUnpackZipFile(importSandboxDirectory, multipartFile);\n            if (zipSuccess) {\n                logger.debug(\"Import data was successfully expanded as a ZIP file\");\n                assessmentPackage = processUnpackedZip(importSandboxDirectory);\n            }\n            else {\n                logger.warn(\"Import data with MIME type {} was neither a supported XML MIME type nor a ZIP file (containing at least one entry)\", contentType);\n                throw new AssessmentPackageDataImportException(ImportFailureReason.NOT_XML_OR_ZIP);\n            }\n        }\n\n        logger.info(\"Successfully imported data for new {}\", assessmentPackage);\n        return assessmentPackage;\n    }\n\n    private AssessmentPackage importStandaloneXml(final File importSandboxDirectory, final MultipartFile multipartFile);\n    private boolean tryUnpackZipFile(final File importSandboxDirectory, final MultipartFile multipartFile);\n    private AssessmentPackage processUnpackedZip(final File importSandboxDirectory);\n    private void buildPackageFileMap(final File importSandboxDirectory,\n            final Set<String> packageQtiFileBuilder, final Set<String> packageSafeFileBuilder,\n            final List<ContentPackageResource> qtiResources);\n    private String checkPackageFile(final File importSandboxDirectory, final URI href);\n\n    private AssessmentPackageFileImporter assessmentPackageFileImporter;\n    private File importSandboxDirectory;\n\n}\n\nclass AssessmentPackageFileImporterTest {\n\n    private AssessmentPackageFileImporter assessmentPackageFileImporter;\n    private File importSandboxDirectory;\n\n    @Test\n    public void notContentPackage() throws Exception {\n", "reference": "        final MultipartFile multipartFile = getThisUnitTestMultipartFile(\"uk/ac/ed/ph/qtiworks/services/NotContentPackage.zip\", \"application/zip\");\n        try {\n            assessmentPackageFileImporter.importAssessmentPackageData(importSandboxDirectory, multipartFile);\n            Assert.fail(\"Should have failed\");\n        }\n        catch (final AssessmentPackageDataImportException e) {\n            Assert.assertEquals(ImportFailureReason.NOT_CONTENT_PACKAGE, e.getFailure().getReason());\n        }\n    }\n\n}", "prediction": "        final MultipartFile multipartFile = new MockMultipartFile(\"file\", \"not-a-content-package.xml\", \"text/xml\", \"\".getBytes());\n        try {\n            assessmentPackageFileImporter.importAssessmentPackageData(importSandboxDirectory, multipartFile);\n            fail(\"Should have thrown exception\");\n        }\n        catch (final AssessmentPackageDataImportException e) {\n            assertEquals(ImportFailureReason.NOT_XML_OR_ZIP, e.getReason());\n        }\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "4226126_0", "part": [1, 1], "seq": [1, 1], "prompt": "class JunitFeatureRunner extends org.junit.runner.Runner {\n\n    public final void init(final Class<?> reportedClass, final List<Class<?>> stepImplementationClasses,\n            final String featureFile, final String tags, final String subStepsFile,\n            final Class<?>[] beforeAndAfterImplementations) {\n        init(reportedClass, stepImplementationClasses, featureFile, tags, subStepsFile, true, null,\n                EclipseDescriptionProvider.class, beforeAndAfterImplementations);\n    }\n\n    public  JunitFeatureRunner();\n    public  JunitFeatureRunner(final Class<?> classContainingTheTests);\n\n    public final void init(final Class<?> reportedClass, final List<Class<?>> stepImplementationClasses,\n            final String featureFile, final String tags, final String subStepsFileName, final boolean strict,\n            final String[] nonStrictKeywordPrecedence,\n            final Class<? extends DescriptionProvider> descriptionProviderClass,\n            final Class<?>[] beforeAndAfterImplementations);\n    @Override public Description getDescription();\n    @Override public void run(final RunNotifier junitNotifier);\n    private String printDescription(final Description desc, final int depth);\n    public IExecutionNode getRootExecutionNode();\n\n    private static final String SUBSTEPS_RESOURCES_BASE_DIRECTORY;\n\n}\n\nclass JunitFeatureRunnerTest extends org.junit.runner.Runner {\n\n    private static final String SUBSTEPS_RESOURCES_BASE_DIRECTORY;\n\n    @Test(expected = SubstepsConfigurationException.class)\n    public void testMissingSubStepCausesFailure() {\n", "reference": "        final String feature = SUBSTEPS_RESOURCES_BASE_DIRECTORY + \"features/error.feature\";\n        final String tag = \"@bug_missing_sub_step_impl\";\n        final String substeps = SUBSTEPS_RESOURCES_BASE_DIRECTORY + \"substeps/error.substeps\";\n\n        final JunitFeatureRunner runner = new JunitFeatureRunner();\n\n        final List<Class<?>> stepImplsList = new ArrayList<Class<?>>();\n        stepImplsList.add(TestStepImplementations.class);\n\n        runner.init(this.getClass(), stepImplsList, feature, tag, substeps, null);\n    }\n\n}", "prediction": "        final List<Class<?>> stepImplementations = new ArrayList<Class<?>>();\n        stepImplementations.add(SubStepImplementation.class);\n        final JunitFeatureRunner runner = new JunitFeatureRunner();\n        runner.init(SubStepImplementation.class, stepImplementations, \"substeps/missing_substep.feature\",\n                \"missing_substep\", \"substeps/missing_substep.substeps\", true, null,\n                EclipseDescriptionProvider.class, new Class<?>[0]);\n        runner.run(new RunNotifier());\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "4242398_4", "part": [1, 1], "seq": [1, 1], "prompt": "class Memory {\n\n    public static long gb(final double gigabytes) {\n        return (long) gigabytes * 1024 * 1024 * 1024;\n    }\n\n    private  Memory();\n\n    public static long mb(final double megabytes);\n    public static long kb(final double kilobytes);\n    public static long toKb(final long bytes);\n    public static int toMb(final long bytes);\n\n}\n\nclass MemoryTest {\n\n    @Test\n    public void testGb() {\n", "reference": "        assertEquals( Memory.kb( Long.SIZE ), (long) 64 * 1024 );\n    }\n\n}", "prediction": "        assertEquals(1024 * 1024 * 1024, Memory.gb(1));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "4260851_21", "part": [1, 1], "seq": [1, 1], "prompt": "class Binders {\n\n    public static Binder defaultBinder() {\n        return DEFAULT_BINDER;\n    }\n\n    private  Binders();\n\n    public static Binder stringBinder();\n    public static Binder dateBinder();\n    public static Binder timestampBinder();\n    public static Binder timeBinder();\n    public static Binder decimalBinder();\n    public static Binder integerBinder();\n\n    private PreparedStatement stmt;\n\n}\n\nclass BindersTest {\n\n    private PreparedStatement stmt;\n\n    @Test\n    public void defaultBinderBindsLocalDateTime() throws SQLException {\n", "reference": "        LocalDateTime localDateTime = LocalDateTime.parse(\"1975-07-19T01:02:03.000\");\n        Binder binder = Binders.defaultBinder();\n        binder.bind(stmt, 1, localDateTime);\n        verify(stmt).setTimestamp(1, Timestamp.valueOf(\"1975-07-19 01:02:03\"));\n    }\n\n}", "prediction": "        LocalDateTime now = LocalDateTime.now();\n        Binders.defaultBinder().bind(stmt, 1, now);\n        assertThat(stmt.getTimestamp(1)).isEqualTo(Timestamp.valueOf(now));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "4263930_0", "part": [1, 1], "seq": [1, 1], "prompt": "class StreamUtils {\n\n    public static String getStreamContents(InputStream is) {\n        Preconditions.checkNotNull(is, \"Cannot get String from a null object\");\n        try {\n            final char[] buffer = new char[0x10000];\n            StringBuilder out = new StringBuilder();\n            Reader in = new InputStreamReader(is, \"UTF-8\");\n            int read;\n            do {\n                read = in.read(buffer, 0, buffer.length);\n                if (read > 0) {\n                    out.append(buffer, 0, read);\n                }\n            } while (read >= 0);\n            in.close();\n            return out.toString();\n        } catch (IOException ioe) {\n            throw new IllegalStateException(\"Error while reading response body\", ioe);\n        }\n    }\n\n    private  StreamUtils();\n\n}\n\nclass StreamUtilsTest {\n\n    @Test\n    public void shouldCorrectlyDecodeAStream() {\n", "reference": "        String value = \"expected\";\n        InputStream is = new ByteArrayInputStream(value.getBytes());\n        String decoded = StreamUtils.getStreamContents(is);\n        assertEquals(\"expected\", decoded);\n    }\n\n}", "prediction": "        InputStream is = new ByteArrayInputStream(\"Hello World\".getBytes());\n        String result = StreamUtils.getStreamContents(is);\n        assertEquals(\"Hello World\", result);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "4470435_39", "part": [1, 1], "seq": [1, 1], "prompt": "class SelectionParameters {\n\n    @Override\n    public int hashCode() {\n        int hash = 3;\n        hash = 97 * hash + (this.qualifyingNames != null ? this.qualifyingNames.hashCode() : 0);\n        hash = 97 * hash + (this.resultType != null ? this.resultType.toString().hashCode() : 0);\n        return hash;\n    }\n\n    public  SelectionParameters(List<TypeMirror> qualifiers, List<String> qualifyingNames, TypeMirror resultType,\n        Types typeUtils);\n    private  SelectionParameters(List<TypeMirror> qualifiers, List<String> qualifyingNames, TypeMirror resultType,\n        Types typeUtils, SourceRHS sourceRHS);\n\n    public static SelectionParameters forInheritance(SelectionParameters selectionParameters);\n    public List<TypeMirror> getQualifiers();\n    public List<String> getQualifyingNames();\n    public TypeMirror getResultType();\n    public SourceRHS getSourceRHS();\n    @Override public boolean equals(Object obj);\n    private boolean equals(List<TypeMirror> mirrors1, List<TypeMirror> mirrors2);\n    private boolean equals(TypeMirror mirror1, TypeMirror mirror2);\n    public static SelectionParameters forSourceRHS(SourceRHS sourceRHS);\n\n    private final Types typeUtils;\n\n}\n\nclass SelectionParametersTest {\n\n    private final Types typeUtils;\n\n    @Test\n    public void testHashCodeWithNullQualifyingNames() {\n", "reference": "        TypeMirror resultType = new TestTypeMirror( \"someType\" );\n        SelectionParameters params = new SelectionParameters( null, null, resultType, null );\n\n        assertThat( params.hashCode() )\n            .as( \"QualifyingNames null hashCode\" )\n            .isEqualTo( 3 * 97 * 97 + \"someType\".hashCode() );\n    }\n\n}", "prediction": "        SelectionParameters parameters = new SelectionParameters(null, null, null, typeUtils);\n        assertEquals(parameters.hashCode(), parameters.hashCode());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "4597349_8", "part": [1, 1], "seq": [1, 1], "prompt": "class SwingTree extends AbstractSwingContainer implements XulTree {\n\n  public XulTreeCols getColumns() {\n    return this.columns;\n  }\n\n  public  SwingTree( Element self, XulComponent parent, XulDomContainer domContainer, String tagName );\n\n  public JTable getTable();\n  public JTree getTree();\n  public int[] getActiveCellCoordinates();\n  public String getOnselect();\n  public XulTreeChildren getRootChildren();\n  public int getRows();\n  public String getSeltype();\n  public Object[][] getValues();\n  public int getWidth();\n  public void setWidth( int width );\n  public boolean isDisabled();\n  public boolean isEditable();\n  public boolean isEnableColumnDrag();\n  public boolean isHierarchical();\n  public void setActiveCellCoordinates( int row, int column );\n  public void setDisabled( boolean dis );\n  public void setEditable( boolean edit );\n  public void setEnableColumnDrag( boolean drag );\n  public void setOnselect( final String select );\n  public void setColumns( XulTreeCols columns );\n  public void setRootChildren( final XulTreeChildren rootChildren );\n  public void addTreeRow( XulTreeRow row );\n  public void removeTreeRows( int[] rows );\n  public void setRows( int rows );\n  public void setSeltype( String type );\n  public void setTableModel( TableModel model );\n  @Override public void layout();\n  private void updateColumnModel();\n  private void setupTable();\n  private void calcColumnWidths();\n  private void setupTree();\n  private XulTreeNode createNode( XulTreeItem item );\n  @Override public void replaceChild( XulComponent oldElement, XulComponent newElement );\n  @Override public Object getManagedObject();\n  public int[] getSelectedRows();\n  public int[] getAbsoluteSelectedRows();\n  public void addRow( XulTreeRow row );\n  public Object getData();\n  public void setData( Object data );\n  public void update();\n  private String extractDynamicColType( Object row, int columnPos );\n  private TableCellRenderer getCellRenderer( final SwingTreeCol col );\n  private TableCellEditor getCellEditor( final SwingTreeCol col );\n  public void clearSelection();\n  public void setSelectedRows( int[] rows );\n  public String getOnedit();\n  public void setOnedit( String onedit );\n  public void setElements( Collection<T> elements );\n  private void addTreeChild( T element, XulTreeRow row );\n  public Collection<T> getElements();\n  private void fireSelectedItem();\n  public Object getSelectedItem();\n  private SearchBundle findSelectedIndex( SearchBundle bundle, XulTreeChildren children, XulTreeItem selectedItem );\n  private FindSelectedItemTuple findSelectedItem( Object parent, String childrenMethodProperty,\n      FindSelectedItemTuple tuple );\n  private static Collection getChildCollection( Object obj, String childrenMethodProperty );\n  public void setExpanded( boolean expanded );\n  public boolean getExpanded();\n  public void registerCellEditor( String key, org.pentaho.ui.xul.util.TreeCellEditor editor );\n  public void registerCellRenderer( String key, TreeCellRenderer renderer );\n  public void setBoundObjectExpanded( Object o, boolean expanded );\n  public void setTreeItemExpanded( XulTreeItem item, boolean expanded );\n  public void collapseAll();\n  public void expandAll();\n  public Collection<T> getSelectedItems();\n  public void setSelectedItems( Collection<T> items );\n  public int findIndexOfItem( Object o );\n  private FindSelectedIndexTuple findSelectedItem( Object parent, Method childrenMethod, FindSelectedIndexTuple tuple );\n  public boolean isHiddenrootnode();\n  public void setHiddenrootnode( boolean hidden );\n  public String getCommand();\n  public void setCommand( String command );\n  public boolean isPreserveexpandedstate();\n  public void setPreserveexpandedstate( boolean preserve );\n  public boolean isSortable();\n  public void setSortable( boolean sort );\n  public boolean isTreeLines();\n  public void setTreeLines( boolean visible );\n  public void setNewitembinding( String binding );\n  public String getNewitembinding();\n  public void setAutocreatenewrows( boolean auto );\n  public boolean getAutocreatenewrows();\n  private void insertRowAtLast();\n  public boolean isPreserveselection();\n  public void setPreserveselection( boolean preserve );\n  private Binding createBinding( XulEventSource source, String prop1, XulEventSource target, String prop2 );\n  private boolean isCollectionManaged();\n\n   XulRunner runner;\n   XulDomContainer container;\n   XulTree tree;\n   XulTree tree2;\n   XulTree tree3;\n   Document document;\n\n}\n\nclass SwingTreeTest {\n\n   XulRunner runner;\n   XulDomContainer container;\n   XulTree tree;\n   XulTree tree2;\n   XulTree tree3;\n   Document document;\n\n  @Test\n  public void testGetCols() throws Exception {\n", "reference": "    assertEquals( tree.getColumns(), document.getElementById( \"column_list\" ) );\n  }\n\n}", "prediction": "    assertNotNull( tree.getColumns() );\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "4622542_24", "part": [1, 1], "seq": [1, 1], "prompt": "class ResourceUtils {\n\n    public static InputStream getResourceWithAbsolutePackagePathAsStream(String absolutePackagePath, String resourceName) {\n        return getResourceWithAbsolutePackagePathAsStream(ResourceUtils.class, absolutePackagePath, resourceName);\n    }\n\n    public static URL getResourceWithAbsolutePackagePath(String absolutePackagePath, String resourceName);\n    private static String getFullPath(String resourcePath);\n    private static Path parsePath(String resourcePath);\n    public static URL getResource(String resourcePath);\n    public static URL getResource(Class<?> clazz, String resourcePath);\n    public static InputStream getResourceAsStream(String resourcePath);\n    public static InputStream getResourceAsStream(Class<?> clazz, String resourcePath);\n    public static URL getResourceWithAbsolutePackagePath(Class<?> clazz, String absolutePackagePath, String resourceName);\n    public static InputStream getResourceWithAbsolutePackagePathAsStream(Class<?> clazz, String absolutePackagePath, String resourceName);\n    private static String getResourcePath(String absolutePackagePath, String resourceName);\n    private static String formatArgument(String argument);\n    private static String constructResourcePath(String packagePath, String resourceName);\n    private static String removeLeadingUnixSeparators(String argument);\n\n}\n\nclass ResourceUtilsTest {\n\n    @Test\n    public void testResourceLoadingGetClass() {\n", "reference": "        InputStream stream = ResourceUtils.getResourceWithAbsolutePackagePathAsStream(getClass(), \"/org/reficio/ws/common/test/\", \"soapEncoding.xsd\");\n        Assert.assertNotNull(stream);\n    }\n\n}", "prediction": "        InputStream is = ResourceUtils.getResourceWithAbsolutePackagePathAsStream(ResourceUtilsTest.class, \"test.txt\");\n        assertNotNull(is);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "4654729_5", "part": [1, 1], "seq": [1, 1], "prompt": "class BindingConditions {\n\n    public static <T> BindingCondition<T> isNamedIgnoringCase(Class<? extends T> type, final CharSequence value) {\n        return new BindingCondition<T>() {\n            \n            @Override\n            public boolean fulfilled(ClassInjector injector, Class<T> type, Map<String, Class<? extends T>[]> inheritanceTree, Annotation qualifier,\n                    ClassLoader classLoader) {\n                return qualifier instanceof Named && ((Named) qualifier).value().equalsIgnoreCase(value.toString());\n            }\n            \n        };\n    }\n\n    @SuppressWarnings(\"unchecked\") public static BindingCondition<T> annotationIsPresent(Class<? extends T> type, Class<? extends Annotation> annotation);\n    public static BindingCondition<T> qualifierIs(Class<? extends T> type, final Class<? extends Annotation> expectedQualifier);\n    public static BindingCondition<T> isNamed(Class<? extends T> type, final CharSequence value);\n    public static BindingCondition<T> allAnnotationsArePresent(Class<? extends T> type, final Class<? extends Annotation>... annotations);\n    public static BindingCondition<T> anyAnnotationIsPresent(Class<? extends T> type, final Class<? extends Annotation>... annotations);\n    public static BindingCondition<T> and(final BindingCondition<T>... conditions);\n    public static BindingCondition<T> or(final BindingCondition<T>... conditions);\n    public static BindingCondition<T> xor(final BindingCondition<T> condition1, final BindingCondition<T> condition2);\n\n     ClassLoader classLoader;\n     BindingCondition<Object> nonConfirming;\n     BindingCondition<Object> confirming;\n\n}\n\nclass BindingConditionsTest {\n\n     ClassLoader classLoader;\n     BindingCondition<Object> nonConfirming;\n     BindingCondition<Object> confirming;\n\n    @Test\n    public void isNotNamedIgnoringCase() {\n", "reference": "        assertFalse(BindingConditions.isNamedIgnoringCase(Tire.class, \"spare\").fulfilled(null, Tire.class, null, new Named() {\n            \n            @Override\n            public Class<? extends Annotation> annotationType() {\n                return Named.class;\n            }\n            \n            @Override\n            public String value() {\n                return \"notspare\";\n            }\n            \n        }, classLoader));\n    }\n\n}", "prediction": "        BindingCondition<Object> condition = BindingConditions.isNamedIgnoringCase(Object.class, \"foo\");\n        assertFalse(condition.fulfilled(classLoader, Object.class, null, null));\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "4718003_0", "part": [1, 1], "seq": [1, 1], "prompt": "class AnnotationInjector {\n\n    public static void inject(final Object object, final Factory factory) {\n        if (object == null) {\n            throw new IllegalArgumentException(\"object cannot be null.\");\n        }\n        if (factory == null) {\n            throw new IllegalArgumentException(\"factory cannot be null.\");\n        }\n        Class<?> c = object.getClass();\n        // first to all annotated public setter methods.\n        for (final Method method : c.getMethods()) {\n            if (method.isAnnotationPresent(InjectForRequest.class)) {\n                injectIntoMethod(object, factory, method);\n            }\n        }\n        // and then all annotated fields.\n        while (c != Object.class && c != null) {\n            for (final Field field : c.getDeclaredFields()) {\n                if (field.isAnnotationPresent(InjectForRequest.class)) {\n                    injectIntoField(object, factory, field);\n                }\n\n            }\n\n            c = c.getSuperclass();\n        }\n    }\n\n    public static Field[] findFieldsWithAnnotation(final Object object,\n                                                   final Class<? extends Annotation> annnotationClass);\n    private static void injectIntoField(final Object object, final Factory factory, final Field field);\n    private static void injectIntoMethod(final Object object, final Factory factory, final Method method);\n\n}\n\nclass AnnotationInjectorTest {\n\n    @Test\n    public void testInject() {\n", "reference": "        final Factory f = new Factory() {\n\n            @SuppressWarnings(\"unchecked\")\n            public <T> T getObject(final String name, final Class<T> type) {\n                return (T) name;\n            }\n\n        };\n        final Sample object = new Sample();\n        AnnotationInjector.inject(object, f);\n        assertEquals(\"me\", object.foo);\n        assertEquals(\"foot\", object.foot);\n\n    }\n\n}", "prediction": "        final Factory factory = new Factory() {\n            @Override\n            public Object create(final Class<?> clazz) {\n                return new Object();\n            }\n        };\n        final Object object = new Object();\n        AnnotationInjector.inject(object, factory);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "4735878_12", "part": [1, 1], "seq": [1, 1], "prompt": "class CategorizedColor extends CategorizedLegend<Color> {\n\n    @Override\n    public Color remove(Double d){\n        if(d==null){\n            throw new NullPointerException(\"The input threshold must not be null\");\n        }\n        if(parameter instanceof ColorLiteral){\n            return null;\n        } else {\n            Categorize2Color c2s = (Categorize2Color) parameter;\n            ColorParameter ret = c2s.remove(new RealLiteral(d));\n            if(ret == null){\n                return null;\n            } else if(c2s.getNumClasses()==1 && c2s.getFallbackValue().equals(c2s.get(0))){\n                parameter = new ColorLiteral(c2s.getFallbackValue().getColor(null));\n            }\n            if(ret instanceof ColorLiteral){\n                try{\n                    return ret.getColor(null);\n                } catch (ParameterException pe){\n                    throw new IllegalStateException(\"We've failed at retrieved the value of a literal. \" +\n                            \"Something is going really wrong here.\");\n                }\n            } else {\n                throw new IllegalStateException(\"We're not supposed to have values that are not ColorLiteral in this categorize.\");\n            }\n        }\n    }\n\n    public  CategorizedColor(ColorParameter sp);\n\n    @Override public SeParameter getParameter();\n    public void setParameter(ColorParameter param);\n    public Color getFallbackValue();\n    public void setFallbackValue(Color value);\n    @Override public Color get(Double d);\n    @Override public void put(Double d, Color v);\n    @Override public Color getFromLower(Double d);\n\n}\n\nclass CategorizedColorTest {\n\n    @Test\n    public void testRemoveFromLiteral(){\n", "reference": "        CategorizedColor cs = new CategorizedColor(new ColorLiteral(\"#EDCBA0\"));\n        assertNull(cs.remove(50.0));\n        assertNull(cs.remove(Double.NEGATIVE_INFINITY));\n    }\n\n}", "prediction": "        CategorizedColor cc = new CategorizedColor(new ColorLiteral(Color.BLACK));\n        assertEquals(Color.BLACK, cc.remove(0.0));\n        assertEquals(Color.BLACK, cc.remove(1.0));\n        assertEquals(Color.BLACK, cc.remove(2.0));\n        assertEquals(Color.BLACK, cc.remove(3.0));\n        assertEquals(Color.BLACK, cc.remove(4.0));\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "4750321_632", "part": [1, 1], "seq": [1, 1], "prompt": "class FilterToCQL implements FilterVisitor, ExpressionVisitor {\n\n    private StringBuffer after( PropertyIsGreaterThan filter, StringBuffer output ){\n        LOGGER.finer(\"exporting AFTER\");\n        \n        Object expr1 = filter.getExpression1();\n        if( expr1 instanceof PropertyName){\n        \tPropertyName propertyName = (PropertyName) expr1;\n        \tpropertyName.accept(this, output);\n        \toutput.append(\" AFTER \");\n            filter.getExpression2().accept(this, output);        \n        }else { \n        \tPropertyName propertyName = (PropertyName) filter.getExpression2();\n            propertyName.accept(this, output);\n            output.append(\" BEFORE \");\n            filter.getExpression1().accept(this, output);        \n        }\n        return output;\n        \n    }\n\n    protected StringBuffer asStringBuffer( Object extraData);\n    public Object visit(ExcludeFilter filter, Object extraData);\n    public Object visit(IncludeFilter filter, Object extraData);\n    public Object visit(And filter, Object extraData);\n    public Object visit(Id filter, Object extraData);\n    public Object visit(Not filter, Object extraData);\n    public Object visit(Or filter, Object extraData);\n    public Object visit(PropertyIsBetween filter, Object extraData);\n    public Object visit(PropertyIsEqualTo filter, Object extraData);\n    public Object visit(PropertyIsNotEqualTo filter, Object extraData);\n    public Object visit(PropertyIsGreaterThan filter, Object extraData);\n    private boolean comparisonHasDate( Filter filter);\n    public Object visit(PropertyIsGreaterThanOrEqualTo filter, Object extraData);\n    public Object visit(PropertyIsLessThan filter, Object extraData);\n    public Object visit(PropertyIsLessThanOrEqualTo filter, Object extraData);\n    public Object visit(PropertyIsLike filter, Object extraData);\n    public Object visit(PropertyIsNull filter, Object extraData);\n    public Object visit(BBOX filter, Object extraData);\n    public Object visit(Beyond filter, Object extraData);\n    public Object visit(Contains filter, Object extraData);\n    public Object visit(Crosses filter, Object extraData);\n    public Object visit(Disjoint filter, Object extraData);\n    public Object visit(DWithin filter, Object extraData);\n    public Object visit(Equals filter, Object extraData);\n    public Object visit(Intersects filter, Object extraData);\n    public Object visit(Overlaps filter, Object extraData);\n    public Object visit(Touches filter, Object extraData);\n    public Object visit(Within filter, Object extraData);\n    public Object visitNullFilter(Object extraData);\n    public Object visit(NilExpression expression, Object extraData);\n    public Object visit(Add expression, Object extraData);\n    public Object visit(Divide expression, Object extraData);\n    public Object visit(Function function, Object extraData);\n    public Object visit(Literal expression, Object extraData);\n    public StringBuffer date( Date date, StringBuffer output );\n    public Object visit(Multiply expression, Object extraData);\n    public Object visit(PropertyName expression, Object extraData);\n    public Object visit(Subtract expression, Object extraData);\n    public Object visit(After after, Object extraData);\n    public Object visit(AnyInteracts anyInteracts, Object extraData);\n    public Object visit(Before before, Object extraData);\n    public Object visit(Begins begins, Object extraData);\n    public Object visit(BegunBy begunBy, Object extraData);\n    public Object visit(During during, Object extraData);\n    public Object visit(EndedBy endedBy, Object extraData);\n    public Object visit(Ends ends, Object extraData);\n    public Object visit(Meets meets, Object extraData);\n    public Object visit(MetBy metBy, Object extraData);\n    public Object visit(OverlappedBy overlappedBy, Object extraData);\n    public Object visit(TContains contains, Object extraData);\n    public Object visit(TEquals equals, Object extraData);\n    public Object visit(TOverlaps contains, Object extraData);\n\n     FilterToCQL toCQL;\n\n}\n\nclass FilterToCQLTest {\n\n     FilterToCQL toCQL;\n\n    @Test \n    public void testAfter() throws Exception{\n", "reference": "    \t\n    \tcqlTest(\"attr AFTER 2006-12-31T01:30:00Z\");\n    }\n\n}", "prediction": "        Filter after = new After(new PropertyName(\"prop1\"), new PropertyName(\"prop2\"));\n        assertEquals(\"prop1 AFTER prop2\", toCQL.visit(after, null));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "4797319_38", "part": [1, 1], "seq": [1, 1], "prompt": "class PointOfFocusProcessor {\n\n  public static RecommendationType process(ASTQueryContainer ast)\n  throws VisitorException {\n    final List<String> v = new ArrayList<String>();\n\n    if (!(ast.getQuery() instanceof ASTSelectQuery)) { // Change to a SelectQuery\n      final ASTSelectQuery selectQuery = new ASTSelectQuery(SyntaxTreeBuilderTreeConstants.JJTSELECTQUERY);\n      final ASTSelect select = new ASTSelect(SyntaxTreeBuilderTreeConstants.JJTSELECT);\n\n      selectQuery.jjtAppendChild(select);\n      for (ASTDatasetClause d : ast.getQuery().getDatasetClauseList()) {\n        selectQuery.jjtAppendChild(d);\n      }\n      selectQuery.jjtAppendChild(ast.getQuery().getWhereClause());\n      if (!(ast.getQuery() instanceof ASTAskQuery)) {\n        if (ast.getQuery().getGroupClause() != null) {\n          selectQuery.jjtAppendChild(ast.getQuery().getGroupClause());\n        }\n        if (ast.getQuery().getHavingClause() != null) {\n          selectQuery.jjtAppendChild(ast.getQuery().getHavingClause());\n        }\n        if (ast.getQuery().getOrderClause() != null) {\n          selectQuery.jjtAppendChild(ast.getQuery().getOrderClause());\n        }\n        if (ast.getQuery().getLimit() != null) {\n          selectQuery.jjtAppendChild(ast.getQuery().getLimit());\n        }\n        if (ast.getQuery().getOffset() != null) {\n          selectQuery.jjtAppendChild(ast.getQuery().getOffset());\n        }\n      }\n      if (ast.getQuery().getBindingsClause() != null) {\n        selectQuery.jjtAppendChild(ast.getQuery().getBindingsClause());\n      }\n      ast.getQuery().jjtReplaceWith(selectQuery);\n    }\n    final ASTMaterializePointOfFocus matPOF = new ASTMaterializePointOfFocus();\n    matPOF.visit(ast, v);\n    final POFRecType type = new POFRecType();\n    return (RecommendationType) type.visit(ast, RecommendationType.NONE);\n  }\n\n  private  PointOfFocusProcessor();\n\n  private ASTQueryContainer ast;\n\n}\n\nclass TestPointOfFocusProcessor {\n\n  private ASTQueryContainer ast;\n\n  @Test(expected=DGSException.class)\n  public void testWrongRecommendationType()\n  throws Exception {\n", "reference": "    final String q = \"SELECT ?s WHERE { GRAPH ?g { < ?p ?o } }\";\n    ast = SyntaxTreeBuilder.parseQuery(q);\n    PointOfFocusProcessor.process(ast);\n  }\n\n}", "prediction": "   PointOfFocusProcessor.process(ast);\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "5184704_9", "part": [1, 1], "seq": [1, 1], "prompt": "class Com_Query extends Packet {\n\n    public static Com_Query loadFromPacket(byte[] packet) {\n        Com_Query obj = new Com_Query();\n        Proto proto = new Proto(packet, 3);\n        \n        obj.sequenceId = proto.get_fixed_int(1);\n        proto.get_filler(1);\n        obj.query = proto.get_eop_str();\n        \n        return obj;\n    }\n\n    public ArrayList<byte[]> getPayload();\n\n}\n\nclass Com_QueryTest {\n\n    @Test\n    public void test3() {\n", "reference": "        byte[] packet = Proto.packet_string_to_bytes(\"\"\n            + \"21 00 00 00 03 73 65 6c    65 63 74 20 40 40 76 65\"\n            + \"72 73 69 6f 6e 5f 63 6f    6d 6d 65 6e 74 20 6c 69\"\n            + \"6d 69 74 20 31                                    \"\n        );\n\n        Com_Query pkt = Com_Query.loadFromPacket(packet);\n        assertArrayEquals(packet, pkt.toPacket());\n        assertEquals(pkt.query, \"select @@version_comment limit 1\");\n    }\n\n}", "prediction": "        byte[] packet = new byte[] { 7, 0, 0, 2, 67, 111, 110, 102, 102, 101, 114, 115, 105, 111, 110, 102, 102, 101, 114, 115, 105, 111, 110, 102, 102, 101, 114, 115, 105, 111, 110, 102, 102, 101, 114, 115, 105, 111, 110, 102, 102, 101, 114, 115, 105, 111, 110, 102, 102, 101, 114, 115, 105, 111, 110, 102, 102, 101, 114, 115, 105, 111, 110, 102, 102, 101, 114, 115, 105, 111, 110, 102, 102, 101, 114, 115, 105, 111, 110, 102, 102, 101, 114, 115, 105, 111, 110, 102, 102, 101, 114, 115, 105, 111, 110, 102, 102, 101, 114, 115, 105, 111, 110, 102, 102, 101, 114, 115, 105, 111, 110, 102, 102, 101, 114, 115, 105, 111, 110, 102, 102, 101, 114, 115, 105, 111, 110, 102, 102, 101, 114, 115, 105, 111, 110, 102, 102, 101, 114, 115, 105, 111, 110, 102, 102, 101, 114, 115, 105, 111, 110, 102, 102, 101, 114, 115, 105, 111, 110, 102, 102, 101, 114, 115, 105, 111, 110, 102, 102, 101, 114, 115, 105, 111, 110, 102, 102, 101, 114, 115, 105, 111, 110, 102, 102, 101, 114, 115, 105, 111, 110, 102, 102, 101, 114, 115, 105, 111, 110, 102, 102, 101, 114, 115, 105, 111, 110, 102, 102, 101, 114, 115, 105, 111, 110, 102, 102, 101, 114, 115, 105, 111, 110, 102, 102, 101, 114, 115, 105, 111, 110, 102, 102, 101, 114, 115, 105, 111, 110, 102, 102, 101, 114, 115, 105, 111, 110, 102, 102, 101, 114, 115, 105, 111, 110, 102, 102, 101, 114, 115, 105, 111, 110, 102, 102, 101, 114, 115, 105, 111, 110, 102, 102, 101, 114, 115, 105, 111, 110, 102, 102, 101, 114, 115, 105, 111, 110, 102, 102, 101, 114, 115, 105, 111, 110, 102, 102, 101, 114, 115, 105, 111, 110, 102, 102, 101, 114, 115, 105, 111, 110, 102, 102, 101, 114, 115, 105, 111, 110, 102, 102, 101, 114, 115, 105, 111, 110, 102, 102, 101, 114, 115, 105, 111, 110, 102, 102, 101, 114, 115, 105, 111, 110, 102, 102, 101, 114, 115, 105, 111, 110, 102, 102, 101, 114, 115, 105, 111, 110, 102, 102, 101, 114, 115, 105, ", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "5239065_27", "part": [1, 1], "seq": [1, 1], "prompt": "class ExpiringSet {\n\n    public boolean contains(final E key) {\n        synchronized (set) {\n            if (set.contains(key)) {\n                return true;\n            }\n            set.add(key);   // not found, so add it\n        }\n        scheduler.schedule(new Runnable() {   // schedule automatic key removal\n            @Override\n            public void run() {\n                synchronized (set) {\n                    set.remove(key);\n                }\n            }\n        }, expireSeconds, TimeUnit.SECONDS);\n        return false;\n    }\n\n    public  ExpiringSet(int expireSeconds);\n\n    public void shutdown();\n\n}\n\nclass ExpiringSetTest {\n\n\t@Test\n\tpublic void testAdd() throws InterruptedException {\n", "reference": "\t\tExpiringSet<String> expiringSet = new ExpiringSet<String>(2);   // seconds\n\t\tassertFalse(expiringSet.contains(\"hello\"));\n\t\tassertTrue(expiringSet.contains(\"hello\"));\n\t}\n\n}", "prediction": "\t\tfinal ExpiringSet<String> set = new ExpiringSet<String>(1);\n\t\tassertFalse(set.contains(\"a\"));\n\t\tassertTrue(set.contains(\"a\"));\n\t\tset.shutdown();\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "5264970_4", "part": [1, 1], "seq": [1, 1], "prompt": "class JsonSerializer extends BaseSerializer {\n\n    @Override\n    protected byte[] serialize(Object data) throws IOException {\n        return gson.toJson(data).getBytes(Charsets.UTF_8);\n    }\n\n    @Inject public  JsonSerializer(Gson gson);\n\n}\n\nclass JsonSerializerTest {\n\n    @Test\n    public void serializeOneAnnotated() throws Exception {\n", "reference": "        Gson gson = new Gson();\n        JsonSerializer serializer = new JsonSerializer(gson);\n\n        Invokable<?, Object> method = Invokable.from(Methods.class.getMethod(\"oneAnnotated\", Pojo.class));\n        Parameter[] parameters = Iterables.toArray(method.getParameters(), Parameter.class);\n\n        Pojo pojo = new Pojo(\"Hello world!\", 42);\n        byte[] bytes = serializer.serialize(parameters, new Object[] { pojo });\n\n        String expected = gson.toJson(Collections.singletonMap(\"value\", pojo));\n        JSONAssert.assertEquals(expected, new String(bytes, Charsets.UTF_8), true);\n    }\n\n}", "prediction": "        JsonSerializer serializer = new JsonSerializer(new Gson());\n        byte[] bytes = serializer.serialize(new Annotated());\n        assertThat(bytes).isEqualTo(\"{\\\"name\\\":\\\"test\\\"}\".getBytes(Charsets.UTF_8));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "5342001_1", "part": [1, 1], "seq": [1, 1], "prompt": "class Mapper implements ResourceLoaderAware {\n\n\tpublic Object map(Object toMap) {\n\t\t\n\t\tif (toMap == null) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tClass<?> mappedClass = mappings.get(toMap.getClass());\n\t\tif (mappedClass != null) {\n\t\t\treturn modelMapper.map(toMap, mappedClass);\t\t\t\n\t\t} else {\n\t\t\treturn toMap;\n\t\t}\n\t}\n\n\tpublic void setPackages(List<String> packages);\n\t@PostConstruct public void init();\n\t@Override public void setResourceLoader(ResourceLoader resourceLoader);\n\n\t@Autowired\n\tprivate Mapper mapper;\n\n}\n\nclass MapperTest {\n\n\t@Autowired\n\tprivate Mapper mapper;\n\n\t@Test\n\tpublic void shouldDetectAnnotationAndMapObjectToDTO() {\n", "reference": "\t\tMovieInfo m = new MovieInfo(\"Iron Man 3\", 2013, \"HD\");\n\t\tObject dto = mapper.map(m);\n\t\tassertTrue(dto instanceof Movie);\n\t\tassertEquals(\"Iron Man 3\", ((Movie)dto).getName());\n\t\tassertEquals(new Integer(2013), ((Movie)dto).getYear());\n\t\tassertEquals(Quality.HD, ((Movie)dto).getQuality());\n\t}\n\n}", "prediction": "\t\tUser user = new User();\n\t\tuser.setId(1L);\n\t\tuser.setName(\"John\");\n\t\tuser.setAge(20);\n\t\tuser.setEmail(\"john@gmail.com\");\n\t\tuser.setPassword(\"123456\");\n\t\tuser.setRoles(Arrays.asList(new Role(\"ROLE_USER\"), new Role(\"ROLE_ADMIN\")));\n\t\t\n\t\tUserDTO dto = mapper.map(user);\n\t\t\n\t\tassertThat(dto.getId()).isEqualTo(user.getId());\n\t\tassertThat(dto.getName()).isEqualTo(user.getName());\n\t\tassertThat(dto.getAge()).isEqualTo(user.getAge());\n\t\tassertThat(dto.getEmail()).isEqualTo(user.getEmail());\n\t\tassertThat(dto.getPassword()).isNull();\n\t\tassertThat(dto.getRoles()).containsExactly(\"ROLE_USER\", \"ROLE_ADMIN\");\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "5622726_23", "part": [1, 1], "seq": [1, 1], "prompt": "class StripHtmlSanitizer implements Sanitizer<String> {\n\n    @Override\n    public String execute(String content) {\n        if (StringUtils.isBlank(content)) {\n            return content;\n        }\n        Document document = Jsoup.parse(content);\n        document.outputSettings().escapeMode(Entities.EscapeMode.xhtml);\n        for (Element element : document.select(\"script,link,iframe,style\")) {\n            element.remove();\n        }\n        return document.text();\n    }\n\n    private static final String URL;\n\n}\n\nclass StripHtmlSanitizerTest {\n\n    private static final String URL;\n\n    @Test\n    public void testExecute() throws Exception {\n", "reference": "\n        StripHtmlSanitizer sanitizer = new StripHtmlSanitizer();\n\n        String html = IOUtils.toString(getClass().getResourceAsStream(\"StripHtmlSanitizerTest_dirty.html\"));\n\n        assertEquals(\"SPG Flights FAQs Home Frequently Asked Questions\", sanitizer.execute(html));\n    }\n\n}", "prediction": "        String content = \"<html><head><title>Test</title></head><body><p>Hello</p></body></html>\";\n        String result = new StripHtmlSanitizer().execute(content);\n        assertEquals(\"Hello\", result);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "5734199_1", "part": [1, 1], "seq": [1, 1], "prompt": "class AbstractDao implements CrudDao<T, ID> {\n\n  public ID getId(Object key) {\n    return mapper.fromKey(key);\n  }\n\n  protected  AbstractDao(Mapper<T, ID> mapper, Supplier<Object, Object, Object, Object> supplier);\n\n  public R withCommitTransaction(TransFunc<R> transFunc);\n  public R withRollbackTransaction(TransFunc<R> transFunc);\n  public R withTransaction(TransFunc<R> transFunc, boolean commit);\n  public static R withTransaction(TransFunc<R> transFunc, boolean commit, Supplier<Object, Object, Object, Object> supplier);\n  private static void pushTransaction(final Object transaction);\n  private static void popTransaction(final Object transaction);\n  private static Object getCurrentTransaction();\n  public int count();\n  @Override public int count(Object parentKey);\n  public void delete(ID id);\n  @Override public void delete(Object parentKey, ID id);\n  public void delete(Iterable<ID> ids);\n  public T get(ID id);\n  @Override public T get(Object parentKey, ID id);\n  @Override public ID put(Object parentKey, ID id, T entity);\n  public ID put(T entity);\n  @Override public ID insert(Object parentKey, ID id, T entity);\n  protected Iterable<T> queryByField(Object ancestorKey, String fieldName, Object fieldValue);\n  protected T queryUniqueByField(Object parentKey, String fieldName, Object fieldValue);\n  public CursorPage<T> queryPage(int requestedPageSize, String cursorString);\n  protected CursorPage<T> queryPageByField(Object parentKey, String fieldName, Object fieldValue, int requestedPageSize, String cursorString);\n  @Override public CursorPage<T> queryPage(Object ancestorKey, int requestedPageSize, String cursorString);\n  protected CursorPage<T> queryPage(boolean keysOnly, int requestedPageSize, Object ancestorKey,\n                          String primaryOrderBy, boolean primaryIsAscending,\n                          String secondaryOrderBy, boolean secondaryIsAscending,\n                          Collection<String> projections,\n                          String cursorString,\n                          Filter... filters);\n  protected Iterable<T> queryIterable(boolean keysOnly, int offset, int limit, Object ancestorKey,\n                                      String primaryOrderBy, boolean primaryIsAscending,\n                                      String secondaryOrderBy, boolean secondaryIsAscending,\n                                      Filter... filters);\n  public Future<T> getAsync(Object parentKey, ID id);\n  public Future<ID> putAsync(T entity);\n  public Object getKey(ID id);\n  public Object getKey(Object parentKey, ID id);\n  public String getKind();\n  public void setParentKey(T entity, Object parentKey);\n  public static void setPrincipalName(String name);\n  private void updateAuditInfo(final Object value);\n  protected void updateAuditInfo(final Object value, final String principalName, final Date date,\n                               final String createdByColumnName, final String createdDateColumnName,\n                               final String updatedByColumnName, final String updatedDateColumnName);\n\n  public static final String PRINCIPAL_FIXTURE;\n  public static final String PRINCIPAL_SET_UP;\n  protected DUserDaoBean userDao;\n  protected DFactoryDaoBean factoryDao;\n  protected Supplier supplier;\n\n}\n\nclass AbstractDaoTest {\n\n  public static final String PRINCIPAL_FIXTURE;\n  public static final String PRINCIPAL_SET_UP;\n  protected DUserDaoBean userDao;\n  protected DFactoryDaoBean factoryDao;\n  protected Supplier supplier;\n\n  @Test\n  public void testFindUniqueByField() throws IOException {\n", "reference": "    createQueryFixtures();\n\n    DUser u47 = userDao.findByEmail(null);\n    assertNull(u47);\n\n    u47 = userDao.findByEmail(\"user_47@example.com\");\n    assertEquals(Long.valueOf(47), u47.getId());\n    assertEquals(\"user_47@example.com\", u47.getEmail());\n  }\n\n}", "prediction": "    // given\n    final String name = \"testFindUniqueByField\";\n    final String email = \"testFindUniqueByField@example.com\";\n    final String password = \"testFindUniqueByField\";\n    final String principalName = \"testFindUniqueByField\";\n    final String principalPassword = \"testFindUniqueByField\";\n    final String principalEmail = \"testFindUniqueByField@example.com\";\n    final String principalPasswordHash = \"testFindUniqueByField\";\n    final String principalSalt = \"testFindUniqueByField\";\n    final String principalRole = \"testFindUniqueByField\";\n    final String principalStatus = \"testFindUniqueByField\";\n    final String principalCreatedBy = \"testFindUniqueByField\";\n    final Date principalCreatedDate = new Date();\n    final String principalUpdatedBy = \"testFindUniqueByField\";\n    final Date principalUpdatedDate = new Date();\n    final String principalDeletedBy = \"testFindUniqueByField\";\n    final Date principalDeletedDate = new Date();\n    final String principalDeletedReason = \"testFindUniqueByField\";\n    final String principalDeletedComment = \"testFindUniqueByField\";\n    final String principalDeletedStatus = \"testFindUniqueByField\";\n    final String principalDeletedStatusReason = \"testFindUniqueByField\";\n    final String principalDeletedStatusComment = \"testFindUniqueByField\";\n    final String principalDeletedStatusDeletedBy = \"testFindUniqueByField\";\n    final Date principalDeletedStatusDeletedDate = new Date();\n    final String principalDeletedStatusDeletedReason = \"testFindUniqueByField\";\n    final String principalDeletedStatusDeletedComment = \"testFindUniqueByField\";\n    final String principalDeletedStatusDeletedStatus = \"testFindUniqueByField\";\n    final String principalDeletedStatusDeletedStatusReason = \"testFindUniqueByField\";\n    final String principalDeletedStatusDeletedStatusComment = \"testFindUniqueByField\";\n    final String principalDeletedStatusDeletedStatusDeletedBy = \"testFindUniqueByField\";\n    final Date principalDeletedStatusDeletedStatusDeletedDate = new Date();\n    final String principalDeletedStatusDeletedStatusDeletedReason = \"testFindUniqueByField\";\n    final String principalDeletedStatusDeletedStatusDeletedComment = \"testFindUniqueByField\";\n    final String principalDeletedStatusDeletedStatusDeletedStatus = \"testFindUniqueByField\";\n    final String principalDeletedStatusDeletedStatusDeletedStatusReason = \"testFindUniqueByField\";\n    final String principalDeletedStatusDeletedStatusDeletedStatusComment = \"testFindUniqueByField\";\n    final String principalDeletedStatusDeletedStatusDeletedStatusDeletedBy = \"testFindUniqueByField\";\n    final Date principalDeletedStatusDeletedStatusDeletedStatusDeletedDate = new Date();\n    final String principalDeletedStatusDeletedStatusDeletedStatusDeletedReason = \"testFindUniqueByField\";\n    final String principalDeletedStatusDeletedStatusDeletedStatusDeletedComment = \"testFindUniqueByField\";\n    final String principalDeletedStatusDeletedStatusDeletedStatusDeletedStatus = \"testFindUniqueByField\";\n    final String principalDeletedStatusDeletedStatusDeletedStatusDeletedStatusReason = \"testFindUniqueByField\";\n    final String principalDeletedStatusDeletedStatusDeletedStatusDeletedStatusComment = \"testFindUniqueByField\";\n    final String principalDeletedStatusDeletedStatusDeletedStatusDeletedStatusDeletedBy = \"testFindUniqueByField\";\n    final Date principalDeletedStatusDeletedStatusDeletedStatusDeletedStatusDeletedDate = new Date();\n    final String principalDeletedStatus", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "5749899_1", "part": [1, 1], "seq": [1, 1], "prompt": "class ModClusterService implements ModClusterServiceMBean, ContainerEventHandler, LoadBalanceFactorProvider,\n        MCMPConnectionListener, ContextFilter {\n\n    @Override\n    public void stop(Server server) {\n        ModClusterLogger.LOGGER.stopServer();\n\n        if (this.established) {\n            for (Engine engine : server.getEngines()) {\n                for (Host host : engine.getHosts()) {\n                    for (Context context : host.getContexts()) {\n                        if (context.isStarted()) {\n                            this.stop(context);\n                        }\n\n                        this.remove(context);\n                    }\n                }\n\n                this.removeAll(engine);\n            }\n        }\n    }\n\n    public  ModClusterService(ModClusterConfiguration config, LoadBalanceFactorProvider loadBalanceFactorProvider);\n    public  ModClusterService(ModClusterConfig config, LoadBalanceFactorProvider loadBalanceFactorProvider);\n    public  ModClusterService(ModClusterConfig config, LoadBalanceFactorProviderFactory loadBalanceFactorProviderFactory);\n    private  ModClusterService(NodeConfiguration nodeConfig, BalancerConfiguration balancerConfig, MCMPHandlerConfiguration mcmpConfig, AdvertiseConfiguration advertiseConfig,\n                              LoadBalanceFactorProviderFactory loadBalanceFactorProviderFactory);\n    private  ModClusterService(NodeConfiguration nodeConfig, BalancerConfiguration balancerConfig, MCMPHandlerConfiguration mcmpConfig, AdvertiseConfiguration advertiseConfig,\n                              LoadBalanceFactorProviderFactory loadBalanceFactorProviderFactory, MCMPRequestFactory requestFactory);\n    private  ModClusterService(NodeConfiguration nodeConfig, BalancerConfiguration balancerConfig, MCMPHandlerConfiguration mcmpConfig, AdvertiseConfiguration advertiseConfig,\n                              LoadBalanceFactorProviderFactory loadBalanceFactorProviderFactory, MCMPRequestFactory requestFactory, MCMPResponseParser responseParser, ResetRequestSource resetRequestSource);\n    protected  ModClusterService(NodeConfiguration nodeConfig, BalancerConfiguration balancerConfig, MCMPHandlerConfiguration mcmpConfig, AdvertiseConfiguration advertiseConfig,\n                                LoadBalanceFactorProviderFactory loadBalanceFactorProviderFactory, MCMPRequestFactory requestFactory, MCMPResponseParser responseParser, ResetRequestSource resetRequestSource, MCMPHandler mcmpHandler, AdvertiseListenerFactory listenerFactory);\n\n    @Override public synchronized void init(Server server);\n    @Override public Set<String> getExcludedContexts(Host host);\n    @Override public boolean isAutoEnableContexts();\n    @Override public synchronized void shutdown();\n    @Override public void start(Server server);\n    protected void config(Engine engine);\n    @Override public boolean isEstablished();\n    @Override public void connectionEstablished(InetAddress localAddress);\n    protected void establishJvmRoute(Engine engine);\n    @Override public void add(Context context);\n    @Override public void start(Context context);\n    private void enable(Context context);\n    private void disable(Context context);\n    private boolean hasContextMultipleReferences(Context context);\n    @Override public void stop(Context context);\n    @Override public void remove(Context context);\n    protected void removeAll(Engine engine);\n    @Override public void status(Engine engine);\n    private boolean include(Context context);\n    @Override public int getLoadBalanceFactor(Engine engine);\n    @Override public void addProxy(String host, int port);\n    @Override public void removeProxy(String host, int port);\n    private InetSocketAddress createSocketAddress(String host, int port);\n    @Override public Map<InetSocketAddress, String> getProxyConfiguration();\n    @Override public Map<InetSocketAddress, String> getProxyInfo();\n    @Override public Map<InetSocketAddress, String> ping();\n    @Override public Map<InetSocketAddress, String> ping(String jvmRoute);\n    @Override public Map<InetSocketAddress, String> ping(String scheme, String host, int port);\n    private Map<InetSocketAddress, String> getProxyResults(MCMPRequest request);\n    @Override public void reset();\n    @Override public void refresh();\n    @Override public boolean disable();\n    @Override public boolean enable();\n    @Override public boolean disableContext(String host, String path);\n    @Override public boolean enableContext(String host, String path);\n    @Override public boolean stop(long timeout, TimeUnit unit);\n    @Override public boolean stopContext(String host, String path, long timeout, TimeUnit unit);\n    private boolean drainRequests(Context context, long start, long end);\n    private int stop(MCMPRequest request);\n    private boolean drainSessions(Context context, long start, long end);\n    private Host findHost(String name);\n    private Context findContext(Host host, String path);\n\n    private static final String SOME_PATH;\n\n}\n\nclass ModClusterServiceTest {\n\n    private static final String SOME_PATH;\n\n    @Test\n    public void stopSingleContext() {\n", "reference": "\n        MCMPHandler mcmpHandler = mock(MCMPHandler.class);\n        ModClusterService mod = createModClusterService(mcmpHandler);\n        Context context = createContext(SOME_PATH);\n        addInnerContexts(context, context);\n\n        mod.stop(context);\n\n        verify(mcmpHandler, times(2)).sendRequest(eq(null));\n    }\n\n}", "prediction": "        ModClusterService service = new ModClusterService(new ModClusterConfig(), new LoadBalanceFactorProviderFactory());\n        Server server = EasyMock.createMock(Server.class);\n        Engine engine = EasyMock.createMock(Engine.class);\n        Host host = EasyMock.createMock(Host.class);\n        Context context = EasyMock.createMock(Context.class);\n        EasyMock.expect(server.getEngines()).andReturn(Collections.singletonList(engine)).anyTimes();\n        EasyMock.expect(engine.getHosts()).andReturn(Collections.singletonList(host)).anyTimes();\n        EasyMock.expect(host.getContexts()).andReturn(Collections.singletonList(context)).anyTimes();\n        EasyMock.expect(context.getPath()).andReturn(SOME_PATH).anyTimes();\n        EasyMock.expect(context.isStarted()).andReturn(true).anyTimes();\n        EasyMock.expect(context.getState()).andReturn(State.STARTED).anyTimes();\n        EasyMock.expect(context.getEngine()).andReturn(engine).anyTimes();\n        EasyMock.expect(context.getHost()).andReturn(host).anyTimes();\n        EasyMock.expect(context.getWorker()).andReturn(null).anyTimes();\n        EasyMock.expect(context.getWorkerName()).andReturn(null).anyTimes();\n        EasyMock.expect(context.getWorkerProperties()).andReturn(null).anyTimes();\n        EasyMock.expect(context.getWorkerProperties()).andReturn(null).anyTimes();\n        EasyMock.expect(context.getWorkerState()).andReturn(null).anyTimes();\n        EasyMock.expect(context.getWorkerState()).andReturn(null).anyTimes();\n        EasyMock.expect(context.getWorkerState()).andReturn(null).anyTimes();\n        EasyMock.expect(context.getWorkerState()).andReturn(null).anyTimes();\n        EasyMock.expect(context.getWorkerState()).andReturn(null).anyTimes();\n        EasyMock.expect(context.getWorkerState()).andReturn(null).anyTimes();\n        EasyMock.expect(context.getWorkerState()).andReturn(null).anyTimes();\n        EasyMock.expect(context.getWorkerState()).andReturn(null).anyTimes();\n        EasyMock.expect(context.getWorkerState()).andReturn(null).anyTimes();\n        EasyMock.expect(context.getWorkerState()).andReturn(null).anyTimes();\n        EasyMock.expect(context.getWorkerState()).andReturn(null).anyTimes();\n        EasyMock.expect(context.getWorkerState()).andReturn(null).anyTimes();\n        EasyMock.expect(context.getWorkerState()).andReturn(null).anyTimes();\n        EasyMock.expect(context.getWorkerState()).andReturn(null).anyTimes();\n        EasyMock.expect(context.getWorkerState()).andReturn(null).anyTimes();\n        EasyMock.expect(context.getWorkerState()).andReturn(null).anyTimes();\n        EasyMock.expect(context.getWorkerState()).andReturn(null).anyTimes();\n        EasyMock.expect(context.getWorkerState()).andReturn(null).anyTimes();\n        EasyMock.expect(context.getWorkerState()).andReturn(null).anyTimes();\n        EasyMock.expect(context.getWorkerState()).andReturn(null).anyTimes();\n        EasyMock.expect(context.getWorkerState()).andReturn(null).anyTimes();\n        EasyMock.expect(context.getWorkerState()).andReturn(null).anyTimes();\n        EasyMock.expect(context.getWorkerState()).", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "5869462_7", "part": [1, 1], "seq": [1, 1], "prompt": "class QuarterlyPeriod implements Period {\n\n\t@Override\n\tpublic Date getEndDate() {\n\t\treturn endDate;\n\t}\n\n\tpublic  QuarterlyPeriod(Date date);\n\n\t@Override public void setStartDate(Date startDate);\n\t@Override public void setEndDate(Date endDate);\n\t@Override public Date getStartDate();\n\t@Override public String getAsIsoString();\n\n}\n\nclass QuarterlyPeriodTest {\n\n\t@Test\n\tpublic void testGetEndLastQuarter() throws ParseException {\n", "reference": "\t\tQuarterlyPeriod instance = new QuarterlyPeriod(new SimpleDateFormat(\n\t\t\t\t\"yyyy-MM-dd\").parse(\"2012-10-19\"));\n\t\tDate expResult = new SimpleDateFormat(\"yyyy-MM-dd\").parse(\"2013-01-01\");\n\t\tlong time = expResult.getTime() - 1;\n\t\texpResult.setTime(time);\n\n\t\tDate result = instance.getEndDate();\n\t\tassertEquals(expResult, result);\n\t}\n\n}", "prediction": "\t\tDate date = new SimpleDateFormat(\"yyyy-MM-dd\").parse(\"2014-01-01\");\n\t\tQuarterlyPeriod period = new QuarterlyPeriod(date);\n\t\tassertEquals(new SimpleDateFormat(\"yyyy-MM-dd\").parse(\"2013-12-31\"), period.getEndDate());\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "6311816_0", "part": [1, 1], "seq": [1, 1], "prompt": "class PropertyStack {\n\n\tpublic String resolvePropertyValue (String value) {\n\t\tList<Chunk> props = parseValue(value);\n\t\treturn resolvePropertyValue (props);\n\t}\n\n\t  PropertyStack();\n\n\tpublic Properties getProperties();\n\tpublic void setProperties(Properties properties);\n\tpublic void addProperty(String name, String value);\n\tprivate String resolvePropertyValue(List<Chunk> chunks);\n\t List<Chunk> parseValue(String value);\n\tprivate Chunk searchNextChunk(String rawString);\n\n\tpublic static final String sample;\n\tpublic static final String sampleValue;\n\tpublic static final String sampleCorrectResult;\n\tpublic static final String bonjour;\n\tpublic static final String bonjourResult;\n\tpublic static final String bonsoir;\n\tpublic static final String bonsoirResult;\n\t PropertyStack propertyStack;\n\n}\n\nclass PropertyStackTest {\n\n\tpublic static final String sample;\n\tpublic static final String sampleValue;\n\tpublic static final String sampleCorrectResult;\n\tpublic static final String bonjour;\n\tpublic static final String bonjourResult;\n\tpublic static final String bonsoir;\n\tpublic static final String bonsoirResult;\n\t PropertyStack propertyStack;\n\n\t@Test\n\tpublic void testPropertyStackParser () {\n", "reference": "\t\tString input = \"test${helloValue}\";\n\t\tString correctResult = \"testHello\";\n\t\tString result = propertyStack.resolvePropertyValue (input);\n\t\tAssert.assertTrue (result.equals(correctResult));\n\t\ttestPropertyStackParser(\"${helloValue}${bonjourValue}\", \"HelloBonjour\");\n\t\ttestPropertyStackParser(\"B${bonsoirValue}XX${bonjourValue}Z\", \"BBonSOIRXXBonjourZ\");\n\t}\n\n}", "prediction": "\t\tString result = propertyStack.resolvePropertyValue(sampleValue);\n\t\tassertEquals(sampleCorrectResult, result);\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "6354623_4", "part": [1, 1], "seq": [1, 1], "prompt": "class CollectionMethod {\n\n    public static <K, V> Map<K, V> recursive(Map<K, V> map) {\n        Map<K, V> result = new HashMap<K, V>();\n        _recursive(result, map);\n        return result;\n    }\n\n    private  CollectionMethod();\n\n    public static ListCycle<T> toCycle(Collection<T> values);\n    public static ArrayCycle<T> toCycle(T[] values);\n    public static BooleanArrayCycle toCycle(boolean[] values);\n    public static CharArrayCycle toCycle(char[] values);\n    public static ByteArrayCycle toCycle(byte[] values);\n    public static ShortArrayCycle toCycle(short[] values);\n    public static IntArrayCycle toCycle(int[] values);\n    public static LongArrayCycle toCycle(long[] values);\n    public static FloatArrayCycle toCycle(float[] values);\n    public static DoubleArrayCycle toCycle(double[] values);\n    public static int length(Map<?, ?> values);\n    public static int length(Collection<?> values);\n    public static int length(Object[] values);\n    public static int length(boolean[] values);\n    public static int length(char[] values);\n    public static int length(byte[] values);\n    public static int length(short[] values);\n    public static int length(int[] values);\n    public static int length(long[] values);\n    public static int length(float[] values);\n    public static int length(double[] values);\n    public static Map<K, V> sort(Map<K, V> map);\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"}) public static List<T> sort(List<T> list);\n    public static Set<T> sort(Set<T> set);\n    public static Collection<T> sort(Collection<T> set);\n    public static T[] sort(T[] array);\n    public static char[] sort(char[] array);\n    public static byte[] sort(byte[] array);\n    public static short[] sort(short[] array);\n    public static int[] sort(int[] array);\n    public static long[] sort(long[] array);\n    public static float[] sort(float[] array);\n    public static double[] sort(double[] array);\n    @SuppressWarnings(\"unchecked\") private static void _recursive(Map<K, V> result, Map<K, V> map);\n    public static List<T> recursive(Collection<T> set);\n    @SuppressWarnings(\"unchecked\") private static void _recursive(Collection<T> result, Collection<T> set);\n    public static List<T> recursive(Collection<T> set, String children);\n    public static List<T> recursive(T node, String children);\n    @SuppressWarnings(\"unchecked\") private static void _recursive(Collection<T> result, T node, String children);\n\n}\n\nclass CollectionMethodTest {\n\n\t@Test\n\tpublic void testRecursiveMap() throws Exception {\n", "reference": "\t\tMap<String, Object> children = new HashMap<String, Object>();\n\t\tchildren.put(\"4\", \"x\");\n\t\tchildren.put(\"5\", \"y\");\n\t\tchildren.put(\"6\", \"z\");\n\t\t\n\t\tMap<String, Object> parent = new HashMap<String, Object>();\n\t\tparent.put(\"1\", \"a\");\n\t\tparent.put(\"children\", children);\n\t\tparent.put(\"2\", \"b\");\n\t\tparent.put(\"3\", \"c\");\n\t\t\n\t\tMap<String, Object> result = CollectionMethod.recursive(parent);\n\t\t\n\t\tAssert.assertEquals(6, result.size());\n\t\tAssert.assertEquals(\"a\", result.get(\"1\"));\n\t\tAssert.assertEquals(\"x\", result.get(\"4\"));\n\t\tAssert.assertEquals(\"y\", result.get(\"5\"));\n\t\tAssert.assertEquals(\"z\", result.get(\"6\"));\n\t\tAssert.assertEquals(\"b\", result.get(\"2\"));\n\t\tAssert.assertEquals(\"c\", result.get(\"3\"));\n\t}\n\n}", "prediction": "\t\tMap<String, String> map = new HashMap<String, String>();\n\t\tmap.put(\"a\", \"1\");\n\t\tmap.put(\"b\", \"2\");\n\t\tmap.put(\"c\", \"3\");\n\t\tmap.put(\"d\", \"4\");\n\t\tmap.put(\"e\", \"5\");\n\t\tmap.put(\"f\", \"6\");\n\t\tmap.put(\"g\", \"7\");\n\t\tmap.put(\"h\", \"8\");\n\t\tmap.put(\"i\", \"9\");\n\t\tmap.put(\"j\", \"10\");\n\t\tMap<String, String> result = CollectionMethod.recursive(map);\n\t\tassertEquals(result.size(), 10);\n\t\tassertEquals(result.get(\"a\"), \"1\");\n\t\tassertEquals(result.get(\"b\"), \"2\");\n\t\tassertEquals(result.get(\"c\"), \"3\");\n\t\tassertEquals(result.get(\"d\"), \"4\");\n\t\tassertEquals(result.get(\"e\"), \"5\");\n\t\tassertEquals(result.get(\"f\"), \"6\");\n\t\tassertEquals(result.get(\"g\"), \"7\");\n\t\tassertEquals(result.get(\"h\"), \"8\");\n\t\tassertEquals(result.get(\"i\"), \"9\");\n\t\tassertEquals(result.get(\"j\"), \"10\");\n\t}", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "6426667_8", "part": [1, 1], "seq": [1, 1], "prompt": "class EventToString {\n\n    public static String format(String className, String methodName, Object... args) {\n        return new EventToString(Charset.defaultCharset())\n                .formatMethodCall(className, methodName, args)\n                .build();\n    }\n\n    public  EventToString(Charset charset);\n\n    public String build();\n    public EventToString formatMethodCall(String className, String methodName, Object... args);\n    private void formatArg(Object arg);\n     EventToString escapeSpecialChars(String arg);\n    private void escapeSpecialChar(char ch);\n    private boolean isUnmappable(char ch);\n\n}\n\nclass EventToStringTest {\n\n    @Test\n    public void does_not_crash_to_null_arguments() {\n", "reference": "        assertThat(EventToString.format(\"TheClass\", \"theMethod\", (Object) null), is(\"TheClass.theMethod(null)\"));\n    }\n\n}", "prediction": "        EventToString.format(\"foo\", \"bar\", null);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "6488635_23", "part": [1, 1], "seq": [1, 1], "prompt": "class OSimpleKeyIndexDefinition extends ODocumentWrapperNoClass implements OIndexDefinition {\n\n  public OType[] getTypes() {\n    return keyTypes;\n  }\n\n  public  OSimpleKeyIndexDefinition(final OType... keyTypes);\n  public  OSimpleKeyIndexDefinition();\n\n  public List<String> getFields();\n  public List<String> getFieldsToIndex();\n  public String getClassName();\n  public Comparable<?> createValue(final List<?> params);\n  public Comparable<?> createValue(final Object... params);\n  public int getParamCount();\n  @Override public ODocument toStream();\n  @Override protected void fromStream();\n  public Object getDocumentValueToIndex(final ODocument iDocument);\n  @Override public boolean equals(final Object o);\n  @Override public int hashCode();\n  @Override public String toString();\n  public String toCreateIndexDDL(final String indexName, final String indexType);\n\n  private OSimpleKeyIndexDefinition simpleKeyIndexDefinition;\n\n}\n\nclass OSimpleKeyIndexDefinitionTest {\n\n  private OSimpleKeyIndexDefinition simpleKeyIndexDefinition;\n\n  @Test\n  public void testGetKeyTypes() {\n", "reference": "    Assert.assertEquals(simpleKeyIndexDefinition.getTypes(), new OType[] { OType.INTEGER, OType.STRING });\n  }\n\n}", "prediction": "    assertEquals(simpleKeyIndexDefinition.getTypes(), new OType[] { OType.STRING });\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "6639766_0", "part": [1, 1], "seq": [1, 1], "prompt": "class DefaultPagerModel implements PagerModel {\n\n\tpublic Collection<Integer> getPages(int currentPage, int pageCount) {\n\t\tSet<Integer> pages = new TreeSet<Integer>();\n\t\t\n\t\t// we will always display the same number of pages\n\t\tint requiredPages = minStartPages + minEndPages + 1 + (currentBuffer * 2);\n\n\t\tif (pageCount <= requiredPages) {\n\t\t\taddPages(pages, 1, pageCount, 1);\n\t\t} else {\n\t\t\tint bufferPages = 1 + (currentBuffer * 2);\n\t\t\taddPages(pages, 1, minStartPages, 1);\n\t\t\taddPages(pages, pageCount, minEndPages, -1);\n\t\t\tif (currentPage <= minStartPages) {\n\t\t\t\t// currentPage is within startPages\n\t\t\t\t// add extra pages to the start\n\t\t\t\taddPages(pages, minStartPages + 1, bufferPages, 1);\n\t\t\t} else if (currentPage >= pageCount - minEndPages) {\n\t\t\t\t// currentPage is within the endPages\n\t\t\t\t// add extra pages to the end\n\t\t\t\taddPages(pages, pageCount - minEndPages, bufferPages, -1);\n\t\t\t} else {\n\t\t\t\t// add buffer pages around currentPage\n\t\t\t\tint start = Math.max(minStartPages + 1, currentPage - currentBuffer);\n\t\t\t\taddPages(pages, start, bufferPages, 1);\n\t\t\t}\n\t\t}\n\t\treturn pages;\n\t}\n\n\tpublic  DefaultPagerModel(int minEndPages, int currentBuffer, int nextPrevThreshold);\n\tpublic  DefaultPagerModel(int minStartPages, int minEndPages, int currentBuffer, int prevThreshold, int nextThreshold);\n\n\tprivate void addPages(Set<Integer> pages, int start, int count, int increment);\n\tpublic boolean isShowNext(int currentPage, int pageCount);\n\tpublic boolean isShowPrevious(int currentPage, int pageCount);\n\n}\n\nclass DefaultPagerModelTest {\n\n\t@Test\n\tpublic void testGetPages() {\n", "reference": "\t\tDefaultPagerModel pagerModel = new DefaultPagerModel(2, 2, 1, 2, 2);\n\n\t\tassertPages(new int[] {1,2,3,4,5,9,10}, pagerModel.getPages(1, 10));\n\t\tassertPages(new int[] {1,2,3,4,5,9,10}, pagerModel.getPages(2, 10));\n\t\tassertPages(new int[] {1,2,3,4,5,9,10}, pagerModel.getPages(3, 10));\n\t\tassertPages(new int[] {1,2,3,4,5,9,10}, pagerModel.getPages(4, 10));\n\t\tassertPages(new int[] {1,2,4,5,6,9,10}, pagerModel.getPages(5, 10));\n\t\tassertPages(new int[] {1,2,5,6,7,9,10}, pagerModel.getPages(6, 10));\n\t\tassertPages(new int[] {1,2,6,7,8,9,10}, pagerModel.getPages(7, 10));\n\t\tassertPages(new int[] {1,2,6,7,8,9,10}, pagerModel.getPages(8, 10));\n\t\tassertPages(new int[] {1,2,6,7,8,9,10}, pagerModel.getPages(9, 10));\n\t\tassertPages(new int[] {1,2,6,7,8,9,10}, pagerModel.getPages(10, 10));\n\t}\n\n}", "prediction": "\t\tPagerModel model = new DefaultPagerModel(1, 1, 1);\n\t\tassertEquals(model.getPages(1, 10), Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));\n\t\tassertEquals(model.getPages(1, 100), Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100));\n\t\tassertEquals(model.getPages(100, 100), Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100));\n\t\tassertEquals(model.getPages(100, 101), Arrays.asList(1, 2, 3, 4, 5", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "6766558_64", "part": [1, 1], "seq": [1, 1], "prompt": "class HystrixCommandProperties {\n\n    public HystrixProperty<Boolean> circuitBreakerForceClosed() {\n        return circuitBreakerForceClosed;\n    }\n\n    protected  HystrixCommandProperties(HystrixCommandKey key);\n    protected  HystrixCommandProperties(HystrixCommandKey key, HystrixCommandProperties.Setter builder);\n    protected  HystrixCommandProperties(HystrixCommandKey key, HystrixCommandProperties.Setter builder, String propertyPrefix);\n\n    public HystrixProperty<Boolean> circuitBreakerEnabled();\n    public HystrixProperty<Integer> circuitBreakerErrorThresholdPercentage();\n    public HystrixProperty<Boolean> circuitBreakerForceOpen();\n    public HystrixProperty<Integer> circuitBreakerRequestVolumeThreshold();\n    public HystrixProperty<Integer> circuitBreakerSleepWindowInMilliseconds();\n    public HystrixProperty<Integer> executionIsolationSemaphoreMaxConcurrentRequests();\n    public HystrixProperty<ExecutionIsolationStrategy> executionIsolationStrategy();\n    public HystrixProperty<Boolean> executionIsolationThreadInterruptOnTimeout();\n    public HystrixProperty<Boolean> executionIsolationThreadInterruptOnFutureCancel();\n    public HystrixProperty<String> executionIsolationThreadPoolKeyOverride();\n    @Deprecated //prefer {@link #executionTimeoutInMilliseconds} public HystrixProperty<Integer> executionIsolationThreadTimeoutInMilliseconds();\n    public HystrixProperty<Integer> executionTimeoutInMilliseconds();\n    public HystrixProperty<Boolean> executionTimeoutEnabled();\n    public HystrixProperty<Integer> fallbackIsolationSemaphoreMaxConcurrentRequests();\n    public HystrixProperty<Boolean> fallbackEnabled();\n    public HystrixProperty<Integer> metricsHealthSnapshotIntervalInMilliseconds();\n    public HystrixProperty<Integer> metricsRollingPercentileBucketSize();\n    public HystrixProperty<Boolean> metricsRollingPercentileEnabled();\n    public HystrixProperty<Integer> metricsRollingPercentileWindow();\n    public HystrixProperty<Integer> metricsRollingPercentileWindowInMilliseconds();\n    public HystrixProperty<Integer> metricsRollingPercentileWindowBuckets();\n    public HystrixProperty<Integer> metricsRollingStatisticalWindowInMilliseconds();\n    public HystrixProperty<Integer> metricsRollingStatisticalWindowBuckets();\n    public HystrixProperty<Boolean> requestCacheEnabled();\n    public HystrixProperty<Boolean> requestLogEnabled();\n    private static HystrixProperty<Boolean> getProperty(String propertyPrefix, HystrixCommandKey key, String instanceProperty, Boolean builderOverrideValue, Boolean defaultValue);\n    private static HystrixProperty<Integer> getProperty(String propertyPrefix, HystrixCommandKey key, String instanceProperty, Integer builderOverrideValue, Integer defaultValue);\n    @SuppressWarnings(\"unused\") private static HystrixProperty<String> getProperty(String propertyPrefix, HystrixCommandKey key, String instanceProperty, String builderOverrideValue, String defaultValue);\n    private static HystrixProperty<ExecutionIsolationStrategy> getProperty(final String propertyPrefix, final HystrixCommandKey key, final String instanceProperty, final ExecutionIsolationStrategy builderOverrideValue, final ExecutionIsolationStrategy defaultValue);\n    public static Setter Setter();\n    public static Setter defaultSetter();\n\n}\n\nclass HystrixCommandPropertiesTest {\n\n    @Test\n    public void testBooleanInstanceBuilderOverrideOfGlobalDynamicOverride1() throws Exception {\n", "reference": "        HystrixCommandProperties properties = new TestPropertiesCommand(TestKey.TEST,\n                new HystrixCommandProperties.Setter().withCircuitBreakerForceClosed(true), \"unitTestPrefix\");\n        ConfigurationManager.getConfigInstance().setProperty(\"unitTestPrefix.command.default.circuitBreaker.forceClosed\", false);\n\n        // the builder injected should take precedence over the global dynamic property\n        assertEquals(true, properties.circuitBreakerForceClosed().get());\n\n        // cleanup \n        ConfigurationManager.getConfigInstance().clearProperty(\"unitTestPrefix.command.default.circuitBreaker.forceClosed\");\n    }\n\n}", "prediction": "        HystrixCommandProperties.Setter builder = HystrixCommandProperties.Setter()\n                .withCircuitBreakerForceOpen(true);\n        HystrixCommandProperties properties = new HystrixCommandProperties(HystrixCommandKey.Factory.asKey(\"TestCircuitBreakerForceOpen\"), builder);\n        assertTrue(properties.circuitBreakerForceOpen().get());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "6861229_2", "part": [1, 1], "seq": [1, 1], "prompt": "class ConfigCapability extends CapabilitySupport implements Capability,\n\t\tConfigEntry {\n\n\tprivate boolean isSnapshot(final String path) {\n\t\treturn path.contains(\"-SNAPSHOT/\");\n\t}\n\n\t@Inject public  ConfigCapability( //\n\t\t\tfinal CarrotMailer mailer, //\n\t\t\tfinal AmazonFactory amazonFactory, //\n\t\t\t@Named(\"base\") final Reporter reporter, //\n\t\t\t@Named(\"maven2\") final GavCalculator calculator, //\n\t\t\tfinal CapabilityRegistry capaRegistry, //\n\t\t\tfinal NexusIsActiveCondition nexusCondition, //\n\t\t\tfinal TaskManager scannerManager, //\n\t\t\tfinal RepositoryRegistry repoRegistry, //\n\t\t\tfinal EventBus eventBus, //\n\t\t\tfinal ConditionFactory conditionFactory //\n\t);\n\n\t@Override public String configId();\n\t@Override public ConfigState configState();\n\t@Override public boolean isConfigState(final ConfigState state);\n\t@Override public AmazonService amazonService();\n\t@Override public String comboId();\n\tprivate void includePattern(final ConfigBean configBean);\n\tprivate void excludePattern(final ConfigBean configBean);\n\tprivate Pattern excludeCustom(final String pattern);\n\tprivate boolean isRelease(final String path);\n\t@Override public boolean isExcluded(final String path);\n\t@Override public Set<Report> reportSubscribeSet();\n\tprivate void reportSubscribeSet(final String reportText);\n\t@Override public boolean isSubscribed(final Report report);\n\tprivate void reportEmailList(final String addressText);\n\t@Override public List<String> reportEmailList();\n\t@Override public String status();\n\tprivate void configState(final ConfigState configState);\n\tprotected boolean isActive();\n\tprotected boolean isEnabled();\n\t@Override public void onCreate();\n\t@Override public void onLoad();\n\t@Override public void onUpdate();\n\t@Override public void onRemove();\n\t@Override public void onActivate();\n\t@Override public void onPassivate();\n\tprivate String repoName();\n\tprivate Repository repo();\n\t@Override public String description();\n\t@Override public Condition activationCondition();\n\n\tprotected final Logger log;\n\n}\n\nclass TestConfigCapability {\n\n\tprotected final Logger log;\n\n\t@Test\n\tpublic void testGAV() {\n", "reference": "\n\t\tfinal M2GavCalculator calc = new M2GavCalculator();\n\n\t\t{\n\t\t\tfinal String path = \"/junit/junit/3.8.1/junit-3.8.1.pom\";\n\t\t\tfinal Gav gav = calc.pathToGav(path);\n\t\t\tlog(path, gav);\n\t\t\tassertFalse(gav.isSnapshot());\n\t\t}\n\n\t\t{\n\t\t\tfinal String path = \"junit/junit/1.4.3-SNAPSHOT/junit-1.4.3-20120912.150156-11.pom\";\n\t\t\tfinal Gav gav = calc.pathToGav(path);\n\t\t\tlog(path, gav);\n\t\t\tassertTrue(gav.isSnapshot());\n\t\t}\n\n\t\t{\n\t\t\tfinal String path = \"junit/junit/1.4.3-SNAPSHOT/junit-1.4.3-SNAPSHOT.pom\";\n\t\t\tfinal Gav gav = calc.pathToGav(path);\n\t\t\tlog(path, gav);\n\t\t\tassertTrue(gav.isSnapshot());\n\t\t}\n\n\t\t{\n\t\t\tfinal String path = \"junit/junit/hello/junit-1.4.3-SNAPSHOT.pom\";\n\t\t\tfinal Gav gav = calc.pathToGav(path);\n\t\t\tlog(path, gav);\n\t\t\tassertNull(gav);\n\t\t}\n\n\t\t{\n\t\t\tfinal String path = \"/.nexus/junit/junit/3.8.1/junit-3.8.1.pom\";\n\t\t\tfinal Gav gav = calc.pathToGav(path);\n\t\t\tlog(path, gav);\n\t\t\tassertNotNull(gav);\n\t\t}\n\n\t\t{\n\t\t\tfinal String path = \"/junit/junit/3.8.1/junit-3.8.1.pom.sha1\";\n\t\t\tfinal Gav gav = calc.pathToGav(path);\n\t\t\tlog(path, gav);\n\t\t\tassertTrue(gav.isHash());\n\t\t}\n\n\t\t{\n\t\t\tfinal String path = \"/junit/junit/3.8.1/junit-3.8.1.pom.md5\";\n\t\t\tfinal Gav gav = calc.pathToGav(path);\n\t\t\tlog(path, gav);\n\t\t\tassertTrue(gav.isHash());\n\t\t\tassertFalse(gav.isSnapshot());\n\t\t}\n\n\t\t{\n\t\t\tfinal String path = \"/junit/junit/3.8.1-SNAPSHOT/junit-3.8.1-SNAPSHOT.pom.asc\";\n\t\t\tfinal Gav gav = calc.pathToGav(path);\n\t\t\tlog(path, gav);\n\t\t\tassertTrue(gav.isSignature());\n\t\t\tassertTrue(gav.isSnapshot());\n\t\t}\n\n\t\t{\n\t\t\tfinal String path = \"/\";\n\t\t\tfinal Gav gav = calc.pathToGav(path);\n\t\t\tlog(path, gav);\n\t\t\tassertNull(gav);\n\t\t}\n\n\t\t{\n\t\t\tfinal String path = \"jboss-releases-thirdparty/esper/esper/2.2.0-JBoss-Nightly/esper-2.2.0-JBoss-Nightly.jar\";\n\t\t\tfinal Gav gav = calc.pathToGav(path);\n\t\t\tlog(path, gav);\n\t\t\tassertNotNull(gav);\n\t\t}\n\n\t}\n\n}", "prediction": "\t\tfinal String gav = \"com.carrotgarden.nexus:carrot-nexus-publisher:1.0.0-SNAPSHOT\";\n\t\tfinal String path = \"com/carrotgarden/nexus/carrot-nexus-publisher/1.0.0-SNAPSHOT/carrot-nexus-publisher-1.0.0-SNAPSHOT.jar\";\n\t\tfinal String gav2 = \"com.carrotgarden.nexus:carrot-nexus-publisher:1.0.0\";\n\t\tfinal String path2 = \"com/carrotgarden/nexus/carrot-nexus-publisher/1.0.0/carrot-nexus-publisher-1.0.0.jar\";\n\t\tAssert.assertEquals(gav, ConfigCapability.gav(path));\n\t\tAssert.assertEquals(gav2, ConfigCapability.gav(path2));\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "6888625_27", "part": [1, 1], "seq": [1, 1], "prompt": "class TemplateResource {\n\n\tprotected void orphanOriginalStormTemplate(String originalTemplateId, ItemManager itemMan) {\n\t\t//can only orphan the original if there was an original\n\t\tif (!StringUtils.isEmpty(originalTemplateId)) {\n\t\t\tItem originalTemplate = itemMan.load(originalTemplateId);\n\t\t\tif (null == originalTemplate) {\n\t\t\t\tthrow new EntityNotFoundException(String.format(\n\t\t\t\t\t\"Could not find template with ID '%s'. \"\n\t\t\t\t\t+ \"Perhaps the template Item was deleted \"\n\t\t\t\t\t+ \"between the time it was persisted and the time it was read?\",\n\t\t\t\t\toriginalTemplateId));\n\t\t\t} else {\n\t\t\t\t//only orphan original template if it was a storm template\n\t\t\t\tif (Type.storms.equals(originalTemplate.getType())) {\n\t\t\t\t\tboolean success = itemMan.orphan(originalTemplate);\n\t\t\t\t\tif (!success) {\n\t\t\t\t\t\tthrow new PersistenceException(\n\t\t\t\t\t\t\tString.format(\n\t\t\t\t\t\t\t\t\"Could not orphan template with ID '%s'\",\n\t\t\t\t\t\t\t\toriginalTemplateId\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@GET @Path(\"/item/{id}\") @Produces(MediaType.APPLICATION_JSON) public Response getTemplate(@PathParam(\"id\") String id, @Context Request request);\n\tpublic Response instantiateTemplate(Document metadataXml, ParsedMetadata parsedMetadata, String id, String content);\n\tprotected String updateStormAlias(String alias, AliasManager aliasMan, String templateId);\n\tprotected Response instantiateStormAndHandleResponse(Document metadataXml, ParsedMetadata parsedMetadata, String templateId, String childJson, String alias, boolean active, AliasManager aliasMan, ItemManager itemMan);\n\tprotected void hoistNewTemplateToTopLevel(String newTemplateId, ItemManager itemMan);\n\tprotected List<Service> getCopyOfServices(Layer layer);\n\t@POST @Path(\"/storm\") @Produces(MediaType.APPLICATION_JSON) @ConfiguredRolesAllowed(ConfiguredRolesAllowedDynamicFeature.CCH_ADMIN_USER_PROP) public Response instantiateStormTemplate(\n\t\t\t@FormDataParam(\"layerId\") String layerId,\n\t\t\t@FormDataParam(\"activeStorm\") String active,\n\t\t\t@FormDataParam(\"alias\") String alias,\n\t\t\t@FormDataParam(\"copyType\") String copyType,\n\t\t\t@FormDataParam(\"copyVal\") String copyVal,\n\t\t\t@FormDataParam(\"trackId\") String trackId,\n\t\t\t@FormDataParam(\"file\") String metadataFile);\n\tprivate Item baseTemplateItem(boolean active, Bbox bbox, List<Service> serviceCopies, Summary summary);\n\tprivate Summary copyExistingSummary(String copyType, String copyVal, ItemManager itemMan, AliasManager aliasMan);\n\tprivate boolean parseAllAttribute(JsonObject parent);\n\tprivate boolean retainAggregations(JsonObject parent);\n\tprivate List<Item> makeItemsFromDocument(Document metadataXml, ParsedMetadata parsedMetadata, Item template, JsonArray children, Map<String, Item> childMap, ItemManager itemMan, LayerManager layerMan);\n\tprivate List<Item> makeItemsFromLayer(Document metadataXml, ParsedMetadata parsedMetadata, Item template, String layerId, LayerManager layerMan);\n\tprivate Item templateItem(Item template, String attr, Layer layer, Summary summary);\n\tprivate Summary makeChildSummary(Document metadataXml, ParsedMetadata parsedMetadata, String attr);\n\tprivate Map<String, Item> makeChildItemMap(List<Item> children);\n\tprivate List<String> makeDisplayedChildren(List<Item> children);\n\tprotected Summary gatherTemplateSummary(Summary previousSummary, List<Item> children);\n\tprotected Set<String> keywordsFromString(String keywords);\n\tprivate List<Item> findItemsToRetain(Item template, boolean retainAggregations);\n\tprivate List<String> visibleItems(JsonArray children, List<Item> items, Map<String, Item> existing);\n\n\tprivate TemplateResource instance;\n\tprivate ItemManager mockItemMan;\n\tprivate AliasManager mockAliasMan;\n\n}\n\nclass TemplateResourceTest {\n\n\tprivate TemplateResource instance;\n\tprivate ItemManager mockItemMan;\n\tprivate AliasManager mockAliasMan;\n\n\t@Test\n\tpublic void testThatSuccessfulItemManagerOrphaningThrowsNoException() {\n", "reference": "\t\tString id = \"foo\";\n\t\tItem item = new Item();\n\t\titem.setType(Type.storms);\n\t\t\n\t\t//simulate Item being present in DB\n\t\twhen(mockItemMan.load(id)).thenReturn(item);\n\t\t//simulate success orphaning item\n\t\twhen(mockItemMan.orphan(item)).thenReturn(true);\n\t\tinstance.orphanOriginalStormTemplate(id, mockItemMan);\n\t\tverify(mockItemMan).orphan(eq(item));\n\t}\n\n}", "prediction": "\t\t//arrange\n\t\tString originalTemplateId = \"originalTemplateId\";\n\t\tItem originalTemplate = new Item();\n\t\toriginalTemplate.setId(originalTemplateId);\n\t\toriginalTemplate.setType(Type.storms);\n\t\twhen(mockItemMan.load(originalTemplateId)).thenReturn(originalTemplate);\n\t\twhen(mockItemMan.orphan(originalTemplate)).thenReturn(true);\n\n\t\t//act\n\t\tinstance.orphanOriginalStormTemplate(originalTemplateId, mockItemMan);\n\n\t\t//assert\n\t\tverify(mockItemMan).load(originalTemplateId);\n\t\tverify(mockItemMan).orphan(originalTemplate);\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "7184464_8", "part": [1, 1], "seq": [1, 1], "prompt": "class JsonLayout extends JsonLayoutBase<IAccessEvent> {\n\n    public JsonLayout() {\n        super();\n        this.includeRemoteAddr = true;\n        this.includeRemoteUser = true;\n        this.includeRequestTime = true;\n        this.includeRequestURI = true;\n        this.includeStatusCode = true;\n        this.includeMethod = true;\n        this.includeProtocol = true;\n        this.includeRequestURL = false;\n        this.includeContentLength = false;\n        this.includeRemoteHost = true;\n        this.includeServerName = true;\n        this.includeRequestHeader = true;\n        this.includeRequestParameter = true;\n        this.includeLocalPort = false;\n        this.includeRequestContent = false;\n        this.includeResponseContent = false;\n    }\n\n    public  JsonLayout();\n\n    @Override protected Map toJsonMap(IAccessEvent event);\n    protected void addRequestTime(long requestTime, Map<String, Object> map);\n    protected void addInt(String key, boolean field, int intValue, Map<String, Object> map);\n    public boolean isIncludeRemoteAddr();\n    public void setIncludeRemoteAddr(boolean includeRemoteAddr);\n    public boolean isIncludeRemoteUser();\n    public void setIncludeRemoteUser(boolean includeRemoteUser);\n    public boolean isIncludeRequestTime();\n    public void setIncludeRequestTime(boolean includeRequestTime);\n    public boolean isIncludeRequestURI();\n    public void setIncludeRequestURI(boolean includeRequestURI);\n    public boolean isIncludeStatusCode();\n    public void setIncludeStatusCode(boolean includeStatusCode);\n    public boolean isIncludeMethod();\n    public void setIncludeMethod(boolean includeMethod);\n    public boolean isIncludeProtocol();\n    public void setIncludeProtocol(boolean includeProtocol);\n    public boolean isIncludeContentLength();\n    public void setIncludeContentLength(boolean includeContentLength);\n    public boolean isIncludeRequestURL();\n    public void setIncludeRequestURL(boolean includeRequestURL);\n    public boolean isIncludeRemoteHost();\n    public void setIncludeRemoteHost(boolean includeRemoteHost);\n    public boolean isIncludeServerName();\n    public void setIncludeServerName(boolean includeServerName);\n    public boolean isIncludeRequestHeader();\n    public void setIncludeRequestHeader(boolean includeRequestHeader);\n    public boolean isIncludeRequestParameter();\n    public void setIncludeRequestParameter(boolean includeRequestParameter);\n    public boolean isIncludeLocalPort();\n    public void setIncludeLocalPort(boolean includeLocalPort);\n    public boolean isIncludeRequestContent();\n    public void setIncludeRequestContent(boolean includeRequestContent);\n    public boolean isIncludeResponseContent();\n    public void setIncludeResponseContent(boolean includeResponseContent);\n\n    private AccessContext context;\n\n}\n\nclass JsonLayoutTest {\n\n    private AccessContext context;\n\n    @Test\n    public void jsonLayout() throws Exception {\n", "reference": "        configure(TEST_DIR_PREFIX + \"input/json/jsonLayout.xml\");\n        ListAppender<IAccessEvent> listAppender = (ListAppender<IAccessEvent>) context.getAppender(\"STR_LIST\");\n        IAccessEvent event = DummyAccessEventBuilder.buildNewAccessEvent();\n        listAppender.doAppend(event);\n\n        assertEquals(1, listAppender.list.size());\n        IAccessEvent iAccessEvent = listAppender.list.get(0);\n\n        JsonLayout jsonLayout = new JsonLayout();\n        jsonLayout.setContext(context);\n        String log = jsonLayout.doLayout(iAccessEvent);\n\n        assertThat(log, containsString(String.format(\"%s=%s\", JsonLayout.REMOTEHOST_ATTR_NAME, event.getRemoteHost())));\n        assertThat(log, containsString(String.format(\"%s=%s\", JsonLayout.REMOTEUSER_ATTR_NAME, event.getRemoteUser())));\n        assertThat(log, containsString(String.format(\"%s=%s\", JsonLayout.REMOTEADDR_ATTR_NAME, event.getRemoteAddr())));\n        assertThat(log, containsString(String.format(\"%s=%s\", JsonLayout.METHOD_ATTR_NAME, event.getMethod())));\n        if (event.getRequestHeaderMap().size() == 2) {\n            Iterator<Map.Entry<String, String>> iterator = event.getRequestHeaderMap().entrySet().iterator();\n            Map.Entry<String, String> firstInMap = iterator.next();\n            Map.Entry<String, String> secondInMap = iterator.next();\n            assertThat(log, containsString(String.format(\"%s={%s=%s, %s=%s}\", JsonLayout.REQUESTHEADER_ATTR_NAME, firstInMap.getKey(), firstInMap.getValue(), secondInMap.getKey(), secondInMap.getValue())));\n        }\n        assertThat(log, containsString(String.format(\"%s=%s\", JsonLayout.PROTOCOL_ATTR_NAME, event.getProtocol())));\n        assertThat(log, containsString(String.format(\"%s=%s\", JsonLayout.SERVERNAME_ATTR_NAME, event.getServerName())));\n        assertThat(log, containsString(String.format(\"%s=%s\", JsonLayout.STATUSCODE_ATTR_NAME, event.getStatusCode())));\n    }\n\n}", "prediction": "        JsonLayout layout = new JsonLayout();\n        String json = layout.doLayout(context);\n        System.out.println(json);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "7209229_19", "part": [1, 1], "seq": [1, 1], "prompt": "class BootstrapPullThread extends BasePullThread {\n\n  protected BackoffTimer getRetriesBeforeCkptCleanup()\n  {\n    return _retriesBeforeCkptCleanup;\n  }\n\n  public  BootstrapPullThread(String name,\n      DatabusSourcesConnection sourcesConn,\n      DbusEventBuffer dbusEventBuffer,\n      ConnectionStateFactory connStateFactory,\n      Set<ServerInfo> bootstrapServers,\n      List<DbusKeyCompositeFilterConfig> bootstrapFilterConfigs,\n      double pullerBufferUtilPct,\n      MBeanServer mbeanServer,\n      DbusEventFactory eventFactory\n      );\n  public  BootstrapPullThread(String name,\n                             DatabusSourcesConnection sourcesConn,\n                             DbusEventBuffer dbusEventBuffer,\n                             ConnectionStateFactory connStateFactory,\n                             Set<ServerInfo> bootstrapServers,\n                             List<DbusKeyCompositeFilterConfig> bootstrapFilterConfigs,\n                             double pullerBufferUtilPct,\n                             MBeanServer mbeanServer,\n                             DbusEventFactory eventFactory,\n                             ReentrantLock v3BootstrapLock,\n                             Logger log);\n\n  @Override protected boolean shouldDelayTearConnection(StateId stateId);\n  @Override protected boolean executeAndChangeState(Object message);\n  private void doSetSourcesSchemas(SourcesMessage sourcesMessage);\n  private void doSetSourcesIds(SourcesMessage sourcesMessage);\n  private void doSetResumeCheckpoint(CheckpointMessage cpMessage);\n  @Override protected void doStart(LifecycleMessage lcMessage);\n  @Override protected void doResume(LifecycleMessage lcMessage);\n  @Override protected void onShutdown();\n  @Override protected void doPause(LifecycleMessage lcMessage);\n  @Override protected void doSuspendOnError(LifecycleMessage lcMessage);\n  @Override protected void onResume();\n  protected void doPickBootstrapServer(ConnectionState curState);\n  private void doRequestTargetScn(ConnectionState curState);\n  protected void doTargetScnResponseSuccess(ConnectionState curState);\n  private void doRequestStartScn(ConnectionState curState);\n  private void doStartScnResponseSuccess(ConnectionState curState);\n  protected void doRequestBootstrapStream(ConnectionState curState);\n  protected void doReadBootstrapEvents(ConnectionState curState);\n  protected void doStreamResponseDone(ConnectionState curState);\n  protected void processBootstrapComplete(Checkpoint cp, ConnectionState curState);\n  protected void sendErrorEventToDispatcher(ConnectionState curState);\n  private void logBootstrapPhase(DbusClientMode mode, int snapshotSrcId, int catchupSrcId);\n  private void processStreamRequestError(ConnectionState state);\n  private void processStreamResponseError(ConnectionState state);\n  private void processTargetScnResponseError(ConnectionState currentState);\n  private void processTargetScnRequestError(ConnectionState currentState);\n  private void processStartScnResponseError(ConnectionState currentState);\n  private void processStartScnRequestError(ConnectionState currentState);\n  @Override protected void resetConnection();\n  private void determineNextStateFromCheckpoint(ConnectionState curState);\n  private void determineNextStateFromSnapshotCheckpoint(Checkpoint cp,\n                                                        BootstrapCheckpointHandler cpHandler,\n                                                        ConnectionState curState);\n  private void determineNextStateFromCatchupCheckpoint(Checkpoint cp,\n                                                       BootstrapCheckpointHandler cpHandler,\n                                                       ConnectionState curState);\n  private void lockV3Bootstrap();\n  private void unlockV3Bootstrap(boolean shutdownCase);\n  private void unlockV3Bootstrap();\n  protected ReentrantLock getV3BootstrapLock();\n\n  public static final Logger LOG;\n  public static final org.apache.avro.Schema SCHEMA;\n  public static int _port;\n  public static String _host;\n  public static String _serverInfoName;\n  public static ServerInfo _serverInfo;\n  private static final BootstrapCheckpointHandler _ckptHandlerSource1;\n  private static final BootstrapCheckpointHandler _ckptHandlerTwoSources;\n  private static final Set<ServerInfo> EXP_SERVERINFO_1;\n  private static final Set<ServerInfo> EXP_SERVERINFO_2;\n  private static final Set<ServerInfo> EXP_SERVERINFO_3;\n\n}\n\nclass TestBootstrapPullThread {\n\n  public static final Logger LOG;\n  public static final org.apache.avro.Schema SCHEMA;\n  public static int _port;\n  public static String _host;\n  public static String _serverInfoName;\n  public static ServerInfo _serverInfo;\n  private static final BootstrapCheckpointHandler _ckptHandlerSource1;\n  private static final BootstrapCheckpointHandler _ckptHandlerTwoSources;\n  private static final Set<ServerInfo> EXP_SERVERINFO_1;\n  private static final Set<ServerInfo> EXP_SERVERINFO_2;\n  private static final Set<ServerInfo> EXP_SERVERINFO_3;\n\n  @Test\n  /** Test BOOTSTRAP transitions - Bootstrap Restart since no serverInfo */\n  public void testTransition_RestartWithNoServerInfo() throws Exception\n  {\n", "reference": "    BootstrapPullThread bsPuller = createBootstrapPullThread(false, false, false);\n    Checkpoint cp = _ckptHandlerSource1.createInitialBootstrapCheckpoint(null, 50L);\n    cp.setBootstrapStartScn(1111L);\n\n    bsPuller.getComponentStatus().start();\n    ConnectionState connState = bsPuller.getConnectionState();\n    connState.switchToBootstrap(cp);\n    testTransitionCase(bsPuller, StateId.BOOTSTRAP, StateId.REQUEST_START_SCN, cp);\n    Assert.assertEquals(cp.getBootstrapStartScn().longValue(),\n                        Checkpoint.UNSET_BOOTSTRAP_START_SCN, \"Cleared Bootstrap StartSCN\");\n    Assert.assertEquals(cp.getBootstrapSinceScn().longValue(), 50L, \"Cleared Bootstrap SinceSCN\");\n    int numRetries = bsPuller.getRetriesBeforeCkptCleanup().getRemainingRetriesNum();\n    Assert.assertEquals(numRetries, 1000, \"NumRetries Check\");\n  }\n\n}", "prediction": "    // Create a puller thread\n    BootstrapPullThread puller = new BootstrapPullThread(\"test\",\n                                                         _sourcesConn,\n                                                         _dbusEventBuffer,\n                                                         _connStateFactory,\n                                                         EXP_SERVERINFO_1,\n                                                         _bootstrapFilterConfigs,\n                                                         _pullerBufferUtilPct,\n                                                         _mbeanServer,\n                                                         _eventFactory);\n    puller.start();\n\n    // Send a LifecycleMessage to the puller thread\n    LifecycleMessage lcMessage = new LifecycleMessage(LifecycleMessage.MessageType.RESTART);\n    puller.handleMessage(lcMessage);\n\n    // Wait for the puller thread to finish\n    puller.join();\n\n    // Check that the puller thread is in the correct state\n    Assert.assertEquals(StateId.INITIAL, puller.getStateId());\n\n    // Check that the puller thread has the correct serverInfo\n    Assert.assertEquals(EXP_SERVERINFO_1, puller.getBootstrapServers());\n\n    // Check that the puller thread has the correct checkpoint handler\n    Assert.assertEquals(_ckptHandlerSource1, puller.getCheckpointHandler());\n\n    // Check that the puller thread has the correct filter configs\n    Assert.assertEquals(_bootstrapFilterConfigs, puller.getFilterConfigs());\n\n    // Check that the puller thread has the correct buffer utilization\n    Assert.assertEquals(_pullerBufferUtilPct, puller.getBufferUtilizationPct());\n\n    // Check that the puller thread has the correct event factory\n    Assert.assertEquals(_eventFactory, puller.getEventFactory());\n\n    // Check that the puller thread has the correct mbean server\n    Assert.assertEquals(_mbeanServer, puller.getMbeanServer());\n\n    // Check that the puller thread has the correct host and port\n    Assert.assertEquals(_host, puller.getHost());\n    Assert.assertEquals(_port, puller.getPort());\n\n    // Check that the puller thread has the correct server info name\n    Assert.assertEquals(_serverInfoName, puller.getServerInfoName());\n\n    // Check that the puller thread has the correct server info\n    Assert.assertEquals(_serverInfo, puller.getServerInfo());\n\n    // Check that the puller thread has the correct source name\n    Assert.assertEquals(\"test\", puller.getSourceName());\n\n    // Check that the puller thread has the correct source id\n    Assert.assertEquals(1, puller.getSourceId());\n\n    // Check that the puller thread has the correct source name\n    Assert.assertEquals(\"test\", puller.getSourceName());\n\n    // Check that the puller thread has the correct source id\n    Assert.assertEquals(1, puller.getSourceId());\n\n    // Check that the puller thread has the correct source name\n    Assert.assertEquals(\"test\", puller.getSourceName());\n\n    // Check that the puller thread has the correct source id\n    Assert.assertEquals(1, puller.getSourceId());\n\n    // Check that the puller thread has the correct source name\n    Assert.assertEquals(\"test\", puller.getSourceName());\n\n    // Check that the puller thread has the correct source id\n    Assert.assertEquals(1, puller.getSourceId());\n\n    // Check that", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "7218024_14", "part": [1, 1], "seq": [1, 1], "prompt": "class DistCpUtils {\n\n  public static String getRelativePath(Path sourceRootPath, Path childPath) {\n    String childPathString = childPath.toUri().getPath();\n    String sourceRootPathString = sourceRootPath.toUri().getPath();\n    return sourceRootPathString.equals(\"/\") ? childPathString :\n        childPathString.substring(sourceRootPathString.length());\n  }\n\n  public static long getFileSize(Path path, Configuration configuration);\n  public static void publish(Configuration configuration,\n                                 String label, T value);\n  public static int getInt(Configuration configuration, String label);\n  public static long getLong(Configuration configuration, String label);\n  public static Class<? extends InputFormat> getStrategy(Configuration conf,\n                                                                 DistCpOptions options);\n  public static String packAttributes(EnumSet<FileAttribute> attributes);\n  public static EnumSet<FileAttribute> unpackAttributes(String attributes);\n  public static void preserve(FileSystem targetFS, Path path,\n                              FileStatus srcFileStatus,\n                              EnumSet<FileAttribute> attributes);\n  public static Path sortListing(FileSystem fs, Configuration conf, Path sourceListing);\n  public static DecimalFormat getFormatter();\n  public static String getStringDescriptionFor(long nBytes);\n  public static boolean checksumsAreEqual(FileSystem sourceFS, Path source,\n                                   FileSystem targetFS, Path target);\n  public static boolean compareFs(FileSystem srcFs, FileSystem destFs);\n\n  private static final Log LOG;\n  private static final Configuration config;\n  private static MiniDFSCluster cluster;\n  private static Random rand;\n\n}\n\nclass TestDistCpUtils {\n\n  private static final Log LOG;\n  private static final Configuration config;\n  private static MiniDFSCluster cluster;\n  private static Random rand;\n\n  @Test\n  public void testGetRelativePathRoot() {\n", "reference": "    Path root = new Path(\"/tmp/abc\");\n    Path child = new Path(\"/tmp/abc/xyz/file\");\n    Assert.assertEquals(DistCpUtils.getRelativePath(root, child), \"/xyz/file\");\n\n    root = new Path(\"/\");\n    child = new Path(\"/a\");\n    Assert.assertEquals(DistCpUtils.getRelativePath(root, child), \"/a\");\n  }\n\n}", "prediction": "    Path root = new Path(\"/\");\n    Path child = new Path(\"/a/b/c\");\n    assertEquals(getRelativePath(root, child), \"/a/b/c\");\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "7243760_25", "part": [1, 1], "seq": [1, 1], "prompt": "class RingBufferSimple extends RingBufferBase<V> {\n\n\t@Override\n\tpublic final int length() {\n\t\treturn array.length;\n\t}\n\n\t@SuppressWarnings(\"unchecked\") public  RingBufferSimple(final int size);\n\n\t@Override protected final V arrayGet(final int clue);\n\t@Override protected final void arraySet(final int clue, final V value);\n\t@Override protected final boolean isEmpty(final int clue);\n\n}\n\nclass TestRingBufferSimple {\n\n\t@Test\n\tpublic void testHead() {\n", "reference": "\n\t\tfinal RingBuffer<Integer> ring = new RingBufferSimple<Integer>(10);\n\t\tassertEquals(ring.length(), 10);\n\n\t\tring.setHead(100, 100);\n\t\tassertEquals(ring.count(), 1);\n\t\tassertEquals(ring.get(100), (Integer) 100);\n\n\t\tfor (int k = 101; k < 110; k++) {\n\t\t\tassertEquals(ring.get(k), null);\n\t\t}\n\n\t\tfor (int k = 100; k < 110; k++) {\n\t\t\tring.set(k, k);\n\t\t}\n\n\t\tassertEquals(ring.count(), 10);\n\n\t\tfor (int k = 100; k < 110; k++) {\n\t\t\tassertEquals(ring.get(k), (Integer) k);\n\t\t}\n\n\t\tring.setHead(105, 205);\n\n\t\tassertEquals(ring.count(), 5);\n\t\tassertEquals(ring.head(), 105);\n\t\tassertEquals(ring.tail(), 114);\n\n\t\tassertEquals(ring.get(105), (Integer) 205);\n\n\t\tfor (int k = 106; k < 110; k++) {\n\t\t\tassertEquals(ring.get(k), (Integer) k);\n\t\t}\n\n\t\tfor (int k = 110; k < 115; k++) {\n\t\t\tassertEquals(ring.get(k), (Integer) null);\n\t\t}\n\n\t\tring.set(114, 114);\n\n\t\tassertEquals(ring.count(), 6);\n\t\tassertEquals(ring.get(114), (Integer) 114);\n\n\t}\n\n}", "prediction": "\t\tfinal RingBufferSimple<Integer> buffer = new RingBufferSimple<>(10);\n\t\tassertEquals(0, buffer.head());\n\t\tbuffer.add(1);\n\t\tassertEquals(1, buffer.head());\n\t\tbuffer.add(2);\n\t\tassertEquals(2, buffer.head());\n\t\tbuffer.add(3);\n\t\tassertEquals(3, buffer.head());\n\t\tbuffer.add(4);\n\t\tassertEquals(4, buffer.head());\n\t\tbuffer.add(5);\n\t\tassertEquals(5, buffer.head());\n\t\tbuffer.add(6);\n\t\tassertEquals(6, buffer.head());\n\t\tbuffer.add(7);\n\t\tassertEquals(7, buffer.head());\n\t\tbuffer.add(8);\n\t\tassertEquals(8, buffer.head());\n\t\tbuffer.add(9);\n\t\tassertEquals(9, buffer.head());\n\t\tbuffer.add(10);\n\t\tassertEquals(10, buffer.head());\n\t\tbuffer.add(11);\n\t\tassertEquals(10, buffer.head());\n\t\tbuffer.add(12);\n\t\tassertEquals(10, buffer.head());\n\t\tbuffer.add(13);\n\t\tassertEquals(10, buffer.head());\n\t\tbuffer.add(14);\n\t\tassertEquals(10, buffer.head());\n\t\tbuffer.add(15);\n\t\tassertEquals(10, buffer.head());\n\t\tbuffer.add(16);\n\t\tassertEquals(10, buffer.head());\n\t\tbuffer.add(17);\n\t\tassertEquals(10, buffer.head());\n\t\tbuffer.add(18);\n\t\tassertEquals(10, buffer.head());\n\t\tbuffer.add(19);\n\t\tassertEquals(10, buffer.head());\n\t\tbuffer.add(20);\n\t\tassertEquals(10, buffer.head());\n\t\tbuffer.add(21);\n\t\tassertEquals(10, buffer.head());\n\t\tbuffer.add(22);\n\t\tassertEquals(10, buffer.head());\n\t\tbuffer.add(23);\n\t\tassertEquals(10, buffer.head());\n\t\tbuffer.add(24);\n\t\tassertEquals(10, buffer.head());\n\t\tbuffer.add(25);\n\t\tassertEquals(10, buffer.head());\n\t\tbuffer.add(26);\n\t\tassertEquals(10, buffer.head());\n\t\tbuffer.add(27);\n\t\tassertEquals(10, buffer.head());\n\t\tbuffer.add(28);\n\t\tassertEquals(10, buffer.head());\n\t\tbuffer.add(29);\n\t\tassertEquals(10, buffer.head());\n\t\tbuffer.add(30);\n\t\tassertEquals(10, buffer.head());\n\t\tbuffer.add(31);\n\t\tassertEquals(10, buffer.head());\n\t\tbuffer.add(32);\n\t\tassertEquals(10, buffer.head());\n\t\tbuffer.add(33);\n\t\tassertEquals(10, buffer.head());\n\t\tbuffer.add(34);\n\t\tassertEquals(10, buffer.head());\n\t\tbuffer.add(35);\n\t", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "7700244_0", "part": [1, 1], "seq": [1, 1], "prompt": "class Stock {\n\n\tpublic Stock(String symbol, double price, int volume, double pe, double eps, double week52low,      \n\t\t\t\t\tdouble week52high, double daylow, double dayhigh, double movingav50day, double marketcap, String name, String currency, double shortRatio, double previousClose, double open, String exchange) {\t\n\t\tthis.symbol = symbol; \n\t\tthis.price = price;\t\n\t\tthis.volume = volume; \n\t\tthis.pe = pe; \n\t\tthis.eps = eps; \n\t\tthis.week52low = week52low; \n\t\tthis.week52high = week52high; \n\t\tthis.daylow = daylow; \n\t\tthis.dayhigh = dayhigh; \n\t\tthis.movingav50day = movingav50day; \n\t\tthis.marketcap = marketcap;\n\t\tthis.name = name;\n\t\tthis.currency = currency;\n\t\tthis.shortRatio = shortRatio;\n\t\tthis.previousClose = previousClose;\n\t\tthis.open = open;\n\t\tthis.exchange = exchange;\n\t}\n\n\tpublic  Stock(String symbol, double price, int volume, double pe, double eps, double week52low,      \n\t\t\t\t\tdouble week52high, double daylow, double dayhigh, double movingav50day, double marketcap, String name, String currency, double shortRatio, double previousClose, double open, String exchange);\n\n\tpublic String getExchange();\n\tpublic double getPreviousClose();\n\tpublic double getOpen();\n\tpublic double getShortRatio();\n\tpublic String getCurrency();\n\tpublic String getSymbol();\n\tpublic double getPrice();\n\tpublic int getVolume();\n\tpublic double getPe();\n\tpublic double getEps();\n\tpublic double getWeek52low();\n\tpublic double getWeek52high();\n\tpublic double getDaylow();\n\tpublic double getDayhigh();\n\tpublic double getMovingav50day();\n\tpublic double getMarketcap();\n\tpublic String getName();\n\n}\n\nclass StockTest {\n\n\t@Test\n\tpublic void testStock() { \n", "reference": "\t\t\n\t\tStock facebook = StockFetcher.getStock(\"FB\");\n\t\tSystem.out.println(\"Price: \" + facebook.getPrice());\n\t\tSystem.out.println(\"Volume: \" + facebook.getVolume()); \n\t\tSystem.out.println(\"P/E: \" + facebook.getPe());\n\t\tSystem.out.println(\"EPS: \" + facebook.getEps());\n\t\tSystem.out.println(\"Year Low: \" + facebook.getWeek52low());\n\t\tSystem.out.println(\"Year High: \" + facebook.getWeek52high());\n\t\tSystem.out.println(\"Day Low: \" + facebook.getDaylow());\n\t\tSystem.out.println(\"Day High: \" + facebook.getDayhigh());\n\t\tSystem.out.println(\"50 Day Moving Av: \" + facebook.getMovingav50day());\n\t\tSystem.out.println(\"Market Cap: \" + facebook.getMarketcap());\n\t\tSystem.out.println(\"The full name is: \" + facebook.getName());\n\t\tSystem.out.println(\"The currency is: \" + facebook.getCurrency());\n\t\tSystem.out.println(\"The short ratio is: \" + facebook.getShortRatio());\n\t\tSystem.out.println(\"The previous close was: \" + facebook.getPreviousClose());\n\t\tSystem.out.println(\"The open for today was: \" + facebook.getOpen());\n\t\tSystem.out.println(\"The exchange is \" + facebook.getExchange());\n\t\t\n\t}\n\n}", "prediction": "\t\tStock stock = new Stock(\"AAPL\", 100.0, 1000, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, \"Apple\", \"USD\", 10.0, 10.0, 10.0);\n\t\tassertEquals(\"AAPL\", stock.getSymbol());\n\t\tassertEquals(100.0, stock.getPrice(), 0.0001);\n\t\tassertEquals(1000, stock.getVolume());\n\t\tassertEquals(10.0, stock.getPe(), 0.0001);\n\t\tassertEquals(10.0, stock.getEps(), 0.0001);\n\t\tassertEquals(10.0, stock.getWeek52low(), 0.0001);\n\t\tassertEquals(10.0, stock.getWeek52high(), 0.0001);\n\t\tassertEquals(10.0, stock.getDaylow(), 0.0001);\n\t\tassertEquals(10.0, stock.getDayhigh(), 0.0001);\n\t\tassertEquals(10.0, stock.getMovingav50day(), 0.0001);\n\t\tassertEquals(10.0, stock.getMarketcap(), 0.0001);\n\t\tassertEquals(\"Apple\", stock.getName());\n\t\tassertEquals(\"USD\", stock.getCurrency());\n\t\tassertEquals(10.0, stock.getShortRatio(), 0.0001);\n\t\tassertEquals(10.0, stock.getPreviousClose(), 0.0001);\n\t\tassertEquals(10.0, stock.getOpen(), 0.0001);\n\t\tassertEquals(\"NASDAQ\", stock.getExchange());\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "7735632_2", "part": [1, 1], "seq": [1, 1], "prompt": "class XmlHelper {\n\n  public static boolean readBooleanAttribute(XMLStreamReader reader, String attr,\n      boolean defaultValue) {\n    String a = reader.getAttributeValue(null, attr);\n    if (a == null || a.isEmpty()) {\n      return defaultValue;\n    }\n    return Boolean.parseBoolean(a);\n  }\n\n  private  XmlHelper();\n\n  public static Optional<String> readAttribute(XMLStreamReader reader, String attr);\n  public static Optional<Integer> readIntAttribute(XMLStreamReader reader, String attr);\n  public static Optional<Double> readDoubleAttribute(XMLStreamReader reader, String attr);\n  public static int readIntAttribute(XMLStreamReader reader, String attr, int defaultValue);\n  public static double readDoubleAttribute(XMLStreamReader reader, String attr, double defaultValue);\n  public static int parseInt(String i);\n  public static void close(XMLStreamReader reader);\n\n}\n\nclass XmlHelperTest {\n\n  @Test\n  public void readBooleanAttribute()\n      throws XMLStreamException, FactoryConfigurationError, IOException {\n", "reference": "    URL url = XmlHelperTest.class.getResource(\"/xml/default/kb-layout.xml\");\n    XMLStreamReader reader = XMLInputFactory.newInstance().createXMLStreamReader(url.openStream());\n    reader.next();\n    reader.require(XMLStreamConstants.START_ELEMENT, null, XmlHelper.KEYBOARD);\n\n    assertFalse(XmlHelper.readBooleanAttribute(reader, XmlHelper.ATTR_REPEATABLE, false));\n    assertFalse(XmlHelper.readBooleanAttribute(reader, \"\", false));\n\n    while (reader.hasNext()) {\n      reader.next();\n      if (!reader.isStartElement() || !XmlHelper.KEY.equals(reader.getLocalName())) {\n        continue;\n      }\n      if (32 == XmlHelper.readIntAttribute(reader, XmlHelper.ATTR_CODES, -1)) {\n        assertTrue(XmlHelper.readBooleanAttribute(reader, XmlHelper.ATTR_REPEATABLE, false));\n        assertTrue(XmlHelper.readBooleanAttribute(reader, XmlHelper.ATTR_MOVABLE, false));\n      }\n\n      if (-1 == XmlHelper.readIntAttribute(reader, XmlHelper.ATTR_CODES, 0)) {\n        assertTrue(XmlHelper.readBooleanAttribute(reader, XmlHelper.ATTR_STICKY, false));\n      }\n    }\n  }\n\n}", "prediction": "    String xml = \"<root attr=\\\"true\\\"/>\";\n    XMLInputFactory factory = XMLInputFactory.newInstance();\n    XMLStreamReader reader = factory.createXMLStreamReader(new StringReader(xml));\n    assertTrue(XmlHelper.readBooleanAttribute(reader, \"attr\", false));\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "7859424_68", "part": [1, 1], "seq": [1, 1], "prompt": "class Conjunction implements Predicate {\n\n\t@Override\n\tpublic boolean at(short p) {\n\t\treturn a.at(p) && b.at(p);\n\t}\n\n\tpublic  Conjunction(Predicate a, Predicate b);\n\n\tprivate Board board;\n\tprivate Conjunction conjunction;\n\tprivate CoordinateSystem coords;\n\n}\n\nclass ConjunctionTest {\n\n\tprivate Board board;\n\tprivate Conjunction conjunction;\n\tprivate CoordinateSystem coords;\n\n\t@Test\n\tpublic void testAt() {\n", "reference": "\t\tString[] before = {\n\t\t\t\t\"......#\",\n\t\t\t\t\".....#.\",\n\t\t\t\t\"..#...#\",\n\t\t\t\t\".#.#...\",\n\t\t\t\t\"..#....\",\n\t\t\t\t\".......\",\n\t\t\t\t\".......\",\n\t\t};\n\t\tboard.setUpProblem(before, BLACK);\n\t\tassertFalse(conjunction.at(at(\"g6\")));\n\t\tassertFalse(conjunction.at(at(\"c4\")));\n\t\tassertFalse(conjunction.at(at(\"a2\")));\n\t\tassertTrue(conjunction.at(at(\"d3\")));\n\t}\n\n}", "prediction": "\t\tassertTrue(conjunction.at(0));\n\t\tassertTrue(conjunction.at(1));\n\t\tassertTrue(conjunction.at(2));\n\t\tassertTrue(conjunction.at(3));\n\t\tassertTrue(conjunction.at(4));\n\t\tassertTrue(conjunction.at(5));\n\t\tassertTrue(conjunction.at(6));\n\t\tassertTrue(conjunction.at(7));\n\t\tassertTrue(conjunction.at(8));\n\t\tassertTrue(conjunction.at(9));\n\t\tassertTrue(conjunction.at(10));\n\t\tassertTrue(conjunction.at(11));\n\t\tassertTrue(conjunction.at(12));\n\t\tassertTrue(conjunction.at(13));\n\t\tassertTrue(conjunction.at(14));\n\t\tassertTrue(conjunction.at(15));\n\t\tassertTrue(conjunction.at(16));\n\t\tassertTrue(conjunction.at(17));\n\t\tassertTrue(conjunction.at(18));\n\t\tassertTrue(conjunction.at(19));\n\t\tassertTrue(conjunction.at(20));\n\t\tassertTrue(conjunction.at(21));\n\t\tassertTrue(conjunction.at(22));\n\t\tassertTrue(conjunction.at(23));\n\t\tassertTrue(conjunction.at(24));\n\t\tassertTrue(conjunction.at(25));\n\t\tassertTrue(conjunction.at(26));\n\t\tassertTrue(conjunction.at(27));\n\t\tassertTrue(conjunction.at(28));\n\t\tassertTrue(conjunction.at(29));\n\t\tassertTrue(conjunction.at(30));\n\t\tassertTrue(conjunction.at(31));\n\t\tassertTrue(conjunction.at(32));\n\t\tassertTrue(conjunction.at(33));\n\t\tassertTrue(conjunction.at(34));\n\t\tassertTrue(conjunction.at(35));\n\t\tassertTrue(conjunction.at(36));\n\t\tassertTrue(conjunction.at(37));\n\t\tassertTrue(conjunction.at(38));\n\t\tassertTrue(conjunction.at(39));\n\t\tassertTrue(conjunction.at(40));\n\t\tassertTrue(conjunction.at(41));\n\t\tassertTrue(conjunction.at(42));\n\t\tassertTrue(conjunction.at(43));\n\t\tassertTrue(conjunction.at(44));\n\t\tassertTrue(conjunction.at(45));\n\t\tassertTrue(conjunction.at(46));\n\t\tassertTrue(conjunction.at(47));\n\t\tassertTrue(conjunction.at(48));\n\t\tassertTrue(conjunction.at(49));\n\t\tassertTrue(conjunction.at(50));\n\t\tassertTrue(conjunction.at(51));\n\t\tassertTrue(conjunction.at(52));\n\t\tassertTrue(conjunction.at(53));\n\t\tassertTrue(conjunction.at(54));\n\t\tassertTrue(conjunction.at(55));\n\t\tassertTrue(conjunction.at(56));\n\t\tassertTrue(conjunction.at(57));\n\t\tassertTrue(conjunction.at(58));\n\t\tassertTrue(conjunction.at(59));\n\t\tassertTrue(conjunction.at(60));\n\t\tassertTrue(conjunction.at(61));\n\t\tassertTrue(conjunction.at(62));\n\t\tassertTrue(conjunction.at(63));\n\t\tassertTrue(conjunction.at(64));\n\t\tassertTrue(conjunction.at(65));\n\t\tassertTrue(conjunction.at(66));\n\t\tassertTrue(conjunction.at(67));\n\t\tassertTrue(conjunction.at(68));\n\t\tassertTrue(conjunction.at(69));\n\t\tassertTrue(conjunction.at(70));\n\t\tassertTrue(conjunction.at(71));\n\t\tassertTrue(conjunction.at(72));\n\t\tassertTrue(conjunction.at(73));\n\t\tassertTrue(conjunction.at(74));\n\t\tassertTrue(conjunction.at(75));\n\t\tassertTrue(conjunction.at(76));\n\t\tassertTrue(conjunction.at(77));\n\t\tassertTrue(conjunction.at(78));\n\t\tassertTrue(conjunction.at(79));\n\t\tassertTrue(conjunction.at(80));\n\t\tassertTrue(conjunction.at(81));\n\t\tassertTrue(conjunction.at(82));\n\t\tassertTrue(conjunction.at(83));\n\t\tassertTrue(conjunction.at(84));\n\t\tassertTrue(conjunction.at(85));\n\t\tassertTrue(conjunction.at(86));\n\t\tassertTrue(conjunction.at(87));\n\t\tassertTrue(conjunction.at(88));\n\t\tassertTrue(conjunction.at(89));\n\t\tassertTrue(conjunction.at(90));\n\t\tassertTrue(conjunction.at(91));\n\t\tassertTrue(conjunction.at(92));\n\t\tassertTrue(conjunction.at(93));\n\t\tassertTrue(conjunction.at(94));\n\t\tassertTrue(conjunction.at(95));\n\t\tassertTrue(conjunction.at(96));\n\t\tassertTrue(conjunction.at(97));\n\t\tassertTrue(conjunction.at(98));\n\t\tassertTrue(conjunction.at(99));\n\t\tassertTrue(conjunction.at(100));\n\t\tassert", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "7914484_242", "part": [1, 1], "seq": [1, 1], "prompt": "class TraxUtils {\n\n\tpublic static void doWithSource(Source source, SourceCallback callback) throws Exception {\n\t\tif (source instanceof DOMSource) {\n\t\t\tcallback.domSource(((DOMSource) source).getNode());\n\t\t\treturn;\n\t\t} else if (StaxUtils.isStaxSource(source)) {\n\t\t\tXMLStreamReader streamReader = StaxUtils.getXMLStreamReader(source);\n\t\t\tif (streamReader != null) {\n\t\t\t\tcallback.staxSource(streamReader);\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tXMLEventReader eventReader = StaxUtils.getXMLEventReader(source);\n\t\t\t\tif (eventReader != null) {\n\t\t\t\t\tcallback.staxSource(eventReader);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (source instanceof SAXSource) {\n\t\t\tSAXSource saxSource = (SAXSource) source;\n\t\t\tcallback.saxSource(saxSource.getXMLReader(), saxSource.getInputSource());\n\t\t\treturn;\n\t\t} else if (source instanceof StreamSource) {\n\t\t\tStreamSource streamSource = (StreamSource) source;\n\t\t\tif (streamSource.getInputStream() != null) {\n\t\t\t\tcallback.streamSource(streamSource.getInputStream());\n\t\t\t\treturn;\n\t\t\t} else if (streamSource.getReader() != null) {\n\t\t\t\tcallback.streamSource(streamSource.getReader());\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (StringUtils.hasLength(source.getSystemId())) {\n\t\t\tString systemId = source.getSystemId();\n\t\t\tcallback.source(systemId);\n\t\t} else {\n\t\t\tthrow new IllegalArgumentException(\"Unknown Source type: \" + source.getClass());\n\t\t}\n\t}\n\n\tpublic static Document getDocument(DOMSource source);\n\tpublic static void doWithResult(Result result, ResultCallback callback);\n\n}\n\nclass TraxUtilsTest {\n\n\t@Test\n\tpublic void testDoWithStaxSourceEventReader() throws Exception {\n", "reference": "\t\tXMLInputFactory inputFactory = XMLInputFactoryUtils.newInstance();\n\t\tXMLEventReader eventReader = inputFactory.createXMLEventReader(new StringReader(\"<element/>\"));\n\n\t\tTraxUtils.SourceCallback mock = createMock(TraxUtils.SourceCallback.class);\n\t\tmock.staxSource(eventReader);\n\n\t\treplay(mock);\n\n\t\tTraxUtils.doWithSource(StaxUtils.createStaxSource(eventReader), mock);\n\n\t\tverify(mock);\n\t}\n\n}", "prediction": "\t\tStaxSource staxSource = new StaxSource(new XMLEventReader() {\n\n\t\t\t@Override\n\t\t\tpublic void close() throws XMLStreamException {\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String getElementText() throws XMLStreamException {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int next() throws XMLStreamException {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int nextTag() throws XMLStreamException {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() throws XMLStreamException {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void require(int arg0, String arg1, String arg2) throws XMLStreamException {\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String getAttributeValue(String arg0, String arg1) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int getAttributeCount() {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic QName getAttributeName(int arg0) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String getAttributeLocalName(int arg0) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String getAttributeNamespace(int arg0) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String getAttributePrefix(int arg0) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String getAttributeType(int arg0) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String getAttributeValue(String arg0, String arg1, String arg2) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String getCharacterEncodingScheme() {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String getEncoding() {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int getEventType() {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String getLocalName() {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Location getLocation() {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic QName getName() {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic NamespaceContext getNamespaceContext() {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int getNamespaceCount() {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String getNamespacePrefix(int arg0) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String getNamespaceURI(int arg0) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic NamespaceContext getNamespaceContext() {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int getNamespaceCount() {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String getNamespacePrefix(int arg0) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String getNamespaceURI(int arg0) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String getNamespaceURI(String arg0) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String getPIData() {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String getPITarget() {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String getPrefix() {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Object getProperty(String arg0) throws IllegalArgumentException {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int getTextCharacters(int arg0, char[] arg1, int arg2, int arg3)\n\t\t\t\t\tthrows XMLStreamException {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic char[] getTextCharacters() throws XMLStreamException {\n\t\t\t\treturn new char[0];\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int getTextLength() {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String getText() {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String getVersion() {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean isAttributeSpecified(int arg0) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean isCharacters() {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean isEndElement() {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean isStandalone() {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean isStartElement() {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean isWhiteSpace() {", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "8108578_8", "part": [1, 1], "seq": [1, 1], "prompt": "class WordReducer extends Reducer<Text, IntWritable, Text, IntWritable> {\n\n    @Override\n    protected void reduce(Text key, Iterable<IntWritable> values, Context context) throws IOException, InterruptedException {\n        if (containsTargetWord(key)) {\n            int wordCount = 0;\n            for (IntWritable value: values) {\n                wordCount += value.get();\n            }\n            context.write(key, new IntWritable(wordCount));\n        }\n    }\n\n    private boolean containsTargetWord(Text key);\n\n    private static final String NOT_TARGET_WORD;\n    private Reducer.Context contextMock;\n    private WordReducer reducer;\n\n}\n\nclass WordReducerTest {\n\n    private static final String NOT_TARGET_WORD;\n    private Reducer.Context contextMock;\n    private WordReducer reducer;\n\n    @Test\n    public void reduceWhenTargetWordIsFound() throws IOException, InterruptedException {\n", "reference": "        Text key = new Text(WordReducer.TARGET_WORD);\n        Iterable<IntWritable> values = createValues(1, 1, 1);\n        reducer.reduce(key, values, contextMock);\n\n        ArgumentCaptor<IntWritable> countArgument = ArgumentCaptor.forClass(IntWritable.class);\n\n        verify(contextMock, times(1)).write(eq(key), countArgument.capture());\n        verifyNoMoreInteractions(contextMock);\n\n        IntWritable count = countArgument.getValue();\n        assertEquals(3, count.get());\n    }\n\n}", "prediction": "        when(contextMock.write(any(Text.class), any(IntWritable.class))).thenReturn(null);\n        reducer.reduce(new Text(NOT_TARGET_WORD), Arrays.asList(new IntWritable(1), new IntWritable(2)), contextMock);\n        verify(contextMock, times(1)).write(any(Text.class), any(IntWritable.class));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "8121707_15", "part": [1, 1], "seq": [1, 1], "prompt": "class JavaDomUtils {\n\n    public static String calculateTypeName(CompilationUnit compilationUnit, FullyQualifiedJavaType fqjt) {\n\n        if (fqjt.isArray()) {\n            // if array, then calculate the name of the base (non-array) type\n            // then add the array indicators back in\n            String fqn = fqjt.getFullyQualifiedName();\n            String typeName = calculateTypeName(compilationUnit,\n                    new FullyQualifiedJavaType(fqn.substring(0, fqn.indexOf('['))));\n            return typeName + fqn.substring(fqn.indexOf('['));\n        }\n\n        if (!fqjt.getTypeArguments().isEmpty()) {\n            return calculateParameterizedTypeName(compilationUnit, fqjt);\n        }\n\n        if (compilationUnit == null\n                || typeDoesNotRequireImport(fqjt)\n                || typeIsInSamePackage(compilationUnit, fqjt)\n                || typeIsAlreadyImported(compilationUnit, fqjt)) {\n            return fqjt.getShortName();\n        } else {\n            return fqjt.getFullyQualifiedName();\n        }\n    }\n\n    private  JavaDomUtils();\n\n    private static String calculateParameterizedTypeName(CompilationUnit compilationUnit,\n            FullyQualifiedJavaType fqjt);\n    private static boolean typeDoesNotRequireImport(FullyQualifiedJavaType fullyQualifiedJavaType);\n    private static boolean typeIsInSamePackage(CompilationUnit compilationUnit,\n            FullyQualifiedJavaType fullyQualifiedJavaType);\n    private static boolean typeIsAlreadyImported(CompilationUnit compilationUnit,\n            FullyQualifiedJavaType fullyQualifiedJavaType);\n\n}\n\nclass JavaDomUtilsTest {\n\n    @Test\n    public void testGenericTypeWithWildCardAllImported() {\n", "reference": "        Interface interfaze = new Interface(new FullyQualifiedJavaType(\"com.foo.UserMapper\"));\n\n        interfaze.addImportedType(new FullyQualifiedJavaType(\"java.util.Map\"));\n        interfaze.addImportedType(new FullyQualifiedJavaType(\"java.util.List\"));\n        interfaze.addImportedType(new FullyQualifiedJavaType(\"com.beeant.dto.User\"));\n        interfaze.addImportedType(new FullyQualifiedJavaType(\"java.math.BigDecimal\"));\n\n        FullyQualifiedJavaType fqjt = new FullyQualifiedJavaType(\"java.util.Map<java.math.BigDecimal, java.util.List<? extends com.beeant.dto.User>>\");\n        assertEquals(\"Map<BigDecimal, List<? extends User>>\",\n                JavaDomUtils.calculateTypeName(interfaze, fqjt));\n    }\n\n}", "prediction": "        CompilationUnit compilationUnit = new CompilationUnit();\n        compilationUnit.setPackage(\"com.example\");\n        compilationUnit.setImports(new HashSet<Import>(Arrays.asList(new Import[] {\n                new Import(\"java.util.List\"),\n                new Import(\"java.util.Map\"),\n                new Import(\"java.util.Set\"),\n        })));\n\n        FullyQualifiedJavaType fqjt = new FullyQualifiedJavaType(\"java.util.Map\");\n        fqjt.setTypeArguments(new HashSet<FullyQualifiedJavaType>(Arrays.asList(new FullyQualifiedJavaType[] {\n                new FullyQualifiedJavaType(\"java.lang.String\"),\n                new FullyQualifiedJavaType(\"java.util.List\"),\n        })));\n\n        String typeName = JavaDomUtils.calculateTypeName(compilationUnit, fqjt);\n        assertEquals(\"Map<String, List>\", typeName);\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "8175611_310", "part": [1, 1], "seq": [1, 1], "prompt": "class ObjectArrayConverter extends AbstractObjectConverter<Object[]> {\n\n    @Override\n    public Object[] convert(Object[] data, boolean isVarargs, Class<?>[] parameterTypes) {\n        Object[] result;\n        if (isVarargs) {\n            result = new Object[parameterTypes.length];\n\n            int lastArgIdx = parameterTypes.length - 1;\n            if (lastArgIdx >= 0) {\n                System.arraycopy(data, 0, result, 0, lastArgIdx);\n            }\n            result[lastArgIdx] = convertVararg(data, parameterTypes[lastArgIdx].getComponentType(), lastArgIdx);\n\n        } else {\n            result = data;\n        }\n        checkIfArgumentsMatchParameterTypes(result, parameterTypes);\n        return result;\n    }\n\n    private Object convertVararg(Object[] data, Class<?> varargComponentType, int nonVarargParameterCount);\n\n    @SuppressFBWarnings(value = \"URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD\", justification = \"Mockito rule needs no further configuration\")\n    @Rule\n    public MockitoRule mockitoRule;\n    @InjectMocks\n    private ObjectArrayConverter underTest;\n\n}\n\nclass ObjectArrayConverterTest {\n\n    @SuppressFBWarnings(value = \"URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD\", justification = \"Mockito rule needs no further configuration\")\n    @Rule\n    public MockitoRule mockitoRule;\n    @InjectMocks\n    private ObjectArrayConverter underTest;\n\n    @Test\n    public void testConvertShouldNotForwardArrayIfVarargsIsArrayOfArray() {\n", "reference": "        // Given:\n        Object[] data = new Object[] { new int[] { 1, 2 } };\n        Class<?>[] parameterTypes = new Class<?>[] { int[].class };\n\n        // When:\n        Object[] result = underTest.convert(data, true, parameterTypes);\n\n        // Then:\n        assertThat(result).isEqualTo(new int[][] { { 1, 2 } });\n    }\n\n}", "prediction": "        // given\n        Object[] data = new Object[] { new Object[] { \"foo\" } };\n        Class<?>[] parameterTypes = new Class<?>[] { String[].class };\n\n        // when\n        Object[] result = underTest.convert(data, true, parameterTypes);\n\n        // then\n        assertThat(result).isEqualTo(data);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "8397753_10", "part": [1, 1], "seq": [1, 1], "prompt": "class GitCheckout {\n\n  public GitCheckoutResponse checkout(File repositoryPath, GitCheckoutOptions options, Ref branch)\n      throws IOException, JavaGitException {\n    CheckUtilities.checkFileValidity(repositoryPath);\n    CheckUtilities.validateArgumentRefType(branch, RefType.BRANCH, \"Branch name\");\n    IClient client = ClientManager.getInstance().getPreferredClient();\n    IGitCheckout gitCheckout = client.getGitCheckoutInstance();\n    return gitCheckout.checkout(repositoryPath, options, branch);\n  }\n\n  public GitCheckoutResponse checkout(File repositoryPath, List<File> paths);\n  public GitCheckoutResponse checkout(File repositoryPath, GitCheckoutOptions options, Ref branch,\n      File file);\n  public GitCheckoutResponse checkout(File repositoryPath, GitCheckoutOptions options, Ref branch,\n      List<File> paths);\n  public GitCheckoutResponse checkout(File repositoryPath, Ref ref, List<File> paths);\n\n    public static final String TEST_BRANCH;\n    private File repositoryDirectory;\n    private String repositoryPath;\n    private GitCommit gitCommit;\n    private GitAdd gitAdd;\n    private GitCheckout gitCheckout;\n    private File file1;\n    private File file2;\n\n}\n\nclass TestGitCheckout  {\n\n    public static final String TEST_BRANCH;\n    private File repositoryDirectory;\n    private String repositoryPath;\n    private GitCommit gitCommit;\n    private GitAdd gitAdd;\n    private GitCheckout gitCheckout;\n    private File file1;\n    private File file2;\n\n    @Test\n    public void testCheckingOutLocalllyDeletedFiles() throws JavaGitException, IOException {\n", "reference": "        List<File> filePaths = new ArrayList<File>();\n        File tmpFile;\n        try {\n            filePaths.add(tmpFile = new File(repositoryPath + File.separator + \"foobar01\"));\n            if (!tmpFile.exists()) {\n                System.out.println(\"tmpFile does not exit: \" + tmpFile.getPath());\n            }\n            if (tmpFile.delete()) { // locally delete the file\n                // check out the file from the repository after deletion\n                GitCheckoutResponse response = gitCheckout.checkout(repositoryDirectory, filePaths);\n                File checkedOutFile = new File(repositoryPath + File.separator + \"foobar01\");\n                assertTrue(checkedOutFile.exists());\n                FileUtilities.modifyFileContents(file2, \"Test for append to a file\");\n                GitCheckoutOptions options = new GitCheckoutOptions();\n                Ref branch = Ref.createBranchRef(\"master\");\n                response = gitCheckout.checkout(repositoryDirectory, options, branch);\n                assertEquals(\"Modified File exists\", 1, response.getNumberOfModifiedFiles());\n            } else {\n                fail(\"File delete failed\");\n            }\n        } catch (IOException e) {\n            System.err.println(e.getMessage());\n            e.printStackTrace();\n        }\n\n    }\n\n}", "prediction": "        GitCheckoutOptions options = new GitCheckoutOptions();\n        options.setForce(true);\n        GitCheckoutResponse response = gitCheckout.checkout(repositoryDirectory, options, TEST_BRANCH, file1);\n        assertTrue(response.isSuccess());\n        assertTrue(file1.exists());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "8849911_0", "part": [1, 1], "seq": [1, 1], "prompt": "class MassConvertController {\n\n    @RequestMapping(value = \"/batch\", method = RequestMethod.GET)\n    public void convert(@RequestParam(PARAM_URL) String sourceUrlParams,\n                        @RequestParam(value = PARAM_URL_TEMPLATE, required = false, defaultValue = DEFAULT_URL_TEMPLATE) String sourceUrlTemplate,\n                        @RequestParam(value = PARAM_OUT_FORMAT, required = false, defaultValue = DEFAULT_OUT_FORMAT) String outputFormat,\n                        HttpServletResponse response) throws Exception {\n\n        if (sourceUrlParams == null || sourceUrlParams.length() == 0) {\n            throw new Exception(\"Required parameter missing: \" + PARAM_URL);\n        }\n\n\n        String[] sourceUrls = getSourceUrls(sourceUrlTemplate, sourceUrlParams);\n        Arrays.sort(sourceUrls);\n\n        String batchSignature = calculateBatchSignature(sourceUrls);\n\n        String batchFilePath = batchDao.findBatchPath(batchSignature, outputFormat);\n\n        if (batchFilePath != null) { // already packed\n            sendRedirect(response, batchFilePath);\n            return;\n        }\n\n\n        List<Callable<Object>> tasks = new ArrayList<Callable<Object>>(sourceUrls.length);\n\n        for (final String sourceUrl : sourceUrls) {\n            tasks.add(createSingleConversionTask(sourceUrl, outputFormat));\n        }\n\n        converterExecutor.invokeAll(tasks); // make sure all files are converted\n\n\n        File batchFile = zipFiles(sourceUrls, outputFormat, batchSignature);\n\n        batchDao.addBatch(batchSignature, outputFormat, batchFile);\n        batchFilePath = batchDao.findBatchPath(batchSignature, outputFormat);\n        sendRedirect(response, batchFilePath);\n    }\n\n    private void sendRedirect(HttpServletResponse response, String batchFilePath);\n    private String[] getSourceUrls(String sourceUrlTemplate, String sourceUrlParams);\n    private File zipFiles(String[] sourceUrls, String outputFormat, String batchSignature);\n    private String calculateBatchSignature(String[] sourceUrls);\n    private Callable<Object> createSingleConversionTask(final String sourceUrl, final String outputFormat);\n    public void shutdown();\n    public void setStaticRedirectUrlPrefix(String staticRedirectUrlPrefix);\n    public void setConvertersPoolSize(int convertersPoolSize);\n    public void setUseXAccelRerirect(Boolean useXAccelRerirect);\n\n}\n\nclass TestMassConvertController {\n\n    @Test\n    public void testZipFile() throws Exception {\n", "reference": "        MassConvertController controller = new MassConvertController();\n        BatchDao batchDao = mock(BatchDao.class);\n//        when(batchDao.findBatchPath(anyString(), anyString())).thenAnswer(new Answer<String>() {\n//            @Override\n//            public String answer(InvocationOnMock invocation) throws Throwable {\n//                return createTestFile((String) invocation.getArguments()[0], (String) invocation.getArguments()[1]);\n//            }\n//        });\n        when(batchDao.findBatchPath(anyString(), anyString())).thenReturn(null);\n\n        controller.batchDao = batchDao;\n\n        UrlDao urlDao = mock(UrlDao.class);\n        when(urlDao.findUrlInfo(\"http://flibusta.net/b/123/fb2\")).thenAnswer(new Answer<UrlInfo>() {\n            @Override\n            public UrlInfo answer(InvocationOnMock invocation) throws Throwable {\n                UrlInfo info = new UrlInfo();\n                info.setBookId(\"123\");\n                info.setSourceFormat(\"epub\");\n                return info;\n            }\n        });\n        when(urlDao.findUrlInfo(\"http://flibusta.net/b/345/fb2?t=def\")).thenAnswer(new Answer<UrlInfo>() {\n            @Override\n            public UrlInfo answer(InvocationOnMock invocation) throws Throwable {\n                UrlInfo info = new UrlInfo();\n                info.setBookId(\"345\");\n                info.setSourceFormat(\"epub\");\n                return info;\n            }\n        });\n\n        controller.urlDao = urlDao;\n\n\n        BookDao bookDao = mock(BookDao.class);\n        when(bookDao.findBook(\"123\", \"epub\")).thenReturn(null);\n        File testFile = createTestFile(\"345\", \"epub\");\n        when(bookDao.findBook(\"345\", \"epub\")).thenReturn(testFile);\n\n        controller.bookDao = bookDao;\n\n        controller.singleConverterController = new SingleUrlConverter() {\n            @Override\n            public void convert(String sourceUrl, String sourceMd5, String outputFormat, String sourceFormat, HttpServletResponse response) throws Exception {\n\n            }\n        };\n\n        controller.convert(\"123;abc;dd_345;def\", \"http://flibusta.net/b/{0}/fb2?t={1}\", \"epub\",\n                new HttpServletResponse() {\n            @Override\n            public void addCookie(Cookie cookie) {\n\n            }\n\n            @Override\n            public boolean containsHeader(String name) {\n                return false;\n            }\n\n            @Override\n            public String encodeURL(String url) {\n                return null;\n            }\n\n            @Override\n            public String encodeRedirectURL(String url) {\n                return null;\n            }\n\n            @Override\n            public String encodeUrl(String url) {\n                return null;\n            }\n\n            @Override\n            public String encodeRedirectUrl(String url) {\n                return null;\n            }\n\n            @Override\n            public void sendError(int sc, String msg) throws IOException {\n\n            }\n\n            @Override\n            public void sendError(int sc) throws IOException {\n\n            }\n\n            @Override\n            public void sendRedirect(String location) throws IOException {\n                System.out.println(\"location = \" + location);\n            }\n\n            @Override\n            public void setDateHeader(String name, long date) {\n\n            }\n\n            @Override\n            public void addDateHeader(String name, long date) {\n\n            }\n\n            @Override\n            public void setHeader(String name, String value) {\n\n            }\n\n            @Override\n            public void addHeader(String name, String value) {\n\n            }\n\n            @Override\n            public void setIntHeader(String name, int value) {\n\n            }\n\n            @Override\n            public void addIntHeader(String name, int value) {\n\n            }\n\n            @Override\n            public void setStatus(int sc) {\n\n            }\n\n            @Override\n            public void setStatus(int sc, String sm) {\n\n            }\n\n            @Override\n            public String getCharacterEncoding() {\n                return null;\n            }\n\n            @Override\n            public String getContentType() {\n                return null;\n            }\n\n            @Override\n            public ServletOutputStream getOutputStream() throws IOException {\n                return null;\n            }\n\n            @Override\n            public PrintWriter getWriter() throws IOException {\n                return null;\n            }\n\n            @Override\n            public void setCharacterEncoding(String charset) {\n\n            }\n\n            @Override\n            public void setContentLength(int len) {\n\n            }\n\n            @Override\n            public void setContentType(String type) {\n\n            }\n\n            @Override\n            public void setBufferSize(int size) {\n\n            }\n\n            @Override\n            public int getBufferSize() {\n                return 0;\n            }\n\n            @Override\n            public void flushBuffer() throws IOException {\n\n            }\n\n            @Override\n            public void resetBuffer() {\n\n            }\n\n            @Override\n            public boolean isCommitted() {\n                return false;\n            }\n\n            @Override\n            public void reset() {\n\n            }\n\n            @Override\n            public void setLocale(Locale loc) {\n\n            }\n\n            @Override\n            public Locale getLocale() {\n                return null;\n            }\n        });\n\n\n    }\n\n}", "prediction": "        String[] sourceUrls = new String[]{\"http://www.google.com\", \"http://www.yahoo.com\"};\n        String batchSignature = calculateBatchSignature(sourceUrls);\n        File batchFile = zipFiles(sourceUrls, \"pdf\", batchSignature);\n        assertTrue(batchFile.exists());\n        assertTrue(batchFile.length() > 0);\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "8896307_1", "part": [1, 1], "seq": [1, 1], "prompt": "class Loader {\n\n    public Loader(DbaConfiguration configuration) throws Exception {\n        this.configuration = configuration;\n    }\n\n    public  Loader(DbaConfiguration configuration);\n\n    public void bootstrap();\n    public void clear();\n    public void prepareDb();\n    public void rollback();\n    public Loader createDatabase();\n    public void dropDatabase();\n    public void execute();\n    private void bootstrapCoRE();\n    private void initialize();\n    private void initializeParameters(Liquibase liquibase);\n    private void load(String changeLog,\n                      Connection connection);\n    private void loadModel();\n\n}\n\nclass LoaderTest {\n\n    @Test\n    public void testLoader() throws Exception {\n", "reference": "        ObjectMapper mapper = new ObjectMapper(new YAMLFactory());\n        DbaConfiguration config = mapper.readValue(getClass().getResourceAsStream(\"/loader.yml\"),\n                                                   DbaConfiguration.class);\n        try (Connection dbaConnection = config.getDbaConnection()) {\n            dbaConnection.setAutoCommit(true);\n            dbaConnection.prepareStatement(\"DROP DATABASE IF EXISTS testme\")\n                         .execute();\n            dbaConnection.prepareStatement(\"DROP ROLE IF EXISTS scott\")\n                         .execute();\n        }\n        config.dropDatabase = true;\n        Loader loader = new Loader(config);\n        try {\n            loader.execute();\n            loader.execute();\n            loader.clear();\n            loader.rollback();\n        } finally {\n            loader.dropDatabase();\n        }\n    }\n\n}", "prediction": "        Loader loader = new Loader(new DbaConfiguration());\n        loader.bootstrap();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "8927606_155", "part": [1, 1], "seq": [1, 1], "prompt": "class AppConstants extends Properties implements Serializable {\n\n\tpublic String getResolvedProperty(String key) {\n\t\tString value = null;\n\t\tvalue=getSystemProperty(key); // first try custom properties\n\t\tif (value==null) {\n\t\t\tvalue = super.getProperty(key); // then try DeploymentSpecifics and appConstants\n\t\t}\n\t\tif (value != null) {\n\t\t\ttry {\n\t\t\t\tString result=StringResolver.substVars(value, this);\n\t\t\t\tif (log.isTraceEnabled()) {\n\t\t\t\t\tif (!value.equals(result)){\n\t\t\t\t\t\tlog.trace(\"resolved key [\"+key+\"], value [\"+value+\"] to [\"+result+\"]\");\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\tlog.error(\"Bad option value [\" + value + \"].\", e);\n\t\t\t\treturn value;\n\t\t\t}\n\t\t} else {\n\t\t\tif (log.isTraceEnabled()) log.trace(\"getResolvedProperty: key [\"+key+\"] resolved to value [\"+value+\"]\");\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tprivate  AppConstants(ClassLoader classLoader);\n\n\tpublic static AppConstants getInstance();\n\tpublic static synchronized AppConstants getInstance(final ClassLoader cl);\n\tpublic static void removeInstance();\n\tpublic static synchronized void removeInstance(final ClassLoader cl);\n\tprivate String getSystemProperty(String key);\n\t@Override public String get(Object key);\n\t@Override public String getProperty(String key);\n\tpublic String getUnresolvedProperty(String key);\n\tpublic StringTokenizer getTokenizedProperty(String key);\n\tpublic StringTokenizer getTokenizedProperty(String key, String defaults);\n\tpublic Properties getAppConstants(String keyBase);\n\tpublic Properties getAppConstants(String keyBase, boolean useSystemProperties, boolean useEnvironmentVariables);\n\tprivate synchronized void load(ClassLoader classLoader, String filename, boolean loadAdditionalPropertiesFiles);\n\tprivate synchronized void load(ClassLoader classLoader, String filename, String suffix, boolean loadAdditionalPropertiesFiles);\n\t@Deprecated @Override public synchronized Object put(Object key, Object value);\n\t@Override public Object setProperty(String key, String value);\n\tpublic Object setProperty(String key, boolean value);\n\tpublic void put(String key, String value);\n\tprivate synchronized Object setProperty(String key, String value, boolean local);\n\t@Deprecated public String toXml();\n\t@Deprecated public String toXml(boolean resolve);\n\tpublic String getString(String key, String dfault);\n\tpublic boolean getBoolean(String key, boolean dfault);\n\tpublic int getInt(String key, int dfault);\n\tpublic long getLong(String key, long dfault);\n\tpublic double getDouble(String key, double dfault);\n\tpublic void setVariableExpander(VariableExpander expander);\n\tpublic VariableExpander getVariableExpander();\n\n\tprivate Logger log;\n\tprivate ClassLoaderMock classLoader;\n\tprivate AppConstants constants;\n\tprivate ClassLoader contextClassLoader;\n\n}\n\nclass AppConstantsTest {\n\n\tprivate Logger log;\n\tprivate ClassLoaderMock classLoader;\n\tprivate AppConstants constants;\n\tprivate ClassLoader contextClassLoader;\n\n\t@Test\n\tpublic void onlyInAppConstants() {\n", "reference": "\t\tassertEquals(\"1\", constants.getResolvedProperty(\"only.in.appconstants\"));\n\t}\n\n}", "prediction": "\t\tassertEquals(\"value1\", constants.getResolvedProperty(\"key1\"));\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "9132656_1", "part": [1, 1], "seq": [1, 1], "prompt": "class MavenColorRenderer extends PatternRenderer {\n\n    @Override\n    protected void renderMessage(Event event, StringBuilder buff) {\n        if (!isActivated) {\n            super.renderMessage(event, buff);\n            return;\n        }\n\n        if (event.getLevel() == WARN) {\n            buff.append(colorize(event, YELLOW));\n        } else if (event.getLevel() == INFO) {\n            buff.append(colorizer.colorize(event.getMessage()));\n        } else {\n            super.renderMessage(event, buff);\n        }\n    }\n\n    public  MavenColorRenderer();\n    public  MavenColorRenderer(boolean isActivated);\n    public  MavenColorRenderer(String pattern);\n    public  MavenColorRenderer(String pattern, boolean isActivated);\n\n    @Override protected void renderLevel(Event event, StringBuilder buff);\n    private static String colorize(Event event, Ansi.Color color);\n\n    @Rule\n    public ClearSystemProperties myPropertyIsCleared;\n    private static final Logger LOGGER;\n\n}\n\nclass MavenColorRendererTest {\n\n    @Rule\n    public ClearSystemProperties myPropertyIsCleared;\n    private static final Logger LOGGER;\n\n    @Test\n    public void do_not_colorize_when_colorization_is_deactivated() {\n", "reference": "        StringBuilder result = new StringBuilder();\n\n        new MavenColorRenderer(false).renderMessage(event(WARN, \"warning message\"), result);\n\n        assertThat(result.toString()).isEqualTo(\"warning message\");\n    }\n\n}", "prediction": "        MavenColorRenderer renderer = new MavenColorRenderer(false);\n        assertEquals(\"message\", renderer.render(new LogEvent(INFO, \"message\")));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "9278888_694", "part": [1, 1], "seq": [1, 1], "prompt": "class MutableSpan implements Cloneable {\n\n  public boolean debug() {\n    return (flags & FLAG_DEBUG) == FLAG_DEBUG;\n  }\n\n  public  MutableSpan();\n  public  MutableSpan(TraceContext context, @Nullable MutableSpan defaults);\n  public  MutableSpan(MutableSpan toCopy);\n\n  @Deprecated public boolean isEmpty();\n  public String traceId();\n  public void traceId(String traceId);\n  @Nullable public String localRootId();\n  public void localRootId(String localRootId);\n  @Nullable public String parentId();\n  public void parentId(@Nullable String parentId);\n  public String id();\n  public void id(String id);\n  @Nullable public String name();\n  public void name(@Nullable String name);\n  public long startTimestamp();\n  public void startTimestamp(long startTimestamp);\n  public long finishTimestamp();\n  public void finishTimestamp(long finishTimestamp);\n  public Kind kind();\n  public void kind(@Nullable Kind kind);\n  @Nullable public String localServiceName();\n  public void localServiceName(@Nullable String localServiceName);\n  @Nullable public String localIp();\n  public boolean localIp(@Nullable String localIp);\n  public int localPort();\n  public void localPort(int localPort);\n  @Nullable public String remoteServiceName();\n  public void remoteServiceName(@Nullable String remoteServiceName);\n  @Nullable public String remoteIp();\n  public void remoteIp(@Nullable String remoteIp);\n  public int remotePort();\n  public void remotePort(int remotePort);\n  public boolean remoteIpAndPort(@Nullable String remoteIp, int remotePort);\n  public Throwable error();\n  public void error(@Nullable Throwable error);\n  public void setDebug();\n  public void unsetDebug();\n  public boolean shared();\n  public void setShared();\n  public void unsetShared();\n  public int annotationCount();\n  public long annotationTimestampAt(int i);\n  public String annotationValueAt(int i);\n  public Collection<Map.Entry<Long, String>> annotations();\n  public void forEachAnnotation(AnnotationConsumer<T> annotationConsumer, T target);\n  public void forEachAnnotation(AnnotationUpdater annotationUpdater);\n  public boolean containsAnnotation(String value);\n  public void annotate(long timestamp, String value);\n  public int tagCount();\n  public String tagKeyAt(int i);\n  public String tagValueAt(int i);\n  public Map<String, String> tags();\n  @Nullable public String tag(String key);\n  @Nullable public String removeTag(String key);\n  public void forEachTag(TagConsumer<T> tagConsumer, T target);\n  public void forEachTag(TagUpdater tagUpdater);\n  public void tag(String key, String value);\n  @Override public String toString();\n  @Override public int hashCode();\n  @Override public boolean equals(Object o);\n  static Object[] add(Object[] input, int i, Object key, Object value);\n  static void update(Object[] input, int i, Object value);\n  static void remove(Object[] input, int i);\n  static Object[] copy(Object[] input);\n  static boolean entriesEqual(Object[] left, int leftCount, Object[] right, int rightCount);\n  static int entriesHashCode(Object[] entries, int count);\n  @Nullable static String normalizeIdField(String field, @Nullable String id, boolean isNullable);\n  static int validateHexAndReturnPadding(String field, String value, int desiredLength);\n  static String padLeft(String id, int desiredLength, int existingPadding);\n  static boolean equal(@Nullable Object a, @Nullable Object b);\n\n  static final Pattern CREDIT_CARD;\n  static final Exception EX1;\n  public static List<Supplier<MutableSpan>> PERMUTATIONS;\n\n}\n\nclass MutableSpanTest {\n\n  static final Pattern CREDIT_CARD;\n  static final Exception EX1;\n  public static List<Supplier<MutableSpan>> PERMUTATIONS;\n\n  @Test public void debug() {\n", "reference": "    MutableSpan span = new MutableSpan();\n    span.setDebug();\n    assertThat(span.debug()).isTrue();\n\n    span.unsetDebug();\n    assertThat(span.debug()).isFalse();\n    assertThat(span.flags).isZero();\n  }\n\n}", "prediction": "    assertThat(new MutableSpan().debug()).isFalse();\n    assertThat(new MutableSpan().setDebug().debug()).isTrue();\n    assertThat(new MutableSpan().unsetDebug().debug()).isFalse();\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "9580168_2", "part": [1, 1], "seq": [1, 1], "prompt": "class PmdValidator implements ResourceValidator {\n\n    @Override\n    @SuppressWarnings(\"PMD.AvoidInstantiatingObjectsInLoops\")\n    public Collection<Violation> validate(final Collection<File> files) {\n        final SourceValidator validator = new SourceValidator(this.env);\n        final Collection<DataSource> sources = new LinkedList<>();\n        for (final File file : files) {\n            sources.add(new FileDataSource(file));\n        }\n        final Collection<RuleViolation> breaches = validator.validate(\n            sources, this.env.basedir().getPath()\n        );\n        final Collection<Violation> violations = new LinkedList<>();\n        for (final RuleViolation breach : breaches) {\n            violations.add(\n                new Violation.Default(\n                    this.name(),\n                    breach.getRule().getName(),\n                    breach.getFilename(),\n                    String.format(\n                        \"%d-%d\",\n                        breach.getBeginLine(), breach.getEndLine()\n                    ),\n                    breach.getDescription()\n                )\n            );\n        }\n        return violations;\n    }\n\n    public  PmdValidator(final Environment env);\n\n    @Override public String name();\n\n    private static final String STATIC_ACCESS;\n    private static final String CODE_IN_CON;\n    private static final String NO_CON_INIT;\n    private static final String MULT_CON_INIT;\n    private static final String BRACKETS;\n    private static final String PLAIN_ASSERTIONS;\n    private static final String STATIC_METHODS;\n    private static final String FILES_CREATE_ERR;\n\n}\n\nclass PmdValidatorTest {\n\n    private static final String STATIC_ACCESS;\n    private static final String CODE_IN_CON;\n    private static final String NO_CON_INIT;\n    private static final String MULT_CON_INIT;\n    private static final String BRACKETS;\n    private static final String PLAIN_ASSERTIONS;\n    private static final String STATIC_METHODS;\n    private static final String FILES_CREATE_ERR;\n\n    @Test\n    @SuppressWarnings(\"PMD.AvoidDuplicateLiterals\")\n    public void doesNotComplainAboutConstantsInInnerClasses() throws Exception {\n", "reference": "        final String file = \"src/main/java/foo/Foo.java\";\n        final Environment env = new Environment.Mock().withFile(\n            file,\n            Joiner.on('\\n').join(\n                \"package foo;\",\n                \"interface Foo {\",\n                \"  final class Bar implements Foo {\",\n                \"    private static final Pattern TEST =\",\n                \"      Pattern.compile(\\\"hey\\\");\",\n                \"    public String doSomething() {\",\n                \"      return Foo.Bar.TEST.toString();\",\n                \"    }\",\n                \"  }\",\n                \"}\"\n            )\n        );\n        MatcherAssert.assertThat(\n            new PmdValidator(env).validate(\n                Collections.singletonList(new File(env.basedir(), file))\n            ),\n            Matchers.<Violation>empty()\n        );\n    }\n\n}", "prediction": "       final File file = this.file(\"InnerClass.java\");\n        final Collection<Violation> violations = new PmdValidator(this.env).validate(\n            Collections.singleton(file)\n        );\n        MatcherAssert.assertThat(\n            violations,\n            Matchers.emptyIterable()\n        );\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "9623064_30", "part": [1, 1], "seq": [1, 1], "prompt": "class RequestUtils {\n\n    public static List<Request> from(String exp){\n        Matcher matcher = p4Range.matcher(exp);\n        if (!matcher.find()) {\n            return Collections.singletonList(new Request(exp));\n        }\n        int rangeFrom = Integer.parseInt(matcher.group(1));\n        int rangeTo = Integer.parseInt(matcher.group(2));\n        if (rangeFrom > rangeTo) {\n            return Collections.emptyList();\n        }\n        List<Request> requests = new ArrayList<Request>(rangeTo - rangeFrom + 1);\n        for (int i = rangeFrom; i <= rangeTo; i++) {\n            requests.add(new Request(matcher.replaceAll(String.valueOf(i))));\n        }\n        return requests;\n    }\n\n}\n\nclass RequestUtilsTest {\n\n    @Test\n    public void test_generate_range_when_invalid_number() throws Exception {\n", "reference": "        List<Request> requests = RequestUtils.from(\"http://angularjs.cn/api/article/latest?p=[10-3]&s=20\");\n        assertThat(requests).isEmpty();\n    }\n\n}", "prediction": "        List<Request> requests = RequestUtils.from(\"1-2-3\");\n        assertThat(requests).isEmpty();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "9836604_9", "part": [1, 1], "seq": [1, 1], "prompt": "class LogoutAction {\n\n\t@RequestMapping(\"/getAppList\")\n\tpublic void getAppList(HttpServletRequest request,\n\t\t\tHttpServletResponse response){\n\t\t//\u89e3\u6790\u7528\u6237\u51ed\u636e\u3002\n\t\tCredential credential = credentialResolver.resolveCredential(request);\n\t\t//\u5b9e\u73b0\u8f93\u51fa\u4e3ajson\u4e32\u3002\n\t\tList<App> list =  this.ki4soService.getAppList(credential);\n\t\tString json = JSON.toJSONString(list);\n\t\tStringBuffer sb = new StringBuffer();\n\t\tsb.append(getCallbackName(\"fetchAppList\", request))\n\t\t.append(\"(\")\n\t\t.append(json)\n\t\t.append(\");\");\n\t\ttry {\n\t\t\tresponse.setContentType(\"application/x-javascript\");\n\t\t\tresponse.setCharacterEncoding(\"UTF-8\");\n\t\t\tresponse.getWriter().println(sb.toString());\n\t\t} catch (IOException e) {\n\t\t}\n\t}\n\n\tpublic void setKi4soService(Ki4soService ki4soService);\n\tpublic void setCredentialResolver(CredentialResolver credentialResolver);\n\tprivate String getCallbackName(String defalutCallbackName, HttpServletRequest request);\n\t@RequestMapping(\"/logout\") public void logout(HttpServletRequest request,\n\t\t\tHttpServletResponse response);\n\n\t@Autowired\n\tprivate LogoutAction logoutAction;\n\n}\n\nclass LogoutActionTest {\n\n\t@Autowired\n\tprivate LogoutAction logoutAction;\n\n\t@Test\n\tpublic void testGetAppList() throws UnsupportedEncodingException {\n", "reference": "\t\t//\u6d4b\u8bd5\u51c6\u5907\u3002\n\t\tMockHttpServletRequest request = new MockHttpServletRequest();\n\t\tMockHttpServletResponse response = new MockHttpServletResponse();\n\t\tCredentialResolver credentialResolver = Mockito.mock(CredentialResolver.class);\n\t\tlogoutAction.setCredentialResolver(credentialResolver);\n\t\t\n\t\tKi4soService ki4soService = Mockito.mock(Ki4soService.class);\n\t\tlogoutAction.setKi4soService(ki4soService);\n\t\t\n\t\tCredential credential = Mockito.mock(Credential.class);\n\t\t\n\t\t//\u8bbe\u7f6e\u9884\u671f\u7ed3\u679c\u3002\n\t\tMockito.when(credentialResolver.resolveCredential(request)).thenReturn(credential);\n\t\tList<App> list = new ArrayList<App>();\n\t\tApp app = new App();\n\t\tapp.setAppId(\"1000\");\n\t\tapp.setAppName(\"\u6d4b\u8bd5\u5e94\u7528\u7a0b\u5e8f1\");\n\t\tapp.setHost(\"app.com\");\n\t\tapp.setLogoutUrl(\"http://app.com/logout.do\");\n\t\tlist.add(app);\n\t\tMockito.when(ki4soService.getAppList(credential)).thenReturn(list);\n\t\t\n\t\t//\u6267\u884c\u67e5\u8be2\u3002\n\t\tlogoutAction.getAppList(request, response);\n\t\t\n\t\t//\u68c0\u67e5\u7ed3\u679c\u3002\n\t\tAssert.assertEquals(\"application/x-javascript\", response.getContentType());\n\t\tAssert.assertEquals(\"UTF-8\", response.getCharacterEncoding());\n\t\t//\u68c0\u67e5\u8f93\u51fa\u7684jsonp\u4e32\u662f\u5426\u6b63\u786e\u3002\n\t\tString content = response.getContentAsString();\n\t\tcontent = content.trim();\n\t\tAssert.assertTrue(content.startsWith(\"fetchAppList(\"));\n\t\tAssert.assertTrue(content.endsWith(\");\"));\n\t\tString json = content.replaceFirst(\"fetchAppList\\\\(\", \"\");\n\t\tjson = json.replaceFirst(\"\\\\);\", \"\");\n\t\tJSONArray data = (JSONArray)JSON.parse(json);\n\t\tAssert.assertEquals(1, data.size());\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tMap<String, Object> map = (Map<String, Object>)data.get(0);\n\t\tAssert.assertEquals(\"1000\", map.get(\"appId\"));\n\t\t\n\t}\n\n}", "prediction": "\t\tlogoutAction.getAppList(null, null);\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "10566148_28", "part": [1, 1], "seq": [1, 1], "prompt": "class SagaExecutionTask implements ExecutedRunnable {\n\n    @Override\n    public void run() {\n        try {\n            handle();\n        } catch (Exception e) {\n            Throwables.throwIfUnchecked(e);\n            throw new RuntimeException(e);\n        }\n    }\n\n    @Inject  SagaExecutionTask(\n            final SagaEnvironment environment,\n            final HandlerInvoker invoker,\n            final Object message,\n            final Map<HeaderName<?>, Object> headers,\n            @Nullable final ExecutionContext parentContext);\n\n    public void handle();\n    private boolean startExecutionChain(final LookupContext messageLookupContext);\n    private boolean executeHandlersForMessage(final LookupContext messageLookupContext, final CurrentExecutionContext executionContext);\n    private void invokeSagas(final CurrentExecutionContext context, final Iterable<SagaInstanceInfo> sagaDescriptions, final Object invokeParam);\n    private void interceptorHandling(final Saga saga, final ExecutionContext context, final Object invokeParam);\n    private void interceptorHandlingExecuted(final Saga saga, final ExecutionContext context, final Object invokeParam);\n    private void interceptorFinished(final Saga saga, final ExecutionContext context);\n    private void interceptorStart(final SagaInstanceInfo sagaDescription, final ExecutionContext context, final Object invokeParam);\n    @SuppressWarnings(\"unchecked\") private void setHeaders(final CurrentExecutionContext context);\n    private void setSagaExecutionContext(final Saga saga, final ExecutionContext context);\n    private void updateStateStorage(final SagaInstanceInfo description, final CurrentExecutionContext context);\n    private void cleanupSagaSate(final String sagaId);\n    @Override public Object message();\n    @Override public Optional<T> getHeaderValue(final HeaderName<T> header);\n\n    private SagaExecutionTask sut;\n    private TimeoutManager timeoutManager;\n    private StateStorage storage;\n    private Saga saga;\n    private SagaInstanceInfo sagaInstanceInfo;\n    private SagaState state;\n    private CurrentExecutionContext context;\n    private Object theMessage;\n    private HandlerInvoker invoker;\n    private InstanceResolver instanceResolver;\n    private SagaModule module;\n    private SagaLifetimeInterceptor interceptor;\n    @Rule\n    public ExpectedException thrown;\n\n}\n\nclass SagaExecutionTaskTest {\n\n    private SagaExecutionTask sut;\n    private TimeoutManager timeoutManager;\n    private StateStorage storage;\n    private Saga saga;\n    private SagaInstanceInfo sagaInstanceInfo;\n    private SagaState state;\n    private CurrentExecutionContext context;\n    private Object theMessage;\n    private HandlerInvoker invoker;\n    private InstanceResolver instanceResolver;\n    private SagaModule module;\n    private SagaLifetimeInterceptor interceptor;\n    @Rule\n    public ExpectedException thrown;\n\n    @Test\n    public void run_invokeThrows_moduleErrorGetsCalled() throws InvocationTargetException, IllegalAccessException {\n", "reference": "        // given\n        NullPointerException npe = new NullPointerException();\n        doThrow(npe).when(invoker).invoke(isA(InvocationContext.class));\n\n        try {\n            // when\n            sut.run();\n        } catch (NullPointerException ex) {\n            // got you\n        }\n\n        // then\n        verify(module).onError(context, theMessage, npe);\n    }\n\n}", "prediction": "        // given\n        doThrow(new RuntimeException()).when(invoker).invoke(any(), any(), any());\n\n        // when\n        sut.run();\n\n        // then\n        verify(module).error(any(), any(), any(), any());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "10585052_3", "part": [1, 1], "seq": [1, 1], "prompt": "class Stamp implements Serializable {\n\n    public Stamp join(Stamp other) {\n        ID idSum = id.sum(other.id);\n        Event eventJoin = event.join(other.event);\n        return new Stamp(idSum, eventJoin);\n    }\n\n    public  Stamp();\n      Stamp(ID id, Event event);\n\n     ID getId();\n     Event getEvent();\n    public Stamp[] fork();\n    public Stamp[] peek();\n    public Stamp event();\n    @Override public String toString();\n    @Override public boolean equals(Object o);\n    @Override public int hashCode();\n    public Stamp[] send();\n    public Stamp receive(Stamp other);\n    public Stamp[] sync(Stamp other);\n    public boolean leq(Stamp other);\n\n    private Stamp seedStamp;\n    private Stamp forkedStamp1;\n    private Stamp forkedStamp2;\n    private Stamp joinedStamp;\n    private List<Stamp> stamps;\n\n}\n\nclass StampTest {\n\n    private Stamp seedStamp;\n    private Stamp forkedStamp1;\n    private Stamp forkedStamp2;\n    private Stamp joinedStamp;\n    private List<Stamp> stamps;\n\n    @Test\n    public void testJoin() {\n", "reference": "        Stamp expected = new Stamp(IDs.one(),\n                Events.with(1, Events.zero(), Events.with(1)));\n\n        assertEquals(expected, forkedStamp1.join(forkedStamp2));\n        assertEquals(expected, forkedStamp2.join(forkedStamp1));\n        assertNormalizedStamp(forkedStamp1.join(forkedStamp2));\n    }\n\n}", "prediction": "        Stamp stamp1 = new Stamp(new ID(1), new Event(1));\n        Stamp stamp2 = new Stamp(new ID(2), new Event(2));\n        Stamp stamp3 = stamp1.join(stamp2);\n        assertEquals(stamp3.getId(), new ID(3));\n        assertEquals(stamp3.getEvent(), new Event(3));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "10981994_42", "part": [1, 1], "seq": [1, 1], "prompt": "class Slf4jLogger extends feign.Logger {\n\n  @Override\n  protected void log(String configKey, String format, Object... args) {\n    // Not using SLF4J's support for parameterized messages (even though it would be more efficient)\n    // because it would\n    // require the incoming message formats to be SLF4J-specific.\n    if (logger.isDebugEnabled()) {\n      logger.debug(String.format(methodTag(configKey) + format, args));\n    }\n  }\n\n  public  Slf4jLogger();\n  public  Slf4jLogger(Class<?> clazz);\n  public  Slf4jLogger(String name);\n    Slf4jLogger(Logger logger);\n\n  @Override protected void logRequest(String configKey, Level logLevel, Request request);\n  @Override protected Response logAndRebufferResponse(String configKey,\n                                            Level logLevel,\n                                            Response response,\n                                            long elapsedTime);\n\n  private static final String CONFIG_KEY;\n  private static final Request REQUEST;\n  private static final Response RESPONSE;\n  @Rule\n  public final RecordingSimpleLogger slf4j;\n  private Slf4jLogger logger;\n\n}\n\nclass Slf4jLoggerTest {\n\n  private static final String CONFIG_KEY;\n  private static final Request REQUEST;\n  private static final Response RESPONSE;\n  @Rule\n  public final RecordingSimpleLogger slf4j;\n  private Slf4jLogger logger;\n\n  @Test\n  public void useLoggerByNameIfRequested() throws Exception {\n", "reference": "    slf4j.logLevel(\"debug\");\n    slf4j.expectMessages(\n        \"DEBUG named.logger - [someMethod] This is my message\" + System.lineSeparator());\n\n    logger = new Slf4jLogger(\"named.logger\");\n    logger.log(CONFIG_KEY, \"This is my message\");\n  }\n\n}", "prediction": "    logger = new Slf4jLogger(\"com.example.Foo\");\n    logger.logRequest(CONFIG_KEY, Level.FULL, REQUEST);\n    assertThat(slf4j.getLoggedMessages())\n        .containsExactly(\"[com.example.Foo] [TRACE] [com.example.Foo] request: \" + REQUEST);\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "10984947_0", "part": [1, 1], "seq": [1, 1], "prompt": "class OAuthDialogFragment extends DialogFragmentCompat {\n\n    static boolean isRedirectUriFound(String uri, String redirectUri) {\n        Uri u = null;\n        Uri r = null;\n        try {\n            u = Uri.parse(uri);\n            r = Uri.parse(redirectUri);\n        } catch (NullPointerException e) {\n            return false;\n        }\n        if (u == null || r == null) {\n            return false;\n        }\n        boolean rOpaque = r.isOpaque();\n        boolean uOpaque = u.isOpaque();\n        if (rOpaque != uOpaque) {\n            return false;\n        }\n        if (rOpaque) {\n            return TextUtils.equals(uri, redirectUri);\n        }\n        if (!TextUtils.equals(r.getScheme(), u.getScheme())) {\n            return false;\n        }\n        if (!TextUtils.equals(r.getAuthority(), u.getAuthority())) {\n            return false;\n        }\n        if (r.getPort() != u.getPort()) {\n            return false;\n        }\n        if (!TextUtils.isEmpty(r.getPath()) && !TextUtils.equals(r.getPath(), u.getPath())) {\n            return false;\n        }\n        Set<String> paramKeys = CompatUri.getQueryParameterNames(r);\n        for (String key : paramKeys) {\n            if (!TextUtils.equals(r.getQueryParameter(key), u.getQueryParameter(key))) {\n                return false;\n            }\n        }\n        String frag = r.getFragment();\n        if (!TextUtils.isEmpty(frag)\n                && !TextUtils.equals(frag, u.getFragment())) {\n            return false;\n        }\n        return true;\n    }\n\n    private  OAuthDialogFragment(android.app.DialogFragment fragment, boolean fullScreen,\n        boolean horizontalProgress, boolean hideFullScreenTitle);\n    private  OAuthDialogFragment(android.support.v4.app.DialogFragment fragment,\n        boolean fullScreen, boolean horizontalProgress, boolean hideFullScreenTitle);\n\n    final void setController(AuthorizationDialogController controller);\n    @TargetApi(HONEYCOMB) public static final OAuthDialogFragment newInstance(\n            GenericUrl authorizationRequestUrl,\n            DialogFragmentController controller);\n    @Override Dialog onCreateDialog(Bundle savedInstanceState);\n    @Override View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState);\n    @SuppressLint(\"SetJavaScriptEnabled\") @Override void onViewCreated(View view, Bundle savedInstanceState);\n    @Override void onActivityCreated(Bundle savedInstanceState);\n    @Override void onDestroy();\n    @Override void onCancel(DialogInterface dialog);\n    private void onError(String errorMessage);\n    private void setProgressShown(String url, View view, int newProgress);\n\n}\n\nclass OAuthDialogFragmentTest extends DialogFragmentCompat {\n\n    @Test\n    public void testRedirectUriDetection() {\n", "reference": "        String r1 = \"http://localhost\";\n        String r2 = \"http://localhost:8080\";\n        String r3 = \"http://localhost:8080/path\";\n        String r4 = \"http://localhost:8080/path?a=1&b=2\";\n        String r5 = \"http://localhost:8080/path#frag\";\n\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(r1, r1));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(r2, r2));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(r3, r2));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(r4, r2));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(r5, r2));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(r4, r3));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(r5, r3));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(r4, r4));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(r5, r5));\n\n        assertFalse(OAuthDialogFragment.isRedirectUriFound(r1, r2));\n        assertFalse(OAuthDialogFragment.isRedirectUriFound(r1, r3));\n        assertFalse(OAuthDialogFragment.isRedirectUriFound(r1, r4));\n        assertFalse(OAuthDialogFragment.isRedirectUriFound(r1, r5));\n        assertFalse(OAuthDialogFragment.isRedirectUriFound(r2, r1));\n        assertFalse(OAuthDialogFragment.isRedirectUriFound(r2, r3));\n        assertFalse(OAuthDialogFragment.isRedirectUriFound(r2, r4));\n        assertFalse(OAuthDialogFragment.isRedirectUriFound(r2, r5));\n        assertFalse(OAuthDialogFragment.isRedirectUriFound(r3, r1));\n        assertFalse(OAuthDialogFragment.isRedirectUriFound(r3, r4));\n        assertFalse(OAuthDialogFragment.isRedirectUriFound(r3, r5));\n        assertFalse(OAuthDialogFragment.isRedirectUriFound(r4, r1));\n        assertFalse(OAuthDialogFragment.isRedirectUriFound(r4, r5));\n        assertFalse(OAuthDialogFragment.isRedirectUriFound(r5, r1));\n        assertFalse(OAuthDialogFragment.isRedirectUriFound(r5, r4));\n\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(r4 + \"&c=3\", r4));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(\"http://localhost:8080/path?b=2&a=1\", r4));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(\"http://localhost:8080/path?c=3&b=2&a=1\", r4));\n    }\n\n}", "prediction": "        assertTrue(OAuthDialogFragment.isRedirectUriFound(\"http://example.com/\",\n                \"http://example.com/\"));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(\"http://example.com/\",\n                \"http://example.com\"));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(\"http://example.com/\",\n                \"http://example.com/\"));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(\"http://example.com/\",\n                \"http://example.com/\"));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(\"http://example.com/\",\n                \"http://example.com/\"));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(\"http://example.com/\",\n                \"http://example.com/\"));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(\"http://example.com/\",\n                \"http://example.com/\"));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(\"http://example.com/\",\n                \"http://example.com/\"));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(\"http://example.com/\",\n                \"http://example.com/\"));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(\"http://example.com/\",\n                \"http://example.com/\"));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(\"http://example.com/\",\n                \"http://example.com/\"));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(\"http://example.com/\",\n                \"http://example.com/\"));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(\"http://example.com/\",\n                \"http://example.com/\"));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(\"http://example.com/\",\n                \"http://example.com/\"));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(\"http://example.com/\",\n                \"http://example.com/\"));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(\"http://example.com/\",\n                \"http://example.com/\"));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(\"http://example.com/\",\n                \"http://example.com/\"));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(\"http://example.com/\",\n                \"http://example.com/\"));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(\"http://example.com/\",\n                \"http://example.com/\"));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(\"http://example.com/\",\n                \"http://example.com/\"));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(\"http://example.com/\",\n                \"http://example.com/\"));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(\"http://example.com/\",\n                \"http://example.com/\"));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(\"http://example.com/\",\n                \"http://example.com/\"));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(\"http://example.com/\",\n                \"http://example.com/\"));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(\"http://example.com/\",\n                \"http://example.com/\"));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(\"http://example.com/\",\n                \"http://example.com/\"));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(\"http://example.com/\",\n                \"http://example.com/\"));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(\"http://example.com/\",\n                \"http://example.com/\"));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(\"http://example.com/\",\n                \"http://example.com/\"));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(\"http://example.com/\",\n                \"http://example.com/\"));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(\"http://example.com/\",\n                \"http://example.com/\"));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(\"http://example.com/\",\n                \"http://example.com/\"));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(\"http://example.com/\",\n                \"http://example.com/\"));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(\"http://example.com/\",\n                \"http://example.com/\"));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(\"http://example.com/\",\n                \"http://example.com/\"));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(\"http://example.com/\",\n                \"http://example.com/\"));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(\"http://example.com/\",\n                \"http://example.com/\"));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(\"http://example.com/\",\n                \"http://example.com/\"));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(\"http://example.com/\",\n                \"http://example.com/\"));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(\"http://example.com/\",\n                \"http://example.com/\"));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(\"http://example.com/\",\n                \"http://example.com/\"));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(\"http://example.com/\",", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "11461895_2", "part": [1, 1], "seq": [1, 1], "prompt": "class Address {\n\n    public static boolean verify(@Nullable String address, boolean acceptSegwit) {\n        Address decodedAddress = decode(address);\n        return decodedAddress != null && (acceptSegwit || decodedAddress.witnessProgram == null);\n    }\n\n      Address(@Nullable String address);\n      Address(boolean testNet, Transaction.Script.WitnessProgram witnessProgram);\n\n    @NonNull @Override public String toString();\n    static Address decode(String address);\n    public static boolean verify(@Nullable String address);\n    static String publicKeyToAddress(byte[] publicKey);\n    static String publicKeyToAddress(boolean testNet, byte[] publicKey);\n    static String publicKeyToP2wkhAddress(boolean testNet, byte[] publicKey);\n    static String publicKeyToP2shP2wkhAddress(boolean testNet, byte[] publicKey);\n    static String ripemd160HashToAddress(boolean testNet, byte[] hashedPublicKey);\n    static String ripemd160HashToP2shAddress(boolean testNet, byte[] hashedPublicKey);\n    private static String ripemd160HashToAddress(byte version, byte[] hashedPublicKey);\n    @Override public boolean equals(Object o);\n    @Override public int hashCode();\n\n}\n\nclass AddressTest {\n\n    @Test\n    public void verify() {\n", "reference": "        assertTrue(Address.verify(\"1111111111111111111114oLvT2\", false));\n        assertTrue(Address.verify(\"1111111111111111111114oLvT2\", true));\n        assertFalse(Address.verify(\"111111111111111111117K4nzc\", false));\n        assertFalse(Address.verify(\"111111111111111111117K4nzc\", true));\n        assertFalse(Address.verify(\"1Wh4bh\", false));\n        assertFalse(Address.verify(\"1Wh4bh\", true));\n    }\n\n}", "prediction": "        assertTrue(Address.verify(\"123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "11556529_9", "part": [1, 1], "seq": [1, 1], "prompt": "class PauselessHashMap extends java.util.AbstractMap<K, V> implements Map<K, V>,\n        Cloneable, Serializable {\n\n    @Override\n    public V put(K key, V value) {\n        return putImpl(key, value);\n    }\n\n    public  PauselessHashMap();\n    public  PauselessHashMap(int capacity);\n    public  PauselessHashMap(int capacity, float loadFactor);\n    public  PauselessHashMap(Map<? extends K, ? extends V> map);\n\n    @SuppressWarnings(\"unchecked\") Entry<K, V>[] newElementArray(int s);\n    private static final int calculateCapacity(int x);\n    @Override public void clear();\n    private void clearImpl();\n    @Override public Object clone();\n    @SuppressWarnings(\"unchecked\") private Object cloneImpl();\n    private void computeThreshold();\n    @Override public boolean containsKey(Object key);\n    @Override @SuppressWarnings(\"unchecked\") public boolean containsValue(Object value);\n    @Override public Set<Map.Entry<K, V>> entrySet();\n    @Override public V get(Object key);\n    final Entry<K, V> getEntry(Object key);\n    final Entry<K,V> findNonNullKeyEntry(Object key, int index, int keyHash);\n    @SuppressWarnings(\"unchecked\") final Entry<K,V> findNonNullKeyEntryInElementData(Object key, int index, int keyHash);\n    @SuppressWarnings(\"unchecked\") final Entry<K,V> findNonNullKeyEntryInResizingIntoElementData(Object key, int index, int keyHash);\n    final Entry<K,V> findNonNullKeyEntryInChain(Object key, Entry<K,V> chainHead, int keyHash);\n    final Entry<K,V> findNullKeyEntry();\n    @SuppressWarnings(\"unchecked\") final Entry<K,V> findNullKeyEntryInElementData();\n    @SuppressWarnings(\"unchecked\") final Entry<K,V> findNullKeyEntryInResizingIntoElementData();\n    final Entry<K,V> findNullKeyEntryInChain(Entry<K,V> chainHead);\n    @Override public boolean isEmpty();\n    @Override public Set<K> keySet();\n    private V putImpl(K key, V value);\n     void forceFinishResizing();\n     void finishResizing();\n    @SuppressWarnings(\"unchecked\") Entry<K, V> createEntry(K key, int index, V value);\n    @SuppressWarnings(\"unchecked\") Entry<K,V> createHashedEntry(K key, int index, int hash);\n    @Override public void putAll(Map<? extends K, ? extends V> map);\n    private void putAllImpl(Map<? extends K, ? extends V> map);\n     void rehash(int capacity);\n     void rehash();\n    @Override public V remove(Object key);\n    private V removeImpl(Object key);\n    @SuppressWarnings(\"unchecked\") final void removeEntry(Entry<K, V> entry);\n    @SuppressWarnings(\"unchecked\") final Entry<K, V> removeEntry(Object key);\n    @Override public int size();\n    @Override public Collection<V> values();\n    private void writeObject(ObjectOutputStream stream);\n    @SuppressWarnings(\"unchecked\") private void readObject(ObjectInputStream stream);\n    static int computeHashCode(Object key);\n    static boolean areEqualKeys(Object key1, Object key2);\n    static boolean areEqualValues(Object value1, Object value2);\n    final void kickBackgroundResize(int capacity);\n    final void doResize(int capacity);\n\n     PauselessHashMap hm;\n    final static int hmSize;\n    static Object[] objArray;\n    static Object[] objArray2;\n\n}\n\nclass PauselessHashMapTest extends java.util.AbstractMap<K, V> {\n\n     PauselessHashMap hm;\n    final static int hmSize;\n    static Object[] objArray;\n    static Object[] objArray2;\n\n    @Test\n    public void testSerializationSelf() throws Exception {\n", "reference": "        PauselessHashMap<String, String> hm = new PauselessHashMap<String, String>();\n        hm.put(\"key\", \"value\");\n\n//        SerializationTest.verifySelf(hm);\n\n        //  regression for HARMONY-1583\n        hm.put(null, \"null\");\n//        SerializationTest.verifySelf(hm);\n    }\n\n}", "prediction": "        PauselessHashMap<String, String> hm = new PauselessHashMap<>();\n        hm.put(\"1\", \"1\");\n        hm.put(\"2\", \"2\");\n        hm.put(\"3\", \"3\");\n        hm.put(\"4\", \"4\");\n        hm.put(\"5\", \"5\");\n        hm.put(\"6\", \"6\");\n        hm.put(\"7\", \"7\");\n        hm.put(\"8\", \"8\");\n        hm.put(\"9\", \"9\");\n        hm.put(\"10\", \"10\");\n        hm.put(\"11\", \"11\");\n        hm.put(\"12\", \"12\");\n        hm.put(\"13\", \"13\");\n        hm.put(\"14\", \"14\");\n        hm.put(\"15\", \"15\");\n        hm.put(\"16\", \"16\");\n        hm.put(\"17\", \"17\");\n        hm.put(\"18\", \"18\");\n        hm.put(\"19\", \"19\");\n        hm.put(\"20\", \"20\");\n        hm.put(\"21\", \"21\");\n        hm.put(\"22\", \"22\");\n        hm.put(\"23\", \"23\");\n        hm.put(\"24\", \"24\");\n        hm.put(\"25\", \"25\");\n        hm.put(\"26\", \"26\");\n        hm.put(\"27\", \"27\");\n        hm.put(\"28\", \"28\");\n        hm.put(\"29\", \"29\");\n        hm.put(\"30\", \"30\");\n        hm.put(\"31\", \"31\");\n        hm.put(\"32\", \"32\");\n        hm.put(\"33\", \"33\");\n        hm.put(\"34\", \"34\");\n        hm.put(\"35\", \"35\");\n        hm.put(\"36\", \"36\");\n        hm.put(\"37\", \"37\");\n        hm.put(\"38\", \"38\");\n        hm.put(\"39\", \"39\");\n        hm.put(\"40\", \"40\");\n        hm.put(\"41\", \"41\");\n        hm.put(\"42\", \"42\");\n        hm.put(\"43\", \"43\");\n        hm.put(\"44\", \"44\");\n        hm.put(\"45\", \"45\");\n        hm.put(\"46\", \"46\");\n        hm.put(\"47\", \"47\");\n        hm.put(\"48\", \"48\");\n        hm.put(\"49\", \"49\");\n        hm.put(\"50\", \"50\");\n        hm.put(\"51\", \"51\");\n        hm.put(\"52\", \"52\");\n        hm.put(\"53\", \"53\");\n        hm.put(\"54\", \"54\");\n        hm.put(\"55\", \"55\");\n        hm.put(\"56\", \"56\");\n        hm.put(\"57\", \"57\");\n        hm.put(\"58\", \"58\");\n        hm.put(\"59\", \"59\");\n        hm.put(\"60\", \"60\");\n        hm.put(\"61\", \"61\");\n        hm.put(\"62\", \"62\");\n        hm.put(\"63\", \"63\");\n        hm.put(\"64\", \"64\");\n        hm.put(\"65\", \"65\");\n        hm.put(\"66\", \"66\");\n        hm.put(\"67\", \"67\");\n        hm.put(\"68\", \"68\");\n        hm.put(\"69\", \"69\");\n        hm.put(\"70\", \"70\");\n        hm.put(\"71\", \"71\");\n        hm.put(\"72\", \"72\");\n        hm.put(\"73\", \"73\");\n        hm.put(\"74\", \"74\");\n        hm.put(\"75\", \"75\");\n        hm", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "11585818_8", "part": [1, 1], "seq": [1, 1], "prompt": "class LogJobFactory implements AsynchronousSpanSink.JobFactory {\n\n    public static LogJobFactory withWriter(final Writer writer) {\n        if (writer == null) throw new NullPointerException(\"Writer must not be null\");\n        return withWriterProvider(new WriterProvider() {\n            @Override\n            public Writer getWriter() throws IOException {\n                return writer;\n            }\n        });\n    }\n\n    private  LogJobFactory(WriterProvider writerProvider);\n\n    public static LogJobFactory withFile(final String file);\n    @Override public Runnable createJob(SpanData data);\n    private static LogJobFactory withWriterProvider(WriterProvider writerProvider);\n\n}\n\nclass LogJobFactoryTest {\n\n    @Test\n    public void testCreateWithWriter() throws Exception {\n", "reference": "        LogJobFactory.withWriter(new StringWriter());\n    }\n\n}", "prediction": "        final Writer writer = mock(Writer.class);\n        LogJobFactory.withWriter(writer).createJob(mock(SpanData.class));\n        verify(writer).write(anyString());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "11614244_58", "part": [1, 1], "seq": [1, 1], "prompt": "class EqualQa implements Qa<Boolean, Boolean> {\n\n    @Override\n    public TransientOperation<Boolean, Boolean> evaluate(final BufferedImage left, final BufferedImage right) {\n        // Check size\n        CheckEqualSizePreprocessor equalSize = new CheckEqualSizePreprocessor(left, right);\n        equalSize.process();\n        equalSize = null;\n\n        ConvenientBufferedImageWrapper leftWrapped = new ConvenientBufferedImageWrapper(left);\n        ConvenientBufferedImageWrapper rightWrapped = new ConvenientBufferedImageWrapper(right);\n        AutoColorConverter convLeft = new AutoColorConverter(leftWrapped, rightWrapped,\n                                                             AutoColorConverter.AlternativeColorConverter.CIEXYZ);\n        AutoColorConverter convRight = new AutoColorConverter(rightWrapped, leftWrapped,\n                                                              AutoColorConverter.AlternativeColorConverter.CIEXYZ);\n\n        // Evaluate\n        EqualMetric metric = new EqualMetric(convLeft, convRight, new Point(0, 0),\n                                             new Point(left.getWidth(), left.getHeight()));\n\n        // Evaluate\n        return metric.execute();\n    }\n\n}\n\nclass EqualQaTest  {\n\n    @Test\n    public void evaluateTest_half000000_111111_half000000_111111() {\n", "reference": "        BufferedImage left = BufferedImageHelper.createSolidHalfImage(new Color(0, 0, 0), new Color(255, 255, 255));\n        BufferedImage right = BufferedImageHelper.createSolidHalfImage(new Color(0, 0, 0), new Color(255, 255, 255));\n\n        EqualQa equalQa = new EqualQa();\n        TransientOperation<Boolean, Boolean> op = equalQa.evaluate(left, right);\n        Assert.assertEquals(true, op.getAggregatedResult());\n        Assert.assertEquals(true, op.getResult());\n    }\n\n}", "prediction": "        BufferedImage left = new BufferedImage(10, 10, BufferedImage.TYPE_INT_RGB);\n        BufferedImage right = new BufferedImage(10, 10, BufferedImage.TYPE_INT_RGB);\n        Graphics gLeft = left.getGraphics();\n        gLeft.setColor(Color.BLACK);\n        gLeft.fillRect(0, 0, 5, 5);\n        gLeft.setColor(Color.WHITE);\n        gLeft.fillRect(5, 5, 5, 5);\n        gLeft.dispose();\n\n        Graphics gRight = right.getGraphics();\n        gRight.setColor(Color.BLACK);\n        gRight.fillRect(0, 0, 5, 5);\n        gRight.setColor(Color.WHITE);\n        gRight.fillRect(5, 5, 5, 5);\n        gRight.dispose();\n\n        TransientOperation<Boolean, Boolean> result = new EqualQa().evaluate(left, right);\n        assertTrue(result.getResult());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "11997640_0", "part": [1, 1], "seq": [1, 1], "prompt": "class AutoKeeperCollector implements InitializingBean {\n\n    public void collectorServerStat(String address) {\n        List<String> netAddress = splitAddress(address);\n        if (netAddress.isEmpty()) {\n            return;\n        }\n        String ip = netAddress.get(0);\n        String port = netAddress.get(1);\n        String[] cmd = { \"/bin/bash\", \"-c\", String.format(CMD_STAT, ip, port) };\n        String cmdresult = collector(cmd);\n        String[] result = cmdresult.split(WRAP);\n        AutoKeeperServerStat summary = new AutoKeeperServerStat();\n        summary.setOriginalContent(cmdresult);\n        for (String line : result) {\n\n            if (line.contains(MODE_FOLLOWER)) {\n                summary.setQuorumType(AutoKeeperQuorumType.FOLLOWER);\n            } else if (line.contains(MODE_LEADERER)) {\n                summary.setQuorumType(AutoKeeperQuorumType.LEADER);\n            } else if (line.contains(MODE_STANDALONE)) {\n                summary.setQuorumType(AutoKeeperQuorumType.STANDALONE);\n            } else if (line.contains(MODE_OBSERVER)) {\n                summary.setQuorumType(AutoKeeperQuorumType.OBSERVER);\n            } else if (line.contains(STRING_LATENCY)) {\n                List<String> latency = Arrays.asList(StringUtils.trimToEmpty(line.replace(STRING_LATENCY,\n                                                                                          StringUtils.EMPTY)).split(\"/\"));\n                summary.setMinLatency(Long.parseLong(latency.get(0)));\n                summary.setAvgLatency(Long.parseLong(latency.get(1)));\n                summary.setMaxLatency(Long.parseLong(latency.get(2)));\n            } else if (line.contains(STRING_OUTSTANDING)) {\n                summary.setQueued(Long.parseLong(StringUtils.trimToEmpty(line.replace(STRING_OUTSTANDING,\n                                                                                      StringUtils.EMPTY))));\n            } else if (line.contains(NODE_COUNT)) {\n                summary.setNodeCount(Long.parseLong(StringUtils.trimToEmpty(line.replace(NODE_COUNT, StringUtils.EMPTY))));\n            } else if (line.contains(STRING_SENT)) {\n                summary.setSent(Long.parseLong(StringUtils.trimToEmpty(line.replace(STRING_SENT, StringUtils.EMPTY))));\n            } else if (line.contains(STRING_RECEIVED)) {\n                summary.setRecved(Long.parseLong(StringUtils.trimToEmpty(line.replace(STRING_RECEIVED,\n                                                                                      StringUtils.EMPTY))));\n            }\n        }\n\n        autoKeeperData.joinServer(address, summary);\n    }\n\n    public void collectorConnectionStat(String address);\n    public void collectorEphemeralStat(String address);\n    public void collectorWatchStat(String address);\n    public static String collector(String[] command);\n    private List<String> splitAddress(String address);\n    private Map<String, List<String>> groupSessionPath(String cmdresult);\n    @Override public void afterPropertiesSet();\n    private void startCollect();\n    public void setAutoKeeperClusterService(AutoKeeperClusterService autoKeeperClusterService);\n    public void setAutoKeeperData(AutoKeeperData autoKeeperData);\n    public void setCollectInterval(long collectInterval);\n\n    @SpringBeanByName\n    private AutoKeeperCollector autoKeeperCollector;\n    @SpringBeanByName\n    private AutoKeeperStatService autoKeeperStatService;\n    private final static String ADDRESS;\n\n}\n\nclass AutoKeeperCollectorTest  {\n\n    @SpringBeanByName\n    private AutoKeeperCollector autoKeeperCollector;\n    @SpringBeanByName\n    private AutoKeeperStatService autoKeeperStatService;\n    private final static String ADDRESS;\n\n    @Test\n    public void testCollectorServerStat() {\n", "reference": "        autoKeeperCollector.collectorServerStat(ADDRESS);\n        autoKeeperCollector.collectorConnectionStat(ADDRESS);\n        autoKeeperCollector.collectorWatchStat(ADDRESS);\n        autoKeeperCollector.collectorEphemeralStat(ADDRESS);\n        AutoKeeperServerStat stat = autoKeeperStatService.findServerStat(ADDRESS);\n        Set<AutoKeeperConnectionStat> conns = stat.getConnectionStats();\n        for (AutoKeeperConnectionStat autoKeeperConnectionStat : conns) {\n            autoKeeperStatService.findConnectionBySessionId(autoKeeperConnectionStat.getSessionId());\n            autoKeeperStatService.findServerStatBySessionId(autoKeeperConnectionStat.getSessionId());\n            String path = autoKeeperConnectionStat.getClientAddress();\n            System.out.println(path);\n        }\n    }\n\n}", "prediction": "        autoKeeperCollector.collectorServerStat(ADDRESS);\n        AutoKeeperServerStat serverStat = autoKeeperStatService.getServerStat(ADDRESS);\n        Assert.assertNotNull(serverStat);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "12061606_111", "part": [1, 1], "seq": [1, 1], "prompt": "class Parser {\n\n    static Graph strict(String str) throws InvalidSmilesException {\n        return new Parser(CharBuffer.fromString(str), true).molecule();\n    }\n\n      Parser(CharBuffer buffer, boolean strict);\n      Parser(String str);\n\n    static Graph losse(String str);\n     Graph molecule();\n    private void createTopologies(CharBuffer buffer);\n    public List<Edge> getEdges(LocalArrangement localArrangement, int u);\n    private int getOtherDb(int u, int v);\n    private int[] findExtendedTetrahedralEnds(int focus);\n    private List<Edge> getLocalEdges(int end);\n    public int[] getAlleneCarriers(int focus);\n    private void addTopology(int u, Configuration c);\n    private int[] insertThImplicitRef(int u, int[] vs);\n    private int[] insertDbImplicitRef(int u, int[] vs);\n    private void addAtom(Atom a, CharBuffer buffer);\n    private void readSmiles(final CharBuffer buffer);\n     Atom readBracketAtom(final CharBuffer buffer);\n    static int readHydrogens(final CharBuffer buffer);\n    static int readCharge(final CharBuffer buffer);\n    private static int readCharge(int acc, final CharBuffer buffer);\n    static int readClass(CharBuffer buffer);\n    private void ring(int rnum, CharBuffer buffer);\n    private void openRing(int rnum, CharBuffer buf);\n    private LocalArrangement createArrangement(int u);\n    private void closeRing(int rnum, CharBuffer buffer);\n     Bond decideBond(final Bond a, final Bond b, int pos, CharBuffer buffer);\n    static Graph parse(String str);\n    public Collection<? extends String> getWarnings();\n\n}\n\nclass ParserTest {\n\n    @Test\n    public void hydrogen_strict_okay() throws IOException {\n", "reference": "        Graph g = Parser.strict(\"[H][H]\");\n    }\n\n}", "prediction": "        Graph g = Parser.strict(\"[H]\");\n        assertEquals(1, g.vertexSet().size());\n        assertEquals(0, g.edgeSet().size());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "12481904_3", "part": [1, 1], "seq": [1, 1], "prompt": "class Organization extends Party {\n\n    public List<Department> listChildDepartments() {\n        String jpql = \"select c from OrgLineMgmt o join o.responsible c \" +\n                \"where o.commissioner = :commissioner and TYPE(c) = Department\";\n        return getRepository().createJpqlQuery(jpql).addParameter(\"commissioner\", this).list();\n    }\n\n    public  Organization();\n    public  Organization(String name);\n\n    public Organization getParent(Date date);\n    public List<Organization> getChildren(Date date);\n    public List<Company> listChildCompanies();\n    public Set<Post> getPosts(Date date);\n    @Override public void terminate(Date date);\n    private boolean hasEmployees(Date date);\n    @Override public String toString();\n\n}\n\nclass OrganizationTest extends Party {\n\n    @Test\n    public final void listChildDepartments() {\n", "reference": "        OrganisationUtils organisationUtils = new OrganisationUtils();\n        Date date = DateUtils.date(2012, 1, 3);\n        Company headquarter = organisationUtils.createCompany(\"\u603b\u516c\u53f8\", date);\n        headquarter.save();\n        Department financial = organisationUtils.createDepartment(\"\u8d22\u52a1\u90e8\", headquarter, date);\n        Company company1 = organisationUtils.createCompany(\"\u5206\u516c\u53f81\", headquarter, date);\n        Department dept1 = organisationUtils.createDepartment(\"\u6838\u7b97\u79d1\", financial, date);\n        Department dept2 = organisationUtils.createDepartment(\"\u8d22\u52a1\u90e82\", company1, date);\n\n        List<Department> departments = headquarter.listChildDepartments();\n\n        assertTrue(departments.contains(financial));\n        assertFalse(departments.contains(company1));\n        assertFalse(departments.contains(dept1));\n        assertFalse(departments.contains(dept2));\n    }\n\n}", "prediction": "        Organization org = new Organization(\"org\");\n        Department dept = new Department(\"dept\");\n        org.addChild(dept);\n        assertEquals(Collections.singletonList(dept), org.listChildDepartments());\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "12483976_0", "part": [1, 1], "seq": [1, 1], "prompt": "class AsyncRunner {\n\n    public static <RESULT> RESULT run(Callable<RESULT> task) throws ExecutionException, InterruptedException {\n        return submit(null, task).get().unwrap();\n    }\n\n    private  AsyncRunner();\n\n    public static Future<AsyncResult<RESULT>> submit(Callback<RESULT> callback, Callable<RESULT> task);\n    public static RESULT run(Callable<RESULT> task, long timeout, TimeUnit unit);\n    public static void setExecutor(AsyncExecutor executor);\n\n    @Rule\n    public ExpectedException exception;\n\n}\n\nclass AsyncRunnerTest {\n\n    @Rule\n    public ExpectedException exception;\n\n    @Test\n    public void runIsSynchronous() throws Exception {\n", "reference": "        final long timeout = 5000;\n\n        Callable<Boolean> task = new Callable<Boolean>() {\n            @Override\n            public Boolean call() throws Exception {\n                Thread.sleep(timeout);\n                return false;\n            }\n        };\n\n        long startTime = System.currentTimeMillis();\n\n        Boolean result = AsyncRunner.run(task);\n\n        long endTime = System.currentTimeMillis();\n\n        assertThat(result, is(false));\n        assertThat(endTime - startTime, greaterThanOrEqualTo(timeout));\n    }\n\n}", "prediction": "        AsyncRunner.run(() -> {\n            throw new RuntimeException();\n        });\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "12925113_6", "part": [1, 1], "seq": [1, 1], "prompt": "class YkneoBitcoinSoft implements YkneoBitcoin {\n\n    @Override\n    public byte[] sign(byte[] hash, int... index) throws PinModeLockedException, UnusableIndexException, IOException, NoKeyLoadedException {\n        DeterministicKey key = getKey(index);\n        ECKey.ECDSASignature signature = key.toECKey().sign(new Sha256Hash(hash));\n        return signature.encodeToDER();\n    }\n\n    public  YkneoBitcoinSoft();\n\n    @Override public byte[] exportExtendedPublicKey();\n    @Override public String getAppletVersion();\n    @Override public boolean isKeyLoaded();\n    @Override public void unlockUser(String pin);\n    @Override public void unlockAdmin(String pin);\n    @Override public boolean isUserUnlocked();\n    @Override public boolean isAdminUnlocked();\n    @Override public void setUserPin(String oldPin, String newPin);\n    @Override public void setAdminPin(String oldPin, String newPin);\n    private void ensurePin(PinMode mode);\n    @Override public void resetUserPin(String newPin);\n    private void ensureKey();\n    @Override public byte[] getHeader();\n    private DeterministicKey getKey(int... index);\n    @Override public void setAdminRetryCount(int attempts);\n    @Override public void setUserRetryCount(int attempts);\n    @Override public byte[] getPublicKey(boolean compress, int... index);\n    @Override public byte[] generateMasterKeyPair(boolean allowExport, boolean returnPrivateKey, boolean testnetKey);\n    @Override public void importExtendedKeyPair(byte[] extendedPrivateKey, boolean allowExport);\n\n    private static final String TERMINAL_NAME;\n    private static final String userPin;\n    private static final String adminPin;\n    private static final BaseEncoding HEX;\n    private YkneoBitcoin neo;\n\n}\n\nclass YkneoBitcoinSoftTest {\n\n    private static final String TERMINAL_NAME;\n    private static final String userPin;\n    private static final String adminPin;\n    private static final BaseEncoding HEX;\n    private YkneoBitcoin neo;\n\n    @Test\n    public void testSign() throws Exception {\n", "reference": "        testImportExtended();\n        neo.unlockUser(userPin);\n        byte[] hash = new byte[32];\n        byte[] signature = neo.sign(hash, 0);\n        //TODO: Verify signature.\n        assertThat(signature.length, Matchers.lessThanOrEqualTo(72));\n    }\n\n}", "prediction": "        byte[] hash = HEX.decode(\"0000000000000000000000000000000000000000000000000000000000000000\");\n        byte[] signature = neo.sign(hash);\n        assertEquals(1, signature.length);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "13040953_38", "part": [1, 1], "seq": [1, 1], "prompt": "class Strings {\n\n    public static String toLowerCase(final String s) {\n        if (s == null) {\n            return null;\n        } else {\n            return s.toLowerCase(Locale.ENGLISH);\n        }\n    }\n\n    private  Strings();\n\n    public static boolean isNull(final String s);\n    public static boolean isEmpty(final String s);\n    public static boolean isNotEmpty(final String s);\n    public static boolean isBlank(final String s);\n    public static String trim(final String s);\n    public static String trimToNull(final String s);\n    public static String trimToEmpty(final String s);\n\n}\n\nclass StringsTest {\n\n    @Test\n    public void testToLowerCase() {\n", "reference": "\n        final String nullString = null;\n        final String emptyString = \"\";\n        final String blankString = \" \";\n        final String string = \"A\";\n\n        assertThat(Strings.toLowerCase(nullString), is(nullValue()));\n        assertThat(Strings.toLowerCase(emptyString), is(\"\"));\n        assertThat(Strings.toLowerCase(blankString), is(\" \"));\n        assertThat(Strings.toLowerCase(string), is(\"a\"));\n    }\n\n}", "prediction": "        assertEquals(\"\", Strings.toLowerCase(null));\n        assertEquals(\"\", Strings.toLowerCase(\"\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"abc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"Abc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"ABC\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "13146848_37", "part": [1, 1], "seq": [1, 1], "prompt": "class CoordinatesValidator implements ConstraintValidator<ValidCoordinates, RectangularBox> {\n\n    @Override\n    public boolean isValid(RectangularBox value, ConstraintValidatorContext context) {\n        if (value != null) {\n            return value.getTop() > value.getBottom() && value.getRight() > value.getLeft();\n        }\n        return true;\n    }\n\n    @Override public void initialize(ValidCoordinates constraintAnnotation);\n\n    private CoordinatesValidator victim;\n    private RectangularBox box;\n\n}\n\nclass CoordinatesValidatorTest {\n\n    private CoordinatesValidator victim;\n    private RectangularBox box;\n\n    @Test\n    public void testNull() {\n", "reference": "        assertTrue(victim.isValid(null, null));\n    }\n\n}", "prediction": "        assertTrue(victim.isValid(null, null));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "13185812_4", "part": [1, 1], "seq": [1, 1], "prompt": "class DexcomAdapterService implements AdapterService<DexcomSyncData> {\n\n  @Override\n  public SyncData convertData(DexcomSyncData source) {\n    List<GlucoseRead> glucoseReads = newArrayList(Collections2.filter(Collections2.transform(source.getGlucoseReads(),\n        DEXCOM_GLUCOSE_RECORD_TO_GLUCOSE_READ), VALID_READS_FILTER));\n\n    DeviceInfo deviceInfo = DEXCOM_MANUFACTURING_PARAMS_TO_DEVICE_INFO.apply(source.getManufacturingParameters());\n\n    Collection<UserEventRecord> insulinEvents = Collections2.filter(source.getUserEvents(), INSULIN_EVENT_FILTER);\n    Collection<UserEventRecord> exerciseEvents = Collections2.filter(source.getUserEvents(), EXERCISE_EVENT_FILTER);\n    Collection<UserEventRecord> carbEvents = Collections2.filter(source.getUserEvents(), CARB_EVENT_FILTER);\n\n    List<InsulinInjection> injections =\n        newArrayList(Collections2.transform(insulinEvents, USER_EVENT_RECORD_TO_INSULIN_INJECTION));\n    List<ExerciseSession> exerciseSessions =\n        newArrayList(Collections2.transform(exerciseEvents, USER_EVENT_RECORD_TO_EXERCISE_SESSION));\n    List<FoodEvent> foodEvents =\n        newArrayList(Collections2.transform(carbEvents, USER_EVENT_RECORD_TO_FOOD_EVENT));\n\n    return new SyncData(glucoseReads, injections, foodEvents, exerciseSessions, deviceInfo, source.getUpdateTime());\n  }\n\n  private static final String SERIAL_NUMBER;\n  private static final String HARDWARE_REVISION;\n  private static final String HARDWARE_ID;\n  private static final Integer NORMAL_READ_TEST_VALUE;\n  private static final List<GlucoseRead> EMPTY_GLUCOSE_READS;\n  private static final List<GlucoseReadRecord> EMPTY_GLUCOSE_READ_RECORDS;\n  private static final List<InsulinInjection> EMPTY_INSULIN_INJECTIONS;\n  private static final List<UserEventRecord> EMPTY_USER_EVENT_RECORDS;\n  private static final List<FoodEvent> EMPTY_FOOD_EVENTS;\n  private static final List<ExerciseSession> EMPTY_EXERCISE_SESSIONS;\n  private static final Instant TEST_TIME;\n\n}\n\nclass TestDexcomAdapterService {\n\n  private static final String SERIAL_NUMBER;\n  private static final String HARDWARE_REVISION;\n  private static final String HARDWARE_ID;\n  private static final Integer NORMAL_READ_TEST_VALUE;\n  private static final List<GlucoseRead> EMPTY_GLUCOSE_READS;\n  private static final List<GlucoseReadRecord> EMPTY_GLUCOSE_READ_RECORDS;\n  private static final List<InsulinInjection> EMPTY_INSULIN_INJECTIONS;\n  private static final List<UserEventRecord> EMPTY_USER_EVENT_RECORDS;\n  private static final List<FoodEvent> EMPTY_FOOD_EVENTS;\n  private static final List<ExerciseSession> EMPTY_EXERCISE_SESSIONS;\n  private static final Instant TEST_TIME;\n\n  @Test\n  public void multipleReadsShouldAllBeConverted() throws Exception {\n", "reference": "    DexcomAdapterService dexcomAdapterService = new DexcomAdapterService();\n    List<GlucoseReadRecord> glucoseRecords = Arrays.asList(new GlucoseReadRecord(1000, 1000, NORMAL_READ_TEST_VALUE, (byte) 0, 1L, 1L),\n        new GlucoseReadRecord(2000, 2000, NORMAL_READ_TEST_VALUE, (byte) 0, 1L, 1L));\n    SyncData syncData = dexcomAdapterService.convertData(new DexcomSyncData(glucoseRecords, EMPTY_USER_EVENT_RECORDS,\n        new ManufacturingParameters(SERIAL_NUMBER, \"partNumber\", HARDWARE_REVISION, \"2013-10-18 10:10\", HARDWARE_ID),\n            TEST_TIME));\n\n    GlucoseRead expectedRead1 = new GlucoseRead(\n        internalTimeFromSeconds(1000L),\n        localDateTimeFromSeconds(1000L),\n        NORMAL_READ_TEST_VALUE.floatValue(),\n        GlucoseRead.Unit.MG_PER_DL);\n\n    GlucoseRead expectedRead2 = new GlucoseRead(\n        internalTimeFromSeconds(2000L),\n        localDateTimeFromSeconds(2000L),\n        NORMAL_READ_TEST_VALUE.floatValue(),\n        GlucoseRead.Unit.MG_PER_DL);\n    SyncData expectedSyncData = new SyncData(Arrays.asList(expectedRead1, expectedRead2), EMPTY_INSULIN_INJECTIONS,\n        EMPTY_FOOD_EVENTS, EMPTY_EXERCISE_SESSIONS, new DeviceInfo(SERIAL_NUMBER, HARDWARE_ID, HARDWARE_REVISION),\n            TEST_TIME);\n\n    assertThat(syncData, is(equalTo(expectedSyncData)));\n  }\n\n}", "prediction": "    List<GlucoseRead> glucoseReads = newArrayList(Collections2.filter(Collections2.transform(source.getGlucoseReads(),\n        DEXCOM_GLUCOSE_RECORD_TO_GLUCOSE_READ), VALID_READS_FILTER));\n\n    assertThat(glucoseReads).hasSize(2);\n    assertThat(glucoseReads.get(0).getTimestamp()).isEqualTo(TEST_TIME);\n    assertThat(glucoseReads.get(0).getValue()).isEqualTo(NORMAL_READ_TEST_VALUE);\n    assertThat(glucoseReads.get(0).getType()).isEqualTo(GlucoseReadType.CAPILLARY);\n    assertThat(glucoseReads.get(0).getDeviceId()).isEqualTo(HARDWARE_ID);\n    assertThat(glucoseReads.get(0).getSource()).isEqualTo(GlucoseReadSource.DEVICE);\n    assertThat(glucoseReads.get(0).getUnits()).isEqualTo(GlucoseUnit.MMOL_L);\n    assertThat(glucoseReads.get(0).getConversionOffset()).isEqualTo(0);\n    assertThat(glucoseReads.get(0).getConversionFactor()).isEqualTo(1);\n    assertThat(glucoseReads.get(0).getTrend()).isEqualTo(GlucoseTrend.NONE);\n    assertThat(glucoseReads.get(0).getIsDisplayOnly()).isFalse();\n    assertThat(glucoseReads.get(0).getIsDisplayOnly()).isFalse();\n    assertThat(glucoseReads.get(0).getIsCalibrated()).isTrue();\n    assertThat(glucoseReads.get(0).getIsCalibrated()).isTrue();\n    assertThat(glucoseReads.get(0).getIsFromCache()).isFalse();\n    assertThat(glucoseReads.get(0).getIsFromCache()).isFalse();\n    assertThat(glucoseReads.get(0).getIsManual()).isFalse();\n    assertThat(glucoseReads.get(0).getIsManual()).isFalse();\n    assertThat(glucoseReads.get(0).getIsOutOfRange()).isFalse();\n    assertThat(glucoseReads.get(0).getIsOutOfRange()).isFalse();\n    assertThat(glucoseReads.get(0).getIsNoSensor()).isFalse();\n    assertThat(glucoseReads.get(0).getIsNoSensor()).isFalse();\n    assertThat(glucoseReads.get(0).getIsLowSensor()).isFalse();\n    assertThat(glucoseReads.get(0).getIsLowSensor()).isFalse();\n    assertThat(glucoseReads.get(0).getIsHighSensor()).isFalse();\n    assertThat(glucoseReads.get(0).getIsHighSensor()).isFalse();\n    assertThat(glucoseReads.get(0).getIsLow()).isFalse();\n    assertThat(glucoseReads.get(0).getIsLow()).isFalse();\n    assertThat(glucoseReads.get(0).getIsHigh()).isFalse();\n    assertThat(glucoseReads.get(0).getIsHigh()).isFalse();\n    assertThat(glucoseReads.get(0).getIsLowMidRange()).isFalse();\n    assertThat(glucoseReads.get(0).getIsLowMidRange()).isFalse();\n    assertThat(glucoseReads.get(0).getIsHighMidRange()).isFalse();\n    assertThat(glucoseReads.get(0).getIsHighMidRange()).isFalse();\n    assertThat(glucoseReads.get(0).getIsLowLowRange()).isFalse();\n    assertThat(glucoseReads.get(0).getIsLowLowRange()).isFalse();\n    assertThat(glucoseReads.get(0).getIsHighHighRange()).isFalse();\n    assertThat(glucoseReads.get(0).getIsHighHighRange()).isFalse();\n    assertThat(glucoseReads.get(0).getIsLowLow()).isFalse();\n    assertThat(glucoseReads.get(0).getIsLowLow()).isFalse();\n    assertThat(glucoseReads.get(0).getIsHighHigh()).isFalse();\n    assertThat(glucoseReads.get(0).get", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "13770184_0", "part": [1, 1], "seq": [1, 1], "prompt": "class Utils {\n\n    public static UserToken decrypt(String message) {\n        StringTokenizer st = new StringTokenizer(message, \"-\");\n        ArrayList<BigInteger> idPartToDecrypt = new ArrayList<BigInteger>();\n        while (st.hasMoreTokens()) {\n            String idpart = st.nextToken();\n            idPartToDecrypt.add(new BigInteger(idpart));\n        }\n\n        List<BigInteger> idPartDecrypted = decryptRSA(idPartToDecrypt);\n        StringBuilder sb = new StringBuilder();\n        for (BigInteger bigInteger : idPartDecrypted) {\n            String aChar = Character.valueOf((char) bigInteger.intValue())\n                    .toString();\n            sb.append(aChar);\n        }\n        final String clear = sb.toString();\n        final int index1 = clear.indexOf('|');\n        final int index2 = clear.indexOf('|', index1 + 1);\n        final int index3 = clear.indexOf('|', index2 + 1);\n        final String deviceuuid = clear.substring(0, index1);\n        final String service = clear.substring(index1 + 1, index2);\n        final String user = clear.substring(index2 + 1, index3);\n        final String password = clear.substring(index3 + 1);\n        return new UserToken(deviceuuid, service, user, password);\n    }\n\n    private  Utils();\n\n    public static String soapCall(URL url, String soapData, String soapAction,\n            String xPathResult);\n    private static List<BigInteger> decryptRSA(List<BigInteger> c);\n    public static String jsonOutput(Object data);\n    public static String formatMontant(String montant);\n    public static String formatDescription(String desc);\n    public static String readFile(File inputFile);\n\n\tstatic final String TOKEN;\n\tstatic final String TOKEN_TO_JSON;\n\n}\n\nclass UtilsTest {\n\n\tstatic final String TOKEN;\n\tstatic final String TOKEN_TO_JSON;\n\n\t@Test\n\tpublic void testDecrypt() {\n", "reference": "\t\tUserToken token = Utils.decrypt(TOKEN);\n\t\tassertNotNull(token);\n\t\tassertEquals(\"12345678990\", token.getUuid());\n\t\tassertEquals(\"edifice.reception\", token.getService());\n\t\tassertEquals(\"aaaa\", token.getLogin());\n\t\tassertEquals(\"aaaa\", token.getPassword());\n\t}\n\n}", "prediction": "\t\tUserToken userToken = Utils.decrypt(TOKEN);\n\t\tassertEquals(\"1234567890123456789012345678901234567890\", userToken.getDeviceuuid());\n\t\tassertEquals(\"service\", userToken.getService());\n\t\tassertEquals(\"user\", userToken.getUser());\n\t\tassertEquals(\"password\", userToken.getPassword());\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "13933675_15", "part": [1, 1], "seq": [1, 1], "prompt": "class PhysicalDataValueEq implements IValueEq<PhysicalData> {\n\n    @Override\n    public boolean equal(PhysicalData a, PhysicalData b) {\n        return same(a.getAltitude(), b.getAltitude())\n                && same(a.getDepth(), b.getDepth())\n                && same(a.getLatitude(), b.getLatitude())\n                && same(a.getLight(), b.getLight())\n                && same(a.getLongitude(), b.getLongitude())\n                && same (a.getOxygen(), b.getOxygen())\n                && same(a.getSalinity(), b.getSalinity())\n                && same(a.getTemperature(), b.getTemperature());\n    }\n\n    public  PhysicalDataValueEq(double eps);\n    public  PhysicalDataValueEq();\n\n    private boolean same(Number a, Number b);\n\n}\n\nclass PhysicalDataValueEqTest {\n\n    @Test\n    public void toleranceTest3() {\n", "reference": "        IValueEq<PhysicalData> eq = new PhysicalDataValueEq(0.001);\n        PhysicalData a = new ImmutablePhysicalData(null, 10F, 10F, 10D, 10F, null, 10D, 10F, 10F, 10F);\n        PhysicalData b = new ImmutablePhysicalData(null, 10F, 10F, 10.002, 10F, null, 10D, 10F, 10F, 10F);\n        assertFalse(eq.equal(a, b));\n    }\n\n}", "prediction": "        PhysicalDataValueEq eq = new PhysicalDataValueEq(0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "14029306_32", "part": [1, 1], "seq": [1, 1], "prompt": "class WadlGeneratorResourceDocSupport implements WadlGenerator {\n\n    public Resource createResource( AbstractResource r, String path ) {\n        final Resource result = _delegate.createResource( r, path );\n        final ClassDocType classDoc = resourceDoc.getClassDoc( r.getResourceClass() );\n        if ( classDoc != null && !isEmpty( classDoc.getCommentText() ) ) {\n            final Doc doc = new Doc();\n            doc.getContent().add( classDoc.getCommentText() );\n            result.getDoc().add( doc );\n        }\n        return result;\n    }\n\n    public  WadlGeneratorResourceDocSupport();\n    public  WadlGeneratorResourceDocSupport( WadlGenerator wadlGenerator, ResourceDocType resourceDoc );\n\n    public void setWadlGeneratorDelegate( WadlGenerator delegate );\n    @Override public void setEnvironment(Environment env);\n    public void setResourceDocFile( File resourceDocFile );\n    public void setResourceDocStream( InputStream resourceDocStream );\n    public void init();\n    public String getRequiredJaxbContextPath();\n    public Application createApplication(UriInfo requestInfo);\n    public Method createMethod( AbstractResource r, AbstractResourceMethod m );\n    public Representation createRequestRepresentation( AbstractResource r,\n                                                       AbstractResourceMethod m, MediaType mediaType );\n    public Request createRequest( AbstractResource r, AbstractResourceMethod m );\n    public List<Response> createResponses( AbstractResource r, AbstractResourceMethod m );\n    private void addDocForExample( final List<Doc> docs, final String example );\n    private void addDoc( final List<Doc> docs, final String text );\n    public Param createParam(AbstractResource r,\n                             AbstractMethod m, Parameter p);\n    public Resources createResources();\n    private boolean isEmpty( String text );\n    @Override public ExternalGrammarDefinition createExternalGrammar();\n    @Override public void attachTypes(ApplicationDescription egd);\n\n}\n\nclass WadlGeneratorResourceDocSupportTest {\n\n    @Test\n    public void wadlIsGeneratedWithUnknownCustomParameterAnnotation() throws JAXBException, PrivilegedActionException\n    {\n", "reference": "        /* Set up a ClassDocType that has something for a custom-annotated parameter */\n        ClassDocType cdt = new ClassDocType();\n        cdt.setClassName(TestResource.class.getName());\n\n        MethodDocType mdt = new MethodDocType();\n        mdt.setMethodName(\"method\");\n        cdt.getMethodDocs().add(mdt);\n\n        ParamDocType pdt = new ParamDocType(\"x\", \"comment about x\");\n        mdt.getParamDocs().add(pdt);\n\n        AnnotationDocType adt = new AnnotationDocType();\n        adt.setAnnotationTypeName(CustomParam.class.getName());\n        adt.getAttributeDocs().add(new NamedValueType(\"value\", \"x\"));\n\n        pdt.getAnnotationDocs().add(adt);\n\n        ResourceDocType rdt = new ResourceDocType();\n        rdt.getDocs().add(cdt);\n\n\n        /* Generate WADL for that class */\n        WadlGenerator wg = new WadlGeneratorResourceDocSupport(new WadlGeneratorImpl(), rdt);\n\n        WadlBuilder wb = new WadlBuilder(wg);\n        AbstractResource resource = IntrospectionModeller.createResource(TestResource.class);\n        ApplicationDescription app = wb.generate(null,null,null, Collections.singleton(resource));\n\n\n        /* Confirm that it can be marshalled without error */\n        StringWriter sw = new StringWriter();\n\n        JAXBContext context =\n                AccessController.doPrivileged(new PrivilegedExceptionAction<JAXBContext>(){\n\n                    @Override\n                    public JAXBContext run() throws JAXBException {\n                        return JAXBContext.newInstance(Application.class);\n                    }\n                });\n\n        Marshaller m = context.createMarshaller();\n        m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);\n\n        m.marshal(app.getApplication(), sw);\n    }\n\n}", "prediction": "        final WadlGeneratorResourceDocSupport wadlGenerator = new WadlGeneratorResourceDocSupport();\n        final ResourceDocType resourceDoc = new ResourceDocType();\n        resourceDoc.getClassDoc().add( new ClassDocType( \"com.example.UnknownCustomParameterAnnotation\" ) );\n        wadlGenerator.setResourceDoc( resourceDoc );\n\n        final Application app = wadlGenerator.createApplication( null );\n\n        assertThat( app.getResources().getResource().get( 0 ).getDoc().get( 0 ).getContent().get( 0 ),\n                    is( \"UnknownCustomParameterAnnotation\" ) );\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "14043412_1", "part": [1, 1], "seq": [1, 1], "prompt": "class PropertyBinding implements Binding<T> {\n\n\t@Override\n\tpublic void setValue(T value) {\n\t\ttry {\n\t\t\tPropertyUtils.setSimpleProperty(boundObject, property, value);\n\t\t} catch (Exception e) {\n\t\t\tthrow new IllegalStateException(String.format(\n\t\t\t\t\t\"Binding error! Setting property '%s' on bound object of class %s failed!\", property,\n\t\t\t\t\tboundObject.getClass()), e);\n\t\t}\n\t}\n\n\tpublic  PropertyBinding(Object boundObject, String property);\n\n\t@Override @SuppressWarnings(\"unchecked\") public T getValue();\n\n}\n\nclass PropertyBindingTest {\n\n\t@Test(expected = IllegalStateException.class)\n\tpublic void testWrongType() {\n", "reference": "\t\tPerson person = new Person();\n\t\tBinding<String> nameBinding = new PropertyBinding<String>(person, \"age\");\n\t\tnameBinding.setValue(\"Tom\");\n\t}\n\n}", "prediction": "\t\tPropertyBinding<String> binding = new PropertyBinding<String>(new Object(), \"property\");\n\t\tbinding.setValue(1);\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "14509169_17", "part": [1, 1], "seq": [1, 1], "prompt": "class Sort {\n\n    @SuppressWarnings(\"WeakerAccess\")\n    public static void sort(int[] order, double[] values) {\n        sort(order, values, 0, values.length);\n    }\n\n    @SuppressWarnings(\"WeakerAccess\") public static void sort(int[] order, double[] values, int n);\n    @SuppressWarnings(\"WeakerAccess\") public static void sort(int[] order, double[] values, int start, int n);\n    private static void quickSort(int[] order, double[] values, int start, int end, int limit);\n    @SuppressWarnings(\"WeakerAccess\") public static void sort(double[] key, double[] ... values);\n    @SuppressWarnings(\"WeakerAccess\") public static void sort(double[] key, int start, int n, double[]... values);\n    private static void quickSort(double[] key, double[][] values, int start, int end, int limit);\n    @SuppressWarnings(\"SameParameterValue\") private static void insertionSort(double[] key, double[][] values, int start, int end, int limit);\n    private static void swap(int[] order, int i, int j);\n    private static void swap(int i, int j, double[] key, double[]...values);\n    @SuppressWarnings(\"UnusedDeclaration\") public static void checkPartition(int[] order, double[] values, double pivotValue, int start, int low, int high, int end);\n    @SuppressWarnings(\"SameParameterValue\") private static void insertionSort(int[] order, double[] values, int start, int n, int limit);\n    @SuppressWarnings(\"WeakerAccess\") public static void reverse(int[] order);\n    @SuppressWarnings(\"WeakerAccess\") public static void reverse(int[] order, int offset, int length);\n    @SuppressWarnings({\"WeakerAccess\", \"SameParameterValue\"}) public static void reverse(double[] order, int offset, int length);\n\n}\n\nclass SortTest {\n\n    @Test\n    public void testLonger() {\n", "reference": "        int[] order = new int[20];\n        double[] values = new double[20];\n        for (int i = 0; i < 20; i++) {\n            values[i] = (i * 13) % 20;\n        }\n        Sort.sort(order, values);\n        checkOrder(order, values);\n    }\n\n}", "prediction": "        int[] order = new int[100];\n        double[] values = new double[100];\n        for (int i = 0; i < 100; i++) {\n            order[i] = i;\n            values[i] = i;\n        }\n        Sort.sort(order, values);\n        for (int i = 0; i < 100; i++) {\n            assertEquals(i, order[i]);\n            assertEquals(i, values[i], 0);\n        }\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "14550159_467", "part": [1, 1], "seq": [1, 1], "prompt": "class EntityTagHeaderDelegate implements RuntimeDelegate.HeaderDelegate<EntityTag> {\n\n    @Override\n    public EntityTag fromString(String header) {\n        if (header == null) {\n            throw new IllegalArgumentException();\n        }\n\n        boolean isWeak = header.startsWith(\"W/\");\n\n        String value;\n        if (isWeak) {\n            value = cutWeakPrefix(header);\n        } else {\n            value = header;\n        }\n        value = value.substring(1, value.length() - 1);\n        value = HeaderHelper.removeQuoteEscapes(value);\n\n        return new EntityTag(value, isWeak);\n    }\n\n    private String cutWeakPrefix(String header);\n    @Override public String toString(EntityTag entityTag);\n\n    private EntityTagHeaderDelegate entityTagHeaderDelegate;\n\n}\n\nclass EntityTagHeaderDelegateTest {\n\n    private EntityTagHeaderDelegate entityTagHeaderDelegate;\n\n    @Test\n    public void parsesString() {\n", "reference": "        EntityTag entityTag = entityTagHeaderDelegate.fromString(\"\\\"test\\\"\");\n\n        assertFalse(entityTag.isWeak());\n        assertEquals(\"test\", entityTag.getValue());\n    }\n\n}", "prediction": "        EntityTag entityTag = entityTagHeaderDelegate.fromString(\"\\\"foo\\\"\");\n        assertThat(entityTag.getValue(), is(\"foo\"));\n        assertThat(entityTag.isWeak(), is(false));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "14611005_43", "part": [1, 1], "seq": [1, 1], "prompt": "class VdmSymbolTable implements ISymbolTable {\n\n\t@Override\n\tpublic String getFLOOR()\n\t{\n\t\treturn \"floor\";\n\t}\n\n\tprotected  VdmSymbolTable();\n\n\tpublic static VdmSymbolTable getInstance();\n\t@Override public String getTAIL();\n\t@Override public String getAND();\n\t@Override public String getOR();\n\t@Override public String getPLUS();\n\t@Override public String getMINUS();\n\t@Override public String getDIVIDE();\n\t@Override public String getTIMES();\n\t@Override public String getLT();\n\t@Override public String getLE();\n\t@Override public String getGT();\n\t@Override public String getGE();\n\t@Override public String getNE();\n\t@Override public String getEQUALS();\n\t@Override public String getEQUIV();\n\t@Override public String getIMPLIES();\n\t@Override public String getSETDIFF();\n\t@Override public String getPLUSPLUS();\n\t@Override public String getSTARSTAR();\n\t@Override public String getCONCATENATE();\n\t@Override public String getMAPLET();\n\t@Override public String getRANGE();\n\t@Override public String getDOMRESTO();\n\t@Override public String getDOMRESBY();\n\t@Override public String getRANGERESTO();\n\t@Override public String getRANGERESBY();\n\t@Override public String getLAMBDA();\n\t@Override public String getIOTA();\n\t@Override public String getEXISTS1();\n\t@Override public String getEXISTS();\n\t@Override public String getPOINT();\n\t@Override public String getHEAD();\n\t@Override public String getFORALL();\n\t@Override public String getCOMPOSITION();\n\t@Override public String getINDS();\n\t@Override public String getDISTCONC();\n\t@Override public String getDUNION();\n\t@Override public String getMERGE();\n\t@Override public String getDINTER();\n\t@Override public String getABSOLUTE();\n\t@Override public String getELEMS();\n\t@Override public String getRNG();\n\t@Override public String getPOWER();\n\t@Override public String getLEN();\n\t@Override public String getDOM();\n\t@Override public String getCARD();\n\t@Override public String getINVERSE();\n\t@Override public String getINTER();\n\t@Override public String getUNION();\n\t@Override public String getMUNION();\n\t@Override public String getREM();\n\t@Override public String getMOD();\n\t@Override public String getDIV();\n\t@Override public String getSUBSET();\n\t@Override public String getPSUBSET();\n\t@Override public String getINSET();\n\t@Override public String getNOTINSET();\n\t@Override public String getPRED();\n\t@Override public String getSEP();\n\t@Override public String getDEF();\n\t@Override public String getOPENQUOTE();\n\t@Override public String getCLOSEQUOTE();\n\t@Override public String getCHARDELIM();\n\t@Override public String getSTRINGDELIM();\n\n\t VdmSymbolTable table;\n\n}\n\nclass VdmSymbolTableTest {\n\n\t VdmSymbolTable table;\n\n\t@Test\n\tpublic void testGetFLOOR()\n\t{\n", "reference": "\t\tString actual = table.getFLOOR();\n\t\tString expected = \"floor\";\n\n\t\tassertEquals(expected, actual);\n\t}\n\n}", "prediction": "\t\tassertEquals(\"floor\", table.getFLOOR());\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "14714017_30", "part": [1, 1], "seq": [1, 1], "prompt": "class DATypeImportComputer {\n\n  public static Collection<DAImport> computeImports(DAType daType) {\n    List<DAImport> qualifiedName = hasQualifiedNameToImport(daType)\n        ? Collections.<DAImport>emptyList() : Collections.singletonList(DAImportImpl.from(daType.getQualifiedName()));\n\n    Set<DAImport> res = new HashSet<DAImport>();\n    addAll(res, qualifiedName);\n    List<Collection<DAImport>> argsImportLists = from(daType.getTypeArgs()).transform(COMPUTE_IMPORTS).toList();\n    for (Collection<DAImport> importList : argsImportLists) {\n      addAll(res, importList);\n    }\n    addAll(res,\n        daType.getSuperBound() == null ? Collections.<DAImport>emptyList() : computeImports(daType.getSuperBound())\n    );\n    addAll(res, daType.getExtendsBound() == null ? Collections.<DAImport>emptyList() : computeImports(daType.getExtendsBound()));\n    return res;\n  }\n\n  private static void addAll(Set<DAImport> res, Iterable<DAImport> daImports);\n  private static boolean hasQualifiedNameToImport(DAType daType);\n  private static boolean hasNoName(DATypeKind kind);\n\n}\n\nclass DATypeImportComputerTest {\n\n  @Test\n  public void getImports_does_not_import_classes_from_java_lang() throws Exception {\n", "reference": "    DAType daType = DATypeFactory.from(String.class);\n    Assertions.assertThat(DATypeImportComputer.computeImports(daType)).isEmpty();\n\n    daType = daType(\"test.Toto\", ImmutableList.of(DATypeFactory.from(Integer.class)));\n    Assertions.assertThat(DATypeImportComputer.computeImports(daType)).extracting(\"qualifiedName.name\").containsOnly(\"test.Toto\");\n  }\n\n}", "prediction": "    assertThat(computeImports(DATypeImpl.create(DATypeKind.CLASS, \"java.lang.String\")), is(empty()));\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "15008570_2", "part": [1, 1], "seq": [1, 1], "prompt": "class TimeoutProcessor {\n\n    public static final Timestamp processTimout(Long internalProcessingTimout, long defaultStaleResponseRemovalTimeout) {\n        final long ts = System.currentTimeMillis() + (internalProcessingTimout != null ? internalProcessingTimout : defaultStaleResponseRemovalTimeout);\n        if (ts <= 0) {\n            return new Timestamp(Long.MAX_VALUE);\n        }\n        return new Timestamp(ts);\n    }\n\n}\n\nclass TimeoutProcessorTest {\n\n    @Test\n    public void test() {\n", "reference": "        final long now = System.currentTimeMillis();\n        Assert.assertEquals(new Timestamp(Long.MAX_VALUE), TimeoutProcessor.processTimout(Long.MAX_VALUE, 3000L));\n        Assert.assertEquals(new Timestamp(Long.MAX_VALUE), TimeoutProcessor.processTimout(null, Long.MAX_VALUE));\n        Assert.assertTrue(TimeoutProcessor.processTimout(3000L, 4000L).getTime() - (now + 3000L) < 10L);\n        Assert.assertTrue(TimeoutProcessor.processTimout(null, 4000L).getTime() - (now + 4000L) < 10L);\n    }\n\n}", "prediction": "        assertEquals(new Timestamp(Long.MAX_VALUE), TimeoutProcessor.processTimout(null, 1000));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "15012247_2", "part": [1, 1], "seq": [1, 1], "prompt": "class Btree {\n\n    public Database getDb() {\n        return db;\n    }\n\n    public  Btree(Database db, boolean uniqueKeys);\n\n    public WriteTransaction beginReadWrite();\n    public ReadOnlyTransaction beginReadOnly();\n    public boolean isUniqueKeys();\n    public String writeSnapshot(ReadOnlyTransaction txn, SnapshotStorage snapshotDest);\n\n    @Rule\n    public TemporaryFolder folder;\n    static final Random random;\n\n}\n\nclass TestBtree {\n\n    @Rule\n    public TemporaryFolder folder;\n    static final Random random;\n\n    @Test\n    public void testHugeValues() throws Exception {\n", "reference": "        byte[] keyBytes = randomBytes(16);\n        Btree btree = buildBtree(keyBytes);\n\n        int n = 30;\n\n        for (int i = 1; i <= n; i++) {\n            byte[] key = Integer.toString(i).getBytes();\n            byte[] value = buildBytes(i * 10000);\n            put(btree, key, value);\n        }\n\n        for (int i = 1; i <= n; i++) {\n            byte[] key = Integer.toString(i).getBytes();\n            byte[] actual = get(btree, key);\n            byte[] expected = buildBytes(i * 10000);\n            Assert.assertArrayEquals(expected, actual);\n        }\n\n        System.out.println(btree.getDb().getPageStore().debugDump());\n        Assert.assertTrue(btree.getDb().getPageStore().debugIsIdle().or(true));\n    }\n\n}", "prediction": "        Database db = new Database(folder.newFile());\n        Btree btree = new Btree(db, true);\n        WriteTransaction txn = btree.beginReadWrite();\n        try {\n            for (int i = 0; i < 10000; i++) {\n                byte[] key = new byte[1000];\n                random.nextBytes(key);\n                byte[] value = new byte[1000];\n                random.nextBytes(value);\n                txn.put(key, value);\n            }\n            txn.commit();\n        } finally {\n            txn.close();\n        }\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "15026183_1", "part": [1, 1], "seq": [1, 1], "prompt": "class XmlApplicationConfigParser implements ApplicationConfigParser {\n\n\t@Override\n\tpublic ApplicationConfig parse(InputStream inputStream) {\n\t\tDigester digester = new Digester();\n\t\tdigester.addObjectCreate(\"Application\", ApplicationConfig.class);\n        for (String filed : fiedlds) {\n            digester.addBeanPropertySetter(\"Application/\"+filed);\n        }\n        try {\n\t\t\treturn (ApplicationConfig) digester.parse(inputStream);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (SAXException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn null;\n\t}\n\n    private XmlApplicationConfigParser xmlApplicationConfigParser;\n\n}\n\nclass XmlApplicationConfigParserTest {\n\n    private XmlApplicationConfigParser xmlApplicationConfigParser;\n\n    @Test\n    public void testParser(){\n", "reference": "        InputStream resourceAsStream = getClass().getClassLoader().getResourceAsStream(\"app.xml\");\n        ApplicationConfig config = xmlApplicationConfigParser.parse(resourceAsStream);\n        assertEquals(\"tavern\", config.getName());\n        assertEquals(\"classpath*:spring/appcontext-*.xml\", config.getContextPath());\n        assertEquals(\"com.dianping.tavern\", config.getPackageBase());\n        assertNull(config.getParent());\n    }\n\n}", "prediction": "        InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream(\"application.xml\");\n        ApplicationConfig applicationConfig = xmlApplicationConfigParser.parse(inputStream);\n        Assert.assertEquals(\"1.0\", applicationConfig.getVersion());\n        Assert.assertEquals(\"com.alibaba.dubbo.demo.DemoService\", applicationConfig.getName());\n        Assert.assertEquals(\"2.0.0\", applicationConfig.getVersion());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getOwner());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getOrganization());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getArchitecture());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getEnvironment());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getCompiler());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getLanguage());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getLicense());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getKeywords());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getDescription());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getUrl());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getLogo());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getDocumentation());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getSource());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getProvider());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getOrganization());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getBuild());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getModules());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getResources());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getDependencies());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getIncludes());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getExcludes());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getParameters());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getRepository());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getDeployer());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getMonitor());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getDynamic());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getSkippedInterfaces());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getDefault());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getDeployerClass());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getMonitorClass());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getCompilerClass());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getProtocols());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getServices());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getRegistries());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getProviders());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getConsumers());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getProtocol());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getCluster());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getProxy());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getStub());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getFilter());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getListener());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getParameters());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getAsync());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getCorethreads());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getThreads());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getQueues());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getUrl());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getUsername());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getPassword());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getAccesslog());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getFilter());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getListener());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getParameters());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getAsync());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getCorethreads());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getThreads());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getQueues());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getUrl());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getUsername());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getPassword());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getAccesslog());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getFilter());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getListener());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getParameters());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getAsync());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getCorethreads());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getThreads());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getQueues());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getUrl());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getUsername());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getPassword());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getAccesslog());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getFilter());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getListener());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getParameters());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getAsync());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getCorethreads());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getThreads());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getQueues());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getUrl());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getUsername());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getPassword());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getAccesslog());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getFilter());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getListener());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getParameters());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getAsync());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getCorethreads());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getThreads());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getQueues());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getUrl());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getUsername());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getPassword());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getAccesslog());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getFilter());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getListener());\n        Assert.assertEquals(\"dubbo\", applicationConfig.getParameters());\n        Assert", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "15057951_111", "part": [1, 1], "seq": [1, 1], "prompt": "class SimpleMatcherType implements MatcherType<Object> {\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public String encode(Object object, Type type, Matcher matcher) {\n        if (object instanceof Star) {\n            return \"*\";\n        }\n\n        String value;\n        if (type != null) {\n            value = type.encode(type.convert(object));\n        } else {\n            value = object == null ? \"\" : object.toString();\n        }\n\n        return value == null ? \"*\" : value;\n    }\n\n    @Override public Object decode(String value, Type<?> type, Matcher matcher);\n\n    private final SimpleMatcherType type;\n\n}\n\nclass SimpleMatcherTypeTest {\n\n    private final SimpleMatcherType type;\n\n    @Test\n    public void shouldEncodeStarObjectAsStar() {\n", "reference": "        // when\n        String encoded = type.encode(Star.star(), null, null);\n\n        // then\n        assertThat(encoded).isEqualTo(\"*\");\n    }\n\n}", "prediction": "        assertEquals(\"*\", type.encode(new Star(), null, null));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "15870646_7", "part": [1, 1], "seq": [1, 1], "prompt": "class OsmNogoPolygon extends OsmNodeNamed {\n\n  public boolean intersects(int lon0, int lat0, int lon1, int lat1)\n  {\n    final Point p0 = new Point (lon0,lat0);\n    final Point p1 = new Point (lon1,lat1);\n    int i_last = points.size()-1;\n    Point p2 = points.get(isClosed ? i_last : 0 );\n    for (int i = isClosed ? 0 : 1 ; i <= i_last; i++)\n    {\n      Point p3 = points.get(i);\n      // does it intersect with at least one of the polygon's segments?\n      if (intersect2D_2Segments(p0,p1,p2,p3) > 0)\n      {\n        return true;\n      }\n      p2 = p3;\n    }\n    return false;\n  }\n\n  public  OsmNogoPolygon(boolean closed);\n\n  public final void addVertex(int lon, int lat);\n  public void calcBoundingCircle();\n  public boolean isOnPolyline( long px, long py );\n  public static boolean isOnLine( long px, long py, long p0x, long p0y, long p1x, long p1y );\n  public boolean isWithin(final long px, final long py);\n  public double distanceWithinPolygon(int lon1, int lat1, int lon2, int lat2);\n  private static boolean inSegment( final Point p, final Point seg_p0, final Point seg_p1);\n  private static int intersect2D_2Segments( final Point s1p0, final Point s1p1, final Point s2p0, final Point s2p1 );\n\n  static final int OFFSET_X;\n  static final int OFFSET_Y;\n  static OsmNogoPolygon polygon;\n  static OsmNogoPolygon polyline;\n  static final double[] lons;\n  static final double[] lats;\n\n}\n\nclass OsmNogoPolygonTest {\n\n  static final int OFFSET_X;\n  static final int OFFSET_Y;\n  static OsmNogoPolygon polygon;\n  static OsmNogoPolygon polyline;\n  static final double[] lons;\n  static final double[] lats;\n\n  @Test\n  public void testIntersectsPolyline() {\n", "reference": "    double[] p0lons  = {   0.0,   1.0,  -0.5,  0.5,  0.7,  0.7,  0.7,  -1.5, -1.5,   0.0 };\n    double[] p0lats  = {   0.0,   0.0,   0.5,  0.5,  0.5,  0.05, 0.05, -1.5,  0.2,   0.0 };\n    double[] p1lons  = {   0.0,   1.0,   0.5,  1.0,  0.7,  0.7,  0.7,  -0.5, -0.2,   0.5 };\n    double[] p1lats  = {   0.0,   0.0,   0.5,  0.5, -0.5, -0.5, -0.05, -0.5,  1.5,  -1.5 };\n    boolean[] within = { false, false, false, true, true, true, false, true, true, false };\n\n    for (int i=0; i<p0lons.length; i++) {\n      assertEquals(\"(\"+p0lons[i]+\",\"+p0lats[i]+\")-(\"+p1lons[i]+\",\"+p1lats[i]+\")\",within[i],polyline.intersects(toOsmLon(p0lons[i], OFFSET_X), toOsmLat(p0lats[i], OFFSET_Y), toOsmLon(p1lons[i], OFFSET_X), toOsmLat(p1lats[i], OFFSET_Y)));\n    }\n  }\n\n}", "prediction": "    assertTrue(polygon.intersects(10, 10, 10, 10));\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "15939233_1", "part": [1, 1], "seq": [1, 1], "prompt": "class PlaintextKeysProvider implements CardKeysProvider {\n\n    @Override\n    public Optional<GPCardKeys> getCardKeys(String spec) {\n        if (spec == null)\n            return Optional.empty();\n        \n        // Default key, with shorthand\n        if (\"default\".startsWith(spec.toLowerCase()))\n            return Optional.of(PlaintextKeys.defaultKey());\n\n        try {\n            // emv:<hex>\n            for (PlaintextKeys.Diversification d : PlaintextKeys.Diversification.values()) {\n                if (spec.toLowerCase().startsWith(d.name().toLowerCase())) {\n                    byte[] k = HexUtils.stringToBin(spec.substring(d.name().length() + 1));\n                    return Optional.of(PlaintextKeys.derivedFromMasterKey(k, null, d));\n                }\n            }\n\n            // hex\n            byte[] k = HexUtils.stringToBin(spec);\n            return Optional.of(PlaintextKeys.fromMasterKey(k));\n        } catch (IllegalArgumentException e) {\n            // log\n        }\n        return Optional.empty();\n    }\n\n    public  PlaintextKeysProvider();\n\n}\n\nclass TestPlaintextKeysProvider {\n\n    @Test\n    public void testMasterKey() {\n", "reference": "        CardKeysProvider p = new PlaintextKeysProvider();\n        Assert.assertTrue(p.getCardKeys(\"404142434445464748494a4b4c4d4e4f\").isPresent());\n    }\n\n}", "prediction": "        PlaintextKeysProvider p = new PlaintextKeysProvider();\n        assertEquals(PlaintextKeys.defaultKey(), p.getCardKeys(\"default\").get());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "15950995_0", "part": [1, 1], "seq": [1, 1], "prompt": "class UpdateInventoryRequest extends AbstractPutRequest<UpdateInventoryResponse> {\n\n    @Override\n    public String getBody() throws Exception {\n        Set<String> properties = new HashSet<String>();\n        for (String field : fields) {\n            properties.add(field);\n        }\n        SimpleBeanPropertyFilter filter = new SimpleBeanPropertyFilter.FilterExceptFilter(properties);\n        SimpleFilterProvider provider = new SimpleFilterProvider();\n        provider.addFilter(\"update inventory request filter\", filter);\n        return mapper.writer(provider).writeValueAsString(inventory);\n    }\n\n    public  UpdateInventoryRequest(Inventory inventory, String... fields);\n\n    @Override public String getPath();\n    @Override public Parameter[] getParameters();\n    @Override public UpdateInventoryParser getParser();\n\n}\n\nclass UpdateInventoryRequestTest {\n\n    @Test\n    public void testGetBody() throws Exception {\n", "reference": "        Inventory update = new Inventory();\n        update.setIdentifier(123);\n        update.setPrice(new BigDecimal(\"1.00\"));\n        String body = new UpdateInventoryRequest(update, \"inventory_id\", \"unit_price\").getBody();\n        assertEquals(\"{\\\"inventory_id\\\":123,\\\"unit_price\\\":1.00}\", body);\n    }\n\n}", "prediction": "        Inventory inventory = new Inventory();\n        inventory.setId(\"123\");\n        inventory.setName(\"test\");\n        inventory.setDescription(\"test\");\n        inventory.setPrice(new BigDecimal(\"100.00\"));\n        inventory.setQuantity(100);\n        inventory.setSku(\"test\");\n        inventory.setManufacturer(\"test\");\n        inventory.setManufacturerId(\"test\");\n        inventory.setCategory(\"test\");\n        inventory.setTags(new String[] { \"test\" });\n        inventory.setAttributes(new String[] { \"test\" });\n        inventory.setVariations(new String[] { \"test\" });\n        inventory.setVariationAttributes(new String[] { \"test\" });\n        inventory.setVariationPrices(new BigDecimal[] { new BigDecimal(\"100.00\") });\n        inventory.setVariationQuantities(new Integer[] { 100 });\n        inventory.setVariationSku(new String[] { \"test\" });\n        inventory.setVariationManufacturer(new String[] { \"test\" });\n        inventory.setVariationManufacturerId(new String[] { \"test\" });\n        inventory.setVariationCategory(new String[] { \"test\" });\n        inventory.setVariationTags(new String[] { \"test\" });\n        inventory.setVariationAttributes(new String[] { \"test\" });\n        inventory.setVariationImages(new String[] { \"test\" });\n        inventory.setVariationUrls(new String[] { \"test\" });\n        inventory.setVariationUrls(new String[] { \"test\" });\n        inventory.setVariationUrls(new String[] { \"test\" });\n        inventory.setVariationUrls(new String[] { \"test\" });\n        inventory.setVariationUrls(new String[] { \"test\" });\n        inventory.setVariationUrls(new String[] { \"test\" });\n        inventory.setVariationUrls(new String[] { \"test\" });\n        inventory.setVariationUrls(new String[] { \"test\" });\n        inventory.setVariationUrls(new String[] { \"test\" });\n        inventory.setVariationUrls(new String[] { \"test\" });\n        inventory.setVariationUrls(new String[] { \"test\" });\n        inventory.setVariationUrls(new String[] { \"test\" });\n        inventory.setVariationUrls(new String[] { \"test\" });\n        inventory.setVariationUrls(new String[] { \"test\" });\n        inventory.setVariationUrls(new String[] { \"test\" });\n        inventory.setVariationUrls(new String[] { \"test\" });\n        inventory.setVariationUrls(new String[] { \"test\" });\n        inventory.setVariationUrls(new String[] { \"test\" });\n        inventory.setVariationUrls(new String[] { \"test\" });\n        inventory.setVariationUrls(new String[] { \"test\" });\n        inventory.setVariationUrls(new String[] { \"test\" });\n        inventory.setVariationUrls(new String[] { \"test\" });\n        inventory.setVariationUrls(new String[] { \"test\" });\n        inventory.setVariationUrls(new String[] { \"test\" });\n        inventory.setVariationUrls(new String[] { \"test\" });\n        inventory.setVariationUrls(new String[] { \"test\" });\n        inventory.setVariationUrls(new String[] { \"test\" });\n        inventory.setVariationUrls(new String[] { \"test\" });\n        inventory.setVariationUrls(new String[] { \"test\" });\n        inventory.setVariationUrls(new String[] { \"test\" });\n        inventory.setVariationUrls(new String[] { \"test\" });\n        inventory.setVariationUrls(new String[] { \"test\" });\n        inventory.setVariationUrls(new String[] { \"test\" });\n        inventory.setVariationUrls(new String[] { \"test\" });\n        inventory.setVariationUrls(new String[] { \"test\" });\n        inventory.setVariationUrls(new String[] { \"test\" });\n        inventory.setVariationUrls(new String[] { \"test\" });\n        inventory.setVariationUrls(new String[] { \"test\" });\n        inventory.setVariationUrls(new String[] { \"test\" });\n        inventory.setVariationUrls(new String[] { \"test\" });\n        inventory.setVariationUrls(new String[] { \"test\" });\n        inventory.setVariationUrls(new String[] { \"test\" });\n        inventory.setVariationUrls(new String[] { \"test\" });\n        inventory.setVariationUrls(new String[] { \"test\" });\n        inventory.setVariationUrls(new String[] { \"test\" });\n        inventory.setVariationUrls(new String[] { \"test\" });\n        inventory.setVariationUrls(new String[] { \"test\" });\n        inventory.setVariationUrls(new String[] { \"test\" });\n        inventory.setVariationUrls(new String[] { \"test\" });\n        inventory.setVariationUrls(new String[] { \"test\" });\n        inventory.setVariationUrls(new String[] { \"test\" });\n        inventory.setVariationUrls(", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "16021499_69", "part": [1, 1], "seq": [1, 1], "prompt": "class AdvancedFilterValidator implements GenericMetaInfDataValidator, FilterValidator, DocumentViewXmlValidator, JcrPathValidator {\n\n    @Override\n    public @Nullable Collection<ValidationMessage> validateJcrPath(@NotNull NodeContext nodeContext,\n            boolean isFolder) {\n        if (!isFolder) {\n            return validateFileNodePath(nodeContext.getNodePath());\n        } else {\n            return null;\n        }\n    }\n\n    public  AdvancedFilterValidator(@NotNull DocumentBuilderFactory factory, @NotNull ValidationMessageSeverity defaultSeverity, @NotNull ValidationMessageSeverity severityForUncoveredAncestorNodes, @NotNull ValidationMessageSeverity severityForUncoveredFilterRootAncestors, @NotNull ValidationMessageSeverity severityForOrphanedFilterEntries, boolean isSubPackage, @NotNull Collection<PackageInfo> dependenciesMetaInfo, @NotNull WorkspaceFilter filter, @NotNull Collection<String> validRoots);\n\n    public void setFilterValidators(Map<String, FilterValidator> filterValidators);\n    @Override public Collection<ValidationMessage> done();\n    @Override public Collection<ValidationMessage> validate(@NotNull WorkspaceFilter filter);\n    private Collection<ValidationMessage> validatePathFilterSets(Collection<PathFilterSet> pathFilterSets, boolean checkRoots);\n    private Collection<ValidationMessage> validateFileNodePath(@NotNull String nodePath);\n    @Override public @Nullable Collection<ValidationMessage> validate(@NotNull DocViewNode node, @NotNull NodeContext nodeContext,\n            boolean isRoot);\n    static boolean isRegexValidForRootPath(String regex, String rootPath);\n    @Override public Collection<ValidationMessage> validateMetaInfData(@NotNull InputStream input, @NotNull Path filePath, @NotNull Path basePath);\n    @Override public boolean shouldValidateMetaInfData(@NotNull Path filePath);\n    private void removeFromOrphanedFilterEntries(@NotNull String nodePath);\n    @Nullable String getDanglingAncestorNodePath(String nodePath, WorkspaceFilter filter);\n\n    private AdvancedFilterValidator validator;\n    @Mock\n    private FilterValidator filterValidator1;\n    @Mock\n    private FilterValidator filterValidator2;\n    @Mock\n    private PackageProperties properties;\n    @Mock\n    private WorkspaceFilter filter;\n    private Collection<PackageInfo> dependenciesMetaInfo;\n    private Collection<String> validRoots;\n    private DocumentBuilderFactory factory;\n\n}\n\nclass AdvancedFilterValidatorTest {\n\n    private AdvancedFilterValidator validator;\n    @Mock\n    private FilterValidator filterValidator1;\n    @Mock\n    private FilterValidator filterValidator2;\n    @Mock\n    private PackageProperties properties;\n    @Mock\n    private WorkspaceFilter filter;\n    private Collection<PackageInfo> dependenciesMetaInfo;\n    private Collection<String> validRoots;\n    private DocumentBuilderFactory factory;\n\n    @Test\n    public void testUncoveredAncestorNodesFailure() throws IOException, ConfigurationException {\n", "reference": "        DefaultWorkspaceFilter filter = new DefaultWorkspaceFilter();\n        try (InputStream input = this.getClass().getResourceAsStream(\"/filter.xml\")) {\n            filter.load(input);\n        }\n        validator = new AdvancedFilterValidator(\n                factory,\n                ValidationMessageSeverity.ERROR,\n                AdvancedFilterValidatorFactory.DEFAULT_SEVERITY_FOR_UNCOVERED_ANCESTOR_NODES,\n                ValidationMessageSeverity.ERROR,\n                ValidationMessageSeverity.ERROR,\n                false,\n                dependenciesMetaInfo,\n                filter, // this is per test\n                validRoots);\n\n        // default severity INFO\n        ValidationExecutorTest.assertViolation(validator.validateJcrPath(getStandardNodeContext(\"/apps\"), false), ValidationMessageSeverity.INFO,\n                new ValidationMessage(ValidationMessageSeverity.INFO,\n                        String.format(AdvancedFilterValidator.MESSAGE_ANCESTOR_NODE_NOT_COVERED_BUT_VALID_ROOT, \"/apps\")));\n        ValidationExecutorTest.assertViolation(validator.validateJcrPath(getStandardNodeContext(\"/apps/test4\"), false), ValidationMessageSeverity.INFO,\n                new ValidationMessage(ValidationMessageSeverity.INFO,\n                        String.format(AdvancedFilterValidator.MESSAGE_ANCESTOR_NODE_NOT_COVERED, \"/apps/test4\")));\n\n        // default severity ERROR\n        validator = new AdvancedFilterValidator(\n                factory,\n                ValidationMessageSeverity.ERROR,\n                ValidationMessageSeverity.ERROR,\n                ValidationMessageSeverity.ERROR,\n                ValidationMessageSeverity.ERROR,\n                false,\n                dependenciesMetaInfo,\n                filter, // this is per test\n                validRoots);\n\n        ValidationExecutorTest.assertViolation(validator.validateJcrPath(getStandardNodeContext(\"/apps/test4\"), false), ValidationMessageSeverity.INFO,\n                new ValidationMessage(ValidationMessageSeverity.ERROR,\n                        String.format(AdvancedFilterValidator.MESSAGE_ANCESTOR_NODE_NOT_COVERED, \"/apps/test4\")));\n\n        // set valid roots\n        validRoots.add(\"/someroot\");\n        // default severity ERROR\n        validator = new AdvancedFilterValidator(\n                factory,\n                ValidationMessageSeverity.ERROR,\n                ValidationMessageSeverity.WARN,\n                ValidationMessageSeverity.ERROR,\n                ValidationMessageSeverity.ERROR,\n                false,\n                dependenciesMetaInfo,\n                filter, // this is per test\n                Collections.emptyList());\n        ValidationExecutorTest.assertViolation(validator.validateJcrPath(getStandardNodeContext(\"/apps\"), false), ValidationMessageSeverity.WARN,\n                new ValidationMessage(ValidationMessageSeverity.WARN,\n                        String.format(AdvancedFilterValidator.MESSAGE_ANCESTOR_NODE_NOT_COVERED, \"/apps\")));\n    }\n\n}", "prediction": "        validator = new AdvancedFilterValidator(factory, ValidationMessageSeverity.ERROR, ValidationMessageSeverity.ERROR, ValidationMessageSeverity.ERROR, ValidationMessageSeverity.ERROR, false, dependenciesMetaInfo, filter, validRoots);\n        validator.setFilterValidators(Collections.singletonMap(\"filter1\", filterValidator1));\n        validator.setFilterValidators(Collections.singletonMap(\"filter2\", filterValidator2));\n        when(filterValidator1.validate(filter)).thenReturn(Collections.singletonList(new ValidationMessage(ValidationMessageSeverity.ERROR, \"message1\")));\n        when(filterValidator2.validate(filter)).thenReturn(Collections.singletonList(new ValidationMessage(ValidationMessageSeverity.ERROR, \"message2\")));\n        Collection<ValidationMessage> messages = validator.validate(filter);\n        assertEquals(2, messages.size());\n        assertEquals(\"message1\", messages.iterator().next().getMessage());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "16362479_546", "part": [1, 1], "seq": [1, 1], "prompt": "class TransactionChainProxy extends AbstractTransactionContextFactory<LocalTransactionChain> implements DOMStoreTransactionChain {\n\n    @Override\n    public DOMStoreWriteTransaction newWriteOnlyTransaction() {\n        getActorUtils().acquireTxCreationPermit();\n        return allocateWriteTransaction(TransactionType.WRITE_ONLY);\n    }\n\n      TransactionChainProxy(final TransactionContextFactory parent, final LocalHistoryIdentifier historyId);\n\n    @Override public DOMStoreReadTransaction newReadOnlyTransaction();\n    @Override public DOMStoreReadWriteTransaction newReadWriteTransaction();\n    @Override public void close();\n    private TransactionProxy allocateWriteTransaction(final TransactionType type);\n    @Override protected LocalTransactionChain factoryForShard(final String shardName, final ActorSelection shardLeader,\n            final ReadOnlyDataTree dataTree);\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) @Override protected Future<PrimaryShardInfo> findPrimaryShard(final String shardName, final TransactionIdentifier txId);\n    private Future<T> combineFutureWithPossiblePriorReadOnlyTxFutures(final Future<T> future,\n            final TransactionIdentifier txId);\n    private Future<T> combineWithPriorReadOnlyTxFutures(final Future<T> future, final TransactionIdentifier txId);\n    @Override protected void onTransactionReady(final TransactionIdentifier transaction,\n            final Collection<Future<T>> cohortFutures);\n    @Override protected void onTransactionContextCreated(final TransactionIdentifier transactionId);\n\n    private LocalHistoryIdentifier historyId;\n\n}\n\nclass TransactionChainProxyTest extends AbstractTransactionContextFactory<LocalTransactionChain> {\n\n    private LocalHistoryIdentifier historyId;\n\n    @SuppressWarnings(\"resource\")\n    @Test\n    public void testNewWriteOnlyTransaction() {\n", "reference": "        DOMStoreTransaction dst = new TransactionChainProxy(mockComponentFactory, historyId).newWriteOnlyTransaction();\n        Assert.assertTrue(dst instanceof DOMStoreWriteTransaction);\n\n    }\n\n}", "prediction": "        final TransactionChainProxy chain = new TransactionChainProxy(this, historyId);\n        final DOMStoreWriteTransaction tx = chain.newWriteOnlyTransaction();\n        assertNotNull(tx);\n        assertTrue(tx instanceof DOMStoreWriteTransaction);\n        assertTrue(tx instanceof TransactionProxy);\n        assertTrue(tx instanceof DOMStoreTransaction);\n        assertTrue(tx instanceof Transaction);\n        assertTrue(tx instanceof TransactionContext);\n        assertTrue(tx instanceof TransactionChain);\n        assertTrue(tx instanceof TransactionChainProxy);\n        assertTrue(tx instanceof DOMStoreTransactionChain);\n        assertTrue(tx instanceof DOMStoreTransactionChainProxy);\n        assertTrue(tx instanceof DOMStoreTransactionChainProxyImpl);\n        assertTrue(tx instanceof DOMStoreTransactionChainProxyImpl.TransactionChainProxyImpl);\n        assertTrue(tx instanceof DOMStoreTransactionChainProxyImpl.TransactionChainProxyImpl.TransactionChainProxyImpl);\n        assertTrue(tx instanceof DOMStoreTransactionChainProxyImpl.TransactionChainProxyImpl.TransactionChainProxyImpl.TransactionChainProxyImpl);\n        assertTrue(tx instanceof DOMStoreTransactionChainProxyImpl.TransactionChainProxyImpl.TransactionChainProxyImpl.TransactionChainProxyImpl.TransactionChainProxyImpl);\n        assertTrue(tx instanceof DOMStoreTransactionChainProxyImpl.TransactionChainProxyImpl.TransactionChainProxyImpl.TransactionChainProxyImpl.TransactionChainProxyImpl.TransactionChainProxyImpl);\n        assertTrue(tx instanceof DOMStoreTransactionChainProxyImpl.TransactionChainProxyImpl.TransactionChainProxyImpl.TransactionChainProxyImpl.TransactionChainProxyImpl.TransactionChainProxyImpl.TransactionChainProxyImpl);\n        assertTrue(tx instanceof DOMStoreTransactionChainProxyImpl.TransactionChainProxyImpl.TransactionChainProxyImpl.TransactionChainProxyImpl.TransactionChainProxyImpl.TransactionChainProxyImpl.TransactionChainProxyImpl.TransactionChainProxyImpl);\n       ", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "16362494_0", "part": [1, 1], "seq": [1, 1], "prompt": "class FlowEntryMgr {\n\n\tpublic void addOpenFlowEntry(String nodeId, String flowEntryLabel, Object flowEntry) throws Exception {\n\n\t\ttry {\n\t\t\tassertConnectorNotNull();\n\t\t\tStringBuilder urlPrefix = constructFlowUrlPrefix(nodeId, flowEntryLabel);\n\t\t\tconnector.putToController(urlPrefix.toString(), flowEntry);\n\t\t} catch (Throwable e) {\n\t\t\tString msg = \"Excepted trying to addOpenFlowEntry for \" + nodeId + \" \" + flowEntryLabel + \" \" + flowEntry;\n\t\t\tlog.error(msg, e);\n\t\t\tthrow new Exception(msg, e);\n\t\t}\n\t}\n\n\tpublic  FlowEntryMgr();\n\n\tpublic void setOdl(Odl odl);\n\tprotected void assertConnectorNotNull();\n\tpublic ReceivedFlowConfig getOpenFlowEntry(String nodeId, String flowEntryLabel);\n\tpublic void toggleOpenFlowEntry(String nodeId, String flowEntryLabel);\n\tpublic void deleteOpenFlowEntry(String nodeId, String flowEntryLabel);\n\tpublic FlowStatistics getOpenFlowStats(String nodeId);\n\tpublic Nodes getNodes();\n\tprotected StringBuilder constructFlowUrlPrefix(String nodeId, String flowEntryLabel);\n\tprotected StringBuilder constructAllFlowsUrlPrefix();\n\tprotected StringBuilder constructFlowStatsUrlPrefix(String nodeId);\n\tprotected StringBuilder constructFlowSwitchUrlPrefix();\n\tpublic void reset();\n\n    private FlowEntryMgr flowEntryMgr;\n    private Connector connector;\n    private String testNodeId;\n\n}\n\nclass FlowEntryMgrTest {\n\n    private FlowEntryMgr flowEntryMgr;\n    private Connector connector;\n    private String testNodeId;\n\n    @Test\n    public void testAddOpenFlowEntry() throws Exception {\n", "reference": "//        flowEntryMgr.addOpenFlowEntry(testNodeId, getFlow2());\n    }\n\n}", "prediction": "        flowEntryMgr.addOpenFlowEntry(testNodeId, \"testFlowEntry\", new FlowEntry());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "16368712_4", "part": [1, 1], "seq": [1, 1], "prompt": "class Task {\n\n  public Task<Void> continueWhile(Callable<Boolean> predicate,\n      Continuation<Void, Task<Void>> continuation) {\n    return continueWhile(predicate, continuation, IMMEDIATE_EXECUTOR, null);\n  }\n\n    Task();\n  private  Task(TResult result);\n  private  Task(boolean cancelled);\n\n  public static UnobservedExceptionHandler getUnobservedExceptionHandler();\n  public static void setUnobservedExceptionHandler(UnobservedExceptionHandler eh);\n  public static Task<TResult>.TaskCompletionSource create();\n  public boolean isCompleted();\n  public boolean isCancelled();\n  public boolean isFaulted();\n  public TResult getResult();\n  public Exception getError();\n  public void waitForCompletion();\n  public boolean waitForCompletion(long duration, TimeUnit timeUnit);\n  @SuppressWarnings(\"unchecked\") public static Task<TResult> forResult(TResult value);\n  public static Task<TResult> forError(Exception error);\n  @SuppressWarnings(\"unchecked\") public static Task<TResult> cancelled();\n  public static Task<Void> delay(long delay);\n  public static Task<Void> delay(long delay, CancellationToken cancellationToken);\n  static Task<Void> delay(long delay, ScheduledExecutorService executor, final CancellationToken cancellationToken);\n  public Task<TOut> cast();\n  public Task<Void> makeVoid();\n  public static Task<TResult> callInBackground(Callable<TResult> callable);\n  public static Task<TResult> callInBackground(Callable<TResult> callable, CancellationToken ct);\n  public static Task<TResult> call(final Callable<TResult> callable, Executor executor);\n  public static Task<TResult> call(final Callable<TResult> callable, Executor executor,\n      final CancellationToken ct);\n  public static Task<TResult> call(final Callable<TResult> callable);\n  public static Task<TResult> call(final Callable<TResult> callable, CancellationToken ct);\n  public static Task<Task<TResult>> whenAnyResult(Collection<? extends Task<TResult>> tasks);\n  @SuppressWarnings(\"unchecked\") public static Task<Task<?>> whenAny(Collection<? extends Task<?>> tasks);\n  public static Task<List<TResult>> whenAllResult(final Collection<? extends Task<TResult>> tasks);\n  public static Task<Void> whenAll(Collection<? extends Task<?>> tasks);\n  public Task<Void> continueWhile(Callable<Boolean> predicate,\n      Continuation<Void, Task<Void>> continuation, CancellationToken ct);\n  public Task<Void> continueWhile(final Callable<Boolean> predicate,\n      final Continuation<Void, Task<Void>> continuation, final Executor executor);\n  public Task<Void> continueWhile(final Callable<Boolean> predicate,\n      final Continuation<Void, Task<Void>> continuation, final Executor executor,\n      final CancellationToken ct);\n  public Task<TContinuationResult> continueWith(\n      final Continuation<TResult, TContinuationResult> continuation, final Executor executor);\n  public Task<TContinuationResult> continueWith(\n      final Continuation<TResult, TContinuationResult> continuation, final Executor executor,\n      final CancellationToken ct);\n  public Task<TContinuationResult> continueWith(\n      Continuation<TResult, TContinuationResult> continuation);\n  public Task<TContinuationResult> continueWith(\n      Continuation<TResult, TContinuationResult> continuation, CancellationToken ct);\n  public Task<TContinuationResult> continueWithTask(\n      final Continuation<TResult, Task<TContinuationResult>> continuation, final Executor executor);\n  public Task<TContinuationResult> continueWithTask(\n      final Continuation<TResult, Task<TContinuationResult>> continuation, final Executor executor,\n      final CancellationToken ct);\n  public Task<TContinuationResult> continueWithTask(\n      Continuation<TResult, Task<TContinuationResult>> continuation);\n  public Task<TContinuationResult> continueWithTask(\n      Continuation<TResult, Task<TContinuationResult>> continuation, CancellationToken ct);\n  public Task<TContinuationResult> onSuccess(\n      final Continuation<TResult, TContinuationResult> continuation, Executor executor);\n  public Task<TContinuationResult> onSuccess(\n      final Continuation<TResult, TContinuationResult> continuation, Executor executor,\n      final CancellationToken ct);\n  public Task<TContinuationResult> onSuccess(\n      final Continuation<TResult, TContinuationResult> continuation);\n  public Task<TContinuationResult> onSuccess(\n      final Continuation<TResult, TContinuationResult> continuation, CancellationToken ct);\n  public Task<TContinuationResult> onSuccessTask(\n      final Continuation<TResult, Task<TContinuationResult>> continuation, Executor executor);\n  public Task<TContinuationResult> onSuccessTask(\n      final Continuation<TResult, Task<TContinuationResult>> continuation, Executor executor,\n      final CancellationToken ct);\n  public Task<TContinuationResult> onSuccessTask(\n      final Continuation<TResult, Task<TContinuationResult>> continuation);\n  public Task<TContinuationResult> onSuccessTask(\n      final Continuation<TResult, Task<TContinuationResult>> continuation,\n      CancellationToken ct);\n  private static void completeImmediately(\n      final bolts.TaskCompletionSource<TContinuationResult> tcs,\n      final Continuation<TResult, TContinuationResult> continuation, final Task<TResult> task,\n      Executor executor, final CancellationToken ct);\n  private static void completeAfterTask(\n      final bolts.TaskCompletionSource<TContinuationResult> tcs,\n      final Continuation<TResult, Task<TContinuationResult>> continuation,\n      final Task<TResult> task, final Executor executor,\n      final CancellationToken ct);\n  private void runContinuations();\n   boolean trySetCancelled();\n   boolean trySetResult(TResult result);\n   boolean trySetError(Exception error);\n\n  @Rule\n  public ExpectedException thrown;\n\n}\n\nclass TaskTest {\n\n  @Rule\n  public ExpectedException thrown;\n\n  @Test\n  public void testContinueWhile() {\n", "reference": "    final AtomicInteger count = new AtomicInteger(0);\n    runTaskTest(new Callable<Task<?>>() {\n      public Task<?> call() throws Exception {\n        return Task.forResult(null).continueWhile(new Callable<Boolean>() {\n          public Boolean call() throws Exception {\n            return count.get() < 10;\n          }\n        }, new Continuation<Void, Task<Void>>() {\n          public Task<Void> then(Task<Void> task) throws Exception {\n            count.incrementAndGet();\n            return null;\n          }\n        }).continueWith(new Continuation<Void, Void>() {\n          public Void then(Task<Void> task) throws Exception {\n            assertEquals(10, count.get());\n            return null;\n          }\n        });\n      }\n    });\n  }\n\n}", "prediction": "    final AtomicInteger counter = new AtomicInteger(0);\n    final Task<Void> task = Task.forResult(null).continueWhile(new Callable<Boolean>() {\n      @Override\n      public Boolean call() throws Exception {\n        return counter.get() < 10;\n      }\n    }, new Continuation<Void, Task<Void>>() {\n      @Override\n      public Task<Void> then(Task<Void> task) throws Exception {\n        counter.incrementAndGet();\n        return null;\n      }\n    });\n\n    task.waitForCompletion();\n    assertEquals(10, counter.get());\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "16462032_69", "part": [1, 1], "seq": [1, 1], "prompt": "class StringUtils {\n\n    public static boolean equals(String s1, String s2, Locale locale) {\n        return Collator.getInstance(locale).equals(s1, s2);\n    }\n\n    private  StringUtils();\n\n    public static boolean endsWithIgnoreCase(String a, String b);\n    public static boolean matchesIgnoreCase(String a, String b, int posA);\n    public static boolean endsWithIgnoreCase(String a, char[] b);\n    public static boolean matchesIgnoreCase(String a, char[] b, int posA);\n    public static boolean endsWith(String a, char[] b);\n    public static boolean matches(String a, char[] b, int posA);\n    public static boolean startsWithIgnoreCase(String a, String b);\n    public static boolean equals(String s1, String s2, boolean caseSensitive);\n    public static int parseIntDef(String s, int def);\n    public static String capitalize(String s);\n    public static String flatten(String s[]);\n    public static String flatten(String s[], String separator);\n    public static boolean isNullOrEmpty(String string);\n\n}\n\nclass StringUtilsTest {\n\n    @Test(dataProvider = \"caseInsensitiveEquals\")\n    public void testCaseInsensitiveEquals(String a, String b, boolean expected) {\n", "reference": "        assert StringUtils.equals(a, b, false) == expected;\n    }\n\n}", "prediction": "        assertEquals(StringUtils.equals(a, b, Locale.ENGLISH), expected);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "16896558_1", "part": [1, 1], "seq": [1, 1], "prompt": "class CompletableFutureFlow {\n\n    static CompletableFuture<Integer> flowWithId(int id, ExecutorService pool) {\n        return firstOperation(id, pool)\n                .thenCompose(__ -> secondOperation(id, pool))\n                .thenCompose(__ -> thirdOperation(id, pool));\n    }\n\n    private static CompletableFuture<Integer> firstOperation(int id, ExecutorService pool);\n    private static CompletableFuture<Integer> slowOperationAsync(int flow, int step, ExecutorService pool);\n    private static int slowOperation(int flow, int step);\n    private static CompletableFuture<Integer> secondOperation(int id, ExecutorService pool);\n    private static CompletableFuture<Integer> thirdOperation(int id, ExecutorService pool);\n    static void getFuture(CompletableFuture<Integer> future);\n\n    public static final int POOL_SIZE;\n    private ExecutorService pool;\n\n}\n\nclass CompletableFutureFlowTest {\n\n    public static final int POOL_SIZE;\n    private ExecutorService pool;\n\n    @Test\n    public void testFlowWithFixedThreadPool() throws Exception {\n", "reference": "        pool = Executors.newFixedThreadPool(POOL_SIZE);\n\n        List<CompletableFuture<Integer>> futures = new ArrayList<>();\n\n        for (int i = 0; i < 20; i++) {\n            futures.add(\n                    CompletableFutureFlow.flowWithId(i, pool));\n        }\n\n        futures.forEach(CompletableFutureFlow::getFuture);\n    }\n\n}", "prediction": "        CompletableFuture<Integer> future = CompletableFutureFlow.flowWithId(1, pool);\n        CompletableFutureFlow.getFuture(future);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "16945217_19", "part": [1, 1], "seq": [1, 1], "prompt": "class TStringUtil extends StringUtils {\n\n    public static List<String> recursiveSplit(String str, String splitor) {\n        List<String> re = new ArrayList<String>();\n        String[] strs = twoPartSplit(str, splitor);\n        if (strs.length == 2) {\n            re.add(strs[0]);\n            re.addAll(recursiveSplit(strs[1], splitor));\n        } else {\n            re.add(strs[0]);\n        }\n        return re;\n    }\n\n    public static String getBetween(String sql, String start, String end);\n    public static String removeBetween(String sql, String start, String end);\n    public static String[] twoPartSplit(String str, String splitor);\n    public static String fillTabWithSpace(String str);\n    public static boolean startsWithIgnoreCaseAndWs(String searchIn, String searchFor);\n    public static boolean startsWithIgnoreCaseAndWs(String searchIn, String searchFor, int beginPos);\n    public static boolean startsWithIgnoreCase(String searchIn, int startAt, String searchFor);\n    public static String stripComments(String src, String stringOpens, String stringCloses, boolean slashStarComments,\n                                       boolean slashSlashComments, boolean hashComments, boolean dashDashComments);\n    public static String removeBetweenWithSplitor(String sql, String start, String end);\n    public static String removeBetweenWithSplitorNotExistNull(String sql, String start, String end);\n    public static boolean isTableFatherAndSon(String fatherTable, String sonTable);\n\n}\n\nclass TStringUtilTest {\n\n    @Test\n    public void testRecursiveSplit() {\n", "reference": "        Assert.assertEquals(TStringUtil.recursiveSplit(\"abc:bc:bc\", \":\"), Arrays.asList(\"abc\", \"bc\", \"bc\"));\n        Assert.assertEquals(TStringUtil.recursiveSplit(\"abc:bc\", \"d\"), Arrays.asList(\"abc:bc\"));\n        Assert.assertEquals(TStringUtil.recursiveSplit(\"abc:bc\", \";\"), Arrays.asList(\"abc:bc\"));\n    }\n\n}", "prediction": "        Assert.assertEquals(Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\"),\n                TStringUtil.recursiveSplit(\"a.b.c.d.e\", \".\"));\n        Assert.assertEquals(Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\"),\n                TStringUtil.recursiveSplit(\"a.b.c.d.e\", \".\"));\n        Assert.assertEquals(Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\"),\n                TStringUtil.recursiveSplit(\"a.b.c.d.e\", \".\"));\n        Assert.assertEquals(Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\"),\n                TStringUtil.recursiveSplit(\"a.b.c.d.e\", \".\"));\n        Assert.assertEquals(Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\"),\n                TStringUtil.recursiveSplit(\"a.b.c.d.e\", \".\"));\n        Assert.assertEquals(Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\"),\n                TStringUtil.recursiveSplit(\"a.b.c.d.e\", \".\"));\n        Assert.assertEquals(Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\"),\n                TStringUtil.recursiveSplit(\"a.b.c.d.e\", \".\"));\n        Assert.assertEquals(Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\"),\n                TStringUtil.recursiveSplit(\"a.b.c.d.e\", \".\"));\n        Assert.assertEquals(Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\"),\n                TStringUtil.recursiveSplit(\"a.b.c.d.e\", \".\"));\n        Assert.assertEquals(Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\"),\n                TStringUtil.recursiveSplit(\"a.b.c.d.e\", \".\"));\n        Assert.assertEquals(Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\"),\n                TStringUtil.recursiveSplit(\"a.b.c.d.e\", \".\"));\n        Assert.assertEquals(Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\"),\n                TStringUtil.recursiveSplit(\"a.b.c.d.e\", \".\"));\n        Assert.assertEquals(Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\"),\n                TStringUtil.recursiveSplit(\"a.b.c.d.e\", \".\"));\n        Assert.assertEquals(Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\"),\n                TStringUtil.recursiveSplit(\"a.b.c.d.e\", \".\"));\n        Assert.assertEquals(Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\"),\n                TStringUtil.recursiveSplit(\"a.b.c.d.e\", \".\"));\n        Assert.assertEquals(Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\"),\n                TStringUtil.recursiveSplit(\"a.b.c.d.e\", \".\"));\n        Assert.assertEquals(Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\"),\n                TStringUtil.recursiveSplit(\"a.b.c.d.e\", \".\"));\n        Assert.assertEquals(Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\"),\n                TStringUtil.recursiveSplit(\"a.b.c.d.e\", \".\"));\n        Assert.assertEquals(Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\"),\n                TStringUtil.recursiveSplit(\"a.b.c.d.e\", \".\"));\n        Assert.assertEquals(Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\"),\n                TStringUtil.recursiveSplit(\"a.b.c.d.e\", \".\"));\n        Assert.assertEquals(Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\"),\n                TStringUtil.recursiveSplit(\"a.b.c.d.e\", \".\"));\n        Assert.assertEquals(Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\"),\n                TStringUtil.recursiveSplit(\"a.b.c.d.e\", \".\"));\n        Assert.assertEquals(Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\"),\n                TStringUtil.recursiveSplit(\"a.b.c.d.e\", \".\"));\n        Assert.assertEquals(Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\"),\n                TStringUtil.recursiveSplit(\"a.b.c.d.e\", \".\"));\n        Assert.assertEquals(Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\"),\n                TStringUtil.recursiveSplit(\"a.b.c.d.e\", \".\"));\n        Assert.assertEquals(Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\"),\n                TStringUtil.recursiveSplit(\"a.b.c.d.e\", \".\"));\n        Assert.assertEquals(Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\"),\n                TStringUtil.recursiveSplit(\"a.b.c.d.e\", \".\"));\n        Assert.assertEquals(Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\"),\n                TStringUtil.recursiveSplit(\"a.b.c.d.e\", \".\"));\n        Assert.assertEquals(Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\"),\n                TStringUtil.recursiveSplit(\"a.b.c.d.e\", \".\"));\n        Assert.assertEquals(Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\"),\n                TStringUtil.recursiveSplit(\"a.b.c.d.e\", \".\"));\n        Assert.assertEquals(Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\"),\n                TStringUtil.recursiveSplit(\"a.b.c.d.e\", \".\"));\n        Assert.assertEquals(Arrays.asList(\"a\", \"b\", \"", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "17146973_1", "part": [1, 1], "seq": [1, 1], "prompt": "class Speakerbox implements TextToSpeech.OnInitListener {\n\n    public void play(CharSequence text) {\n        play(text.toString(), null, null, null);\n    }\n\n    public  Speakerbox(final Application application);\n\n    @Override public void onInit(int status);\n    public void setActivity(Activity activity);\n    public Application.ActivityLifecycleCallbacks getCallbacks();\n    public void playAndOnStart(String text, Runnable onStart);\n    public void playAndOnDone(String text, Runnable onDone);\n    public void playAndOnError(String text, Runnable onError);\n    public void play(String text, Runnable onStart, Runnable onDone, Runnable onError);\n    public void stop();\n    private String applyRemixes(String text);\n    private void playInternal(String text, String utteranceId);\n    public void dontPlayIfContains(String text);\n    private boolean doesNotContainUnwantedPhrase(String text);\n    public void mute();\n    public void unmute();\n    public boolean isMuted();\n    public void remix(String original, String remix);\n    public TextToSpeech getTextToSpeech();\n    public void requestAudioFocus();\n    public void abandonAudioFocus();\n    public void enableVolumeControl(Activity activity);\n    public void disableVolumeControl(Activity activity);\n    public void setQueueMode(int queueMode);\n    @TargetApi(Build.VERSION_CODES.LOLLIPOP) public Set<Locale> getAvailableLanguages();\n    public void setLanguage(Locale locale);\n    public void shutdown();\n    private boolean detectAndRun(String utteranceId, HashMap<String, Runnable> hashMap);\n\n    private Activity activity;\n    private Speakerbox speakerbox;\n    private com.mapzen.speakerbox.ShadowTextToSpeech shadowTextToSpeech;\n\n}\n\nclass SpeakerboxTest {\n\n    private Activity activity;\n    private Speakerbox speakerbox;\n    private com.mapzen.speakerbox.ShadowTextToSpeech shadowTextToSpeech;\n\n    @Test\n    public void shouldPlayCharacterSequence() throws Exception {\n", "reference": "        CharSequence expected = \"Hello\";\n        speakerbox.play(expected);\n        assertThat(shadowTextToSpeech.getLastSpokenText()).isEqualTo(expected.toString());\n    }\n\n}", "prediction": "        speakerbox.play(\"Hello\");\n        assertEquals(\"Hello\", shadowTextToSpeech.getLastSpokenText());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "17203543_4", "part": [1, 1], "seq": [1, 1], "prompt": "class POIBean {\n\n\tpublic String getDescription() {\n\t\treturn description;\n\t}\n\n\tpublic  POIBean(String _id, String _name, String _desc, int _type, double lat, double lon);\n\n\tpublic String getId();\n\tpublic void setId(String id);\n\tpublic String getName();\n\tpublic void setName(String name);\n\tpublic void setDescription(String description);\n\tpublic int getType();\n\tpublic void setType(int type);\n\tpublic JSONObject toJSONObject();\n\n\tprivate POIBean poiBean;\n\n}\n\nclass POIBeanTest {\n\n\tprivate POIBean poiBean;\n\n\t@Test\n\tpublic void testGetDescription() {\n", "reference": "\t\tassertEquals(poiBean.getDescription(), \"haha\");\n\t}\n\n}", "prediction": "\t\tassertEquals(\"\", poiBean.getDescription());\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "17537838_1", "part": [1, 1], "seq": [1, 1], "prompt": "class DefaultRoleToGroupMapper implements RoleToGroupMapper {\n\n    @Override\n    public List<String> groupsFromRoles(List<String> roles) {\n        if (template == null || roles == null) {\n            return roles;\n        } else {\n            List<String> renamedRoles = new ArrayList<>();\n            for (String role : roles) {\n                String renamedRole = template.replace(ROLE_MAPPING_PLACEHOLDER, role);\n                renamedRoles.add(renamedRole);\n                LOG.debug(\"Mapped role {} to {}\", role, renamedRole);\n            }\n            return renamedRoles;\n        }\n    }\n\n    @Override public void cleanup();\n    @Override public void initialize(Properties properties);\n\n}\n\nclass DefaultRoleToGroupMapperTest {\n\n    @Test\n    public void testNullMapping() {\n", "reference": "        DefaultRoleToGroupMapper mapper = new DefaultRoleToGroupMapper();\n\n        List<String> result = mapper.groupsFromRoles(null);\n        assertNull(result);\n    }\n\n}", "prediction": "        DefaultRoleToGroupMapper mapper = new DefaultRoleToGroupMapper();\n        List<String> groups = mapper.groupsFromRoles(null);\n        assertNull(groups);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "17586846_36", "part": [1, 1], "seq": [1, 1], "prompt": "class AHashSet extends MapAsSetWrapper<T, AHashSet<T>> {\n\n    public static <T> AHashSet<T> empty () {\n        return empty (AEquality.EQUALS);\n    }\n\n    private  AHashSet(AMap<T, ?> inner);\n\n    @SuppressWarnings (\"unchecked\") public static AHashSet<T> empty(AEquality equality);\n    @SuppressWarnings (\"unchecked\") public static AHashSet<T> create(T... elements);\n    public static AHashSet<T> create(Iterable<T> elements);\n    @SuppressWarnings (\"unchecked\") public static AHashSet<T> create(AEquality equality, T... elements);\n    public static AHashSet<T> create(AEquality equality, Iterable<T> elements);\n    public static AHashSet<T> fromMap(AHashMap<T, ?> inner);\n    private Object readResolve();\n    @Override protected AHashSet<T> wrapAsSet(AMap<T, ?> inner);\n\n}\n\nclass AHashSetTest extends MapAsSetWrapper<T, AHashSet<T>> {\n\n    @Test\n    public void testEquals2() {\n", "reference": "        assertEquals(AHashSet.empty (),\n                     AHashSet.empty ());\n        assertEquals(AHashSet.empty ().with(\"a\"),\n                     AHashSet.empty ().with(\"a\"));\n        assertEquals(AHashSet.empty ().with(\"a\").with(\"b\"),\n                     AHashSet.empty ().with(\"b\").with(\"a\"));\n\n        assertNotEquals(AHashSet.empty (),\n                        AHashSet.empty ().with(\"a\"));\n        assertNotEquals(AHashSet.empty ().with(\"a\"),\n                        AHashSet.empty ());\n        assertNotEquals(AHashSet.empty ().with(\"a\").with(\"b\"),\n                        AHashSet.empty ().with(\"a\").with(\"b\").with(\"c\"));\n        assertNotEquals(AHashSet.empty ().with(\"a\").with(\"b\").with(\"c\"),\n                        AHashSet.empty ().with(\"a\").with(\"b\"));\n        assertNotEquals(AHashSet.empty ().with(\"a\").with(\"b\").with(\"c\"),\n                        AHashSet.empty ().with(\"b\").with(\"c\"));\n\n        assertNotEquals(AHashSet.empty (), null);\n    }\n\n}", "prediction": "        AHashSet<String> set1 = AHashSet.create(\"a\", \"b\", \"c\");\n        AHashSet<String> set2 = AHashSet.create(\"a\", \"b\", \"c\");\n        assertEquals(set1, set2);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "17627031_46", "part": [1, 1], "seq": [1, 1], "prompt": "class JsonHandler extends HandlerBase {\n\n\tprotected JsonArrayBuilder showArray(int[] iarray) {\n\t\tJsonArrayBuilder aBuilder = Json.createArrayBuilder();\n\t\tfor (int i : iarray) {\n\t\t\taBuilder.add(i);\n\t\t}\n\t\treturn aBuilder;\n\t}\n\n\tpublic  JsonHandler();\n\tpublic  JsonHandler(String name, String release, int[] date, String note, String rights);\n\n\t@Override public void show();\n\t@Override public void show(App app);\n\t@Override public void show(OutputHandler handler);\n\t@Override public void show(Module module);\n\t@Override public void show(RepInfo info);\n\tprotected JsonObjectBuilder showAgent(Agent agent, String label);\n\tprotected JsonObjectBuilder showChecksum(Checksum checksum);\n\tprotected JsonObjectBuilder showDocument(Document document);\n\t@Override public void showFooter();\n\t@Override public void showHeader();\n\tprotected JsonObjectBuilder showIdentifier(Identifier identifier);\n\tprotected JsonObjectBuilder showMessage(Message message);\n\tprotected JsonObjectBuilder showSignature(Signature signature);\n\tprotected String valueToString(Object obj);\n\tprotected JsonObjectBuilder showProperty(Property property);\n\tprotected JsonObjectBuilder showScalarProperty(Property property);\n\tprotected JsonObjectBuilder showListProperty(Property property);\n\tprotected JsonObjectBuilder showSetProperty(Property property);\n\tprotected JsonObjectBuilder showMapProperty(Property property);\n\tprotected int propertyLength(Property property);\n\tprotected JsonObjectBuilder showArrayProperty(Property property);\n\tprotected JsonObjectBuilder showTextMDMetadata(TextMDMetadata textMD);\n\tprotected JsonObjectBuilder showNisoImageMetadata(NisoImageMetadata niso);\n\tprotected JsonObjectBuilder showNisoImageMetadata(NisoImageMetadata niso, boolean bMix10);\n\tprotected JsonObjectBuilder showNisoBasicDigitalObjectInformation(NisoImageMetadata niso, boolean bMix10);\n\tprotected JsonObjectBuilder showNisoBasicImageInformation(NisoImageMetadata niso, boolean bMix10);\n\tprotected JsonObjectBuilder showNisoImageCaptureMetadata(NisoImageMetadata niso, boolean bMix10);\n\tprotected JsonObjectBuilder showNisoImageAssessmentMetadata(NisoImageMetadata niso, boolean bMix10);\n\tprotected JsonObjectBuilder showChangeHistory(NisoImageMetadata niso, boolean bMix10);\n\tprivate String meteringModeToString(int n);\n\tprivate String photometricInterpretationToString(int n);\n\tprivate String compressionSchemeToString(int n);\n\tprotected JsonObjectBuilder showAESAudioMetadata(AESAudioMetadata aes);\n\tprivate JsonObjectBuilder writeAESTimeRange(AESAudioMetadata.TimeDesc start, AESAudioMetadata.TimeDesc duration);\n\tprotected JsonArrayBuilder showArray(double[] darray);\n\tprotected JsonArrayBuilder showArray(String[] sarray);\n\tprotected JsonArrayBuilder showArray(Rational[] rarray);\n\tprotected JsonArrayBuilder showRational(Rational r);\n\n\tprivate static final Logger LOGGER;\n\tprivate static final String TIME_PATTERN;\n\tprivate static final String DATE_PATTERN;\n\tprivate static final String DATE_REPLACEMENT;\n\tprivate static final String RELEASE_PATTERN;\n\tprivate static final String RELEASE_REPLACEMENT;\n\tprivate static final String DIR_PATTERN;\n\tprivate static final String DIR_REPLACEMENT;\n\tprivate static final String CONF_PATTERN;\n\tprivate static final String CONF_REPLACEMENT;\n\tprivate static final String RIGHTS_PATTERN;\n\tprivate static final String RIGHTS_REPLACEMENT;\n\tprivate static final String VENDOR_PATTERN;\n\tprivate static final String VENDOR_REPLACEMENT;\n\tprivate static final String DUMMY;\n\tprivate static final String DUMMY_CK;\n\tprivate static final String APP_JSON;\n\tprivate static final String API_JSON;\n\tprivate static final String HANDLER_JSON;\n\tprivate static final String MODULE_JSON;\n\tprivate static final String INFO_JSON;\n\tprivate static final String FIND;\n\tprivate static App mockApp;\n\tprivate static JhoveBase je;\n\tprivate File outputFile;\n\tprivate StringWriter outString;\n\tprivate PrintWriter writer;\n\tprivate JsonHandler handler;\n\n}\n\nclass JsonHandlerTest {\n\n\tprivate static final Logger LOGGER;\n\tprivate static final String TIME_PATTERN;\n\tprivate static final String DATE_PATTERN;\n\tprivate static final String DATE_REPLACEMENT;\n\tprivate static final String RELEASE_PATTERN;\n\tprivate static final String RELEASE_REPLACEMENT;\n\tprivate static final String DIR_PATTERN;\n\tprivate static final String DIR_REPLACEMENT;\n\tprivate static final String CONF_PATTERN;\n\tprivate static final String CONF_REPLACEMENT;\n\tprivate static final String RIGHTS_PATTERN;\n\tprivate static final String RIGHTS_REPLACEMENT;\n\tprivate static final String VENDOR_PATTERN;\n\tprivate static final String VENDOR_REPLACEMENT;\n\tprivate static final String DUMMY;\n\tprivate static final String DUMMY_CK;\n\tprivate static final String APP_JSON;\n\tprivate static final String API_JSON;\n\tprivate static final String HANDLER_JSON;\n\tprivate static final String MODULE_JSON;\n\tprivate static final String INFO_JSON;\n\tprivate static final String FIND;\n\tprivate static App mockApp;\n\tprivate static JhoveBase je;\n\tprivate File outputFile;\n\tprivate StringWriter outString;\n\tprivate PrintWriter writer;\n\tprivate JsonHandler handler;\n\n\t@Test\n\tpublic void testShowArrayString() throws IOException {\n", "reference": "\t\tfinal String[] sArrayTest = { null, \"\", \"DUMMY\" };\n\t\tJsonArrayBuilder b = this.handler.showArray(sArrayTest);\n\n\t\tbuildJson(b);\n        handler.close();\n        \n\t\tString result = outString.toString();\n\t\tLOGGER.info(FIND + result);\n\t\tfinal String expected = \"{\\\"ARRAY\\\":[null,\\\"\\\",\\\"DUMMY\\\"]}\";\n\t\t\n\t    assertEquals(expected, result);\n\t}\n\n}", "prediction": "\t\tString[] sarray = new String[] { \"a\", \"b\", \"c\" };\n\t\tJsonArrayBuilder aBuilder = handler.showArray(sarray);\n\t\tassertEquals(\"[\\\"a\\\",\\\"b\\\",\\\"c\\\"]\", aBuilder.build().toString());\n\t}", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "17898911_105", "part": [1, 1], "seq": [1, 1], "prompt": "class ColumnTypeEditor implements IsWidget,\n                                         org.dashbuilder.dataset.client.editor.ColumnTypeEditor {\n\n    @Override\n    public DropDownImageListEditor<ColumnType> columnType() {\n        return columnType;\n    }\n\n    @Inject public  ColumnTypeEditor(final DropDownImageListEditor<ColumnType> columnType);\n\n    @PostConstruct public void init();\n    @Override public Widget asWidget();\n    public void addHelpContent(final String title,\n                               final String content,\n                               final Placement placement);\n    @Override public void setOriginalColumnType(final ColumnType columnType);\n    @Override public void flush();\n    @Override public void onPropertyChange(final String... paths);\n    @Override public void setValue(final DataColumnDef value);\n    @Override public void setDelegate(final EditorDelegate<DataColumnDef> delegate);\n    private Collection<ImageListEditor<ColumnType>.Entry> getAcceptableEntries(final ColumnType type);\n    protected Collection<ImageListEditor<ColumnType>.Entry> getDefaultEntries();\n    private ImageListEditor<ColumnType>.Entry buildEntry(final ColumnType type);\n     SafeUri getImageUri(final ColumnType type);\n     String getColumnTypeDescription(final ColumnType type);\n    @Override public void isEditMode(final boolean isEdit);\n     void onColumnTypeChanged(@Observes ValueChangeEvent<ColumnType> event);\n\n    @Mock DropDownImageListEditor<ColumnType> columnType;\n    @Mock Widget columnTypeWidget;\n    private ColumnTypeEditor presenter;\n\n}\n\nclass ColumnTypeEditorTest {\n\n    @Mock DropDownImageListEditor<ColumnType> columnType;\n    @Mock Widget columnTypeWidget;\n    private ColumnTypeEditor presenter;\n\n    @Test\n    public void testColumnType() {\n", "reference": "        assertEquals(columnType, presenter.columnType());\n    }\n\n}", "prediction": "        assertEquals(columnType, presenter.columnType());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "18311299_15", "part": [1, 1], "seq": [1, 1], "prompt": "class TableMetadata {\n\n    List<String> getColumnNames(String tableName) throws SQLException {\n        List<String> result = Lists.newArrayList();\n        try (\n                Connection connection = connectionProvider.getConnection();\n                PreparedStatement stmt = connection.prepareStatement(GET_COLUMN_NAMES_QUERY)) {\n            stmt.setString(1, tableName);\n            ResultSet rs = stmt.executeQuery();\n\n            while (rs.next()) {\n                result.add(rs.getString(1));\n            }\n\n            return result;\n        } catch (SQLException sqle) {\n            throw new DataAccessException(COLUMN_NAMES_ERROR + tableName, sqle);\n        }\n    }\n\n      TableMetadata(ConnectionProvider connectionProvider);\n\n    @Mock AbstractConnectionProvider mockedConnectionProvider;\n    @Mock Connection mockedConnection;\n    @Mock PreparedStatement mockedStmt;\n    @Mock ResultSet mockedResultSet;\n     TableMetadata tableMetadata;\n\n}\n\nclass TableMetadataTest {\n\n    @Mock AbstractConnectionProvider mockedConnectionProvider;\n    @Mock Connection mockedConnection;\n    @Mock PreparedStatement mockedStmt;\n    @Mock ResultSet mockedResultSet;\n     TableMetadata tableMetadata;\n\n    @Test(groups = INTEGRATION)\n    public void testGetColumnNamesForExistingTable() throws SQLException {\n", "reference": "        tableMetadata = new TableMetadata(new MysqlConnectionProvider(URL, USERNAME, PASSWORD));\n        List<String> columnNames = tableMetadata.getColumnNames(TEST_TABLE_NAME);\n\n        assertEquals(columnNames.size(), 2);\n        assertTrue(columnNames.contains(\"ID\"));\n        assertTrue(columnNames.contains(\"TXT\"));\n    }\n\n}", "prediction": "        List<String> expected = Lists.newArrayList(\"id\", \"name\");\n        when(mockedResultSet.next()).thenReturn(true, true, false);\n        when(mockedResultSet.getString(1)).thenReturn(\"id\", \"name\");\n        when(mockedStmt.executeQuery()).thenReturn(mockedResultSet);\n        when(mockedConnection.prepareStatement(anyString())).thenReturn(mockedStmt);\n        when(mockedConnectionProvider.getConnection()).thenReturn(mockedConnection);\n\n        List<String> actual = tableMetadata.getColumnNames(\"test\");\n\n        assertEquals(actual, expected);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "18467626_23", "part": [1, 1], "seq": [1, 1], "prompt": "class CPLCUtils {\n\n\tpublic static CPLC parse(byte[] raw) {\n\t\tCPLC ret = null;\n\t\tif (raw != null) {\n\t\t\tbyte[] cplc = null;\n\t\t\t// try to interpret as raw data (not TLV)\n\t\t\tif (raw.length == CPLC.SIZE + 2) {\n\t\t\t\tcplc = raw;\n\t\t\t}\n\t\t\t// or maybe it's prepended with CPLC tag:\n\t\t\telse if (raw.length == CPLC.SIZE + 5) {\n\t\t\t\tcplc = TlvUtil.getValue(raw, CPLC_TAG);\n\t\t\t} else {\n\t\t\t\tLOGGER.error(\"CPLC data not valid\");\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tret = new CPLC();\n\t\t\tret.parse(cplc,null);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tprivate  CPLCUtils();\n\n}\n\nclass CPLCUtilsTest {\n\n\t@Test\n\tpublic void testPrependedCPLC(){\n", "reference": "\t\t// prepended with CPLC tag\n\t\tCPLC cplc = CPLCUtils.parse(BytesUtils.fromString(\"9F 7F 2A 47 90 50 40 47 91 81 02 31 00 83 58 00 11 68 91 45 81 48 12 83 65 00 00 00 00 01 2F 31 30 31 31 36 38 00 00 00 00 00 00 00 00 90 00\"));\t\t\n\t\tAssertions.assertThat(cplc).isNotNull();\n\t\tAssertions.assertThat(cplc.getIcFabricator()).isEqualTo(0x4790);\n\t\tAssertions.assertThat(cplc.getIcType()).isEqualTo(0x5040);\n\t\tAssertions.assertThat(cplc.getOs()).isEqualTo(0x4791);\n\t\tAssertions.assertThat(cplc.getOsReleaseLevel()).isEqualTo(0x3100);\n\t\tAssertions.assertThat(cplc.getIcSerialNumber()).isEqualTo(0x00116891);\n\t\tAssertions.assertThat(cplc.getIcBatchId()).isEqualTo(0x4581);\n\t\tAssertions.assertThat(cplc.getIcModuleFabricator()).isEqualTo(0x4812);\n\t\tAssertions.assertThat(cplc.getIccManufacturer()).isEqualTo(0x0000);\n\t\tAssertions.assertThat(cplc.getIcEmbeddingDate()).isNull();\n\t\tAssertions.assertThat(cplc.getPrepersoId()).isEqualTo(0x012F);\n\t\tAssertions.assertThat(cplc.getPrepersoEquipment()).isEqualTo(0x31313638);\n\t\tAssertions.assertThat(cplc.getPersoId()).isEqualTo(0x0000);\n\t\tAssertions.assertThat(cplc.getPersoEquipment()).isEqualTo(0x0000);\n\t}\n\n}", "prediction": "\t\tbyte[] raw = new byte[] {\n\t\t\t\t(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n\t\t\t\t(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n\t\t\t\t(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n\t\t\t\t(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n\t\t\t\t(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n\t\t\t\t(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n\t\t\t\t(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n\t\t\t\t(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n\t\t\t\t(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n\t\t\t\t(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n\t\t\t\t(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n\t\t\t\t(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n\t\t\t\t(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n\t\t\t\t(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n\t\t\t\t(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n\t\t\t\t(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n\t\t\t\t(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n\t\t\t\t(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n\t\t\t\t(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n\t\t\t\t(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n\t\t\t\t(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n\t\t\t\t(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n\t\t\t\t(byte) 0x", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "18749200_0", "part": [1, 1], "seq": [1, 1], "prompt": "class PID implements Serializable {\n\n  public static PID fromString(String pid) throws IllegalArgumentException {\n    List<String> components = Splitter.on(\"@\").omitEmptyStrings().splitToList(pid);\n    if (components.size() != 2) {\n      throw new IllegalArgumentException(\n          \"Illegal libprocess pid: \" + pid + \". Format is id@host:port.\");\n    }\n    String id = components.get(0);\n    if (CharMatcher.WHITESPACE.matchesAnyOf(id)) {\n      throw new IllegalArgumentException(\"No whitespace allowed in process id.\");\n    }\n    HostAndPort hostAndPort = HostAndPort.fromString(components.get(1))\n        .requireBracketsForIPv6();\n    if (!hostAndPort.hasPort()) {\n      throw new IllegalArgumentException(\"No port specified.\");\n    }\n    return new PID(id, hostAndPort);\n  }\n\n  public  PID(String id, HostAndPort hostAndPort);\n\n  public String getId();\n  public HostAndPort getHostAndPort();\n  public URL getBaseUrl();\n  @Override public String toString();\n  @Override public boolean equals(Object o);\n  @Override public int hashCode();\n\n}\n\nclass PIDTest {\n\n  @Test\n  public void testFromString() throws Exception {\n", "reference": "    PID pid = PID.fromString(\"scheduler@192.168.1.1:8081\");\n    assertEquals(\"scheduler@192.168.1.1:8081\", pid.toString());\n    assertEquals(\"http://192.168.1.1:8081/scheduler\", pid.getBaseUrl().toString());\n  }\n\n}", "prediction": "    PID pid = PID.fromString(\"foo@127.0.0.1:1234\");\n    assertEquals(\"foo\", pid.getId());\n    assertEquals(\"127.0.0.1\", pid.getHostAndPort().getHost());\n    assertEquals(1234, pid.getHostAndPort().getPort());\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "18788616_0", "part": [1, 1], "seq": [1, 1], "prompt": "class Select {\n\n    public Select(Findr findr) {\n        this.findr = findr;\n    }\n\n    public  Select(Findr findr);\n\n    public Findr getFindr();\n    public Select selectByVisibleText(String text);\n    public Select assertSelectedText(String expected);\n    public static Function<WebElement,?> makeSelectByVisibleText(final String text);\n    public static Predicate<WebElement> selectedText(final String expectedText);\n    @Deprecated public static void selectByVisibleText(Findr selectFindr, final String text);\n\n}\n\nclass SelectTest  {\n\n    @Ignore(\"shaky : the page uses iframes and it doesn't seem to be ok\")\n    @Test\n    public void testSelect() {\n", "reference": "        getWebDriver().get(\"http://www.w3schools.com/tags/tryit.asp?filename=tryhtml_select\");\n        getWebDriver().switchTo().frame(\"view\");\n        Findr fSelect = findr().elem(By.tagName(\"select\"));\n        Select select = new Select(fSelect);\n\n        // assert value\n        fSelect.where(Select.selectedText(\"Volvo\")).eval();\n        // change value\n        fSelect.eval(Select.makeSelectByVisibleText(\"Audi\"));\n        // assert value again\n        fSelect.where(Select.selectedText(\"Audi\")).eval();\n\n        // same with instance methods\n        select.assertSelectedText(\"Audi\")\n            .selectByVisibleText(\"Volvo\")\n            .assertSelectedText(\"Volvo\");\n    }\n\n}", "prediction": "        Findr findr = new Findr(new HtmlPage(\"http://www.w3schools.com/tags/tryit.asp?filename=tryhtml_select\"));\n        Select select = new Select(findr);\n        select.selectByVisibleText(\"Option 1\");\n        assertEquals(\"Option 1\", select.getFindr().getSelectedText());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "19730456_168", "part": [1, 1], "seq": [1, 1], "prompt": "class BloomFilter implements Serializable {\n\n    public synchronized boolean getBit(int bit) {\n        return bitset.get(bit);\n    }\n\n    public  BloomFilter(double c, int n, int k);\n    public  BloomFilter(int bitSetSize, int expectedNumberOElements);\n    public  BloomFilter(double falsePositiveProbability, int expectedNumberOfElements);\n    public  BloomFilter(int bitSetSize, int expectedNumberOfFilterElements, int actualNumberOfFilterElements, BitSet filterData);\n\n    @Override public boolean equals(Object obj);\n    @Override public int hashCode();\n    public double expectedFalsePositiveProbability();\n    public double getFalsePositiveProbability(double numberOfElements);\n    public double getFalsePositiveProbability();\n    public int getK();\n    public synchronized void clear();\n    public synchronized void add(byte[] bytes);\n    private int[] createHashes(byte[] bytes, int k);\n    public synchronized boolean contains(byte[] bytes);\n    public synchronized void setBit(int bit, boolean value);\n    public synchronized BitSet getBitSet();\n    public synchronized int size();\n    public synchronized int count();\n    public int getExpectedNumberOfElements();\n    public double getExpectedBitsPerElement();\n    public double getBitsPerElement();\n\n    static Random r;\n\n}\n\nclass BloomFilterTest {\n\n    static Random r;\n\n    @Test\n    public void testGetBit() {\n", "reference": "        System.out.println(\"getBit\");\n        BloomFilter instance = new BloomFilter(1000, 100);\n        Random r = new Random();\n\n        for (int i = 0; i < 100; i++) {\n            boolean b = r.nextBoolean();\n            instance.setBit(i, b);\n            assertSame(instance.getBit(i), b);\n        }\n    }\n\n}", "prediction": "        BloomFilter bf = new BloomFilter(1000, 1000);\n        bf.add(\"test\".getBytes());\n        assertTrue(bf.getBit(1));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "19980663_4", "part": [1, 1], "seq": [1, 1], "prompt": "class TableManagerResource {\n\n    @GET\n    @Timed\n    @Path(\"/{name}\")\n    @ApiOperation(\"Get Table\")\n    public Response get(@PathParam(\"name\") String name) {\n        name = ElasticsearchUtils.getValidTableName(name);\n        Table table = tableManager.get(name);\n        return Response.ok()\n                .entity(table)\n                .build();\n    }\n\n    @Inject public  TableManagerResource(TableManager tableManager);\n\n    @POST @Timed @ApiOperation(\"Save Table\") public Response save(@Valid final Table table, @QueryParam(\"forceCreate\") @DefaultValue(\"false\") boolean forceCreate);\n    @PUT @Timed @Path(\"/{name}\") @ApiOperation(\"Update Table\") public Response get(@PathParam(\"name\") final String name, @Valid final Table table);\n    @DELETE @Timed @Path(\"/{name}/delete\") @ApiOperation(\"Delete Table\") public Response delete(@PathParam(\"name\") String name);\n    @GET @Timed @ApiOperation(\"Get all Tables\") public Response getAll();\n\n    @Rule\n    public ResourceTestRule resources;\n    private TableManager tableManager;\n\n}\n\nclass TableManagerResourceTest  {\n\n    @Rule\n    public ResourceTestRule resources;\n    private TableManager tableManager;\n\n    @Test\n    public void testGet() throws Exception {\n", "reference": "        doNothing().when(getDataStore())\n                .initializeTable(any(Table.class), anyBoolean());\n        doNothing().when(getQueryStore())\n                .initializeTable(any(String.class));\n\n\n        Table response = resources.client()\n                .target(String.format(\"/v1/tables/%s\", TEST_TABLE_NAME))\n                .request()\n                .get(Table.class);\n        assertNotNull(response);\n        assertEquals(TEST_TABLE_NAME, response.getName());\n        assertEquals(7, response.getTtl());\n    }\n\n}", "prediction": "        Table table = new Table();\n        table.setName(\"test\");\n        tableManager.save(table);\n        Response response = resources.client().target(\"/table/test\").request().get();\n        assertEquals(200, response.getStatus());\n        Table table2 = response.readEntity(Table.class);\n        assertEquals(table.getName(), table2.getName());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "20043683_8", "part": [1, 1], "seq": [1, 1], "prompt": "class JaxbLoader {\n\n    public static MMOs loadXml(final File xmlFile)\n            throws JAXBException, SAXException, ParserConfigurationException, FileNotFoundException {\n        final JAXBContext jaxbContext = JAXBContext.newInstance(MMOs.class);\n        final Unmarshaller jaxbUnmarshaller = jaxbContext.createUnmarshaller();\n\n        // avoid getting the DTD (was mainly for when demoing without a network, but should maybe be kept?)\n        final SAXParserFactory spf = SAXParserFactory.newInstance();\n        spf.setFeature(\"http://apache.org/xml/features/validation/schema\", false);\n        spf.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n        final XMLReader xmlReader = spf.newSAXParser().getXMLReader();\n        final InputSource inputSource = new InputSource(new FileReader(xmlFile));\n        final SAXSource source = new SAXSource(xmlReader, inputSource);\n\n        return (MMOs) jaxbUnmarshaller.unmarshal(source);\n    }\n\n    private static final File TEST_XML;\n\n}\n\nclass JaxbLoaderTest {\n\n    private static final File TEST_XML;\n\n    @Test\n    public void failToLoad() {\n", "reference": "        //noinspection OverlyBroadCatchBlock\n        try {\n            JaxbLoader.loadXml(new File(\"noSuchFile\"));\n            fail(\"We should have had an exception before now.\");\n        }\n        catch (final FileNotFoundException ignored) {\n            // do nothing\n        }\n        catch (final Throwable t) {\n            //noinspection CallToPrintStackTrace\n            t.printStackTrace();\n            fail(\"There should be no other throwables.\");\n        }\n    }\n\n}", "prediction": "        try {\n             JaxbLoader.loadXml(TEST_XML);\n            fail(\"Should have failed to load\");\n        } catch (final JAXBException e) {\n            assertThat(e.getMessage(), containsString(\"cvc-elt.1: Cannot find the declaration of element 'mmos'\"));\n        }\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "20126854_34", "part": [1, 1], "seq": [1, 1], "prompt": "class BsPatch {\n\n  public static void applyPatch(\n      RandomAccessFile oldData, OutputStream newData, InputStream patchData)\n      throws PatchFormatException, IOException {\n    patchData = new BufferedInputStream(patchData, PATCH_STREAM_BUFFER_SIZE);\n    newData = new BufferedOutputStream(newData, OUTPUT_STREAM_BUFFER_SIZE);\n    try {\n      applyPatchInternal(oldData, newData, patchData);\n    } finally {\n      newData.flush();\n    }\n  }\n\n  private static void applyPatchInternal(\n      final RandomAccessFile oldData,\n      final OutputStream newData,\n      final InputStream patchData);\n  static void transformBytes(\n      final int diffLength,\n      final InputStream patchData,\n      final RandomAccessFile oldData,\n      final OutputStream newData,\n      final byte[] buffer1,\n      final byte[] buffer2);\n  static final long readBsdiffLong(InputStream in);\n  static void readFully(\n      final InputStream in, final byte[] destination, final int startAt, final int numBytes);\n  static void pipe(\n      final InputStream in, final OutputStream out, final byte[] buffer, int copyLength);\n\n  private static final String SIGNATURE;\n  private byte[] buffer1;\n  private byte[] buffer2;\n  private File oldFile;\n\n}\n\nclass BsPatchTest {\n\n  private static final String SIGNATURE;\n  private byte[] buffer1;\n  private byte[] buffer2;\n  private File oldFile;\n\n  @Test\n  public void testApplyPatch_NewLengthTooLarge() throws Exception {\n", "reference": "    createEmptyOldFile(10);\n    InputStream patchIn =\n        makePatch(\n            SIGNATURE,\n            Integer.MAX_VALUE + 1, // newLength (max supported is Integer.MAX_VALUE)\n            10, // diffSegmentLength\n            0, // copySegmentLength\n            0, // offsetToNextInput\n            new byte[10] // addends\n            );\n    ByteArrayOutputStream newData = new ByteArrayOutputStream();\n    try {\n      BsPatch.applyPatch(\n          new RandomAccessFile(oldFile, \"r\"), newData, patchIn);\n      Assert.fail(\"Read patch with excessive newLength\");\n    } catch (PatchFormatException expected) {\n      // No way to mock the internal logic, so resort to testing exception string for coverage\n      String actual = expected.getMessage();\n      Assert.assertEquals(\"bad newSize\", actual);\n    }\n  }\n\n}", "prediction": "    final File newFile = File.createTempFile(\"new\", \".bin\");\n    newFile.deleteOnExit();\n    final File patchFile = File.createTempFile(\"patch\", \".bin\");\n    patchFile.deleteOnExit();\n    final FileOutputStream patchOut = new FileOutputStream(patchFile);\n    final byte[] patchData = new byte[1024];\n    final Random random = new Random();\n    random.nextBytes(patchData);\n    patchOut.write(patchData);\n    patchOut.close();\n    final RandomAccessFile oldData = new RandomAccessFile(oldFile, \"r\");\n    try {\n      BsPatch.applyPatch(oldData, new FileOutputStream(newFile), new FileInputStream(patchFile));\n      fail();\n    } catch (final PatchFormatException expected) {\n    }\n  }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "20498194_7", "part": [1, 1], "seq": [1, 1], "prompt": "class PigResource {\n\n\t@GET\n\t@Path(\"request/{requestId}/status\")\n\t@Produces( {MediaType.TEXT_PLAIN} )\n\tpublic Response getRequestStatus(@PathParam(\"requestId\") String requestId) throws IOException {\n\t\tlogger.info(\"Request for retrieving status for \" + requestId);\n\t\treturn Response.ok()\n\t\t    .entity(\n\t\t        PigJobServerImpl.getPigJobServer().getRequestStatus(requestId)\n\t\t    ).build();\n\t}\n\n\t@POST @Path(\"/jar/{jarName}\") @Consumes ( {MediaType.APPLICATION_OCTET_STREAM} ) @Produces ({MediaType.APPLICATION_JSON, MediaType.TEXT_PLAIN}) public Response registerJar(@PathParam(\"jarName\") String jarName, InputStream uploadedJar);\n\t@DELETE @Path(\"/jar/{jarName}\") @Produces ( {MediaType.TEXT_PLAIN} ) public Response unregisterJar(@PathParam(\"jarName\") String jarName);\n\t@GET @Path(\"/jar/{jarName}\") @Produces ( {MediaType.APPLICATION_OCTET_STREAM} ) public Response getRegisteredJar(@PathParam(\"jarName\") String jarName);\n\t@POST @Path(\"/script/{scriptName}\") @Consumes ( {MediaType.APPLICATION_OCTET_STREAM} ) @Produces ({MediaType.APPLICATION_JSON, MediaType.TEXT_PLAIN}) public Response registerScript(@PathParam(\"scriptName\") String scriptName, InputStream uploadedScript);\n\t@DELETE @Path(\"/script/{scriptName}\") @Produces ( {MediaType.TEXT_PLAIN} ) public Response unregisterScript(@PathParam(\"scriptName\") String scriptName);\n\t@GET @Path(\"/script/{scriptName}\") @Produces ( {MediaType.APPLICATION_OCTET_STREAM} ) public Response getRegisteredScript(@PathParam(\"scriptName\") String scriptName);\n\t@POST @Path(\"/request/{scriptName}\") @Consumes( {MediaType.APPLICATION_JSON} ) @Produces( {MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML, MediaType.TEXT_PLAIN} ) public Response submitPigJob(@PathParam(\"scriptName\") String scriptName, String data);\n\t@GET @Path(\"/request/{requestId}\") @Produces( {MediaType.APPLICATION_JSON} ) public Response getInput(@PathParam(\"requestId\") String requestId);\n\t@GET @Path(\"/request/{requestId}/stats\") @Produces( {MediaType.APPLICATION_JSON} ) public Response getRequestStats(@PathParam(\"requestId\") String requestId);\n\t@GET @Path(\"/request/{requestId}/output\") @Produces( {MediaType.TEXT_PLAIN} ) public Response getOutput(@PathParam(\"requestId\") String requestId);\n\t@GET @Path(\"request/{requestId}/cancel\") @Produces( {MediaType.TEXT_PLAIN} ) public Response cancelRequest(@PathParam(\"requestId\") String requestId);\n\n    private static final String HADOOP_TMP_PATH;\n    private Configuration conf;\n    private FileSystem fileSystem;\n\n}\n\nclass TestPigResource {\n\n    private static final String HADOOP_TMP_PATH;\n    private Configuration conf;\n    private FileSystem fileSystem;\n\n    @Test \n    public void testGetStatus() throws Exception {\n", "reference": "    \tPigResource resource= new PigResource();\n    \tPigRequestStats stats= new PigRequestStats(15, 14, null, 5);\n    \tstats.setStatus(\"STATUS\");\n    \t\n    \tString requestId= UUID.randomUUID().toString();\n    \tString path= PropertyLoader.getInstance().getProperty(\"requests.basepath\") + requestId \n    \t\t\t+ \"/stats\";\n    \t\n    \tPigUtils.writeStatsFile(new Path(path), stats);\n    \tResponse resp=  resource.getRequestStatus(requestId);\n    \tAssert.assertEquals(resp.getStatus(), 200);\n    \t\n    \trequestId= \"abc\";\n    \ttry {\n    \t\tresp=  resource.getRequestStatus(requestId);\n    \t} catch (Exception e) {\n    \t\tAssert.assertNotNull(resp);\n    \t}\n    \t\n    \trequestId= UUID.randomUUID().toString();\n    \tfileSystem.mkdirs(new Path(PropertyLoader.getInstance().getProperty(\"requests.basepath\") + requestId));\n    \ttry {\n    \t\tresp=  resource.getRequestStatus(requestId);\n    \t} catch (Exception e) {\n    \t\tAssert.assertNotNull(e);\n    \t}\n    }\n\n}", "prediction": "        PigJobServerImpl.getPigJobServer().registerJar(\"test.jar\", new ByteArrayInputStream(\"test\".getBytes()));\n        String requestId = PigJobServerImpl.getPigJobServer().submitPigJob(\"test.jar\", \"test\");\n        assertEquals(PigJobServerImpl.getPigJobServer().getRequestStatus(requestId), \"RUNNING\");\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "20521495_26", "part": [1, 1], "seq": [1, 1], "prompt": "class SolrOperationsService {\n\n    public void createCore(StratioStreamingMessage message) throws IOException, URISyntaxException, SolrServerException, ParserConfigurationException, SAXException, TransformerException, InterruptedException {\n        String core = message.getStreamName();\n        String dataPath = this.dataDir + '/' + core + \"/data\";\n        String confPath = this.dataDir + '/' + core + \"/conf\";\n        createDirs(dataPath, confPath);\n        createSolrConfig(confPath);\n        createSolrSchema(message.getColumns(), confPath);\n        SolrClient solrClient = getSolrclient(core);\n        CoreAdminRequest.Create createCore = new CoreAdminRequest.Create();\n        createCore.setDataDir(dataPath);\n        createCore.setInstanceDir(dataDir + '/' + core);\n        createCore.setCoreName(core);\n        createCore.setSchemaName(\"schema.xml\");\n        createCore.setConfigName(\"solrconfig.xml\");\n        if (solrClient instanceof CloudSolrClient) {\n            ((CloudSolrClient)solrClient).uploadConfig(Paths.get(confPath), core);\n        }\n        solrClient.request(createCore);\n    }\n\n    public  SolrOperationsService(String solrHosts, String zkHosts, String dataDir, Boolean isCloud);\n\n    public void createDirs(String dataPath, String confPath);\n    public void createSolrConfig(String confPath);\n    public void createSolrSchema(List<ColumnNameTypeValue> columns, String confpath);\n    private String streamingToSolr(ColumnType column);\n    public List<String> getCoreList();\n    private SolrClient getSolrclient(String core);\n\n    private static final Logger LOGGER;\n    private SolrOperationsService service;\n    private static final String HOSTS;\n    private static final Boolean IS_CLOUD;\n    @Rule\n    public TemporaryFolder DATA_FOLDER;\n    @Rule\n    public TemporaryFolder CONF_FOLDER;\n\n}\n\nclass SolrOperationsServiceTest {\n\n    private static final Logger LOGGER;\n    private SolrOperationsService service;\n    private static final String HOSTS;\n    private static final Boolean IS_CLOUD;\n    @Rule\n    public TemporaryFolder DATA_FOLDER;\n    @Rule\n    public TemporaryFolder CONF_FOLDER;\n\n    @Test\n    @Ignore\n    public void testCreateCore() throws Exception {\n", "reference": "\n        StratioStreamingMessage message= new StratioStreamingMessage(\n                    StreamsHelper.STREAM_NAME, Long.parseLong(\"1234567890\"), StreamsHelper.COLUMNS);\n            service.createCore(message);\n    }\n\n}", "prediction": "        service.createCore(new StratioStreamingMessage(\"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "20551894_10", "part": [1, 1], "seq": [1, 1], "prompt": "class CDAHelper {\n\n\tpublic static   II buildTemplateID(String root , String extension ,String assigningAuthorityName)\n\t{\n\n\t\t\tII templateID = DatatypesFactory.eINSTANCE.createII();\n\t\t\tif(root!=null)\n\t\t\t{\n\t\t\ttemplateID.setRoot(root);\n\t\t\t}\n\t\t\tif(extension!=null)\n\t\t\t{\n\t\t\ttemplateID.setExtension(extension);\n\t\t\t}\n\t\t\tif(assigningAuthorityName!=null)\n\t\t\t{\n\t\t\ttemplateID.setAssigningAuthorityName(assigningAuthorityName);\n\t\t\t}\n\t\t\t\n\t\t\treturn templateID;\n\n\t}\n\n\tpublic static SimpleDateFormat getDateFormat();\n\tpublic static IVL_TS buildEffectiveTimeinIVL(Date d , Date d1);\n\tpublic static IVL_TS buildEffectiveTimeinIVL(Date d);\n\tpublic static ST buildTitle(String title);\n\tpublic static II buildID(String root , String extension);\n\tpublic static CE buildCodeCE(String code , String codeSystem, String displayString, String codeSystemName);\n\tpublic static CD buildCodeCD(String code , String codeSystem, String displayString, String codeSystemName);\n\tpublic static TS buildEffectiveTime(Date d);\n\tpublic static ED buildEDText(String value);\n\tpublic static String getDatatypesValue(Integer datatypeId,Obs obs);\n\tpublic static Obs getLatestObs(List<Obs> observationList);\n\tpublic static CS getStatusCode(String statusCode);\n\tpublic static IVL_TS buildDateTime(Date date);\n\tpublic static String getCodeSystemByName(String codeSystemName);\n\tpublic static String removeDirtyValue(String input);\n\tpublic static String getUnitsaccordingto_Tf_PCC(String unit);\n\tpublic static String getConceptIdasString(int conceptId);\n\n}\n\nclass CDAHelperTest  {\n\n\t@Test\n\tpublic void shouldCreateTemplateIDIfParametersareNull()\n\t{\n", "reference": "\t\tII templateid=CDAHelper.buildTemplateID(null, null, null);\n\t\t\n\t\tString root=templateid.getRoot();\n\t\tString extension=templateid.getExtension();\n\t\tString authority=templateid.getAssigningAuthorityName();\n\t\t\n\t\tAssert.assertEquals(root, null);\n\t\tAssert.assertEquals(extension, null);\n\t\tAssert.assertEquals(authority, null);\n\t}\n\n}", "prediction": "\t\tII templateID = CDAHelper.buildTemplateID(null, null, null);\n\t\tassertNull(templateID.getRoot());\n\t\tassertNull(templateID.getExtension());\n\t\tassertNull(templateID.getAssigningAuthorityName());\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "20570214_46", "part": [1, 1], "seq": [1, 1], "prompt": "class JwtValidator {\n\n  Jwt validate(String algorithm, ToBeSignedJwt target)\n      throws InvalidAlgorithmParameterException, JwtExpiredException, JwtNotBeforeException,\n          JwtInvalidException {\n    validateTimestampClaims(target);\n\n    if (!target.getAlgorithm().equals(algorithm)) {\n      throw new InvalidAlgorithmParameterException(\n          String.format(\n              \"invalid algorithm; expected %s, got %s\", algorithm, target.getAlgorithm()));\n    }\n\n    @SuppressWarnings(\"unchecked\") // keys() returns Iterator, not Iterator<String>\n    Iterator<String> headerIterator = this.header.keys();\n    while (headerIterator.hasNext()) {\n      String name = headerIterator.next();\n      if (name.equals(JwtNames.HEADER_ALGORITHM)) {\n        continue;\n      }\n      String value = target.getHeader(name);\n      if (value == null || !value.equals(this.getHeader(name))) {\n        throw new JwtInvalidException(\n            String.format(\n                \"invalid JWT; expected header '%s' with value %s, but got %s\",\n                name, value, this.getHeader(name)));\n      }\n    }\n\n    @SuppressWarnings(\"unchecked\") // keys() returns Iterator, not Iterator<String>\n    Iterator<String> payloadIterator = this.payload.keys();\n    while (payloadIterator.hasNext()) {\n      String name = payloadIterator.next();\n      if (name.equals(JwtNames.CLAIM_AUDIENCE)) {\n        // This is checked below.\n        continue;\n      }\n      Object value = target.getClaim(name);\n      if (value == null || !value.equals(this.getClaim(name))) {\n        throw new JwtInvalidException(\n            String.format(\n                \"invalid JWT; expected claim '%s' with value %s, but got %s\",\n                name, value, this.getClaim(name)));\n      }\n    }\n\n    // Check that the validator's audience is in the list of claimed audiences.\n    List<String> audiences = target.getAudiences();\n    String audience = (String) this.getClaim(JwtNames.CLAIM_AUDIENCE);\n    if ((audiences == null && audience != null)\n        || (audiences != null && !audiences.contains(audience))) {\n      throw new JwtInvalidException(\n          String.format(\n              \"invalid JWT; cannot find the expected audience %s in claimed audiences %s\",\n              audience, audiences));\n    }\n\n    return new Jwt(target.getHeader(), target.getPayload(), this.clock, this.clockSkew);\n  }\n\n  private  JwtValidator(Builder builder);\n\n  private String getHeader(String name);\n  private Object getClaim(String name);\n   Clock getClock();\n   Duration getClockSkew();\n  private void validateTimestampClaims(ToBeSignedJwt target);\n\n}\n\nclass JwtValidatorTest {\n\n  @Test\n  public void validate_notExpired_success() throws Exception {\n", "reference": "    String algo = \"HS256\";\n    Clock clock = Clock.systemUTC();\n    // This token expires in 1 minute in the future.\n    Instant expiration = clock.instant().plus(Duration.ofMinutes(1));\n    ToBeSignedJwt unverified =\n        new ToBeSignedJwt.Builder().setAlgorithm(algo).setExpiration(expiration).build();\n    JwtValidator validator = new JwtValidator.Builder().build();\n    Jwt token = validator.validate(algo, unverified);\n\n    assertThat(token.getExpiration().getEpochSecond()).isEqualTo(expiration.getEpochSecond());\n  }\n\n}", "prediction": "    JwtValidator validator =\n        new JwtValidator.Builder()\n            .setIssuer(\"issuer\")\n            .setAudience(\"audience\")\n            .setExpiration(Duration.ofMinutes(1))\n            .build();\n\n    Jwt jwt =\n        validator.validate(\n            \"HS256\",\n            new ToBeSignedJwt.Builder()\n                .setIssuer(\"issuer\")\n                .setAudience(\"audience\")\n                .setExpiration(Duration.ofMinutes(1))\n                .build());\n\n    assertThat(jwt.getIssuer()).isEqualTo(\"issuer\");\n    assertThat(jwt.getAudiences()).containsExactly(\"audience\");\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "21187043_1", "part": [1, 1], "seq": [1, 1], "prompt": "class Helper {\n\n    public void validate(List<VersionModule> modules) {\n        if (modules == null || modules.isEmpty()) {\n            throw new IllegalArgumentException(\"No modules found.\");\n        }\n        for (VersionModule module : modules) {\n            if (!Utils.hasAnnotatedMethods(module.getClass(), VersionCode.class)) {\n                throw new IllegalArgumentException(\"No annotated method found.\");\n            }\n        }\n    }\n\n      Helper(Application application);\n\n    public void execute(int baseVersion, List<VersionModule> modules);\n     void execute(int baseVersion, VersionModule module, List<Method> methods);\n\n    private Helper mHelper;\n\n}\n\nclass HelperTest {\n\n    private Helper mHelper;\n\n    @Test(expected = IllegalArgumentException.class)\n    public void validationFailure_null() throws Exception {\n", "reference": "        mHelper.validate(null);\n    }\n\n}", "prediction": "        mHelper.validate(null);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "21267129_1", "part": [1, 1], "seq": [1, 1], "prompt": "class RandomStringUtils {\n\n    public static String random(int length) {\n        return new RandomStringGenerator.Builder()\n                .filteredBy(NUMBERS, LETTERS)\n                .build().generate(length);\n    }\n\n    private  RandomStringUtils();\n\n    public static String randomLetters(int length);\n    public static String randomNumeric(int length);\n\n    @SuppressWarnings(\"unused\")\n    private final static Logger LOGGER;\n\n}\n\nclass RandomStringUtilsTest {\n\n    @SuppressWarnings(\"unused\")\n    private final static Logger LOGGER;\n\n    @Test\n    public void testRandom() {\n", "reference": "        for (int length = 1; length < 10; length++) {\n            String value = RandomStringUtils.random(length);\n            //LOGGER.debug( \"random alphanumeric string: \" + value );\n\n            Assert.assertEquals(\n                    \"random string has a length of \" + length,\n                    length, value.length());\n\n            Assert.assertTrue(\n                    \"random string is alphanumeric\",\n                    isAsciiAlphanumeric(value));\n        }\n    }\n\n}", "prediction": "        RandomStringUtils.random(10);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "21427154_1", "part": [1, 1], "seq": [1, 1], "prompt": "class ManagementClient implements Closeable {\n\n    static String formatIP(String ip) {\n        //it appears some system can return a binding with the zone specifier on the end\n        if (ip.contains(\":\") && ip.contains(\"%\")) {\n            ip = ip.split(\"%\")[0];\n        }\n        if (ip.equals(\"0.0.0.0\")) {\n            logger.debug(\"WildFly is bound to 0.0.0.0 which is correct, setting client to 127.0.0.1\");\n            ip = \"127.0.0.1\";\n        }\n        return ip;\n    }\n\n    public  ManagementClient(ModelControllerClient client, final String mgmtAddress, final int managementPort, final String protocol);\n    public  ManagementClient(ModelControllerClient client, final CommonContainerConfiguration config);\n\n    public ModelControllerClient getControllerClient();\n     void reset();\n    private void init();\n    public URI getWebUri();\n    public ProtocolMetaData getProtocolMetaData(String deploymentName);\n    public boolean isServerInRunningState();\n    public boolean isClosed();\n    @Override public void close();\n    private static ModelNode defined(final ModelNode node, final String message);\n    private URI getBinding(final String protocol, final String socketBinding);\n    private boolean isEnterpriseArchive(String deploymentName);\n    private boolean isWebArchive(String deploymentName);\n    private void extractEnterpriseArchiveContexts(HTTPContext context, ModelNode deploymentNode);\n    private void extractWebArchiveContexts(HTTPContext context, ModelNode deploymentNode);\n    private String toContextName(String deploymentName);\n    private ModelNode executeForResult(final ModelNode operation);\n    private ModelNode readDeploymentNode(final String deploymentName);\n    private void checkSuccessful(final ModelNode result,\n                                 final ModelNode operation);\n    private MBeanServerConnection getConnection();\n    public JMXServiceURL getRemoteJMXURL();\n    public int getMgmtPort();\n    public String getMgmtAddress();\n    public String getMgmtProtocol();\n    public URI getRemoteEjbURL();\n    private void checkState();\n\n}\n\nclass ManagementClientTest {\n\n    @Test\n    public void shouldParseLocalIPAsNormalIP() {\n", "reference": "        String sourceIp = \"10.1.2.3\";\n        String formattedIp = ManagementClient.formatIP(sourceIp);\n        Assert.assertEquals(sourceIp, formattedIp);\n    }\n\n}", "prediction": "        //given\n        ManagementClient client = ManagementClient.onlineStandalone(\n                new ModelControllerClientConfiguration.Builder()\n                        .setHost(\"127.0.0.1\")\n                        .setPort(9990)\n                        .setProtocol(\"http-remoting\")\n                        .build());\n\n        //when\n        String ip = client.getMgmtAddress();\n\n        //then\n        assertThat(ip).isEqualTo(\"127.0.0.1\");\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "21859706_0", "part": [1, 1], "seq": [1, 1], "prompt": "class MemcachedResponseStore extends ResponseStore {\n\n    @Override\n    public void invalidate(String key) {\n        checkNotNull(key);\n        checkArgument(key.length() > 0, \"key can not be empty\");\n\n        if (!_readOnly) {\n            _client.delete(buildKey(key));\n        }\n    }\n\n    public  MemcachedResponseStore(MemcachedClient client, String keyPrefix, boolean readOnly);\n\n    @Override public Optional<CachedResponse> get(String key);\n    @Override public void put(String key, CachedResponse response);\n    private String buildKey(String key);\n\n}\n\nclass MemcachedResponseStoreTest {\n\n    @Test(dataProvider = \"invalidateData\")\n    public void invalidate(String prefix, boolean readOnly, String key, String memcacheKey) {\n", "reference": "        MemcachedClient client = mock(MemcachedClient.class);\n        MemcachedResponseStore store = new MemcachedResponseStore(client, prefix, readOnly);\n        store.invalidate(key);\n\n        if (!readOnly) {\n            verify(client).delete(memcacheKey);\n        }\n\n        verifyNoMoreInteractions(client);\n    }\n\n}", "prediction": "        MemcachedClient client = mock(MemcachedClient.class);\n        MemcachedResponseStore store = new MemcachedResponseStore(client, prefix, readOnly);\n        store.invalidate(key);\n        verify(client).delete(memcacheKey);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "22256861_268", "part": [1, 1], "seq": [1, 1], "prompt": "class LandsatTypeInfo {\n\n    static boolean isLandsat5Legacy(String fileName) {\n        return LandsatType.LANDSAT5_LEGACY.matchesFileNamepattern(fileName);\n    }\n\n    private  LandsatTypeInfo();\n\n    public static boolean isLandsat(String fileName);\n    public static boolean isLandsatL2(String fileName);\n    static boolean isLandsatCollection(String fileName);\n    static boolean isESALandsatCollection(String fileName);\n    static boolean isMss(String fileName);\n    static boolean isLandsat4(String fileName);\n    static boolean isLandsat5(String fileName);\n    static boolean isLandsat7Legacy(String fileName);\n    static boolean isLandsat7(String fileName);\n    static boolean isLandsat8(String fileName);\n    public static boolean isLandsatLevel2(String fileName);\n    private static String getCompressionExtension();\n    private static String getTxtExtension();\n    private static String getXmlExtension();\n\n}\n\nclass LandsatTypeInfoTest {\n\n    @Test\n    public void testIsLandsat5LegacyFilename() throws Exception {\n", "reference": "        assertTrue(LandsatTypeInfo.isLandsat5Legacy(\"LT51960300302003GSI01_MTL.txt\")); //according to specification\n        assertTrue(LandsatTypeInfo.isLandsat5Legacy(\"LT51960300302003GSI01_MTL.TXT\"));\n\n        assertTrue(LandsatTypeInfo.isLandsat5Legacy(\"L5196030_03020031023_MTL.txt\")); //according to real-world data\n        assertTrue(LandsatTypeInfo.isLandsat5Legacy(\"L5196030_03020031023_MTL.TXT\"));\n\n        assertTrue(LandsatTypeInfo.isLandsat5Legacy(\"LT51960302003296MTI01.tar.gz\"));\n\n        assertFalse(LandsatTypeInfo.isLandsat5Legacy(\"L51950302003257MTI01.tar.gz\"));  // Sensor type missing\n        assertFalse(LandsatTypeInfo.isLandsat5Legacy(\"LT72160332013191LGN00.tar.gz\")); // '5' expected after 'LT'\n        assertFalse(LandsatTypeInfo.isLandsat5Legacy(\"LT82160332013191LGN00.tgz\")); // 'tar.gz' or 'txt' expected as extension\n        assertFalse(LandsatTypeInfo.isLandsat5Legacy(\"LT82160332013191LGN00.dat\")); // 'tar.gz' or 'txt' expected as extension\n    }\n\n}", "prediction": "        assertTrue(LandsatTypeInfo.isLandsat5Legacy(\"LC08_L1TP_013032_20140318_20170318_01_RT.tar\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "22430702_6", "part": [1, 1], "seq": [1, 1], "prompt": "class VertexListStreamWriter implements AutoCloseable {\n\n\tpublic void writeAll() throws IOException {\n\t\twhile (inputStream.hasNextVertex()) {\n\t\t\twriteNextVertex();\n\t\t}\n\t\toutputWriter.flush();\n\t}\n\n\tpublic  VertexListStreamWriter(VertexListStream inputStream, OutputStream outputStream);\n\n\tprivate void writeNextVertex();\n\t@Override public void close();\n\n\tprivate static final VertexListStream.VertexData[] vertices;\n\tprivate static final String expectedOutput;\n\n}\n\nclass VertexListStreamWriterTest {\n\n\tprivate static final VertexListStream.VertexData[] vertices;\n\tprivate static final String expectedOutput;\n\n\t@Test\n\tpublic void testWriteAllOnMockVertexListStream() throws IOException {\n", "reference": "\t\tVertexListStream vertexListStream = new MockVertexListStream(vertices);\n\t\tByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n\n\t\ttry (VertexListStreamWriter writer = new VertexListStreamWriter(vertexListStream, outputStream)) {\n\t\t\twriter.writeAll();\n\t\t\tassertEquals(\"Output of VertexListStreamWriter is correct\", expectedOutput, outputStream.toString());\n\t\t}\n\t}\n\n}", "prediction": "\t\tVertexListStream inputStream = new VertexListStream(vertices);\n\t\tByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n\t\tVertexListStreamWriter writer = new VertexListStreamWriter(inputStream, outputStream);\n\t\twriter.writeAll();\n\t\tassertEquals(expectedOutput, outputStream.toString());\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "22441114_3", "part": [1, 1], "seq": [1, 1], "prompt": "class Aether {\n\n    protected AetherResult resolveWithTransitives(Artifact artifact) throws AetherException {\n        try {\n            CollectRequest collectRequest = new CollectRequest(\n                    new Dependency(artifact, scope),\n                    repositories()\n            );\n\n            DependencyRequest request = new DependencyRequest(collectRequest, null);\n            return new AetherResult(system.resolveDependencies(session, request).getArtifactResults());\n        } catch (DependencyResolutionException e) {\n            throw new AetherException(\"Can't resolve given artifact \" + artifact, e);\n        }\n    }\n\n      Aether(File localRepoDir, Settings settings);\n      Aether(RepositorySystem system, RepositorySystemSession session, List<RemoteRepository> repositories);\n\n    public static Aether aether(File localRepoDir);\n    public static Aether aether(File localRepoDir, Settings settings);\n    public static Aether aether(Settings settings);\n    public static Aether aether(RepositorySystem system, RepositorySystemSession session, List<RemoteRepository> repositories);\n    public Aether scope(String scope);\n    public AetherResult resolve(String artifactCoordinates);\n    public AetherResult resolve(Artifact artifact);\n    public AetherResult resolve(String artifactCoordinates, boolean withTransitives);\n    public AetherResult resolve(Artifact artifact, boolean withTransitives);\n    public AetherResult resolveAll(String... artifactsCoordinates);\n    public AetherResult resolveAll(Artifact... artifacts);\n    protected AetherResult resolveWithoutTransitives(Artifact... artifacts);\n    protected List<ArtifactRequest> buildArtifactRequests(Artifact... artifacts);\n    public List<Artifact> collect(String artifactCoordinates);\n    public List<Artifact> collect(Artifact artifact);\n    public void install(File jar, String groupId, String artifactId, String version);\n    public void install(File jar, String groupId, String artifactId, String extension, String version);\n    public void install(File jar, String groupId, String artifactId, String classifier, String extension, String version);\n    public void install(File jar, File pom, String groupId, String artifactId, String classifier, String extension, String version);\n    public void install(Artifact... artifacts);\n    public void deploy(DistributionManagement distribution, File jar, String groupId, String artifactId, String version);\n    public void deploy(DistributionManagement distribution, File jar, String groupId, String artifactId,\n                       String extension, String version);\n    public void deploy(DistributionManagement distribution, File jar, String groupId, String artifactId,\n                       String classifier, String extension, String version);\n    public void deploy(DistributionManagement distribution, File jar, File pom, String groupId, String artifactId,\n                       String classifier, String extension, String version);\n    public void deploy(DistributionManagement distribution, Artifact... artifacts);\n    protected File createPomFile(String groupId, String artifactId, String version);\n    protected List<RemoteRepository> repositories();\n\n}\n\nclass AetherTest  {\n\n    @Test\n    public void resolveWithTransitivesTest() throws Exception {\n", "reference": "        List<ArtifactResult> results = aether(localRepo, mavenSettings)\n                .resolve(ALLURE_MODEL).get();\n\n        assertThat(results.size(), is(5));\n    }\n\n}", "prediction": "        Aether aether = Aether.aether(new File(\"target/local-repo\"));\n        AetherResult result = aether.resolve(\"org.apache.maven:maven-core:2.2.1\");\n        assertThat(result.artifacts()).hasSize(1);\n        assertThat(result.artifacts()).contains(new Artifact(\"org.apache.maven\", \"maven-core\", \"2.2.1\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "22460817_0", "part": [1, 1], "seq": [1, 1], "prompt": "class Str {\n\n    public static String trim(String s) {\n        if (s == null)\n            return null;\n        s = s.trim();\n        return s.length() > 0 ? s : null;\n    }\n\n    public static String group(String text, String regexp);\n    public static String group(String text, String regexp, int group);\n    public static Pair<String, String> groups(String text, String regexp, int group1, int group2);\n    public static boolean containsSpaces(String ... strings);\n    public static String lower(String s);\n    public static String upper(String s);\n\n}\n\nclass StrTest {\n\n    @Test\n    public void trim() {\n", "reference": "        assertNull(Str.trim(null));\n        assertNull(Str.trim(\"\"));\n        assertNull(Str.trim(\" \"));\n        assertNull(Str.trim(\" \\t\\n \"));\n        assertNotNull(Str.trim(\".\"));\n        assertNotNull(Str.trim(\" . \"));\n    }\n\n}", "prediction": "        assertEquals(null, Str.trim(null));\n        assertEquals(\"\", Str.trim(\"\"));\n        assertEquals(\"\", Str.trim(\" \"));\n        assertEquals(\"\", Str.trim(\"\\t\"));\n        assertEquals(\"\", Str.trim(\"\\n\"));\n        assertEquals(\"\", Str.trim(\"\\r\"));\n        assertEquals(\"\", Str.trim(\"\\r\\n\"));\n        assertEquals(\"\", Str.trim(\"\\t\\n\"));\n        assertEquals(\"\", Str.trim(\"\\t\\r\"));\n        assertEquals(\"\", Str.trim(\"\\t\\r\\n\"));\n        assertEquals(\"\", Str.trim(\"\\t \\n\\r\"));\n        assertEquals(\"\", Str.trim(\"\\t \\n\\r\\n\"));\n        assertEquals(\"\", Str.trim(\"\\t \\n\\r\\n \"));\n        assertEquals(\"\", Str.trim(\"\\t \\n\\r\\n \\t\"));\n        assertEquals(\"\", Str.trim(\"\\t \\n\\r\\n \\t \"));\n        assertEquals(\"\", Str.trim(\"\\t \\n\\r\\n \\t \\t\"));\n        assertEquals(\"\", Str.trim(\"\\t \\n\\r\\n \\t \\t \"));\n        assertEquals(\"\", Str.trim(\"\\t \\n\\r\\n \\t \\t \\t\"));\n        assertEquals(\"\", Str.trim(\"\\t \\n\\r\\n \\t \\t \\t \"));\n        assertEquals(\"\", Str.trim(\"\\t \\n\\r\\n \\t \\t \\t \\t\"));\n        assertEquals(\"\", Str.trim(\"\\t \\n\\r\\n \\t \\t \\t \\t \"));\n        assertEquals(\"\", Str.trim(\"\\t \\n\\r\\n \\t \\t \\t \\t \\t\"));\n        assertEquals(\"\", Str.trim(\"\\t \\n\\r\\n \\t \\t \\t \\t \\t \"));\n        assertEquals(\"\", Str.trim(\"\\t \\n\\r\\n \\t \\t \\t \\t \\t \\t\"));\n        assertEquals(\"\", Str.trim(\"\\t \\n\\r\\n \\t \\t \\t \\t \\t \\t \"));\n        assertEquals(\"\", Str.trim(\"\\t \\n\\r\\n \\t \\t \\t \\t \\t \\t \\t\"));\n        assertEquals(\"\", Str.trim(\"\\t \\n\\r\\n \\t \\t \\t \\t \\t \\t \\t \"));\n        assertEquals(\"\", Str.trim(\"\\t \\n\\r\\n \\t \\t \\t \\t \\t \\t \\t \\t\"));\n        assertEquals(\"\", Str.trim(\"\\t \\n\\r\\n \\t \\t \\t \\t \\t \\t \\t \\t \"));\n        assertEquals(\"\", Str.trim(\"\\t \\n\\r\\n \\t \\t \\t \\t \\t \\t \\t \\t \\t\"));\n        assertEquals(\"\", Str.trim(\"\\t \\n\\r\\n \\t \\t \\t \\t \\t \\t \\t \\t \\t \"));\n        assertEquals(\"\", Str.trim(\"\\t \\n\\r\\n \\t \\t \\t \\t \\t \\t \\t \\t \\t \\t\"));\n        assertEquals(\"\", Str.trim(\"\\t \\n\\r\\n \\t \\t \\t \\t \\t \\t \\t \\t \\t \\t \"));\n        assertEquals(\"\", Str.trim(\"\\t \\n\\r\\n \\t \\t \\t \\t \\t \\t \\t \\t \\t \\t \\t\"));\n        assertEquals(\"\", Str.trim(\"\\t \\n\\r\\n \\t \\t \\t \\t \\t \\t \\t \\t \\t \\t \\t \"));\n        assertEquals(\"\", Str.trim(\"\\t \\n\\r\\n \\t \\t \\t \\t \\t \\t \\t \\t \\t \\t \\t \\t\"));\n        assertEquals(\"\", Str.trim(\"\\t \\n\\r\\n \\t \\t \\t \\t \\t \\t \\t \\t \\t \\t \\t \\t \"));\n        assertEquals(\"\", Str.trim(\"\\t \\n\\r\\n \\t \\t \\t \\t \\t \\t \\t \\t \\t \\t \\t \\t \\t\"));\n        assertEquals(\"\", Str.trim(\"\\t \\n\\r\\n \\t \\t \\t \\t \\t \\t \\t \\t \\t \\t \\t \\t \\t \"));\n        assertEquals(\"\", Str.trim(\"\\t \\n\\r\\n \\t \\t \\t \\t \\t \\t \\t \\t \\t \\t \\t \\t \\t \\t\"));\n        assertEquals(\"\", Str.trim(\"\\t \\n\\r\\n \\t \\t \\t \\t \\t \\t \\t \\t \\t \\t \\t \\t \\t \\t \"));\n        assertEquals(\"\", Str.trim(\"\\t \\n\\r\\n \\t \\t \\t \\t \\t \\t \\t \\t \\t \\t \\t \\t \\t \\t \\t\"));\n        assertEquals(\"\", Str.trim(\"\\t \\n\\r\\n \\t \\t \\t \\t \\t \\t \\t \\t \\t \\t \\t \\t \\t \\t \\t \"));\n        assertEquals(\"\", Str.trim(\"\\t \\n\\r\\n \\t \\t \\t \\t \\t \\t \\t \\t \\t \\t \\t \\t \\t \\t \\t \\t\"));\n        assertEquals(\"\", Str.trim(\"\\t \\n\\r\\n \\t \\t \\t \\t \\t \\t \\t \\t \\t \\t \\t \\", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "23086156_28", "part": [1, 1], "seq": [1, 1], "prompt": "class InMemoryFactory {\n\n\tpublic URL createInMemoryResource(String resource) throws MalformedURLException\n\t{\n\t\tString content = resource.replace('\\\\', '/');\n\t\treturn url(content);\n\t}\n\n\tpublic  InMemoryFactory();\n\n\tpublic URL createInMemoryClass(Class<?> claSs);\n\tprivate URL url(String content);\n\tprotected void assertElementName(String name);\n\n     InMemoryFactory underTest;\n\n}\n\nclass InMemoryFactoryTest {\n\n     InMemoryFactory underTest;\n\n    @Test(/*expected=IllegalArgumentException.class*/)\n    public void testCreateInMemoryResourceError()\n    {\n", "reference": "        try\n        {\n            String resource = \"data\\\\stuf\\\\content.properties\";\n\n            URL createInMemoryResource = underTest.createInMemoryResource(resource);\n            createInMemoryResource.toExternalForm();\n        } catch (MalformedURLException e)\n        {\n            fail(\"No exception should occu\");\n        }\n    }\n\n}", "prediction": "        underTest.createInMemoryResource(\"\");\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "23237318_30", "part": [1, 1], "seq": [1, 1], "prompt": "class ErrorHandler {\n\n    public boolean hasTooManyErrors(BaseTask.StreamMetrics metrics) {\n        long msgsDone = metrics.processed.getCount() + metrics.dropped.getCount();\n        if (msgsDone > 100L) {\n            double dropRate = metrics.dropped.getOneMinuteRate();\n            double successRate = metrics.processed.getOneMinuteRate();\n            if (dropRate > 0.0) {\n                double totalRate = dropRate + successRate;\n                double dropRatio = dropRate/totalRate;\n                if (logger.isTraceEnabled()) {\n                    logger.trace(String.format(\"Drop rate: %f msg/s, success rate %f msg/s, total rate %f msg/s, drop ratio %f, max drop ratio %f\",\n                            dropRate, successRate, totalRate, dropRatio, dropMaxRatio));\n                }\n                if (dropRatio > dropMaxRatio) {\n                    logger.error(String.format(\"Error ratio (1min avg) %2f has exceeded threshold %f.\", dropRatio, dropMaxRatio));\n                    return true;\n                }\n            }\n            else {\n                logger.trace(\"Drop rate is still 0.0\");\n            }\n        }\n        return false;\n    }\n\n    public  ErrorHandler(Config config, TaskInfo taskInfo);\n\n    public void start();\n    public boolean dropOnError();\n    public double getDropMaxRatio();\n    private void logDroppedMsgConfig();\n    private SystemProducer getSystemProducer(Config config);\n    public void handleException(IncomingMessageEnvelope envelope, Exception e, BaseTask.StreamMetrics metrics);\n    public void handleExpectedError(IncomingMessageEnvelope envelope, Exception e, BaseTask.StreamMetrics metrics);\n    private void handleDroppedMessage(IncomingMessageEnvelope envelope, Exception e, Meter dropped);\n    private byte[] serializeDroppedMessage(IncomingMessageEnvelope envelope, Exception e);\n    public void stop();\n\n    private final Clock clock;\n\n}\n\nclass ErrorHandlerTest {\n\n    private final Clock clock;\n\n    @Test\n    public void testNotTooManyErrors() throws Exception {\n", "reference": "        ErrorHandler errHandler = getErrorHandler();\n        BaseTask.StreamMetrics metrics = new BaseTask.StreamMetrics(new Meter(clock), new Meter(clock));\n\n        when(clock.getTick()).thenReturn(0L);\n        metrics.processed.mark(910L);\n        metrics.dropped.mark(90L);\n\n        when(clock.getTick()).thenReturn(TimeUnit.SECONDS.toNanos(10));\n        assertTrue(metrics.processed.getOneMinuteRate() > 0);\n        assertTrue(metrics.dropped.getOneMinuteRate() > 0);\n        assertFalse(errHandler.hasTooManyErrors(metrics));\n    }\n\n}", "prediction": "        ErrorHandler errorHandler = new ErrorHandler(config, taskInfo);\n        errorHandler.start();\n        assertFalse(errorHandler.hasTooManyErrors(new BaseTask.StreamMetrics()));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "23310687_6", "part": [1, 1], "seq": [1, 1], "prompt": "class UBL22DocumentTypes {\n\n  @Nonnull\n  @ReturnsMutableCopy\n  public static ICommonsSet <String> getAllNamespaces ()\n  {\n    return s_aNamespace2DocType.copyOfKeySet ();\n  }\n\n  private  UBL22DocumentTypes();\n\n  @Nullable public static EUBL22DocumentType getDocumentTypeOfNamespace(@Nullable final String sNamespace);\n  @Nullable public static Class <?> getImplementationClassOfNamespace(@Nullable final String sNamespace);\n  @Nullable public static EUBL22DocumentType getDocumentTypeOfImplementationClass(@Nullable final Class <?> aImplClass);\n  @Nullable public static Schema getSchemaOfNamespace(@Nullable final String sNamespace);\n  @Nonnull @ReturnsMutableCopy public static ICommonsSet <String> getAllLocalNames();\n  @Nullable public static EUBL22DocumentType getDocumentTypeOfLocalName(@Nullable final String sLocalName);\n  @Nullable public static Class <?> getImplementationClassOfLocalName(@Nullable final String sLocalName);\n  @Nullable public static Schema getSchemaOfLocalName(@Nullable final String sLocalName);\n  @Nullable public static Schema getSchemaOfImplementationClass(@Nullable final Class <?> aImplClass);\n\n}\n\nclass UBL22DocumentTypesTest {\n\n  @Test\n  public void testGetAllNamespaces ()\n  {\n", "reference": "    assertNotNull (UBL22DocumentTypes.getAllNamespaces ());\n    assertNotNull (UBL22DocumentTypes.getAllLocalNames ());\n    assertEquals (UBL22DocumentTypes.getAllNamespaces ().size (), UBL22DocumentTypes.getAllLocalNames ().size ());\n\n    for (final String sNamespace : UBL22DocumentTypes.getAllNamespaces ())\n    {\n      assertNotNull (UBL22DocumentTypes.getDocumentTypeOfNamespace (sNamespace));\n      assertNotNull (UBL22DocumentTypes.getImplementationClassOfNamespace (sNamespace));\n      assertNotNull (UBL22DocumentTypes.getSchemaOfNamespace (sNamespace));\n    }\n    assertNull (UBL22DocumentTypes.getDocumentTypeOfNamespace (\"any\"));\n    assertNull (UBL22DocumentTypes.getImplementationClassOfNamespace (\"any\"));\n    assertNull (UBL22DocumentTypes.getSchemaOfNamespace (\"any\"));\n    assertNull (UBL22DocumentTypes.getDocumentTypeOfNamespace (null));\n    assertNull (UBL22DocumentTypes.getImplementationClassOfNamespace (null));\n    assertNull (UBL22DocumentTypes.getSchemaOfNamespace (null));\n\n    for (final String sNamespace : UBL22DocumentTypes.getAllLocalNames ())\n    {\n      assertNotNull (UBL22DocumentTypes.getDocumentTypeOfLocalName (sNamespace));\n      assertNotNull (UBL22DocumentTypes.getImplementationClassOfLocalName (sNamespace));\n      assertNotNull (UBL22DocumentTypes.getSchemaOfLocalName (sNamespace));\n    }\n    assertNull (UBL22DocumentTypes.getDocumentTypeOfLocalName (\"any\"));\n    assertNull (UBL22DocumentTypes.getImplementationClassOfLocalName (\"any\"));\n    assertNull (UBL22DocumentTypes.getSchemaOfLocalName (\"any\"));\n    assertNull (UBL22DocumentTypes.getDocumentTypeOfLocalName (null));\n    assertNull (UBL22DocumentTypes.getImplementationClassOfLocalName (null));\n    assertNull (UBL22DocumentTypes.getSchemaOfLocalName (null));\n  }\n\n}", "prediction": "   final ICommonsSet <String> aAllNamespaces = UBL22DocumentTypes.getAllNamespaces ();\n    assertNotNull (aAllNamespaces);\n    assertFalse (aAllNamespaces.isEmpty ());\n    assertTrue (aAllNamespaces.contains (\"urn:oasis:names:specification:ubl:schema:xsd:Invoice-2\"));\n  }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "23330642_0", "part": [1, 1], "seq": [1, 1], "prompt": "class Main extends MainSupport {\n\n    @Override\n    protected Map<String, CamelContext> getCamelContextMap() {\n        BeanManager manager = container.getBeanManager();\n        return manager.getBeans(CamelContext.class, Any.Literal.INSTANCE).stream()\n            .map(bean -> getReference(manager, CamelContext.class, bean))\n            .collect(toMap(CamelContext::getName, identity()));\n    }\n\n    public static void main(String... args);\n    public static Main getInstance();\n    @Override protected ProducerTemplate findOrCreateCamelTemplate();\n    @Override protected void doStart();\n    private void warnIfNoCamelFound();\n    @Override protected void doStop();\n\n}\n\nclass MainTest {\n\n    @Test\n    public void testMainSupport() throws Exception {\n", "reference": "        Main main = new Main();\n        main.start();\n\n        assertThat(\"Camel contexts are not deployed!\", main.getCamelContextMap(), allOf(hasKey(\"default\"), hasKey(\"foo\")));\n\n        CamelContext context = main.getCamelContextMap().get(\"default\");\n        assertThat(\"Default Camel context is not started\", context.getStatus(), is(equalTo(ServiceStatus.Started)));\n        assertThat(\"Foo Camel context is not started\", main.getCamelContextMap().get(\"foo\").getStatus(), is(equalTo(ServiceStatus.Started)));\n\n        MockEndpoint outbound = context.getEndpoint(\"mock:outbound\", MockEndpoint.class);\n        outbound.expectedMessageCount(1);\n        outbound.expectedBodiesReceived(\"message\");\n\n        ProducerTemplate producer = main.getCamelTemplate();\n        producer.sendBody(\"direct:inbound\", \"message\");\n\n        MockEndpoint.assertIsSatisfied(2L, TimeUnit.SECONDS, outbound);\n\n        main.stop();\n    }\n\n}", "prediction": "        MainSupport main = new MainSupport();\n        assertNotNull(main.getCamelContextMap());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "24048150_4", "part": [1, 1], "seq": [1, 1], "prompt": "class Tail {\n\n    public static String getParametricCustomSimpleTail() {\n        String tail = PrefsUtil.readString(Consts.Keys.Key_Custom_Tail, \"\");\n        if (TextUtils.isEmpty(tail)) {\n            return \"\";\n        } else {\n            return \"\\n\\n[blockquote]\" + tail + \"[/blockquote]\";\n        }\n    }\n\n    public static String getComplexReplyTail();\n    public static String getDefaultComplexTail();\n    private static String getPhoneComplexTail();\n    public static String getParametricCustomComplexTail();\n    public static String getSimpleReplyTail();\n    private static String getPhoneSimpleTail();\n    private static String getDefaultSimpleTail();\n    public static String getDefaultPlainTail();\n    public static String getPhonePlainTail();\n    public static String getUrl();\n\n}\n\nclass TailTest {\n\n    @Test\n    public void getParametricCustomSimpleTail() throws Exception {\n", "reference": "\n    }\n\n    public static String getComplexReplyTail();\n    public static String getDefaultComplexTail();\n    private static String getPhoneComplexTail();\n    public static String getParametricCustomComplexTail();\n    public static String getSimpleReplyTail();\n    private static String getPhoneSimpleTail();\n    private static String getDefaultSimpleTail();\n    public static String getDefaultPlainTail();\n    public static String getPhonePlainTail();\n    public static String getUrl();\n\n}\n\nclass TailTest {\n\n    @Test\n    public void getParametricCustomSimpleTail() throws Exception {\n\n    }\n\n}", "prediction": "        assertEquals(\"\", Tail.getParametricCustomSimpleTail());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "24095382_0", "part": [1, 1], "seq": [1, 1], "prompt": "class StringValidator extends FXAbstractValidator<TextInputControl, FXString> {\n\n  @Override\n  public void validate(TextInputControl control, FXString annotation) throws ValidationException {\n    // shortcut: do not check if disabled.\n    if (control.isDisabled()) {\n      this.isValid.set(true);\n      return;\n    }\n    if (!control.isVisible()) {\n      this.isValid.set(true);\n      return;\n    }\n\n    boolean valid = true;\n\n    // 1. minLength?\n    if (annotation.minLength() > 0) {\n      valid = valid && control.getText().length() >= annotation.minLength();\n      \n      this.isValid.set(valid);\n      if (!valid) {\n        String msg = annotation.messageMinLength();\n        if (annotation.messageMinLength().contains(\"%d\")) {\n          msg = String.format(annotation.messageMinLength(), annotation.minLength());\n        }\n        throw new ValidationException(msg);\n      }\n    }\n\n    // 2. maxLength?\n    if (annotation.maxLength() > 0) {\n      valid = valid && control.getText().length() <= annotation.maxLength();\n      this.isValid.set(valid);\n      if (!valid) {\n        String msg = annotation.messageMaxLength();\n        if (annotation.messageMaxLength().contains(\"%d\")) {\n          msg = String.format(annotation.messageMaxLength(), annotation.maxLength());\n        }\n        throw new ValidationException(msg);\n      }\n    }\n\n    // 3. pattern?\n    if (annotation.pattern().length() > 0) {\n      // check for necessary lazy initialization: \n      if (this.pattern == null) {\n        this.createRegex(annotation);\n      }\n      \n      valid = valid && this.pattern.matcher(control.getText()).matches();\n      this.isValid.set(valid);\n      if (!valid) {\n        String msg = annotation.messagePattern();\n        throw new ValidationException(msg);\n      }\n    }\n  }\n\n  public  StringValidator();\n  public  StringValidator(TextInputControl control, FXString annotation);\n\n  private void createRegex(FXString annotation);\n\n}\n\nclass StringValidatorTest {\n\n  @Test\n  @Disabled(\"TODO\")\n  public void testValidate() throws Exception {\n", "reference": "    System.out.println(\"validate\");\n    TextInputControl control = null;\n    FXString annotation = null;\n    StringValidator instance = new StringValidator();\n    instance.validate(control, annotation);\n    // TODO review the generated test code and remove the default call to fail.\n    fail(\"The test case is a prototype.\");\n  }\n\n}", "prediction": "   \n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "24459625_5", "part": [1, 1], "seq": [1, 1], "prompt": "class AwsApaRequesterImpl implements AwsApaRequester {\n\n    @Override\n    public Response<ItemLookupResponse> itemLookupAsync(\n            ItemLookupRequest request) throws ExecutionException,\n            InterruptedException {\n        AWSECommerceServicePortType port = preparePort();\n        ItemLookup itemLookup = prepareItemLookup(request);\n        Response<ItemLookupResponse> response = port\n                .itemLookupAsync(itemLookup);\n        return response;\n    }\n\n    public  AwsApaRequesterImpl();\n    public  AwsApaRequesterImpl(String endpoint, String accessKeyId,\n                               String secretAccessKey, String associateTag);\n\n    private static void checkArgs(String endpoint, String accessKeyId,\n                                  String secretAccessKey, String associateTag);\n    private static void checkIfNullOrEmpty(String str, String name);\n    protected AWSECommerceServicePortType preparePort();\n    protected ItemSearch prepareItemSearch(ItemSearchRequest request);\n    protected ItemLookup prepareItemLookup(ItemLookupRequest request);\n    @Override public ItemSearchResponse itemSearch(ItemSearchRequest request);\n    @Override public Response<ItemSearchResponse> itemSearchAsync(\n            ItemSearchRequest request);\n    public T invokeWithRetry(WebServiceInvoker<T> invoker);\n    @Override public ItemLookupResponse itemLookup(ItemLookupRequest request);\n    public T getResponseWithRetry(final Response<T> res);\n    public int getRetryCount();\n    public void setRetryCount(int retryCount);\n    public long getRetryInterval();\n    public void setRetryInterval(long retryInterval);\n\n    protected AwsApaRequester requester;\n\n}\n\nclass AwsApaRequesterImplTest {\n\n    protected AwsApaRequester requester;\n\n    @Test\n    public void testItemLookupAsync02() throws Exception {\n", "reference": "        Response<ItemLookupResponse> res = null;\n        {\n            ItemLookupRequest request = new ItemLookupRequest();\n            request.getItemId().add(\"489471499X\");\n            request.getResponseGroup().add(\"Small\");\n            res = requester.itemLookupAsync(request);\n        }\n        Response<ItemLookupResponse> res1 = res;\n\n        {\n            ItemLookupRequest request = new ItemLookupRequest();\n            request.getItemId().add(\"4798024031\");\n            request.getResponseGroup().add(\"Small\");\n            res = requester.itemLookupAsync(request);\n        }\n        Response<ItemLookupResponse> res2 = res;\n\n        {\n            ItemLookupRequest request = new ItemLookupRequest();\n            request.getItemId().add(\"4797339535\");\n            request.getResponseGroup().add(\"Small\");\n            res = requester.itemLookupAsync(request);\n        }\n        Response<ItemLookupResponse> res3 = res;\n\n        {\n            ItemLookupResponse response = res1.get();\n            assertNotNull(response);\n            assertNotNull(response.getItems());\n            assertTrue(response.getItems().size() == 1);\n            assertNotNull(response.getItems().get(0).getItem());\n            assertTrue(response.getItems().get(0).getItem().size() == 1);\n            Item item = response.getItems().get(0).getItem().get(0);\n            assertEquals(\"489471499X\", item.getASIN());\n            assertNotNull(item.getItemAttributes());\n        }\n\n        {\n            ItemLookupResponse response = res2.get();\n            assertNotNull(response);\n            assertNotNull(response.getItems());\n            assertTrue(response.getItems().size() == 1);\n            assertNotNull(response.getItems().get(0).getItem());\n            assertTrue(response.getItems().get(0).getItem().size() == 1);\n            Item item = response.getItems().get(0).getItem().get(0);\n            assertEquals(\"4798024031\", item.getASIN());\n            assertNotNull(item.getItemAttributes());\n        }\n\n        {\n            ItemLookupResponse response = res3.get();\n            assertNotNull(response);\n            assertNotNull(response.getItems());\n            assertTrue(response.getItems().size() == 1);\n            assertNotNull(response.getItems().get(0).getItem());\n            assertTrue(response.getItems().get(0).getItem().size() == 1);\n            Item item = response.getItems().get(0).getItem().get(0);\n            assertEquals(\"4797339535\", item.getASIN());\n            assertNotNull(item.getItemAttributes());\n        }\n    }\n\n}", "prediction": "        ItemLookupRequest request = new ItemLookupRequest();\n        request.setItemId(\"B000000000\");\n        Response<ItemLookupResponse> response = requester.itemLookupAsync(request);\n        assertNotNull(response);\n        assertNotNull(response.getResult());\n        assertNotNull(response.getResult().getItems());\n        assertEquals(1, response.getResult().getItems().size());\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "24474053_3", "part": [1, 1], "seq": [1, 1], "prompt": "class ConcreteIntPredicate implements IntPredicate {\n\n    public static ConcreteIntPredicate lte(int i) {\n        return new LTEIntPredicate(i);\n    }\n\n    private  ConcreteIntPredicate();\n\n    @Override public final ConcreteIntPredicate and(IntPredicate intPredicate);\n    @Override public final ConcreteIntPredicate negate();\n    @Override public final ConcreteIntPredicate or(IntPredicate intPredicate);\n    @Override @SuppressFBWarnings(value = \"AOM_ABSTRACT_OVERRIDDEN_METHOD\", justification = \"We want subclasses to implement this\") public abstract int hashCode();\n    @Override @SuppressFBWarnings(value = \"AOM_ABSTRACT_OVERRIDDEN_METHOD\", justification = \"We want subclasses to implement this\") public abstract boolean equals(Object o);\n    @Override @SuppressFBWarnings(value = \"AOM_ABSTRACT_OVERRIDDEN_METHOD\", justification = \"We want subclasses to implement this\") public abstract String toString();\n    public static ConcreteIntPredicate gt(int i);\n    public static ConcreteIntPredicate gte(int i);\n    public static ConcreteIntPredicate lt(int i);\n    public static ConcreteIntPredicate eq(int i);\n\n}\n\nclass ConcreteIntPredicateTest {\n\n    @Test\n    public void testLte() {\n", "reference": "        int v = 100;\n        ConcreteIntPredicate lteP = lte(100);\n        assertTrue(lteP.test(v));\n        assertFalse(lteP.test(v + 1));\n        assertTrue(lteP.test(v - 1));\n        assertEquals(lte(v), lteP);\n        assertEquals(lte(v).hashCode(), lteP.hashCode());\n        assertNotEquals(lt(v), lteP);\n        assertNotEquals(lte(v + 1), lteP);\n        assertEquals(lteP.toString(), \"<= 100\");\n    }\n\n}", "prediction": "        IntPredicate lte = ConcreteIntPredicate.lte(10);\n        assertTrue(lte.test(10));\n        assertTrue(lte.test(9));\n        assertFalse(lte.test(11));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "25259107_33", "part": [1, 1], "seq": [1, 1], "prompt": "class U2fPrimitives {\n\n    public DeviceRegistration finishRegistration(RegisterRequest registerRequest, RegisterResponse response) throws U2fRegistrationException {\n        return finishRegistration(registerRequest, response, null);\n    }\n\n    public  U2fPrimitives(Crypto crypto, ChallengeGenerator challengeGenerator);\n    public  U2fPrimitives();\n\n    public RegisterRequest startRegistration(String appId);\n    public RegisterRequest startRegistration(String appId, byte[] challenge);\n    public DeviceRegistration finishRegistration(RegisterRequest registerRequest,\n                                                 RegisterResponse response,\n                                                 Set<String> facets);\n    public SignRequest startSignature(String appId, DeviceRegistration deviceRegistration);\n    public SignRequest startSignature(String appId, DeviceRegistration deviceRegistration, byte[] challenge);\n    public void finishSignature(SignRequest signRequest,\n                                SignResponse response,\n                                DeviceRegistration deviceRegistration);\n    public void finishSignature(SignRequest signRequest,\n                                SignResponse response,\n                                DeviceRegistration deviceRegistration,\n                                Set<String> facets);\n\n    final HashSet<String> allowedOrigins;\n     U2fPrimitives u2f;\n    @Rule\n    public ExpectedException expectedException;\n\n}\n\nclass U2fPrimitivesTest {\n\n    final HashSet<String> allowedOrigins;\n     U2fPrimitives u2f;\n    @Rule\n    public ExpectedException expectedException;\n\n    @Test\n    public void finishRegistrationShouldDetectIncorrectClientDataOrigin() throws Exception {\n", "reference": "        expectedException.expectCause(isA(U2fBadInputException.class));\n\n        RegisterRequest registerRequest = new RegisterRequest(SERVER_CHALLENGE_REGISTER_BASE64, APP_ID_ENROLL);\n\n        String clientDataBase64 = U2fB64Encoding.encode(\"{\\\"typ\\\":\\\"navigator.id.finishEnrollment\\\",\\\"challenge\\\":\\\"vqrS6WXDe1JUs5_c3i4-LkKIHRr-3XVb3azuA5TifHo\\\",\\\"origin\\\":\\\"http://evil.com\\\"}\".getBytes(\"UTF-8\"));\n\n        u2f.finishRegistration(\n            registerRequest,\n            new RegisterResponse(\n                TestVectors.REGISTRATION_DATA_BASE64,\n                clientDataBase64\n            )\n        );\n\n        fail(\"finishRegistration did not detect incorrect origin in client data\");\n    }\n\n}", "prediction": "        RegisterRequest registerRequest = u2f.startRegistration(\"http://localhost:8080\");\n        RegisterResponse response = new RegisterResponse(new byte[32], new byte[32], new byte[32], new byte[32], new byte[32], new byte[32], new byte[32], new byte[32], new byte[32], new byte[32], new byte[32], new byte[32], new byte[32], new byte[32], new byte[32], new byte[32], new byte[32], new byte[32], new byte[32], new byte[32], new byte[32], new byte[32], new byte[32], new byte[32], new byte[32], new byte[32], new byte[32], new byte[32], new byte[32], new byte[32], new byte[32], new byte[32], new byte[32], new byte[32], new byte[32], new byte[32], new byte[32], new byte[32], new byte[32], new byte[32],", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "25359676_335", "part": [1, 1], "seq": [1, 1], "prompt": "class LegacyDataAdapterImpl implements LegacyDataAdapter {\n\n    @Override\n    public boolean isPersistable(Class<?> dataObjectClass) {\n        return selectAdapter(dataObjectClass).isPersistable(dataObjectClass);\n    }\n\n    @Override public T save(T dataObject);\n    @Override public T linkAndSave(T dataObject);\n    @Override public T saveDocument(T document);\n    @Override public T findByPrimaryKey(Class<T> clazz, Map<String, ?> primaryKeys);\n    @Override public T findBySinglePrimaryKey(Class<T> clazz, Object primaryKey);\n    @Override public void delete(Object dataObject);\n    @Override public void deleteMatching(Class<?> type, Map<String, ?> fieldValues);\n    @Override public T retrieve(T dataObject);\n    @Override public Collection<T> findAll(Class<T> clazz);\n    @Override public Collection<T> findMatching(Class<T> clazz, Map<String, ?> fieldValues);\n    @Override public Collection<T> findMatchingOrderBy(Class<T> clazz, Map<String, ?> fieldValues, String sortField,\n            boolean sortAscending);\n    @Override public Map<String, ?> getPrimaryKeyFieldValues(Object dataObject);\n    @Override public void retrieveNonKeyFields(Object persistableObject);\n    @Override public void retrieveReferenceObject(Object persistableObject, String referenceObjectName);\n    @Override public void refreshAllNonUpdatingReferences(Object persistableObject);\n    @Override public boolean isProxied(Object object);\n    @Override public Object resolveProxy(Object object);\n    @Override public Collection<T> findCollectionBySearchHelper(Class<T> dataObjectClass, Map<String, String> formProperties,\n            boolean unbounded, boolean allPrimaryKeyValuesPresentAndNotWildcard, Integer searchResultsLimit);\n    @Override public Collection<T> findCollectionBySearchHelper(Class<T> dataObjectClass, Map<String, String> formProperties,\n            List<String> wildcardAsLiteralPropertyNames, boolean unbounded,\n            boolean allPrimaryKeyValuesPresentAndNotWildcard, Integer searchResultsLimit);\n    @Override public T findObjectBySearch(Class<T> type, Map<String, String> formProps);\n    @Override public boolean allPrimaryKeyValuesPresentAndNotWildcard(Class<?> boClass, Map<String, String> formProps);\n    @Override public List<String> listPrimaryKeyFieldNames(Class<?> type);\n    @Override public Class<?> determineCollectionObjectType(Class<?> containingType, String collectionPropertyName);\n    @Override public boolean hasReference(Class<?> boClass, String referenceName);\n    @Override public boolean hasCollection(Class<?> boClass, String collectionName);\n    @Override public boolean isExtensionAttribute(Class<?> boClass, String attributePropertyName, Class<?> propertyType);\n    @Override public Class<?> getExtensionAttributeClass(Class<?> boClass, String attributePropertyName);\n    @Override public Map<String, ?> getPrimaryKeyFieldValuesDOMDS(Object dataObject);\n    @Override public boolean equalsByPrimaryKeys(Object do1, Object do2);\n    @Override public void materializeAllSubObjects(Object object);\n    @Override public Class<?> getPropertyType(Object object, String propertyName);\n    @Override public Object getExtension(\n            Class<?> businessObjectClass);\n    @Override public void refreshReferenceObject(Object businessObject, String referenceObjectName);\n    @Override public boolean isLockable(Object object);\n    @Override public void verifyVersionNumber(Object dataObject);\n    @Override public RemotableQuickFinder.Builder createQuickFinder(Class<?> containingClass, String attributeName);\n    @Override public boolean isReferenceUpdatable(Class<?> type, String referenceName);\n    @Override @SuppressWarnings(\"rawtypes\") public Map<String, Class> listReferenceObjectFields(Class<?> type);\n    @Override public boolean isCollectionUpdatable(Class<?> type, String collectionName);\n    @Override @SuppressWarnings(\"rawtypes\") public Map<String, Class> listCollectionObjectTypes(Class<?> type);\n    @Override public Object getReferenceIfExists(Object bo, String referenceName);\n    @Override public boolean allForeignKeyValuesPopulatedForReference(Object bo, String referenceName);\n    @Override public RelationshipDefinition getDictionaryRelationship(Class<?> c, String attributeName);\n    @Override public String getTitleAttribute(Class<?> dataObjectClass);\n    @Override public boolean areNotesSupported(Class<?> dataObjectClass);\n    @Override public String getDataObjectIdentifierString(Object dataObject);\n    @Override public Class<?> getInquiryObjectClassIfNotTitle(Object dataObject, String propertyName);\n    @Override public Map<String, String> getInquiryParameters(Object dataObject, List<String> keys, String propertyName);\n    @Override public boolean hasLocalLookup(Class<?> dataObjectClass);\n    @Override public boolean hasLocalInquiry(Class<?> dataObjectClass);\n    @Override public org.kuali.rice.krad.bo.DataObjectRelationship getDataObjectRelationship(Object dataObject,\n            Class<?> dataObjectClass, String attributeName, String attributePrefix, boolean keysOnly,\n            boolean supportsLookup, boolean supportsInquiry);\n    @Override public ForeignKeyFieldsPopulationState getForeignKeyFieldsPopulationState(Object dataObject, String referenceName);\n    @Override public Map<String, String> getForeignKeysForReference(Class<?> clazz, String attributeName);\n    @Override public boolean hasPrimaryKeyFieldValues(Object dataObject);\n    @Override public void setObjectPropertyDeep(Object bo, String propertyName, Class type,\n            Object propertyValue);\n    @Override @SuppressWarnings(\"rawtypes\") public Class materializeClassForProxiedObject(Object object);\n    @Override public Object getNestedValue(Object bo, String fieldName);\n    @Override @SuppressWarnings(\"rawtypes\") public Object createNewObjectFromClass(Class clazz);\n    @Override public boolean isNull(Object object);\n    @Override public void setObjectProperty(Object bo, String propertyName, Class propertyType,\n            Object propertyValue);\n    @Override public T findByDocumentHeaderId(Class<T> documentClass, String id);\n    @Override public List<T> findByDocumentHeaderIds(Class<T> documentClass, List<String> ids);\n    protected LegacyDataAdapter selectAdapter(Object dataObject);\n    public LegacyDataAdapter getKradLegacyDataAdapter();\n    public void setKradLegacyDataAdapter(LegacyDataAdapter kradLegacyDataAdapter);\n    public LegacyDataAdapter getKnsLegacyDataAdapter();\n    public void setKnsLegacyDataAdapter(LegacyDataAdapter knsLegacyDataAdapter);\n\n    @Mock private LegacyDataAdapter knsLegacyDataAdapter;\n    @Mock private LegacyDataAdapter kradLegacyDataAdapter;\n    @Mock private DataDictionaryService dataDictionaryService;\n    @Mock private MetadataRepository metadataRepository;\n    @InjectMocks private LegacyDataAdapterImpl lda;\n\n}\n\nclass LegacyDataAdapterImplTest {\n\n    @Mock private LegacyDataAdapter knsLegacyDataAdapter;\n    @Mock private LegacyDataAdapter kradLegacyDataAdapter;\n    @Mock private DataDictionaryService dataDictionaryService;\n    @Mock private MetadataRepository metadataRepository;\n    @InjectMocks private LegacyDataAdapterImpl lda;\n\n    @Test\n    public void testIsPersistable() throws Exception {\n", "reference": "        lda.isPersistable(NonLegacy.class);\n        verify(kradLegacyDataAdapter).isPersistable(eq(NonLegacy.class));\n        verifyZeroInteractions(knsLegacyDataAdapter);\n    }\n\n}", "prediction": "        Class<?> clazz = String.class;\n        when(kradLegacyDataAdapter.isPersistable(clazz)).thenReturn(true);\n        when(knsLegacyDataAdapter.isPersistable(clazz)).thenReturn(false);\n        assertTrue(lda.isPersistable(clazz));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "25434304_1", "part": [1, 1], "seq": [1, 1], "prompt": "class Naming {\n\n    static String normalize(CharSequence name) {\n        return capitalize(name.toString().replaceFirst(\"^_\", \"\"))\n                .replaceFirst(\"^Class$\", \"Class_\");\n    }\n\n    private  Naming();\n\n    static String withGeneratedSuffix(CharSequence what);\n    private static String capitalize(String name);\n\n}\n\nclass NamingTest {\n\n    @Test\n    public void shouldIgnoreUnderscoresInBeginning() throws Exception {\n", "reference": "        assertThat(Naming.normalize(\"_public\"), equalTo(\"Public\"));\n    }\n\n}", "prediction": "        assertEquals(\"Class\", Naming.normalize(\"_Class\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "25434873_0", "part": [1, 1], "seq": [1, 1], "prompt": "class Converters {\n\n    static <T> Converter<T> getConverter(Scope scope, Class<T> parameterType) {\n        return getConverter(scope, parameterType, EMPTY_ANNOTATIONS);\n    }\n\n    private  Converters();\n\n    static Converter<T> getConverter(Scope scope, Class<T> parameterType, Annotation[] parameterAnnotations);\n    @SuppressWarnings(\"unchecked\") static Converter<T> newEnumConverter(Class<?> parameterType);\n    @SuppressWarnings(\"unchecked\") private static Converter<T> cast(Class<T> parameterType, Converter<?> converter);\n\n}\n\nclass ConvertersTest {\n\n    @Test\n    public void shouldRetrieveConfiguredConverter() throws NoSuchMethodException {\n", "reference": "        final SomeBeanConverter someBeanConverter = new SomeBeanConverter();\n        final Scope scope = new SingleBeanScope<>(SomeBeanConverter.class, someBeanConverter);\n        final Method method = ConvertersTest.class.getDeclaredMethod(\"methodWithConvertedParameter\", SomeBean.class);\n        final Converter<SomeBean> converter = Converters.getConverter(scope, SomeBean.class, method.getParameterAnnotations()[0]);\n\n        Assert.assertNotNull(\"should not be null\", converter);\n        Assert.assertEquals(\"should be retrieved from scope\", someBeanConverter, converter);\n    }\n\n}", "prediction": "        Converter<String> converter = Converters.getConverter(Scope.REQUEST, String.class);\n        assertThat(converter).isNotNull();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "26593878_1", "part": [1, 1], "seq": [1, 1], "prompt": "class MMTypeTools {\n\n    public static String bestMatch(Collection<String> supported, String header) {\n        List<ParseResults> parseResults = new LinkedList<ParseResults>();\n\n        List<FitnessAndQuality> weightedMatches = new LinkedList<FitnessAndQuality>();\n        for (String r : header.split(\",\")) {\n            parseResults.add(parseMediaRange(r));\n        }\n\n        for (String s : supported) {\n            FitnessAndQuality fitnessAndQuality = fitnessAndQualityParsed(s,\n                    parseResults);\n            fitnessAndQuality.mimeType = s;\n            weightedMatches.add(fitnessAndQuality);\n        }\n        Collections.sort(weightedMatches);\n\n        FitnessAndQuality lastOne = weightedMatches.get(weightedMatches.size() - 1);\n//        debug(\"Get back: \" + lastOne.quality + \" , \" + lastOne.mimeType);\n\n        if (lastOne.quality != 0) {\n            return lastOne.mimeType;\n        }\n\n        return \"\";\n    }\n\n    private static FitnessAndQuality fitnessAndQualityParsed(String mimeType,\n            Collection<ParseResults> parsedRanges);\n    private static ParseResults parseMediaRange(String range);\n    private static ParseResults parseMimeType(String mimeType);\n\n}\n\nclass MMTypeToolsTest {\n\n    @Test\n    public void testBestMatch() {\n", "reference": "        System.out.println(\"bestMatch\");\n        \n        Collection<String> acceps = new ArrayList<String>();\n        acceps.add(\"text/html\");\n        acceps.add(\"text/*;q=0.9\");\n        acceps.add(\"image/jpeg;q=0.9\");\n        acceps.add(\"image/png;q=0.9\");\n        acceps.add(\"image/*;q=0.9\");\n        acceps.add(\"*/*;q=0.8\");\n       \n        String fileContentType = \"text/plain\";\n        String expResult = \"text/*;q=0.9\";\n        String result = MMTypeTools.bestMatch(acceps, fileContentType);\n        assertEquals(expResult, result);\n    }\n\n}", "prediction": "        Assert.assertEquals(\"text/html\", MMTypeTools.bestMatch(Arrays.asList(\"text/html\"), \"text/html\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "26644682_425", "part": [1, 1], "seq": [1, 1], "prompt": "class XlsDetector extends POIFSContainerDetector implements Detector {\n\n    @Override\n    public Format detect(Metadata metadata, TikaInputStream inputStream) throws IOException {\n\n        Format result = null;\n\n        MediaType mediaType = super.detect(inputStream, metadata);\n        if (mediaType == null || StringUtils.equals(mediaType.toString(), FormatUtils.UNKNOWN_MEDIA_TYPE)) {\n            mediaType = zipContainerDetector.detect(inputStream, new Metadata());\n        }\n\n        if (mediaType != null) {\n            String mediaTypeName = mediaType.toString();\n            if (StringUtils.startsWith(mediaTypeName, XlsFormatFamily.MEDIA_TYPE)\n                    || StringUtils.equals(mediaTypeName, OLD_XLS_MEDIA_TYPE)) {\n                result = new Format(xlsFormatFamily, FormatUtils.DEFAULT_ENCODING);\n            }\n        }\n\n        return result;\n    }\n\n    @Autowired XlsDetector xlsDetector;\n\n}\n\nclass XlsDetectorTest extends POIFSContainerDetector {\n\n    @Autowired XlsDetector xlsDetector;\n\n    @Test\n    public void read_xls_that_can_be_parsed_as_csv_TDP_375() throws Exception {\n", "reference": "\n        String fileName = \"TDP-375_xsl_read_as_csv.xls\";\n\n        try (InputStream inputStream = this.getClass().getResourceAsStream(fileName)) {\n            Format actual = xlsDetector.detect(inputStream);\n            Assert.assertNotNull(actual);\n            assertTrue(actual.getFormatFamily() instanceof XlsFormatFamily);\n            assertEquals(XlsFormatFamily.MEDIA_TYPE, actual.getFormatFamily().getMediaType());\n            assertTrue(StringUtils.equals(\"UTF-8\", actual.getEncoding()));\n        }\n\n    }\n\n}", "prediction": "        InputStream inputStream = getClass().getResourceAsStream(\"/test-documents/test-document-xls-can-be-parsed-as-csv.xls\");\n        assertNotNull(inputStream);\n\n        Metadata metadata = new Metadata();\n        Format format = xlsDetector.detect(metadata, TikaInputStream.get(inputStream));\n        assertNotNull(format);\n        assertEquals(xlsFormatFamily, format.getFormatName());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "26722690_20", "part": [1, 1], "seq": [1, 1], "prompt": "class URLUtils {\n\n    static public String getParentPath(String path) {\n        if (path == null || path.isEmpty() || path.equals(\"/\")) {\n            return path;\n        }\n\n        int lastSlashPos = path.lastIndexOf('/');\n\n        if (lastSlashPos > 0) {\n            return path.substring(0, lastSlashPos); // strip off the slash\n        } else if (lastSlashPos == 0) {\n            return \"/\";\n        } else {\n            return \"\"; // we expect people to add + \"/somedir on their own\n        }\n    }\n\n    static public String removeTrailingSlashes(String s);\n    static public String decodeQueryString(String qs);\n    static public String getPrefixUrl(HttpServerExchange exchange);\n    public static String getQueryStringRemovingParams(HttpServerExchange exchange, String... paramsToRemove);\n    public static String getIdString(BsonValue id);\n\n    private static final Logger LOG;\n    @Rule\n    public TestRule watcher;\n\n}\n\nclass URLUtilsTest {\n\n    private static final Logger LOG;\n    @Rule\n    public TestRule watcher;\n\n    @Test\n    public void testGetParentPath() {\n", "reference": "        String path = \"/a/b/c/d\";\n        String expResult = \"/a/b/c\";\n        String result = URLUtils.getParentPath(path);\n        assertEquals(expResult, result);\n    }\n\n}", "prediction": "        Assert.assertEquals(\"\", URLUtils.getParentPath(\"\"));\n        Assert.assertEquals(\"/\", URLUtils.getParentPath(\"/\"));\n        Assert.assertEquals(\"/\", URLUtils.getParentPath(\"/a\"));\n        Assert.assertEquals(\"/a\", URLUtils.getParentPath(\"/a/\"));\n        Assert.assertEquals(\"/a\", URLUtils.getParentPath(\"/a/b\"));\n        Assert.assertEquals(\"/a/b\", URLUtils.getParentPath(\"/a/b/\"));\n        Assert.assertEquals(\"/a/b\", URLUtils.getParentPath(\"/a/b/c\"));\n        Assert.assertEquals(\"/a/b/c\", URLUtils.getParentPath(\"/a/b/c/\"));\n        Assert.assertEquals(\"/a/b/c\", URLUtils.getParentPath(\"/a/b/c/d\"));\n        Assert.assertEquals(\"/a/b/c/d\", URLUtils.getParentPath(\"/a/b/c/d/\"));\n        Assert.assertEquals(\"/a/b/c/d\", URLUtils.getParentPath(\"/a/b/c/d/e\"));\n        Assert.assertEquals(\"/a/b/c/d/e\", URLUtils.getParentPath(\"/a/b/c/d/e/\"));\n        Assert.assertEquals(\"/a/b/c/d/e\", URLUtils.getParentPath(\"/a/b/c/d/e/f\"));\n        Assert.assertEquals(\"/a/b/c/d/e/f\", URLUtils.getParentPath(\"/a/b/c/d/e/f/\"));\n        Assert.assertEquals(\"/a/b/c/d/e/f\", URLUtils.getParentPath(\"/a/b/c/d/e/f/g\"));\n        Assert.assertEquals(\"/a/b/c/d/e/f/g\", URLUtils.getParentPath(\"/a/b/c/d/e/f/g/\"));\n        Assert.assertEquals(\"/a/b/c/d/e/f/g\", URLUtils.getParentPath(\"/a/b/c/d/e/f/g/h\"));\n        Assert.assertEquals(\"/a/b/c/d/e/f/g/h\", URLUtils.getParentPath(\"/a/b/c/d/e/f/g/h/\"));\n        Assert.assertEquals(\"/a/b/c/d/e/f/g/h\", URLUtils.getParentPath(\"/a/b/c/d/e/f/g/h/i\"));\n        Assert.assertEquals(\"/a/b/c/d/e/f/g/h/i\", URLUtils.getParentPath(\"/a/b/c/d/e/f/g/h/i/\"));\n        Assert.assertEquals(\"/a/b/c/d/e/f/g/h/i\", URLUtils.getParentPath(\"/a/b/c/d/e/f/g/h/i/j\"));\n        Assert.assertEquals(\"/a/b/c/d/e/f/g/h/i/j\", URLUtils.getParentPath(\"/a/b/c/d/e/f/g/h/i/j/\"));\n        Assert.assertEquals(\"/a/b/c/d/e/f/g/h/i/j\", URLUtils.getParentPath(\"/a/b/c/d/e/f/g/h/i/j/k\"));\n        Assert.assertEquals(\"/a/b/c/d/e/f/g/h/i/j/k\", URLUtils.getParentPath(\"/a/b/c/d/e/f/g/h/i/j/k/\"));\n        Assert.assertEquals(\"/a/b/c/d/e/f/g/h/i/j/k\", URLUtils.getParentPath(\"/a/b/c/d/e/f/g/h/i/j/k/l\"));\n        Assert.assertEquals(\"/a/b/c/d/e/f/g/h/i/j/k/l\", URLUtils.getParentPath(\"/a/b/c/d/e/f/g/h/i/j/k/l/\"));\n        Assert.assertEquals(\"/a/b/c/d/e/f/g/h/i/j/k/l\", URLUtils.getParentPath(\"/a/b/c/d/e/f/g/h/i/j/k/l/m\"));\n        Assert.assertEquals(\"/a/b/c/d/e/f/g/h/i/j/k/l/m\", URLUtils.getParentPath(\"/a/b/c/d/e/f/g/h/i/j/k/l/m/\"));\n        Assert.assertEquals(\"/a/b/c/d/e/f/g/h/i/j/k/l/m\", URLUtils.getParentPath(\"/a/b/c/d/e/f/g/h/i/j/k/l/m/n\"));\n        Assert.assertEquals(\"/a/b/c/d/e/f/g/h/i/j/k/l/m/n\", URLUtils.getParentPath(\"/a/b/c/d/e/f/g/h/i/j/k/l/m/n/\"));\n        Assert.assertEquals(\"/a/b/c/d/e/f/g/h/i/j/k/l/m/n\", URLUtils.getParentPath(\"/a/b/c/d/e/f/g/h/i/j/k/l/m/n/o\"));\n        Assert.assertEquals(\"/a/b/c/d/e/f/g/h/i/j/k/l/m/n/o\", URLUtils.getParentPath(\"/a/b/c/d/e/f/g/h/i/j/k/l/m/n/o/\"));\n        Assert.assertEquals(\"/a/b/c/d/e/f/g/h/i/j/k/l/m/n/o\", URLUtils.getParentPath(\"/a/b/c/d/e/f/g/h/i/j/k/l/m/n/o/p\"));\n        Assert.assertEquals(\"/a/b/c/d/e/f/g/h/i/j/k/l/m/n/o/p\", URLUtils.getParentPath(\"/a/b/c/d/e/f/g/h/i/j/k/l/m/n/o/p/\"));\n        Assert.assertEquals(\"/a/b/c/d/e/f/g/h/i/j/k/l/m/n/o/p\", URLUtils.getParentPath(\"/a/b/c/d/e/f/g/h/i/j/k/l/m/n/o/p/q\"));\n        Assert.assertEquals(\"/a/b/c/d/e/f/g/h/i/j/k/l/m/n/o/p/q\", URLUtils.getParentPath(\"/", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "26951044_44", "part": [1, 1], "seq": [1, 1], "prompt": "class ListValue extends PropertyValue {\n\n    public int getIndex(PropertyValue member) {\n        return this.list.indexOf(member);\n    }\n\n      ListValue(String key);\n\n    @Override public ValueType getValueType();\n    @Override public int getSize();\n    @Override public Iterator<PropertyValue> iterator();\n    public ListValue addPropertyValue(PropertyValue value);\n    public ListValue addValue(String value);\n    public ListValue addValues(String... values);\n    public ObjectValue addObject();\n    public ListValue addList();\n    public String getValue(int index);\n    public PropertyValue getPropertyValue(int n);\n    public List<ObjectValue> getObjects(String name);\n    public List<ListValue> getLists(String name);\n    public List<ListValue> getLists();\n    public List<PropertyValue> getPropertyValues(String name);\n    @Override public ObjectValue toObjectValue();\n    @Override public ListValue toListValue();\n    public String getValue();\n    @Override public PropertyValue setValue(String value);\n    @Override public ListValue mutable();\n    @Override protected ListValue deepClone();\n    @Override public boolean equals(Object o);\n    private String generateListKey();\n    @Override public int hashCode();\n    @Override public String toString();\n    public static ListValue from(Collection<PropertyValue> values);\n\n}\n\nclass ListValueTest {\n\n    @Test\n    public void getIndex() {\n", "reference": "        ListValue lv = PropertyValue.createList();\n        PropertyValue val = new PropertyValue(  \"k\", \"v\");\n        lv.addPropertyValue(val);\n        PropertyValue val2 = new PropertyValue(  \"k2\", \"v2\");\n        lv.addPropertyValue(val2);\n        assertThat(0).isEqualTo(lv.getIndex(val));\n        assertThat(1).isEqualTo(lv.getIndex(val2));\n        PropertyValue val3 = new PropertyValue(  \"k3\", \"v\");\n        assertThat(-1).isEqualTo(lv.getIndex(val3));\n    }\n\n}", "prediction": "        ListValue list = new ListValue(\"key\");\n        list.addValue(\"value1\");\n        list.addValue(\"value2\");\n        assertEquals(0, list.getIndex(new StringValue(\"value1\")));\n        assertEquals(1, list.getIndex(new StringValue(\"value2\")));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "27187107_4", "part": [1, 1], "seq": [1, 1], "prompt": "class ZkBasedTreeNodeResource implements Closeable {\n\n    @Override\n    public void close() {\n        synchronized (lock) {\n            if (resource != null && cleanup != null) {\n                cleanup.test(resource);\n            }\n            if (treeCache != null) {\n                treeCache.close();\n            }\n            closed = true;\n        }\n    }\n\n    private  ZkBasedTreeNodeResource(Builder<T> builder);\n\n    public static Builder<T> newBuilder();\n    private void ensureTreeCacheReady();\n    public T get();\n    private void checkClosed();\n    private void cleanup(T currentResource, T oldResource);\n    public boolean isClosed();\n    private T doFactory();\n    private void generateFullTree(Map<String, ChildData> map, TreeCache cache, String rootPath);\n\n    private static final Logger logger;\n\n}\n\nclass ZkBasedTreeNodeResourceTest  {\n\n    private static final Logger logger;\n\n    @Test\n    void testClose() {\n", "reference": "        ZkBasedTreeNodeResource<Map<String, String>> tree = ZkBasedTreeNodeResource\n                .<Map<String, String>> newBuilder()\n                .curator(curatorFramework)\n                .path(\"/test\")\n                .factory(p -> p.entrySet().stream()\n                        .collect(toMap(Entry::getKey, e -> new String(e.getValue().getData()))))\n                .build();\n        System.out.println(tree.get());\n        tree.close();\n        assertThrows(IllegalStateException.class, tree::get);\n    }\n\n}", "prediction": "        ZkBasedTreeNodeResource<String> resource = ZkBasedTreeNodeResource.<String>newBuilder()\n                .withZkClient(zkClient)\n                .withPath(\"/test\")\n                .withFactory(() -> \"test\")\n                .withCleanup(resource -> {\n                    logger.info(\"cleanup resource: {}\", resource);\n                })\n                .build();\n\n        resource.get();\n        resource.close();\n        assertThrows(IllegalStateException.class, resource::get);\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "27244573_56", "part": [1, 1], "seq": [1, 1], "prompt": "class TherionImporter extends Importer {\n\n    public static List<String> getContentsOfBeginEndBlock(List<String> lines, String tag)\n            throws Exception {\n\n        boolean foundStartBlock = false;\n        boolean foundEndBlock = false;\n        String endTag = \"end\" + tag;\n\n        List<String> contents = new ArrayList<>();\n\n        for (String line : lines) {\n            line = line.trim();\n\n            if (line.equals(tag)) {\n                if (foundStartBlock) {\n                    throw new Exception(\"Opening block tag \" + tag + \" encountered twice\");\n                } else {\n                    foundStartBlock = true;\n                    continue;\n                }\n\n            } else if (line.equals(endTag)) {\n                if (foundStartBlock) {\n                    foundEndBlock = true;\n                    break;\n                } else {\n                    throw new Exception(\"End block tag \" + endTag + \" encountered before block start\");\n                }\n\n            } else if (!foundStartBlock) {\n                continue;\n            }\n\n            contents.add(line);\n        }\n\n        if (!foundStartBlock) {\n            throw new Exception(\"Failed to find opening block tag \" + tag);\n        } else if (!foundEndBlock) {\n            throw new Exception(\"Failed to find end block tag \" + endTag);\n        }\n\n        return contents;\n    }\n\n    public Survey toSurvey(File directory);\n    private static Survey parseTh(File file);\n    public static String getSurveyName(File file);\n    public boolean canHandleFile(File directory);\n    public static void updateCentreline(List<String> lines, Survey survey);\n    private static void handleElevationDirectionData(List<String> lines, Survey survey);\n\n    private static final String FAKE_POCKETTOPO_TEXT;\n    private static String FAKE_TEXT;\n    private static final List<String> LINES;\n\n}\n\nclass TherionImporterTest {\n\n    private static final String FAKE_POCKETTOPO_TEXT;\n    private static String FAKE_TEXT;\n    private static final List<String> LINES;\n\n    @Test(expected=Exception.class)\n    public void testBlockExtractionFailsIfTwoOpeningTags() throws Exception {\n", "reference": "        List<String> LINES = Arrays.asList(\"block\", \"blah\", \"block\", \"blah\", \"endblock\");\n        TherionImporter.getContentsOfBeginEndBlock(LINES, \"block\");\n    }\n\n}", "prediction": "        TherionImporter.getContentsOfBeginEndBlock(LINES, \"fake\");\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "27323134_39", "part": [1, 1], "seq": [1, 1], "prompt": "class GetEncoderList extends UseCase {\n\n    @Override\n    public Observable buildUseCaseObservable() {\n        return this.dvrRepository.encoders();\n    }\n\n    @Inject public  GetEncoderList( DvrRepository dvrRepository, ThreadExecutor threadExecutor, PostExecutionThread postExecutionThread );\n\n    private GetEncoderList getEncoderList;\n    @Mock\n    private ThreadExecutor mockThreadExecutor;\n    @Mock\n    private PostExecutionThread mockPostExecutionThread;\n    @Mock\n    private DvrRepository mockDvrRepository;\n\n}\n\nclass GetEncoderListTest {\n\n    private GetEncoderList getEncoderList;\n    @Mock\n    private ThreadExecutor mockThreadExecutor;\n    @Mock\n    private PostExecutionThread mockPostExecutionThread;\n    @Mock\n    private DvrRepository mockDvrRepository;\n\n    @Test\n    public void testGetEncoderListUseCaseObservableHappyCase() {\n", "reference": "\n        getEncoderList.buildUseCaseObservable();\n\n        verify( mockDvrRepository ).encoders();\n        verifyNoMoreInteractions( mockDvrRepository );\n        verifyZeroInteractions( mockThreadExecutor );\n        verifyZeroInteractions( mockPostExecutionThread );\n\n    }\n\n}", "prediction": "        when(mockDvrRepository.encoders()).thenReturn(Observable.just(new ArrayList<Encoder>()));\n\n        getEncoderList.buildUseCaseObservable().test().assertValue(new ArrayList<Encoder>());\n\n        verify(mockDvrRepository).encoders();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "28178086_286", "part": [1, 1], "seq": [1, 1], "prompt": "class Matrix implements Cloneable {\n\n    public void copy(Matrix C) {\n        System.arraycopy(C.data_, 0, data_, 0, data_.length);\n    }\n\n    public  Matrix(final double[] data, final int nrows, final int ncols);\n    public  Matrix(final int nrows, final int ncols);\n    public  Matrix(final SubMatrix sm);\n\n    public static Matrix diagonal(final double[] d);\n    public static Matrix diagonal(final IReadDataBlock d);\n    public static Matrix diff(int n, int lag, int d);\n    public static Matrix diff(int n, Polynomial D);\n    public static Matrix identity(final int n);\n    public static Matrix square(final int n);\n    public static Matrix select(SubMatrix m, boolean[] rsel, boolean[] csel);\n    public static Matrix select(SubMatrix m, int[] rsel, int[] csel);\n    public static Matrix selectRows(SubMatrix m, boolean[] rsel);\n    public static Matrix selectRows(SubMatrix m, int[] rsel);\n    public static Matrix selectColumns(SubMatrix m, boolean[] csel);\n    public static Matrix selectColumns(SubMatrix m, int[] csel);\n    public void add(final double r);\n    public void add(final int row, final int col, final double val);\n    public void add(final Matrix M);\n    public void chs();\n    public void clean(double epsilon);\n    public void clear();\n    @Override public Matrix clone();\n    public DataBlock column(final int col);\n    public List<DataBlock> columnList();\n    public DataBlockIterator columns();\n    public void copyTo(final double[] buffer, final int start);\n    public DataBlock diagonal();\n    public DataBlock subDiagonal(int pos);\n    public DataBlock skewDiagonal(int pos);\n    public double get(final int row, final int col);\n    public int getColumnsCount();\n    public int getRowsCount();\n    public double[] internalStorage();\n    public boolean isZero(double eps);\n    public boolean isDiagonal(double eps);\n    public boolean isZero();\n    public boolean isDiagonal();\n    public boolean isSquare();\n    public Matrix minus(final double r);\n    public Matrix minus(final Matrix Y);\n    public void mul(final double r);\n    public void mul(final int row, final int col, final double val);\n    public double nrm2();\n    public Matrix plus(final double r);\n    public Matrix plus(final Matrix Y);\n    public void randomize();\n    public void randomize(int seed);\n    public DataBlock row(final int row);\n    public List<DataBlock> rowList();\n    public DataBlockIterator rows();\n    public void set(double value);\n    public void set(final int row, final int col, final double value);\n    public void set(MatrixFunction fn);\n    public void set(MatrixRelativeFunction fn);\n    public void add(MatrixFunction fn);\n    public void add(MatrixRelativeFunction fn);\n    public double ssq();\n    public void sub(final double r);\n    public void sub(final Matrix M);\n    public SubMatrix all();\n    @Deprecated public SubMatrix subMatrix();\n    public SubMatrix subMatrix(final int r0, final int r1, final int c0,\n            final int c1);\n    public double sum();\n    public Matrix times(final double r);\n    public Matrix times(final Matrix Y);\n    public double dot(Matrix m);\n    public static Matrix rsolve(SubMatrix S, SubMatrix B);\n    public static Matrix lsolve(SubMatrix S, SubMatrix B);\n    public void toLower();\n    public void toUpper();\n    public Matrix transpose();\n    public void addAY(double a, Matrix Y);\n    public void addXaXt(double a, DataBlock x);\n    public void addXaYt(double a, DataBlock x, DataBlock y);\n    public boolean isEmpty();\n    @Override public String toString();\n    public String toString(String fmt);\n    @Override public boolean equals(Object obj);\n    public boolean equals(Matrix other);\n    public boolean equals(Matrix other, double eps);\n    @Override public int hashCode();\n    public int rank();\n    public void permuteColumns(final int i, final int j);\n    public void permuteRows(final int i, final int j);\n    public double distance(Matrix m);\n    public void smooth(double eps);\n    public SubMatrix topLeft();\n    public SubMatrix topLeft(int nr, int nc);\n    public SubMatrix bottomRight();\n    public SubMatrix bottomRight(int nr, int nc);\n\n}\n\nclass MatrixTest {\n\n    @Test\n    public void testcopy() {\n", "reference": "        Matrix M = new Matrix(11, 10);\n        M.randomize();\n        boolean[] rsel = new boolean[M.getRowsCount()];\n        boolean[] csel = new boolean[M.getColumnsCount()];\n        for (int i = 0; i < rsel.length; ++i) {\n            if (i % 3 == 0) {\n                rsel[i] = true;\n            }\n        }\n        for (int i = 0; i < csel.length; ++i) {\n            if (i % 2 == 0) {\n                csel[i] = true;\n            }\n        }\n        Matrix M2 = M.clone();\n\n        int[] irsel = new int[]{1, 2, 3, 5};\n        int[] icsel = new int[]{1, 3, 5, 8};\n\n        Matrix mr = Matrix.selectRows(M.subMatrix(), rsel);\n        M2.subMatrix().copyRows(mr.subMatrix(), rsel);\n        assertTrue(M2.equals(M));\n\n        Matrix mc = Matrix.selectColumns(M.subMatrix(), csel);\n        M2.subMatrix().copyColumns(mc.subMatrix(), csel);\n        assertTrue(M2.equals(M));\n\n        Matrix m = Matrix.select(M.subMatrix(), rsel, csel);\n        M2.subMatrix().copy(m.subMatrix(), rsel, csel);\n        assertTrue(M2.equals(M));\n\n        mr = Matrix.selectRows(M.subMatrix(), irsel);\n        M2.subMatrix().copyRows(mr.subMatrix(), irsel);\n        assertTrue(M2.equals(M));\n\n        mc = Matrix.selectColumns(M.subMatrix(), icsel);\n        M2.subMatrix().copyColumns(mc.subMatrix(), icsel);\n        assertTrue(M2.equals(M));\n\n        m = Matrix.select(M.subMatrix(), irsel, icsel);\n        M2.subMatrix().copy(m.subMatrix(), irsel, icsel);\n        assertTrue(M2.equals(M));\n    }\n\n}", "prediction": "        Matrix m = new Matrix(new double[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }, 3, 3);\n        Matrix m2 = new Matrix(new double[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }, 3, 3);\n        m.copy(m2);\n        assertEquals(m, m2);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "28752850_14", "part": [1, 1], "seq": [1, 1], "prompt": "class Timepoint implements Parcelable, Comparable<Timepoint> {\n\n    public boolean isAM() {\n        return hour < 12;\n    }\n\n    public  Timepoint(Timepoint time);\n    public  Timepoint(@IntRange(from=0, to=23) int hour,\n                     @IntRange(from=0, to=59) int minute,\n                     @IntRange(from=0, to=59) int second);\n    public  Timepoint(@IntRange(from=0, to=23) int hour,\n                     @IntRange(from=0, to=59) int minute);\n    public  Timepoint(@IntRange(from=0, to=23) int hour);\n    public  Timepoint(Parcel in);\n\n    @IntRange(from=0, to=23) public int getHour();\n    @IntRange(from=0, to=59) public int getMinute();\n    @IntRange(from=0, to=59) public int getSecond();\n    public boolean isPM();\n    public void setAM();\n    public void setPM();\n    public void add(TYPE type, int value);\n    public int get(@NonNull TYPE type);\n    public int toSeconds();\n    @Override public int hashCode();\n    @Override public boolean equals(Object o);\n    public boolean equals(@Nullable Timepoint time, @NonNull TYPE resolution);\n    @Override public int compareTo(@NonNull Timepoint t);\n    @Override public void writeToParcel(Parcel out, int flags);\n    @Override public int describeContents();\n    @Override public String toString();\n\n}\n\nclass TimepointTest {\n\n    @Test\n    public void isAMShouldReturnFalseIfTimepointIsAfterMidday() {\n", "reference": "        Timepoint timepoint = new Timepoint(13);\n        Assert.assertFalse(timepoint.isAM());\n    }\n\n}", "prediction": "        Timepoint time = new Timepoint(13, 0, 0);\n        assertFalse(time.isAM());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "28835543_0", "part": [1, 1], "seq": [1, 1], "prompt": "class Chatroom extends AbstractActor {\n\n    public List<Messages.PostToChatroom> joinChatroom(Messages.JoinChatroom msg) {\n        joinedUsers.add(msg.userRef);\n        return chatHistory;\n    }\n\n    @Override public PartialFunction<Object, BoxedUnit> receive();\n\n    static ActorSystem system;\n\n}\n\nclass ChatroomTest extends AbstractActor {\n\n    static ActorSystem system;\n\n    @Test\n    public void testShouldAddUserToJoinedUsersWhenJoiningUnitTest() {\n", "reference": "        Props props = Props.create(Chatroom.class);\n        TestActorRef<Chatroom> ref = TestActorRef.create(system, props);\n        Chatroom chatroom = ref.underlyingActor();\n\n        UserRef userRef = new UserRef(system.deadLetters(), \"user\");\n        Messages.JoinChatroom request = new Messages.JoinChatroom(userRef);\n        chatroom.joinChatroom(request);\n\n        assertEquals(chatroom.joinedUsers.get(0), userRef);\n    }\n\n}", "prediction": "        ActorRef chatroom = system.actorOf(Props.create(Chatroom.class));\n        ActorRef user = system.actorOf(Props.create(User.class));\n        chatroom.tell(new Messages.JoinChatroom(user), ActorRef.noSender());\n        assertTrue(chatroom.underlyingActor().joinedUsers.contains(user));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "28896975_1", "part": [1, 1], "seq": [1, 1], "prompt": "class DownloadManager {\n\n  public int add(DownloadRequest request) {\n    request = checkNotNull(request, \"request == null\");\n    if (isDownloading(request.uri().toString())) {\n      return -1;\n    }\n\n    request.context(context);\n    request.downloader(downloader.copy());\n\n    /* add download request into download request queue */\n    return downloadRequestQueue.add(request) ? request.downloadId() : -1;\n  }\n\n    DownloadManager(Builder builder);\n\n  public DownloadState query(int downloadId);\n   DownloadState query(String url);\n  public boolean isDownloading(int downloadId);\n  public boolean isDownloading(String url);\n  public int getTaskSize();\n  public boolean cancel(int downloadId);\n  public void cancelAll();\n  public void release();\n  public Builder newBuilder();\n\n  private MockWebServer mockWebServer;\n  private DownloadManager downloadManager;\n  private DownloadRequest request;\n\n}\n\nclass DownloadManagerTest {\n\n  private MockWebServer mockWebServer;\n  private DownloadManager downloadManager;\n  private DownloadRequest request;\n\n  @Test public void testDuplicate() throws Exception {\n", "reference": "    int downloadId = downloadManager.add(request);\n    assertEquals(1, downloadId);\n    int downloadId2 = downloadManager.add(request);\n    assertEquals(-1, downloadId2);\n  }\n\n}", "prediction": "    assertThat(downloadManager.add(request)).isEqualTo(request.downloadId());\n    assertThat(downloadManager.add(request)).isEqualTo(-1);\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "29186921_2", "part": [1, 1], "seq": [1, 1], "prompt": "class PriceSpikePredicate extends AbstractAdviserPredicate {\n\n  @Override\n  public boolean apply(PriceTick priceTick) {\n    if (barOpenTimestamp <= 0 || priceTick.getTimestamp() > barCloseTimestamp) {\n      prepareNewBar(priceTick);\n      return false;\n    }\n    final double pipsVariation = getPricePips(\n        priceTick.getClosePriceAsk() - openPriceAsk, priceMinimalDecimalPosition);\n    if (pipsVariation >= minimumPips && ! eventDispatched) {\n      eventDispatched = true;\n      return true;\n    }\n    return false;\n  }\n\n  public  PriceSpikePredicate(PredicateExecutionContext predicateExecutionContext);\n\n  @Override public void init();\n  private void prepareNewBar(PriceTick priceTick);\n\n  private static final Map<String, String> PROPERTIES;\n\n}\n\nclass PriceSpikePredicateTest {\n\n  private static final Map<String, String> PROPERTIES;\n\n  @Test\n  public void testPredicateTriggeredEURUSD() throws Exception {\n", "reference": "    Iterable<PriceTick> priceTicks = TestingPriceFactory.createPriceTicks(\n        TestingConstants.INSTRUMENT_EURUSD_ID,\n        Range.closed(\n            TestingConstants.DEFAULT_START_DATE.getMillis(),\n            TestingConstants.DEFAULT_START_DATE.plusMinutes(1).getMillis()),\n        Range.closed(1.23101, 1.23211),\n        1);\n    PriceSpikePredicate priceSpikePredicate =\n        createPriceSpikePredicate(TestingConstants.INSTRUMENT_EURUSD_ID);\n    for (PriceTick priceTick : priceTicks) {\n      if (priceSpikePredicate.apply(priceTick)) {\n        return;\n      }\n    }\n    fail(\"Predicate not triggered.\");\n  }\n\n}", "prediction": "    final PriceTick priceTick = new PriceTick(\n        \"EURUSD\",\n        \"20180101\",\n        \"15:00:00\",\n        1.12345,\n        1.12346,\n        1.12347,\n        1.12348,\n        1.12349,\n        1.12350,\n        1.12351,\n        1.12352,\n        1.12353,\n        1.12354,\n        1.12355,\n        1.12356,\n        1.12357,\n        1.12358,\n        1.12359,\n        1.12360,\n        1.12361,\n        1.12362,\n        1.12363,\n        1.12364,\n        1.12365,\n        1.12366,\n        1.12367,\n        1.12368,\n        1.12369,\n        1.12370,\n        1.12371,\n        1.12372,\n        1.12373,\n        1.12374,\n        1.12375,\n        1.12376,\n        1.12377,\n        1.12378,\n        1.12379,\n        1.12380,\n        1.12381,\n        1.12382,\n        1.12383,\n        1.12384,\n        1.12385,\n        1.12386,\n        1.12387,\n        1.12388,\n        1.12389,\n        1.12390,\n        1.12391,\n        1.12392,\n        1.12393,\n        1.12394,\n        1.12395,\n        1.12396,\n        1.12397,\n        1.12398,\n        1.12399,\n        1.12400,\n        1.12401,\n        1.12402,\n        1.12403,\n        1.12404,\n        1.12405,\n        1.12406,\n        1.12407,\n        1.12408,\n        1.12409,\n        1.12410,\n        1.12411,\n        1.12412,\n        1.12413,\n        1.12414,\n        1.12415,\n        1.12416,\n        1.12417,\n        1.12418,\n        1.12419,\n        1.12420,\n        1.12421,\n        1.12422,\n        1.12423,\n        1.12424,\n        1.12425,\n        1.12426,\n        1.12427,\n        1.12428,\n        1.12429,\n        1.12430,\n        1.12431,\n        1.12432,\n        1.12433,\n        1.12434,\n        1.12435,\n        1.12436,\n        1.12437,\n        1.12438,\n        1.12439,\n        1.12440,\n        1.12441,\n        1.12442,\n        1.12443,\n        1.12444,\n        1.12445,\n        1.12446,\n        1.12447,\n        1.12448,\n        1.12449,\n        1.12450,\n        1.12451,\n        1.12452,\n        1.12453,\n        1.12454,\n        1.12455,\n        1.12456,\n        1.12457,\n        1.12458,\n        1.12459,\n        1.12460,\n        1.12461,\n        1.12462,\n        1.12463,\n        1.12464,\n        1.12465,\n        1.12466,\n        1.12467,\n        1.12468,\n        1.12469,\n        1.12470,\n        1.12471,\n        1.12472,\n        1.12473,\n        1.12474,\n        1.12475,\n        1.12476,\n        1.12477,\n        1.12478,\n        1.12479,\n        1.12480,\n        1.12481,\n        1.12482,\n        1.12483,\n        1.12484,\n        1.12485,\n        1.12486,\n        1.12487,\n        1.12488,\n        1.12489,\n        1.12490,\n        1.12491,\n        1.12492,\n        1.12493,\n        1.12494,\n        1.12495,\n        1.12496,\n        1.12497,\n        1.12498,\n        1.12499,\n        1.12500,\n        1.12501,\n        1.12502", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "29603649_809", "part": [1, 1], "seq": [1, 1], "prompt": "class ChangeStatusCommand implements StubDescriptorModificationCommand {\n\n    @Override\n    public Map<String, StubDescriptor> modify(Map<String, StubDescriptor> stubDescriptors) {\n        Map<String, StubDescriptor> updated = new LinkedHashMap<>(stubDescriptors);\n        StubDescriptor selected = updated.get(groupName);\n        if (selected != null) {\n            StubDescriptorAttributes attributes = selected.getAttributes();\n            attributes.setActive(nextStatus);\n            if (nextStatus) {\n                logger.info(urlAccessLogMessageAssembler.assembleMessage(request, groupName + \" stub configuration: Enabled\"));\n            } else {\n                logger.info(urlAccessLogMessageAssembler.assembleMessage(request, groupName + \" stub configuration: Disabled\"));\n            }\n        }\n        return updated;\n    }\n\n    public  ChangeStatusCommand(final boolean nextStatus, final String groupName, final HttpServletRequest request,\n            final UrlAccessLogMessageAssembler urlAccessLogMessageAssembler);\n\n    public String getGroupName();\n    public HttpServletRequest getRequest();\n    public boolean isNextStatus();\n\n    private static final String GROUPNAME_FIRST;\n    private Map<String, StubDescriptor> normalStubDescriptors;\n    private StubDescriptorAttributes attributes;\n    private StubDescriptor stubDescriptor;\n    @Mock\n    private HttpServletRequest request;\n    @Mock\n    private UrlAccessLogMessageAssembler urlAccessLogMessageAssembler;\n    private ChangeStatusCommand underTest;\n\n}\n\nclass ChangeStatusCommandTest {\n\n    private static final String GROUPNAME_FIRST;\n    private Map<String, StubDescriptor> normalStubDescriptors;\n    private StubDescriptorAttributes attributes;\n    private StubDescriptor stubDescriptor;\n    @Mock\n    private HttpServletRequest request;\n    @Mock\n    private UrlAccessLogMessageAssembler urlAccessLogMessageAssembler;\n    private ChangeStatusCommand underTest;\n\n    @Test\n    public void testSetStatusShouldDisableTheSelectedStubDescriptor() {\n", "reference": "        //GIVEN in setUp\n        normalStubDescriptors = new LinkedHashMap<>();\n        attributes = new StubDescriptorAttributes(GROUPNAME_FIRST, true);\n        stubDescriptor = new StubDescriptor(attributes, new ArrayList<DialogDescriptor>(), new ArrayList<InterceptorDescriptor>(), null);\n        normalStubDescriptors.put(GROUPNAME_FIRST, stubDescriptor);\n        //WHEN\n        underTest = new ChangeStatusCommand(false, GROUPNAME_FIRST, request, urlAccessLogMessageAssembler);\n        Map<String, StubDescriptor> result = underTest.modify(normalStubDescriptors);\n        //THEN\n        StubDescriptor resultDescriptor = result.get(GROUPNAME_FIRST);\n        Assert.assertNotNull(resultDescriptor);\n        boolean resultAttribute = resultDescriptor.getAttributes().isActive();\n        Assert.assertFalse(resultAttribute);\n    }\n\n}", "prediction": "        // given\n        underTest = new ChangeStatusCommand(false, GROUPNAME_FIRST, request, urlAccessLogMessageAssembler);\n        // when\n        Map<String, StubDescriptor> updated = underTest.modify(normalStubDescriptors);\n        // then\n        assertThat(updated.get(GROUPNAME_FIRST).getAttributes().isActive(), is(false));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "29774200_74", "part": [1, 1], "seq": [1, 1], "prompt": "class TeamCityConnection implements BuildCapability, TestCapability, ViewCapability {\n\n    @Override\n    public String getMavenId(SoftwareProjectId softwareProjectId) throws ProjectNotFoundException,\n            MavenIdNotFoundException {\n        checkConnected();\n        checkSoftwareProjectId(softwareProjectId);\n        String projectId = softwareProjectId.getProjectId();\n        try {\n            return teamCity.findMavenId(projectId);\n        } catch (fr.norad.visuwall.providers.common.MavenIdNotFoundException e) {\n            throw new MavenIdNotFoundException(\"Cannot find maven id for \" + softwareProjectId, e);\n        }\n    }\n\n    @Override public void connect(String url, String login, String password);\n    @Override public void close();\n    @Override public String getDescription(SoftwareProjectId softwareProjectId);\n    @Override public SoftwareProjectId identify(ProjectKey projectKey);\n    @Override public List<String> getBuildIds(SoftwareProjectId softwareProjectId);\n    @Override public Map<SoftwareProjectId, String> listSoftwareProjectIds();\n    @Override public BuildState getBuildState(SoftwareProjectId softwareProjectId, String buildId);\n    @Override public Date getEstimatedFinishTime(SoftwareProjectId softwareProjectId, String buildId);\n    @Override public boolean isBuilding(SoftwareProjectId softwareProjectId, String buildId);\n    @Override public String getLastBuildId(SoftwareProjectId softwareProjectId);\n    @Override public String getName(SoftwareProjectId softwareProjectId);\n    @Override public boolean isClosed();\n    @Override public BuildTime getBuildTime(SoftwareProjectId softwareProjectId, String buildId);\n    @Override public boolean isProjectDisabled(SoftwareProjectId softwareProjectId);\n    @Override public List<Commiter> getBuildCommiters(SoftwareProjectId softwareProjectId, String buildId);\n    @Override public TestResult analyzeUnitTests(SoftwareProjectId softwareProjectId);\n    @Override public TestResult analyzeIntegrationTests(SoftwareProjectId softwareProjectId);\n    private void addBuildIds(Set<String> numbers, TeamCityBuildType buildType);\n    private void checkBuildId(String buildId);\n    private void checkConnected();\n    private void checkSoftwareProjectId(SoftwareProjectId softwareProjectId);\n    @Override public List<SoftwareProjectId> findSoftwareProjectIdsByViews(List<String> views);\n    @Override public List<String> findViews();\n    @Override public List<String> findProjectNamesByView(String viewName);\n    private void checkViewName(String viewName);\n\n     TeamCityConnection teamCityConnection;\n    @Mock TeamCity teamCity;\n\n}\n\nclass TeamCityConnectionTest {\n\n     TeamCityConnection teamCityConnection;\n    @Mock TeamCity teamCity;\n\n    @Test\n    public void should_throw_exception_when_getting_maven_id() throws Exception {\n", "reference": "        SoftwareProjectId softwareProjectId = softwareProjectId();\n        String projectId = softwareProjectId.getProjectId();\n        when(teamCity.findMavenId(projectId)).thenReturn(\"groupId:artifactId\");\n\n        String mavenId = teamCityConnection.getMavenId(softwareProjectId);\n\n        assertEquals(\"groupId:artifactId\", mavenId);\n    }\n\n}", "prediction": "        SoftwareProjectId softwareProjectId = new SoftwareProjectId(\"projectId\", \"projectName\");\n        when(teamCity.findMavenId(\"projectId\")).thenThrow(new fr.norad.visuwall.providers.common.MavenIdNotFoundException(\"\"));\n        try {\n            teamCityConnection.getMavenId(softwareProjectId);\n            fail(\"Should have thrown exception\");\n        } catch (MavenIdNotFoundException e) {\n            assertThat(e.getMessage(), is(\"Cannot find maven id for \" + softwareProjectId));\n        }\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "29929519_5", "part": [1, 1], "seq": [1, 1], "prompt": "class Schema {\n\n\tpublic SchemaVersion getVersion() {\n\t\treturn version;\n\t}\n\n\tpublic static Schema build(String path);\n\tpublic void save(OutputStream os);\n\tpublic Collection<Type> getTypes();\n\tpublic Collection<UserType> getUserTypes();\n\tpublic Type findType(String idOrName);\n\tpublic Collection<Type> getDerivedTypes(String baseTypeId,\n\t\t\tboolean directOnly);\n\tpublic Collection<Type> getDerivedTypes(Type baseType,\n\t\t\tboolean directOnly);\n\tprivate Set<Type> getDerivedTypes(Type type, boolean directOnly,\n\t\t\tjava.util.Map<Type, Set<Type>> derivedTypeMap);\n\tprivate java.util.Map<Type, Set<Type>> createDerivedMap();\n\n}\n\nclass SchemaTest {\n\n\t@Test\n\tpublic void schemaVersionNameTest() throws URISyntaxException,\n\t\t\tTeslaSchemaException, NoSuchAlgorithmException, SAXException,\n\t\t\tIOException, ParserConfigurationException {\n", "reference": "\t\tSchema schema = parseSchema(\"src/test/resources/versionname.tml\");\n\t\tassertNotNull(schema);\n\t\tassertTrue(schema.getVersion().getName()\n\t\t\t\t.contains(\"#versionname#\"));\n\t}\n\n}", "prediction": "\n\t\tSchema schema = Schema.build(getClass().getResource(\n\t\t\t\t\"/schema/schema.xml\").toURI());\n\t\tassertEquals(\"1.0\", schema.getVersion().getName());\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "29952888_47", "part": [1, 1], "seq": [1, 1], "prompt": "class BlobsServiceImpl implements BlobsService {\n\n    @Override\n    public List<Entity> extractEntitiesFromBlob(BlobKey blobKey) {\n        JsonReader jsonReader = jsonBlobReaderFactory.create(blobKey);\n\n        return gson.fromJson(jsonReader, new TypeToken<List<Entity>>() {\n        }.getType());\n    }\n\n    @Inject  BlobsServiceImpl(\n            BlobInfoFactory blobInfoFactory,\n            JsonBlobReaderFactory jsonBlobReaderFactory,\n            Gson gson);\n\n    @Override public Iterator<BlobInfo> getAllBlobInfos();\n\n    @Inject BlobsService blobsService;\n    @Inject BlobGenerator blobGenerator;\n\n}\n\nclass BlobsServiceImplTest  {\n\n    @Inject BlobsService blobsService;\n    @Inject BlobGenerator blobGenerator;\n\n    @Test\n    public void extractEntitiesFromBlob() throws Exception {\n", "reference": "        // given\n        BlobKey blobKey = createCarBlob();\n\n        // when\n        List<Entity> entities = blobsService.extractEntitiesFromBlob(blobKey);\n\n        // then\n        assertEquals(1, entities.size());\n    }\n\n}", "prediction": "        BlobKey blobKey = blobGenerator.generateBlob(new ArrayList<Entity>());\n\n        List<Entity> entities = blobsService.extractEntitiesFromBlob(blobKey);\n\n        assertThat(entities).isEmpty();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "30619741_23", "part": [1, 1], "seq": [1, 1], "prompt": "class ClusterMicroserviceProvider implements MicroserviceProvider, ClusterSilverService {\n\n   @Override\n   public Set<Object> lookupMicroservice(final MicroserviceMetaData metaData) {\n      try {\n         Set<Address> addressesForMetadata = alreadyQueriedAddresses.getOrDefault(metaData, new HashSet<>());\n         this.sender.sendToClusterAsync(metaData, addressesForMetadata,\n               new FutureListenerHelper<MicroserviceSearchResponse>(rspList -> {\n                  try {\n                     RspList<MicroserviceSearchResponse> responseRspList = rspList.get(10, TimeUnit.SECONDS);\n                     log.info(\"Response retrieved!  {}\", responseRspList);\n                     Collection<Rsp<MicroserviceSearchResponse>> result = responseRspList.values();\n                     if (log.isTraceEnabled()) {\n                        log.trace(\"Size of a responses is : {} \", responseRspList.getResults().size());\n                     }\n                     result.stream().filter(Rsp::hasException).forEach(rsp -> log.error(\"Exception was thrown during lookup on node: \" + rsp.getSender(), rsp.getException()));\n\n                     Set<ServiceHandle> remoteServiceHandles = result.stream()\n                                                                     .filter(rsp -> rsp.wasReceived() && !rsp.hasException() && rsp.getValue().getResult().canBeUsed())\n                                                                     .map((rsp) -> new RemoteServiceHandle(rsp.getSender(), rsp.getValue().getHandle(), sender, metaData))\n                                                                     .collect(Collectors.toSet());\n                     // this is to save jgroups traffic for a given metadata\n                     addressesForMetadata.addAll(responseRspList.values().stream().map(Rsp::getSender).collect(Collectors.toSet()));\n                     alreadyQueriedAddresses.put(metaData, addressesForMetadata);\n                     this.remoteServiceHandlesStore.addHandles(metaData, remoteServiceHandles);\n                  } catch (Throwable e) {\n                     log.error(\"Error while looking up microservices.\", e);\n                  }\n\n               }));\n         // If this is first query for the metadata we should wait for a response\n         if (addressesForMetadata.isEmpty() && !sender.isEmptyCluster()) {\n            Thread.sleep(timeout);\n         }\n\n         return this.remoteServiceHandlesStore.getServices(metaData);\n      } catch (Throwable e) {\n         log.error(\"Error while looking up microservices.\", e);\n         return emptySet();\n      }\n   }\n\n   @Override public void initialize(final Context context);\n   @Override public Context getContext();\n   @Override public void run();\n   @Override public Set<Object> lookupLocalMicroservice(final MicroserviceMetaData metaData);\n\n   public static final RemoteServiceHandlesStore REMOTE_SERVICE_HANDLES_STORE;\n   @Tested\n   private ClusterMicroserviceProvider clusterMicroserviceProvider;\n   @Injectable\n   private RemoteServiceHandlesStore store;\n   @Injectable\n   private JgroupsMessageSender sender;\n\n}\n\nclass ClusterMicroserviceProviderTest {\n\n   public static final RemoteServiceHandlesStore REMOTE_SERVICE_HANDLES_STORE;\n   @Tested\n   private ClusterMicroserviceProvider clusterMicroserviceProvider;\n   @Injectable\n   private RemoteServiceHandlesStore store;\n   @Injectable\n   private JgroupsMessageSender sender;\n\n   @Test\n   public void testLookupMicroservice() throws Exception {\n", "reference": "      Set<ServiceHandle> mockHandles = Util.createSetFrom(Util.createHandle(1), Util.createHandle(2));\n      Set<Object> services = Util.createSetFrom(new Object(), new Object());\n\n      new Expectations() {{\n         sender.sendToClusterAsync(META_DATA, (Set<Address>) any, (FutureListener<RspList<MicroserviceSearchResponse>>) any);\n         times = 1;\n         result = mockHandles;\n         store.getServices(META_DATA);\n         result = services;\n         times = 1;\n\n      }};\n      Set<Object> objects = clusterMicroserviceProvider.lookupMicroservice(META_DATA);\n      assertThat(objects).isNotEmpty().isEqualTo(services);\n   }\n\n}", "prediction": "     MicroserviceMetaData metaData = new MicroserviceMetaData(\"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "30644093_34", "part": [1, 1], "seq": [1, 1], "prompt": "class DefinitionDocumentNameResolver extends DocumentResolver {\n\n    public String apply(String definitionName) {\n        if (config.isSeparatedDefinitionsEnabled())\n            return new File(config.getSeparatedDefinitionsFolder(), markupDocBuilder.addFileExtension(normalizeName(definitionName))).getPath();\n        else\n            return markupDocBuilder.addFileExtension(config.getDefinitionsDocument());\n    }\n\n    public  DefinitionDocumentNameResolver(Swagger2MarkupConverter.SwaggerContext context);\n\n}\n\nclass DefinitionDocumentNameResolverTest {\n\n    @Test\n    public void testWithInterDocumentCrossReferencesAndNoOutputPath() {\n", "reference": "        Swagger2MarkupConfig config = (Swagger2MarkupConfig) new Swagger2MarkupConfigBuilder()\n                .withInterDocumentCrossReferences()\n                .build();\n        Swagger2MarkupConverter.SwaggerContext context = createContext(config);\n\n        assertThat(new DefinitionDocumentNameResolver(context).apply(\"DefinitionName\"))\n                .isEqualTo(\"definitions.adoc\");\n    }\n\n}", "prediction": "        Swagger2MarkupConfig config = new Swagger2MarkupConfigBuilder()\n                .withSeparatedDefinitionsEnabled(true)\n                .build();\n\n        Swagger2MarkupConverter.SwaggerContext context = new Swagger2MarkupConverter.SwaggerContext(config, new Swagger(), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new File(\".\"), new", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "30953541_1", "part": [1, 1], "seq": [1, 1], "prompt": "class PBInstance implements Comparable<PBInstance>, Serializable {\n\n    @Override\n    public String toString() {\n        StringBuilder str = new StringBuilder();\n        str.append(rolesetId+\": \");\n        \n        str.append(predicateNode.getWord()+\"\\n\");\n        \n        for (PBArg arg: args)\n            str.append(arg+\"\\n\");\n        \n        return str.toString();\n    }\n\n    public  PBInstance();\n\n    public TBNode getPredicate();\n    public String getRoleset();\n    public String getVerbnetId();\n    public void setVerbnetId(String verbnetId);\n    public TBTree getTree();\n    public PBArg[] getArgs();\n    public PBArg[] getEmptyArgs();\n    public PBArg[] getAllArgs();\n    public static int[] getNodeId(TBNode node);\n    static void markNode(TBNode node, String[] preMarkup, String[] postMarkup, String pre, String post,  boolean printEC);\n    public static void markArg(PBArg arg, String[] preMarkup, String[] postMarkup, String pre, String post, boolean printEC);\n    public String toText(boolean printEC);\n    public String toText();\n    @Override public int compareTo(PBInstance rhs);\n\n}\n\nclass TestPBInstance {\n\n    @Test\n    public void testPBArg() throws IOException {\n", "reference": "        System.out.println(Arrays.toString(\"19:1*27:0;31:4\".split(\"(?=[\\\\*,;])\")));\n        assertTrue(PBArg.ARG_PATTERN.matcher(\"19:1*27:0-LINK-SLC\").matches());\n        assertFalse(PBArg.ARG_PATTERN.matcher(\"19:1*27:0LINK-SLC\").matches());\n        \n        String treeDir = \"/home/verbs/student/shumin/corpora/ontonotes-release-4.0/data/english/annotations/\";\n        \n        TBReader tbReader = new TBReader(treeDir, false);\n        PBFileReader reader = new PBFileReader(tbReader,\n                \"/home/verbs/student/shumin/corpora/ontonotes-release-4.0/data/english/annotations/nw/wsj/23/wsj_2356.prop\",\n                new OntoNotesTokenizer());\n        List<PBInstance> instances = new ArrayList<PBInstance> ();\n        PBInstance instance=null;\n        try {\n            while ((instance = reader.nextProp())!=null)\n            {\n                instances.add(instance);\n                System.out.println(instance.tree.getFilename()+\" \"+instance.tree.getIndex());\n                System.out.println(instance);\n                System.out.flush();\n            }\n        } catch (PBFormatException e) {\n            System.err.println(instances.size());\n            e.printStackTrace();\n            assertTrue(false);\n        } catch (ParseException e) {\n            System.err.println(instances.size());\n            e.printStackTrace();\n            assertTrue(false);\n        }\n        \n        int instanceNum = instances.size();\n        \n        int iNum = 0;\n        \n        reader = new PBFileReader(new TBReader(treeDir, false),\n                \"/home/verbs/student/shumin/corpora/ontonotes-release-4.0/data/english/annotations/nw/wsj/23/wsj_2356.prop\",\n                new OntoNotesTokenizer());\n \n        while ((instances = reader.nextPropSet())!=null)\n        {\n            System.out.println(\"--------------------------\");\n            iNum += instances.size();\n            for (PBInstance aInstance:instances)\n            {\n                System.out.println(aInstance.tree.getFilename()+\" \"+aInstance.tree.getIndex());\n                System.out.println(aInstance);\n                System.out.flush();\n            }\n        } \n        System.out.println(instanceNum+\" \"+iNum);\n        assertEquals(instanceNum, iNum);\n        \n        iNum = 0;\n        \n        PBReader pbReader = new PBReader(new TBReader(treeDir, false),\n                \"/home/verbs/student/shumin/corpora/ontonotes-release-4.0/data/english/annotations/nw/wsj/23/wsj_2356.prop\",\n                \".+\",\n                new OntoNotesTokenizer());\n \n        while ((instances = pbReader.nextPropSet())!=null)\n        {\n            System.out.println(\"--------------------------\");\n            iNum += instances.size();\n            for (PBInstance aInstance:instances)\n            {\n                System.out.println(aInstance.tree.getFilename()+\" \"+aInstance.tree.getIndex());\n                System.out.println(aInstance);\n                System.out.flush();\n            }\n        } \n        System.out.println(instanceNum+\" \"+iNum);\n        assertEquals(instanceNum, iNum);\n    }\n\n}", "prediction": "       PBArg arg = new PBArg();\n        arg.setArgType(PBArg.ArgType.N);\n        arg.setArgNumber(1);\n        arg.setArgPosition(PBArg.ArgPosition.S);\n        arg.setArgValue(\"test\");\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.ArgValueType.S);\n        arg.setArgValueType(PBArg.Arg", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "30956938_154", "part": [1, 1], "seq": [1, 1], "prompt": "class SpreadsheetImportHealthChecker implements HealthChecker<SpreadsheetImportActivity> {\n\n\tpublic boolean canVisit(Object subject) {\n\t\treturn (subject != null && subject instanceof SpreadsheetImportActivity);\n\t}\n\n\tpublic VisitReport visit(SpreadsheetImportActivity activity, List<Object> ancestors);\n\tpublic boolean isTimeConsuming();\n\n\tprivate SpreadsheetImportHealthChecker healthChecker;\n\tprivate SpreadsheetImportActivity activity;\n\tprivate ArrayList ancestors;\n\n}\n\nclass SpreadsheetImportHealthCheckerTest {\n\n\tprivate SpreadsheetImportHealthChecker healthChecker;\n\tprivate SpreadsheetImportActivity activity;\n\tprivate ArrayList ancestors;\n\n\t@Test\n\tpublic void testCanHandle() {\n", "reference": "\t\tassertTrue(healthChecker.canVisit(activity));\n\t\tassertFalse(healthChecker.canVisit(null));\n\t\tassertFalse(healthChecker.canVisit(\"\"));\n\t}\n\n}", "prediction": "\t\tassertTrue(healthChecker.canVisit(activity));\n\t\tassertFalse(healthChecker.canVisit(new Object()));\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "31758882_0", "part": [1, 1], "seq": [1, 1], "prompt": "class ChannelInput {\n\n    public void read(byte[] dst, int offset, int length) throws IOException {\n        for (; length > 0; ) {\n            int remaining = buffer.remaining();\n            if (length <= remaining) {\n                buffer.get(dst, offset, length);\n                break;\n            }\n            buffer.get(dst, offset, remaining);\n            offset += remaining;\n            length -= remaining;\n            fill();\n        }\n    }\n\n      ChannelInput(FileChannel channel, int position, int bufferSize);\n\n    private void fill();\n    public int position();\n    public void position(int newPosition);\n    public byte readByte();\n    public short readShort();\n    public int readInt();\n    public long readLong();\n    public void skip(int bytes);\n\n   private static File dir;\n\n}\n\nclass ChannelInputTest {\n\n   private static File dir;\n\n   @Test\n    public void testRead() throws IOException {\n", "reference": "        File file = new File(dir, \"read.dat\");\n        file.delete();\n\n        DataOutputStream out = new DataOutputStream(new FileOutputStream(file));\n        out.writeByte(0x23);\n        out.writeShort(0x1234);\n        out.writeInt(0x12345678);\n        out.writeLong(0x1234567898765432L);\n        // total 1 + 2 + 4 + 8 = 15 bytes\n\n        // put a short across a buffer boundary\n        for (int i = 0; i < 8192 - 15 - 1; i++) out.write(0);\n        out.writeShort(0x4321);\n\n        // put an int across the next buffer boundary\n        for (int i = 0; i < 8192 - 1 - 3; i++) out.write(0);\n        out.writeInt(0x1a2b3c4d);\n\n        // put a long across the next buffer boundary\n        for (int i = 0; i < 8192 - 1 - 7; i++) out.write(0);\n        out.writeLong(0x1122334455667788L);\n\n        // now write several buffers worth of data\n        for (int i = 0; i < 8192 * 3; i++) out.writeByte(i);\n\n        out.close();\n\n        FileInputStream ins = new FileInputStream(file);\n        ChannelInput in = new ChannelInput(ins.getChannel(), 0, 8192);\n\n        assertEquals((byte)0x23, in.readByte());\n        assertEquals((short)0x1234, in.readShort());\n        assertEquals(0x12345678, in.readInt());\n        assertEquals(0x1234567898765432L, in.readLong());\n\n        in.skip(8192 - 15 - 1);\n        assertEquals((short)0x4321, in.readShort());\n\n        in.skip(8192 - 1 - 3);\n        assertEquals(0x1a2b3c4d, in.readInt());\n\n        in.skip(8192 - 1 - 7);\n        assertEquals(0x1122334455667788L, in.readLong());\n\n        byte[] data = new byte[8192 * 3];\n        in.read(data, 0, data.length);\n        for (int i = 0; i < data.length; i++) {\n            assertEquals((byte)i, data[i]);\n        }\n\n        ins.close();\n   }\n\n}", "prediction": "        File file = new File(dir, \"test.bin\");\n        FileChannel channel = new RandomAccessFile(file, \"rw\").getChannel();\n        ChannelInput input = new ChannelInput(channel, 0, 1024);\n        byte[] data = new byte[1024];\n        for (int i = 0; i < 1024; i++) {\n            data[i] = (byte) i;\n        }\n        channel.write(ByteBuffer.wrap(data));\n        input.position(0);\n        byte[] read = new byte[1024];\n        input.read(read, 0, 1024);\n        assertArrayEquals(data, read);\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "31906424_2", "part": [1, 1], "seq": [1, 1], "prompt": "class Onem2mSimpleAdapterModule extends org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.onem2msimpleadapter.impl.rev141210.AbstractOnem2mSimpleAdapterModule {\n\n    @Override\n    public void customValidation() {\n        // add custom validation form module attributes here.\n    }\n\n    public  Onem2mSimpleAdapterModule(org.opendaylight.controller.config.api.ModuleIdentifier identifier, org.opendaylight.controller.config.api.DependencyResolver dependencyResolver);\n    public  Onem2mSimpleAdapterModule(org.opendaylight.controller.config.api.ModuleIdentifier identifier, org.opendaylight.controller.config.api.DependencyResolver dependencyResolver, org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.onem2msimpleadapter.impl.rev141210.Onem2mSimpleAdapterModule oldModule, java.lang.AutoCloseable oldInstance);\n\n    @Override public java.lang.AutoCloseable createInstance();\n\n}\n\nclass Onem2mSimpleAdapterModuleTest {\n\n    @Test\n    public void testCustomValidation() {\n", "reference": "//        Onem2mSimpleAdapterModule module = new Onem2mSimpleAdapterModule(mock(ModuleIdentifier.class), mock(DependencyResolver.class));\n//\n//        // ensure no exceptions on validation\n//        // currently this method is empty\n//        module.customValidation();\n    }\n\n}", "prediction": "        Onem2mSimpleAdapterModule module = new Onem2mSimpleAdapterModule(null, null);\n        module.customValidation();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "31940141_17", "part": [1, 1], "seq": [1, 1], "prompt": "class VariableTable {\n\n    public Variable acquireExtra(Class<?> type) {\n        Validate.notNull(type);\n        \n        return acquireExtra(Type.getType(type));\n    }\n\n    public  VariableTable(ClassNode classNode, MethodNode methodNode);\n    private  VariableTable(boolean isStatic, Type objectType, Type methodType, int maxLocals);\n\n    public Variable getArgument(int index);\n    public Variable acquireExtra(Type type);\n    public void releaseExtra(Variable variable);\n    public int getArgCount();\n\n    private ClassNode classNode;\n    private MethodNode methodNode;\n\n}\n\nclass VariableTableTest {\n\n    private ClassNode classNode;\n    private MethodNode methodNode;\n\n    @Test\n    public void mustBeAbleToAcquireExtraVariable() {\n", "reference": "        VariableTable fixture = new VariableTable(classNode, methodNode);\n        \n        Variable var1 = fixture.acquireExtra(Type.LONG_TYPE);\n        assertEquals(var1.getType(), Type.LONG_TYPE);\n        assertEquals(var1.getIndex(), 1);\n        assertTrue(var1.isUsed());\n        \n        Variable var2 = fixture.acquireExtra(Type.BOOLEAN_TYPE);\n        assertEquals(var2.getType(), Type.BOOLEAN_TYPE);\n        assertEquals(var2.getIndex(), 3);\n        assertTrue(var2.isUsed());\n    }\n\n}", "prediction": "        Variable variable = variableTable.acquireExtra(Type.INT_TYPE);\n        assertThat(variable.getType(), is(Type.INT_TYPE));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "31962976_0", "part": [1, 1], "seq": [1, 1], "prompt": "class SpiderStarter {\n\n\tpublic void action() {\n\t\tSpider.create(new DoubanHouseProcessor())\n\t\t\t\t.addUrl(HouseSource.DOUBAN)\n\t\t\t\t.addPipeline(new ConsolePipeline())\n\t\t\t\t.run();\n\n\t\tSpider.create(new TongChengHouseProcessor())\n\t\t\t\t.addUrl(HouseSource.COM_58)\n\t\t\t\t.addPipeline(new ConsolePipeline())\n\t\t\t\t.run();\n\t}\n\n}\n\nclass SpiderStarterTest {\n\n\t@Test\n\tpublic void testAction() {\n", "reference": "\t\tSpiderStarter spiderStarter = new SpiderStarter();\n\t\tspiderStarter.action();\n\t}\n\n}", "prediction": "\t\tnew SpiderStarter().action();\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "32177955_0", "part": [1, 1], "seq": [1, 1], "prompt": "class Snapshot {\n\n    public static Builder builder(Instant time, Snapshot other) {\n        return new Builder(time, other);\n    }\n\n    @SuppressWarnings(\"unused\") private  Snapshot();\n    public  Snapshot(Instant time);\n\n    public Optional<Long> getId();\n    public Optional<Long> getEventId();\n    public Instant getSnapshotTime();\n    public TeamTagMap getTeamTagMap();\n    public Instant getStartTime();\n    public Instant getEndTime();\n    public TeamStates getTeamStates();\n    public TeamStates getPublicTeamStates();\n    public String getStatusMessage();\n    public Status getStatus();\n    public int getUpdateFrequency();\n    public static Optional<Snapshot> loadForEvent(Connection connection, Event event);\n    public static Optional<Snapshot> loadLatest(Connection connection);\n    public static Optional<Snapshot> loadBefore(Connection connection, Instant time);\n    public void save(Connection connection);\n    public static void deleteAfter(Connection connection, Snapshot snapshot);\n\n    private ObjectMapper objectMapper;\n\n}\n\nclass TestSnapshot {\n\n    private ObjectMapper objectMapper;\n\n    @Test\n    public void testSerializeToJson_DefaultObject() throws Exception {\n", "reference": "        Snapshot snapshot = Snapshot.builder(Instant.EPOCH, null)\n                .withStartTime(Instant.EPOCH)\n                .withEndTime(Instant.EPOCH)\n                .build();\n        MatcherAssert.assertThat(objectMapper.writeValueAsString(snapshot),\n                SameJSONAs.sameJSONAs(\"{snapshotTime:0,startTime:0,endTime:0,teamTagMap:{},\" +\n                        \"teamStates:{},publicTeamStates:{},statusMessage:\\\"\\\",status:NoResults,updateFrequency:3}\"));\n    }\n\n}", "prediction": "        Snapshot snapshot = new Snapshot(Instant.now());\n        String json = objectMapper.writeValueAsString(snapshot);\n        Snapshot deserialized = objectMapper.readValue(json, Snapshot.class);\n        assertThat(deserialized).isEqualTo(snapshot);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "32357795_148", "part": [1, 1], "seq": [1, 1], "prompt": "class Ontopia {\n\n  public static String getVersion() {\n    return getMajorVersion() + \".\" + getMinorVersion() + \".\" + getMicroVersion()\n      + (getBetaVersion() <= 0 ? \"\" : \"b\" + getBetaVersion())\n      ;\n  }\n\n  private  Ontopia();\n\n  public static String getName();\n  public static int getMajorVersion();\n  public static int getMinorVersion();\n  public static int getMicroVersion();\n  public static int getBetaVersion();\n  public static boolean isBeta();\n  public static Calendar getBuildDate();\n  public static String getBuildUser();\n  public static String getBuild();\n  private static void checkClass(String class_name, String jar_file);\n  private static void checkProduct();\n  public static void checkClasses();\n  public static void check();\n  public static String getInfo();\n  public static void main(String argv[]);\n\n}\n\nclass OntopiaTest {\n\n  @Test\n  public void testGetVersion() {\n", "reference": "    Assert.assertNotNull(Ontopia.getVersion());\n  }\n\n}", "prediction": "    String version = Ontopia.getVersion();\n    assertTrue(version.matches(\"\\\\d+\\\\.\\\\d+\\\\.\\\\d+\"));\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "32446940_5", "part": [1, 1], "seq": [1, 1], "prompt": "class TextSplitter {\n\n\tpublic static StringStyle[] splitStringAlgorithm(String text, double width, DrawHandler drawer) {\n\t\treturn splitStringAndHeightAlgorithm(text, width, drawer).getWrappedLines();\n\t}\n\n\tpublic static void drawText(DrawHandler drawer, String[] textLines, double topLeftX, double topLeftY, double width, double height, AlignHorizontal hAlignment, AlignVertical vAlignment);\n\tpublic static boolean checkifStringFitsNoWordwrap(String text, double width, DrawHandler drawer);\n\tpublic static boolean checkifStringFitsWithWordwrap(String text, double width, DrawHandler drawer);\n\tpublic static double getSplitStringHeight(String text, double width, DrawHandler drawer);\n\tpublic static double getSplitStringHeight(String[] textLines, double width, DrawHandler drawer);\n\tprivate static WordwrapCacheValue splitStringAndHeightAlgorithm(String text, double maxWidth, DrawHandler drawer);\n\tprivate static boolean wordFits(double maxWidth, DrawHandler drawer, String word);\n\tpublic static double getTextMinWidth(String text, DrawHandler drawer);\n\tpublic static double getTextMinWidth(String[] textLines, DrawHandler drawer);\n\tprivate static WordRegion[] splitIntoWords(String text);\n\tprivate static boolean isWhitespace(char c);\n\tprivate static double endBuffer(DrawHandler drawer);\n\tprivate static WordRegion[] getCachedWords(String lineKey);\n\tprivate static void setCachedWords(String lineKey, WordRegion[] words);\n\tprivate static Double getCachedMinWidth(MinWidthCacheKey key);\n\tprivate static void setCachedMinWidth(MinWidthCacheKey key, Double value);\n\tprivate static WordwrapCacheValue getCachedWordwrap(WordwrapCacheKey key);\n\tprivate static WordwrapCacheValue getCachedWordwrap(WordRegion[] words, double width, Style style, Set<FormatLabels> format);\n\tprivate static void setCachedWordwrap(WordwrapCacheKey key, WordwrapCacheValue value);\n\n\tprivate static final DrawHandler dimensionCalculatorDrawHandler;\n\n}\n\nclass TextSplitterTest {\n\n\tprivate static final DrawHandler dimensionCalculatorDrawHandler;\n\n\t@Test\n\tpublic void emptyResultIfNotEnoughSpaceForSingleChar() throws Exception {\n", "reference": "\t\tStringStyle[] style = TextSplitter.splitStringAlgorithm(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\", 1.0, dimensionCalculatorDrawHandler);\n\t\tassertContentEquals(style, Collections.<String> emptyList());\n\t}\n\n}", "prediction": "\t\tString text = \"a\";\n\t\tdouble width = 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "32498781_5", "part": [1, 1], "seq": [1, 1], "prompt": "class FormInputEnumUtils {\n\n\tpublic static LinkedHashMap<Object,String> extractKeyValue(String keyProperty,String valueProperty,Object... arrays) {\n\t\tif(arrays == null) return new LinkedHashMap(0);\n\t\treturn extractKeyValue(keyProperty,valueProperty,Arrays.asList(arrays));\n\t}\n\n\tpublic static LinkedHashMap<Object,String> toMap(FormInputEnum... arrays);\n\tpublic static LinkedHashMap<Object,String> toMap(Collection<FormInputEnum> list);\n\tpublic static LinkedHashMap<Object,String> extractKeyValue(String keyProperty,String valueProperty,List arrays);\n\tprivate static Object getPropertyValue(String keyProperty, Object obj);\n\n}\n\nclass FormInputEnumUtilsTest {\n\n\t@Test\n\tpublic void test_extractKeyValue() {\n", "reference": "\t\tMap map = FormInputEnumUtils.extractKeyValue(\"userid\", \"username\", new RapidEnumUser(\"1\",\"2\"),new RapidEnumUser(\"2\",\"2\"));\n\t\tAssert.assertEquals(2,map.size());\n\t\tAssert.assertTrue(map.containsKey(\"1\"));\n\t\tAssert.assertTrue(map.containsKey(\"2\"));\n\t\tAssert.assertTrue(map.containsValue(\"2\"));\n\t}\n\n}", "prediction": "\t\tList<FormInputEnum> list = Arrays.asList(FormInputEnum.values());\n\t\tLinkedHashMap<Object,String> map = FormInputEnumUtils.extractKeyValue(\"key\", \"value\", list);\n\t\tassertEquals(list.size(), map.size());\n\t\tfor(FormInputEnum formInputEnum : list) {\n\t\t\tassertEquals(formInputEnum.getKey(), map.get(formInputEnum.getKey()));\n\t\t}\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "33015857_198", "part": [1, 1], "seq": [1, 1], "prompt": "class Sets {\n\n    public static <V> Set<V> set( Collection<V> collection ) {\n        if (collection instanceof Set) {\n            return (Set <V>) collection;\n        }\n        if (collection==null) {\n            return Collections.EMPTY_SET;\n        }\n        return new LinkedHashSet<>( collection );\n    }\n\n    public static Enumeration<V> enumeration( final Set<V> set );\n    public static Set<V> set( Class<V> clazz );\n    public static Set<V> set( Iterable<V> iterable );\n    public static Set<V> set( Enumeration<V> enumeration );\n    public static Set<V> set( Iterator<V> iterator );\n    @SafeVarargs public static Set<V> set( final V... array );\n    @SafeVarargs public static Set<V> set( int size, final V... array  );\n    public static NavigableSet<V> sortedSet( Iterator<V> iterator );\n    public static NavigableSet<V> sortedSet( Class<V> clazz );\n    public static NavigableSet<V> sortedSet( Iterable<V> iterable );\n    public static NavigableSet<V> sortedSet( Enumeration<V> enumeration );\n    @SafeVarargs public static NavigableSet<V> sortedSet( final V... array );\n    public static NavigableSet<V> sortedSet( Collection<V> collection );\n    public static NavigableSet<V> safeSortedSet( Iterator<V> iterator );\n    public static NavigableSet<V> safeSortedSet( Class<V> clazz );\n    public static NavigableSet<V> safeSortedSet( Iterable<V> iterable );\n    public static NavigableSet<V> safeSortedSet( Enumeration<V> enumeration );\n    @SafeVarargs public static NavigableSet<V> safeSortedSet( final V... array );\n    public static NavigableSet<V> safeSortedSet( Collection<V> collection );\n    public static Set<V> safeSet( Class<V> clazz );\n    public static Set<V> safeSet( Iterable<V> iterable );\n    public static Set<V> safeSet( Enumeration<V> enumeration );\n    public static Set<V> safeSet( Iterator<V> iterator );\n    @SafeVarargs public static Set<V> safeSet( final V... array );\n    public static Set<V> safeSet( Collection<V> collection );\n    public static int len( Set<?> set );\n    public static boolean in( V value, Set<?> set );\n    public static void add( Set<V> set, V value );\n    public static T idx( NavigableSet<T> set, final T index );\n    public static T idx( Set<T> set, final T index );\n    public static T after( NavigableSet<T> set, final T index );\n    public static T before( NavigableSet<T> set, final T index );\n    public static SortedSet<V> slc( NavigableSet<V> set, V startIndex, V endIndex );\n    public static SortedSet<V> slcEnd( NavigableSet<V> set, V fromIndex );\n    public static SortedSet<V> slc( NavigableSet<V> set, V toIndex );\n    public static Set<V> copy( HashSet<V> collection );\n    public static NavigableSet<V> copy( TreeSet<V> collection );\n    public static Set<V> copy( CopyOnWriteArraySet<V> collection );\n    public static NavigableSet<V> copy( ConcurrentSkipListSet<V> collection );\n    public static NavigableSet<V> copy( NavigableSet<V> collection );\n    public static Set<V> copy( Set<V> collection );\n    public static Set<V> deepCopy( Collection<V> collection );\n    public static Set<V> deepCopyToSet( Collection<V> src,  Set<V> dst);\n    public static List<T> deepCopy( Collection<V> src, Class<T> dest  );\n    public static Set<V> deepCopy( Set<V> set );\n    public static List<Map<String, Object>> toListOfMaps( Set<?> set );\n    public static Set<T> setFromProperty( Class<T> propertyType, String propertyPath, Collection<?> list );\n    public static Set<T> setFromProperty( Class<T> propertyType, String propertyPath, Iterable<?> list );\n    public static String toPrettyJson(Set set);\n\n     Class<String> string;\n\n}\n\nclass SetsTest {\n\n     Class<String> string;\n\n    @Test\n    public void arrayConversion() {\n", "reference": "\n        String[] arry = Arry.array(\"0\", \"1\", \"2\", \"3\", \"4\");\n\n        Set<String> set = set( 3, arry);\n\n        puts(set(\"0\", \"1\", \"2\").equals(set));\n    }\n\n}", "prediction": "        String[] array = new String[] { \"a\", \"b\", \"c\" };\n        Set<String> set = Sets.set( array );\n        assertEquals( 3, set.size() );\n        assertTrue( set.contains( \"a\" ) );\n        assertTrue( set.contains( \"b\" ) );\n        assertTrue( set.contains( \"c\" ) );\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "33297716_4", "part": [1, 1], "seq": [1, 1], "prompt": "class JDOMetaContext implements MetaContext {\n\n    MetaColumn getColumnByQualifiedName(String dataSourceName, String schemaName, String tableName, String columnName) throws MetaException {\n        try {\n            Query query = pm.newQuery(MColumn.class);\n            query.setFilter(\"name == columnName && \"\n                    + \"table.name == tableName && \"\n                    + \"table.schema.name == schemaName && \"\n                    + \"table.schema.dataSource.name == dataSourceName\");\n            query.declareParameters(\"String dataSourceName, String schemaName, String tableName, String columnName\");\n            query.setUnique(true);\n\n            MColumn mColumn = (MColumn) query.executeWithArray(dataSourceName, schemaName, tableName, columnName);\n            if (mColumn == null)\n                throw new MetaException(\"column '\" + dataSourceName + \".\" + schemaName + \".\" + tableName + \".\" + columnName + \"' does not exist\");\n            return mColumn;\n        } catch (RuntimeException e) {\n            throw new MetaException(\"failed to get column '\" + dataSourceName + \".\" + schemaName + \".\" + tableName + \".\" + columnName + \"'\", e);\n        }\n    }\n\n    public  JDOMetaContext(PersistenceManager persistenceManager,\n                          UpdateLoggerFactory updateLoggerFactory);\n\n    private MUser getMUser(String name, boolean nothrow);\n    @Override public boolean userExists(String name);\n    @Override public MetaUser getUser(String name);\n    @Override public MetaUser createUser(String name, String password);\n    @Override public void alterUser(String name, String newPassword);\n    @Override public void dropUser(String name);\n    @Override public void commentOnUser(String comment, String name);\n    @Override public Collection<MetaUser> getUsers();\n    private MDataSource getMDataSource(String name, boolean nothrow);\n    @Override public boolean dataSourceExists(String name);\n    @Override public MetaDataSource getDataSource(String name);\n    @Override public MetaDataSource addJdbcDataSource(String driverName, String connectionString, String name);\n    private DataContext createElasticSearchDataContext(JSONObject jsonObject);\n    private DataContext createMongoDbDataContext(JSONObject jsonObject);\n    private DataContext createCouchDbDataContext(JSONObject jsonObject);\n    private DataContext createCassandraDataContext(JSONObject jsonObject);\n    @Override public MetaDataSource addMetaModelDataSource(String driverName, String connectionString, String name);\n    @Override public void dropJdbcDataSource(String name);\n    private void addColumn(Column rawColumn, MTable mTable);\n    private Column[] getRawTableColumns(Table rawTable);\n    private void addColumnsOfTable(Table rawTable, MTable mTable);\n    private void addTablesOfSchema(Schema rawSchema, MSchema mSchema, UpdateLogger upLog);\n    private void addDataSourceInternal(DataContext dc, MDataSource mDataSource);\n    private void updateColumnsOfTable(Table rawTable, MTable mTable);\n    private void updateTablesOfSchema(Schema rawSchema, MSchema mSchema, final String tableRegex);\n    private void updateJdbcDataSourceInternal(DataContext dc, MDataSource mDataSource,\n                                              final String schemaRegex, final String tableRegex);\n    @Override public MetaDataSource updateJdbcDataSource(String dataSourceName, final String schemaRegex, final String tableRegex);\n    @Override public void commentOnDataSource(String comment, String name);\n    @Override public Collection<MetaDataSource> getDataSources();\n    @Override public Collection<ResultOfGetColumns> getColumns(String dataSourceName, String schemaRegex, String tableRegex, String colmnRegex);\n     MetaSchema getSchemaByQualifiedName(String dataSourceName, String schemaName);\n    @Override public void commentOnSchema(String comment, String dataSourceName, String schemaName);\n     MetaTable getTableByQualifiedName(String dataSourceName, String schemaName, String tableName);\n    @Override public void commentOnTable(String comment, String dataSourceName, String schemaName, String tableName);\n    @Override public void commentOnColumn(String comment, String dataSourceName, String schemaName, String tableName, String columnName);\n    @Override public void setDataCategoryOn(String category, String dataSourceName, String schemaName, String tableName, String columnName);\n    @Override public MetaRole createRole(String name);\n    @Override public void dropRoleByName(String name);\n    @Override public void addSystemPrivileges(List<SystemPrivilege> sysPrivs, List<String> userNames);\n    @Override public void removeSystemPrivileges(List<SystemPrivilege> sysPrivs, List<String> userNames);\n    @Override public MetaSchemaPrivilege getSchemaPrivilege(String[] schemaName, String userName);\n    @Override public Collection<MetaSchemaPrivilege> getSchemaPrivilegesByUser(String userName);\n    @Override public void addObjectPrivileges(List<ObjectPrivilege> objPrivs, String[] schemaName, List<String> userNames);\n    @Override public void removeObjectPrivileges(List<ObjectPrivilege> objPrivs, String[] schemaName, List<String> userNames);\n    @Override public void close();\n\n    private static final String SCHEMA_NAME;\n    private static MemoryDatabase memDbData;\n    private final UpdateLoggerFactory ulf;\n    private MemoryDatabase memDbMeta;\n    private MetaStore metaStore;\n    private MetaContext metaContext;\n    @Rule\n    public ExpectedException thrown;\n\n}\n\nclass JDOMetaContextTest {\n\n    private static final String SCHEMA_NAME;\n    private static MemoryDatabase memDbData;\n    private final UpdateLoggerFactory ulf;\n    private MemoryDatabase memDbMeta;\n    private MetaStore metaStore;\n    private MetaContext metaContext;\n    @Rule\n    public ExpectedException thrown;\n\n    @Test\n    public void testGetColumnByQualifiedNameFail() throws Exception\n    {\n", "reference": "        thrown.expect(MetaException.class);\n        thrown.expectMessage(\"does not exist\");\n        ((JDOMetaContext) metaContext).getColumnByQualifiedName(memDbData.name, SCHEMA_NAME, \"employee\", \"any\");\n    }\n\n}", "prediction": "        thrown.expect(MetaException.class);\n        thrown.expectMessage(\"column 'foo.bar.baz.qux' does not exist\");\n        metaContext.getColumnByQualifiedName(\"foo\", \"bar\", \"baz\", \"qux\");\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "33329835_8", "part": [1, 1], "seq": [1, 1], "prompt": "class EbtsBuilder {\n\n    public byte[] build(final Ebts ebts) throws EbtsBuildingException {\n        this.ebts = ebts;\n        //Create the auto-expanding output stream\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        //Get list of all records\n        //Overwrite CNT field(1.03)\n        final List<LogicalRecord> records = ebts.getAllRecords();\n        for (final LogicalRecord record : records) {\n\n            if (genericTypes.contains(record.getRecordType())) {\n                genericBuilder((GenericRecord)record,baos);\n            } else if (binaryHeaderTypes.contains(record.getRecordType())) {\n                binaryHeaderBuilder((BinaryHeaderImageRecord)record,baos);\n            }\n        }\n        return baos.toByteArray();\n    }\n\n    public  EbtsBuilder();\n    public  EbtsBuilder(final int precedingZeros);\n\n    private void fixCountField(final GenericRecord record);\n    private int getNextAvailableIDC();\n    private void genericBuilder(final GenericRecord record, final ByteArrayOutputStream baos);\n    private static void binaryHeaderBuilder(final BinaryHeaderImageRecord record, final ByteArrayOutputStream baos);\n    public void setPrecedingZeros(final int precedingZeros);\n\n    private static final Logger log;\n\n}\n\nclass EbtsBuilderTest {\n\n    private static final Logger log;\n\n    @Test\n    public void type7asType4TestSuccess() throws Exception {\n", "reference": "        Ebts ebts = new Ebts();\n        GenericRecord type1 = new GenericRecord(1);\n        type1.setField(3, new Field(\"0400\"));\n        type1.setField(8, new Field(\"WVMEDS001\"));\n\n        GenericRecord type2 = new GenericRecord(2);\n        type2.setField(2, new Field(\"04\"));\n        type2.setField(19, new Field(\"Smith,John\"));\n        type2.getField(19).getOccurrences().add(new Occurrence(\"Smith,Johnny\"));\n        type2.setField(18, new Field(\"Smith,Jo\"));\n        type2.setField(41, new Field(\"B\"));\n        type2.setField(40, new Field(\"A\"));\n\n        List<String> strings = new ArrayList<String>();\n        strings.add(\"Test1\");\n        strings.add(\"Test2\");\n        strings.add(\"Test3\");\n        List<Occurrence> occs = EbtsUtils.convertStringList(strings);\n        occs.add(new Occurrence(\"HI\"));\n        occs.remove(new Occurrence(\"HI\"));\n\n        type2.setField(50,new Field(occs));\n\n        int[] header = new int[]{4, 1, 1, 6, 1, 2, 2, 1};\n        BinaryHeaderImageRecord type7 = new BinaryHeaderImageRecord(7,header);\n        type7.setImageData(new byte[]{});\n        type7.setField(3,new Field(\"1\"));\n        type7.setField(4,new Field(\"1\"));\n        type7.setField(5,new Field(\"1\"));\n        type7.setField(6,new Field(\"1\"));\n        type7.setField(7,new Field(\"1\"));\n        type7.setField(8,new Field(\"1\"));\n\n        ebts.addRecord(type1);\n        ebts.addRecord(type2);\n        ebts.addRecord(type7);\n\n        EbtsBuilder ebtsBuilder = new EbtsBuilder();\n        byte[] binaryData = ebtsBuilder.build(ebts);\n\n        Ebts parsedEbts = EbtsParser.parse(binaryData,Type7Handling.TREAT_AS_TYPE4);\n        log.info(\"{}\",parsedEbts);\n\n    }\n\n}", "prediction": "        final Ebts ebts = new Ebts();\n        final Type7Record type7 = new Type7Record();\n        type7.setRecordType(RecordType.TYPE_7);\n        type7.setRecordLength(1);\n        type7.setRecordData(new byte[] { 0x01 });\n        ebts.addRecord(type7);\n        final Type4Record type4 = new Type4Record();\n        type4.setRecordType(RecordType.TYPE_4);\n        type4.setRecordLength(1);\n        type4.setRecordData(new byte[] { 0x01 });\n        ebts.addRecord(type4);\n        final byte[] result = new EbtsBuilder().build(ebts);\n        assertArrayEquals(new byte[] { 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x0", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "33403291_0", "part": [1, 1], "seq": [1, 1], "prompt": "class MinecraftlyUtil {\n\n\tpublic static long convertMillisToTicks( long milliseconds ) {\n\t\tdouble nearestTickTime = round( milliseconds, 50 );\n\t\treturn (long) ((nearestTickTime / 1000) * 20);\n\t}\n\n\tpublic static UUID convertFromNoDashes( String uuidString );\n\tpublic static String convertToNoDashes( UUID uuid );\n\tpublic static String convertToNoDashes( String uuidString );\n\tpublic static String downloadText( String url );\n\tpublic static String downloadText( URL url );\n\tpublic static String readText( String filePath );\n\tpublic static String readText( File file );\n\tpublic static double round( double value, double factor );\n\tpublic static InetSocketAddress parseAddress( String address );\n\tpublic static String getTimeString( long millis );\n\n}\n\nclass MinecraftlyUtilTest {\n\n\t@Test\n\tpublic void tickConversionTest() {\n", "reference": "\n\t\tAssert.assertEquals( 1, MinecraftlyUtil.convertMillisToTicks( 40 ) );\n\t\tAssert.assertEquals( 1, MinecraftlyUtil.convertMillisToTicks( 50 ) );\n\t\tAssert.assertEquals( 1, MinecraftlyUtil.convertMillisToTicks( 60 ) );\n\n\t\tAssert.assertEquals( 3, MinecraftlyUtil.convertMillisToTicks( 140 ) );\n\t\tAssert.assertEquals( 3, MinecraftlyUtil.convertMillisToTicks( 150 ) );\n\t\tAssert.assertEquals( 3, MinecraftlyUtil.convertMillisToTicks( 160 ) );\n\n\t}\n\n}", "prediction": "\t\tassertEquals( 1000, convertMillisToTicks( 20 ) );\n\t\tassertEquals( 1000, convertMillisToTicks( 20000 ) );\n\t\tassertEquals( 1000, convertMillisToTicks( 2000000 ) );\n\t\tassertEquals( 1000, convertMillisToTicks( 2000000000 ) );\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "33821709_0", "part": [1, 1], "seq": [1, 1], "prompt": "class QuietPeriodListener implements Listener {\n\n\tprotected QuietPeriodListener(long quietPeriodInMS, Listener listenerToWrap, ExceptionHandler exceptionHandler) {\n\t\tthis.quietPeriodInMS = quietPeriodInMS;\n\t\tthis.delegate = listenerToWrap;\n\t\tthis.exceptionHandler = exceptionHandler;\n\t}\n\n\tprotected  QuietPeriodListener(long quietPeriodInMS, Listener listenerToWrap, ExceptionHandler exceptionHandler);\n\n\t@Override public synchronized void onChange(Path path, ChangeKind changeKind);\n\n\t AssertableExceptionHandler assertableExceptionHandler;\n\tvolatile boolean notified;\n\n}\n\nclass QuietPeriodListenerTest {\n\n\t AssertableExceptionHandler assertableExceptionHandler;\n\tvolatile boolean notified;\n\n\t@Test\n\tpublic void testQuietPeriodListener() throws Throwable {\n", "reference": "\t\tassertableExceptionHandler = new AssertableExceptionHandler();\n\t\tListener originalListener = (path, changeKind) -> {\n\t\t\tassertFalse(notified); // We want this to only be called once\n\t\t\tnotified = true;\n\t\t};\n\n\t\tListener quietListener = new QuietPeriodListener(100, originalListener, assertableExceptionHandler);\n\t\t\n\t\tnotified = false;\n\t\tquietListener.onChange(null, null);\n\t\tassertableExceptionHandler.assertNoErrorInTheBackgroundThread();\n\t\tawait().atMost(1, SECONDS).until(() -> notified, is(true));\n\t\tassertableExceptionHandler.assertNoErrorInTheBackgroundThread();\n\t\t\n\t\tnotified = false;\n\t\tquietListener.onChange(null, null);\n\t\tquietListener.onChange(null, null);\n\t\tassertableExceptionHandler.assertNoErrorInTheBackgroundThread();\n\t\tawait().atMost(1, SECONDS).until(() -> notified, is(true));\n\t\tassertableExceptionHandler.assertNoErrorInTheBackgroundThread();\n\n\t\t\n\t\tnotified = false;\n\t\tquietListener.onChange(null, null);\n\t\tassertableExceptionHandler.assertNoErrorInTheBackgroundThread();\n\t\tawait().atMost(1, SECONDS).until(() -> notified, is(true));\n\t\tassertableExceptionHandler.assertNoErrorInTheBackgroundThread();\n\n\t\tThread.sleep(500);\n\t\t\n\t\tnotified = false;\n\t\tquietListener.onChange(null, null);\n\t\tassertableExceptionHandler.assertNoErrorInTheBackgroundThread();\n\t\tawait().atMost(1, SECONDS).until(() -> notified, is(true));\n\t\tassertableExceptionHandler.assertNoErrorInTheBackgroundThread();\n\t}\n\n}", "prediction": "\t\tfinal long quietPeriodInMS = 100;\n \t\tfinal long sleepTimeInMS = 200;\n \t\tfinal Listener listener = new QuietPeriodListener(quietPeriodInMS, new Listener() {\n \t\t\t@Override\n \t\t\tpublic void onChange(Path path, ChangeKind changeKind) {\n \t\t\t\tnotified = true;\n \t\t\t}\n \t\t}, assertableExceptionHandler);\n \t\tlistener.onChange(Paths.get(\"\"), ChangeKind.ADDED);\n \t\tassertFalse(notified);\n \t\tThread.sleep(sleepTimeInMS);\n \t\tassertFalse(notified);\n \t\tlistener.onChange(Paths.get(\"\"), ChangeKind.ADDED);\n \t\tassertTrue(notified);\n \t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "34164637_3", "part": [1, 1], "seq": [1, 1], "prompt": "class Main {\n\n    private Main() {\n        // Prevent instantiation.\n    }\n\n    private  Main();\n\n    public static void main(@Nonnull final String... args);\n    @Nonnull private static String getWarFile();\n\n    private static final Logger LOG;\n\n}\n\nclass MainTest {\n\n    private static final Logger LOG;\n\n    @SuppressWarnings(\"ProhibitedExceptionDeclared\")\n    @Test(expected = IllegalStateException.class)\n    public void testMainFails() throws Exception {\n", "reference": "        LOG.info(\"testMainFails\");\n\n        // This will fail, as it needs to run from a WAR file and we can't do that here.\n        // Arguments: [--port <port>] [--silent] [--debug] [--help]\n        Main.main(\"--port\", \"8080\", \"--debug\");\n    }\n\n}", "prediction": "        Main.main(new String[0]);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "34531285_0", "part": [1, 1], "seq": [1, 1], "prompt": "class DBSupport {\n\n    public static void createIndex(List<SearchIndexValue> indexValues, String dbFileDir) throws BuilderException {\n\n        final String dbFile = concat(dbFileDir, DB_FILE);\n        // Create DB file\n        try (final Connection connection = DriverManager.getConnection(\"jdbc:sqlite:\" + dbFile);\n             final Statement stmt = connection.createStatement()){\n            stmt.execute(CREATE_INDEX_SQL);\n            // Update DB\n            try (final PreparedStatement pst = connection.prepareStatement(INSERT_INDEX_SQL)) {\n                for (final SearchIndexValue value : indexValues) {\n                    pst.setString(1, value.getName());\n                    pst.setString(2, value.getType().getTypeName());\n                    pst.setString(3, value.getPath());\n                    pst.execute();\n                }\n            }\n        } catch (SQLException e) {\n            throw new BuilderException(\"Error writing to SQLite DB\", e);\n        }\n        logVerbose(\"Created the SQLite search index\");\n    }\n\n    private  DBSupport();\n\n    private static final File javadocLocation;\n    private static final String QUERY;\n    @Rule\n    public TemporaryFolder temporaryFolder;\n\n}\n\nclass DBSupportTest {\n\n    private static final File javadocLocation;\n    private static final String QUERY;\n    @Rule\n    public TemporaryFolder temporaryFolder;\n\n    @Test\n    public void testCreateIndexDB() throws Exception {\n", "reference": "        assertThat(javadocLocation, notNullValue());\n        final IndexData indexData = JavadocSupport.findIndexFile(javadocLocation);\n        final List<SearchIndexValue> indexValues = JavadocSupport.findSearchIndexValues(indexData.getFilesToIndex());\n        final String docFileRoot = FilenameUtils.concat(temporaryFolder.getRoot().getPath(), \"Foo\");\n        final String dbDirName = DocSetSupport.getDBDir(docFileRoot);\n        final File dbDir = getFile(dbDirName);\n        FileUtils.forceMkdir(dbDir);\n        DBSupport.createIndex(indexValues, dbDirName);\n        final File dbFile = getFile(dbDir, \"docSet.dsidx\");\n        assertTrue(\"DB file does not exist\", dbFile.exists());\n\n        final Map<String, Integer> expectedTypes = ExpectedDataUtil.getExpectedData().getExpectedDataBaseTypes();\n        try (final Connection connection = DriverManager.getConnection(\"jdbc:sqlite:\" + dbFile);\n             final PreparedStatement stmt = connection.prepareStatement(QUERY)){\n\n            for (Map.Entry<String, Integer> expectedEntry : expectedTypes.entrySet()) {\n                stmt.setString(1, expectedEntry.getKey());\n                try (final ResultSet rs = stmt.executeQuery()) {\n                    while (rs.next()) {\n                        final int count = rs.getInt(1);\n                        assertThat(expectedEntry.getValue().intValue(), is(count));\n                    }\n                }\n            }\n        }\n    }\n\n}", "prediction": "        final List<SearchIndexValue> indexValues = new ArrayList<>();\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.CLASS, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.METHOD, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.FIELD, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.CONSTRUCTOR, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.OTHER, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.PACKAGE, \"path\"));\n        indexValues.add(new SearchIndexValue(\"name\", SearchIndexValue.Type.P", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "34533675_16", "part": [1, 1], "seq": [1, 1], "prompt": "class ShapeFileReader extends RecordReader<ShapeKey, ShpRecord> {\n\n    public void close()\n            throws IOException\n    {\n        shpInputStream.close();\n    }\n\n    public  ShapeFileReader();\n    public  ShapeFileReader(int[] indexes);\n\n    public void initialize(InputSplit split, TaskAttemptContext context);\n    public boolean nextKeyValue();\n    public ShapeKey getCurrentKey();\n    public ShpRecord getCurrentValue();\n    public float getProgress();\n\n    public static FileSystem fs;\n    public static MiniDFSCluster hdfsCluster;\n    public static String hdfsURI;\n\n}\n\nclass ShapefileReaderTest extends RecordReader<ShapeKey, ShpRecord> {\n\n    public static FileSystem fs;\n    public static MiniDFSCluster hdfsCluster;\n    public static String hdfsURI;\n\n    @Test\n    public void testReadBoundary()\n            throws IOException\n    {\n", "reference": "        String inputLocation = getShapeFilePath(\"dbf\");\n        // load shapefile with geotools's reader\n        ShpFiles shpFile = new ShpFiles(inputLocation + \"/map.shp\");\n        GeometryFactory geometryFactory = new GeometryFactory();\n        org.geotools.data.shapefile.shp.ShapefileReader gtlReader = new org.geotools.data.shapefile.shp.ShapefileReader(shpFile, false, true, geometryFactory);\n        String gtlbounds =\n                gtlReader.getHeader().minX() + \":\" +\n                        gtlReader.getHeader().minY() + \":\" +\n                        gtlReader.getHeader().maxX() + \":\" +\n                        gtlReader.getHeader().maxY();\n        // read shapefile by our reader\n        BoundBox bounds = ShapefileReader.readBoundBox(sc, inputLocation);\n        String myBounds =\n                bounds.getXMin() + \":\" +\n                        bounds.getYMin() + \":\" +\n                        bounds.getXMax() + \":\" +\n                        bounds.getYMax();\n        assertEquals(gtlbounds, myBounds);\n        gtlReader.close();\n    }\n\n}", "prediction": "       ShapeFileReader reader = new ShapeFileReader();\n        reader.initialize(new ShapeFileSplit(new Path(hdfsURI + \"/test/data/boundary.shp\"), 0, 1000000000), null);\n        assertTrue(reader.nextKeyValue());\n        assertEquals(reader.getCurrentKey().getShapeType(), ShapeType.POLYGON);\n        assertEquals(reader.getCurrentValue().getShapeType(), ShapeType.POLYGON);\n        assertEquals(reader.getCurrentValue().getGeometry().getCoordinates().length, 1);\n        assertEquals(reader.getCurrentValue().getGeometry().getCoordinates()[0].length, 5);\n        assertEquals(reader.getCurrentValue().getGeometry().getCoordinates()[0][0].getX(), 100.0);\n        assertEquals(reader.getCurrentValue().getGeometry().getCoordinates()[0][0].getY(), 100.0);\n        assertEquals(reader.getCurrentValue().getGeometry().getCoordinates()[0][1].getX(), 100.0);\n        assertEquals(reader.getCurrentValue().getGeometry().getCoordinates()[0][1].getY(), 101.0);\n        assertEquals(reader.getCurrentValue().getGeometry().getCoordinates()[0][2].getX(), 101.0);\n        assertEquals(reader.getCurrentValue().getGeometry().getCoordinates()[0][2].getY(), 101.0);\n        assertEquals(reader.getCurrentValue().getGeometry().getCoordinates()[0][3].getX(), 101.0);\n        assertEquals(reader.getCurrentValue().getGeometry().getCoordinates()[0][3].getY(), 100.0);\n        assertEquals(reader.getCurrentValue().getGeometry().getCoordinates()[0][4].getX(), 100.0);\n        assertEquals(reader.getCurrentValue().getGeometry().getCoordinates()[0][4].getY(), 100.0);\n        assertTrue(reader.nextKeyValue());\n        assertEquals(reader.getCurrentKey().getShapeType(), ShapeType.POLYGON);\n        assertEquals(reader.getCurrentValue().getShapeType(), ShapeType.POLYGON);\n        assertEquals(reader.getCurrentValue().getGeometry().getCoordinates().length, 1);\n        assertEquals(reader.getCurrentValue().getGeometry().getCoordinates()[0].length, 5);\n        assertEquals(reader.getCurrentValue().getGeometry().getCoordinates()[0][0].getX(), 101.0);\n        assertEquals(reader.getCurrentValue().getGeometry().getCoordinates()[0][0].getY(), 101.0);\n        assertEquals(reader.getCurrentValue().getGeometry().getCoordinates()[0][1].getX(), 101.0);\n        assertEquals(reader.getCurrentValue().getGeometry().getCoordinates()[0][1].getY(), 102.0);\n        assertEquals(reader.getCurrentValue().getGeometry().getCoordinates()[0][2].getX(), 102.0);\n        assertEquals(reader.getCurrentValue().getGeometry().getCoordinates()[0][2].getY(), 102.0);\n        assertEquals(reader.getCurrentValue().getGeometry().getCoordinates()[0][3].getX(), 102.0);\n        assertEquals(reader.getCurrentValue().getGeometry().getCoordinates()[0][3].getY(), 101.0);\n        assertEquals(reader.getCurrentValue().getGeometry().getCoordinates()[0][4].getX(), 101.0);\n        assertEquals(reader.getCurrentValue().getGeometry().getCoordinates()[0][4].getY(), 101.0);\n        assertFalse(reader.nextKeyValue());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "35486799_0", "part": [1, 1], "seq": [1, 1], "prompt": "class JsonRestClientImpl implements JsonRestClient {\n\n  @Override\n  public JsonNode get(final String url, final RestRequestHeader... requestHeaders) throws JsonProcessingException, IOException {\n    final ResponseEntity<String> response = restClient.get(url, String.class, requestHeaders);\n    return getJson(response);\n  }\n\n  @Override public JsonNode post(final String url, final RestRequestBody requestBody, final RestRequestHeader... requestHeaders);\n  private JsonNode getJson(final ResponseEntity<String> response);\n\n  private static final String ANY_URL;\n  private static final String RESPONSE_STUB_PATH;\n  @InjectMocks\n  private JsonRestClient jsonRestClient;\n  private String responseStub;\n\n}\n\nclass JsonRestClientImplTest  {\n\n  private static final String ANY_URL;\n  private static final String RESPONSE_STUB_PATH;\n  @InjectMocks\n  private JsonRestClient jsonRestClient;\n  private String responseStub;\n\n  @Test\n  public void testGet() throws JsonProcessingException, IOException {\n", "reference": "    setupExpectation(HttpMethod.GET);\n    assertResponseOk(jsonRestClient.get(ANY_URL));\n  }\n\n}", "prediction": "    final JsonNode response = jsonRestClient.get(ANY_URL);\n    assertThat(response.get(\"key\").asText(), is(\"value\"));\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "35555582_1", "part": [1, 1], "seq": [1, 1], "prompt": "class AutoValueParcelExtension extends AutoValueExtension {\n\n  @Override\n  public String generateClass(Context context, String className, String classToExtend,\n                              boolean isFinal) {\n    ProcessingEnvironment env = context.processingEnvironment();\n    TypeName autoValueType =\n        TypeName.get(env.getTypeUtils().erasure(context.autoValueClass().asType()));\n\n    ImmutableList<Property> properties = readProperties(context);\n    if (!validateProperties(env, properties)) {\n      return null;\n    }\n\n    ImmutableMap<TypeMirror, FieldSpec> typeAdapters = getTypeAdapters(properties);\n\n    TypeName type = ClassName.get(context.packageName(), className);\n    TypeSpec.Builder subclass = TypeSpec.classBuilder(className)\n        .addModifiers(FINAL)\n        .addMethod(generateConstructor(properties))\n        .addMethod(generateWriteToParcel(env, properties, typeAdapters));\n\n    GeneratedAnnotations.generatedAnnotation(env.getElementUtils(), env.getSourceVersion())\n        .map(\n            annotation ->\n                AnnotationSpec.builder(ClassName.get(annotation))\n                    .addMember(\"value\", \"$S\", getClass().getName())\n                    .build())\n        .ifPresent(subclass::addAnnotation);\n\n    if (!typeAdapters.isEmpty()) {\n      for (FieldSpec field : typeAdapters.values()) {\n        subclass.addField(field);\n      }\n    }\n\n    subclass.addField(generateCreator(env, autoValueType, properties, type, typeAdapters));\n\n    ClassName superClass = ClassName.get(context.packageName(), classToExtend);\n    List<? extends TypeParameterElement> tpes = context.autoValueClass().getTypeParameters();\n    if (tpes.isEmpty()) {\n      subclass.superclass(superClass);\n    } else {\n      TypeName[] superTypeVariables = new TypeName[tpes.size()];\n      for (int i = 0, tpesSize = tpes.size(); i < tpesSize; i++) {\n        TypeParameterElement tpe = tpes.get(i);\n        subclass.addTypeVariable(TypeVariableName.get(tpe));\n        superTypeVariables[i] = TypeVariableName.get(tpe.getSimpleName().toString());\n      }\n      subclass.superclass(ParameterizedTypeName.get(superClass, superTypeVariables));\n    }\n    if (needsContentDescriptor(context)) {\n      subclass.addMethod(generateDescribeContents());\n    }\n\n    JavaFile javaFile = JavaFile.builder(context.packageName(), subclass.build()).build();\n    return javaFile.toString();\n  }\n\n  @Override public IncrementalExtensionType incrementalType(ProcessingEnvironment processingEnvironment);\n  @Override public boolean applicable(Context context);\n  @Override public boolean mustBeFinal(Context context);\n  @Override public Set<String> consumeProperties(Context context);\n  @Override public Set<ExecutableElement> consumeMethods(Context context);\n  private static boolean needsContentDescriptor(Context context);\n  private static ExecutableElement findWriteToParcel(Context context);\n  private static VariableElement findCreator(Context context);\n  private ImmutableList<Property> readProperties(Context context);\n  private boolean validateProperties(ProcessingEnvironment env, List<Property> properties);\n   MethodSpec generateConstructor(List<Property> properties);\n   FieldSpec generateCreator(ProcessingEnvironment env, TypeName autoValueType,\n      List<Property> properties, TypeName type, Map<TypeMirror, FieldSpec> typeAdapters);\n   MethodSpec generateWriteToParcel(ProcessingEnvironment env, List<Property> properties,\n      Map<TypeMirror, FieldSpec> typeAdapters);\n  private static AnnotationSpec createSuppressUncheckedWarningAnnotation();\n  private ImmutableMap<TypeMirror, FieldSpec> getTypeAdapters(List<Property> properties);\n   MethodSpec generateDescribeContents();\n\n  @Rule public CompilationRule rule;\n   AutoValueParcelExtension extension;\n  private Elements elements;\n  private TestProcessingEnvironment processingEnvironment;\n  private JavaFileObject parcelable;\n  private JavaFileObject parcel;\n  private JavaFileObject nullable;\n  private JavaFileObject textUtils;\n\n}\n\nclass AutoValueParcelExtensionTest {\n\n  @Rule public CompilationRule rule;\n   AutoValueParcelExtension extension;\n  private Elements elements;\n  private TestProcessingEnvironment processingEnvironment;\n  private JavaFileObject parcelable;\n  private JavaFileObject parcel;\n  private JavaFileObject nullable;\n  private JavaFileObject textUtils;\n\n  @Test public void acceptsParcelableProperties() throws Exception {\n", "reference": "    TypeElement type = elements.getTypeElement(SampleTypeWithParcelable.class.getCanonicalName());\n    AutoValueExtension.Context context = createContext(type);\n\n    String generated = extension.generateClass(context, \"Test_TypeWithParcelable\", \"SampleTypeWithParcelable\", true);\n    assertThat(generated).isNotNull();\n  }\n\n}", "prediction": "    assertThat(extension.applicable(context(parcelable))).isTrue();\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "35564219_13", "part": [1, 1], "seq": [1, 1], "prompt": "class SavingStreamProvider implements BitmapProvider {\n\n    @Override\n    public Bitmap load() throws IOException {\n        Bitmap bitmap;\n        try {\n            bitmap = loadBitmap();\n        } catch (OutOfMemoryError e) {\n            if (request.memoryCache() != null) request.memoryCache().clear();\n            System.gc();\n            try {\n                bitmap = loadBitmap();\n            } catch (OutOfMemoryError e2) {\n                throw e2;\n            }\n        }\n        return bitmap;\n    }\n\n    public  SavingStreamProvider(MirageRequest request);\n\n    abstract protected InputStream stream();\n    private Bitmap loadBitmap();\n    @Override public String id();\n    private int determineSampleSize(BitmapFactory.Options outOpts);\n\n}\n\nclass SavingStreamProviderTest  {\n\n    @Test\n    public void testLoads_doesNotSaveSource() throws IOException {\n", "reference": "        MirageRequest request = mock(MirageRequest.class);\n        UrlFactory factory = mock(UrlFactory.class);\n        InputStream inputStream = mock(InputStream.class);\n        when(factory.getStream(any(Uri.class))).thenReturn(inputStream);\n        when(request.urlFactory()).thenReturn(factory);\n        when(request.uri()).thenReturn(Uri.parse(\"http://www.sample.com/\"));\n\n        DiskCache diskCache = mock(DiskCache.class);\n        MemoryCache<String, Bitmap> memCache = mock(MemoryCache.class);\n        when(request.diskCache()).thenReturn(diskCache);\n        when(request.memoryCache()).thenReturn(memCache);\n\n        SavingStreamProvider provider = new SavingStreamProvider(request) {\n            @Override\n            protected InputStream stream() throws IOException {\n                ByteArrayOutputStream bos = new ByteArrayOutputStream();\n                Bitmap bitmap = Bitmap.createBitmap(400, 600, Bitmap.Config.ARGB_8888);\n                bitmap.compress(Bitmap.CompressFormat.PNG, 0 /*ignored for PNG*/, bos);\n                byte[] bitmapdata = bos.toByteArray();\n                ByteArrayInputStream bs = new ByteArrayInputStream(bitmapdata);\n                return bs;\n            }\n        };\n        when(request.provider()).thenReturn(provider);\n\n        Bitmap bitmap = provider.load();\n        Assert.assertNotNull(bitmap);\n\n        verify(diskCache, times(0)).put(anyString(), any(DiskCache.Writer.class));\n    }\n\n}", "prediction": "        final Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);\n        final InputStream stream = new ByteArrayInputStream(new byte[1000]);\n        final SavingStreamProvider provider = new SavingStreamProvider(new MirageRequest.Builder(new Uri.Builder().build()).build()) {\n            @Override\n            protected InputStream stream() {\n                return stream;\n            }\n        };\n        provider.load();\n        assertThat(stream.available(), is(1000));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "35627039_96", "part": [1, 1], "seq": [1, 1], "prompt": "class TopologyDag implements Serializable {\n\n    List<Component> topOrder() {\n        Map<Component, State> state = new HashMap<>();\n        List<Component> res = new ArrayList<>();\n        for(Component component: Sets.union(inputComponents, outputComponents)) {\n            if (state.get(component) != State.VISITED) {\n                res.addAll(dfs(component, state));\n            }\n        }\n        Collections.reverse(res);\n        return res;\n    }\n\n    public TopologyDag add(OutputComponent component);\n    public Set<OutputComponent> getOutputComponents();\n    public TopologyDag add(InputComponent component);\n    public Set<InputComponent> getInputComponents();\n    public TopologyDag add(Processor processor);\n    public Set<Component> getComponents();\n    public void addEdge(OutputComponent from, InputComponent to);\n    public void addEdge(String id, OutputComponent from, InputComponent to, String streamId);\n    public void addEdge(String id, OutputComponent from, InputComponent to, String streamId, Stream.Grouping grouping);\n    public void addEdge(Edge edge);\n    public void addEdge(String id, OutputComponent from, InputComponent to, StreamGrouping streamGrouping);\n    public void removeEdge(OutputComponent from, InputComponent to);\n    public void removeEdge(OutputComponent from, InputComponent to, String streamId, Stream.Grouping grouping);\n    public List<Edge> getEdgesFrom(Component component);\n    public List<Edge> getEdgesTo(Component component);\n    public List<Edge> getEdges(Component component);\n    public List<Edge> getAllEdges();\n    public List<Component> adjacent(Component component);\n    public void traverse(TopologyDagVisitor visitor);\n    private List<Component> dfs(Component current, Map<Component, State> state);\n    private void ensureValid(OutputComponent from, InputComponent to);\n    private void doAddEdge(String id, OutputComponent from, InputComponent to, StreamGrouping streamGrouping);\n    private String getDefaultStreamId(OutputComponent source);\n    @Override public String toString();\n\n     TopologyDag topology;\n\n}\n\nclass TopologyDagTest {\n\n     TopologyDag topology;\n\n    @Test\n    public void testTopOrder() {\n", "reference": "        Source src1 = new StreamlineSource(Collections.singleton(new Stream(\"f1\", \"f2\")));\n        Source src2 = new StreamlineSource(Collections.singleton(new Stream(\"f1\", \"f2\")));\n        Sink sink = new StreamlineSink();\n        Processor processor = new StreamlineProcessor(Collections.singleton(new Stream(\"r1\")));\n\n        topology.add(src1).add(src2).add(processor).add(sink);\n        topology.addEdge(src1, processor);\n        topology.addEdge(src2, processor);\n        topology.addEdge(processor, sink);\n\n        List<Component> topOrder = topology.topOrder();\n        assertArrayEquals(new Component[] {src2, src1, processor, sink}, topOrder.toArray());\n    }\n\n}", "prediction": "        topology.add(new Processor(\"p1\"));\n        topology.add(new Processor(\"p2\"));\n        topology.add(new Processor(\"p3\"));\n        topology.add(new Processor(\"p4\"));\n        topology.add(new Processor(\"p5\"));\n        topology.add(new Processor(\"p6\"));\n        topology.add(new Processor(\"p7\"));\n        topology.add(new Processor(\"p8\"));\n        topology.add(new Processor(\"p9\"));\n        topology.add(new Processor(\"p10\"));\n        topology.add(new Processor(\"p11\"));\n        topology.add(new Processor(\"p12\"));\n        topology.add(new Processor(\"p13\"));\n        topology.add(new Processor(\"p14\"));\n        topology.add(new Processor(\"p15\"));\n        topology.add(new Processor(\"p16\"));\n        topology.add(new Processor(\"p17\"));\n        topology.add(new Processor(\"p18\"));\n        topology.add(new Processor(\"p19\"));\n        topology.add(new Processor(\"p20\"));\n        topology.add(new Processor(\"p21\"));\n        topology.add(new Processor(\"p22\"));\n        topology.add(new Processor(\"p23\"));\n        topology.add(new Processor(\"p24\"));\n        topology.add(new Processor(\"p25\"));\n        topology.add(new Processor(\"p26\"));\n        topology.add(new Processor(\"p27\"));\n        topology.add(new Processor(\"p28\"));\n        topology.add(new Processor(\"p29\"));\n        topology.add(new Processor(\"p30\"));\n        topology.add(new Processor(\"p31\"));\n        topology.add(new Processor(\"p32\"));\n        topology.add(new Processor(\"p33\"));\n        topology.add(new Processor(\"p34\"));\n        topology.add(new Processor(\"p35\"));\n        topology.add(new Processor(\"p36\"));\n        topology.add(new Processor(\"p37\"));\n        topology.add(new Processor(\"p38\"));\n        topology.add(new Processor(\"p39\"));\n        topology.add(new Processor(\"p40\"));\n        topology.add(new Processor(\"p41\"));\n        topology.add(new Processor(\"p42\"));\n        topology.add(new Processor(\"p43\"));\n        topology.add(new Processor(\"p44\"));\n        topology.add(new Processor(\"p45\"));\n        topology.add(new Processor(\"p46\"));\n        topology.add(new Processor(\"p47\"));\n        topology.add(new Processor(\"p48\"));\n        topology.add(new Processor(\"p49\"));\n        topology.add(new Processor(\"p50\"));\n        topology.add(new Processor(\"p51\"));\n        topology.add(new Processor(\"p52\"));\n        topology.add(new Processor(\"p53\"));\n        topology.add(new Processor(\"p54\"));\n        topology.add(new Processor(\"p55\"));\n        topology.add(new Processor(\"p56\"));\n        topology.add(new Processor(\"p57\"));\n        topology.add(new Processor(\"p58\"));\n        topology.add(new Processor(\"p59\"));\n        topology.add(new Processor(\"p60\"));\n        topology.add(new Processor(\"p61\"));\n        topology.add(new Processor(\"p62\"));\n        topology.add(new Processor(\"p63\"));\n        topology.add(new Processor(\"p64\"));\n        topology.add(new Processor(\"p65\"));\n        topology.add(new Processor(\"p66\"));\n        topology.add(new Process", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "36372567_0", "part": [1, 1], "seq": [1, 1], "prompt": "class GeocoderUtils {\n\n    public static String getGeocodedLocationFor(Context context, String phoneNumber, ClassLoader classLoader, boolean isForChina) {\n        try {\n\t\t\tfinal String currentIso = isForChina ? Locale.CHINA.getCountry() : getCurrentCountryIso(context, classLoader);\n\t\t\tfinal Locale locale = isForChina ? Locale.CHINA : context.getResources().getConfiguration().locale;\n            return getDescriptionForNumber(parsePhoneNumber(phoneNumber, currentIso), locale);\n        } catch (NumberParseException e) {\n            return null;\n        }\n    }\n\n    private static String getCurrentCountryIso(Context context, ClassLoader loader);\n    static Phonenumber.PhoneNumber parsePhoneNumber(String number, String currentIso);\n    static String getDescriptionForNumber(Phonenumber.PhoneNumber number, Locale languageCode);\n\n}\n\nclass GeocoderUtilsTest {\n\n\t@Test\n\tpublic void testGetGeocodedLocationFor() throws Exception {\n", "reference": "\t\tfinal List<String> numberList = Arrays.asList(\"10086\",\n\t\t\t\t\"15573275419\", \"057157892157\");\n\t\ttry {\n\t\t\tLocale locale = Locale.CHINA;\n\t\t\tfinal PhoneNumberUtil phoneNumberUtil = PhoneNumberUtil.getInstance();\n\n\t\t\tfor (String s : numberList) {\n\t\t\t\tPhonenumber.PhoneNumber phoneNumber = GeocoderUtils.parsePhoneNumber(s, locale.getCountry());\n\t\t\t\tSystem.out.println(\"geocoder: \" + GeocoderUtils.getDescriptionForNumber(phoneNumber, locale));\n\t\t\t}\n\t\t} catch (NumberParseException e) {\n\t\t\tSystem.err.println(\"NumberParseException was thrown: \" + e.toString());\n\t\t}\n\t}\n\n}", "prediction": "\t\tassertEquals(\"China\", GeocoderUtils.getGeocodedLocationFor(null, \"+8613800000000\", GeocoderUtils.class.getClassLoader(), true));\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "36725014_3", "part": [1, 1], "seq": [1, 1], "prompt": "class Insert extends QueryBuilder {\n\n    Insert(QueryBuilderOptions options) {\n        super(options, Arrays.asList(\n                new StringBlock(options, \"INSERT\"),\n                new IntoTableBlock(options),            // 1\n                new InsertFieldValueBlock(options),     // 2\n                new InsertFieldsFromQueryBlock(options) // 3\n        ));\n    }\n\n      Insert(QueryBuilderOptions options);\n\n    @Override public QueryBuilder into(String table);\n    @Override public QueryBuilder set(String field, T value);\n    @Override public QueryBuilder fromQuery(Iterable<String> fields, QueryBuilder query);\n\n}\n\nclass InsertTest {\n\n    @Test(expected=UnsupportedOperationException.class)\n    public void limitShouldThrow() {\n", "reference": "        Squel.insert()\n                .limit(10);\n    }\n\n}", "prediction": "        new Insert(new QueryBuilderOptions()).limit(1);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "37208641_80", "part": [1, 1], "seq": [1, 1], "prompt": "class BasicPath implements Path {\n\n    @Override\n    public String toString() {\n        if (describedBy.isPresent() && !describedBy.equals(xpathExplanation)) {\n            return describedBy.get();\n        } else {\n            Optional<String> underlyingOption = (underlying.isPresent()) ?\n                    Optional.of(\"under reference element \" + underlying.get()) :\n                    Optional.empty();\n            Optional<String> xpathOption = getXpathExplanationForToString();\n\n            Optional<String> propsOption =\n                    (elementProperties.size() == 1 && (!xpathOption.orElse(\"\").contains(\", \") || xpathOption.equals(describedBy))) ?\n                            getPropertiesToStringForLength1() :\n                            (elementProperties.size() == 2 && !xpathOption.orElse(\"\").contains(\" \")) ?\n                                    Optional.of(format(\"that %s, and %s\",\n                                            elementProperties.get(0), elementProperties.get(elementProperties.size() - 1))) :\n                                    (elementProperties.size() > 1 || (xpathOption.orElse(\"\").contains(\" \") && !elementProperties.isEmpty())) ?\n                                            getPropertiesToStringForLengthLargerThan2() :\n                                            Optional.empty();\n\n            return (xpathExplanation.isPresent() && !underlyingOption.isPresent() && !propsOption.isPresent()) ?\n                    xpathExplanation.get() :\n                    Stream.of(underlyingOption, xpathOption, propsOption).filter(Optional::isPresent).map(Optional::get).\n                            collect(Collectors.joining(\", \"));\n        }\n\n    }\n\n    private  BasicPath(Optional<WebElement> underlying,\n                      Optional<String> xpath,\n                      List<ElementProperty> elementProperties,\n                      Optional<String> xpathExplanation,\n                      Optional<String> describedBy,\n                      Optional<String> insideXpath,\n                      Optional<String> alternateXpath\n    );\n\n    public static PathBuilder builder();\n    public static Path textNode(String text);\n    public static BasicPath customElement(String el);\n    public static BasicPath customNameSpaceElement(String el);\n    public static ChildNumber childNumber(Integer n);\n    public static GlobalOccurrenceNumber occurrenceNumber(Integer n);\n    public static Path firstOccurrenceOf(Path path);\n    public static Path lastOccurrenceOf(Path path);\n    @Override public Optional<String> getXPath();\n    @Override public Optional<String> getAlternateXPath();\n    private Optional<String> getXPathWithoutInsideClause();\n    @Override public Optional<WebElement> getUnderlyingSource();\n    @Override public Optional<String> getXpathExplanation();\n    @Override public Optional<String> getDescribedBy();\n    @Override public List<ElementProperty> getElementProperties();\n    @Override public Path describedBy(String description);\n    private void verifyRelationBetweenElements(Path path);\n    @Override public Path or(Path path);\n    @Override public Path that(ElementProperty... prop);\n    @Override public Path and(ElementProperty... prop);\n    @Override public Path withText(String txt);\n    @Override public Path inside(final Path path);\n    @Override public Path insideTopLevel();\n    @Override public Path afterSibling(Path path);\n    @Override public Path immediatelyAfterSibling(Path path);\n    @Override public Path after(Path path);\n    @Override public Path beforeSibling(Path path);\n    @Override public Path immediatelyBeforeSibling(Path path);\n    @Override public Path before(Path path);\n    @Override public Path childOf(Path path);\n    @Override public Path parentOf(Path path);\n    @Override public Path containing(Path path);\n    @Override public Path contains(Path path);\n    @Override public Path ancestorOf(Path path);\n    @Override public Path descendantOf(Path path);\n    @Override public Path withGlobalIndex(Integer n);\n    @Override public Path withClass(String cssClass);\n    @Override public Path withClasses(String... cssClasses);\n    @Override public Path withTextContaining(String txt);\n    private Optional<String> getXpathExplanationForToString();\n    private Optional<String> getPropertiesToStringForLength1();\n    private Optional<String> getPropertiesToStringForLengthLargerThan2();\n    private BasicPath createWithSimpleRelation(Path path, String relation);\n    private String wrapIfNeeded(Path path);\n    private BasicPath createWithHumanReadableRelation(Path path, String xpathRelation, String humanReadableRelation);\n    private BasicPath createNewWithAdditionalProperty(ElementProperty prop);\n\n}\n\nclass BasicPathTest  {\n\n    @Test\n    public void bareboneTostring() {\n", "reference": "        BasicPath path = new PathBuilder().withXpath(\"Johhny\").build();\n        assertThat(path.toString(), is(equalTo(\"xpath: \\\"Johhny\\\"\")));\n    }\n\n}", "prediction": "        Path path = BasicPath.builder().build();\n        assertEquals(\"\", path.toString());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "37717709_106", "part": [1, 1], "seq": [1, 1], "prompt": "class JVoiceXmlDocumentServer implements DocumentServer {\n\n    @Override\n    public URI storeAudio(final AudioInputStream in) throws BadFetchError {\n        try {\n            final File directory = getRecordingsDirectory();\n            final File file = File.createTempFile(\"rec-\", \".wav\", directory);\n            AudioSystem.write(in, AudioFileFormat.Type.WAVE, file);\n            LOGGER.info(\"recorded to file '\" + file.toURI() + \"'\");\n            return file.toURI();\n        } catch (IOException ex) {\n            throw new BadFetchError(ex.getMessage(), ex);\n        }\n    }\n\n    public  JVoiceXmlDocumentServer();\n\n    public void setDocumentStorage(final DocumentStorage documentStorage);\n    @Override public void start();\n    public void setSchemeStrategies(final List<SchemeStrategy> schemeStrategies);\n    public void setFetchAttributes(final FetchAttributes attrs);\n    private FetchAttributes mergeFetchAttributes(final FetchAttributes attrs);\n    private VoiceXmlDocument readDocument(final InputStream input);\n    @Override public VoiceXmlDocument getDocument(final String sessionId,\n            final DocumentDescriptor descriptor);\n    private SchemeStrategy getSchemeStrategy(final URI uri);\n    public void addSchemeStrategy(final SchemeStrategy strategy);\n    @Override public URI resolveBuiltinUri(final URI uri);\n    @Override public URI addGrammarDocument(final String sessionId,\n            final GrammarDocument document);\n    @Override public GrammarDocument getGrammarDocument(final String sessionId,\n            final URI uri, final FetchAttributes attrs);\n    @Override public AudioInputStream getAudioInputStream(final String sessionId,\n            final URI uri);\n    @Override public Object getObject(final String sessionId,\n            final DocumentDescriptor descriptor, final String type);\n    private Document readXml(final InputStream in);\n    private File getRecordingsDirectory();\n    @Override public void sessionClosed(final String sessionId);\n    @Override public void stop();\n\n    private DocumentMap map;\n    private JVoiceXmlDocumentServer server;\n\n}\n\nclass TestJVoiceXmlDocumentServer {\n\n    private DocumentMap map;\n    private JVoiceXmlDocumentServer server;\n\n    @Test\n    public void testStoreAudio() throws Exception, JVoiceXMLEvent {\n", "reference": "        final URL file = this.getClass().getResource(\"/test.wav\");\n        final AudioInputStream ain = AudioSystem.getAudioInputStream(file);\n        final URI result = server.storeAudio(ain);\n        Assert.assertNotNull(result);\n        final File rec = new File(result);\n        Assert.assertTrue(\"expexcted file exists\", rec.exists());\n    }\n\n}", "prediction": "        final URI uri = server.storeAudio(new AudioInputStream(new ByteArrayInputStream(new byte[0]), new AudioFormat(8000, 16, 1, true, false)));\n        assertNotNull(uri);\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "38317187_68", "part": [1, 1], "seq": [1, 1], "prompt": "class SegmentProcessor {\n\n    static void process(List<String[]> segments, Consumer<String[]> consumer) {\n        if (segments != null) {\n            int index = 0;\n            int length = segments.size();\n            for (String[] segment : segments) {\n                String key = segment[0];\n                String value = segment[1];\n                if (key != null && value != null) {\n                    switch (key) {\n                        case HOST:\n                            if (length > 1 && index == 0) {\n                                value = \"*\";\n                            }\n                            break;\n\n                        case PROFILE:\n                        case SERVER_GROUP:\n                            if (index == 0) {\n                                value = \"*\";\n                            }\n                            break;\n\n                        case SERVER:\n                        case SERVER_CONFIG:\n                            if (index == 1) {\n                                value = \"*\";\n                            }\n                            break;\n                        default:\n                            break;\n                    }\n                }\n                consumer.accept(new String[]{key, value});\n                index++;\n            }\n        }\n    }\n\n    private  SegmentProcessor();\n\n    private AsListConsumer consumer;\n\n}\n\nclass SegmentProcessorTest {\n\n    private AsListConsumer consumer;\n\n    @Test\n    public void serverConfig2() throws Exception {\n", "reference": "        Fixture fixture = new Fixture.Builder(\"server-config2\")\n                .segments(\"host\", \"*\", \"server-config\", \"server-one\", \"jvm\", \"*\")\n                .expected(\"host\", \"*\", \"server-config\", \"*\", \"jvm\", \"*\")\n                .build();\n        SegmentProcessor.process(fixture.segments, consumer);\n        assertFixture(fixture, consumer.result);\n    }\n\n}", "prediction": "        List<String[]> segments = new ArrayList<>();\n        segments.add(new String[]{\"server\", \"127.0.0.1:8080\"});\n        segments.add(new String[]{\"serverConfig\", \"127.0.0.1:8080\"});\n        SegmentProcessor.process(segments, consumer);\n        assertThat(consumer.getList(), contains(\n                new String[]{\"server\", \"127.0.0.1:8080\"},\n                new String[]{\"serverConfig\", \"127.0.0.1:8080\"}\n        ));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "38639709_4", "part": [1, 1], "seq": [1, 1], "prompt": "class LaunchingRepositoryBuildVisitor extends AbstractRepositoryBuildVisitor {\n\n  @Override\n  protected void visitLaunching(RepositoryBuild build) throws Exception {\n    LOG.info(\"Going to enqueue module builds for repository build {}\", build.getId().get());\n\n    final Set<Module> activeModules = filterActive(moduleService.getByBranch(build.getBranchId()));\n\n    // 1. Check for malformed files\n    if (!malformedFileService.getMalformedFiles(build.getBranchId()).isEmpty()) {\n      failBranchAndModuleBuilds(build, activeModules);\n      return;\n    }\n\n    // 2. Check for buildable modules\n    if (activeModules.isEmpty()) {\n      LOG.info(\"No active modules to build in branch {} - failing build\", build.getId().get());\n      repositoryBuildService.fail(build);\n      return;\n    }\n\n    final Optional<Long> interProjectBuildId;\n    final Set<Module> toBuild;\n\n    // 3. The modules we choose to build depends on if this is an InterProject build or not\n    //    If this is an InterProject build we enqueue one of those as well.\n    if (build.getBuildOptions().getBuildDownstreams() == BuildDownstreams.INTER_PROJECT) {\n      toBuild = determineModulesToBuildUsingInterProjectBuildGraph(build, activeModules);\n      InterProjectBuild ipb = InterProjectBuild.getQueuedBuild(ImmutableSet.copyOf(getIds(toBuild)), build.getBuildTrigger());\n      interProjectBuildId = Optional.of(interProjectBuildService.enqueue(ipb));\n    } else {\n      interProjectBuildId = Optional.absent();\n      toBuild = findModulesToBuild(build, activeModules);\n    }\n\n    // 4. Launch the modules we want to build\n    for (Module module : build.getDependencyGraph().get().orderByTopologicalSort(toBuild)) {\n\n      enqueueModuleBuild(build, module);\n      if (build.getBuildOptions().getBuildDownstreams() == BuildDownstreams.INTER_PROJECT) {\n        interProjectBuildMappingService.insert(InterProjectBuildMapping.makeNewMapping(interProjectBuildId.get(), build.getBranchId(), build.getId(), module.getId().get()));\n      }\n    }\n\n    // 5. Only calculate skipped modules after we know what modules will build\n    Set<Module> skipped = Sets.difference(activeModules, toBuild);\n    for (Module module : skipped) {\n      moduleBuildService.skip(build, module);\n    }\n\n    // 6. Update the state of this branch build.\n    repositoryBuildService.update(build.toBuilder().setState(State.IN_PROGRESS).build());\n  }\n\n  @Inject public  LaunchingRepositoryBuildVisitor(RepositoryBuildService repositoryBuildService,\n                                         ModuleBuildService moduleBuildService,\n                                         MalformedFileService malformedFileService,\n                                         InterProjectBuildService interProjectBuildService,\n                                         InterProjectBuildMappingService interProjectBuildMappingService,\n                                         ModuleService moduleService,\n                                         DependenciesService dependenciesService,\n                                         GitHubHelper gitHubHelper);\n\n  private void failBranchAndModuleBuilds(RepositoryBuild build, Set<Module> activeModules);\n  private Set<Module> determineModulesToBuildUsingInterProjectBuildGraph(RepositoryBuild build, Set<Module> activeModules);\n  private Set<Module> findModulesToBuild(RepositoryBuild build, Set<Module> buildableModules);\n  private void addDownstreamModules(RepositoryBuild build, Set<Module> allModules, Set<Module> toBuild);\n  private boolean lastBuildSucceeded(Module module);\n  private static Set<Integer> getIds(Set<Module> modules);\n  private static Set<Module> filterActive(Set<Module> modules);\n  private static Map<Integer, Module> mapByModuleId(Set<Module> modules);\n  private void enqueueModuleBuild(RepositoryBuild branchBuild, Module module);\n\n  private static final BranchService branchService;\n  private static final BuildConfigUtils buildConfigUtils;\n  private static final RepositoryBuildService repositoryBuildService;\n  private static final ModuleBuildService moduleBuildService;\n  private static final MalformedFileService malformedFileService;\n  private static final InterProjectBuildService interProjectBuildService;\n  private static final InterProjectBuildMappingService interProjectBuildMappingService;\n  private static final ModuleService moduleService;\n  private static final DependenciesService dependenciesService;\n  private static final GitHubHelper gitHubHelper;\n  private static final GitInfo branch;\n  private static final BuildConfig defaultBuildConfig;\n  private static final Module activeModule;\n  private static final Module inactiveModule;\n  private static final Map<Integer, Set<Integer>> dependencyMap;\n  private static final CommitInfo commitInfo;\n  private static final RepositoryBuild launchingBuild;\n  private static final LaunchingRepositoryBuildVisitor buildVisitor;\n\n}\n\nclass LaunchingRepositoryBuildVisitorTest {\n\n  private static final BranchService branchService;\n  private static final BuildConfigUtils buildConfigUtils;\n  private static final RepositoryBuildService repositoryBuildService;\n  private static final ModuleBuildService moduleBuildService;\n  private static final MalformedFileService malformedFileService;\n  private static final InterProjectBuildService interProjectBuildService;\n  private static final InterProjectBuildMappingService interProjectBuildMappingService;\n  private static final ModuleService moduleService;\n  private static final DependenciesService dependenciesService;\n  private static final GitHubHelper gitHubHelper;\n  private static final GitInfo branch;\n  private static final BuildConfig defaultBuildConfig;\n  private static final Module activeModule;\n  private static final Module inactiveModule;\n  private static final Map<Integer, Set<Integer>> dependencyMap;\n  private static final CommitInfo commitInfo;\n  private static final RepositoryBuild launchingBuild;\n  private static final LaunchingRepositoryBuildVisitor buildVisitor;\n\n  @Test\n  public void itEnqueuesModuleBuildsAndUpdatesRepositoryBuildToLaunching() throws Exception {\n", "reference": "    when(malformedFileService.getMalformedFiles(anyInt())).thenReturn(ImmutableSet.of());\n    when(moduleService.getByBranch(1)).thenReturn(ImmutableSet.of(activeModule, inactiveModule));\n\n    doThrow(new RuntimeException(\"Build should not have been failed\")).when(repositoryBuildService).fail(any());\n\n    RepositoryBuild[] savedRepositoryBuild = {null};\n    doAnswer(invocation -> {\n      savedRepositoryBuild[0] = (RepositoryBuild) invocation.getArguments()[0];\n      return null;\n    }).when(repositoryBuildService).update(anyObject());\n\n    List<Module> modulesThatWereEnqueued = new ArrayList<>();\n    doAnswer(invocation -> {\n      modulesThatWereEnqueued.add((Module) invocation.getArguments()[1]);\n      return null;\n    }).when(moduleBuildService).enqueue(anyObject(), anyObject(), anyObject(), anyObject());\n\n    RepositoryBuild expectedRepositoryBuild = launchingBuild.toBuilder().setState(RepositoryBuild.State.IN_PROGRESS).build();\n\n    buildVisitor.visitLaunching(launchingBuild);\n\n    assertThat(savedRepositoryBuild).isNotNull();\n    assertThat(savedRepositoryBuild[0]).isEqualTo(expectedRepositoryBuild);\n\n    assertThat(modulesThatWereEnqueued).doesNotContain(inactiveModule);\n    assertThat(modulesThatWereEnqueued).isEqualTo(ImmutableList.of(activeModule));\n  }\n\n}", "prediction": "    buildVisitor.visit(launchingBuild);\n\n    assertThat(moduleBuildService.getByBranchAndState(launchingBuild.getBranchId(), State.QUEUED)).hasSize(1);\n    assertThat(moduleBuildService.getByBranchAndState(launchingBuild.getBranchId(), State.SKIPPED)).hasSize(1);\n    assertThat(moduleBuildService.getByBranchAndState(launchingBuild.getBranchId(), State.IN_PROGRESS)).hasSize(1);\n    assertThat(moduleBuildService.getByBranchAndState(launchingBuild.getBranchId(), State.SUCCESS)).hasSize(1);\n    assertThat(moduleBuildService.getByBranchAndState(launchingBuild.getBranchId(), State.FAILED)).hasSize(1);\n\n    assertThat(repositoryBuildService.getByBranchAndState(launchingBuild.getBranchId(), State.LAUNCHING)).hasSize(1);\n  }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "38716513_8", "part": [1, 1], "seq": [1, 1], "prompt": "class AnsiParser {\n\n    public static Stack<TextLeaf> parseText(String text) {\n        return new AnsiParser().parse(text);\n    }\n\n    private Stack<TextLeaf> parse(String text);\n    private void emitText(String text);\n    private void removeCurrentLine();\n    private boolean isResetLineEscape(String str, int controlStartPosition);\n\n}\n\nclass AnsiParserTest {\n\n    @Test\n    public void parseTextBackspace() throws Exception {\n", "reference": "        assertEquals(AnsiParser.parseText(\"Hello World\\b\\b\\b\\b\\b\\n\\bMars\"), new TextLeaf(\"Hello Mars\"));\n    }\n\n}", "prediction": "        Stack<TextLeaf> stack = AnsiParser.parseText(\"abc\\bdef\");\n        assertEquals(2, stack.size());\n        assertEquals(\"abc\", stack.get(0).getText());\n        assertEquals(\"def\", stack.get(1).getText());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "38781549_3", "part": [1, 1], "seq": [1, 1], "prompt": "class JSONUtil {\n\n    public static String toJSON( Object obj )\n    {\n        return toJSON(obj, (JSONConfig)null);\n    }\n\n    private  JSONUtil();\n\n    public static String toJSON( Object obj, JSONConfig cfg );\n    public static void toJSON( Object obj, Writer json );\n    public static void toJSON( Object obj, JSONConfig cfg, Writer json );\n    private static void appendPropertyValue( Object propertyValue, Writer json, JSONConfig cfg );\n    private static void appendRecursiblePropertyValue( Object propertyValue, Writer json, JSONConfig cfg, JSONType jsonType );\n    private static void appendSimplePropertyValue( Object propertyValue, Writer json, JSONConfig cfg, JSONType jsonType );\n    private static void appendNumber( Number num, Writer json, JSONConfig cfg );\n    private static void appendDate( Date date, Writer json, JSONConfig cfg );\n    private static void appendArrayPropertyValue( Object propertyValue, Writer json, JSONConfig cfg );\n    private static void appendObjectPropertyValue( Map<?,?> map, Writer json, JSONConfig cfg );\n    private static Map<?,?> resourceBundleToMap( ResourceBundle bundle );\n    private static String getPropertyName( Object key, JSONConfig cfg, Set<String> propertyNames );\n    private static void appendPropertyName( String propertyName, Writer json, boolean quoteIdentifier );\n    private static String escapeBadIdentifierCodePoints( String propertyName, JSONConfig cfg );\n    private static String escapeNonAscii( String str, JSONConfig cfg );\n    private static String escapeSurrogates( String str, JSONConfig cfg );\n    private static boolean hasSurrogates( String str );\n    private static void writeString( String strValue, Writer json, JSONConfig cfg, boolean checkNum );\n    private static void fastWriteString( String strValue, Writer json );\n    private static boolean isValidJSONNumber( String numericString, JSONConfig cfg, Number num );\n    private static boolean isSafeJsonNumber( Number num, String numericString, JSONConfig cfg );\n    static ResourceBundle getBundle( Locale locale );\n    public static Set<String> getJavascriptReservedWords();\n    public static boolean isReservedWord( String name );\n    static boolean isValidIdentifierStart( int codePoint, JSONConfig cfg );\n    static boolean isValidIdentifierPart( int codePoint, JSONConfig cfg );\n    public static void checkValidJavascriptPropertyName( String propertyName, JSONConfig cfg );\n    public static void checkValidJavascriptPropertyName( String propertyName );\n    private static void checkValidJavascriptPropertyNameImpl( String propertyName, JSONConfig cfg );\n    public static boolean isValidJavascriptPropertyName( String propertyName, JSONConfig cfg );\n    public static boolean isValidJavascriptPropertyName( String propertyName );\n    private static boolean isValidJavascriptPropertyNameImpl( String propertyName, JSONConfig cfg );\n    static Pattern getPropertyNameValidationPattern( JSONConfig cfg );\n\n    private static final Log s_log;\n    private static Invocable invocable;\n    private static final int BAD_CHARS;\n\n}\n\nclass TestJSONUtil {\n\n    private static final Log s_log;\n    private static Invocable invocable;\n    private static final int BAD_CHARS;\n\n    @Test\n    public void testECMA6UnicodeEscapeInString()\n    {\n", "reference": "        JSONConfig cfg = new JSONConfig().setUseECMA6(true).setEscapeNonAscii(true)\n                                         .setBadCharacterPolicy(JSONConfig.ESCAPE);\n        StringBuilder buf = new StringBuilder();\n        Set<Character> singles = new HashSet<>(Arrays.asList('\\b','\\t','\\n','\\f','\\r'));\n        Random rand = new Random();\n        int bound = Character.MAX_CODE_POINT+1;\n        int min = Character.MIN_SUPPLEMENTARY_CODE_POINT;\n        for ( int i = 0; i < 4096; i++ ){\n            int cp;\n            do{\n                cp = rand.nextInt(bound);\n            }while ( cp > 0xF && cp < min );\n            buf.setLength(0);\n            buf.appendCodePoint(cp);\n            String result;\n            if ( cp < 0xF && singles.contains((char)cp) ){\n                result = '\"' + StringProcessor.getEscape((char)cp) + '\"';\n            }else{\n                result = '\"' + String.format(\"\\\\u{%X}\", cp) + '\"';\n            }\n            String json = JSONUtil.toJSON(buf, cfg);\n            assertThat(json, is(result));\n        }\n    }\n\n}", "prediction": "        String json = \"{\\\"key\\\":\\\"\\\\u{1F600}\\\"}\";\n        JSONObject obj = JSONUtil.toJSONObject(json);\n        assertEquals(\"\ud83d\ude00\", obj.getString(\"key\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "39889599_2", "part": [1, 1], "seq": [1, 1], "prompt": "class AdapterDelegatesManager {\n\n    public void onBindViewHolder(@NonNull T items, int position,\n                                 @NonNull RecyclerView.ViewHolder holder, List payloads) {\n\n        AdapterDelegate<T> delegate = getDelegateForViewType(holder.getItemViewType());\n        if (delegate == null) {\n            throw new NullPointerException(\"No delegate found for item at position = \"\n                    + position\n                    + \" for viewType = \"\n                    + holder.getItemViewType());\n        }\n        delegate.onBindViewHolder(items, position, holder,\n                payloads != null ? payloads : PAYLOADS_EMPTY_LIST);\n    }\n\n    public  AdapterDelegatesManager();\n    public  AdapterDelegatesManager(@NonNull AdapterDelegate<T>... delegates);\n\n    public AdapterDelegatesManager<T> addDelegate(@NonNull AdapterDelegate<T> delegate);\n    public AdapterDelegatesManager<T> addDelegate(int viewType,\n                                                  @NonNull AdapterDelegate<T> delegate);\n    public AdapterDelegatesManager<T> addDelegate(int viewType, boolean allowReplacingDelegate,\n                                                  @NonNull AdapterDelegate<T> delegate);\n    public AdapterDelegatesManager<T> removeDelegate(@NonNull AdapterDelegate<T> delegate);\n    public AdapterDelegatesManager<T> removeDelegate(int viewType);\n    public int getItemViewType(@NonNull T items, int position);\n    @NonNull public RecyclerView.ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType);\n    public void onBindViewHolder(@NonNull T items, int position,\n                                 @NonNull RecyclerView.ViewHolder holder);\n    public void onViewRecycled(@NonNull RecyclerView.ViewHolder holder);\n    public boolean onFailedToRecycleView(@NonNull RecyclerView.ViewHolder holder);\n    public void onViewAttachedToWindow(@NonNull RecyclerView.ViewHolder holder);\n    public void onViewDetachedFromWindow(@NonNull RecyclerView.ViewHolder holder);\n    public AdapterDelegatesManager<T> setFallbackDelegate(\n            @Nullable AdapterDelegate<T> fallbackDelegate);\n    public int getViewType(@NonNull AdapterDelegate<T> delegate);\n    @Nullable public AdapterDelegate<T> getDelegateForViewType(int viewType);\n    @Nullable public AdapterDelegate<T> getFallbackDelegate();\n\n}\n\nclass AdapterDelegatesManagerTest {\n\n    @Test\n    public void onBindViewHolder() {\n", "reference": "\n        // 3 elements and each element has it's own viewtype and hence own delegate\n        List<Object> items = Arrays.asList(new Object(), new Object(), new Object());\n        SpyableAdapterDelegate<List<Object>> d0 = new SpyableAdapterDelegate<>(0);\n        SpyableAdapterDelegate<List<Object>> d1 = new SpyableAdapterDelegate<>(1);\n        SpyableAdapterDelegate<List<Object>> d2 = new SpyableAdapterDelegate<>(2);\n\n        AdapterDelegatesManager<List<Object>> manager = new AdapterDelegatesManager<>();\n        manager.addDelegate(d0);\n        manager.addDelegate(d1);\n        manager.addDelegate(d2);\n\n        // Test first item\n        manager.onBindViewHolder(items, 0, d0.viewHolder);\n        Assert.assertTrue(d0.onBindViewHolderCalled);\n        Assert.assertFalse(d1.onBindViewHolderCalled);\n        Assert.assertFalse(d2.onBindViewHolderCalled);\n\n        resetDelegates(d0, d1, d2);\n\n        // Test second item\n        manager.onBindViewHolder(items, 1, d1.viewHolder);\n        Assert.assertTrue(d1.onBindViewHolderCalled);\n        Assert.assertFalse(d0.onBindViewHolderCalled);\n        Assert.assertFalse(d2.onBindViewHolderCalled);\n\n        resetDelegates(d0, d1, d2);\n\n        // Test third item\n        manager.onBindViewHolder(items, 2, d2.viewHolder);\n        Assert.assertTrue(d2.onBindViewHolderCalled);\n        Assert.assertFalse(d1.onBindViewHolderCalled);\n        Assert.assertFalse(d0.onBindViewHolderCalled);\n\n        resetDelegates(d0, d1, d2);\n    }\n\n}", "prediction": "        AdapterDelegatesManager<String> manager = new AdapterDelegatesManager<>();\n        manager.addDelegate(new AdapterDelegate<String>() {\n            @Override\n            public boolean isForViewType(@NonNull String items, int position) {\n                return true;\n            }\n\n            @NonNull\n            @Override\n            public RecyclerView.ViewHolder onCreateViewHolder(@NonNull ViewGroup parent) {\n                return null;\n            }\n\n            @Override\n            public void onBindViewHolder(@NonNull String items, int position,\n                                        @NonNull RecyclerView.ViewHolder holder) {\n\n            }\n        });\n        manager.onBindViewHolder(\"\", 0, mock(RecyclerView.ViewHolder.class), null);\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "39905754_12", "part": [1, 1], "seq": [1, 1], "prompt": "class EightQueens {\n\n    static boolean isSolution(List<Position> board) {\n        int size = board.size();\n        for (int i = 0; i < size; i++) {\n            Position firstPosition = board.get(i);\n            if (firstPosition.intersectPositions(board, i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static List<Position> findSolution(int boardSize);\n    private static List<Position> generate(int size);\n\n}\n\nclass EightQueensTest {\n\n    @Test\n    public void\n    it_should_refuse_two_queens_with_same_y(){\n", "reference": "        List<Position> board = asList(pos(0, 0), pos(1, 0));\n        assertFalse(EightQueens.isSolution(board));\n    }\n\n}", "prediction": "        List<Position> board = EightQueens.findSolution(2);\n        assertThat(board).hasSize(2);\n        assertThat(board.get(0).getX()).isEqualTo(0);\n        assertThat(board.get(0).getY()).isEqualTo(0);\n        assertThat(board.get(1).getX()).isEqualTo(1);\n        assertThat(board.get(1).getY()).isEqualTo(0);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "40001904_44", "part": [1, 1], "seq": [1, 1], "prompt": "class Page implements WikiConstants {\n\n\tpublic int getNumberOfCategories()\n\t{\n\t\tBigInteger nrOfCategories = new BigInteger(\"0\");\n\n\t\tlong id = __getId();\n\t\tSession session = wiki.__getHibernateSession();\n\t\tsession.beginTransaction();\n\t\tObject returnValue = session\n\t\t\t\t.createNativeQuery(\"select count(pages) from page_categories where id = :pageid\")\n\t\t\t\t.setParameter(\"pageid\", id, LongType.INSTANCE).uniqueResult();\n\t\tsession.getTransaction().commit();\n\n\t\tif (returnValue != null) {\n\t\t\tnrOfCategories = (BigInteger) returnValue;\n\t\t}\n\t\treturn nrOfCategories.intValue();\n\t}\n\n\tprotected  Page(Wikipedia wiki, long id);\n\tprotected  Page(Wikipedia wiki, int pageID);\n\tpublic  Page(Wikipedia wiki, String pName);\n\tpublic  Page(Wikipedia wiki, String pName, boolean useExactTitle);\n\tprotected  Page(Wikipedia wiki, long id,\n\t\t\tde.tudarmstadt.ukp.wikipedia.api.hibernate.Page hibernatePage);\n\n\tprivate void fetchByHibernateId(long id);\n\tprivate void fetchByPageId(int pageID);\n\tprivate void fetchByTitle(Title pTitle, boolean useExactTitle);\n\t long __getId();\n\tpublic int getPageId();\n\tpublic Set<Category> getCategories();\n\tpublic Set<Page> getInlinks();\n\tpublic int getNumberOfInlinks();\n\tpublic Set<Integer> getInlinkIDs();\n\tpublic Set<Page> getOutlinks();\n\tpublic int getNumberOfOutlinks();\n\tpublic Set<Integer> getOutlinkIDs();\n\tpublic Title getTitle();\n\tpublic Set<String> getRedirects();\n\tpublic String getText();\n\tpublic boolean isDisambiguation();\n\tpublic boolean isRedirect();\n\tpublic boolean isDiscussion();\n\tpublic String getPlainText();\n\tprivate Object parsePage(AstVisitor v);\n\tprivate EngProcessedPage getCompiledPage();\n\tprotected String getPageInfo();\n\n\tprivate static final Logger logger;\n\tprivate static final String A_FAMOUS_PAGE;\n\tprivate static final int A_FAMOUS_PAGE_ID;\n\tprivate static final long A_FAMOUS_PAGE_OBJECT_ID;\n\tprivate Page page;\n\n}\n\nclass PageTest  {\n\n\tprivate static final Logger logger;\n\tprivate static final String A_FAMOUS_PAGE;\n\tprivate static final int A_FAMOUS_PAGE_ID;\n\tprivate static final long A_FAMOUS_PAGE_OBJECT_ID;\n\tprivate Page page;\n\n\t@Test\n\tpublic void testGetNumberOfCategories() {\n", "reference": "\t\tint categories = page.getNumberOfCategories();\n\t\tassertTrue(categories > 0);\n\t\tassertEquals(2, categories);\n\t}\n\n}", "prediction": "\t\tassertEquals(1, page.getNumberOfCategories());\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "40101342_3", "part": [1, 1], "seq": [1, 1], "prompt": "class HbaseQueryImpl implements HbaseQuery {\n\n    @Override\n    public List<DynaBean> select(String sql) throws SQLSyntaxErrorException, IOException {\n        return select(sql, null, null);\n    }\n\n    @Override public List<DynaBean> select(String sql, String startRow,\n            String stopRow);\n    private SelectSqlVisitor parseSql(String sql);\n\n     HbaseQuery hbaseQuery;\n\n}\n\nclass HbaseQueryImplTest {\n\n     HbaseQuery hbaseQuery;\n\n    @Test\n    public void testLimit() throws SQLSyntaxErrorException, IOException {\n", "reference": "        String sql = \"SELECT TIME_ID, AREA_NAME FROM report1 limit 3 offset 2\";\n        HbaseQuery hbaseQuery = new HbaseQueryImpl();\n        List<DynaBean> rows = hbaseQuery.select(sql);\n        printBean(rows);\n        Assert.assertEquals(3, rows.size());\n    }\n\n}", "prediction": "        List<DynaBean> result = hbaseQuery.select(\"select * from test limit 10\");\n        assertEquals(10, result.size());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "40735368_644", "part": [1, 1], "seq": [1, 1], "prompt": "class SchemaResolver {\n\n    public static String getSimpleHttpResourcePath(String location) {\n        return getSimpleHttpResourcePath(location, false);\n    }\n\n    public  SchemaResolver(SchemaCatalog catalog, boolean classpath, SchemaCache cache);\n    public  SchemaResolver(SchemaCatalog catalog, SchemaCache cache);\n    public  SchemaResolver();\n    public  SchemaResolver(SchemaCatalog catalog);\n    public  SchemaResolver(SchemaCache cache);\n\n    public String resolve(String location, String context);\n    public String resolve(String location);\n    public static String getSimpleHttpResourcePath(String location, boolean keepQuery);\n    public static String getSimpleHttpResourcePath(URI location);\n    public static String getSimpleHttpResourcePath(URI location, boolean keepQuery);\n    public static URL getClasspathResourceUrl(String location);\n    public static String resolveClasspathLocation(String location);\n    private static String stringToMD5String(String message);\n\n}\n\nclass SchemaResolverTest {\n\n    @Test\n    public void queryIgnored() {\n", "reference": "        String path = SchemaResolver\n                .getSimpleHttpResourcePath(\"http://schemas.example.org/exampleml/exml.xsd?q=ignored\");\n        Assert.assertEquals(\"/org/example/schemas/exampleml/exml.xsd\", path);\n    }\n\n}", "prediction": "        String location = \"http://example.com/schema.xsd?query\";\n        String expected = \"http://example.com/schema.xsd\";\n        assertEquals(expected, SchemaResolver.getSimpleHttpResourcePath(location));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "41263775_123", "part": [1, 1], "seq": [1, 1], "prompt": "class GeneratedAttributeSupport {\n\npublic static Byte valueOf(byte value) { return value; public static Byte valueOf(byte value) { return value; }\n\npublic static Byte valueOf(byte value) { return value;   GeneratedAttributeSupport();\n\npublic static Byte valueOf(byte value) { return value; public static Short valueOf(short value);\npublic static Byte valueOf(byte value) { return value; public static Integer valueOf(int value);\npublic static Byte valueOf(byte value) { return value; public static Long valueOf(long value);\npublic static Byte valueOf(byte value) { return value; public static Float valueOf(float value);\npublic static Byte valueOf(byte value) { return value; public static Double valueOf(double value);\npublic static Byte valueOf(byte value) { return value; public static Boolean valueOf(boolean value);\npublic static Byte valueOf(byte value) { return value; public static Character valueOf(char value);\npublic static Byte valueOf(byte value) { return value; public static List<Byte> valueOf(byte[] value);\npublic static Byte valueOf(byte value) { return value; public static List<Short> valueOf(short[] value);\npublic static Byte valueOf(byte value) { return value; public static List<Integer> valueOf(int[] value);\npublic static Byte valueOf(byte value) { return value; public static List<Long> valueOf(long[] value);\npublic static Byte valueOf(byte value) { return value; public static List<Float> valueOf(float[] value);\npublic static Byte valueOf(byte value) { return value; public static List<Double> valueOf(double[] value);\npublic static Byte valueOf(byte value) { return value; public static List<Boolean> valueOf(boolean[] value);\npublic static Byte valueOf(byte value) { return value; public static List<Character> valueOf(char[] value);\npublic static Byte valueOf(byte value) { return value; public static List<T> valueOf(T[] value);\npublic static Byte valueOf(byte value) { return value; public static List<T> valueOf(List<T> value);\npublic static Byte valueOf(byte value) { return value; public static T valueOf(T value);\npublic static Byte valueOf(byte value) { return value; static List<T> wrapArray(final Object array);\n\n}\n\nclass GeneratedAttributeSupportTest {\n\n    @Test\n    public void testAsList_PrimitiveArray() throws Exception {\n", "reference": "        int[] input = new int[] {1, 2, 3, 4, 5};\n        List<Integer> list = GeneratedAttributeSupport.valueOf(input);\n        Assert.assertEquals(5, list.size());\n        for (int i = 0; i < 5; i++) {\n            Assert.assertEquals(Integer.valueOf(input[i]), list.get(i));\n        }\n\n        list.set(2, 7);\n        Assert.assertEquals(Integer.valueOf(7), list.get(2));\n        Assert.assertEquals(7, input[2]);\n    }\n\n}", "prediction": "        assertEquals(Arrays.asList(1, 2, 3), GeneratedAttributeSupport.valueOf(new byte[] { 1, 2, 3 }));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "41294846_7", "part": [1, 1], "seq": [1, 1], "prompt": "class Objects {\n\n\tstatic boolean equals(final Object a, final Object b) {\n\t\treturn (a == null) ? (b == null) : a.equals(b);\n\t}\n\n\tstatic boolean deepEquals(final Object a, final Object b);\n\tstatic int hash(final Object... values);\n\tstatic String toString(final Object o);\n\n}\n\nclass ObjectsTest {\n\n  @Test public void equals_differentBooleanParams_returnFalse() {\n", "reference": "    // Given\n    final boolean paramA = true;\n    final boolean paramB = false;\n\n    // When\n    final boolean result = Objects.equals(paramA, paramB);\n\n    // Then\n    assertThat(result, is(false));\n  }\n\n}", "prediction": "    assertFalse(Objects.equals(true, false));\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "41307987_12", "part": [1, 1], "seq": [1, 1], "prompt": "class BasicLoop {\n\n\tpublic String doSomethingWithInput(String input) {\n\t\ttry {\n\t\t\tString[] articles = input.split(\",\");\n\t\t\tfor (String article : articles) {\n\t\t\t\tswitch (Articles.valueOf(article.trim().toLowerCase())) {\n\t\t\t\tcase pommes:\n\t\t\t\t\ttotal += 100;\n\t\t\t\t\ttotal += remisePommesGlobale();\n\t\t\t\t\tbreak;\n\t\t\t\tcase apples:\n\t\t\t\t\ttotal += 100;\n\t\t\t\t\ttotal += remiseApples();\n\t\t\t\t\ttotal += remisePommesGlobale();\n\t\t\t\t\tbreak;\n\t\t\t\tcase mele:\n\t\t\t\t\ttotal += 100;\n\t\t\t\t\ttotal += remiseMele();\n\t\t\t\t\ttotal += remisePommesGlobale();\n\t\t\t\t\tbreak;\n\t\t\t\tcase cerises:\n\t\t\t\t\ttotal += 75;\n\t\t\t\t\ttotal += remiseCerises();\n\t\t\t\t\tbreak;\n\t\t\t\tcase bananes:\n\t\t\t\t\ttotal += 150;\n\t\t\t\t\ttotal += remiseBananes();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttotal += remiseFruitGlobale();\n\t\t\t}\n\t\t\treturn \"< \" + String.valueOf(total);\n\t\t} catch (IllegalArgumentException|NullPointerException e) {\n\t\t\treturn \"< \" + input;\n\t\t}\n\t}\n\n\tpublic void loop();\n\tprivate int remiseBananes();\n\tprivate int remiseCerises();\n\tprivate int remiseApples();\n\tprivate int remiseMele();\n\tprivate int remisePommesGlobale();\n\tprivate int remiseFruitGlobale();\n\tpublic static void main(String[] args);\n\n}\n\nclass BasicLoopTest {\n\n    @Test\n    @Ignore\n    public void doit_supporter_la_remise_par_article() {\n", "reference": "    \tBasicLoop basicLoop = new BasicLoop();\n    \tString out = basicLoop.doSomethingWithInput(\"mele\");\n\t\tassertThat(out ).isEqualTo(\"< 100\");\n    \tout = basicLoop.doSomethingWithInput(\"Apples\");\n\t\tassertThat(out ).isEqualTo(\"< 200\");\n    \tout = basicLoop.doSomethingWithInput(\"apples\");\n\t\tassertThat(out ).isEqualTo(\"< 300\");\n\t\tout = basicLoop.doSomethingWithInput(\"Pommes\");\n\t\tassertThat(out ).isEqualTo(\"< 400\");\n\t\tout = basicLoop.doSomethingWithInput(\"apples\");\n\t\tassertThat(out ).isEqualTo(\"< 400\");\n\t\tout = basicLoop.doSomethingWithInput(\"mele\");\n\t\tassertThat(out ).isEqualTo(\"< 450\");\n    \tout = basicLoop.doSomethingWithInput(\"cerises\");\n\t\tassertThat(out ).isEqualTo(\"< 525\");\n    \tout = basicLoop.doSomethingWithInput(\"cerises\");\n\t\tassertThat(out ).isEqualTo(\"< 580\");\n    }\n\n}", "prediction": "        BasicLoop loop = new BasicLoop();\n        assertEquals(\"< 100\", loop.doSomethingWithInput(\"pommes\"));\n        assertEquals(\"< 100\", loop.doSomethingWithInput(\"pommes,pommes\"));\n        assertEquals(\"< 100\", loop.doSomethingWithInput(\"pommes,pommes,pommes\"));\n        assertEquals(\"< 100\", loop.doSomethingWithInput(\"pommes,pommes,pommes,pommes\"));\n        assertEquals(\"< 100\", loop.doSomethingWithInput(\"pommes,pommes,pommes,pommes,pommes\"));\n        assertEquals(\"< 100\", loop.doSomethingWithInput(\"pommes,pommes,pommes,pommes,pommes,pommes\"));\n        assertEquals(\"< 100\", loop.doSomethingWithInput(\"pommes,pommes,pommes,pommes,pommes,pommes,pommes\"));\n        assertEquals(\"< 100\", loop.doSomethingWithInput(\"pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes\"));\n        assertEquals(\"< 100\", loop.doSomethingWithInput(\"pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes\"));\n        assertEquals(\"< 100\", loop.doSomethingWithInput(\"pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes\"));\n        assertEquals(\"< 100\", loop.doSomethingWithInput(\"pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes\"));\n        assertEquals(\"< 100\", loop.doSomethingWithInput(\"pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes\"));\n        assertEquals(\"< 100\", loop.doSomethingWithInput(\"pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes\"));\n        assertEquals(\"< 100\", loop.doSomethingWithInput(\"pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes\"));\n        assertEquals(\"< 100\", loop.doSomethingWithInput(\"pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes\"));\n        assertEquals(\"< 100\", loop.doSomethingWithInput(\"pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes\"));\n        assertEquals(\"< 100\", loop.doSomethingWithInput(\"pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes\"));\n        assertEquals(\"< 100\", loop.doSomethingWithInput(\"pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes\"));\n        assertEquals(\"< 100\", loop.doSomethingWithInput(\"pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes\"));\n        assertEquals(\"< 100\", loop.doSomethingWithInput(\"pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes\"));\n        assertEquals(\"< 100\", loop.doSomethingWithInput(\"pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes\"));\n        assertEquals(\"< 100\", loop.doSomethingWithInput(\"pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes\"));\n        assertEquals(\"< 100\", loop.doSomethingWithInput(\"pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes\"));\n        assertEquals(\"< 100\", loop.doSomethingWithInput(\"pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes\"));\n        assertEquals(\"< 100\", loop.doSomethingWithInput(\"pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes\"));\n        assertEquals(\"< 100\", loop.doSomethingWithInput(\"pommes,pommes,pommes,pommes,pommes,pommes,pommes,pommes", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "42585709_5", "part": [1, 1], "seq": [1, 1], "prompt": "class SecurityUtils {\n\n    public static boolean isAuthenticated() {\n        SecurityContext securityContext = SecurityContextHolder.getContext();\n        Collection<? extends GrantedAuthority> authorities = securityContext.getAuthentication().getAuthorities();\n        if (authorities != null) {\n            for (GrantedAuthority authority : authorities) {\n                if (authority.getAuthority().equals(AuthoritiesConstants.ANONYMOUS)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    private  SecurityUtils();\n\n    public static String getCurrentLogin();\n    public static boolean isUserInRole(String authority);\n\n}\n\nclass SecurityUtilsTest {\n\n    @Test\n    public void testAnonymousIsNotAuthenticated() {\n", "reference": "        SecurityContext securityContext = SecurityContextHolder.createEmptyContext();\n        Collection<GrantedAuthority> authorities = new ArrayList<>();\n        authorities.add(new SimpleGrantedAuthority(AuthoritiesConstants.ANONYMOUS));\n        securityContext.setAuthentication(new UsernamePasswordAuthenticationToken(\"anonymous\", \"anonymous\", authorities));\n        SecurityContextHolder.setContext(securityContext);\n        boolean isAuthenticated = SecurityUtils.isAuthenticated();\n        assertThat(isAuthenticated).isFalse();\n    }\n\n}", "prediction": "        assertFalse(SecurityUtils.isAuthenticated());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "42847560_12", "part": [1, 1], "seq": [1, 1], "prompt": "class QueryStringDecoderUtil {\n\n    public Map<String, List<String>> parameters() {\n        if (params == null) {\n            if (hasPath) {\n                int pathLength = path().length();\n                if (uri.length() == pathLength) {\n                    return Collections.emptyMap();\n                }\n                decodeParams(uri.substring(pathLength + 1));\n            } else {\n                if (uri.isEmpty()) {\n                    return Collections.emptyMap();\n                }\n                decodeParams(uri);\n            }\n        }\n        return params;\n    }\n\n    public  QueryStringDecoderUtil(String uri);\n    public  QueryStringDecoderUtil(String uri, boolean hasPath);\n    public  QueryStringDecoderUtil(String uri, Charset charset);\n    public  QueryStringDecoderUtil(String uri, Charset charset, boolean hasPath);\n    public  QueryStringDecoderUtil(String uri, Charset charset, boolean hasPath, int maxParams);\n    public  QueryStringDecoderUtil(URI uri);\n    public  QueryStringDecoderUtil(URI uri, Charset charset);\n    public  QueryStringDecoderUtil(URI uri, Charset charset, int maxParams);\n\n    public String uri();\n    public String path();\n    private void decodeParams(String s);\n    private boolean addParam(Map<String, List<String>> params, String name, String value);\n    public static String decodeComponent(final String s);\n    public static String decodeComponent(final String s, final Charset charset);\n    private static char decodeHexNibble(final char c);\n\n}\n\nclass QueryStringDecoderUtilTest {\n\n    @Test\n    public void testBasicUris() throws URISyntaxException {\n", "reference": "        QueryStringDecoderUtil d = new QueryStringDecoderUtil(new URI(\"http://localhost/path\"));\n        assertEquals(0, d.parameters().size());\n    }\n\n}", "prediction": "        QueryStringDecoderUtil decoder = new QueryStringDecoderUtil(\"http://localhost:8080/path?param1=value1&param2=value2\");\n        assertEquals(\"http://localhost:8080/path?param1=value1&param2=value2\", decoder.uri());\n        assertEquals(\"http://localhost:8080/path\", decoder.path());\n        assertEquals(2, decoder.parameters().size());\n        assertEquals(\"value1\", decoder.parameters().get(\"param1\").get(0));\n        assertEquals(\"value2\", decoder.parameters().get(\"param2\").get(0));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "42949039_256", "part": [1, 1], "seq": [1, 1], "prompt": "class BusinessObjectDataKeyComparator implements Comparator<BusinessObjectDataKey>, Serializable {\n\n    @Override\n    public int compare(final BusinessObjectDataKey data1, final BusinessObjectDataKey data2)\n    {\n        if (data1 == null || data2 == null)\n        {\n            return data1 == null && data2 == null ? 0 : (data1 == null ? -1 : 1);\n        }\n        int result = ObjectUtils.compare(data1.getBusinessObjectDefinitionName(), data2.getBusinessObjectDefinitionName());\n        if (result != 0)\n        {\n            return result;\n        }\n        result = ObjectUtils.compare(data1.getBusinessObjectFormatUsage(), data2.getBusinessObjectFormatUsage());\n        if (result != 0)\n        {\n            return result;\n        }\n        result = ObjectUtils.compare(data1.getBusinessObjectFormatFileType(), data2.getBusinessObjectFormatFileType());\n        if (result != 0)\n        {\n            return result;\n        }\n        result = ObjectUtils.compare(data1.getBusinessObjectFormatVersion(), data2.getBusinessObjectFormatVersion());\n        if (result != 0)\n        {\n            return result;\n        }\n        result = ObjectUtils.compare(data1.getPartitionValue(), data2.getPartitionValue());\n        if (result != 0)\n        {\n            return result;\n        }\n        return ObjectUtils.compare(data1.getBusinessObjectDataVersion(), data2.getBusinessObjectDataVersion());\n    }\n\n    private BusinessObjectDataKeyComparator comparator;\n\n}\n\nclass BusinessObjectDataKeyComparatorTest {\n\n    private BusinessObjectDataKeyComparator comparator;\n\n    @Test\n    public void testCompareBusinessObjectDataVersion() throws Exception\n    {\n", "reference": "        BusinessObjectDataKey businessObjectDataKey1 = new BusinessObjectDataKey();\n        BusinessObjectDataKey businessObjectDataKey2 = new BusinessObjectDataKey();\n\n        // \"a\" = \"b\"\n        businessObjectDataKey1.setBusinessObjectDataVersion(0);\n        businessObjectDataKey2.setBusinessObjectDataVersion(0);\n        assertEquals(0, comparator.compare(businessObjectDataKey1, businessObjectDataKey2));\n\n        // \"a\" < \"b\"\n        businessObjectDataKey1.setBusinessObjectDataVersion(0);\n        businessObjectDataKey2.setBusinessObjectDataVersion(1);\n        assertEquals(-1, comparator.compare(businessObjectDataKey1, businessObjectDataKey2));\n\n        // \"b\" > \"a\"\n        assertEquals(1, comparator.compare(businessObjectDataKey2, businessObjectDataKey1));\n    }\n\n}", "prediction": "        BusinessObjectDataKey key1 = new BusinessObjectDataKey();\n        key1.setBusinessObjectDataVersion(1);\n        BusinessObjectDataKey key2 = new BusinessObjectDataKey();\n        key2.setBusinessObjectDataVersion(2);\n        assertTrue(comparator.compare(key1, key2) < 0);\n        assertTrue(comparator.compare(key2, key1) > 0);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "43156715_2", "part": [1, 1], "seq": [1, 1], "prompt": "class Filter {\n\n    public static Function<Beacon, Boolean> proximityIsEqualTo(final Proximity... proximities) {\n        return new Function<Beacon, Boolean>() {\n            @Override\n            public Boolean apply(Beacon beacon) {\n                for (Proximity proximity : proximities) {\n                    if (beacon.getProximity() == proximity) {\n                        return true;\n                    }\n                }\n\n                return false;\n            }\n        };\n    }\n\n    public static Function<Beacon, Boolean> proximityIsNotEqualTo(final Proximity... proximities);\n    public static Function<Beacon, Boolean> distanceIsEqualTo(final double distance);\n    public static Function<Beacon, Boolean> distanceIsGreaterThan(final double distance);\n    public static Function<Beacon, Boolean> distanceIsLowerThan(final double distance);\n    public static Function<Beacon, Boolean> hasName(final String... names);\n    public static Function<Beacon, Boolean> exceptName(final String... names);\n    public static Function<Beacon, Boolean> hasMacAddress(final String... macs);\n    public static Function<Beacon, Boolean> exceptMacAddress(final String... macs);\n    public static Function<Beacon, Boolean> hasMacAddress(final MacAddress... macs);\n    public static Function<Beacon, Boolean> exceptMacAddress(final MacAddress... macs);\n\n}\n\nclass FilterTest {\n\n  @Test\n  public void proximityShouldBeEqualToImmediateAndNear() {\n", "reference": "    // given\n    Beacon beacon = Mockito.mock(Beacon.class);\n\n    // when\n    when(beacon.getProximity()).then(new Answer<Proximity>() {\n      @Override\n      public Proximity answer(InvocationOnMock invocationOnMock) throws Throwable {\n        return Proximity.NEAR;\n      }\n    });\n\n    Function<Beacon, Boolean> filter =\n        Filter.proximityIsEqualTo(Proximity.IMMEDIATE, Proximity.NEAR);\n    Boolean call = apply(filter, beacon);\n\n    // then\n    assertThat(call).isTrue();\n  }\n\n}", "prediction": "    Beacon beacon = new Beacon(Proximity.IMMEDIATE, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, ", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "43989661_0", "part": [1, 1], "seq": [1, 1], "prompt": "class TimeResolver {\n\n    public static Long resolveExpression(String subject) {\n      Matcher m = expiryPattern.matcher(subject);\n      if (m.find()) {\n        String key = m.group(2);\n        if (key.equals(\"\")) key = defaultUnit;\n        return Long.parseLong(m.group(1), 10) * timeMultipliers.get(key);\n      }\n      return -1L;\n    }\n\n    public static ZonedDateTime getExpiryDate(String expiresInString);\n\n}\n\nclass TimeResolverTest {\n\n  @Test\n  public void testResolution() {\n", "reference": "    Assert.assertEquals(TimeResolver.resolveExpression(\"30s\"), Long.valueOf(30));\n    Assert.assertEquals(TimeResolver.resolveExpression(\"180s\"), Long.valueOf(180));\n    Assert.assertEquals(TimeResolver.resolveExpression(\"1m\"), Long.valueOf(60));\n    Assert.assertEquals(TimeResolver.resolveExpression(\"10m\"), Long.valueOf(600));\n    Assert.assertEquals(TimeResolver.resolveExpression(\"2h\"), Long.valueOf(7200));\n  }\n\n}", "prediction": "    assertEquals(1000L, TimeResolver.resolveExpression(\"1s\"));\n    assertEquals(1000L, TimeResolver.resolveExpression(\"1000ms\"));\n    assertEquals(1000L, TimeResolver.resolveExpression(\"1000\"));\n    assertEquals(1000L, TimeResolver.resolveExpression(\"1000 \"));\n    assertEquals(1000L, TimeResolver.resolveExpression(\"1000 \" + defaultUnit));\n    assertEquals(1000L, TimeResolver.resolveExpression(\"1000 \" + defaultUnit + \"s\"));\n    assertEquals(1000L, TimeResolver.resolveExpression(\"1000 \" + defaultUnit + \"s \"));\n    assertEquals(1000L, TimeResolver.resolveExpression(\"1000 \" + defaultUnit + \"s \" + defaultUnit));\n    assertEquals(1000L, TimeResolver.resolveExpression(\"1000 \" + defaultUnit + \"s \" + defaultUnit + \"s\"));\n    assertEquals(1000L, TimeResolver.resolveExpression(\"1000 \" + defaultUnit + \"s \" + defaultUnit + \"s \"));\n    assertEquals(1000L, TimeResolver.resolveExpression(\"1000 \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit));\n    assertEquals(1000L, TimeResolver.resolveExpression(\"1000 \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s\"));\n    assertEquals(1000L, TimeResolver.resolveExpression(\"1000 \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \"));\n    assertEquals(1000L, TimeResolver.resolveExpression(\"1000 \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit));\n    assertEquals(1000L, TimeResolver.resolveExpression(\"1000 \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s\"));\n    assertEquals(1000L, TimeResolver.resolveExpression(\"1000 \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \"));\n    assertEquals(1000L, TimeResolver.resolveExpression(\"1000 \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit));\n    assertEquals(1000L, TimeResolver.resolveExpression(\"1000 \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s\"));\n    assertEquals(1000L, TimeResolver.resolveExpression(\"1000 \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \"));\n    assertEquals(1000L, TimeResolver.resolveExpression(\"1000 \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit));\n    assertEquals(1000L, TimeResolver.resolveExpression(\"1000 \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s\"));\n    assertEquals(1000L, TimeResolver.resolveExpression(\"1000 \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \"));\n    assertEquals(1000L, TimeResolver.resolveExpression(\"1000 \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit));\n    assertEquals(1000L, TimeResolver.resolveExpression(\"1000 \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s\"));\n    assertEquals(1000L, TimeResolver.resolveExpression(\"1000 \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \"));\n    assertEquals(1000L, TimeResolver.resolveExpression(\"1000 \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit));\n    assertEquals(1000L, TimeResolver.resolveExpression(\"1000 \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s\"));\n    assertEquals(1000L, TimeResolver.resolveExpression(\"1000 \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \"));\n    assertEquals(1000L, TimeResolver.resolveExpression(\"1000 \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit));\n    assertEquals(1000L, TimeResolver.resolveExpression(\"1000 \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s\"));\n    assertEquals(1000L, TimeResolver.resolveExpression(\"1000 \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \" + defaultUnit + \"s \"));\n    assertEquals(1000L, TimeResolver.resolveExpression(\"1000 \" + defaultUnit + \"s \" + defaultUnit + \"s \" + default", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "44304666_0", "part": [1, 1], "seq": [1, 1], "prompt": "class ProvinceModel implements PickerItem {\n\n\tpublic List<String> getCityIdList() {\n\n\t\tint count = getCityCount();\n\t\tList<String> cityIdList = new ArrayList<String>();\n\n\t\tfor (int i = 0; i < count; i++) {\n\n\t\t\tcityIdList.add(mCityList.get(i).id);\n\t\t}\n\n\t\treturn cityIdList;\n\t}\n\n\tpublic void addCity(CityModel city);\n\tpublic CityModel getCity(int position);\n\tpublic ArrayList<CityModel> getCityList();\n\tpublic int getCityCount();\n\tpublic List<String> getCityNameList();\n\t@Override public String getText();\n\tpublic String toString();\n\n    private ProvinceModel model;\n    private CityModel[] cities;\n\n}\n\nclass ProvinceModelTest  {\n\n    private ProvinceModel model;\n    private CityModel[] cities;\n\n    @Test\n    public void testGetCityIdList() {\n", "reference": "        // when empty then\n        assertTrue(model.getCityIdList().isEmpty());\n\n        // when\n        model.addCity(new CityModel());\n        // then\n        assertEquals(1, model.getCityIdList().size());\n        assertNull(model.getCityIdList().get(0));\n\n        // when\n        for (CityModel city : cities) {\n            model.addCity(city);\n        }\n\n        // then\n        assertEquals(CITIES_NUM + 1, model.getCityIdList().size());\n        assertNull(model.getCityIdList().get(0));\n\n        for (int i=0; i<cities.length; i++) {\n            assertEquals(cities[i].id, model.getCityIdList().get(i+1));\n        }\n    }\n\n}", "prediction": "        List<String> cityIdList = model.getCityIdList();\n        assertEquals(cityIdList.size(), cities.length);\n        for (int i = 0; i < cities.length; i++) {\n            assertEquals(cityIdList.get(i), cities[i].id);\n        }\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "44322761_17", "part": [1, 1], "seq": [1, 1], "prompt": "class District implements AddressEntity, Comparable<District> {\n\n    public String getProvinceCode() {\n        return code.substring(0, 2);\n    }\n\n    public  District(String code, String name);\n\n    @Override public String getCode();\n    @Override public String getName();\n    @Override public int hashCode();\n    @Override public boolean equals(Object other);\n    @Override public String toString();\n    @Override public int compareTo(District that);\n\n    private District bangkok;\n\n}\n\nclass DistrictTest {\n\n    private District bangkok;\n\n    @Test\n    public void getProvinceCode() {\n", "reference": "        assertEquals(\"10\", bangkok.getProvinceCode());\n    }\n\n}", "prediction": "        assertEquals(\"10\", bangkok.getProvinceCode());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "44442208_5", "part": [1, 1], "seq": [1, 1], "prompt": "class VaultSecurityManager implements SecurityManager {\n\n    @Override\n    public Object authenticate(Properties properties) throws AuthenticationFailedException {\n        String username = properties.getProperty(\"security-username\");\n        Assert.hasText(username, \"Missing username\");\n        LOG.info(\"authenticate: username={}\", username);\n\n        String password = properties.getProperty(\"security-password\");\n        Assert.hasText(password, \"Missing password\");\n        LOG.trace(\"authenticate: username={}, password={}\", username, password);\n\n        VaultResponse vaultResponse = vaultTemplate.read(readPath + username);\n\n        if (vaultResponse == null) {\n            throw new AuthenticationFailedException(username);\n        }\n\n        String actualPassword = (String) vaultResponse.getData().get(\"password\");\n        LOG.trace(\"authenticate: username={}, password={}, actualPassword={}\", username, password, actualPassword);\n\n        if (!password.equals(actualPassword)) {\n            throw new AuthenticationFailedException(username);\n        }\n\n        return new UsernamePrincipal(username);\n    }\n\n    public  VaultSecurityManager();\n    public  VaultSecurityManager(VaultTemplate vaultTemplate, String readPath);\n\n    @Override public void init(Properties securityProps);\n    @Override public boolean authorize(Object principal, ResourcePermission permission);\n    @Override public void close();\n\n    private VaultSecurityManager vaultSecurityManager;\n    @Mock\n    private VaultTemplate vaultTemplate;\n\n}\n\nclass VaultSecurityManagerTest {\n\n    private VaultSecurityManager vaultSecurityManager;\n    @Mock\n    private VaultTemplate vaultTemplate;\n\n    @Test\n    void authenticate_success() {\n", "reference": "        String username = \"some-user\";\n        String password = \"some-password\";\n\n        VaultResponse vaultResponse = mock(VaultResponse.class);\n        Map<String, Object> data = new HashMap<>();\n        data.put(\"password\", password);\n        when(vaultResponse.getData()).thenReturn(data);\n        when(vaultTemplate.read(anyString())).thenReturn(vaultResponse);\n\n        Properties props = new Properties();\n        props.setProperty(\"security-username\",username);\n        props.setProperty(\"security-password\",password);\n        vaultSecurityManager.authenticate(props);\n    }\n\n}", "prediction": "        Properties properties = new Properties();\n        properties.setProperty(\"security-username\", \"test\");\n        properties.setProperty(\"security-password\", \"test\");\n\n        vaultSecurityManager.authenticate(properties);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "45098765_3", "part": [1, 1], "seq": [1, 1], "prompt": "class ByteArrayComparator implements Comparator<byte[]> {\n\n    @Override\n    public int compare(byte[] o1, byte[] o2) {\n\tfor (int i = 0; i < Math.min(o1.length, o2.length); i++) {\n\t    if (o1[i] != o2[i]) {\n\t\treturn (o1[i] & 0xFF) - (o2[i] & 0xFF);\n\t    }\n\t}\n\tif (o1.length == o2.length) {\n\t    return 0;\n\t} else if (o1.length < o2.length) {\n\t    return -1;\n\t} else {\n\t    return +1;\n\t}\n    }\n\n    private  ByteArrayComparator();\n\n    public static ByteArrayComparator getInstance();\n    public static int compareArrays(byte[] o1, byte[] o2);\n\n    private static final ByteArrayComparator comparator;\n\n}\n\nclass ByteArrayComparatorTest {\n\n    private static final ByteArrayComparator comparator;\n\n    @Test\n    public void testGreater() {\n", "reference": "\tassertEquals(1, comparator.compare(new byte[] { 1 }, new byte[] {}));\n\tassertEquals(1, comparator.compare(new byte[] { 1, 1 }, new byte[] { 1 }));\n\tassertEquals(1, comparator.compare(new byte[] { 1, 1, 1 }, new byte[] { 1, 1 }));\n\n\tassertEquals(1, comparator.compare(new byte[] { 2 }, new byte[] { 1 }));\n\tassertEquals(1, comparator.compare(new byte[] { 1, 2 }, new byte[] { 1, 1 }));\n\tassertEquals(1, comparator.compare(new byte[] { 1, 1, 2 }, new byte[] { 1, 1, 1 }));\n    }\n\n}", "prediction": "\tassertEquals(1, comparator.compare(new byte[] { 1, 2, 3 }, new byte[] { 1, 2, 2 }));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "45889273_4", "part": [1, 1], "seq": [1, 1], "prompt": "class IntegratorOutputNode extends VolatileXMLFilterImpl implements IdQueryable {\n\n    public StatefulXMLFilter addDescendent(String path, XMLReader source, boolean requireForWrite) {\n        String[] pe = path.substring(1).split(\"/\");\n        LinkedList<String> pathElements = new LinkedList<String>(Arrays.asList(pe));\n        return addDescendent(pathElements, source, requireForWrite);\n    }\n\n    public  IntegratorOutputNode();\n    public  IntegratorOutputNode(StatefulXMLFilter payload);\n\n    public static void main(String[] args);\n    @Override public void reset();\n    public void setDescendentsSpring(List<String> descendentsSpring);\n    public List<String> getDescendentsSpring();\n    public void setSubIntegratorsSpring(List<XMLReader> writeDuplicateIdsSpring);\n    public List<XMLReader> getSubIntegratorsSpring();\n    public void initSpring();\n    public StatefulXMLFilter addDescendent(LinkedList<String> pathElements, XMLReader source, boolean requireForWrite);\n    public void setAggregating(boolean aggregating);\n    public Boolean isAggregating();\n    @Override public void setName(String name);\n    @Override public String getName();\n    @Override public boolean getFeature(String name);\n    @Override public void setFeature(String name, boolean value);\n    @Override public Object getProperty(String name);\n    private void localSetProperty(String name, Object value, T exception);\n    private boolean localSetProperty(String name, Object value);\n    @Override public void setProperty(String name, Object value);\n    @Override public void setEntityResolver(EntityResolver resolver);\n    @Override public EntityResolver getEntityResolver();\n    @Override public void setDTDHandler(DTDHandler handler);\n    @Override public DTDHandler getDTDHandler();\n    @Override public ContentHandler getContentHandler();\n    @Override public void setErrorHandler(ErrorHandler handler);\n    @Override public ErrorHandler getErrorHandler();\n    @Override public void parse(InputSource input);\n    @Override public void parse(String systemId);\n    @Override public void setContentHandler(ContentHandler ch);\n    private void assignOutput(ContentHandler ch);\n    private boolean init();\n    private void setParentProperties(XMLReader parent);\n    public ExecutorService getExecutor();\n    public void setExecutor(ExecutorService executor);\n    public DataSourceFactory getDataSourceFactory();\n    public void setDataSourceFactory(DataSourceFactory dsf);\n    @Override public void run();\n    private void handleLocalException();\n    private static SAXParser getSP();\n    private static XMLReader getXR();\n    private static InputSourceXMLReader getResettableSR(InputSource source);\n    public static void main2(String[] args);\n    private static void one(Transformer t, IntegratorOutputNode root, String systemId);\n    private static void two(Transformer t, IntegratorOutputNode root);\n    private void run2();\n    private void run2(int requiredIndexesBitflags);\n    @Override public void step();\n    @Override public boolean isFinished();\n    @Override public void skipOutput();\n    @Override public void writeOutput(ContentHandler ch);\n    @Override public String buffersToString();\n    @Override public void writeEndElements(ContentHandler ch, int lowerLevel, boolean aggregate);\n    @Override public void writeStartElements(ContentHandler ch, int lowerLevel, boolean aggregate);\n    @Override public void writeRootElement(ContentHandler ch);\n    @Override public boolean self();\n    @Override public Comparable getId();\n    @Override public int getLevel();\n    private void blockForOutputFilterInitialization();\n    public void addChild(String childElementName, IdQueryable child, boolean requireForWrite);\n\n    private static final ClassLoader cl;\n\n}\n\nclass IntegratorOutputNodeTest {\n\n    private static final ClassLoader cl;\n\n    @Test\n    public void testIntegrate5() throws TransformerConfigurationException, TransformerException, ParserConfigurationException, SAXException, IOException {\n", "reference": "        String testId = \"testIntegrate5\";\n        System.out.println(\"running test: \"+testId);\n        IntegratorOutputNode root = new IntegratorOutputNode();\n        root.addDescendent(\"/record/marc\", new PreConfiguredXMLReader(new InputSource(cl.getResourceAsStream(\"input/marc.xml\"))), false);\n        root.addDescendent(\"/record/marcEmpty\", new PreConfiguredXMLReader(new InputSource(cl.getResourceAsStream(\"input/marcEmpty.xml\"))), true);\n        verify(root, testId.concat(\".xml\"), true);\n    }\n\n}", "prediction": "        String systemId = \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\";\n        String systemId2 = \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\";\n        String systemId3 = \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\";\n        String systemId4 = \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\";\n        String systemId5 = \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\";\n        String systemId6 = \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\";\n        String systemId7 = \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\";\n        String systemId8 = \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\";\n        String systemId9 = \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\";\n        String systemId10 = \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\";\n        String systemId11 = \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\";\n        String systemId12 = \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\";\n        String systemId13 = \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\";\n        String systemId14 = \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\";\n        String systemId15 = \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\";\n        String systemId16 = \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\";\n        String systemId17 = \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\";\n        String systemId18 = \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\";\n        String systemId19 = \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\";\n        String systemId20 = \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\";\n        String systemId21 = \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\";\n        String systemId22 = \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\";\n        String systemId23 = \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\";\n        String systemId24 = \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\";\n        String systemId25 = \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\";\n        String systemId26 = \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\";\n        String systemId27 = \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\";\n        String systemId28 = \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\";\n        String systemId29 = \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\";\n        String systemId30 = \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\";\n        String systemId31 = \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\";\n        String systemId32 = \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\";\n       ", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "45926632_2", "part": [1, 1], "seq": [1, 1], "prompt": "class CollectorFactory {\n\n  public CollectorType getType() {\n    return type;\n  }\n\n  public  CollectorFactory(\n      CollectorType type,\n      TimeUtils time,\n      KafkaServer server,\n      Properties serverConfiguration,\n      Runtime serverRuntime\n  );\n\n  public Collector getCollector();\n\n}\n\nclass CollectorFactoryTest {\n\n    @Test\n    public void testBasicType() {\n", "reference": "        // Given\n        TimeUtils time = new TimeUtils();\n        CollectorFactory factory = new CollectorFactory(CollectorType.BASIC, time, null, null, null);\n\n        // when\n        CollectorType type = factory.getType();\n\n        // Then\n        assertThat(type).isEqualTo(CollectorType.BASIC);\n    }\n\n}", "prediction": "        CollectorFactory factory = new CollectorFactory(CollectorType.BASIC, null, null, null, null);\n        assertEquals(CollectorType.BASIC, factory.getType());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "45991588_0", "part": [1, 1], "seq": [1, 1], "prompt": "class NumberProvider {\n\n  public int provideNumber() {\n    return 42;\n  }\n\n}\n\nclass NumberProviderTest {\n\n  @Test public void shouldProvideProperNumber() {\n", "reference": "    // given\n    NumberProvider numberProvider = new NumberProvider();\n\n    // when\n    int number = numberProvider.provideNumber();\n\n    // then\n    assertThat(number).isEqualTo(42);\n  }\n\n}", "prediction": "    assertEquals(42, new NumberProvider().provideNumber());\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "46855694_3", "part": [1, 1], "seq": [1, 1], "prompt": "class CalculPrice {\n\n    public static final double getGenericPrice(double price, double discount, double taxe, int binaryMask) {\n        if (hasOption(binaryMask, Type.DISCOUNT_COST)) {\n            return getDiscountCost(price, discount);\n        }\n        if (hasOption(binaryMask, Type.TAXE_COST)) {\n            return getTaxCost(price, taxe);\n        }\n        if (hasOption(binaryMask, Type.DISCOUNT)) {\n            price = applyDiscount(price, discount);\n        }\n        if (hasOption(binaryMask, Type.TAXE)) {\n            price = applyTax(price, taxe);\n        }\n        return price;\n    }\n\n    private static boolean hasOption(int binaryMask, int model);\n    public static final double removeTaxe(double price, double tax);\n    public static final double getDiscountCost(double price, double discount);\n    public static final double applyDiscount(double price, double discount);\n    public static final double mergeDiscount(double productDiscount, double ticketDiscount);\n    public static double applyTax(double price, double taxRate);\n    public static double getTaxCost(double price, double taxRate);\n    public static double round(double number);\n    public static double round(double number, int decimalNumber);\n\n    private static final double delta;\n    private final double price;\n    private final double taxe;\n    private final double discount;\n\n}\n\nclass CalculPriceTest {\n\n    private static final double delta;\n    private final double price;\n    private final double taxe;\n    private final double discount;\n\n    @Test\n    public void getPriceWithDiscountWithoutTaxeTest() {\n", "reference": "        double discount = 0.2d;\n        final double control = 40d;\n        assertEquals(control, getGenericPrice(price, discount, taxe, Type.DISCOUNT));\n    }\n\n}", "prediction": "        double price = 100;\n        double discount = 0.1;\n        double taxe = 0;\n        double expected = 90;\n        double actual = CalculPrice.getGenericPrice(price, discount, taxe, Type.DISCOUNT_COST);\n        assertEquals(expected, actual, delta);\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "47017637_1", "part": [1, 1], "seq": [1, 1], "prompt": "class RegistrationService {\n\n\tpublic boolean register(User user) throws IllegalArgumentException {\n\t\tString email = user.getEmail();\n\t\tif (getByEMail(email) != null) {\n\t\t\tlog.info(String.format(\"User with email=%s already registered\",\n\t\t\t\t\temail));\n\t\t\treturn false;\n\t\t}\n\t\tif (!validEMailAdress(email)) {\n\t\t\tlog.info(String.format(\"email=%s invalid\", email));\n\t\t\tthrow new IllegalArgumentException(\"Invalid EMail Adress!\");\n\t\t}\n\t\tjdbcTemplate.update(\n\t\t\t\t\"INSERT INTO T_USER(firstname, name, email) VALUES (?, ?, ?)\",\n\t\t\t\tuser.getFirstname(), user.getName(), email);\n\t\tlog.info(String.format(\"Registered firstname=%s name=%s email=%s\",\n\t\t\t\tuser.getFirstname(), user.getName(), email));\n\t\treturn true;\n\t}\n\n\tpublic boolean validEMailAdress(String email);\n\tpublic User getByEMail(String email);\n\tpublic void reset();\n\tpublic void unregister(String email);\n\tpublic void clean();\n\n\t@Autowired\n\tprivate RegistrationService registrationService;\n\n}\n\nclass RegistrationServiceTest {\n\n\t@Autowired\n\tprivate RegistrationService registrationService;\n\n\t@Test(expected=IllegalArgumentException.class)\n\tpublic void avoidInvalidEMail() {\n", "reference": "\t\tUser user = new User(\"Eberhard\",\"Wolff\",\"HURZ!\");\n\t\tregistrationService.register(user);\n\t}\n\n}", "prediction": "\t\tregistrationService.register(new User(\"John\", \"Doe\", \"john.doe@invalid\"));\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "47182929_1", "part": [1, 1], "seq": [1, 1], "prompt": "class CalendarService {\n\n\tpublic Date getNextLaboralDay(final Date date, final int days, final HolidayCalendar calendar) {\n\t\tDateTime tmp = new DateTime(date);\n\t\t// Note: in the case of previous dates we want to have an offset\n\t\tint check = days < 0 ? Math.abs(days) - 1 : days;\n\t\tint count = 0;\n\t\tint increment = days < 0 ? -1 : 1;\n\t\tdo {\n\t\t\tif (!isLaboralDay(tmp.toDate(), calendar)) {\n\t\t\t\ttmp = tmp.plusDays(increment);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmp = tmp.plusDays(increment);\n\t\t\tcount++;\n\t\t}\n\t\twhile (count < check);\n\t\treturn tmp.toDate();\n\t}\n\n\tpublic boolean isLaboralDay(Date date, HolidayCalendar calendar);\n\n}\n\nclass CalendarServiceTest {\n\n\t@Test\n\tpublic void test02() {\n", "reference": "\t\tCalendarService service = new CalendarService();\n\t\tDateTime dt = new DateTime(2017, 10, 1, 0, 0, 0);\n\t\tDate result = service.getNextLaboralDay(dt.toDate(), 0, null);\n\t\tDateTime dtResult = new DateTime(result);\n\n\t\tAssert.assertEquals(2017, dtResult.getYear());\n\t\tAssert.assertEquals(10, dtResult.getMonthOfYear());\n\t\tAssert.assertEquals(2, dtResult.getDayOfMonth());\n\t}\n\n}", "prediction": "\t\tCalendarService service = new CalendarService();\n\t\tDate date = new Date();\n\t\tDate next = service.getNextLaboralDay(date, 1, new HolidayCalendar());\n\t\tassertTrue(next.after(date));\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "47529369_6", "part": [1, 1], "seq": [1, 1], "prompt": "class OtpKeyRequestProcessor extends AbstractGameBootProcessor<OtpKeyRequest> {\n\n  private Response newKey(OtpKeyRequest message) throws Exception {\n    Integer size = message.getKeySize() == null ? defaultKeySize : message.getKeySize();\n    SystemIdKey systemId = new SystemIdKey(message.getOtpSystemId());\n\n    log.debug(\"Creating new OTP key of size {} for {}\", size, systemId);\n\n    byte[] newKey = pad.generateKey(size);\n\n    newKeyRegistry.put(systemId, newKey);\n\n    return new Response(message, ResponseCode.SUCCESS, newKey);\n  }\n\n  @Override public String getType();\n  @Override protected void validate(OtpKeyRequest message);\n  @Override protected Response processImpl(OtpKeyRequest message);\n  private Response deleteKey(OtpMessage message);\n\n  static final Long CLEAR_CHANNEL_ID;\n  static final Integer KEY_SIZE;\n  @Autowired\n  private OtpKeyRequestProcessor processor;\n  @Value(\"${otp.maximum.key.size}\")\n  private Integer maxKeySize;\n\n}\n\nclass OtpKeyRequestProcessorTest {\n\n  static final Long CLEAR_CHANNEL_ID;\n  static final Integer KEY_SIZE;\n  @Autowired\n  private OtpKeyRequestProcessor processor;\n  @Value(\"${otp.maximum.key.size}\")\n  private Integer maxKeySize;\n\n  @Test\n  public void testNewKey() throws Exception {\n", "reference": "    failExpected(null, \"Null message\");\n\n    OtpKeyRequest r = new OtpKeyRequest();\n    failExpected(r, \"mt message\");\n\n    r.setOtpSystemId(CLEAR_CHANNEL_ID);\n    r.setKeyFunction(KeyFunction.NEW);\n\n    r.setKeySize(-32);\n    failExpected(r, \"negative size\");\n\n    r.setKeySize(KEY_SIZE);\n    r.setKeyFunction(null);\n    failExpected(r, \"No key function\");\n\n    r.setKeyFunction(KeyFunction.NEW);\n    r.setKeySize(maxKeySize + 1);\n    failExpected(r, \"> max key size\");\n\n    r.setKeySize(KEY_SIZE);\n\n    Response rep = processor.process(r);\n\n    assertEquals(ResponseCode.SUCCESS, rep.getResponseCode());\n    assertNotNull(rep.getPayload());\n    assertEquals(1, rep.getPayload().length);\n    assertTrue(rep.getPayload()[0] instanceof byte[]);\n\n    byte[] b = (byte[]) rep.getPayload()[0];\n\n    assertEquals(KEY_SIZE.intValue(), b.length);\n  }\n\n}", "prediction": "    OtpKeyRequest message = new OtpKeyRequest(CLEAR_CHANNEL_ID, KEY_SIZE);\n    Response response = processor.process(message);\n    assertEquals(ResponseCode.SUCCESS, response.getResponseCode());\n    assertEquals(KEY_SIZE, response.getData().length);\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "47972099_112", "part": [1, 1], "seq": [1, 1], "prompt": "class TypeInfoParser {\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static <X> TypeInformation<X> parse(String infoString) {\n\t\ttry {\n\t\t\tif (infoString == null) {\n\t\t\t\tthrow new IllegalArgumentException(\"String is null.\");\n\t\t\t}\n\t\t\tString clearedString = infoString.replaceAll(\"\\\\s\", \"\");\n\t\t\tif (clearedString.length() == 0) {\n\t\t\t\tthrow new IllegalArgumentException(\"String must not be empty.\");\n\t\t\t}\n\t\t\tStringBuilder sb = new StringBuilder(clearedString);\n\t\t\tTypeInformation<X> ti = (TypeInformation<X>) parse(sb);\n\t\t\tif (sb.length() > 0) {\n\t\t\t\tthrow new IllegalArgumentException(\"String could not be parsed completely.\");\n\t\t\t}\n\t\t\treturn ti;\n\t\t} catch (Exception e) {\n\t\t\tthrow new IllegalArgumentException(\"String could not be parsed: \" + e.getMessage(), e);\n\t\t}\n\t}\n\n\t@SuppressWarnings({ \"rawtypes\", \"unchecked\" }) private static TypeInformation<?> parse(StringBuilder sb);\n\tprivate static Class<?> loadClass(String fullyQualifiedName);\n\n}\n\nclass TypeInfoParserTest {\n\n\t@Test\n\tpublic void testLargeMixedTuple() {\n", "reference": "\t\tTypeInformation<?> ti = TypeInfoParser.parse(\"org.apache.flink.api.java.tuple.Tuple4<Double,java.lang.Class[],StringValue,Tuple1<int>>[]\");\n\t\tAssert.assertEquals(\"ObjectArrayTypeInfo<Java Tuple4<Double, ObjectArrayTypeInfo<GenericType<java.lang.Class>>, ValueType<StringValue>, Java Tuple1<Integer>>>\", ti.toString());\n\t}\n\n}", "prediction": "\t\tTypeInformation<?> ti = TypeInfoParser.parse(\"Tuple15<String, Integer, Long, Double, Float, Boolean, Short, Byte, Character, Tuple2<String, Integer>, Tuple3<String, Integer, Long>, Tuple4<String, Integer, Long, Double>, Tuple5<String, Integer, Long, Double, Float>, Tuple6<String, Integer, Long, Double, Float, Short>, Tuple7<String, Integer, Long, Double, Float, Short, Byte>>\");\n\t\tassertTrue(ti instanceof TupleTypeInfo);\n\t\tTupleTypeInfo<?> tti = (TupleTypeInfo<?>) ti;\n\t\tassertEquals(15, tti.getArity());\n\t\tassertEquals(String.class, tti.getTypeAt(0));\n\t\tassertEquals(Integer.class, tti.getTypeAt(1));\n\t\tassertEquals(Long.class, tti.getTypeAt(2));\n\t\tassertEquals(Double.class, tti.getTypeAt(3));\n\t\tassertEquals(Float.class, tti.getTypeAt(4));\n\t\tassertEquals(Boolean.class, tti.getTypeAt(5));\n\t\tassertEquals(Short.class, tti.getTypeAt(6));\n\t\tassertEquals(Byte.class, tti.getTypeAt(7));\n\t\tassertEquals(Character.class, tti.getTypeAt(8));\n\t\tassertEquals(Tuple2.class, tti.getTypeAt(9).getTypeClass());\n\t\tassertEquals(Tuple3.class, tti.getTypeAt(10).getTypeClass());\n\t\tassertEquals(Tuple4.class, tti.getTypeAt(11).getTypeClass());\n\t\tassertEquals(Tuple5.class, tti.getTypeAt(12).getTypeClass());\n\t\tassertEquals(Tuple6.class, tti.getTypeAt(13).getTypeClass());\n\t\tassertEquals(Tuple7.class, tti.getTypeAt(14).getTypeClass());\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "48053234_46", "part": [1, 1], "seq": [1, 1], "prompt": "class EventListFeed extends FlattenableFeed<List<Event>> {\n\n    @Override\n    public List<Event> flatten() {\n        if(events == null) {\n            return new ArrayList<>();\n        }\n        for(Event event : events) {\n            event.setUser(users.get(event.getUserId()));\n            event.setPost(posts.get(event.getPostId()));\n        }\n        return events;\n    }\n\n    @Override FlattenableFeed<List<Event>> constructDefaultFeed();\n    @Override FlattenableFeed<List<Event>> parseJson(JsonObject jsonObject);\n\n}\n\nclass EventListFeedTest {\n\n    @Test\n    public void nullFeedReturnsEmptyList() {\n", "reference": "        List<Event> events = new EventListFeed().flatten();\n\n        assertThat(events, notNullValue());\n    }\n\n}", "prediction": "        EventListFeed feed = new EventListFeed();\n        assertEquals(new ArrayList<>(), feed.flatten());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "48122737_0", "part": [1, 1], "seq": [1, 1], "prompt": "class Context implements IContext<TEntity> {\n\n    public void OnEntityCreated(ContextEntityChanged listener) {\n        if (OnEntityCreated != null) {\n            OnEntityCreated = EntitasCollections.createSet(ContextEntityChanged.class);\n        }\n        OnEntityCreated.add(listener);\n    }\n\n    public  Context(int totalComponents, int startCreationIndex, ContextInfo contexInfo,\n                   EntityBaseFactory<TEntity> factoryMethod, Function<TEntity, IAERC> aercFactory);\n\n     ContextInfo createDefaultContextInfo();\n    @Override public TEntity createEntity();\n    @Override public void destroyAllEntities();\n    @Override public boolean hasEntity(TEntity entity);\n    @Override public TEntity[] getEntities();\n    @Override public int getTotalComponents();\n    @Override public Group<TEntity> getGroup(IMatcher matcher);\n    @Override public void addEntityIndex(IEntityIndex entityIndex);\n    @Override public IEntityIndex getEntityIndex(String name);\n    @Override public void resetCreationIndex();\n    @Override public void clearComponentPool(int index);\n    @Override public void clearComponentPools();\n    @Override public void reset();\n    public void updateGroupsComponentAddedOrRemoved(TEntity entity, int index, IComponent component, List<Group<TEntity>>[] groupsForIndex);\n    protected void updateGroupsComponentReplaced(TEntity entity, int index, IComponent previousComponent,\n                                                 IComponent newComponent, List<Group<TEntity>>[] groupsForIndex);\n    protected void onEntityReleased(TEntity entity);\n     void onDestroyEntity(TEntity entity);\n    @Override public Stack<IComponent>[] getComponentPools();\n    @Override public ContextInfo getContextInfo();\n    @Override public int getCount();\n    @Override public int getReusableEntitiesCount();\n    @Override public int getRetainedEntitiesCount();\n    public IEntity[] getEntities(IMatcher matcher);\n    @Override public Collector createCollector(IMatcher matcher);\n    @Override public Collector createCollector(IMatcher matcher, GroupEvent groupEvent);\n    public Collector<TEntity> createCollector(Context context, TriggerOnEvent<TEntity>[] triggers);\n    public void clearEventsListener();\n    public void OnEntityWillBeDestroyed(ContextEntityChanged listener);\n    public void OnEntityDestroyed(ContextEntityChanged listener);\n    public void OnGroupCreated(ContextGroupChanged listener);\n    public void notifyEntityCreated(IEntity entity);\n    public void notifyEntityWillBeDestroyed(IEntity entity);\n    public void notifyEntityDestroyed(IEntity entity);\n    public void notifyGroupCreated(IGroup group);\n    @Override public String toString();\n\n    @Rule\n    public ExpectedException exception;\n    private TestContext context;\n    private TestEntity entity;\n\n}\n\nclass ContextTest {\n\n    @Rule\n    public ExpectedException exception;\n    private TestContext context;\n    private TestEntity entity;\n\n    @Test\n    public void OnEntityCreatedTest() {\n", "reference": "        context.OnEntityCreated((context, e) -> assertTrue(e.isEnabled()));\n        entity = context.createEntity();\n    }\n\n}", "prediction": "        exception.expect(UnsupportedOperationException.class);\n        context.OnEntityCreated(new ContextEntityChanged() {\n            @Override\n            public void OnEntityCreated(IEntity entity) {\n            }\n        });\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "48161197_0", "part": [1, 1], "seq": [1, 1], "prompt": "class QuarkCube {\n\n  public static Set<Set<Dimension>> getDimensionSets(Set<Dimension> dimensions) {\n    Set<Set<Dimension>> result = Sets.newHashSet();\n    result.add(new HashSet<>());\n    for (Dimension d : dimensions) {\n      // traverse only the top level dimension i.e., with no parents\n      if (d.parentDimension == null) {\n        result = cartesian(ImmutableList.of(result,\n            getHierarichalSet(d, new AtomicBoolean(false))));\n      }\n    }\n    return result;\n  }\n\n  public  QuarkCube(String name, Object sql, List<Measure> measures,\n                   List<Dimension> dimensionList,\n                   List<String> tableName, String groupingColumn);\n  public  QuarkCube(String name, Object sql, List<Measure> measures,\n                   List<Dimension> dimensionList,\n                   List<Group> groupList,\n                   List<String> tableName, String groupingColumn);\n  public  QuarkCube(String name, Object sql, List<Measure> measures,\n                   List<Dimension> dimensionList,\n                   List<Group> groupList,\n                   List<String> tableName, String groupingColumn,\n                   List<String> alias);\n\n  private void buildGroups(List<Dimension> dimensions,\n                           List<Group> groupList,\n                           Map<String, Set<Dimension>> groupToDimensionMap,\n                           Map<String, Dimension> idToDimensionMap);\n  private void addDimension(Map<String, Set<QuarkCube.Dimension>> groupToDimensionMap,\n                            List<Group> groupList,\n                            Map<String, QuarkCube.Dimension> idToDimensionMap,\n                            Dimension dimension);\n  public Lattice build(CalciteSchema calciteSchema, QuarkTable quarkTable);\n  private void validateCubeLatticeFilter(Lattice.Builder latticeBuilder);\n  private static Set<Set<Dimension>> getHierarichalSet(Dimension d,\n      AtomicBoolean isChildMandatory);\n  private ImmutableList<String> toUpperCase(List<String> stringList);\n  static String toString(Object o);\n  private static String concatenate(List list);\n  public static Set<Set<E>> cartesian(List<Set<T>> list);\n\n  public Fixture fixture;\n\n}\n\nclass QuarkCubeTest {\n\n  public Fixture fixture;\n\n  @Test\n  public void computeDimensionSet() {\n", "reference": "    Set<Set<QuarkCube.Dimension>> dimSet = QuarkCube.getDimensionSets(\n        fixture.getAllDim());\n    assertEquals(dimSet.size(), 8);\n  }\n\n}", "prediction": "    Set<Dimension> dimensions = new HashSet<>();\n    Dimension d1 = new Dimension(\"d1\", \"d1\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null,", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "48337544_10", "part": [1, 1], "seq": [1, 1], "prompt": "class DescribableModel implements Serializable {\n\n    @SuppressWarnings(\"unchecked\")\n    public static UninstantiatedDescribable uninstantiate2_(Object o) {\n        return new DescribableModel(o.getClass()).uninstantiate2(o);\n    }\n\n    public  DescribableModel(Class<T> clazz);\n\n    public static DescribableModel<T> of(Class<T> clazz);\n    private void addParameter(Map<String,DescribableParameter> props, Type type, String name, Setter setter);\n    public Class<T> getType();\n    public Collection<DescribableParameter> getParameters();\n    public DescribableParameter getParameter(String name);\n    public boolean hasSingleRequiredParameter();\n    public @CheckForNull DescribableParameter getSoleRequiredParameter();\n    public @CheckForNull DescribableParameter getFirstRequiredParameter();\n    public String getDisplayName();\n    @Deprecated public T instantiate(Map<String,?> arguments);\n    public T instantiate(Map<String,?> arguments, @CheckForNull TaskListener listener);\n    @SuppressWarnings(\"unchecked\") private static Map<String, Object> deeplyImmutable(Map<String, ?> m);\n    private static UninstantiatedDescribable deeplyImmutable(UninstantiatedDescribable ud);\n    @SuppressWarnings(\"unchecked\") private Constructor<T> findConstructor(int length);\n    private Object[] buildArguments(Map<String,?> bag, Type[] types, String[] names, boolean callEvenIfNoArgs, TaskListener listener);\n    private void injectSetters(Object o, Map<String,?> arguments, TaskListener listener);\n    @SuppressWarnings(\"unchecked\") private Object coerce(String context, Type type, Object o, TaskListener listener);\n    private Object coerceStringToNumber(@Nonnull String context, @Nonnull Class numberClass, @Nonnull String o);\n    static Class<?> resolveClass(Class<?> base, @Nullable String name, @Nullable String symbol);\n    private List<Object> coerceList(String context, Type type, List<?> list, TaskListener listener);\n    private static @CheckForNull Class<?> parameterValueClass(@Nonnull Class<?> parameterDefinitionClass);\n    static Set<Class<?>> findSubtypes(Class<?> supertype);\n    public Map<String,Object> uninstantiate(T o);\n    public UninstantiatedDescribable uninstantiate2(T o);\n    static String symbolOf(Object o);\n    public static Map<String,Object> uninstantiate_(Object o);\n    private static Map<String,Object> uninstantiate__(Object o, Class<T> clazz);\n    public boolean isDeprecated();\n    public @CheckForNull String getHelp();\n    @CheckForNull String getHelp(String name);\n     void toString(StringBuilder b, Stack<Class<?>> modelTypes);\n    @Override public String toString();\n    private Object writeReplace();\n    private static Object getVmDefaultValueForPrimitiveType(Class<?> type);\n\n    @ClassRule\n    public static JenkinsRule rule;\n    @ClassRule\n    public static LoggerRule logging;\n\n}\n\nclass DescribableModelTest {\n\n    @ClassRule\n    public static JenkinsRule rule;\n    @ClassRule\n    public static LoggerRule logging;\n\n    @Issue(\"JENKINS-43337\")\n    @Test\n    public void ambiguousSimpleName() throws Exception {\n", "reference": "        AmbiguousContainer container = new AmbiguousContainer(new FirstAmbiguous.CommonName(\"first\"),\n                new UnambiguousClassName(\"second\"));\n\n        UninstantiatedDescribable ud = DescribableModel.uninstantiate2_(container);\n\n        Object o = ud.toMap().get(\"ambiguous\");\n        assertTrue(o instanceof Map);\n        Map<String,Object> m = (Map<String,Object>)o;\n\n        // Make sure the ambiguous class is fully qualified.\n        assertEquals(FirstAmbiguous.CommonName.class.getName(), m.get(\"$class\"));\n\n        Object o2 = ud.toMap().get(\"unambiguous\");\n        assertTrue(o2 instanceof Map);\n        Map<String,Object> m2 = (Map<String,Object>)o2;\n\n        // Make sure the unambiguous class just uses the simple name.\n        assertEquals(UnambiguousClassName.class.getSimpleName(), m2.get(\"$class\"));\n    }\n\n}", "prediction": "        assertThat(DescribableModel.of(AmbiguousSimpleName.class).getType().getSimpleName(), is(\"AmbiguousSimpleName\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "48337670_296", "part": [1, 1], "seq": [1, 1], "prompt": "class UnitUtils {\n\n    public static @Nullable Unit<?> parseUnit(@Nullable String pattern) {\n        if (pattern == null || pattern.isBlank()) {\n            return null;\n        }\n\n        String unitSymbol = pattern;\n        int lastBlankIndex = pattern.lastIndexOf(\" \");\n        if (lastBlankIndex >= 0) {\n            unitSymbol = pattern.substring(lastBlankIndex).trim();\n        }\n\n        if (!UNIT_PLACEHOLDER.equals(unitSymbol)) {\n            if (UNIT_PERCENT_FORMAT_STRING.equals(unitSymbol)) {\n                return SmartHomeUnits.PERCENT;\n            }\n            try {\n                Quantity<?> quantity = Quantities.getQuantity(\"1 \" + unitSymbol);\n                return quantity.getUnit();\n            } catch (IllegalArgumentException e) {\n                // we expect this exception in case the extracted string does not match any known unit\n                LOGGER.debug(\"Unknown unit from pattern: {}\", unitSymbol);\n            }\n        }\n\n        return null;\n    }\n\n    public static @Nullable Class<? extends Quantity<?>> parseDimension(String dimension);\n    public static @Nullable String getDimensionName(Unit<?> unit);\n    public static boolean isDifferentMeasurementSystem(Unit<? extends Quantity<?>> thisUnit, Unit<?> thatUnit);\n    private static boolean isMetricConversion(UnitConverter converter);\n    @SuppressWarnings(\"unchecked\") private static Class<? extends Quantity<?>> dimensionClass(String prefix, String name);\n\n}\n\nclass UnitUtilsTest {\n\n    @Test\n    public void testParsePureUnit() {\n", "reference": "        assertThat(UnitUtils.parseUnit(\"DU\"), is(SmartHomeUnits.DOBSON_UNIT));\n        assertThat(UnitUtils.parseUnit(\"\u00b0F\"), is(ImperialUnits.FAHRENHEIT));\n        assertThat(UnitUtils.parseUnit(\"m\"), is(SIUnits.METRE));\n        assertThat(UnitUtils.parseUnit(\"%\"), is(SmartHomeUnits.PERCENT));\n    }\n\n}", "prediction": "        assertEquals(SmartHomeUnits.CELSIUS, UnitUtils.parseUnit(\"\u00b0C\"));\n        assertEquals(SmartHomeUnits.PERCENT, UnitUtils.parseUnit(\"%\"));\n        assertEquals(SmartHomeUnits.PERCENT, UnitUtils.parseUnit(\"100%\"));\n        assertEquals(SmartHomeUnits.PERCENT, UnitUtils.parseUnit(\"100% \"));\n        assertEquals(SmartHomeUnits.PERCENT, UnitUtils.parseUnit(\"100% \" + UNIT_PLACEHOLDER));\n        assertEquals(SmartHomeUnits.PERCENT, UnitUtils.parseUnit(\"100% \" + UNIT_PLACEHOLDER + \" \"));\n        assertEquals(SmartHomeUnits.PERCENT, UnitUtils.parseUnit(\"100% \" + UNIT_PLACEHOLDER + \" \" + UNIT_PLACEHOLDER));\n        assertEquals(SmartHomeUnits.PERCENT, UnitUtils.parseUnit(\"100% \" + UNIT_PLACEHOLDER + \" \" + UNIT_PLACEHOLDER + \" \"));\n        assertEquals(SmartHomeUnits.PERCENT, UnitUtils.parseUnit(\"100% \" + UNIT_PLACEHOLDER + \" \" + UNIT_PLACEHOLDER + \" \" + UNIT_PLACEHOLDER));\n        assertEquals(SmartHomeUnits.PERCENT, UnitUtils.parseUnit(\"100% \" + UNIT_PLACEHOLDER + \" \" + UNIT_PLACEHOLDER + \" \" + UNIT_PLACEHOLDER + \" \"));\n        assertEquals(SmartHomeUnits.PERCENT, UnitUtils.parseUnit(\"100% \" + UNIT_PLACEHOLDER + \" \" + UNIT_PLACEHOLDER + \" \" + UNIT_PLACEHOLDER + \" \" + UNIT_PLACEHOLDER));\n        assertEquals(SmartHomeUnits.PERCENT, UnitUtils.parseUnit(\"100% \" + UNIT_PLACEHOLDER + \" \" + UNIT_PLACEHOLDER + \" \" + UNIT_PLACEHOLDER + \" \" + UNIT_PLACEHOLDER + \" \"));\n        assertEquals(SmartHomeUnits.PERCENT, UnitUtils.parseUnit(\"100% \" + UNIT_PLACEHOLDER + \" \" + UNIT_PLACEHOLDER + \" \" + UNIT_PLACEHOLDER + \" \" + UNIT_PLACEHOLDER + \" \" + UNIT_PLACEHOLDER));\n        assertEquals(SmartHomeUnits.PERCENT, UnitUtils.parseUnit(\"100% \" + UNIT_PLACEHOLDER + \" \" + UNIT_PLACEHOLDER + \" \" + UNIT_PLACEHOLDER + \" \" + UNIT_PLACEHOLDER + \" \" + UNIT_PLACEHOLDER + \" \"));\n        assertEquals(SmartHomeUnits.PERCENT, UnitUtils.parseUnit(\"100% \" + UNIT_PLACEHOLDER + \" \" + UNIT_PLACEHOLDER + \" \" + UNIT_PLACEHOLDER + \" \" + UNIT_PLACEHOLDER + \" \" + UNIT_PLACEHOLDER + \" \" + UNIT_PLACEHOLDER));\n        assertEquals(SmartHomeUnits.PERCENT, UnitUtils.parseUnit(\"100% \" + UNIT_PLACEHOLDER + \" \" + UNIT_PLACEHOLDER + \" \" + UNIT_PLACEHOLDER + \" \" + UNIT_PLACEHOLDER + \" \" + UNIT_PLACEHOLDER + \" \" + UNIT_PLACEHOLDER + \" \"));\n        assertEquals(SmartHomeUnits.PERCENT, UnitUtils.parseUnit(\"100% \" + UNIT_PLACEHOLDER + \" \" + UNIT_PLACEHOLDER + \" \" + UNIT_PLACEHOLDER + \" \" + UNIT_PLACEHOLDER + \" \" + UNIT_PLACEHOLDER + \" \" + UNIT_PLACEHOLDER + \" \" + UNIT_PLACEHOLDER));\n        assertEquals(SmartHomeUnits.PERCENT, UnitUtils.parseUnit(\"100% \" + UNIT_PLACEHOLDER + \" \" + UNIT_PLACEHOLDER + \" \" + UNIT_PLACEHOLDER + \" \" + UNIT_PLACEHOLDER + \" \" + UNIT_PLACEHOLDER + \" \" + UNIT_PLACEHOLDER + \" \" + UNIT_PLACEHOLDER + \" \"));\n        assertEquals(SmartHomeUnits.PERCENT, UnitUtils.parseUnit(\"100% \" + UNIT_PLACEHOLDER + \" \" + UNIT_PLACEHOLDER + \" \" + UNIT_PLACEHOLDER + \" \" + UNIT_PLACEHOLDER + \" \" + UNIT_PLACE", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "48366700_12", "part": [1, 1], "seq": [1, 1], "prompt": "class AndroidMocks {\n\n    public static TextView mockTextView() {\n        return mock(TextView.class);\n    }\n\n    public static Context mockContext();\n    public static MenuItem mockMenuItem();\n    public static MenuItem mockMenuItem(int itemId);\n    public static LayoutInflater mockLayoutInflater();\n    public static Intent mockIntent();\n    public static Bundle mockBundle();\n    public static View mockView(ViewPropertyAnimator animator);\n    public static View mockView();\n    public static View mockView(Resources resources);\n    @SuppressLint(\"NewApi\") public static ViewPropertyAnimator mockViewPropertyAnimator();\n    public static TextView mockTextView(Resources resources);\n    public static Button mockButton();\n    public static ImageButton mockImageButton();\n    public static Fragment mockFragment();\n    public static Activity mockActivity(Application application);\n    public static Activity mockActivity();\n    public static Application mockApplication();\n    public static FragmentManager mockFragmentManager();\n    @TargetApi(Build.VERSION_CODES.HONEYCOMB) @SuppressLint({ \"CommitTransaction\", \"NewApi\" }) public static FragmentManager mockFragmentManager(FragmentTransaction transaction);\n    public static Editable mockEditable(String s);\n    public static EditText mockEditText(Editable editable);\n    @Deprecated public static EditText mockEditField(Editable editable);\n    public static EditText mockEditText(String s);\n    @Deprecated public static EditText mockEditField(String s);\n    public static Resources mockResources();\n    public static EditText prepare(String s, EditText field);\n    public static TextView mockTextView(String s);\n    public static AutoCompleteTextView mockAutoCompleteEditField(String s);\n    public static SharedPreferences.Editor mockEditor();\n    public static AlertDialog.Builder mockDialogBuilder();\n    public static AlertDialog.Builder mockDialogBuilder(ArgumentCaptor<DialogInterface.OnClickListener> positive, ArgumentCaptor<DialogInterface.OnClickListener> negative);\n    public static CheckBox mockCheckBox();\n    public static WebView mockWebView();\n    public static ProgressBar mockProgressBar();\n    public static LinearLayout mockLinearLayout();\n    public static RelativeLayout mockRelativeLayout();\n    public static FrameLayout mockFrameLayout();\n    public static RecyclerView mockRecyclerView();\n    public static CardView mockCardView();\n\n}\n\nclass AndroidMocksTest {\n\n    @Test\n    public void mockTextView() {\n", "reference": "        TextView textView = AndroidMocks.mockTextView();\n        assertThat(textView).isNotNull();\n    }\n\n}", "prediction": "        TextView textView = AndroidMocks.mockTextView();\n        assertNotNull(textView);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "48544726_7", "part": [1, 1], "seq": [1, 1], "prompt": "class RepoInfoPresenter extends BasePresenter {\n\n    public void onCreateView(Bundle savedInstanceState) {\n\n        if (savedInstanceState != null) {\n            contributorList = (List<Contributor>) savedInstanceState.getSerializable(BUNDLE_CONTRIBUTORS_KEY);\n            branchList = (List<Branch>) savedInstanceState.getSerializable(BUNDLE_BRANCHES_KEY);\n        }\n\n        if (contributorList == null || branchList == null) {\n            loadData();\n        } else {\n            view.showBranches(branchList);\n            view.showContributors(contributorList);\n        }\n\n    }\n\n    private void loadData();\n    public void onCreate(RepoInfoView view, Repository repository);\n    protected void hideInfoLoadingState();\n    public void onSaveInstanceState(Bundle outState);\n    @Override protected View getView();\n\n    @Inject\n    protected List<ContributorDTO> contributorDTOs;\n    @Inject\n    protected List<BranchDTO> branchDTOs;\n    @Inject\n    protected List<Contributor> contributorList;\n    @Inject\n    protected List<Branch> branchList;\n    @Inject\n    protected RepoBranchesMapper branchesMapper;\n    @Inject\n    protected RepoContributorsMapper contributorsMapper;\n    @Inject\n    protected Model model;\n    @Inject\n    protected Repository repository;\n    private RepoInfoView mockView;\n    private RepoInfoPresenter repoInfoPresenter;\n\n}\n\nclass RepoInfoPresenterTest extends BasePresenter {\n\n    @Inject\n    protected List<ContributorDTO> contributorDTOs;\n    @Inject\n    protected List<BranchDTO> branchDTOs;\n    @Inject\n    protected List<Contributor> contributorList;\n    @Inject\n    protected List<Branch> branchList;\n    @Inject\n    protected RepoBranchesMapper branchesMapper;\n    @Inject\n    protected RepoContributorsMapper contributorsMapper;\n    @Inject\n    protected Model model;\n    @Inject\n    protected Repository repository;\n    private RepoInfoView mockView;\n    private RepoInfoPresenter repoInfoPresenter;\n\n    @Test\n    public void testShowLoadingOnError() {\n", "reference": "        doAnswer(invocation -> Observable.error(new Throwable(TestConst.TEST_ERROR)))\n                .when(model)\n                .getRepoContributors(TestConst.TEST_OWNER, TestConst.TEST_REPO);\n        doAnswer(invocation -> Observable.error(new Throwable(TestConst.TEST_ERROR)))\n                .when(model)\n                .getRepoBranches(TestConst.TEST_OWNER, TestConst.TEST_REPO);\n\n        repoInfoPresenter.onCreateView(null);\n\n        verify(mockView).showLoading();\n    }\n\n}", "prediction": "        repoInfoPresenter.onCreateView(null);\n        repoInfoPresenter.onError(new Exception());\n        verify(mockView).showLoading(false);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "49236241_0", "part": [1, 1], "seq": [1, 1], "prompt": "class MapScreenshotProvider extends BaseScreenshotProvider {\n\n    @NonNull\n    @VisibleForTesting\n        /* default */ List<MapView> locateMapViewsInHierarchy(@NonNull final View view) {\n        final List<MapView> result = new ArrayList<>();\n\n        final Queue<View> viewsToProcess = new LinkedList<>();\n        viewsToProcess.add(view);\n\n        while (!viewsToProcess.isEmpty()) {\n            final View viewToProcess = viewsToProcess.remove();\n\n            if (viewToProcess instanceof MapView && viewToProcess.getVisibility() == VISIBLE) {\n                result.add((MapView) viewToProcess);\n            } else if (viewToProcess instanceof ViewGroup) {\n                final ViewGroup viewGroup = (ViewGroup) viewToProcess;\n\n                for (int childIndex = 0; childIndex < viewGroup.getChildCount(); childIndex++) {\n                    viewsToProcess.add(viewGroup.getChildAt(childIndex));\n                }\n            }\n        }\n\n        return result;\n    }\n\n    public  MapScreenshotProvider(\n            @NonNull final Context applicationContext,\n            @NonNull final Logger logger);\n\n    @NonNull @Override public Observable<Bitmap> getScreenshotBitmap(@NonNull final Activity activity);\n    @NonNull private Observable<List<LocatedBitmap>> getMapViewBitmapsObservable(@NonNull final List<MapView> mapViews);\n\n    private MapScreenshotProvider mapScreenshotProvider;\n    @Mock\n    private Context applicationContext;\n\n}\n\nclass MapScreenshotProviderTest {\n\n    private MapScreenshotProvider mapScreenshotProvider;\n    @Mock\n    private Context applicationContext;\n\n    @SuppressWarnings(\"MethodName\")\n    @Test\n    public void testThat_noExceptionThrown_when_searchingViewHierarchyThatContainsMultipleViews() {\n", "reference": "        // Arrange\n        final ViewGroup mockRootView = mock(ViewGroup.class);\n        final int numberOfChildViews = 4;\n        assert numberOfChildViews > 1;\n\n        when(mockRootView.getChildCount()).thenReturn(numberOfChildViews);\n        when(mockRootView.getChildAt(anyInt())).thenReturn(mock(View.class));\n\n        // Act\n        mapScreenshotProvider.locateMapViewsInHierarchy(mockRootView);\n    }\n\n}", "prediction": "        final View view = mock(View.class);\n        final ViewGroup viewGroup = mock(ViewGroup.class);\n        final View view1 = mock(View.class);\n        final View view2 = mock(View.class);\n        final View view3 = mock(View.class);\n\n        when(view.getParent()).thenReturn(viewGroup);\n        when(viewGroup.getChildCount()).thenReturn(3);\n        when(viewGroup.getChildAt(0)).thenReturn(view1);\n        when(viewGroup.getChildAt(1)).thenReturn(view2);\n        when(viewGroup.getChildAt(2)).thenReturn(view3);\n\n        mapScreenshotProvider.locateMapViewsInHierarchy(view);\n\n        verify(view1).getParent();\n        verify(view2).getParent();\n        verify(view3).getParent();\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "49475567_144", "part": [1, 1], "seq": [1, 1], "prompt": "class ViewHelper {\n\n    public String sectionNumber(int section, int subsection)\n    {\n        return String.format(\"%d.%d\", section, subsection);\n    }\n\n    public String sectionHeaderText(int section, int subsection, FunctionDocumentation functionDocumentation);\n    public String sectionAnchor(int section, int subsection);\n    public String href(String id);\n    public String href(ItemDocumentation itemDocumentation);\n    public String href(ItemDocumentationSupport ids);\n    public String itemAnchor(ItemDocumentation itemDocumentation);\n    public String memberText(GroupDocumentation g, GroupMember m);\n    public String summarize(BaseDocumentation doc, int length, String elideText);\n\n    private ViewHelper vh;\n    private ItemDocumentation doc;\n\n}\n\nclass ViewHelperTest {\n\n    private ViewHelper vh;\n    private ItemDocumentation doc;\n\n    @Test\n    public void testSectionNumber()\n    {\n", "reference": "        assertEquals(\"10.2\", vh.sectionNumber(10, 2));\n    }\n\n}", "prediction": "        assertEquals(\"1.1\", vh.sectionNumber(1, 1));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "49483698_18", "part": [1, 1], "seq": [1, 1], "prompt": "class Strings {\n\n    public static String repeat(char c, int count) {\n        if (count < 1) return EMPTY_STRING;\n        char[] chars = new char[count];\n        Arrays.fill(chars, c);\n        return new String(chars);\n    }\n\n    private  Strings();\n\n    public static boolean isNullOrEmpty(String str);\n    public static boolean hasText(String s);\n    public static boolean allHasText(String... strings);\n    private static void checkVarargString(String... strings);\n    public static boolean allNullOrEmpty(String... strings);\n    public static String leftTrim(String s);\n    public static String rightTrim(String str);\n    public static boolean containsNone(String str, String invalidCharsStr);\n    public static boolean containsOnly(String str, String allowedChars);\n    public static String repeat(String str, int count);\n    public static String reverse(String str);\n    public static String insertFromLeft(String str, int interval, String stringToInsert);\n    public static String insertFromRight(String str, int interval, String stringToInsert);\n    public static String rightPad(String str, int size);\n    public static String rightPad(String str, int size, char padChar);\n    public static String rightPad(String str, int size, String padStr);\n    public static String leftPad(String str, int size);\n    public static String leftPad(String str, int size, char padChar);\n    public static String subStringUntilFirst(String str, String s);\n    public static String subStringUntilLast(String str, String s);\n    public static String subStringAfterFirst(String str, String s);\n    public static String subStringAfterLast(String str, String s);\n    public static String leftPad(String str, int size, String padStr);\n    public static String whiteSpacesToSingleSpace(String str);\n    public static String eliminateWhiteSpaces(String str);\n    public static String concatWithString(String str, Collection<?> collection);\n    public static String concatWithString(String str, Object... objects);\n    public static String[] separateGrams(String word, int gramSize);\n\n}\n\nclass StringsTest {\n\n    @Test\n    public void repeatTest() {\n", "reference": "        assertEquals(repeat('c', -1), \"\");\n        assertEquals(repeat('c', 3), \"ccc\");\n        assertEquals(repeat('c', 1), \"c\");\n        assertEquals(repeat('c', 0), \"\");\n\n        assertNull(repeat(null, 1));\n        assertEquals(repeat(\"ab\", -1), \"\");\n        assertEquals(repeat(\"ab\", 3), \"ababab\");\n        assertEquals(repeat(\"ab\", 1), \"ab\");\n        assertEquals(repeat(\"ab\", 0), \"\");\n    }\n\n}", "prediction": "        assertEquals(\"\", Strings.repeat('a', 0));\n        assertEquals(\"a\", Strings.repeat('a', 1));\n        assertEquals(\"aa\", Strings.repeat('a', 2));\n        assertEquals(\"aaaa\", Strings.repeat('a', 4));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "49652464_6", "part": [1, 1], "seq": [1, 1], "prompt": "class Encoder {\n\n    public static String substring(String tail, int startIndex, int endIndex) {\n        if (tail == null) {\n            return \"\";\n        }\n        if (tail.length() <= startIndex) {\n            return \"\";\n        } else {\n            if (endIndex > tail.length() - 1) {\n                return tail.substring(startIndex, tail.length());\n            } else {\n                return tail.substring(startIndex, endIndex);\n            }\n        }\n    }\n\n    private static Set<String> getSet(String value);\n    public static Set<String> operatePhonetic(String acc, Character c, String tail);\n    private static boolean isDoubleConsonnant(Character c, String tail);\n    private static Set<String> replaceTwoLettersSounds(String acc, char c, String tail);\n    private static Set<String> handleJEANSpecialCase(String acc, char c, String tail);\n    private static Set<String> replaceAISounds(String acc, char c, String tail, Character... firstLetters);\n    private static Set<String> replaceThreeLettersINSound(String acc, char c, String tail, Character... firstLetters);\n    private static Set<String> replaceONOrINOrANSound(String acc, char c, String tail, String replaceValue, Character... firstLetters);\n    public static Character charAt(String tail, int position);\n\n}\n\nclass EncoderTest {\n\n    @Test\n    public void testSubstringEndIndexEqualsToStartIndex() throws Exception {\n", "reference": "        Encoder encoder = new Encoder();\n        String result = encoder.substring(\"ERT\", 2, 2);\n        Assertions.assertThat(result).isEqualTo(\"\");\n    }\n\n}", "prediction": "        assertEquals(\"\", Encoder.substring(\"\", 0, 0));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "49943894_350", "part": [1, 1], "seq": [1, 1], "prompt": "class RouterDeploymentDefinition {\n\n    protected void setupAccountOwner() {\n        if (networkModel.isNetworkSystem(guestNetwork) || guestNetwork.getGuestType() == Network.GuestType.Shared) {\n            owner = accountMgr.getAccount(Account.ACCOUNT_ID_SYSTEM);\n        }\n    }\n\n    protected  RouterDeploymentDefinition(final Network guestNetwork, final DeployDestination dest,\n                                         final Account owner, final Map<Param, Object> params);\n\n    public Long getServiceOfferingId();\n    public Vpc getVpc();\n    public Network getGuestNetwork();\n    public DeployDestination getDest();\n    public Account getOwner();\n    public Map<Param, Object> getParams();\n    public boolean isRedundant();\n    public DeploymentPlan getPlan();\n    public boolean isVpcRouter();\n    public Pod getPod();\n    public Long getPodId();\n    public List<DomainRouterVO> getRouters();\n    public VirtualRouterProvider getVirtualProvider();\n    public boolean isBasic();\n    public boolean isPublicNetwork();\n    public PublicIp getSourceNatIP();\n    public boolean needsPublicNic();\n    public boolean hasSourceNatService();\n    protected void generateDeploymentPlan();\n    public List<DomainRouterVO> deployVirtualRouter();\n    private boolean isRouterDeployed();\n    @DB protected void findOrDeployVirtualRouter();\n    protected void lock();\n    protected void unlock();\n    protected void checkPreconditions();\n    protected List<DeployDestination> findDestinations();\n    protected int getNumberOfRoutersToDeploy();\n    protected boolean prepareDeployment();\n    protected void executeDeployment();\n    protected void findSourceNatIP();\n    protected void findDefaultServiceOfferingId();\n    protected void findServiceOfferingId();\n    protected void findVirtualProvider();\n    protected void deployAllVirtualRouters();\n    protected List<HostPodVO> listByDataCenterIdVMTypeAndStates(final long id, final VirtualMachine.Type type, final VirtualMachine.State... states);\n    protected void planDeploymentRouters();\n    protected boolean routersNeedReset();\n\n    @Mock\n    protected NetworkVO mockNw;\n    protected RouterDeploymentDefinition deployment;\n\n}\n\nclass RouterDeploymentDefinitionTest  {\n\n    @Mock\n    protected NetworkVO mockNw;\n    protected RouterDeploymentDefinition deployment;\n\n    @Test\n    public void testSetupAccountOwnerNotNetworkSystem() {\n", "reference": "        // Prepare\n        when(mockNetworkModel.isNetworkSystem(mockNw)).thenReturn(false);\n        when(mockNw.getGuestType()).thenReturn(Network.GuestType.Shared);\n        final Account newAccountOwner = mock(Account.class);\n        when(mockAccountMgr.getAccount(Account.ACCOUNT_ID_SYSTEM)).thenReturn(newAccountOwner);\n        //Execute\n        deployment.setupAccountOwner();\n        // Assert\n        assertEquals(\"New account owner not properly set\", newAccountOwner, deployment.owner);\n    }\n\n}", "prediction": "        when(mockNw.getGuestType()).thenReturn(Network.GuestType.Isolated);\n        deployment.setupAccountOwner();\n        assertEquals(deployment.getOwner(), deployment.getAccount());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "49945501_58", "part": [1, 1], "seq": [1, 1], "prompt": "class RestExceptionHandlerRegistry {\n\n    public Optional<ExceptionHandlerBinding> findBindingFor(Class<? extends Throwable> exceptionClass) {\n        if (exceptionHandlerBindings == null || exceptionHandlerBindings.isEmpty()) {\n            return Optional.empty();\n        }\n        int currentDistance = Integer.MAX_VALUE;\n        ExceptionHandlerBinding closestBinding = null;\n        for (ExceptionHandlerBinding binding : exceptionHandlerBindings) {\n            int tempDistance = getDistanceBetweenExceptions(exceptionClass, binding.getExceptionClass());\n            if (tempDistance < currentDistance) {\n                currentDistance = tempDistance;\n                closestBinding = binding;\n                if (currentDistance == 0) {\n                    break;\n                }\n            }\n        }\n        return Optional.ofNullable(closestBinding);\n    }\n\n    public  RestExceptionHandlerRegistry(Set<ExceptionHandlerBinding> bindings);\n\n    private int getDistanceBetweenExceptions(Class<?> clazz, Class<?> mapperTypeClazz);\n\n    private RestExceptionHandlerRegistry registry;\n\n}\n\nclass RestExceptionHandlerRegistryTest {\n\n    private RestExceptionHandlerRegistry registry;\n\n    @Test\n    public void shouldReturnEmpty_IfBindingNotFound() throws Exception {\n", "reference": "        ExceptionHandlerBinding binding = ExceptionHandlerBinding.fromAnnotatedClass(IllegalStateExceptionHandler.class);\n        registry = new RestExceptionHandlerRegistry(Sets.newHashSet(binding));\n        Optional<ExceptionHandlerBinding> foundBinding = registry.findBindingFor(IllegalArgumentException.class);\n        assertThat(foundBinding).isEmpty();\n    }\n\n}", "prediction": "        Optional<ExceptionHandlerBinding> binding = registry.findBindingFor(RuntimeException.class);\n\n        assertThat(binding).isNotPresent();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "50205233_147", "part": [1, 1], "seq": [1, 1], "prompt": "class TokenStream {\n\n    public String consume() throws ParsingException, IllegalStateException {\n        if (completed) {\n            throwNoMoreContent();\n        }\n        // Get the value from the current token ...\n        String result = currentToken().value();\n        moveToNextToken();\n        return result;\n    }\n\n    public  TokenStream(String content,\n                       Tokenizer tokenizer,\n                       boolean caseSensitive);\n\n    public TokenStream start();\n    protected List<Token> initializeTokens(List<Token> tokens);\n    public void rewind();\n    public Marker mark();\n    public boolean rewind(Marker marker);\n    public boolean advance(Marker marker);\n    public Position previousPosition();\n    public Position previousPosition(int count);\n    public Position nextPosition();\n    public int consumeInteger();\n    public long consumeLong();\n    public boolean consumeBoolean();\n    protected void throwNoMoreContent();\n    public String peek();\n    public TokenStream consume(String expected);\n    public TokenStream consume(char expected);\n    public TokenStream consume(int expectedType);\n    public TokenStream consume(String expected,\n                               String... expectedForNextTokens);\n    public TokenStream consume(String[] nextTokens);\n    public TokenStream consume(Iterable<String> nextTokens);\n    public String consumeAnyOf(int... typeOptions);\n    public String consumeAnyOf(String... options);\n    public TokenStream consumeThrough(char expected);\n    public TokenStream consumeThrough(char expected, char skipMatchingTokens);\n    public TokenStream consumeThrough(String expected);\n    public TokenStream consumeThrough(String expected, String skipMatchingTokens);\n    public TokenStream consumeUntil(char expected);\n    public TokenStream consumeUntil(char expected, char skipMatchingTokens);\n    public TokenStream consumeUntil(String expected);\n    public TokenStream consumeUntil(String expected, String... skipMatchingTokens);\n    public TokenStream consumeUntilEndOrOneOf(String... stopTokens);\n    public boolean canConsumeInteger(IntConsumer consumer);\n    public boolean canConsumeBoolean(BooleanConsumer consumer);\n    public boolean canConsumeLong(LongConsumer consumer);\n    public boolean canConsume(String expected);\n    public boolean canConsume(int type, String expected);\n    public boolean canConsumeWord(String expected);\n    public boolean canConsume(char expected);\n    public boolean canConsume(int expectedType);\n    public boolean canConsume(String currentExpected,\n                              String... expectedForNextTokens);\n    public boolean canConsume(int type, String currentExpected, String... expectedForNextTokens);\n    public boolean canConsumeWords(String currentExpected, String... expectedForNextTokens);\n    public boolean canConsume(String[] nextTokens);\n    public boolean canConsume(Iterable<String> nextTokens);\n    public boolean canConsumeAnyOf(String firstOption,\n                                   String... additionalOptions);\n    public boolean canConsumeAnyOf(String[] options);\n    public boolean canConsumeAnyOf(Iterable<String> options);\n    public boolean canConsumeAnyOf(int firstTypeOption,\n                                   int... additionalTypeOptions);\n    public boolean canConsumeAnyOf(int[] typeOptions);\n    public boolean matches(String expected);\n    public boolean matches(int type, String expected);\n    public boolean matchesWord(String expected);\n    public boolean matches(char expected);\n    public boolean matches(int expectedType);\n    public boolean matches(String currentExpected,\n                           String... expectedForNextTokens);\n    public boolean matches(String[] nextTokens);\n    public boolean matches(Iterable<String> nextTokens);\n    public boolean matches(int currentExpectedType,\n                           int... expectedTypeForNextTokens);\n    public boolean matches(int[] typesForNextTokens);\n    public boolean matchesAnyOf(String firstOption,\n                                String... additionalOptions);\n    public boolean matchesAnyOf(int type, String firstOption, String... additionalOptions);\n    public boolean matchesAnyWordOf(String firstOption, String... additionalOptions);\n    public boolean matchesAnyOf(String[] options);\n    public boolean matchesAnyOf(Iterable<String> options);\n    public boolean matchesAnyOf(int firstTypeOption,\n                                int... additionalTypeOptions);\n    public boolean matchesAnyOf(int[] typeOptions);\n    public boolean hasNext();\n    @Override public String toString();\n    private void moveToNextToken(List<Token> newTokens);\n    private void moveToNextToken();\n    final Token currentToken();\n    public String getContentFrom(Marker starting);\n    public String getContentBetween(Marker starting,\n                                    Position end);\n    public String getContentBetween(Position starting,\n                                    Position end);\n    protected String getContentBetween(int startIndex,\n                                       Position end);\n    public final Token previousToken(int count);\n     String generateFragment();\n    static String generateFragment(String content,\n                                   int indexOfProblem,\n                                   int charactersToIncludeBeforeAndAfter,\n                                   String highlightText);\n    public static BasicTokenizer basicTokenizer(boolean includeComments);\n    public String getInputString();\n\n    public static final int WORD;\n    public static final int SYMBOL;\n    public static final int DECIMAL;\n    public static final int SINGLE_QUOTED_STRING;\n    public static final int DOUBLE_QUOTED_STRING;\n    public static final int COMMENT;\n    private Tokenizer tokenizer;\n    private String content;\n    private TokenStream tokens;\n\n}\n\nclass TokenStreamTest {\n\n    public static final int WORD;\n    public static final int SYMBOL;\n    public static final int DECIMAL;\n    public static final int SINGLE_QUOTED_STRING;\n    public static final int DOUBLE_QUOTED_STRING;\n    public static final int COMMENT;\n    private Tokenizer tokenizer;\n    private String content;\n    private TokenStream tokens;\n\n    @Test(expected = ParsingException.class)\n    public void shouldFailToConsumeInCaseSensitiveMannerWithExpectedValuesWhenMatchingIncorrectCase() {\n", "reference": "        makeCaseSensitive();\n        tokens.consume(\"Select\");\n        tokens.consume(\"all\");\n        tokens.consume(\"Columns\");\n    }\n\n}", "prediction": "        tokens.consume(\"foo\");\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "50250915_64", "part": [1, 1], "seq": [1, 1], "prompt": "class BitbucketServerScm extends AbstractBitbucketScm {\n\n    @Nonnull\n    @Override\n    public String getId() {\n        return ID;\n    }\n\n    public  BitbucketServerScm(Reachable parent);\n\n    @Nonnull @Override public String getUri();\n    @Override public ScmServerEndpointContainer getServers();\n    @Override protected @Nonnull String createCredentialId(@Nonnull String apiUrl);\n    @Nonnull @Override protected String getDomainId();\n\n     String token;\n\n}\n\nclass BitbucketServerScmTest extends AbstractBitbucketScm {\n\n     String token;\n\n    @Test\n    public void getBitbucketScmWithoutApiUrlParam() throws IOException, UnirestException {\n", "reference": "        new RequestBuilder(baseUrl)\n                .status(400)\n                .jwtToken(getJwtToken(j.jenkins, authenticatedUser.getId(), authenticatedUser.getId()))\n                .get(\"/organizations/jenkins/scm/\"+BitbucketServerScm.ID+\"/\")\n                .build(Map.class);\n    }\n\n}", "prediction": "        BitbucketServerScm scm = new BitbucketServerScm(new Reachable(\"http://localhost:7990\"));\n        assertEquals(\"http://localhost:7990/rest/api/1.0\", scm.getUri());\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "51344857_3", "part": [1, 1], "seq": [1, 1], "prompt": "class HtmlImageActionCreator {\n\n    public static Element getImageActionElement(String imageActionStringRepresentation) {\n        return new Element(Tag.valueOf(\"a\"), \"\")\n                .attr(\"href\", imageActionStringRepresentation)\n                .appendChild(\n                        new Element(Tag.valueOf(\"img\"), \"\")\n                                .attr(\"src\", imageActionStringRepresentation));\n    }\n\n}\n\nclass HtmlImageActionCreatorTest {\n\n    @Test\n    public void testGetImageActionElement() {\n", "reference": "        String link = \"{action_string_representation}\";\n        Element element = HtmlImageActionCreator.getImageActionElement(link);\n\n        assertThat(element.tag().getName(), is(\"a\"));\n        assertThat(element.attr(\"href\"), is(link));\n        assertThat(element.children().size(), is(1));\n        assertThat(element.children().first().tag().getName(), is(\"img\"));\n        assertThat(element.children().first().attr(\"src\"), is(link));\n    }\n\n}", "prediction": "        Element element = HtmlImageActionCreator.getImageActionElement(\"http://www.google.com/logo.png\");\n        assertEquals(\"a\", element.tagName());\n        assertEquals(\"http://www.google.com/logo.png\", element.attr(\"href\"));\n        assertEquals(\"http://www.google.com/logo.png\", element.child(0).attr(\"src\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "51400982_2", "part": [1, 1], "seq": [1, 1], "prompt": "class KafkaOffsetManager implements AutoCloseable {\n\n    public void setOffsets(Map<TopicAndPartition, Long> offsets) throws IllegalArgumentException {\n\n        if (MapUtils.isEmpty(offsets)) {\n            throw new IllegalArgumentException(\"Offsets map can't be null or empty\");\n        }\n        if (!KafkaOffsetManagerUtils.isValidOffsetMap(offsets)) {\n            throw new IllegalArgumentException(\"Invalid offsets Map<TopicAndPartition, Long>\");\n        }\n        dao.setOffsets(groupid, offsets);\n    }\n\n    private  KafkaOffsetManager();\n\n    public void close();\n    public Map<TopicAndPartition, Long> getOffsets();\n    public Map<TopicAndPartition, Long> getEarliestOffsets();\n    public Map<TopicAndPartition, Long> getEarliestOffsets(String topic);\n    public Map<TopicAndPartition, Long> getLatestOffsets();\n    public Map<TopicAndPartition, Long> getLatestOffsets(String topic);\n    protected scala.collection.immutable.Set<TopicAndPartition> getPartitionsForTopcic(String topic);\n\n    private static Logger Log;\n    private KafkaOffsetManager validKOM;\n    private IOffsetDao dao;\n    private List<String> topicList;\n    @ClassRule\n    public static KafkaJunitRule kafkaRule;\n\n}\n\nclass KafkaOffsetManagerTest {\n\n    private static Logger Log;\n    private KafkaOffsetManager validKOM;\n    private IOffsetDao dao;\n    private List<String> topicList;\n    @ClassRule\n    public static KafkaJunitRule kafkaRule;\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testSetWithInvalidParams() throws Exception {\n", "reference": "\n        validKOM.setOffsets(null);\n    }\n\n}", "prediction": "        validKOM.setOffsets(null);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "51700398_22", "part": [1, 1], "seq": [1, 1], "prompt": "class SymbolService {\n\n\tpublic void addFavoriteSymbol(String fromSymbolCode, String toSymbolCode, String username) {\n\t\tfavoriteSymbolRepository.save(new FavoriteSymbolEntity(fromSymbolCode, toSymbolCode, username));\n\t\tlog.info(\"Favorite symbol added:{}/{} user:{}\", fromSymbolCode, toSymbolCode, username);\n\t}\n\n\tpublic Symbol addSymbol(String code, String name, String countryFlag, String currencyCode);\n\tpublic Optional<Symbol> getForCode(String code);\n\tpublic Optional<Symbol> getForCodeWithNoCurrency(String code);\n\tpublic void deleteFavoriteSymbol(String fromSymbolCode, String toSymbolCode, String username);\n\n\t@Autowired\n\tprivate SymbolRepository symbolRepo;\n\t@Autowired\n\tprivate SymbolService symbolService;\n\n}\n\nclass SymbolServiceTest {\n\n\t@Autowired\n\tprivate SymbolRepository symbolRepo;\n\t@Autowired\n\tprivate SymbolService symbolService;\n\n\t@Sql(\"/sql/insert_user_symbol_favorite.sql\")\n\t@Test\n\tpublic void testAddFavoriteSymbol() throws Exception {\n", "reference": "\t\tsymbolService.addFavoriteSymbol(USD, EUR, \"user\");\n\t}\n\n}", "prediction": "\t\tsymbolService.addFavoriteSymbol(\"BTC\", \"USD\", \"test\");\n\t\tList<FavoriteSymbolEntity> favoriteSymbols = favoriteSymbolRepository.findAll();\n\t\tassertEquals(1, favoriteSymbols.size());\n\t\tassertEquals(\"BTC\", favoriteSymbols.get(0).getFromSymbolCode());\n\t\tassertEquals(\"USD\", favoriteSymbols.get(0).getToSymbolCode());\n\t\tassertEquals(\"test\", favoriteSymbols.get(0).getUsername());\n\t}", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "51772967_5", "part": [1, 1], "seq": [1, 1], "prompt": "class FileAccessService {\n\n    public boolean isUserCanDelete(String userId, File file) {\n        if (isOwner(userId, file)) return true;\n        if (isUserHasAtLeastGivenPermission(userId, file, Permission.GET_AND_DELETE)) return true;\n        return false;\n    }\n\n    public boolean isUserHasNotAccess(String userId, File file);\n    public boolean isUserCanNotDelete(String userId, File file);\n    public boolean isUserCanNotShare(String userId, File file);\n    public boolean isUserHasAccess(String userId, File file);\n    public boolean isUserCanShare(String userId, File file);\n    public boolean isOwner(String userId, File file);\n    public boolean isUserHasAtLeastGivenPermission(String userId, File file, Permission... permissions);\n\n    private FileAccessService fileAccessService;\n\n}\n\nclass FileAccessServiceTest {\n\n    private FileAccessService fileAccessService;\n\n    @Test\n    public void testIsUserCanDelete() throws Exception {\n", "reference": "\n    }\n\n    public boolean isUserHasNotAccess(String userId, File file);\n    public boolean isUserCanNotDelete(String userId, File file);\n    public boolean isUserCanNotShare(String userId, File file);\n    public boolean isUserHasAccess(String userId, File file);\n    public boolean isUserCanShare(String userId, File file);\n    public boolean isOwner(String userId, File file);\n    public boolean isUserHasAtLeastGivenPermission(String userId, File file, Permission... permissions);\n\n    private FileAccessService fileAccessService;\n\n}\n\nclass FileAccessServiceTest {\n\n    private FileAccessService fileAccessService;\n\n    @Test\n    public void testIsUserCanDelete() throws Exception {\n\n    }\n\n}", "prediction": "        File file = new File();\n        file.setOwner(\"owner\");\n        file.setPermissions(new HashSet<>(Arrays.asList(new Permission[]{Permission.GET_AND_DELETE})));\n        assertTrue(fileAccessService.isUserCanDelete(\"owner\", file));\n        assertFalse(fileAccessService.isUserCanDelete(\"user\", file));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "52609528_163", "part": [1, 1], "seq": [1, 1], "prompt": "class RequestPropertyFilter {\n\n    public static FilterResult filterProperty(HttpServerRequest request, String filterPropertyKey, String filterPropertyValue, boolean reject) {\n\n        CaseInsensitiveHeaders headers = new CaseInsensitiveHeaders();\n        headers.setAll(request.headers());\n\n        if (URL.equals(filterPropertyKey)) {\n            boolean matches = filterRequestURL(request, filterPropertyValue);\n            FilterResult result = rejectIfNeeded(reject, matches);\n            logFilterResult(request, filterPropertyKey, filterPropertyValue, result);\n            return result;\n        }\n        if (METHOD.equals(filterPropertyKey)) {\n            boolean matches = filterRequestMethod(request, filterPropertyValue);\n            FilterResult result = rejectIfNeeded(reject, matches);\n            logFilterResult(request, filterPropertyKey, filterPropertyValue, result);\n            return result;\n        }\n        if (headers.names().contains(filterPropertyKey) && headers.get(filterPropertyKey).equalsIgnoreCase(filterPropertyValue)) {\n            FilterResult result = reject ? FilterResult.REJECT : FilterResult.FILTER;\n            logFilterResult(request, filterPropertyKey, filterPropertyValue, result);\n            return result;\n        }\n        logFilterResult(request, filterPropertyKey, filterPropertyValue, FilterResult.REJECT, true);\n        return FilterResult.REJECT;\n    }\n\n    private static FilterResult rejectIfNeeded(boolean reject, boolean matches);\n    private static boolean filterRequestURL(HttpServerRequest request, String url);\n    private static boolean filterRequestMethod(HttpServerRequest request, String method);\n    private static void logFilterResult(HttpServerRequest request, String filterPropertyKey, String filterPropertyValue, FilterResult filterResult);\n    private static void logFilterResult(HttpServerRequest request, String filterPropertyKey, String filterPropertyValue, FilterResult filterResult, boolean noMatchingProperty);\n\n    private final String METHOD_PUT;\n    private final String METHOD_PUT_POST_REGEX;\n    private final String METHOD_GET;\n    private final String PUT_REQUEST_REGEX;\n    private final String PUT_REQUEST_URI;\n    private final String OTHER_PUT_REQUEST_URI;\n\n}\n\nclass RequestPropertyFilterTest {\n\n    private final String METHOD_PUT;\n    private final String METHOD_PUT_POST_REGEX;\n    private final String METHOD_GET;\n    private final String PUT_REQUEST_REGEX;\n    private final String PUT_REQUEST_URI;\n    private final String OTHER_PUT_REQUEST_URI;\n\n    @Test\n    public void testPropertyMethodNoMatchRequest(TestContext context){\n", "reference": "        context.assertEquals(FilterResult.NO_MATCH,\n                RequestPropertyFilter.filterProperty(new PUTRequest(), RequestPropertyFilter.METHOD, METHOD_GET, false));\n\n        // check again with reject = true\n        context.assertEquals(FilterResult.NO_MATCH,\n                RequestPropertyFilter.filterProperty(new PUTRequest(), RequestPropertyFilter.METHOD, METHOD_GET, true));\n    }\n\n}", "prediction": "       Async async = context.async();\n        HttpServerRequest request = mock(HttpServerRequest.class);\n        when(request.method()).thenReturn(METHOD_GET);\n        when(request.uri()).thenReturn(PUT_REQUEST_URI);\n        FilterResult result = RequestPropertyFilter.filterProperty(request, METHOD, METHOD_PUT, true);\n        context.assertEquals(FilterResult.REJECT, result);\n        async.complete();\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "52850323_1", "part": [1, 1], "seq": [1, 1], "prompt": "class RCLJava {\n\n  public static boolean ok() {\n    return nativeOk();\n  }\n\n  private  RCLJava();\n\n  private static SingleThreadedExecutor getGlobalExecutor();\n  private static void cleanup();\n  public static boolean isInitialized();\n  public static void rclJavaInit();\n  private static native void nativeRCLJavaInit();\n  private static native long nativeCreateNodeHandle(String nodeName, String namespace);\n  private static native String nativeGetRMWIdentifier();\n  public static String getRMWIdentifier();\n  private static native boolean nativeOk();\n  public static Node createNode(final String nodeName);\n  public static Node createNode(final String nodeName, final String namespace);\n  public static void spin(final Node node);\n  public static void spin(final ComposableNode composableNode);\n  public static void spinOnce(final Node node);\n  public static void spinOnce(final ComposableNode composableNode);\n  public static void spinSome(final Node node);\n  public static void spinSome(final ComposableNode composableNode);\n  private static native void nativeShutdown();\n  public static void shutdown();\n  public static long convertQoSProfileToHandle(final QoSProfile qosProfile);\n  private static native long nativeConvertQoSProfileToHandle(int history, int depth,\n      int reliability, int durability, boolean avoidROSNamespaceConventions);\n  public static void disposeQoSProfile(final long qosProfileHandle);\n  private static native void nativeDisposeQoSProfile(long qosProfileHandle);\n\n}\n\nclass RCLJavaTest {\n\n  @Test\n  public final void testOk() {\n", "reference": "    RCLJava.rclJavaInit();\n    assertEquals(true, RCLJava.ok());\n    RCLJava.shutdown();\n    assertEquals(false, RCLJava.ok());\n  }\n\n}", "prediction": "    assertTrue(RCLJava.ok());\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "52972024_314", "part": [1, 1], "seq": [1, 1], "prompt": "class ReceiverGenerator implements IReceiverGenerator {\n\n    @Override\n    public IMessageReceiver generate(\n            final Object objInstance,\n            final IResolveDependencyStrategy wrapperResolutionStrategy,\n            final String methodName\n    ) throws InvalidArgumentException, ReceiverGeneratorException {\n        if (\n                null == objInstance ||\n                null == methodName ||\n                methodName.isEmpty() ||\n                null == wrapperResolutionStrategy\n        ) {\n            throw new InvalidArgumentException(\"One of the arguments null or empty.\");\n        }\n        try {\n            Class<IMessageReceiver> clazz = generateClass(\n                    objInstance,\n                    methodName\n            );\n            return clazz.getConstructor(\n                    new Class[]{objInstance.getClass(), IResolveDependencyStrategy.class}\n            )\n                    .newInstance(new Object[]{objInstance, wrapperResolutionStrategy});\n        } catch (Throwable e) {\n            throw new ReceiverGeneratorException(\n                    \"Could not generate message receiver because of the following error:\",\n                    e\n            );\n        }\n    }\n\n    public  ReceiverGenerator(final ClassLoader classLoader);\n\n    private Class<IMessageReceiver> generateClass(\n            final Object usersObject,\n            final String handlerName\n    );\n    private Class findWrapperInterface(final Object actor, final String handler);\n\n}\n\nclass ReceiverGeneratorTest {\n\n    @Test(expected = ReceiverGeneratorException.class)\n    public void checkReceiverGeneratorExceptionOn()\n            throws Exception {\n", "reference": "        CustomActor a = new CustomActor();\n        IResolveDependencyStrategy strategy = mock(IResolveDependencyStrategy.class);\n\n        IReceiverGenerator rg = new ReceiverGenerator(null);\n        rg.generate(a, strategy, \"a\");\n        fail();\n    }\n\n}", "prediction": "        ReceiverGenerator receiverGenerator = new ReceiverGenerator(\n                getClass().getClassLoader()\n        );\n        receiverGenerator.generate(\n                new Object(),\n                new ResolveDependencyStrategy(),\n                \"test\"\n        );\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "53297769_0", "part": [1, 1], "seq": [1, 1], "prompt": "class ShouldUseCompactResponses extends AbstractSetting<Boolean> {\n\n    @Override\n    public Boolean getValue() {\n        return AppiumUIA2Driver\n                .getInstance()\n                .getSessionOrThrow()\n                .shouldUseCompactResponses();\n    }\n\n    public  ShouldUseCompactResponses();\n\n    @Override protected void apply(Boolean shouldUseCompactResponses);\n\n    private ShouldUseCompactResponses shouldUseCompactResponses;\n    private Session session;\n\n}\n\nclass ShouldUseCompactResponsesTest {\n\n    private ShouldUseCompactResponses shouldUseCompactResponses;\n    private Session session;\n\n    @Test\n    public void shouldBeAbleToEnableShouldUseCompactResponses() {\n", "reference": "        session.setCapability(SHOULD_USE_COMPACT_RESPONSES.toString(), \"true\");\n        Assert.assertEquals(true, shouldUseCompactResponses.getValue());\n    }\n\n}", "prediction": "        shouldUseCompactResponses.setValue(true);\n        assertTrue(shouldUseCompactResponses.getValue());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "54455350_1", "part": [1, 1], "seq": [1, 1], "prompt": "class TravelNotesPresenter implements TravelNotesContract.Presenter {\n\n    @Override\n    public void loadData(String key,int page) {\n        view.showDialog();\n//        RouterDemo.getRouter(obj.getLifecycleSubject(),key, page+\"\")\n//                .doOnTerminate(() -> view.disDialog())\n//                .subscribe(d -> obj.dataBinding(d),\n//                        e -> obj.dataError(e));\n        APIServiceManager\n                .getTravelNotesAPI()\n                .getTravelNotesList(key, page + \"\")\n                .compose(obj.bindToLifecycle())\n                .compose(RxSchedulersHelper.io_main())\n                .compose(SchedulersHelper.handleResult())\n                .doOnTerminate(() -> view.disDialog())\n                .subscribe(d -> obj.dataBinding(d),\n                        e -> obj.dataError(e));\n//                .subscribe(s -> RxBus.getInstance().post(RxBus.getInstance()\n//                        .getTag(obj.getClass(),RxBus.TAG_UPDATE), s),\n//                        e -> RxBus.getInstance().post(RxBus.getInstance()\n//                                .getTag(obj.getClass(),RxBus.TAG_ERROR), e.getMessage()));\n    }\n\n    public  TravelNotesPresenter(TravelNotesContract.View view, TravelNotesActivity obj);\n\n    @Override public int refreshData(String key,int page,boolean isNote);\n    @Override public void loadData(String key,int page,int count);\n    @Override public void start();\n    @Override public void close();\n\n     TravelNotesPresenter travelNotesPresenter;\n\n}\n\nclass TravelNotesPresenterTest implements TravelNotesContract.Presenter {\n\n     TravelNotesPresenter travelNotesPresenter;\n\n    @Test\n    public void loadData() throws Exception {\n", "reference": "        travelNotesPresenter.loadData(\"\",0);\n    }\n\n}", "prediction": "        travelNotesPresenter.loadData(\"\", 1);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "54785866_1", "part": [1, 1], "seq": [1, 1], "prompt": "class UIFrame extends UIElement {\n\n\t@Override\n\tpublic Object deepCopy() {\n\t\tfinal int attrSize = attributes != null ? attributes.size() : 0;\n\t\tfinal int childrenSize = children != null ? children.size() : 0;\n\t\tfinal UIFrame clone = new UIFrame(getName(), attrSize, childrenSize);\n\t\tclone.type = type;\n\t\tif (childrenSize > 0) {\n\t\t\tfor (int i = 0; i < childrenSize; i++) {\n\t\t\t\tclone.children.add((UIElement) children.get(i).deepCopy());\n\t\t\t}\n\t\t}\n\t\tif (attrSize > 0) {\n\t\t\tfor (int i = 0; i < attrSize; i++) {\n\t\t\t\tclone.attributes.add((UIAttribute) attributes.get(i).deepCopy());\n\t\t\t}\n\t\t}\n\t\tif (relative != DFLT_RELATIVE) {\n\t\t\tclone.relative = new String[4];\n\t\t\tSystem.arraycopy(relative, 0, clone.relative, 0, 4);\n\t\t}\n\t\tif (offset != DFLT_OFFSET) {\n\t\t\tclone.offset = new String[4];\n\t\t\tSystem.arraycopy(offset, 0, clone.offset, 0, 4);\n\t\t}\n\t\tif (pos != DFLT_POS) {\n\t\t\tclone.pos = new String[4];\n\t\t\tSystem.arraycopy(pos, 0, clone.pos, 0, 4);\n\t\t}\n\t\treturn clone;\n\t}\n\n\tpublic  UIFrame();\n\tpublic  UIFrame(final String name, final String type);\n\tpublic  UIFrame(final String name, final int initialAttributesCapacity, final int initialChildrenCapacity);\n\tpublic  UIFrame(final String name);\n\n\tprivate void init();\n\tpublic String getType();\n\tpublic void setType(final String type);\n\t@Override public List<UIElement> getChildren();\n\tpublic void setChildren(final List<UIElement> children);\n\t@Override public List<UIElement> getChildrenRaw();\n\tpublic void addAttribute(final UIAttribute value);\n\tpublic UIAttribute getValue(final String key);\n\tpublic List<UIAttribute> getAttributes();\n\tpublic String getAnchorRelative(final UIAnchorSide side);\n\tpublic String getAnchorOffset(final UIAnchorSide side);\n\tpublic String getAnchorPos(final UIAnchorSide side);\n\tpublic void setAnchor(final String relative, final String offset);\n\tpublic void setAnchor(final UIAnchorSide side, final String relative, final String pos, final String offset);\n\tpublic void setAnchorRelative(final UIAnchorSide side, final String relative);\n\tpublic void setAnchorPos(final UIAnchorSide side, final String pos);\n\tpublic void setAnchorOffset(final UIAnchorSide side, final String offset);\n\t@Override public UIElement receiveFrameFromPath(final String path);\n\t@Override public String toString();\n\t@Override public boolean equals(final Object obj);\n\tprivate Object[] getSignatureFields();\n\t@Override public int hashCode();\n\n}\n\nclass UIFrameTest {\n\n\t@Test\n\tvoid deepCopy() {\n", "reference": "\t\tfinal UIFrame frame = new UIFrame(\"UIFrameTest_setAnchor\");\n\t\t\n\t\tframe.setAnchor(\"$parent\", \"0\");\n\t\tassertEquals(\"$parent\", frame.getAnchorRelative(UIAnchorSide.TOP));\n\t\tassertEquals(\"$parent\", frame.getAnchorRelative(UIAnchorSide.LEFT));\n\t\tassertEquals(\"$parent\", frame.getAnchorRelative(UIAnchorSide.BOTTOM));\n\t\tassertEquals(\"$parent\", frame.getAnchorRelative(UIAnchorSide.RIGHT));\n\t\tassertEquals(\"MIN\", frame.getAnchorPos(UIAnchorSide.TOP));\n\t\tassertEquals(\"MIN\", frame.getAnchorPos(UIAnchorSide.LEFT));\n\t\tassertEquals(\"MAX\", frame.getAnchorPos(UIAnchorSide.BOTTOM));\n\t\tassertEquals(\"MAX\", frame.getAnchorPos(UIAnchorSide.RIGHT));\n\t\tassertEquals(\"0\", frame.getAnchorOffset(UIAnchorSide.TOP));\n\t\tassertEquals(\"0\", frame.getAnchorOffset(UIAnchorSide.LEFT));\n\t\tassertEquals(\"0\", frame.getAnchorOffset(UIAnchorSide.BOTTOM));\n\t\tassertEquals(\"0\", frame.getAnchorOffset(UIAnchorSide.RIGHT));\n\t\t\n\t\tfinal UIFrame frame2 = (UIFrame) frame.deepCopy();\n\t\tassertEquals(\"$parent\", frame2.getAnchorRelative(UIAnchorSide.TOP));\n\t\tassertEquals(\"$parent\", frame2.getAnchorRelative(UIAnchorSide.LEFT));\n\t\tassertEquals(\"$parent\", frame2.getAnchorRelative(UIAnchorSide.BOTTOM));\n\t\tassertEquals(\"$parent\", frame2.getAnchorRelative(UIAnchorSide.RIGHT));\n\t\tassertEquals(\"MIN\", frame2.getAnchorPos(UIAnchorSide.TOP));\n\t\tassertEquals(\"MIN\", frame2.getAnchorPos(UIAnchorSide.LEFT));\n\t\tassertEquals(\"MAX\", frame2.getAnchorPos(UIAnchorSide.BOTTOM));\n\t\tassertEquals(\"MAX\", frame2.getAnchorPos(UIAnchorSide.RIGHT));\n\t\tassertEquals(\"0\", frame2.getAnchorOffset(UIAnchorSide.TOP));\n\t\tassertEquals(\"0\", frame2.getAnchorOffset(UIAnchorSide.LEFT));\n\t\tassertEquals(\"0\", frame2.getAnchorOffset(UIAnchorSide.BOTTOM));\n\t\tassertEquals(\"0\", frame2.getAnchorOffset(UIAnchorSide.RIGHT));\n\t\t\n\t\tframe2.setAnchor(UIAnchorSide.BOTTOM, \"$Minimap\", \"mid\", \"11\");\n\t\tassertEquals(\"$parent\", frame2.getAnchorRelative(UIAnchorSide.TOP));\n\t\tassertEquals(\"$parent\", frame2.getAnchorRelative(UIAnchorSide.LEFT));\n\t\tassertEquals(\"$Minimap\", frame2.getAnchorRelative(UIAnchorSide.BOTTOM));\n\t\tassertEquals(\"$parent\", frame2.getAnchorRelative(UIAnchorSide.RIGHT));\n\t\tassertEquals(\"MIN\", frame2.getAnchorPos(UIAnchorSide.TOP));\n\t\tassertEquals(\"MIN\", frame2.getAnchorPos(UIAnchorSide.LEFT));\n\t\tassertEquals(\"mid\", frame2.getAnchorPos(UIAnchorSide.BOTTOM));\n\t\tassertEquals(\"MAX\", frame2.getAnchorPos(UIAnchorSide.RIGHT));\n\t\tassertEquals(\"0\", frame2.getAnchorOffset(UIAnchorSide.TOP));\n\t\tassertEquals(\"0\", frame2.getAnchorOffset(UIAnchorSide.LEFT));\n\t\tassertEquals(\"11\", frame2.getAnchorOffset(UIAnchorSide.BOTTOM));\n\t\tassertEquals(\"0\", frame2.getAnchorOffset(UIAnchorSide.RIGHT));\n\t\t\n\t}\n\n}", "prediction": "\t\tfinal UIFrame frame = new UIFrame(\"frame\", \"type\");\n\t\tframe.addAttribute(new UIAttribute(\"attr\", \"value\"));\n\t\tframe.addChild(new UIFrame(\"child\"));\n\t\tfinal UIFrame clone = (UIFrame) frame.deepCopy();\n\t\tassertNotSame(frame, clone);\n\t\tassertEquals(frame.getName(), clone.getName());\n\t\tassertEquals(frame.getType(), clone.getType());\n\t\tassertEquals(frame.getAttributes(), clone.getAttributes());\n\t\tassertEquals(frame.getChildren(), clone.getChildren());\n\t}", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "54854741_58", "part": [1, 1], "seq": [1, 1], "prompt": "class OfxTransactionReader implements Closeable {\n\n\tString readNextNonBlankLine() throws IOException {\n\t\tskipBlankLines();\n\t\treturn reader.readLine();\n\t}\n\n\tpublic  OfxTransactionReader(InputStream inputStream);\n\n\tpublic List<Transaction> transactions();\n\tprivate Transaction readTransaction(SgmlReader sgmlReader, String tagName, String accountNumber);\n\tprivate Long readTransactionAmount(String value);\n\tprivate Date readTransactionDate(String value);\n\tprivate String readAccountNumber(SgmlReader sgmlReader, String tagName);\n\tprivate boolean isCloseTag(Token token, String tagName);\n\tprivate void readHeader();\n\tprivate void advanceToFirstNonHeaderLine();\n\tprivate void skipBlankLines();\n\tprivate void checkValidFormat(String expected, String line);\n\t@Override public void close();\n\n}\n\nclass OfxTransactionReaderTest {\n\n\t@Test\n\tpublic void readNextNonBlankLine() throws IOException {\n", "reference": "\t\ttry (OfxTransactionReader reader = new OfxTransactionReader(\n\t\t\t\tnew ByteArrayInputStream(\"\\n\\r\\none\\n\\rtwo\".getBytes(StandardCharsets.UTF_8)))) {\n\t\t\tassertEquals(\"one\", reader.readNextNonBlankLine());\n\t\t\tassertEquals(\"two\", reader.readNextNonBlankLine());\n\t\t\tassertEquals(null, reader.readNextNonBlankLine());\n\t\t}\n\t}\n\n}", "prediction": "\t\tString line = \"  \\n\";\n\t\tString nextLine = \"line\";\n\t\tStringReader stringReader = new StringReader(line + nextLine);\n\t\tOfxTransactionReader ofxTransactionReader = new OfxTransactionReader(new BufferedReader(stringReader));\n\t\tassertEquals(nextLine, ofxTransactionReader.readNextNonBlankLine());\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "55138951_1", "part": [1, 1], "seq": [1, 1], "prompt": "class CCSManageSvImpl implements ICCSManageSv {\n\n    @Override\n    public void delete(CCSOperationParam param) throws PaasException {\n        param.validate();\n        if (!exists(param))\n            return;\n\n        CcsServiceUserConfig config = getCcsServiceUserConfig(param.getUserId(), param.getServiceId());\n\n        ZKClient client = null;\n        try {\n            client = ZookeeperClientUtil.getZkClientFromPool(config.getZkAddress(), config.getZkUserName(),\n                    CiperUtil.decrypt(ConfigCenterConstants.operators, config.getZkPassword()),config.getServiceId());\n            client.deleteNode(appendCustomUserRootNode(param.getUserId(), param.getServiceId())\n                    + param.getPath());\n        } catch (Exception e) {\n        \tlogger.error(e.getMessage(),e);\n            throw new PaasException(ResourceUtil.getMessage(BundleKeyConstants.CONFIG_ERROR), e);\n        }\n    }\n\n    @Override public void add(CCSOperationParam param, String data);\n    @Override public void add(CCSOperationParam param, byte[] data);\n    @Override public boolean exists(CCSOperationParam param);\n    private CcsServiceUserConfig getCcsServiceUserConfig(String userId, String serviceId);\n    @Override public void modify(CCSOperationParam param, String data);\n    @Override public void modify(CCSOperationParam param, byte[] data);\n    @Override public String get(CCSOperationParam param);\n    @Override public byte[] readBytes(CCSOperationParam param);\n    @Override public List<String> listSubPath(CCSOperationParam param);\n    @Override public Map<String,String> listAllPath(CCSOperationParam param);\n    public List<String> formatPath(List<String> children,CCSOperationParam param);\n    @Override public List<CCSSubListDTO> listSubPathAndData(CCSOperationParam param);\n    @Override public List<String> getServices(CCSOperationParam param);\n    private String appendCustomUserRootNode(String userId, String serviceId);\n    public Map<String, String> getResult();\n    public void setResult(Map<String, String> result);\n\n    private String userId;\n    private String serviceId;\n    @Autowired\n    private ICCSManageSv manageSv;\n    @Autowired\n    private IConfigCenterServiceManageSv iConfigCenterServiceManageSv;\n\n}\n\nclass CCSManageSvImplTest {\n\n    private String userId;\n    private String serviceId;\n    @Autowired\n    private ICCSManageSv manageSv;\n    @Autowired\n    private IConfigCenterServiceManageSv iConfigCenterServiceManageSv;\n\n    @Test\n    public void testDelete() throws Exception {\n", "reference": "        CCSOperationParam ccsOperationParam = new CCSOperationParam();\n        ccsOperationParam.setUserId(userId);\n        ccsOperationParam.setServiceId(serviceId);\n        ccsOperationParam.setPath(\"/test/testPath\");\n        manageSv.delete(ccsOperationParam);\n        assertFalse(manageSv.exists(ccsOperationParam));\n    }\n\n}", "prediction": "       \n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "56359101_193", "part": [1, 1], "seq": [1, 1], "prompt": "class AutonomiccsSystemVmDeploymentService implements InitializingBean {\n\n    protected NetworkVO getDefaultNetwork(long dataCenterId) {\n        DataCenterVO dc = dataCenterDao.findById(dataCenterId);\n        if (dc.getNetworkType() == NetworkType.Advanced && dc.isSecurityGroupEnabled()) {\n            return getDefaultNetworkForAdvancedNetworkingWithSecurityGroupds(dataCenterId, dc);\n        }\n        return getDefaultNetwork(dc);\n    }\n\n    public HostVO searchForRandomHostInCloudToDeployAutonomiccsSystemVm();\n    protected HostVO searchForRandomHostInZoneToDeployAutonomiccsSystemVm(DataCenterVO dataCenterVO);\n    public HostVO searchForRandomHostInPodToDeployAutonomiccsSystemVm(HostPodVO pod);\n    protected HostVO searchForRandomHostInClusterToDeployAutonomiccsSystemVm(ClusterVO c);\n    protected HostVO searchForAnotherRandomHostInTheClusterToStartSystemVmExcludingHosts(ClusterVO c, List<HostVO> excludeHosts);\n    protected boolean canDeployAutonomiccsSystemVmOnHost(HostVO h);\n    protected boolean canHostSupportVm(ServiceOfferingVO vmServiceOffering, HostResources hostResources);\n    public HostVO searchForAnotherRandomHostToStartSystemVm(VMInstanceVO vmInstance);\n    protected HostVO searchForAnotherRandomHostInTheClusterToStartSystemVmExcludingHost(HostVO excludeHost);\n    public AutonomiccsSystemVm deploySystemVmWithJava(Long hostId, SystemVmType systemVmType);\n    protected AutonomiccsSystemVm deploySystemVm(Long hostId, SystemVmType systemVmType);\n    protected AutonomiccsSystemVm allocateAndStartTheSystemVm(VMTemplateVO systemVmTemplate, DataCenterDeployment plan, LinkedHashMap<Network, List<? extends NicProfile>> networks,\n            AutonomiccsSystemVm autonomiccsSystemVm);\n    protected void waitUntilTheAutonomiccsSystemVmIsUpAndRunning(AutonomiccsSystemVm autonomiccsSystemVm);\n    protected AutonomiccsSystemVm createTheAutonomiccsSystemVm(VMTemplateVO systemVmTemplate, Account systemAcct, long id, String name);\n    protected LinkedHashMap<Network, List<? extends NicProfile>> getSystemVmNetworks(HostVO host, DataCenterDeployment plan, Account systemAcct);\n    protected NicProfile createDefaultNic();\n    protected VMTemplateVO getSystemVmTemplate(HostVO host);\n    protected void validateParametersToDeployTheSystemVm(Long hostId, HostVO host);\n    protected long getNextSystemVmId();\n    protected NetworkVO getDefaultNetwork(DataCenterVO dc);\n    protected NetworkVO getDefaultNetworkForAdvancedNetworkingWithSecurityGroupds(long dataCenterId, DataCenterVO dc);\n    protected String createAutonomiccsSystemVmNameForType(long id, SystemVmType systemVmType, String instanceSuffix);\n    protected String getVirtualMachineInstanceSuffix();\n    protected Map<String, String> getConfigurationsFromDatabase();\n    @Override public void afterPropertiesSet();\n    protected void loadAutonomiccsSystemVmServiceOffering();\n\n    private final String commandToInstallOpenJDK7;\n    private final int ONE_MEGABYTE_IN_BYTES;\n    @Spy\n    @InjectMocks\n    private AutonomiccsSystemVmDeploymentService spy;\n    @Mock\n    private ServiceOfferingVO autonomiccsSystemVmServiceOffering;\n    @Mock\n    private SshUtils sshUtils;\n    @Mock\n    private AutonomiccsSystemVmTemplateService autonomiccsSystemVmTemplateService;\n    @Mock\n    private AutonomiccsSystemVmDao autonomiccsSystemVmDao;\n    @Mock\n    private HostService hostService;\n    @Mock\n    private ConfigurationDao configurationDao;\n    @Mock\n    private DataCenterDao dataCenterDao;\n    @Mock\n    private AccountManager accountManager;\n    @Mock\n    private NetworkDao networkDao;\n    @Mock\n    private NetworkModel networkModel;\n    @Mock\n    private NetworkOfferingDao networkOfferingDao;\n    @Mock\n    private NetworkOrchestrationService networkManager;\n    @Mock\n    private VirtualMachineManager virtualMachineManager;\n    @Mock\n    private AutonomiccsServiceOfferingService autonomiccsServiceOfferingService;\n    @Mock\n    private HostUtils hostUtils;\n    @Mock\n    private ThreadUtils threadUtils;\n    @Mock\n    private ClusterService clusterService;\n    @Mock\n    private HostResourcesService hostResourcesService;\n    @Mock\n    private PodService podService;\n    @Mock\n    private ZoneService zoneService;\n\n}\n\nclass AutonomiccsSystemVmDeploymentServiceTest {\n\n    private final String commandToInstallOpenJDK7;\n    private final int ONE_MEGABYTE_IN_BYTES;\n    @Spy\n    @InjectMocks\n    private AutonomiccsSystemVmDeploymentService spy;\n    @Mock\n    private ServiceOfferingVO autonomiccsSystemVmServiceOffering;\n    @Mock\n    private SshUtils sshUtils;\n    @Mock\n    private AutonomiccsSystemVmTemplateService autonomiccsSystemVmTemplateService;\n    @Mock\n    private AutonomiccsSystemVmDao autonomiccsSystemVmDao;\n    @Mock\n    private HostService hostService;\n    @Mock\n    private ConfigurationDao configurationDao;\n    @Mock\n    private DataCenterDao dataCenterDao;\n    @Mock\n    private AccountManager accountManager;\n    @Mock\n    private NetworkDao networkDao;\n    @Mock\n    private NetworkModel networkModel;\n    @Mock\n    private NetworkOfferingDao networkOfferingDao;\n    @Mock\n    private NetworkOrchestrationService networkManager;\n    @Mock\n    private VirtualMachineManager virtualMachineManager;\n    @Mock\n    private AutonomiccsServiceOfferingService autonomiccsServiceOfferingService;\n    @Mock\n    private HostUtils hostUtils;\n    @Mock\n    private ThreadUtils threadUtils;\n    @Mock\n    private ClusterService clusterService;\n    @Mock\n    private HostResourcesService hostResourcesService;\n    @Mock\n    private PodService podService;\n    @Mock\n    private ZoneService zoneService;\n\n    @Test\n    public void getDefaultNetworkTestNetworkTypeNotAdvanced() {\n", "reference": "        NetworkVO network = Mockito.mock(NetworkVO.class);\n        NetworkVO network2 = Mockito.mock(NetworkVO.class);\n        DataCenterVO dc = configureGetDefaultNetworkTest(NetworkType.Basic, true, network, network2);\n\n        NetworkVO result = spy.getDefaultNetwork(0l);\n\n        verifyGetDefaultNetworkTest(dc, network2, result, 0, 0, 1);\n    }\n\n}", "prediction": "        DataCenterVO dc = new DataCenterVO(\"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\", \"test\",", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "56533838_1", "part": [1, 1], "seq": [1, 1], "prompt": "class BuildFileGenerator {\n\n  void generateBuildFiles(ApisVisitor visitor) throws IOException {\n    System.out.println(\"\\n\\n========== READING INPUT DIRECTORY ==========\");\n    Files.walkFileTree(visitor.getSrcDir(), visitor);\n    visitor.setWriterMode(true);\n    System.out.println(\"\\n\\n========== WRITING GENERATED FILES ==========\");\n    Files.walkFileTree(visitor.getSrcDir(), visitor);\n\n    System.out.println(\"\\nBUILD.bazel file generation completed successfully\\n\");\n  }\n\n  public static void main(String[] args);\n\n  private static final String SRC_DIR;\n  private static final String PATH_PREFIX;\n\n}\n\nclass BuildFileGeneratorTest {\n\n  private static final String SRC_DIR;\n  private static final String PATH_PREFIX;\n\n  @Test\n  public void testRegeneration() throws IOException, InterruptedException {\n", "reference": "    // In this test we run the generator twice, changing the generated\n    // google/example/library/v1/BUILD.bazel\n    // after the first run, and verifying that some changed values are preserved\n    // (and some are not).\n    Path tempDirPath = getTemporaryDirectory();\n\n    // I'm lazy, so let's just \"cp -r\" stuff.\n    Path fixturesPath = Paths.get(PATH_PREFIX, SRC_DIR);\n    new ProcessBuilder(new String[] {\"cp\", \"-r\", fixturesPath.toString(), tempDirPath.toString()})\n        .start()\n        .waitFor();\n\n    String buildozerPath = getBuildozerPath();\n    Path copiedGoogleapis = Paths.get(tempDirPath.toString(), \"googleapis\");\n    ArgsParser args =\n        new ArgsParser(new String[] {\"--buildozer=\" + buildozerPath, \"--src=\" + copiedGoogleapis});\n    new BuildFileGenerator()\n        .generateBuildFiles(args.createApisVisitor(null, tempDirPath.toString()));\n\n    Path fileBodyPathPrefix =\n        Paths.get(copiedGoogleapis.toString(), \"google\", \"example\", \"library\");\n    Path gapicBuildFilePath = Paths.get(fileBodyPathPrefix.toString(), \"v1\", \"BUILD.bazel\");\n    String rawBuildFilePath = Paths.get(fileBodyPathPrefix.toString(), \"BUILD.bazel\").toString();\n\n    Assert.assertEquals(\n        ApisVisitor.readFile(gapicBuildFilePath.toString() + \".baseline\"),\n        ApisVisitor.readFile(gapicBuildFilePath.toString()));\n    Assert.assertEquals(\n        ApisVisitor.readFile(rawBuildFilePath + \".baseline\"),\n        ApisVisitor.readFile(rawBuildFilePath));\n\n    // Now change some values in google/example/library/v1/BUILD.bazel\n    Buildozer.setBinaryPath(buildozerPath);\n    Buildozer buildozer = Buildozer.getInstance();\n    // The following values should be preserved:\n    buildozer.batchSetAttribute(\n        gapicBuildFilePath, \"library_nodejs_gapic\", \"package_name\", \"@google-cloud/library\");\n    buildozer.batchRemoveAttribute(\n        gapicBuildFilePath, \"library_nodejs_gapic\", \"extra_protoc_parameters\");\n    buildozer.batchAddAttribute(\n        gapicBuildFilePath, \"library_nodejs_gapic\", \"extra_protoc_parameters\", \"param1\");\n    buildozer.batchAddAttribute(\n        gapicBuildFilePath, \"library_nodejs_gapic\", \"extra_protoc_parameters\", \"param2\");\n    buildozer.batchSetAttribute(\n        gapicBuildFilePath,\n        \"google-cloud-example-library-v1-csharp\",\n        \"name\",\n        \"renamed_csharp_rule\");\n    buildozer.batchSetAttribute(\n        gapicBuildFilePath, \"google-cloud-example-library-v1-java\", \"name\", \"renamed_java_rule\");\n\n    // The following values should NOT be preserved:\n    buildozer.batchSetAttribute(\n        gapicBuildFilePath,\n        \"library_nodejs_gapic\",\n        \"grpc_service_config\",\n        \"fake_grpc_service_config\");\n\n    buildozer.commit();\n\n    // Run the generator again\n    new BuildFileGenerator()\n        .generateBuildFiles(args.createApisVisitor(null, tempDirPath.toString()));\n\n    // Check that values are preserved\n    Assert.assertEquals(\n        \"@google-cloud/library\",\n        buildozer.getAttribute(gapicBuildFilePath, \"library_nodejs_gapic\", \"package_name\"));\n    Assert.assertEquals(\n        \"[param1 param2]\",\n        buildozer.getAttribute(\n            gapicBuildFilePath, \"library_nodejs_gapic\", \"extra_protoc_parameters\"));\n    Assert.assertEquals(\n        \"renamed_csharp_rule\",\n        buildozer.getAttribute(gapicBuildFilePath, \"%csharp_gapic_assembly_pkg\", \"name\"));\n    Assert.assertEquals(\n        \"renamed_java_rule\",\n        buildozer.getAttribute(gapicBuildFilePath, \"%java_gapic_assembly_gradle_pkg\", \"name\"));\n    // Check that grpc_service_config value is not preserved:\n    Assert.assertEquals(\n        \"library_example_grpc_service_config.json\",\n        buildozer.getAttribute(gapicBuildFilePath, \"library_nodejs_gapic\", \"grpc_service_config\"));\n\n    // Now run with overwrite and verify it actually ignores all the changes\n    ArgsParser argsOverwrite =\n        new ArgsParser(\n            new String[] {\n              \"--overwrite\", \"--buildozer=\" + buildozerPath, \"--src=\" + copiedGoogleapis\n            });\n    new BuildFileGenerator()\n        .generateBuildFiles(argsOverwrite.createApisVisitor(null, tempDirPath.toString()));\n    Assert.assertEquals(\n        ApisVisitor.readFile(gapicBuildFilePath.toString() + \".baseline\"),\n        ApisVisitor.readFile(gapicBuildFilePath.toString()));\n    Assert.assertEquals(\n        ApisVisitor.readFile(rawBuildFilePath + \".baseline\"),\n        ApisVisitor.readFile(rawBuildFilePath));\n  }\n\n}", "prediction": "    BuildFileGenerator.generateBuildFiles(new ApisVisitor(SRC_DIR, PATH_PREFIX));\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "56582318_18", "part": [1, 1], "seq": [1, 1], "prompt": "class BufferComputing {\n\n  public static ILineString buildHalfOffsetLine(Side side, ILineString line,\n      double distance) {\n    IPolygon offsetBuffer = buildHalfOffsetBuffer(side, line, distance);\n    IDirectPositionList pts = offsetBuffer.coord();\n\n    for (IDirectPosition pt : line.coord())\n      pts.remove(pt);\n    // then remove the last point of the polygon\n    pts.remove(pts.size() - 1);\n\n    return new GM_LineString(pts);\n\n  }\n\n  public static IPolygon buildLineHalfBuffer(ILineString line, double distance,\n      Side side);\n  public static IPolygon buildSegmentHalfBuffer(ILineSegment line,\n      double distance, Side side);\n  public static HashMap<IDirectPosition, Integer> getEndingPtsOfRoundPart(\n      IDirectPosition point, IRing buffer, double distance);\n  public static int getSideEndingPtsOfRoundPart(Side side, boolean start,\n      IDirectPosition point, IRing buffer, double distance);\n  public static IPolygon buildHalfOffsetBuffer(Side side, ILineString line,\n      double distance);\n\n}\n\nclass BufferComputingTest {\n\n  @Test\n  public void testBuildHalfOffsetLine() {\n", "reference": "    IDirectPosition p1 = new DirectPosition(0.0, 0.0);\n    IDirectPosition p2 = new DirectPosition(10.0, 0.0);\n    IDirectPosition p3 = new DirectPosition(20.0, 0.0);\n    IDirectPosition p4 = new DirectPosition(20.0, 10.0);\n    IDirectPosition p6 = new DirectPosition(0.0, 5.0);\n    IDirectPosition p7 = new DirectPosition(10.0, 5.0);\n    IDirectPosition p8 = new DirectPosition(20.0, 5.0);\n    IDirectPosition p9 = new DirectPosition(0.0, 5.0);\n    IDirectPosition p10 = new DirectPosition(10.0, 5.0);\n    IDirectPosition p11 = new DirectPosition(15.0, 5.0);\n    IDirectPosition p12 = new DirectPosition(15.0, 10.0);\n    IDirectPositionList list1 = new DirectPositionList();\n    IDirectPositionList list2 = new DirectPositionList();\n    IDirectPositionList list3 = new DirectPositionList();\n    IDirectPositionList list4 = new DirectPositionList();\n    list1.add(p1);\n    list1.add(p2);\n    list1.add(p3);\n    ILineString line1 = new GM_LineString(list1);\n    list2.add(p6);\n    list2.add(p7);\n    list2.add(p8);\n    ILineString line2 = new GM_LineString(list2);\n    Assert.assertTrue(line2.equals(BufferComputing.buildHalfOffsetLine(\n        Side.LEFT, line1, 5.0)));\n    Assert.assertTrue(line1.equals(BufferComputing.buildHalfOffsetLine(\n        Side.RIGHT, line2, 5.0)));\n    list3.add(p1);\n    list3.add(p2);\n    list3.add(p3);\n    list3.add(p4);\n    ILineString line3 = new GM_LineString(list3);\n    list4.add(p9);\n    list4.add(p10);\n    list4.add(p11);\n    list4.add(p12);\n    ILineString line4 = new GM_LineString(list4);\n    Assert.assertTrue(line4.equals((IGeometry) BufferComputing\n        .buildHalfOffsetLine(Side.LEFT, line3, 5.0)));\n    IDirectPositionList list5 = new DirectPositionList();\n    list5.add(new DirectPosition(0.0, 10.0));\n    list5.add(new DirectPosition(20.0, 10.0));\n    list5.add(new DirectPosition(20.0, 0.0));\n    ILineString line5 = new GM_LineString(list5);\n    IDirectPositionList list6 = new DirectPositionList();\n    list6.add(new DirectPosition(0.0, 5.0));\n    list6.add(new DirectPosition(15.0, 5.0));\n    list6.add(new DirectPosition(15.0, 0.0));\n    ILineString line6 = new GM_LineString(list6);\n    Assert.assertTrue(line6.equals(BufferComputing.buildHalfOffsetLine(\n        Side.RIGHT, line5, 5.0)));\n\n  }\n\n}", "prediction": "    ILineString line = new GM_LineString(new GM_Coord(1, 1), new GM_Coord(2, 2));\n    ILineString halfOffsetLine = BufferComputing.buildHalfOffsetLine(Side.LEFT,\n        line, 1);\n    assertEquals(2, halfOffsetLine.coord().size());\n    assertEquals(new GM_Coord(1, 1), halfOffsetLine.coord().get(0));\n    assertEquals(new GM_Coord(1, 1), halfOffsetLine.coord().get(1));\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "56585217_5", "part": [1, 1], "seq": [1, 1], "prompt": "class UserServiceImpl implements UserService {\n\n    @Transactional(readOnly = true)\n    @Override\n    public User authenticate(String email, String password) throws UserNotFoundException, PasswordNotMatchedException {\n        User user = findByEmail(email);\n        if (user == null) {\n            throw new UserNotFoundException(\"\u672a\u627e\u5230\u90ae\u7bb1\u4e3a [\" + email + \"] \u7684\u7528\u6237\");\n        }\n\n        String encPassword = DigestUtils.md5Hex(password);\n        if (!encPassword.equalsIgnoreCase(user.getPassword())) {\n            throw new PasswordNotMatchedException(\"\u7528\u6237 [\" + email + \"] \u8f93\u5165\u7684\u5bc6\u7801\u9519\u8bef\");\n        }\n        return user;\n    }\n\n    @Override public void save(User user);\n    @Override public void save(User user, int[] appIds);\n    @Override public void update(User user);\n    @Override public void updatePassword(int id, String oldPassword, String newPassword);\n    @Override public void update(User user, int[] appIds);\n    @Override public void deleteById(int id);\n    @Transactional(readOnly = true) @Override public User findById(int id);\n    @Transactional(readOnly = true) @Override public User findByEmail(String email);\n    @Transactional(readOnly = true) @Override public int[] findUserAppIds(int id);\n    @Override public List<User> findOrdinaryUsers();\n    @Transactional(readOnly = true) @Override public List<User> findAll();\n    private void saveUserApps(int userId, int[] appIds);\n\n    @Autowired\n    private UserService userService;\n\n}\n\nclass UserServiceImplTest  {\n\n    @Autowired\n    private UserService userService;\n\n    @Test(dataProvider = \"dataUser\", expectedExceptions = UserNotFoundException.class)\n    public void testAuthenticate(User user) {\n", "reference": "        userService.save(user);\n\n        userService.authenticate(\"kevinzzzzzzzzzzz999999****@weghst.com\", \"88888888\");\n    }\n\n}", "prediction": "        userService.authenticate(user.getEmail(), user.getPassword());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "58314354_0", "part": [1, 1], "seq": [1, 1], "prompt": "class IgnoreMissingValuesConverter implements ITypeConverter<Float> {\n\n    @Override\n    public Float convert(final String s) {\n\n        if(StringUtils.isNullOrWhiteSpace(s)) {\n            return null;\n        }\n\n        boolean isMissingValue = missingValueRepresentation\n                .stream()\n                .anyMatch(x -> x.equals(s));\n\n        if(isMissingValue) {\n            return null;\n        }\n\n        return Float.parseFloat(s);\n    }\n\n    public  IgnoreMissingValuesConverter(String... missingValueRepresentation);\n    public  IgnoreMissingValuesConverter(List<String> missingValueRepresentation);\n\n    @Override public Type getTargetType();\n\n}\n\nclass IgnoreMissingValuesConverterTest {\n\n    @Test\n    public void returns_null_if_value_is_missing() throws Exception {\n", "reference": "\n        IgnoreMissingValuesConverter converter = new IgnoreMissingValuesConverter(\"M\", \"m\");\n\n        Assert.assertEquals(null, converter.convert(\"\"));\n        Assert.assertEquals(null, converter.convert(\"M\"));\n        Assert.assertEquals(null, converter.convert(\"m\"));\n\n        Assert.assertEquals(1.0f, converter.convert(\"1.0\"), 1e-3);\n    }\n\n}", "prediction": "        IgnoreMissingValuesConverter converter = new IgnoreMissingValuesConverter(\"NA\", \"N/A\");\n\n        assertThat(converter.convert(\"NA\"), is(nullValue()));\n        assertThat(converter.convert(\"N/A\"), is(nullValue()));\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "58628767_0", "part": [1, 1], "seq": [1, 1], "prompt": "class ROdps {\n\n  public List<DataFrameItem> getTables(String projectName, String pattern) throws ROdpsException {\n    DataFrameItem<String> owner = new DataFrameItem<String>(\"owner\", \"string\");\n    DataFrameItem<String> tableName = new DataFrameItem<String>(\"table_name\", \"string\");\n    List<DataFrameItem> data = new ArrayList<DataFrameItem>();\n    data.add(owner);\n    data.add(tableName);\n\n    TableFilter filter = new TableFilter();\n    filter.setName(pattern);\n\n    for (Iterator<Table> it = odps.tables().iterator(projectName, filter); it.hasNext();) {\n      Table tb = it.next();\n      owner.getData().add(tb.getOwner());\n      tableName.getData().add(tb.getName());\n    }\n    return data;\n  }\n\n  public  ROdps(String projectName, String accessID, String accessKey, String endPoint,\n      String dtEndpoint, String logviewHost, String log4j_properties);\n\n  public void setBizId(String s);\n  public void set(String key, String value);\n  public void unset(String key);\n  public void writeTableFromDT(String projectName, String tableName, String partition,\n      String dataFilePathName, String columnDelimiter, String rowDelimiter, long recordCount,\n      int threadNumber);\n  public List<List<String>> loadTableFromDT(String projectName, String tableName, String partition,\n      String tempFile, String colDelimiter, String rowDelimiter, int limit, int threadNumber);\n  public boolean useProject(String projectName);\n  private Map<String, Schema> createSchema(String schemaJson, String type);\n  private Project getProjectObject(String projectName);\n  public String getProjectName(String projectName);\n  public long getTableSize(String projectName, String tableName, String partition);\n  public List<DataFrameItem> describeTable(String projectName, String tableName, String partition);\n  private String formatDateTime(Date date);\n  private DataFrameItem createSingleValueFrame(String name, String type, Object obj);\n  public boolean dropTable(String projectName, String tableName);\n  public boolean isTableExist(String projectName, String tableName, String partition);\n  public String getTableSchemaJson(String projectName, String tableName);\n  public int getIndexFromColName(String colName, String tableSchemaJson);\n  public List<String> runSqlTask(String sql);\n  private String getTableName(String projectName, String tableName);\n  public static String formatPartition(String part, String valueDim, String fieldDim);\n  private static LinkedHashMap<String, String> parsePartition(String part);\n  private static String partitionMap2String(Map<String, String> sepc, String valueDim,\n      String fieldDim);\n  public boolean setLogPath(String log_path);\n\n  final static String table;\n  static String file;\n  static ROdps rodps;\n\n}\n\nclass ROdpsTest  {\n\n  final static String table;\n  static String file;\n  static ROdps rodps;\n\n  @Test\n  public void testGetTablesList() throws ROdpsException, OdpsException {\n", "reference": "    List<DataFrameItem> ret = rodps.getTables(null, null);\n\n    for (DataFrameItem d : ret) {\n      List res = d.getData();\n      System.out.println(res);\n    }\n\n    assertNotNull(ret);\n    assertEquals(2, ret.size());\n    System.out.println(\"testN1GetTableList:\" + ret);\n  }\n\n}", "prediction": "    List<DataFrameItem> data = rodps.getTables(\"odps_test\", \"test_%\");\n    Assert.assertEquals(data.size(), 1);\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "58892507_4", "part": [1, 1], "seq": [1, 1], "prompt": "class CoffeeHouse extends AbstractLoggingActor {\n\n    public static Props props(int caffeineLimit){\n        return Props.create(CoffeeHouse.class, () -> new CoffeeHouse(caffeineLimit));\n    }\n\n    public  CoffeeHouse(int caffeineLimit);\n\n    @Override public SupervisorStrategy supervisorStrategy();\n    private boolean coffeeApproved(ApproveCoffee approveCoffee);\n    private void addGuestToBookkeeper(ActorRef guest);\n    private void removeGuestFromBookkeeper(ActorRef guest);\n    protected ActorRef createBarista();\n    protected ActorRef createWaiter();\n    protected ActorRef createGuest(Coffee favoriteCoffee, int caffeineLimit);\n\n}\n\nclass CoffeeHouseTest extends AbstractLoggingActor {\n\n  @Test\n  public void shouldCreateChildActorCalledBaristaWhenCreated() {\n", "reference": "    new JavaTestKit(system) {{\n      system.actorOf(CoffeeHouse.props(Integer.MAX_VALUE), \"create-barista\");\n      expectActor(this, \"/user/create-barista/waiter\");\n    }};\n  }\n\n}", "prediction": "    new CoffeeHouse(100);\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "59021106_12", "part": [1, 1], "seq": [1, 1], "prompt": "class Valor {\n\n    public final String getString() {\n        return string;\n    }\n\n    public  Valor(final String valor);\n    public  Valor(final float valor);\n    public  Valor(final boolean valor);\n    public  Valor(final LocalDate umaData);\n\n    public final boolean getBoolean();\n    public final float getReal();\n    public final LocalDate getData();\n    public static Valor dataFromString(final String data);\n    public byte getTipo();\n    @Override public String toString();\n    @Override public boolean equals(Object o);\n    @Override public int hashCode();\n\n}\n\nclass ValorTest {\n\n    @Test\n    public void umValorString() {\n", "reference": "        final String sequencia = \"sequ\u00eancia de caracteres\";\n        Valor verdadeiro = new Valor(sequencia);\n        assertEquals(sequencia, verdadeiro.getString());\n    }\n\n}", "prediction": "        Valor valor = new Valor(\"teste\");\n        assertEquals(\"teste\", valor.getString());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "59801168_4", "part": [1, 1], "seq": [1, 1], "prompt": "class NotificationCenter {\n\n    public static void notify(EventCatalog event, ResponseWrapper response) {\n        for (TaskExecutor tasker : NotificationCenter.getSubscriberList(event)) {\n            switch (response.getType()) {\n                case SUCCESS:\n                    tasker.executeOnSuccessTask(response.getPayload());\n                    break;\n                case ERROR:\n                    tasker.executeOnErrorTask(response.getPayload());\n                    break;\n            }\n        }\n    }\n\n    private static Set<TaskExecutor> getSubscriberList(EventCatalog event);\n\n}\n\nclass TestNotificationCenter {\n\n    @Test\n    public void testNotifySuccess () {\n", "reference": "        ResponseWrapper response = Mockito.mock(ResponseWrapper.class);\n        Mockito.when(response.getType()).thenReturn(ResponseType.SUCCESS);\n        NotificationCenter.notify(EventCatalog.e0000, response);\n    }\n\n}", "prediction": "        ResponseWrapper response = new ResponseWrapper(ResponseWrapper.ResponseType.SUCCESS, \"\");\n        NotificationCenter.notify(EventCatalog.TEST_EVENT, response);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "59952554_6", "part": [1, 1], "seq": [1, 1], "prompt": "class CreditCardTransaction {\n\n    public boolean isInWhiteList(String cardBin) {\n        return isWhiteListBinsAvailable() && creditCard.getWhitelistBins().contains(cardBin);\n    }\n\n    public  CreditCardTransaction();\n\n    public void setProperties(CreditCard creditCard, ArrayList<BankBinsResponse> bankBins);\n    private void init();\n    public boolean isWhiteListBinsAvailable();\n    public boolean isBlackListBinsAvailable();\n    public void setBlackListBinsAvailable(boolean blackListBinsAvailable);\n    public boolean isInstallmentAvailable();\n    public boolean isBankBinsAvailable();\n    public void setBankBins(ArrayList<BankBinsResponse> bankBins);\n    public ArrayList<Integer> getInstallmentTerms(String cardBin);\n    public String getBankByBin(String cardBin);\n    public String getBankByCardNumber(String cardNumber);\n    public boolean isMandiriCardDebit(String cardBin);\n    private BankBinsResponse getMandiriDebitResponse();\n    private String findBankByCardBin(BankBinsResponse savedBankBin, String cardBin);\n    private String findBankByCardNumber(BankBinsResponse savedBankBin, String cardNumber);\n    public Integer getInstallmentTerm(int currentPosition);\n    public void setInstallment(int termPosition);\n    public boolean isInstallmentValid();\n    public void setInstallmentAvailableStatus(boolean installmentStatus);\n    public int getInstallmentTermSelected();\n    public String getInstallmentBankSelected();\n    public void setBankPointStatus(boolean bniPointActivated);\n    public void setBankPoint(BanksPointResponse response, String bankType);\n    public String getBankName();\n    public boolean isBankPointEnabled();\n    public boolean isBankPointValid();\n    public float getBankPointRedeemed();\n    public void setBankPointRedeemed(float pointRedeemed);\n    public boolean checkCardBinValidity(String cardNumber);\n    private boolean isCardBinValid(String cardNumber);\n    private boolean isWhitelistBinContainCardNumber(String cardNumber);\n    public boolean isBlacklistContainCardNumber(String cardNumber);\n    public boolean isCardBinBlocked(String cardNumber);\n    public void setSelectedPromo(Promo seletedPromo);\n    public Promo getSelectedPromo();\n    public boolean isSelectedPromoAvailable();\n    public boolean isInstallmentOptionRequired();\n\n    private static final String BIN_VALID;\n    private static final String BIN_INVALID;\n    private static final String BANK_MANDIRI;\n    private static final String MANDIRI_BIN;\n    private static final String BANK_BNI;\n    private static final String BANK_OFFLINE;\n    private CreditCardTransaction cardTransaction;\n    private ArrayList<String> bankBins;\n    private CreditCard card;\n    private CreditCardInstallment cardInstallment;\n    private Installment installment;\n    private Map<String, ArrayList<Integer>> sampleTerms;\n\n}\n\nclass CreditCardTransactionTest {\n\n    private static final String BIN_VALID;\n    private static final String BIN_INVALID;\n    private static final String BANK_MANDIRI;\n    private static final String MANDIRI_BIN;\n    private static final String BANK_BNI;\n    private static final String BANK_OFFLINE;\n    private CreditCardTransaction cardTransaction;\n    private ArrayList<String> bankBins;\n    private CreditCard card;\n    private CreditCardInstallment cardInstallment;\n    private Installment installment;\n    private Map<String, ArrayList<Integer>> sampleTerms;\n\n    @Test\n    public void isInWhitlistbins_whenInvalid() {\n", "reference": "        assertFalse(cardTransaction.isInWhiteList(BIN_INVALID));\n    }\n\n}", "prediction": "        assertFalse(cardTransaction.isInWhiteList(BIN_INVALID));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "59970637_16", "part": [1, 1], "seq": [1, 1], "prompt": "class LocalOntology implements Ontology {\n\n  public Ontology getInstance() {\n    if (ontology == null) {\n      ontology = new LocalOntology();\n    }\n    return ontology;\n  }\n\n  public  LocalOntology();\n\n  @Override public void load();\n  @Override public void load(String[] urls);\n  private void load(Object m, String url);\n  public OntologyParser getParser();\n  public static OntModel getModel();\n  public List<String> getLoadedOntologyResources();\n  @Override public void merge(Ontology o);\n  @Override public Iterator<String> subclasses(String entitySearchTerm);\n  @Override public Iterator synonyms(String queryKeyPhrase);\n  public void addSearchTerm(String label, OntResource resource);\n  public Map<OntResource, String> retrieve(String label);\n  protected static void renderHierarchy(PrintStream out, OntClass cls, List<Object> occurs, int depth);\n  public static void renderClassDescription(PrintStream out, OntClass c, int depth);\n  protected static void renderRestriction(PrintStream out, Restriction r);\n  protected static void renderURI(PrintStream out, PrefixMapping prefixes, String uri);\n  protected static void renderAnonymous(PrintStream out, Resource anon, String name);\n  protected static void indent(PrintStream out, int depth);\n\n  private LocalOntology lOnt;\n\n}\n\nclass TestLocalOntology {\n\n  private LocalOntology lOnt;\n\n  @Test\n  public final void testGetInstance() {\n", "reference": "    assertSame(\"Ontology instance should be of type LocalOntology\", LocalOntology.class, lOnt.getInstance().getClass());\n  }\n\n}", "prediction": "    Ontology ont = lOnt.getInstance();\n    assertNotNull(ont);\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "59995075_0", "part": [1, 1], "seq": [1, 1], "prompt": "class Step6GraphTransitivityCleaner {\n\n    public static Set<Set<String>> mergeClusters(Set<Set<String>> equalClusters)\n    {\n        // create a new undirected graph\n        Graph graph = new DefaultGraph(\"CC Test\");\n        graph.setAutoCreate(true);\n        graph.setStrict(false);\n\n        // add all \"edges\"; for each pair from each cluster\n        for (Set<String> cluster : equalClusters) {\n            List<String> clusterList = new ArrayList<>(cluster);\n\n            for (int i = 0; i < clusterList.size(); i++) {\n                for (int j = i + 1; j < clusterList.size(); j++) {\n                    // edge name\n                    String iName = clusterList.get(i);\n                    String jName = clusterList.get(j);\n\n                    List<String> names = Arrays.asList(iName, jName);\n                    Collections.sort(names);\n                    String edgeName = StringUtils.join(names, \"_\");\n\n                    graph.addEdge(edgeName, iName, jName);\n                }\n            }\n        }\n\n        // compute connected components\n        ConnectedComponents cc = new ConnectedComponents();\n        cc.init(graph);\n\n        Set<Set<String>> result = new HashSet<>();\n\n        cc.setCountAttribute(\"cluster\");\n        cc.compute();\n\n        //        System.out.println(cc.getConnectedComponentsCount());\n\n        // re-create clusters from all connected components\n        for (ConnectedComponents.ConnectedComponent component : cc) {\n            Set<String> cluster = new HashSet<>();\n            for (Node n : component) {\n                cluster.add(n.getId());\n            }\n            result.add(cluster);\n        }\n\n        //        System.out.println(result);\n\n        return result;\n    }\n\n    public  Step6GraphTransitivityCleaner(ArgumentPairListSorter argumentPairListSorter,\n            boolean removeEqualEdgesParam);\n\n    public GraphCleaningResults processSingleFile(File file, File outputDir, String prefix,\n            Boolean collectGeneratedArgumentPairs);\n    public static Graph cleanCopyGraph(Graph graph);\n    private static DescriptiveStatistics computeTransitivityScores(Graph graph);\n    private static List<List<Object>> findCyclesInGraph(Graph graph);\n    protected static Set<Set<String>> buildEquivalencyClusters(\n            List<AnnotatedArgumentPair> argumentPairs);\n    public static Graph buildGraphFromArgumentPairs(List<AnnotatedArgumentPair> argumentPairs);\n    public static double computeEdgeWeight(AnnotatedArgumentPair annotatedArgumentPair,\n            double lambda);\n    @SuppressWarnings(\"unchecked\") public static void collectResults(String[] args);\n    @SuppressWarnings(\"unchecked\") public static void printResultStatistics(File xmlFile);\n    public static SortedMap<String, DescriptiveStatistics> collectStatisticsOverGraphCleaningResults(\n            Collection<GraphCleaningResults> results);\n    @SuppressWarnings(\"unchecked\") public static void main(String[] args);\n\n}\n\nclass Step6GraphTransitivityCleanerTest {\n\n    @Test\n    public void testMergeClusters()\n            throws Exception\n    {\n", "reference": "        Set<Set<String>> c1 = new HashSet<>();\n        c1.add(new HashSet<>(Arrays.asList(\"1\", \"2\")));\n        c1.add(new HashSet<>(Arrays.asList(\"3\", \"4\")));\n        Set<Set<String>> merged1 = Step6GraphTransitivityCleaner.mergeClusters(c1);\n        assertEquals(2, merged1.size());\n\n        Set<Set<String>> c2 = new HashSet<>();\n        c2.add(new HashSet<>(Arrays.asList(\"1\", \"2\")));\n        c2.add(new HashSet<>(Arrays.asList(\"3\", \"4\")));\n        c2.add(new HashSet<>(Arrays.asList(\"5\", \"4\")));\n\n        Set<Set<String>> merged2 = Step6GraphTransitivityCleaner.mergeClusters(c2);\n        assertEquals(2, merged2.size());\n\n        Set<Set<String>> c3 = new HashSet<>();\n        c3.add(new HashSet<>(Arrays.asList(\"1\", \"5\")));\n        c3.add(new HashSet<>(Arrays.asList(\"3\", \"4\")));\n        c3.add(new HashSet<>(Arrays.asList(\"5\", \"4\")));\n\n        Set<Set<String>> merged3 = Step6GraphTransitivityCleaner.mergeClusters(c3);\n        assertEquals(1, merged3.size());\n    }\n\n}", "prediction": "        Set<Set<String>> clusters = new HashSet<>();\n        clusters.add(new HashSet<>(Arrays.asList(\"a\", \"b\", \"c\")));\n        clusters.add(new HashSet<>(Arrays.asList(\"d\", \"e\", \"f\")));\n        clusters.add(new HashSet<>(Arrays.asList(\"g\", \"h\", \"i\")));\n\n        Set<Set<String>> result = Step6GraphTransitivityCleaner.mergeClusters(clusters);\n\n        assertEquals(2, result.size());\n        assertTrue(result.contains(new HashSet<>(Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"))));\n        assertTrue(result.contains(new HashSet<>(Arrays.asList(\"g\", \"h\", \"i\"))));\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "60802987_0", "part": [1, 1], "seq": [1, 1], "prompt": "class IcndbJoke {\n\n    public String getJoke() {\n        return value.getJoke();\n    }\n\n    public String getType();\n    public void setType(String type);\n    public Joke getValue();\n    public void setValue(Joke value);\n\n    private String jsonTxt;\n\n}\n\nclass IcndbJokeTest {\n\n    private String jsonTxt;\n\n    @Test\n    public void testGetJoke() throws Exception {\n", "reference": "        Gson gson = new Gson();\n        IcndbJoke icndbJoke = gson.fromJson(jsonTxt, IcndbJoke.class);\n        String correct = \"Xav Ducrohet writes code that optimizes itself.\";\n        assertNotNull(icndbJoke);\n        assertEquals(correct, icndbJoke.getJoke());\n    }\n\n}", "prediction": "        IcndbJoke joke = new IcndbJoke();\n        joke.setValue(new Joke());\n        joke.getValue().setJoke(\"test\");\n        assertEquals(\"test\", joke.getJoke());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "60940117_7", "part": [1, 1], "seq": [1, 1], "prompt": "class RedisScriptLoader {\n\n    Mono<StoredScript> storedScript() {\n        return Mono.defer(() -> {\n            Flux<String> source = this.storedScript.get();\n            return source.next().map(sha -> new StoredScript(sha, source));\n        });\n    }\n\n    public  RedisScriptLoader(RedisScriptingReactiveCommands<String, String> redisScriptingCommands, String scriptUri);\n    public  RedisScriptLoader(RedisScriptingReactiveCommands<String, String> redisScriptingCommands, String scriptUri, boolean eagerLoad);\n\n    @SuppressWarnings(\"PreferJavaTimeOverload\") private Flux<String> loadScript();\n    private String readScriptFile();\n\n    @RegisterExtension\n    static RedisStandaloneConnectionSetupExtension extension;\n\n}\n\nclass RedisScriptLoaderTest {\n\n    @RegisterExtension\n    static RedisStandaloneConnectionSetupExtension extension;\n\n    @Test\n    @DisplayName(\"should cache loaded sha\")\n    void shouldCache() {\n", "reference": "        RedisScriptLoader scriptLoader = new RedisScriptLoader(extension.getScriptingReactiveCommands(), \"hello-world.lua\");\n\n        assertThat(scriptLoader.storedScript().block(Duration.ofSeconds(5)).getSha()).isNotEmpty();\n\n        scriptFlush();\n\n        assertThat(scriptLoader.storedScript().block(Duration.ofSeconds(5)).getSha()).isNotEmpty();\n    }\n\n}", "prediction": "        RedisScriptLoader loader = new RedisScriptLoader(extension.getConnection().reactive(), \"classpath:script.lua\");\n        Mono<StoredScript> storedScript = loader.storedScript();\n        StepVerifier.create(storedScript)\n                .expectNextMatches(s -> s.getSha().equals(\"sha\"))\n                .expectComplete()\n                .verify();\n        StepVerifier.create(storedScript)\n                .expectNextMatches(s -> s.getSha().equals(\"sha\"))\n                .expectComplete()\n                .verify();\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "60958121_4", "part": [1, 1], "seq": [1, 1], "prompt": "class User {\n\n    public void login(final LoginInterface loginInterface) {\n        if (webService.isNetworkOffline()) {\n            loginInterface.onLoginFailed();\n            return;\n        }\n\n        Response response = new Response() {\n            @Override\n            public void onRequestCompleted(boolean isSuccess, String data) {\n                if (isSuccess) {\n                    loginInterface.onLoginSuccess();\n                } else {\n                    loginInterface.onLoginFailed();\n                }\n            }\n        };\n        webService.login(userId, password, response);\n    }\n\n    public  User(WebService webService, int userId, String password);\n\n    public void logout();\n    public void sendMessage(String message);\n    public void getMessages();\n\n    public static final int USER_ID;\n    public static final String PASSWORD;\n    @Rule\n    public MockitoRule mockitoRule;\n    @Mock\n    private WebService mockWebService;\n    @Mock\n    private LoginInterface mockLoginInterface;\n    @Captor\n    private ArgumentCaptor<Response> responseArgumentCaptor;\n\n}\n\nclass UserTest {\n\n    public static final int USER_ID;\n    public static final String PASSWORD;\n    @Rule\n    public MockitoRule mockitoRule;\n    @Mock\n    private WebService mockWebService;\n    @Mock\n    private LoginInterface mockLoginInterface;\n    @Captor\n    private ArgumentCaptor<Response> responseArgumentCaptor;\n\n    @Test\n    public void stubMethodAnswer() throws Exception {\n", "reference": "        User user = new User(mockWebService, USER_ID, PASSWORD);\n        when(mockWebService.isNetworkOffline()).then(new Answer<Boolean>() {\n            int index = 0;\n\n            @Override\n            public Boolean answer(InvocationOnMock invocation) throws Throwable {\n                return index++ % 2 == 0;\n            }\n        });\n\n        user.login(mockLoginInterface);\n        user.login(mockLoginInterface);\n        user.login(mockLoginInterface);\n\n        verify(mockWebService, times(1)).login(anyInt(), anyString(), any(Response.class));\n    }\n\n}", "prediction": "        when(mockWebService.isNetworkOffline()).thenReturn(true);\n\n        User user = new User(mockWebService, USER_ID, PASSWORD);\n        user.login(mockLoginInterface);\n\n        verify(mockLoginInterface).onLoginFailed();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "61158193_4", "part": [1, 1], "seq": [1, 1], "prompt": "class GenericDAO {\n\n    public void update(PK id, T model) {\n        try (Connection connection = connectionProvider.get()) {\n            Map<?, ?> map = MAPPER.map(model);\n            Map<String, ?> result = R.table(tableName).get(id).update(map).run(connection);\n\n            if (((Long) result.get(\"errors\")) > 0) {\n                throw new ReqlClientError(\"Failed to update model. %s\", ((String) result.get(\"first_error\")).split(\"\\n\")[0]);\n            }\n        }\n    }\n\n    public  GenericDAO(Provider<Connection> connection, Class<T> clazz, String tableName, String primaryKey);\n\n    protected void addIndex(boolean geo, String fields);\n    public void initTable();\n    public void create(T model);\n    public Optional<T> read(PK id);\n    public DAOIterator<T> read();\n    public DAOIterator<T> read(Function<Table, ReqlExpr> filter);\n    public void updateNonAtomic(PK id, T model);\n    public void delete(PK id);\n    public Observable<ChangeFeedElement<T>> changes();\n    @SuppressWarnings(\"unchecked\") public Observable<ChangeFeedElement<T>> changes(Function<Table, ReqlExpr> filter);\n    private boolean hasTable(Connection connection, String table);\n    private boolean hasIndex(Connection connection, String indexName);\n    private List indexFieldsToReQL(ReqlExpr row, String[] fields);\n    private ChangeFeedElement<T> mapChangeFeedElement(Map<?, Map<?, ?>> map);\n\n    private static RethinkDB r;\n    private GenericDAO<TestModel, String> dao;\n\n}\n\nclass GenericDAOTest {\n\n    private static RethinkDB r;\n    private GenericDAO<TestModel, String> dao;\n\n    @Test\n    public void update() {\n", "reference": "        TestModel model = new TestModel(\"1\");\n        dao.create(model);\n\n        model.sub = new TestModel.SubModel();\n        model.sub.name = \"test\";\n        dao.update(model.id, model);\n\n        assertThat(dao.read(\"1\").get().sub.name).isEqualTo(model.sub.name);\n    }\n\n}", "prediction": "        TestModel model = new TestModel();\n        model.setId(\"1\");\n        model.setName(\"test\");\n        dao.create(model);\n\n        model.setName(\"test2\");\n        dao.update(\"1\", model);\n\n        Optional<TestModel> read = dao.read(\"1\");\n        assertTrue(read.isPresent());\n        assertEquals(\"test2\", read.get().getName());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "61996222_33", "part": [1, 1], "seq": [1, 1], "prompt": "class AnswerAnalyzer implements Analyzer {\n\n\t@Override\n\tpublic Interpretation analyze(Interpretation interpretation) {\n\t\t\n\t\t// case pas object answer\n\t\tMap<SemanticRole, String> pas = interpretation.getPas();\n\t\tif(pas.containsKey(SemanticRole.PREDICATE)\n\t\t\t\t&& pas.containsKey(SemanticRole.LOCATION)){\n\t\t\tString pp = pas.get(SemanticRole.LOCATION);\n\t\t\tString pred = pas.get(SemanticRole.PREDICATE);\n\t\t\tif(Linguistics.tobe.contains(pred)){\n\t\t\t\tpred = \"\";\n\t\t\t} else {\n\t\t\t\tpred = pred + \" \";\n\t\t\t}\n\t\t\tif(pp.contains(\" \")){\n\t\t\t\tpp = pp.substring(pp.indexOf(\" \") + 1);\n\t\t\t}\n\t\t\tinterpretation.setObjAnswer(pp.toLowerCase());\n\t\t\tinterpretation.setPredAnswer(pred + pp.toLowerCase());\n\t\t\treturn interpretation;\n\n\t\t} else if(pas.containsKey(SemanticRole.PREDICATE)\n\t\t\t\t&& pas.containsKey(SemanticRole.PATIENT)){\n\t\t\tString pred = pas.get(SemanticRole.PREDICATE).toLowerCase();\n\t\t\tif(Linguistics.tobe.contains(pred)){\n\t\t\t\tpred = \"\";\n\t\t\t} else {\n\t\t\t\tpred = pred + \" \";\n\t\t\t}\n\t\t\tString pat = pas.get(SemanticRole.PATIENT).toLowerCase();\n\t\t\tinterpretation.setObjAnswer(pat);\n\t\t\tinterpretation.setPredAnswer(pred + pat);\n\t\t\treturn interpretation;\n\t\t}\n\t\t\n\t\t// check for last verb\n\t\tint verbIndex = -1;\n\t\tList<String> tokens = interpretation.getTokens();\n\t\tString[] pos = interpretation.getPosTags();\n\n\t\tif (pos != null) {\n\t\t\tfor(int i=0; i < pos.length; i++) {\n\t\t\t\tif(pos[i] != null && pos[i].startsWith(\"V\")) {\n\t\t\t\t\tverbIndex = i;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tlogger.warn(\"POSTAGS missing but AnswerAnalyzer is used!\");\n\t\t}\n\n//\t\tSystem.out.println(\"Verbindex=\"+verbIndex);\n\t\t\n\t\t// case one term answer\n        if (tokens != null && !tokens.isEmpty()) {\n            if(verbIndex == -1){\n                if (tokens.size() == 1) {\n                    interpretation.setObjAnswer(tokens.get(0));\n                    interpretation.setPredAnswer(tokens.get(0));\n                    return interpretation;\n                }\n            }\n\t\t\n            // case pas failed object answer\n            StringBuilder answer = new StringBuilder(\"\");\n            StringBuilder answerPred = new StringBuilder(\"\");\n            for(int i = verbIndex; i < tokens.size(); i++){\n                if(i != verbIndex){\n                    if(tokens.get(i) != null && !\"me\".equals(tokens.get(i).toLowerCase())){\n                        if(answer.length() > 0) answer.append(' ');\n                        if(Character.isLetterOrDigit(tokens.get(i).charAt(0))) answer.append(tokens.get(i).toLowerCase());\n                        if(answerPred.length()>0) answerPred.append(' ');\n                        if(Character.isLetterOrDigit(tokens.get(i).charAt(0))) answerPred.append(tokens.get(i).toLowerCase());\n                    }\n                } else if(verbIndex != -1 && !Linguistics.tobe.contains(tokens.get(i))){\n                    answerPred.append(tokens.get(i).toLowerCase());\n                }\n            }\n            interpretation.setObjAnswer(answer.toString());\n            interpretation.setPredAnswer(answerPred.toString());\n        } else {\n\t\t    logger.warn(\"TOKENS missing but AnswerAnalyzer is used!\");\n\t\t}\n\n\t\treturn interpretation;\n\t}\n\n\tprivate static final SimpleTokenizer tokenizer;\n\tprivate static final OpenNLPPPOSTagger pos;\n\tprivate static final OpenNLPParser parser;\n\tprivate static final AnswerAnalyzer answer;\n\n}\n\nclass AnswerAnalyzerTest {\n\n\tprivate static final SimpleTokenizer tokenizer;\n\tprivate static final OpenNLPPPOSTagger pos;\n\tprivate static final OpenNLPParser parser;\n\tprivate static final AnswerAnalyzer answer;\n\n\t@Test\n\tpublic void testOrigin() {\n", "reference": "\t\tassertEquals(\"netherlands\", analyze(\"Netherlands\"));\n\t\tassertEquals(\"india\", analyze(\"I am from India\"));\n\t\tassertEquals(\"germany\", analyze(\"I live in Germany\"));\n\t\tassertEquals(\"sweden\", analyze(\"My home country is Sweden\"));\n\t\tassertEquals(\"garching\", analyze(\"My home town is Garching\"));\n\t\tassertEquals(\"austria\", analyze(\"I was born in Austria\"));\n\t}\n\n}", "prediction": "\t\tInterpretation interpretation = new Interpretation();\n\t\tinterpretation.setTokens(tokenizer.tokenize(\"where is the origin of the word 'hello'?\"));\n\t\tinterpretation.setPosTags(pos.tag(interpretation.getTokens()));\n\t\tinterpretation.setParses(parser.parse(interpretation.getTokens(), interpretation.getPosTags()));\n\t\tinterpretation = answer.analyze(interpretation);\n\t\tassertEquals(\"origin\", interpretation.getObjAnswer());\n\t\tassertEquals(\"where is the origin of the word 'hello'?\", interpretation.getPredAnswer());\n\t}", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "62342369_64", "part": [1, 1], "seq": [1, 1], "prompt": "class CustomExpectedStepParser implements StepParser<ExpectedStep> {\n\n\tprivate ParseContext parse(String expression) {\n\t\tExpectedStepLexer lexer = new ExpectedStepLexer(new ANTLRInputStream(expression));\n\t\tExpectedStepParser parser = new ExpectedStepParser(new CommonTokenStream(lexer));\n\t\tparser.addErrorListener(new BaseErrorListener() {\n\t        @Override\n\t        public void syntaxError(Recognizer<?, ?> recognizer, Object offendingSymbol, int line, int charPositionInLine, String msg, RecognitionException e) {\n\t            throw new IllegalStateException(\"failed to parse at line \" + line + \" due to \" + msg, e);\n\t        }\n\t    });\n\t\treturn parser.parse();\n\t\t\n\t}\n\n\t@Override public int getParserScoreForStep(AbstractStep step);\n\t@Override public void parseStep(ParsingContext parsingContext, ExpectedStep step);\n\n}\n\nclass CustomExpectedStepParserTest  {\n\n\t@Test\n\tpublic void testMultipleSet() throws Exception {\n", "reference": "\t\tList<AbstractStep> steps = new ArrayList<>();\n\t\tsteps.add(step(\"Set a=\\\"b\\\"\\t c=\\\"d\\\"\"));\n\t\t\n\t\tList<AbstractArtefact> children = getChildren(parse(steps));\n\t\t\n\t\tSet set = (Set) children.get(0);\n\t\tAssert.assertEquals(\"a\",set.getKey().getValue());\n\t\tAssert.assertEquals(\"\\\"b\\\"\",set.getValue().getExpression());\n\t\t\n\t\tset = (Set) children.get(1);\n\t\tAssert.assertEquals(\"c\",set.getKey().getValue());\n\t\tAssert.assertEquals(\"\\\"d\\\"\",set.getValue().getExpression());\n\t}\n\n}", "prediction": "\n\t\tString expression = \"set a to 1, set b to 2\";\n\t\tParseContext parse = parse(expression);\n\t\tassertEquals(expression, parse.getExpression());\n\t\tassertEquals(2, parse.getSteps().size());\n\t\tassertEquals(\"set a to 1\", parse.getSteps().get(0).getExpression());\n\t\tassertEquals(\"set b to 2\", parse.getSteps().get(1).getExpression());\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "62700410_9", "part": [1, 1], "seq": [1, 1], "prompt": "class NativeImageLoader extends BaseImageLoader {\n\n    protected Mat centerCropIfNeeded(Mat img) {\n        int x = 0;\n        int y = 0;\n        int height = img.rows();\n        int width = img.cols();\n        int diff = Math.abs(width - height) / 2;\n\n        if (width > height) {\n            x = diff;\n            width = width - diff;\n        } else if (height > width) {\n            y = diff;\n            height = height - diff;\n        }\n        return img.apply(new Rect(x, y, width, height));\n    }\n\n    public  NativeImageLoader();\n    public  NativeImageLoader(int height, int width);\n    public  NativeImageLoader(int height, int width, int channels);\n    public  NativeImageLoader(int height, int width, int channels, boolean centerCropIfNeeded);\n    public  NativeImageLoader(int height, int width, int channels, ImageTransform imageTransform);\n    public  NativeImageLoader(int height, int width, int channels, MultiPageMode mode);\n    protected  NativeImageLoader(NativeImageLoader other);\n\n    @Override public String[] getAllowedFormats();\n    @Override public INDArray asRowVector(File f);\n    @Override public INDArray asRowVector(InputStream is);\n    public INDArray asRowVector(Object image);\n    public INDArray asRowVector(Frame image);\n    public INDArray asRowVector(Mat image);\n    static Mat convert(PIX pix);\n    @Override public INDArray asMatrix(File f);\n    @Override public INDArray asMatrix(InputStream is);\n    private Mat streamToMat(InputStream is);\n    @Override public Image asImageMatrix(File f);\n    @Override public Image asImageMatrix(InputStream is);\n    public INDArray asMatrix(Object image);\n    protected void fillNDArray(Mat image, INDArray ret);\n    public void asMatrixView(InputStream is, INDArray view);\n    public void asMatrixView(File f, INDArray view);\n    public void asMatrixView(Mat image, INDArray view);\n    public INDArray asMatrix(Frame image);\n    public INDArray asMatrix(Mat image);\n    protected INDArray transformImage(Mat image, INDArray ret);\n    protected Mat scalingIfNeed(Mat image);\n    protected Mat scalingIfNeed(Mat image, int dstHeight, int dstWidth);\n    public ImageWritable asWritable(File f);\n    public INDArray asMatrix(ImageWritable writable);\n    public Frame asFrame(INDArray array);\n    public Frame asFrame(INDArray array, int dataType);\n    public Mat asMat(INDArray array);\n    public Mat asMat(INDArray array, int dataType);\n    private INDArray asMatrix(BytePointer bytes, int length);\n\n    static final long seed;\n    static final Random rng;\n\n}\n\nclass TestNativeImageLoader {\n\n    static final long seed;\n    static final Random rng;\n\n    @Test\n    public void testCenterCropIfNeeded() throws Exception {\n", "reference": "        int w1 = 60, h1 = 110, ch1 = 1;\n        int w2 = 120, h2 = 70, ch2 = 3;\n\n        Mat img1 = makeRandomImage(h1, w1, ch1);\n        Mat img2 = makeRandomImage(h2, w2, ch2);\n\n        NativeImageLoader loader = new NativeImageLoader(h1, w1, ch1, true);\n\n        Mat cropped1 = loader.centerCropIfNeeded(img1);\n        assertEquals(85, cropped1.rows());\n        assertEquals(60, cropped1.cols());\n        assertEquals(img1.channels(), cropped1.channels());\n\n        Mat cropped2 = loader.centerCropIfNeeded(img2);\n        assertEquals(70, cropped2.rows());\n        assertEquals(95, cropped2.cols());\n        assertEquals(img2.channels(), cropped2.channels());\n    }\n\n}", "prediction": "        NativeImageLoader loader = new NativeImageLoader(28, 28, 1, true);\n        Mat img = loader.asMatrix(new File(\"src/test/resources/datavec-data-image/mnist/0/0_0.png\"));\n        assertEquals(28, img.rows());\n        assertEquals(28, img.cols());\n        img = loader.centerCropIfNeeded(img);\n        assertEquals(28, img.rows());\n        assertEquals(28, img.cols());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "63002081_0", "part": [1, 1], "seq": [1, 1], "prompt": "class Preconditions {\n\n  public static void notNull(Object parameter) {\n    if (parameter == null) {\n      throw new IllegalArgumentException(\"parameter cannot be null\");\n    }\n  }\n\n  private  Preconditions();\n\n}\n\nclass PreconditionsTest {\n\n  @Test\n  public void whenNonNullParameterPassed_thenNothingHappens() {\n", "reference": "    Preconditions.notNull(new Object());\n  }\n\n}", "prediction": "    Preconditions.notNull(\"parameter\");\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "64247174_4", "part": [1, 1], "seq": [1, 1], "prompt": "class PostMessage extends UseCase<MessageDto, Void, MessageRepository> {\n\n    @Inject\n    public PostMessage(MessageRepository repository,\n                       Messenger messenger,\n                       @Named(\"Thread\") Scheduler threadScheduler,\n                       @Named(\"PostExecution\") Scheduler postExecutionScheduler) {\n        super(repository, messenger, threadScheduler, postExecutionScheduler);\n    }\n\n    @Inject public  PostMessage(MessageRepository repository,\n                       Messenger messenger,\n                       @Named(\"Thread\") Scheduler threadScheduler,\n                       @Named(\"PostExecution\") Scheduler postExecutionScheduler);\n\n    @Override protected Observable<Void> buildObservable(MessageDto messageDto);\n\n    private final MessageDto testMessage;\n\n}\n\nclass PostMessageTest extends UseCase<MessageDto, Void, MessageRepository> {\n\n    private final MessageDto testMessage;\n\n    @Test\n    @Override\n    public void testBuildUseCaseObservable() {\n", "reference": "        testBuildUseCaseObservable(testMessage, new Action0() {\n            @Override\n            public void call() {\n                verify(mockRepository).postMessage(testMessage, mockMessenger);\n            }\n        });\n    }\n\n}", "prediction": "        TestSubscriber<Void> testSubscriber = new TestSubscriber<>();\n        TestSubscriber<MessageDto> testSubscriber2 = new TestSubscriber<>();\n        TestSubscriber<MessageDto> testSubscriber3 = new TestSubscriber<>();\n\n        Observable<MessageDto> observable = buildObservable(testMessage);\n        observable.subscribe(testSubscriber);\n\n        verify(repository).postMessage(testMessage);\n        testSubscriber.assertNoErrors();\n        testSubscriber.assertCompleted();\n        testSubscriber.assertNoValues();\n\n        observable.subscribe(testSubscriber2);\n        testSubscriber2.assertNoErrors();\n        testSubscriber2.assertCompleted();\n        testSubscriber2.assertValue(testMessage);\n\n        observable.subscribe(testSubscriber3);\n        testSubscriber3.assertNoErrors();\n        testSubscriber3.assertCompleted();\n        testSubscriber3.assertValue(testMessage);\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "64692993_5", "part": [1, 1], "seq": [1, 1], "prompt": "class Calculator {\n\n    public double mul(double firstOperand, double secondOperand) {\n        return firstOperand * secondOperand;\n    }\n\n    public double add(double firstOperand, double secondOperand);\n    public double sub(double firstOperand, double secondOperand);\n    public double div(double firstOperand, double secondOperand);\n    public double pow(double firstOperand, double secondOperand);\n\n    private Calculator mCalculator;\n\n}\n\nclass CalculatorTest {\n\n    private Calculator mCalculator;\n\n    @Test\n  public void mulTwoNumbersZero() {\n", "reference": "    double resultMul = mCalculator.mul(2d, 0d);\n    assertThat(resultMul, is(equalTo(0d)));\n\n    }\n\n}", "prediction": "    assertEquals(0, mCalculator.mul(0, 0), 0);\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "64733500_0", "part": [1, 1], "seq": [1, 1], "prompt": "class CloseableDriver implements AutoCloseable {\n\n    public Session newSession() {\n        return driver.session();\n    }\n\n    public  CloseableDriver(String uri, String user, String pwd);\n\n    @Override public void close();\n\n     CloseableDriver driver;\n\n}\n\nclass CloseableDriverTest {\n\n     CloseableDriver driver;\n\n    @Test\n    public void queryTest() throws Exception {\n", "reference": "        try (Session session = driver.newSession()) {\n            StatementResult result = session.run(\"MATCH (loan:Loan)-[:APPLY]-(person:Person)-[:OWN]-(appPhone:Phone)-[:CALL]-(callPhones:Phone) \" +\n                    \"where loan.loanId='12345' \" +\n                    \"return distinct loan,person,appPhone,callPhones\");\n\n            while (result.hasNext()) {\n                Record record = result.next();\n                Node loan = record.get(\"loan\").asNode();\n                Node person = record.get(\"person\").asNode();\n                Node appPhone = record.get(\"appPhone\").asNode();\n                Node callPhones = record.get(\"callPhones\").asNode();\n\n                System.out.println(loan.get(\"amount\").asDouble());\n                System.out.println(person.get(\"ssn\").asString());\n                System.out.println(appPhone.get(\"phoneNo\").asString());\n                System.out.println(callPhones.get(\"phoneNo\").asString());\n            }\n        }\n    }\n\n}", "prediction": "        try (Session session = driver.newSession()) {\n            session.run(\"CREATE (a:Person {name: 'A'})-[:KNOWS]->(b:Person {name: 'B'})\");\n            Result result = session.run(\"MATCH (a:Person)-[:KNOWS]->(b:Person) RETURN a.name, b.name\");\n            assertEquals(\"A\", result.single().get(\"a.name\").asString());\n            assertEquals(\"B\", result.single().get(\"b.name\").asString());\n        }\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "64865857_0", "part": [1, 1], "seq": [1, 1], "prompt": "class MacAddress {\n\n\tpublic static MacAddress broadcast() {\n\t\tif (broadcast == null) {\n\t\t\tbyte[] pole = new byte[6];\n\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\tpole[i] = (byte) 255;\n\t\t\t}\n\t\t\tbroadcast = new MacAddress(pole);\n\t\t}\n\t\treturn broadcast;\n\t}\n\n\tpublic  MacAddress(String address);\n\tpublic  MacAddress(String address, char delimiter);\n\tpublic  MacAddress(byte[] representation);\n\n\t@Override public String toString();\n\tpublic String getCiscoRepresentation();\n\tpublic byte [] getByteArray();\n\t@Override public boolean equals(Object obj);\n\t@Override public int hashCode();\n\tpublic boolean isLessOrEqualThan(MacAddress other);\n\tprivate boolean isByteLessThan(MacAddress other, int cisloBytu);\n\tpublic static boolean isBroadcast(MacAddress mac);\n\tpublic static MacAddress getRandomMac();\n\tprivate static byte[] stringToBytes(String adr, char delimiter);\n\tprivate static byte stringToByte(String s);\n\tprivate static String byteToString(byte bajt);\n\n}\n\nclass MacAddressTest {\n\n     @Test\n     public void testBroadcast() {\n", "reference": "         MacAddress mac;\n         String sm;\n\n         sm=\"ff:ff:ff:ff:ff:ff\";\n         mac = new MacAddress(sm);\n         assertTrue(MacAddress.isBroadcast(mac));\n\n         sm=\"1a:4c:05:49:ad:f9\";\n         mac = new MacAddress(sm);\n         assertFalse(MacAddress.isBroadcast(mac));\n     }\n\n}", "prediction": "\t\tMacAddress mac = MacAddress.broadcast();\n\t\tassertEquals(\"ff:ff:ff:ff:ff:ff\", mac.toString());\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "66055507_6", "part": [1, 1], "seq": [1, 1], "prompt": "class SimpleFactory {\n\n  @Updater\n  @Recycle\n  Simple simple(String appendix) throws IOException {\n    return new Simple(string, appendix);\n  }\n\n    SimpleFactory(String string);\n\n  private final SimpleFactory factory;\n  private final SimpleUpdaterFactory updaterFactory;\n\n}\n\nclass SimpleFactoryTest {\n\n  private final SimpleFactory factory;\n  private final SimpleUpdaterFactory updaterFactory;\n\n  @Test\n  public void simple() throws Exception {\n", "reference": "    SimpleFactory.Simple simple = factory.simple(\"b\");\n    SimpleFactoryBuilders.SimpleUpdater updater = updaterFactory.updater(simple);\n    SimpleFactory.Simple updatedSimple = updater\n        .appendix(\"c\")\n        .done();\n    assertThat(simple.concat(), is(\"ab\"));\n    assertThat(updatedSimple.concat(), is(\"ac\"));\n    // updater is recycled\n    assertTrue(updater\n        == updaterFactory.updater(factory.simple(\"x\")));\n  }\n\n}", "prediction": "    factory.simple(\"\");\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "66060256_0", "part": [1, 1], "seq": [1, 1], "prompt": "class Confetto {\n\n    protected static Long computeMillisToReachTarget(Float targetVelocity, float initialVelocity,\n            float acceleration) {\n        if (targetVelocity != null) {\n            if (acceleration != 0f) {\n                final long time = (long) ((targetVelocity - initialVelocity) / acceleration);\n                return time > 0 ? time : 0;\n            } else {\n                if (targetVelocity < initialVelocity) {\n                    return 0L;\n                } else {\n                    return null;\n                }\n            }\n        } else {\n            return null;\n        }\n    }\n\n    public void prepare(Rect bound);\n    private boolean doesLocationIntercept(float x, float y);\n    public boolean onTouchDown(MotionEvent event);\n    public void onTouchMove(MotionEvent event);\n    public void onTouchUp(MotionEvent event);\n    public abstract int getWidth();\n    public abstract int getHeight();\n    protected static long computeBound(float initialPos, float velocity, float acceleration,\n            Long targetTime, Float targetVelocity, int minBound, int maxBound);\n    public void reset();\n    protected void configurePaint(Paint paint);\n    public boolean applyUpdate(long passedTime);\n    private void computeDistance(float[] pair, long t, float xi, float vi, float ai, Long targetTime,\n                                 Float vTarget);\n    public void draw(Canvas canvas);\n    private void draw(Canvas canvas, float x, float y, float rotation, float percentageAnimated);\n    protected abstract void drawInternal(Canvas canvas, Matrix matrix, Paint paint, float x,\n            float y, float rotation, float percentAnimated);\n    public void setInitialDelay(long val);\n    public void setInitialX(float val);\n    public void setInitialY(float val);\n    public void setInitialVelocityX(float val);\n    public void setInitialVelocityY(float val);\n    public void setAccelerationX(float val);\n    public void setAccelerationY(float val);\n    public void setTargetVelocityX(Float val);\n    public void setTargetVelocityY(Float val);\n    public void setInitialRotation(float val);\n    public void setInitialRotationalVelocity(float val);\n    public void setRotationalAcceleration(float val);\n    public void setTargetRotationalVelocity(Float val);\n    public void setTTL(long val);\n    public void setFadeOut(Interpolator fadeOutInterpolator);\n\n}\n\nclass ConfettoTest {\n\n    @Test\n    public void test_computeMillisToReachTarget() {\n", "reference": "        Long time = Confetto.computeMillisToReachTarget(null, 0f, 0f);\n        assertNull(time);\n        time = Confetto.computeMillisToReachTarget(0f, 10f, 10f);\n        assertEquals(0, time.longValue());\n        time = Confetto.computeMillisToReachTarget(20f, 10f, 10f);\n        assertEquals(1, time.longValue());\n        time = Confetto.computeMillisToReachTarget(30f, 0f, 10f);\n        assertEquals(3, time.longValue());\n        time = Confetto.computeMillisToReachTarget(20f, 10f, 0f);\n        assertNull(time);\n    }\n\n}", "prediction": "        assertEquals(1000L, Confetto.computeMillisToReachTarget(100f, 0f, 0f));\n        assertEquals(1000L, Confetto.computeMillisToReachTarget(100f, 0f, 10f));\n        assertEquals(1000L, Confetto.computeMillisToReachTarget(100f, 0f, -10f));\n        assertEquals(1000L, Confetto.computeMillisToReachTarget(100f, 10f, 0f));\n        assertEquals(1000L, Confetto.computeMillisToReachTarget(100f, -10f, 0f));\n        assertEquals(1000L, Confetto.computeMillisToReachTarget(100f, 10f, 10f));\n        assertEquals(1000L, Confetto.computeMillisToReachTarget(100f, -10f, -10f));\n        assertEquals(1000L, Confetto.computeMillisToReachTarget(100f, 10f, -10f));\n        assertEquals(1000L, Confetto.computeMillisToReachTarget(100f, -10f, 10f));\n        assertEquals(1000L, Confetto.computeMillisToReachTarget(100f, 10f, 0f));\n        assertEquals(1000L, Confetto.computeMillisToReachTarget(100f, -10f, 0f));\n        assertEquals(1000L, Confetto.computeMillisToReachTarget(100f, 0f, 10f));\n        assertEquals(1000L, Confetto.computeMillisToReachTarget(100f, 0f, -10f));\n        assertEquals(1000L, Confetto.computeMillisToReachTarget(100f, 10f, 0f));\n        assertEquals(1000L, Confetto.computeMillisToReachTarget(100f, -10f, 0f));\n        assertEquals(1000L, Confetto.computeMillisToReachTarget(100f, 10f, 10f));\n        assertEquals(1000L, Confetto.computeMillisToReachTarget(100f, -10f, -10f));\n        assertEquals(1000L, Confetto.computeMillisToReachTarget(100f, 10f, -10f));\n        assertEquals(1000L, Confetto.computeMillisToReachTarget(100f, -10f, 10f));\n        assertEquals(1000L, Confetto.computeMillisToReachTarget(100f, 10f, 0f));\n        assertEquals(1000L, Confetto.computeMillisToReachTarget(100f, -10f, 0f));\n        assertEquals(1000L, Confetto.computeMillisToReachTarget(100f, 0f, 10f));\n        assertEquals(1000L, Confetto.computeMillisToReachTarget(100f, 0f, -10f));\n        assertEquals(1000L, Confetto.computeMillisToReachTarget(100f, 10f, 0f));\n        assertEquals(1000L, Confetto.computeMillisToReachTarget(100f, -10f, 0f));\n        assertEquals(1000L, Confetto.computeMillisToReachTarget(100f, 10f, 10f));\n        assertEquals(1000L, Confetto.computeMillisToReachTarget(100f, -10f, -10f));\n        assertEquals(1000L, Confetto.computeMillisToReachTarget(100f, 10f, -10f));\n        assertEquals(1000L, Confetto.computeMillisToReachTarget(100f, -10f, 10f));\n        assertEquals(1000L, Confetto.computeMillisToReachTarget(100f, 10f, 0f));\n        assertEquals(1000L, Confetto.computeMillisToReachTarget(100f, -10f, 0f));\n        assertEquals(1000L, Confetto.computeMillisToReachTarget(100f, 0f, 10f));\n        assertEquals(1000L, Confetto.computeMillisToReachTarget(100f, 0f, -10f));\n        assertEquals(1000L, Confetto.computeMillisToReachTarget(100f, 10f, 0f));\n        assertEquals(1000L, Confetto.computeMillisToReachTarget(100f, -10f, 0f));\n        assertEquals(1000L, Confetto.computeMillisToReachTarget(100f, 10f, 10f));\n        assertEquals(1000L, Confetto.computeMillisToReachTarget(100f, -10f, -10f));\n        assertEquals(1000L, Confetto.computeMillisToReachTarget(100f, 10f, -10f));\n        assertEquals(1000L, Confetto.computeMillisToReachTarget(100f, -10", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "66076162_4", "part": [1, 1], "seq": [1, 1], "prompt": "class ErrorMessageFactory {\n\n  public static String create(Context context, Exception exception) {\n    String errorMessage = context.getString(R.string.exception_generic);\n\n    if (exception instanceof NoInternetConnectionException) {\n      errorMessage = context.getString(R.string.exception_no_internet_connection);\n    } else if (exception instanceof NoResponseException) {\n      errorMessage = context.getString(R.string.exception_no_response);\n    } else if (exception instanceof InvalidServerException) {\n      errorMessage = context.getString(R.string.exception_invalid_server);\n    } else if (exception.getMessage() != null && !exception.getMessage().isEmpty()) {\n      errorMessage = exception.getMessage();\n    }\n\n    return errorMessage;\n  }\n\n  private  ErrorMessageFactory();\n\n  @Mock private Context context;\n\n}\n\nclass ErrorMessageFactoryTest {\n\n  @Mock private Context context;\n\n  @Test\n  public void shouldReturnDefaultErrorMessageForInvalidServerException() throws Exception {\n", "reference": "    when(context.getString(R.string.exception_invalid_server)).thenReturn(\n        \"Invalid Server Default Error Message\");\n    InvalidServerException invalidServerException = new InvalidServerException();\n\n    String errorMessage = ErrorMessageFactory.create(context, invalidServerException);\n\n    verify(context, times(1)).getString(R.string.exception_invalid_server);\n    assertThat(errorMessage, notNullValue());\n    assertThat(errorMessage, is(\"Invalid Server Default Error Message\"));\n  }\n\n}", "prediction": "    // Given\n    Exception exception = new InvalidServerException();\n\n    // When\n    String errorMessage = ErrorMessageFactory.create(context, exception);\n\n    // Then\n    assertThat(errorMessage).isEqualTo(context.getString(R.string.exception_invalid_server));\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "66291451_3", "part": [1, 1], "seq": [1, 1], "prompt": "class MarkerBitmap {\n\n    public final Bitmap getBitmap(final boolean hasPhoto, final boolean ownPhoto, final boolean stationActive) {\n        if (ownPhoto) {\n            if (stationActive) {\n                return iconBmpOwnPhoto;\n            }\n            return iconBmpOwnPhotoInactive;\n        } else if (hasPhoto) {\n            if (stationActive) {\n                return iconBmpWithPhoto;\n            }\n            return iconBmpWithPhotoInactive;\n        }\n        if (stationActive) {\n            return iconBmpWithoutPhoto;\n        }\n        return iconBmpWithoutPhotoInactive;\n    }\n\n    public  MarkerBitmap(final Context context, final Bitmap srcWithoutPhoto, final Bitmap srcWithPhoto, final Bitmap srcOwnPhoto,\n                        final Bitmap srcWithoutPhotoInactive, final Bitmap srcWithPhotoInactive, final Bitmap srcOwnPhotoInactive,\n                        final Point grid, final float textSize, final int maxSize, final Paint paint);\n    public  MarkerBitmap(final Context context, final Bitmap bitmap, final Point grid, final float textSize, final int maxSize, final Paint paint);\n\n    public static Bitmap getBitmapFromTitle(final String title, final Paint paint);\n    protected static void clearCaptionBitmap();\n    public final Point getIconOffset();\n    public final float getTextSize();\n    public final int getItemMax();\n    public Paint getPaint();\n    public void decrementRefCounters();\n\n    private Bitmap srcWithoutPhoto;\n    private Bitmap srcWithPhoto;\n    private Bitmap srcOwnPhoto;\n    private Bitmap srcWithoutPhotoInactive;\n    private Bitmap srcWithPhotoInactive;\n    private Bitmap srcOwnPhotoInactive;\n    private MarkerBitmap markerBitmap;\n\n}\n\nclass MarkerBitmapTest {\n\n    private Bitmap srcWithoutPhoto;\n    private Bitmap srcWithPhoto;\n    private Bitmap srcOwnPhoto;\n    private Bitmap srcWithoutPhotoInactive;\n    private Bitmap srcWithPhotoInactive;\n    private Bitmap srcOwnPhotoInactive;\n    private MarkerBitmap markerBitmap;\n\n    @Test\n    public void getBitmap_PhotoInactive() {\n", "reference": "        Bitmap bitmap = markerBitmap.getBitmap(true, false, false);\n        assertEquals(srcWithPhotoInactive, bitmap);\n    }\n\n}", "prediction": "        assertEquals(srcWithPhotoInactive, markerBitmap.getBitmap(true, true, false));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "67832483_6", "part": [1, 1], "seq": [1, 1], "prompt": "class Driver {\n\n    public static DriverBuilder builder() {\n        return new DriverBuilder();\n    }\n\n    @Deprecated  Driver();\n    private  Driver(String name, boolean license, int age, String email, List<Car> cars);\n\n    public void add(Car car);\n    @Override public String toString();\n\n    private static Validator validator;\n    private CurrencyUnit usd;\n    private Car ferrari;\n\n}\n\nclass DriverTest {\n\n    private static Validator validator;\n    private CurrencyUnit usd;\n    private Car ferrari;\n\n    @Test\n    public void shouldReturnErrorWhenDriverEmailIsInvalid() {\n", "reference": "\n        Driver driver = Driver.builder().withAge(25)\n                .withCars(Arrays.asList(ferrari))\n                .withEmail(\"emailemail\")\n                .withLicense(true)\n                .withName(\"Speed Racer\").build();\n\n        Set<ConstraintViolation<Driver>> validate = validator.validate(driver);\n        assertFalse(validate.isEmpty());\n        String message = validate.stream().findFirst()\n                .map(ConstraintViolation::getMessageTemplate)\n                .orElse(null);\n        assertEquals(\"Email should be valid\", message);\n    }\n\n}", "prediction": "        Driver driver = Driver.builder().name(\"John\").license(true).age(20).email(\"john@gmail\").build();\n\n        Set<ConstraintViolation<Driver>> constraintViolations = validator.validate(driver);\n\n        assertThat(constraintViolations).hasSize(1);\n        assertThat(constraintViolations).extracting(\"message\").contains(\"Invalid email\");\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "67869571_3", "part": [1, 1], "seq": [1, 1], "prompt": "class Preference {\n\n    public Observable<T> asObservable() {\n        return values;\n    }\n\n      Preference(SharedPreferences preferences, final String key, T defValue, Proxy<T> proxy, Observable<String> keyChanges);\n\n    public T asValue();\n    public Action1<? super T> asAction();\n\n    private SharedPreferences preferences;\n    private RxSharedPreferences rxPreferences;\n\n}\n\nclass PreferenceTest {\n\n    private SharedPreferences preferences;\n    private RxSharedPreferences rxPreferences;\n\n    @Test\n    public void asObservable() {\n", "reference": "        Preference<String> preference = rxPreferences.getString(\"key1\", \"defValue\");\n\n        TestSubscriber<String> o = new TestSubscriber<>();\n        Subscription subscription = preference.asObservable().subscribe(o);\n        o.assertValues(\"defValue\");\n\n        rxPreferences.putString(\"key1\", \"value1\");\n        o.assertValues(\"defValue\", \"value1\");\n\n        rxPreferences.remove(\"key1\");\n        o.assertValues(\"defValue\", \"value1\", \"defValue\");\n\n        subscription.unsubscribe();\n        rxPreferences.putString(\"key1\", \"foo\");\n        o.assertValues(\"defValue\", \"value1\", \"defValue\");\n    }\n\n}", "prediction": "        Preference<String> preference = new Preference<>(preferences, \"key\", \"defValue\", new StringProxy(), Observable.<String>empty());\n        preference.asObservable().subscribe(new Action1<String>() {\n            @Override\n            public void call(String s) {\n                assertEquals(\"value\", s);\n            }\n        });\n        verify(preferences).registerOnSharedPreferenceChangeListener(any(SharedPreferences.OnSharedPreferenceChangeListener.class));\n        verify(preferences).unregisterOnSharedPreferenceChangeListener(any(SharedPreferences.OnSharedPreferenceChangeListener.class));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "67913797_5", "part": [1, 1], "seq": [1, 1], "prompt": "class StreamSchema implements Serializable {\n\n    public TypeInformation<T> getTypeInfo() {\n        return typeInfo;\n    }\n\n    public  StreamSchema(TypeInformation<T> typeInfo, String... fieldNames);\n    public  StreamSchema(TypeInformation<T> typeInfo, int[] fieldIndexes, String[] fieldNames);\n\n    public boolean isAtomicType();\n    public boolean isTupleType();\n    public boolean isRowType();\n    public boolean isPojoType();\n    public boolean isCaseClassType();\n    public boolean isCompositeType();\n    private int[] getFieldIndexes(TypeInformation<E> typeInfo, String... fieldNames);\n    private TypeInformation[] getFieldTypes(TypeInformation<E> typeInfo, int[] fieldIndexes, String[] fieldNames);\n    public int[] getFieldIndexes();\n    public String[] getFieldNames();\n    public TypeInformation[] getFieldTypes();\n    public StreamSerializer<T> getStreamSerializer();\n    public TypeSerializer<T> getTypeSerializer();\n    public void setTypeSerializer(TypeSerializer<T> typeSerializer);\n\n}\n\nclass StreamSchemaTest {\n\n    @Test\n    public void testStreamTupleSerializerWithPrimitive() {\n", "reference": "        TypeInformation<String> typeInfo = TypeInformation.of(new TypeHint<String>() {});\n        StreamSchema<String> schema = new StreamSchema<>(typeInfo, \"words\");\n        assertEquals(String.class, schema.getTypeInfo().getTypeClass());\n        TypeInformation<Tuple2<String, String>> tuple2TypeInformation = Types.TUPLE(TypeInformation.of(String.class), schema.getTypeInfo());\n        assertEquals(\"Java Tuple2<String, String>\", tuple2TypeInformation.toString());\n    }\n\n}", "prediction": "        StreamSchema schema = new StreamSchema(Types.TUPLE(Types.INT, Types.STRING));\n        StreamSerializer<Tuple2<Integer, String>> serializer = schema.getStreamSerializer();\n        Tuple2<Integer, String> tuple = new Tuple2<>(1, \"test\");\n        byte[] bytes = serializer.serialize(tuple);\n        Tuple2<Integer, String> deserialized = serializer.deserialize(bytes);\n        assertEquals(tuple, deserialized);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "67999496_20", "part": [1, 1], "seq": [1, 1], "prompt": "class NodeExamples extends AbstractExamples {\n\n\tpublic NodeResponse getNodeResponseWithAllFields() {\n\t\tNodeResponse nodeResponse = new NodeResponse();\n\t\tnodeResponse.setUuid(NODE_DELOREAN_UUID);\n\t\tNodeReference parentNodeReference = new NodeReference();\n\t\tparentNodeReference.setUuid(NODE_ROOT_UUID);\n\t\tparentNodeReference.setDisplayName(\"parentNodeDisplayName\");\n\t\tnodeResponse.setParentNode(parentNodeReference);\n\t\tnodeResponse.setCreated(createOldTimestamp());\n\t\tnodeResponse.setEdited(createNewTimestamp());\n\t\tnodeResponse.setCreator(createUserReference());\n\t\tnodeResponse.setTags(Arrays.asList(new TagReference().setName(\"red\").setUuid(TAG_RED_UUID).setTagFamily(\"colors\")));\n\t\tnodeResponse.setPath(VersionHandler.CURRENT_API_BASE_PATH + \"/yourProject/webroot/Images\");\n\t\tMap<String, PublishStatusModel> languageInfo = new HashMap<>();\n\n\t\tlanguageInfo.put(\"de\", new PublishStatusModel().setVersion(\"1.0\").setPublished(true).setPublishDate(createOldTimestamp()).setPublisher(\n\t\t\tcreateUserReference()));\n\t\tlanguageInfo.put(\"en\", new PublishStatusModel().setVersion(\"1.1\").setPublished(false).setPublishDate(createOldTimestamp()).setPublisher(\n\t\t\tcreateUserReference()));\n\n\t\tnodeResponse.setAvailableLanguages(languageInfo);\n\t\tHashMap<String, String> languagePaths = new HashMap<>();\n\t\tlanguagePaths.put(\"en\", VersionHandler.CURRENT_API_BASE_PATH + \"/yourProject/webroot/Images\");\n\t\tlanguagePaths.put(\"de\", VersionHandler.CURRENT_API_BASE_PATH + \"/yourProject/webroot/Bilder\");\n\t\tnodeResponse.setLanguagePaths(languagePaths);\n\t\tnodeResponse.setChildrenInfo(new HashMap<>());\n\t\tnodeResponse.getChildrenInfo().put(\"blogpost\", new NodeChildrenInfo().setCount(1).setSchemaUuid(UUID_2));\n\t\tnodeResponse.getChildrenInfo().put(\"folder\", new NodeChildrenInfo().setCount(5).setSchemaUuid(UUID_3));\n\n\t\tFieldMap fields = new FieldMapImpl();\n\t\tfields.put(\"name\", createStringField(\"Name for language tag de-DE\"));\n\t\tfields.put(\"filename\", createStringField(\"dummy-content.de.html\"));\n\t\tfields.put(\"teaser\", createStringField(\"Dummy teaser for de-DE\"));\n\t\tfields.put(\"content\", createHtmlField(\"Content for language tag de-DE\"));\n\t\tfields.put(\"relatedProduct\", createNodeField(UUID_1));\n\t\tfields.put(\"price\", createNumberField(100.1));\n\t\tfields.put(\"enabled\", createBooleanField(true));\n\t\tfields.put(\"branch\", createDateField(createOldTimestamp()));\n\t\tfields.put(\"categories\", createNodeListField(UUID_4, UUID_5, UUID_6));\n\t\tfields.put(\"names\", createStringListField(\"Jack\", \"Joe\", \"Mary\", \"Tom\"));\n\t\tfields.put(\"categoryIds\", createNumberListField(1, 42, 133, 7));\n\t\tfields.put(\"binary\", createBinaryField());\n\t\tfields.put(\"location\", createMicronodeField(\"geolocation\", Tuple.tuple(\"latitude\", createNumberField(48.208330230278)), Tuple.tuple(\n\t\t\t\"longitude\", createNumberField(16.373063840833))));\n\t\tfields.put(\"locations\", createMicronodeListField(createMicronodeField(\"geolocation\", Tuple.tuple(\"latitude\", createNumberField(\n\t\t\t48.208330230278)), Tuple.tuple(\"longitude\", createNumberField(16.373063840833))), createMicronodeField(\"geolocation\", Tuple.tuple(\n\t\t\t\t\"latitude\", createNumberField(48.137222)), Tuple.tuple(\"longitude\", createNumberField(11.575556)))));\n\t\tnodeResponse.setFields(fields);\n\n\t\tnodeResponse.setSchema(getSchemaReference(\"content\"));\n\t\tnodeResponse.setPermissions(READ, UPDATE, DELETE, CREATE);\n\n\t\t// breadcrumb\n\t\tList<NodeReference> breadcrumb = new ArrayList<>();\n\t\t// breadcrumb.add(new NodeReferenceImpl().setDisplayName(\"/\").setPath(\"/\").setUuid(randomUUID()));\n\t\tbreadcrumb.add(new NodeReference().setDisplayName(\"news\").setPath(\"/news\").setUuid(NODE_DELOREAN_UUID));\n\t\tbreadcrumb.add(new NodeReference().setDisplayName(\"2015\").setPath(\"/automobiles/delorean-dmc-12\").setUuid(NODE_AUTOMOBILES_CATEGEORY_UUID));\n\t\tnodeResponse.setBreadcrumb(breadcrumb);\n\n\t\t// tags\n\t\tList<TagReference> tags = new ArrayList<>();\n\t\ttags.add(new TagReference().setName(\"red\").setUuid(TAG_RED_UUID).setTagFamily(\"colors\"));\n\t\ttags.add(new TagReference().setName(\"green\").setUuid(TAG_GREEN_UUID).setTagFamily(\"colors\"));\n\n\t\ttags.add(new TagReference().setName(\"car\").setUuid(UUID_1));\n\t\ttags.add(new TagReference().setName(\"ship\").setUuid(UUID_2));\n\t\tnodeResponse.setTags(tags);\n\n\t\treturn nodeResponse;\n\t}\n\n\tpublic static Field createBinaryField();\n\tpublic NavigationResponse getNavigationResponse();\n\tpublic NodeResponse getNodeResponse2();\n\tpublic NodeCreateRequest getNodeCreateRequest2();\n\tpublic NodeCreateRequest getNodeCreateRequest();\n\tpublic NodeUpdateRequest getNodeUpdateRequest2();\n\tpublic BinaryFieldTransformRequest getBinaryFieldTransformRequest();\n\tpublic NodeUpdateRequest getNodeUpdateRequest();\n\tpublic NodeListResponse getNodeListResponse();\n\tpublic Map<String, List<FormParameter>> getExampleBinaryUploadFormParameters();\n\tpublic NodeVersionsResponse createVersionsList();\n\n}\n\nclass NodeExamplesTest {\n\n\t@Test\n\tpublic void testNodeExample() {\n", "reference": "\t\tNodeResponse response = new NodeExamples().getNodeResponseWithAllFields();\n\t\tassertNotNull(response.getUuid());\n\t\tassertThat(response.getTags()).isNotEmpty();\n\t\tassertThat(response.getBreadcrumb()).isNotEmpty();\n\t\tassertNotNull(response.toJson());\n\t}\n\n}", "prediction": "\t\tNodeResponse nodeResponse = getNodeResponseWithAllFields();\n\t\tassertNotNull(nodeResponse);\n\t\tassertEquals(NODE_DELOREAN_UUID, nodeResponse.getUuid());\n\t\tassertEquals(NODE_ROOT_UUID, nodeResponse.getParentNode().getUuid());\n\t\tassertEquals(\"parentNodeDisplayName\", nodeResponse.getParentNode().getDisplayName());\n\t\tassertEquals(createOldTimestamp(), nodeResponse.getCreated());\n\t\tassertEquals(createNewTimestamp(), nodeResponse.getEdited());\n\t\tassertEquals(createUserReference(), nodeResponse.getCreator());\n\t\tassertEquals(Arrays.asList(new TagReference().setName(\"red\").setUuid(TAG_RED_UUID).setTagFamily(\"colors\")), nodeResponse.getTags());\n\t\tassertEquals(VersionHandler.CURRENT_API_BASE_PATH + \"/yourProject/webroot/Images\", nodeResponse.getPath());\n\t\tassertEquals(createOldTimestamp(), nodeResponse.getAvailableLanguages().get(\"de\").getPublishDate());\n\t\tassertEquals(createUserReference(), nodeResponse.getAvailableLanguages().get(\"de\").getPublisher());\n\t\tassertEquals(\"1.0\", nodeResponse.getAvailableLanguages().get(\"de\").getVersion());\n\t\tassertEquals(true, nodeResponse.getAvailableLanguages().get(\"de\").isPublished());\n\t\tassertEquals(createNewTimestamp(), nodeResponse.getAvailableLanguages().get(\"en\").getPublishDate());\n\t\tassertEquals(createUserReference(), nodeResponse.getAvailableLanguages().get(\"en\").getPublisher());\n\t\tassertEquals(\"1.1\", nodeResponse.getAvailableLanguages().get(\"en\").getVersion());\n\t\tassertEquals(false, nodeResponse.getAvailableLanguages().get(\"en\").isPublished());\n\t\tassertEquals(VersionHandler.CURRENT_API_BASE_PATH + \"/yourProject/webroot/Images\", nodeResponse.getLanguagePaths().", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "69660791_9", "part": [1, 1], "seq": [1, 1], "prompt": "class Main {\n\n    public static boolean booleanExpression(boolean a, boolean b, boolean c, boolean d) {\n        return a & b & c & d;\n    }\n\n}\n\nclass MainTest {\n\n    @Test(timeout = 2000)\n    public void booleanExpression() throws Throwable {\n", "reference": "        Class<?> mainClass = TestUtils.getUserClass(\"Main\");\n        for (int i = 0; i < 16; i++) {\n            boolean a = (i % 2) == 1;\n            boolean b = ((i >> 1) % 2) == 1;\n            boolean c = ((i >> 2) % 2) == 1;\n            boolean d = ((i >> 3) % 2) == 1;\n\n            Class<Boolean> booleanClass = Boolean.TYPE;\n            Method booleanExpression = TestUtils.getMethod(mainClass,\n                    \"booleanExpression\",\n                    new int[]{Modifier.PUBLIC | Modifier.STATIC},\n                    booleanClass,\n                    booleanClass, booleanClass, booleanClass, booleanClass);\n\n            boolean actualValue = (boolean) TestUtils.invokeMethod(mainClass, booleanExpression, a, b, c, d);\n            boolean expectedValue = Integer.bitCount(i) == 2;\n\n            String message = String.format(\"Main.booleanExpression(%b, %b, %b, %b)\", a, b, c, d);\n            assertEquals(message, expectedValue, actualValue);\n        }\n    }\n\n}", "prediction": "       assertTrue(Main.booleanExpression(true, true, true, true));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "69711339_2", "part": [1, 1], "seq": [1, 1], "prompt": "class UserRegistration {\n\n    public void registerNewUser(String emailAddress) throws UserAlreadyRegisteredException, EmailFailedException {\n        if (database.hasUser(emailAddress)) {\n            throw new UserAlreadyRegisteredException();\n        }\n\n        if(!emailSender.sendRegistrationEmail(new RegistrationEmail(emailAddress))) {\n            throw new EmailFailedException();\n        }\n        database.addUser(emailAddress);\n    }\n\n    public  UserRegistration(Database database, EmailSender emailSender);\n\n    public void deleteUser(String emailAddress);\n\n    private UserRegistration testee;\n    private Database mockDatabase;\n    private EmailSender mockEmailSender;\n\n}\n\nclass UserRegistrationTest {\n\n    private UserRegistration testee;\n    private Database mockDatabase;\n    private EmailSender mockEmailSender;\n\n    @Test\n    public void shouldAddNewUserToDatabase() throws UserAlreadyRegisteredException, IOException {\n", "reference": "        UserRegistration testee = new UserRegistration(mockDatabase, mockEmailSender);\n\n        String emailAddress = \"foo@example.com\";\n        when(mockDatabase.hasUser(emailAddress)).thenReturn(false);\n\n        when(mockEmailSender\n                .sendRegistrationEmail(any(RegistrationEmail.class)))\n                .thenReturn(true);\n\n        testee.registerNewUser(emailAddress);\n        Mockito.verify(mockDatabase).addUser(emailAddress);\n    }\n\n}", "prediction": "        testee.registerNewUser(\"test@example.com\");\n\n        verify(mockDatabase).addUser(\"test@example.com\");\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "69858273_0", "part": [1, 1], "seq": [1, 1], "prompt": "class TimeBasedCache {\n\n    public V get(K key)\n    {\n        // optimistically try to get the key without locking\n        V value = _cache.get(key);\n        if (value == null && mayReload())\n        {\n            reloadCache();\n            value = _cache.get(key);\n        }\n\n        return value;\n    }\n\n    public  TimeBasedCache(Duration minTimeBetweenReloads, Supplier<ImmutableMap<K, V>> valuesSupplier);\n    public  TimeBasedCache(Duration minTimeBetweenReloads,\n                          Supplier<ImmutableMap<K, V>> valuesSupplier,\n                          ImmutableMap<K, V> initialCache,\n                          Clock clock);\n\n    private boolean mayReload();\n    public void clear();\n    private void reloadCache();\n    public Optional<Instant> getLastReloadInstant();\n    public Duration getMinTimeBetweenReloads();\n\n}\n\nclass TimeBasedCacheTest {\n\n    @Test\n    public void doesNotReloadCacheWithinTimeLimit()\n            throws Exception\n    {\n", "reference": "        // fake clock returns current time, then the same thing again,\n        // then 4 seconds later, then 8 seconds later.\n        Clock fakeClock = mock(Clock.class);\n        Instant now = Instant.now();\n        when(fakeClock.millis()).thenCallRealMethod();\n        when(fakeClock.instant()).thenReturn(\n                now, // get(\"0\") - first map loading\n                now, // cache asks when the latest loading happened\n                now.plus(Duration.ofSeconds(4)), // get(\"1\") - no reloading\n                // get(\"0\") - should not even ask about the time as entry was found\n                now.plus(Duration.ofSeconds(4)), // get(\"1\") - no reloading\n                now.plus(Duration.ofSeconds(8))); // get(\"1\") - reload\n\n        @SuppressWarnings(\"unchecked\")\n        Supplier<ImmutableMap> fakeSupplier = mock(Supplier.class);\n        when(fakeSupplier.get()).thenReturn(\n                ImmutableMap.of(\"0\", 0),\n                ImmutableMap.of(\"1\", 1));\n\n        // the map will always contain a single entry with the number of reloads as in\n        // (\"reloads\" -> reloads)\n        AtomicInteger reloads = new AtomicInteger(0);\n\n        TimeBasedCache<String, Integer> cache = new TimeBasedCache<>(Duration.ofSeconds(5),\n                () -> ImmutableMap.copyOf(ImmutableMap.of(Integer.toString(reloads.get()),\n                        reloads.getAndIncrement())),\n                ImmutableMap.of(), fakeClock);\n\n        // should have only (\"0\" -> 0) in the map in the beginning\n        assertNotNull(cache.get(\"0\"));\n        assertNull(cache.get(\"1\"));\n\n        // second time we try, the map should not reload\n        assertNotNull(cache.get(\"0\"));\n        assertNull(cache.get(\"1\"));\n\n        // when the first reload happens, the cache contains (\"1\" -> 1)\n        assertNotNull(cache.get(\"1\"));\n        assertNull(cache.get(\"0\"));\n    }\n\n}", "prediction": "        Instant now = Instant.now();\n        TimeBasedCache<String, String> cache = new TimeBasedCache<>(Duration.ofMillis(100), () -> ImmutableMap.of(\"foo\", \"bar\"));\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo\"), \"bar\");\n        assertEquals(cache.get(\"foo", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "69946649_0", "part": [1, 1], "seq": [1, 1], "prompt": "class RegexContainer {\n\n    static <T> Optional<RegexContainer<T>> checkAndCreate(String maybeRegex, T content) {\n        if (maybeRegex.startsWith(\"/\") && maybeRegex.endsWith(\"/\")) {\n            try {\n                Pattern regex = Pattern.compile(maybeRegex.substring(1, maybeRegex.length() - 1));\n                return Optional.of(new RegexContainer<>(regex, content));\n            } catch (PatternSyntaxException e) {\n                return Optional.empty();\n            }\n        }\n        return Optional.empty();\n    }\n\n      RegexContainer(Pattern regex, T content);\n\n     Optional<T> match(String metricName);\n\n}\n\nclass RegexContainerTest {\n\n    @Test\n    public void shouldCheckAndNotCreate() throws Exception {\n", "reference": "        Optional<RegexContainer<Map<String, String>>> result = RegexContainer\n                .checkAndCreate(\"/{}won't compile/\", Collections.singletonMap(\"k\", \"v\"));\n        assertThat(result).isEmpty();\n    }\n\n}", "prediction": "        assertThat(RegexContainer.checkAndCreate(\"\", \"\").isPresent()).isFalse();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "70932660_4", "part": [1, 1], "seq": [1, 1], "prompt": "class NvaMonitor implements AutoCloseable {\n\n    public synchronized Future<Void> start() throws NvaMonitorException {\n        //log.debug(\"executorService.isShutdown(): \" + executorService.isShutdown());\n        //Preconditions.checkState(!executorService.isShutdown(), \"Already started\");\n        Preconditions.checkState(!this.isRunning, \"Already started\");\n        // We need to eventually support multiple monitors, but for now, just grab the\n        // first one.\n        MonitorConfiguration monitorConfiguration =\n            this.configuration.getMonitors().get(0);\n        Callable<Void> monitor = createMonitorCallable(monitorConfiguration);\n        isRunning = true;\n        Future<Void> task = executorService.submit(\n            monitor\n        );\n\n        return task;\n    }\n\n    public  NvaMonitor(DaemonConfiguration configuration);\n\n    @SuppressWarnings(\"unchecked\") private Callable<Void> createMonitorCallable(MonitorConfiguration monitorConfiguration);\n    public synchronized void stop();\n    @Override public synchronized void close();\n\n}\n\nclass NvaMonitorTest {\n\n    @Test\n    void testAbstractMonitor() {\n", "reference": "        List<MonitorConfiguration> monitors = new ArrayList<>();\n        monitors.add(\n            new MonitorConfiguration(\n                \"com.microsoft.azure.practices.nvadaemon.NvaMonitorTest$AbstractMonitor\",\n                null));\n        DaemonConfiguration daemonConfiguration = new DaemonConfiguration(monitors, null);\n        NvaMonitor nvaMonitor = new NvaMonitor(daemonConfiguration);\n        Assertions.assertThrows(NvaMonitor.NvaMonitorException.class,\n            () -> nvaMonitor.start());\n    }\n\n}", "prediction": "        NvaMonitor monitor = new NvaMonitor(new DaemonConfiguration());\n        monitor.start();\n        monitor.stop();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "70996010_18", "part": [1, 1], "seq": [1, 1], "prompt": "class RuleDatabaseUpdateTask extends AsyncTask<Void, Void, Void> {\n\n    void releaseGarbagePermissions() {\n        ContentResolver contentResolver = context.getContentResolver();\n        for (UriPermission permission : contentResolver.getPersistedUriPermissions()) {\n            if (isGarbage(permission.getUri())) {\n                Log.i(TAG, \"releaseGarbagePermissions: Releasing permission for \" + permission.getUri());\n                contentResolver.releasePersistableUriPermission(permission.getUri(), Intent.FLAG_GRANT_READ_URI_PERMISSION);\n            } else {\n                Log.v(TAG, \"releaseGarbagePermissions: Keeping permission for \" + permission.getUri());\n            }\n        }\n    }\n\n    public  RuleDatabaseUpdateTask(Context context, Configuration configuration, boolean notifications);\n\n    private void setupNotificationBuilder();\n    @Override protected Void doInBackground(final Void... configurations);\n    private boolean isGarbage(Uri uri);\n    @NonNull RuleDatabaseItemUpdateRunnable getCommand(Configuration.Item item);\n    private synchronized void updateProgressNotification();\n    private synchronized void postExecute();\n    synchronized void addError(Configuration.Item item, String message);\n    synchronized void addDone(Configuration.Item item);\n    synchronized void addBegin(Configuration.Item item);\n    synchronized long pendingCount();\n\n     HashMap<String, Uri> uriLocations;\n\n}\n\nclass RuleDatabaseUpdateTaskTest {\n\n     HashMap<String, Uri> uriLocations;\n\n    @Test\n    public void testReleaseGarbagePermissions() throws Exception {\n", "reference": "        Context mockContext = mock(Context.class);\n        ContentResolver mockResolver = mock(ContentResolver.class);\n        when(mockContext.getContentResolver()).thenReturn(mockResolver);\n\n        final List<UriPermission> persistedPermissions = new LinkedList<>();\n        when(mockResolver.getPersistedUriPermissions()).thenReturn(persistedPermissions);\n\n        UriPermission usedPermission = mock(UriPermission.class);\n        when(usedPermission.getUri()).thenReturn(newUri(\"content://used\"));\n        persistedPermissions.add(usedPermission);\n\n        UriPermission garbagePermission = mock(UriPermission.class);\n        when(garbagePermission.getUri()).thenReturn(newUri(\"content://garbage\"));\n        persistedPermissions.add(garbagePermission);\n\n        doAnswer(new Answer<Void>() {\n            @Override\n            public Void answer(InvocationOnMock invocation) throws Throwable {\n                Iterator<UriPermission> iter = persistedPermissions.iterator();\n                while (iter.hasNext()) {\n                    UriPermission perm = iter.next();\n                    if (perm.getUri() == invocation.getArgumentAt(0, Uri.class))\n                        iter.remove();\n                }\n                return null;\n            }\n        }).when(mockResolver, \"releasePersistableUriPermission\", any(Uri.class), anyInt());\n\n        Configuration configuration = new Configuration();\n        configuration.hosts.items.add(newItemForLocation(\"content://used\"));\n\n        assertTrue(persistedPermissions.contains(usedPermission));\n        assertTrue(persistedPermissions.contains(garbagePermission));\n\n        new RuleDatabaseUpdateTask(mockContext, configuration, false).releaseGarbagePermissions();\n\n        assertTrue(persistedPermissions.contains(usedPermission));\n        assertFalse(persistedPermissions.contains(garbagePermission));\n    }\n\n}", "prediction": "        RuleDatabaseUpdateTask task = new RuleDatabaseUpdateTask(context, configuration, false);\n        task.releaseGarbagePermissions();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "71089550_3", "part": [1, 1], "seq": [1, 1], "prompt": "class Types {\n\n\tpublic static boolean isSubtype(Type subType, Type superType) {\n\t    if (Types.isEqual(subType, superType)) return true;\n\t    if (subType instanceof IntegerType && superType instanceof FloatType) {\n\t        return true;\n\t    }\n\t    if (superType instanceof TopReferenceType && isRefType(subType)) {\n\t        return true;\n\t    }\n\t    if (subType instanceof BottomReferenceType && isRefType(superType)) {\n\t        return true;\n\t    }\n\t    if (subType instanceof ObjectType && superType instanceof ObjectType) {\n\t        // NOTE: this only handles concrete types and does not reason about MRO/MRW\n\t        ObjectType subObjType = (ObjectType) subType;\n\t        List<Property> superTypeProps = ((ObjectType)superType).properties();\n\t        // each super type property should be present in the subtype with (1) the same\n\t        // type and (2) an equally strong or stronger read-write permission\n\t        for (Property superProp: superTypeProps) {\n\t            if (!subObjType.hasProperty(superProp.getName())) {\n\t                return false;\n\t            }\n\t            Property subProp = subObjType.getProperty(superProp.getName());\n\t            if (!Types.isEqual(superProp.getType(), subProp.getType())) {\n\t                return false;\n\t            }\n\t            if (superProp.isRW() && !subProp.isRW()) { // permissions weakened\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t    return false;\n\t}\n\n\tpublic static boolean isEqual(Type type1, Type type2);\n\tprivate static boolean isEqualHelper(Type type1, Type type2, Set<Pair<Type, Type>> queried);\n\tprivate static boolean isContainedIn(List<Type> types, Type type);\n\tprivate static boolean isContainedIn(List<Type> types1, List<Type> types2);\n\tpublic static Type mkArray(Type celltype);\n\tpublic static Type mkMap(Type celltype);\n\tpublic static ConstructorType mkCtor(List<Type> paramTypes, List<String> paramNames, Type returnType, Type proto);\n\tpublic static FunctionType mkFunc(Type ret, List<Type> paramty);\n\tpublic static FunctionType mkFunc(Type ret, List<Type> paramty, List<String> params);\n\tpublic static boolean isStringType(Type targetType);\n\tpublic static boolean isArrayType(Type targetType);\n\tpublic static boolean isMapType(Type type);\n\tpublic static Type mkAny();\n\tpublic static Type mkVoid();\n\tpublic static FloatType mkFloat();\n\tpublic static StringType mkString();\n\tpublic static BooleanType mkBool();\n\tpublic static IntegerType mkInt();\n\tpublic static Property mkProperty(final String name, final Type ty);\n\tpublic static AttachedMethodType mkMethod(final Type thistype, final Type ret, List<Type> pty);\n\tpublic static AttachedMethodType mkMethod(final Type thistype, final Type ret, Type... args);\n\tpublic static AttachedMethodType mkMethod(Type thistype, Type ret, List<String> pnames, List<Type> pty);\n\tpublic static ObjectType mkObject(List<Property> props);\n\tpublic static Type mkMapIteratorType(Type t);\n\tpublic static boolean isComponentOf(Type type, IntersectionType iType);\n\tpublic static boolean isRefType(Type t);\n\tpublic static boolean usableAsConstructor(Type t);\n\tpublic static boolean isSubtypeish(Type subType, Type superType);\n\tpublic static Type coarseUpperBound(Type t1, Type t2);\n\tpublic static Type coarseLowerBound(Type t1, Type t2);\n\tpublic static Type lowestSubtype(Type t);\n\n}\n\nclass TypesTest {\n\n    @Test\n    public void testRecursiveSubtype() {\n", "reference": "        ObjectType o1 = new ObjectType();\n        o1.setProperty(\"f\", o1);\n        ObjectType o2 = new ObjectType();\n        o2.setProperty(\"f\", o2);\n        Assert.assertTrue(Types.isSubtype(o1, o2));\n\n        FunctionType f1 = new FunctionType(oneElementArrayList(null), oneElementArrayList(\"1\"), new VoidType());\n        f1.setParamType(f1, 0);\n        FunctionType f2 = new FunctionType(oneElementArrayList(null), oneElementArrayList(\"1\"), new VoidType());\n        f2.setParamType(f2, 0);\n        Assert.assertTrue(Types.isSubtype(f1, f2));\n    }\n\n}", "prediction": "        Type t1 = Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(Types.mkArray(", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "71127071_0", "part": [1, 1], "seq": [1, 1], "prompt": "class ZwitscherController {\n\n    @RequestMapping(method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_UTF8_VALUE)\n    public HttpEntity<Collection<String>> tweets(@RequestParam(value = \"q\", required = false) String q) {\n        Collection<String> tweets = repository.search(ofNullable(q).orElse(query), pageSize);\n        return new ResponseEntity<>(tweets, HttpStatus.OK);\n    }\n\n    @Autowired public  ZwitscherController(ZwitscherRepository repository);\n\n    @Value(\"${tweet.query:cloudnativenerd}\") public void setQuery(String query);\n    @Value(\"${tweet.pageSize:42}\") public void setPageSize(int pageSize);\n\n}\n\nclass ZwitscherControllerTest {\n\n    @Test\n    public void tweets() throws Exception {\n", "reference": "        ZwitscherRepository repository = mock(ZwitscherRepository.class);\n        ZwitscherController controller = new ZwitscherController(repository);\n        controller.setQuery(\"cloudnativenerd\");\n        controller.setPageSize(42);\n\n        when(repository.search(\"cloudnativenerd\", 42)).thenReturn(Collections.singleton(\"Hello Test.\"));\n\n        HttpEntity<Collection<String>> tweets = controller.tweets(null);\n        assertFalse(tweets.getBody().isEmpty());\n    }\n\n}", "prediction": "        mockMvc.perform(get(\"/tweets\").param(\"q\", \"cloudnativenerd\"))\n                .andExpect(status().isOk())\n                .andExpect(content().contentType(MediaType.APPLICATION_JSON_UTF8_VALUE))\n                .andExpect(jsonPath(\"$\", hasSize(42)));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "71972621_23", "part": [1, 1], "seq": [1, 1], "prompt": "class GlobalPropertyResource {\n\n    @DELETE\n    @Timed\n    @UnitOfWork\n    @Path(\"{id}\")\n    @ApiOperation(value = \"Soft delete\")\n    public Response delete(@PathParam(\"id\") final int id) {\n        service.delete(id);\n        return Response.ok().build();\n    }\n\n    @POST @Consumes(MediaType.APPLICATION_JSON) @Timed @UnitOfWork @ApiOperation(value = \"Save global property\", response = GlobalPropertyDomain.class) public Response save(@NotNull @Valid final GlobalPropertyDomain globalProperty);\n    @GET @Timed @UnitOfWork(transactional = false) @Path(\"{id}\") @ApiOperation(value = \"Get global property by id\", response = GlobalPropertyDomain.class) public Response get(@PathParam(\"id\") final int id);\n    @GET @Timed @UnitOfWork(transactional = false) @ApiOperation(value = \"Search global property based on name, param\", response = Set.class) public Response search(@QueryParam(\"name\") final String name, @QueryParam(\"type\") final String propertyType);\n\n    private static IGlobalPropertyService service;\n    private static GlobalPropertyDomain globalProperty;\n    private static GlobalPropertyResource resource;\n\n}\n\nclass GlobalPropertyResourceTest {\n\n    private static IGlobalPropertyService service;\n    private static GlobalPropertyDomain globalProperty;\n    private static GlobalPropertyResource resource;\n\n    @Test\n    public void testDeleteById() {\n", "reference": "        doNothing().when(service).delete(anyInt());\n\n        final Response response = resource.delete(globalProperty.getId());\n        Assert.assertEquals(response.getStatus(), 200);\n    }\n\n}", "prediction": "        resource.delete(globalProperty.getId());\n        assertNull(service.get(globalProperty.getId()));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "72159384_0", "part": [1, 1], "seq": [1, 1], "prompt": "class ConsumerRecordRelay implements Runnable {\n\n    void stop() {\n        logger.info(\"Stopping Kafka message relay\");\n        stopped = true;\n    }\n\n    public  ConsumerRecordRelay(Consumer<K, V> consumer, BlockingQueueConsumer<K, V> blockingQueueConsumer);\n\n    @Override public void run();\n    public void setOffset(ConsumerRecord<K, V> record);\n    public void removePartitionFromOffset(TopicPartition topicPartition);\n    private void commitOffsets();\n    private void callback(Map<TopicPartition, OffsetAndMetadata> offset, Exception ex);\n\n    @Mock\n    private Consumer<Integer, String> consumer;\n    @Mock\n    private BlockingQueueConsumer<Integer, String> blockingQueueConsumer;\n    private ConsumerRecord<Integer, String> record;\n\n}\n\nclass ConsumerRecordRelayTest {\n\n    @Mock\n    private Consumer<Integer, String> consumer;\n    @Mock\n    private BlockingQueueConsumer<Integer, String> blockingQueueConsumer;\n    private ConsumerRecord<Integer, String> record;\n\n    @Test\n    public void relayWithException() throws Exception {\n", "reference": "        when(consumer.poll(anyLong())).thenThrow(RuntimeException.class);\n\n        ConsumerRecordRelay<Integer, String> relay = new ConsumerRecordRelay<>(consumer, blockingQueueConsumer);\n        new Thread(relay).start();\n        verify(blockingQueueConsumer, never()).relay(record);\n        verify(consumer, timeout(1000).only()).poll(anyLong());\n        relay.stop();\n    }\n\n}", "prediction": "        ConsumerRecordRelay relay = new ConsumerRecordRelay(consumer, blockingQueueConsumer);\n        relay.run();\n        verify(blockingQueueConsumer).consume(record);\n        verify(consumer).commitSync(Collections.singletonMap(new TopicPartition(\"topic\", 0), new OffsetAndMetadata(1)));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "72189814_155", "part": [1, 1], "seq": [1, 1], "prompt": "class HaloNetClient {\n\n    @Api(2.0)\n    public Response request(@NonNull HaloRequest haloRequest) throws HaloNetException {\n        Request request = haloRequest.buildOkRequest();\n        try {\n            Response response = mClient.newCall(request).execute();\n            if (response.isSuccessful()) {\n                return response;\n            } else {\n                throw new HaloNetworkExceptionResolver().resolve(response);\n            }\n        } catch (HaloNetException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new HaloNetworkExceptionResolver().resolve(e, request, HaloUtils.isNetworkConnected(mContext));\n        }\n    }\n\n    public  HaloNetClient(@NonNull Context context, @NonNull OkHttpClient.Builder clientBuilder, @NonNull HaloEndpointCluster endpoints, boolean disableKitKatCertificate);\n\n    @NonNull @Api(2.0) public OkHttpClient.Builder buildCertificates(@NonNull OkHttpClient.Builder okBuilder);\n    @SuppressWarnings(\"unchecked\") @Api(2.0) public T request(@NonNull HaloRequest haloRequest, @NonNull final TypeReference<T> type);\n    @SuppressWarnings(\"unchecked\") @Api(2.0) public T request(@NonNull HaloRequest haloRequest, @NonNull Class<T> clazz);\n    @Api(2.0) public HaloEndpointCluster endpoints();\n    @NonNull @Api(2.0) public OkHttpClient ok();\n    @Api(2.0) public void overrideOk(@NonNull OkHttpClient.Builder builder);\n    @NonNull @Api(2.0) public Context context();\n    @NonNull @Api(2.4) public void closeCache();\n\n    private CallbackFlag mCallbackFlag;\n    private HaloNetClient mHaloNetClient;\n    private HaloFramework mFramework;\n    private MockServer mMockServer;\n    private String mEndpointURL;\n\n}\n\nclass HaloNetClientTest  {\n\n    private CallbackFlag mCallbackFlag;\n    private HaloNetClient mHaloNetClient;\n    private HaloFramework mFramework;\n    private MockServer mMockServer;\n    private String mEndpointURL;\n\n    @Test\n    public void thatCanPostARequestWithJSONObjectBody() throws IOException, JSONException {\n", "reference": "        enqueueServerFile(mMockServer,GET_TEST_ITEM);\n        HaloNetworkApi networkApi = givenAHaloNetWorkApi(mFramework,mEndpointURL);\n        HaloRequest request = givenAPostRequestWithJSONObjectBody(networkApi);\n        String response = mHaloNetClient.request(request,String.class);\n        assertThat(response).isNotNull();\n        assertThat(response).isEqualTo(\"ExampleResponseTestFromNetWork\");\n    }\n\n}", "prediction": "        JSONObject jsonObject = new JSONObject();\n        jsonObject.put(\"key\", \"value\");\n        HaloRequest request = new HaloRequest.Builder(mHaloNetClient)\n                .url(mEndpointURL + \"/test\")\n                .method(HaloRequestMethod.POST)\n                .body(jsonObject)\n                .build();\n        mHaloNetClient.request(request);\n        Assert.assertTrue(mCallbackFlag.isDone());\n        Assert.assertTrue(mCallbackFlag.isSuccess());\n        Assert.assertEquals(mCallbackFlag.getResponse().code(), 200);\n        Assert.assertEquals(mCallbackFlag.getResponse().body().string(), \"{\\\"key\\\":\\\"value\\\"}\");\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "72299435_7", "part": [1, 1], "seq": [1, 1], "prompt": "class VolleyX {\n\n    public static <T> Observable<T> from(final Request<T> request) {\n        if (!sInited) throw new IllegalStateException(\"call init first\");\n        if (request == null) throw new NullPointerException(\"request can not be null\");\n        return Observable.defer(new Func0<Observable<T>>() {\n            @Override\n            public Observable<T> call() {\n                try {\n                    return Observable.just(generateData(request));\n                } catch (InterruptedException | ExecutionException e) {\n                    VolleyXLog.e(e.getMessage());\n                    return Observable.error(e);\n                }\n            }\n        });\n    }\n\n    public static void init(Context context);\n    public static Observable<T> from(final Request<T> request, final String listernerField);\n    static T generateData(Request<T> request);\n    static T generateData(Request<T> request, String listernerField);\n    static RequestFuture<T> getRequestFuture(Request<T> request, String listernerField);\n    public static void setRequestQueue(RequestQueue queue);\n\n    @Mock RequestQueue mockReqeustQueue;\n    @Mock Request mockRequest;\n\n}\n\nclass VolleyXTest  {\n\n    @Mock RequestQueue mockReqeustQueue;\n    @Mock Request mockRequest;\n\n    @Test\n    public void testFrom1() throws Exception {\n", "reference": "        VolleyX.sInited = true;\n\n        assertThat(VolleyX.from(mockRequest, \"\"), is(instanceOf(Observable.class)));\n    }\n\n}", "prediction": "        VolleyX.init(mock(Context.class));\n        VolleyX.setRequestQueue(mockReqeustQueue);\n        VolleyX.from(mockRequest);\n        verify(mockReqeustQueue).add(mockRequest);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "74042107_5", "part": [1, 1], "seq": [1, 1], "prompt": "class SubtractiveMixingStrategy implements MixingStrategy {\n\n    public Liquid mixLiquids(LinkedList<Liquid> inflow) {\n        if (inflow == null || inflow.isEmpty()) {\n            throw new IllegalArgumentException(\"Must at least mix one liquid\");\n        }\n\n        // Count full amount first...\n        float fullAmount = 0;\n        for (Liquid liquid : inflow) {\n            fullAmount += liquid.getAmount();\n        }\n\n        if (Math.abs(fullAmount) < 0.000001) {\n            return new Liquid(0, inflow.peekFirst().getTemperature(), inflow.peekFirst().getColor());\n        }\n\n        // Real calculations...\n        double c = 0;\n        double m = 0;\n        double y = 0;\n        float temperature = 0;\n\n        for (Liquid liquid : inflow) {\n            c += (liquid.getAmount() / fullAmount) * liquid.getColor().getCyan();\n            m += (liquid.getAmount() / fullAmount) * liquid.getColor().getMagenta();\n            y += (liquid.getAmount() / fullAmount) * liquid.getColor().getYellow();\n\n            temperature += (liquid.getAmount() / fullAmount) * liquid.getTemperature();\n        }\n\n        // Fix floating point inaccuracies\n        c = Math.min(1, c);\n        m = Math.min(1, m);\n        y = Math.min(1, y);\n        temperature = Math.min(SimulationConstants.MAX_TEMPERATURE,\n                Math.max(SimulationConstants.MIN_TEMPERATURE, temperature));\n\n        return new Liquid(fullAmount, temperature, new Color(c, m, y));\n    }\n\n}\n\nclass SubtractiveMixingStrategyTest {\n\n    @Test\n    public void testMixingTwoLiquidsDifferentAmounts() {\n", "reference": "        LinkedList<Liquid> liquids = new LinkedList<>();\n        liquids.add(new Liquid(300, 340, new Color(0x880000)));\n        liquids.add(new Liquid(100, 300, new Color(0x440000)));\n\n        Liquid result = new SubtractiveMixingStrategy().mixLiquids(liquids);\n        assertEquals(new Liquid(400, 330, new Color(0x770000)), result);\n    }\n\n}", "prediction": "        LinkedList<Liquid> inflow = new LinkedList<>();\n        inflow.add(new Liquid(1, 100, new Color(0, 0, 0)));\n        inflow.add(new Liquid(2, 100, new Color(0, 0, 0)));\n\n        Liquid mixed = new SubtractiveMixingStrategy().mixLiquids(inflow);\n\n        assertEquals(3, mixed.getAmount(), 0.000001);\n        assertEquals(100, mixed.getTemperature(), 0.000001);\n        assertEquals(new Color(0, 0, 0), mixed.getColor());\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "74059585_25", "part": [1, 1], "seq": [1, 1], "prompt": "class NonRegisteringDriver implements Driver {\n\n  @Override\n  public DriverPropertyInfo[] getPropertyInfo(@Nullable String url, @Nullable Properties info)\n      throws SQLException {\n    checkNotNullUrl(url);\n\n    return DriverManager.getDriver(getRealUrl(url)).getPropertyInfo(getRealUrl(url), info);\n  }\n\n  public  NonRegisteringDriver();\n  @VisibleForTesting  NonRegisteringDriver(TraceService traceService);\n\n  @Override public boolean acceptsURL(@Nullable String url);\n  @Override public Connection connect(@Nullable String url, @Nullable Properties info);\n  @VisibleForTesting Connection connect(String url, Properties info, TraceOptions traceOptions);\n  @Override public int getMajorVersion();\n  @Override public int getMinorVersion();\n  @Override public Logger getParentLogger();\n  @Override public boolean jdbcCompliant();\n  private static String getRealUrl(String url);\n  private static void checkNotNullUrl(String url);\n\n  private final TraceService mockTraceService;\n  private final TraceService.Span mockTraceSpan;\n  private final Driver mockRealDriver;\n  private final Connection mockRealConnection;\n  private NonRegisteringDriver driver;\n\n}\n\nclass NonRegisteringDriverTest {\n\n  private final TraceService mockTraceService;\n  private final TraceService.Span mockTraceSpan;\n  private final Driver mockRealDriver;\n  private final Connection mockRealConnection;\n  private NonRegisteringDriver driver;\n\n  @Test\n  public void getPropertyInfo() throws Exception {\n", "reference": "    DriverPropertyInfo[] driverPropertyInfos = new DriverPropertyInfo[0];\n    when(mockRealDriver.acceptsURL(\"jdbc:mockdriver\")).thenReturn(true);\n    when(mockRealDriver.getPropertyInfo(eq(\"jdbc:mockdriver\"), any(Properties.class)))\n        .thenReturn(driverPropertyInfos);\n\n    Properties info = new Properties();\n    assertThat(driver.getPropertyInfo(\"jdbc:stackdriver:mockdriver\", info))\n        .isSameAs(driverPropertyInfos);\n    verify(mockRealDriver).getPropertyInfo(\"jdbc:mockdriver\", info);\n  }\n\n}", "prediction": "    when(mockRealDriver.getPropertyInfo(anyString(), any(Properties.class)))\n        .thenReturn(new DriverPropertyInfo[] {});\n    assertThat(driver.getPropertyInfo(\"jdbc:mysql://localhost:3306/test\", new Properties()))\n        .isEmpty();\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "74458764_50", "part": [1, 1], "seq": [1, 1], "prompt": "class JedisPoolFacade extends AbstractJedisFacade {\n\n  @Override\n  public Long publish(byte[] channel, byte[] message) {\n    return jedis().publish(channel, message);\n  }\n\n    JedisPoolFacade(Pool<Jedis> jedisPool);\n\n   Jedis jedis();\n  @Override public void requestFinished();\n  @Override public void psubscribe(final RedisPubSub listener, String pattern);\n  @Override public void punsubscribe(final RedisPubSub listener, byte[] pattern);\n  @Override public Long hdel(byte[] key, byte[]... fields);\n  @Override public List<byte[]> hmget(byte[] key, byte[]... fields);\n  @Override public String hmset(byte[] key, Map<byte[], byte[]> hash);\n  @Override public Long hsetnx(final byte[] key, final byte[] field, final byte[] value);\n  @Override public Long hset(final byte[] key, final byte[] field, final byte[] value);\n  @Override public Set<byte[]> hkeys(byte[] key);\n  @Override public String set(byte[] key, byte[] value);\n  @Override public String setex(byte[] key, int expiry, byte[] value);\n  @Override public Long expire(byte[] key, int value);\n  @Override public void srem(byte[] key, byte[]... member);\n  @Override public Long sadd(byte[] key, byte[]... member);\n  @Override public Long del(byte[]... keys);\n  @Override public Boolean exists(byte[] key);\n  @Override public Set<byte[]> smembers(byte[] key);\n  @Override public Set<byte[]> spop(byte[] key, long count);\n  @Override public Long expireAt(byte[] key, long unixTime);\n  @Override public Long zadd(byte[] key, double score, byte[] elem);\n  @Override public Long zrem(byte[] key, byte[]... fields);\n  @Override public Set<byte[]> zrangeByScore(byte[] key, double start, double end);\n  @Override public Set<byte[]> zrange(byte[] key, long start, long end);\n  @Override public Long persist(byte[] key);\n  @Override public String info(String section);\n  @Override public RedisFacade.ResponseFacade<T> transaction(final byte[] key, final TransactionRunner<T> transaction);\n  @Override public void close();\n  @Override public String rename(byte[] oldkey, byte[] newkey);\n  @Override public byte[] get(byte[] key);\n  @Override public void startMonitoring(MetricRegistry metrics);\n\n  private Pool<Jedis> pool;\n  private JedisPoolFacade rf;\n  private Jedis jedis;\n\n}\n\nclass TestJedisPoolFacade {\n\n  private Pool<Jedis> pool;\n  private JedisPoolFacade rf;\n  private Jedis jedis;\n\n  @Test\n  public void testPublish() {\n", "reference": "    byte[] channel = new byte[]{};\n    byte[] message = new byte[]{};\n    rf.publish(channel, message);\n    verify(jedis).publish(channel, message);\n  }\n\n}", "prediction": "    rf.publish(\"test\".getBytes(), \"test\".getBytes());\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "74581177_26", "part": [1, 1], "seq": [1, 1], "prompt": "class GlobalAntExecutor {\n\n    public String generateFullTemporaryDir(final String generatorBuilderPath, final String temporaryDir) throws APIRestGeneratorException\n    {\n        final String fullTemporaryDir = generatorBuilderPath + File.separator + ConstantsAnt.BASE_GEN_FOLDERS + temporaryDir ;\n        FilesUtility.createFullDirectoryTree(fullTemporaryDir);\n\n        return fullTemporaryDir;\n    }\n\n    public  GlobalAntExecutor(final String parserType, final String translatorType);\n\n    public void launchAntExecutor(final String generatorBuilderPath,\n                                  final String fileName,\n                                  final String deliverableFileName,\n                                  final String temporaryDir,\n                                  final PrintStream errorStreamWrapper,\n                                  final PrintStream outputStreamWrapper);\n    public String generateTemporaryOutputDirectory(final String generatorBuilderPath);\n    public void removeFullTemporaryDirectory(final String fullTemporaryDir);\n    public void validateFileExtension(final String fileName);\n    public String getDeliverableFileName(final String fileName, final String translatorType);\n\n}\n\nclass GlobalAntExecutorTest {\n\n\t@Test\n\tpublic void generateFullTemporaryDirTest() throws APIRestGeneratorException\n\t{\n", "reference": "\t\tfinal GlobalAntExecutor globalAntExecutor = new GlobalAntExecutor(ConstantsTest.PARSER_TYPE, ConstantsTest.TRANSLATOR_TYPE) ;\n\t\tglobalAntExecutor.generateFullTemporaryDir(ConstantsTest.GENERATOR_BUILDER_PATH, ConstantsTest.TEMPORARY_DIR) ;\n\t}\n\n}", "prediction": "\t\tfinal String generatorBuilderPath = \"src/test/resources/\";\n\t\tfinal String temporaryDir = \"temp\";\n\t\tfinal String fullTemporaryDir = \"src/test/resources/temp\";\n\n\t\tfinal GlobalAntExecutor globalAntExecutor = new GlobalAntExecutor(\"\", \"\");\n\t\tfinal String result = globalAntExecutor.generateFullTemporaryDir(generatorBuilderPath, temporaryDir);\n\n\t\tassertEquals(fullTemporaryDir, result);\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "75793136_1", "part": [1, 1], "seq": [1, 1], "prompt": "class GitHubApiController {\n\n    @GetMapping(\"user/{screenName}\")\n    public ResponseEntity<User> discoverUserByScreenName(@PathVariable(\"screenName\")  String screenName) {\n        return Optional.of(ResponseEntity.ok(gitHubService.discoverUserByScreenName(screenName)))\n                .or(new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR));\n    }\n\n    @Autowired public  GitHubApiController(GitHubService gitHubService);\n\n    @LocalServerPort\n    private int port;\n    @Autowired\n    private TestRestTemplate restTemplate;\n\n}\n\nclass GitHubApiControllerTest {\n\n    @LocalServerPort\n    private int port;\n    @Autowired\n    private TestRestTemplate restTemplate;\n\n    @Test\n    public void testDiscoverUserByScreenName() throws Exception {\n", "reference": "        ResponseEntity<User> user1 = restTemplate.getForEntity(\"http://localhost:\" + port + \"/v1/user/bingohuang\", User.class);\n        assertEquals(HttpStatus.OK, user1.getStatusCode());\n\n        ResponseEntity<User> user2 = restTemplate.getForEntity(\"http://localhost:\" + port + \"/v1/user/163yun\", User.class);\n        assertEquals(HttpStatus.OK, user2.getStatusCode());\n\n        ResponseEntity<User> user3 = restTemplate.getForEntity(\"http://localhost:\" + port + \"/v1/user/huangqingbing\", User.class);\n        assertEquals(HttpStatus.OK, user3.getStatusCode());\n    }\n\n}", "prediction": "        ResponseEntity<User> response = restTemplate.getForEntity(\"http://localhost:\" + port + \"/user/octocat\", User.class);\n        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);\n        assertThat(response.getBody().getLogin()).isEqualTo(\"octocat\");\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "75865158_0", "part": [1, 1], "seq": [1, 1], "prompt": "class Solver {\n\n    public Puzzle solvePuzzle() {\n        Puzzle workingPuzzle = new Puzzle(originalPuzzle);\n        solve(workingPuzzle);\n        return workingPuzzle;\n    }\n\n    public  Solver(Puzzle puzzle);\n\n    private Boolean solve(Puzzle workingPuzzle);\n\n}\n\nclass SolverTest {\n\n    @Test\n    public void ValidPuzzle_Solve_NoNullValues() {\n", "reference": "\n        //Arrange & Act\n        Puzzle solvedPuzzle = solvePuzzle(getPuzzle());\n\n        //Assert\n        for (int x = 0; x < Puzzle.SIZE; x++) {\n            for (int y = 0; y < Puzzle.SIZE; y++) {\n                Point currentPoint = new Point(x, y);\n                Assert.assertNotNull(solvedPuzzle.getNumber(currentPoint));\n            }\n        }\n    }\n\n}", "prediction": "        Puzzle puzzle = new Puzzle(new int[][] {\n                { 0, 0, 0, 0, 0, 0, 0, 0, 0 },\n                { 0, 0, 0, 0, 0, 0, 0, 0, 0 },\n                { 0, 0, 0, 0, 0, 0, 0, 0, 0 },\n                { 0, 0, 0, 0, 0, 0, 0, 0, 0 },\n                { 0, 0, 0, 0, 0, 0, 0, 0, 0 },\n                { 0, 0, 0, 0, 0, 0, 0, 0, 0 },\n                { 0, 0, 0, 0, 0, 0, 0, 0, 0 },\n                { 0, 0, 0, 0, 0, 0, 0, 0, 0 },\n                { 0, 0, 0, 0, 0, 0, 0, 0, 0 }\n        });\n        Solver solver = new Solver(puzzle);\n        Puzzle solvedPuzzle = solver.solvePuzzle();\n        assertNotNull(solvedPuzzle);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "75941229_0", "part": [1, 1], "seq": [1, 1], "prompt": "class KafkaSenderExporter {\n\n  @Activate\n  public void activate(Config config, BundleContext context, Map<String, String> properties) {\n    sender = KafkaSender.newBuilder()\n        .bootstrapServers(config.bootstrapServers())\n        .encoding(config.encoding())\n        .messageMaxBytes(config.messageMaxBytes())\n        .overrides(getOverrides(properties))\n        .topic(config.topic())\n        .build();\n    reg = context.registerService(Sender.class, sender, new Hashtable<String, String>(properties));\n  }\n\n  private HashMap<String, String> getOverrides(Map<String, String> properties);\n  @Deactivate public void deactive();\n\n}\n\nclass KafkaSenderExporterTest {\n\n  @Test\n  public void testConfig() {\n", "reference": "    KafkaSenderExporter exporter = new KafkaSenderExporter();\n    Map<String, String> properties = new HashMap<String, String>();\n    properties.put(\"kafka.myprop\", \"myvalue\");\n    BundleContext context = mock(BundleContext.class);\n    Config config = mock(Config.class);\n    when(config.bootstrapServers()).thenReturn(\"server1\");\n    when(config.encoding()).thenReturn(Encoding.JSON);\n    when(config.topic()).thenReturn(\"mytopic\");\n    exporter.activate(config, context, properties);\n  }\n\n}", "prediction": "    Map<String, String> properties = new HashMap<>();\n    properties.put(\"bootstrap.servers\", \"localhost:9092\");\n    properties.put(\"topic\", \"test\");\n    properties.put(\"encoding\", \"json\");\n    properties.put(\"message.max.bytes\", \"1000000\");\n    properties.put(\"key.serializer\", \"org.apache.kafka.common.serialization.StringSerializer\");\n    properties.put(\"value.serializer\", \"org.apache.kafka.common.serialization.StringSerializer\");\n    properties.put(\"acks\", \"all\");\n    properties.put(\"retries\", \"10\");\n    properties.put(\"batch.size\", \"16384\");\n    properties.put(\"linger.ms\", \"1\");\n    properties.put(\"buffer.memory\", \"33554432\");\n    properties.put(\"max.block.ms\", \"1000\");\n    properties.put(\"max.request.size\", \"104857600\");\n    properties.put(\"compression.type\", \"gzip\");\n    properties.put(\"compression.level\", \"1\");\n    properties.put(\"batch.size\", \"16384\");\n    properties.put(\"linger.ms\", \"1\");\n    properties.put(\"buffer.memory\", \"33554432\");\n    properties.put(\"max.block.ms\", \"1000\");\n    properties.put(\"max.request.size\", \"104857600\");\n    properties.put(\"compression.type\", \"gzip\");\n    properties.put(\"compression.level\", \"1\");\n    properties.put(\"batch.size\", \"16384\");\n    properties.put(\"linger.ms\", \"1\");\n    properties.put(\"buffer.memory\", \"33554432\");\n    properties.put(\"max.block.ms\", \"1000\");\n    properties.put(\"max.request.size\", \"104857600\");\n    properties.put(\"compression.type\", \"gzip\");\n    properties.put(\"compression.level\", \"1\");\n    properties.put(\"batch.size\", \"16384\");\n    properties.put(\"linger.ms\", \"1\");\n    properties.put(\"buffer.memory\", \"33554432\");\n    properties.put(\"max.block.ms\", \"1000\");\n    properties.put(\"max.request.size\", \"104857600\");\n    properties.put(\"compression.type\", \"gzip\");\n    properties.put(\"compression.level\", \"1\");\n    properties.put(\"batch.size\", \"16384\");\n    properties.put(\"linger.ms\", \"1\");\n    properties.put(\"buffer.memory\", \"33554432\");\n    properties.put(\"max.block.ms\", \"1000\");\n    properties.put(\"max.request.size\", \"104857600\");\n    properties.put(\"compression.type\", \"gzip\");\n    properties.put(\"compression.level\", \"1\");\n    properties.put(\"batch.size\", \"16384\");\n    properties.put(\"linger.ms\", \"1\");\n    properties.put(\"buffer.memory\", \"33554432\");\n    properties.put(\"max.block.ms\", \"1000\");\n    properties.put(\"max.request.size\", \"104857600\");\n    properties.put(\"compression.type\", \"gzip\");\n    properties.put(\"compression.level\", \"1\");\n    properties.put(\"batch.size\", \"16384\");\n    properties.put(\"linger.ms\", \"1\");\n    properties.put(\"buffer.memory\", \"33554432\");\n    properties.put(\"max.block.ms\", \"1000\");\n    properties.put(\"max.request.size\", \"104857600\");\n    properties.put(\"compression.type\", \"gzip\");\n    properties.put(\"compression.level\", \"1\");\n    properties.put(\"batch.size\", \"16384\");\n    properties.put(\"linger.ms\", \"1\");\n    properties.put(\"buffer.memory\", \"33554432\");\n    properties.put(\"max.block.ms\", \"1000\");\n    properties.put(\"max.request.size\", \"104857600\");\n    properties.put(\"compression.type\", \"gzip\");\n    properties.put(\"compression.level\", \"1\");\n    properties.put(\"batch.size\", \"16384\");\n    properties.put(\"linger.ms\", \"1\");\n    properties.put(\"buffer.memory\", \"33554432\");\n    properties.put(\"max.block.ms\", \"1000\");\n    properties.put(\"max.request.size\", \"104857600\");\n    properties.put(\"compression.type\", \"gzip\");\n    properties.put(\"compression.level\", \"1\");\n    properties.put(\"batch.size\", \"16384\");\n    properties.put(\"linger.ms\", \"1\");\n    properties.put(\"buffer.memory\", \"33554432\");\n    properties.put(\"max.block.ms\", \"1000\");\n    properties.put(\"max.request.size\", \"104857600\");\n    properties.put(\"compression.type\", \"gzip\");\n    properties.put(\"compression.level\", \"1\");\n    properties.put(\"batch.size\", \"16384\");\n    properties.put(\"linger.ms\", \"1\");\n    properties.put(\"buffer.memory\", \"33554432\");\n    properties.put(\"max.block.ms\", \"1000\");\n    properties.put(\"max.request", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "75955378_35", "part": [1, 1], "seq": [1, 1], "prompt": "class ArraySplitOperation implements MultiplexOperation {\n\n  @Override\n  public List<InternalEvent> perform(InternalEvent ievent) throws OperationException {\n    {\n      if (ievent.getEventObj() == null) {\n        throw new OperationException(\"Deserialized object is null\");\n      }\n\n      Object payload;\n      try {\n        payload = ievent.getEventObj().getField(this.path);\n      } catch (FieldNotFoundException e) {\n        throw new OperationException(e);\n      }\n\n      if (!(payload instanceof JsonArray)) {\n        throw new OperationException(\"Payload data is not a JsonArray\");\n      }\n\n      LinkedHashMap<String, String> partitions = ievent.getPartitions();\n\n      JsonArray arr = (JsonArray) payload;\n\n      ArrayList<InternalEvent> output = new ArrayList<InternalEvent>();\n      for (JsonElement elm : arr) {\n        try {\n          JsonObject newObject = elm.getAsJsonObject();\n          for (String field : this.fieldsToKeep) {\n            JsonObject jsonObject = (JsonObject) ievent.getEventObj().getPayload();\n            newObject.add(field, jsonObject.get(field));\n          }\n\n          InternalEvent newEvent = new InternalEvent(newObject.toString(), ievent.getCtx(), ievent.getArrivalTime());\n          DeserializedEvent newDeserEvent = new GenericJsonEvent(newObject);\n          newEvent.setEventObj(newDeserEvent);\n          newEvent.setEventTime(ievent.getEventTime());\n\n          /*\n           * Deep clone the partitions\n           */\n          if (partitions != null) {\n            LinkedHashMap<String, String> newPartitions =\n                new LinkedHashMap<String, String>(partitions.size());\n\n            partitions.entrySet().forEach(kv -> {\n              newPartitions.put(new String(kv.getKey()), new String(kv.getValue()));\n            });\n\n            newEvent.setPartitions(newPartitions);\n          }\n\n          output.add(newEvent);\n        } catch (Exception e) {\n          throw new OperationException(e);\n        }\n      }\n\n      return output;\n    }\n  }\n\n  public  ArraySplitOperation(String path);\n  public  ArraySplitOperation(String path,\n                             List<String> fieldsToKeep);\n\n}\n\nclass ArraySplitOperationTest  {\n\n  @Test(expected = OperationException.class)\n  public void testMissingField()\n      throws JsonSyntaxException, UnsupportedEncodingException, IOException {\n", "reference": "    JsonParser parser = new JsonParser();\n    TestContext t = new TestContext();\n    t.setFunctionName(\"foo\");\n    LambdaContext lctx = new LambdaContext(t);\n\n    JsonElement input = parser.parse(getResourceString(\"array_input.json\"));\n\n    GenericJsonEvent devent = new GenericJsonEvent(input.getAsJsonObject());\n    ArraySplitOperation operation = new ArraySplitOperation(\"$.bar]\");\n\n    InternalEvent ievent = new InternalEvent(\"\", lctx, 123);\n    ievent.setEventObj(devent);\n    ievent.setEventTime(124);\n    List<InternalEvent> events = operation.perform(ievent);\n  }\n\n}", "prediction": "   String json = \"{\\\"a\\\":[{\\\"b\\\":\\\"c\\\"},{\\\"b\\\":\\\"d\\\"}]}\";\n    JsonObject jsonObject = new JsonParser().parse(json).getAsJsonObject();\n    InternalEvent ievent = new InternalEvent(jsonObject.toString(), null, 0);\n\n    ArraySplitOperation op = new ArraySplitOperation(\"a.b\");\n    op.perform(ievent);\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "77110232_1", "part": [1, 1], "seq": [1, 1], "prompt": "class Buffer {\n\n    char charAt(int pos) {\n        int seg = pos / segmentLen;\n        int off = pos % segmentLen;\n\n        int index = begins[seg] + off;\n        return buf.charAt(index);\n    }\n\n      Buffer(CharSequence sb, int segmentLen, long seed);\n\n     List<Integer> segments(int from, int end);\n     CharSequence subSequence(int from, int end);\n\n    static String lng;\n\n}\n\nclass BufferTest {\n\n    static String lng;\n\n    @Test public void firstFailure() {\n", "reference": "        long seed = 1394639167285L;\n        \n        Buffer b = new Buffer(lng, 3, seed);\n\n        StringBuilder recover = new StringBuilder();\n        for (int i = 0; i < lng.length(); i++) {\n            recover.append(b.charAt(i));\n        }\n        \n        assertEquals(recover.toString(), lng);\n    }\n\n}", "prediction": "        String s = lng;\n        int len = s.length();\n        int segmentLen = 10;\n        Buffer buf = new Buffer(s, segmentLen, 0);\n        for (int i = 0; i < len; i++) {\n            assertEquals(s.charAt(i), buf.charAt(i));\n        }\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "78464881_4", "part": [1, 1], "seq": [1, 1], "prompt": "class SolaceJmsAutoConfigurationBase implements SpringSolJmsConnectionFactoryCloudFactory, SpringSolJmsJndiTemplateCloudFactory {\n\n    @Bean\n    @Override\n    public SolConnectionFactory getSolConnectionFactory() {\n        return getSolConnectionFactory(findFirstSolaceServiceCredentialsImpl());\n    }\n\n      SolaceJmsAutoConfigurationBase(SolaceJmsProperties properties);\n\n    abstract SolaceServiceCredentials findFirstSolaceServiceCredentialsImpl();\n    @Override public abstract List<SolaceServiceCredentials> getSolaceServiceCredentials();\n    @Bean @Override public SolaceServiceCredentials findFirstSolaceServiceCredentials();\n    @Override public SolConnectionFactory getSolConnectionFactory(String id);\n    @Override public SolConnectionFactory getSolConnectionFactory(SolaceServiceCredentials solaceServiceCredentials);\n    @Override @Deprecated public List<SolaceMessagingInfo> getSolaceMessagingInfos();\n    private SolaceServiceCredentials findSolaceServiceCredentialsById(String id);\n     void setProperties(SolaceJmsProperties properties);\n    @Bean @Override public JndiTemplate getJndiTemplate();\n    @Override public JndiTemplate getJndiTemplate(SolaceServiceCredentials solaceServiceCredentials);\n    @Override public JndiTemplate getJndiTemplate(String id);\n\n    private SolaceJmsProperties solaceJmsProperties;\n    private SolaceJmsAutoConfigurationBase jmsAutoConfBase;\n    private SolaceServiceCredentials solaceServiceCredentials;\n    private ObjectMapper objectMapper;\n\n}\n\nclass SolaceJmsAutoConfigurationBaseTest  {\n\n    private SolaceJmsProperties solaceJmsProperties;\n    private SolaceJmsAutoConfigurationBase jmsAutoConfBase;\n    private SolaceServiceCredentials solaceServiceCredentials;\n    private ObjectMapper objectMapper;\n\n    @Test\n    public void testGetSolConnectionFactory() {\n", "reference": "        validateSolConnectionFactory(jmsAutoConfBase.getSolConnectionFactory(), false);\n        disableSolaceServiceCredentials();\n        validateSolConnectionFactory(jmsAutoConfBase.getSolConnectionFactory(), true);\n    }\n\n}", "prediction": "        SolConnectionFactory solConnectionFactory = jmsAutoConfBase.getSolConnectionFactory();\n        assertNotNull(solConnectionFactory);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "78699707_0", "part": [1, 1], "seq": [1, 1], "prompt": "class ReversedCharSequence extends ReverseIndexMapperBase implements ReverseCharSequence {\n\n    @Override\n    public ReversedCharSequence subSequence(int start, int end) {\n        if (start < 0 || end > length())\n            throw new IndexOutOfBoundsException(\"[\" + start + \", \" + end + \") not in [0,\" + length() + \"]\");\n        final int startIndex = mapBoundary(end);\n        final int endIndex = startIndex + end - start;\n        return startIndex == myStartIndex && endIndex == myEndIndex ? this : new ReversedCharSequence(myChars, startIndex, endIndex);\n    }\n\n    @SuppressWarnings(\"WeakerAccess\") private  ReversedCharSequence(CharSequence chars, int start, int end);\n\n    @Override public CharSequence getReversedChars();\n    public int getStartIndex();\n    @Override public IndexMapper getIndexMapper();\n    @Override public int getEndIndex();\n    @Override public int length();\n    @Override public char charAt(int index);\n    @Override public String toString();\n    @Override public boolean equals(Object o);\n    @Override public int hashCode();\n    public static ReversedCharSequence of(final CharSequence chars);\n    public static ReversedCharSequence of(final CharSequence chars, final int start);\n    public static ReversedCharSequence of(final CharSequence chars, final int start, final int end);\n\n}\n\nclass ReversedCharSequenceTest {\n\n    @Test\n    public void subSequence() throws Exception {\n", "reference": "        CharSequence orig = \"abcdef\";\n        CharSequence reved = \"fedcba\";\n        ReversedCharSequence test = (ReversedCharSequence) ReversedCharSequence.of(orig);\n\n        int iMax = orig.length();\n        for (int i = 0; i < iMax; i++) {\n            for (int j = iMax - i - 1; j >= 0 && j >= i; j--) {\n                assertEquals(\"subSequence(\" + i + \",\" + j + \")\", reved.subSequence(i, j), test.subSequence(i, j).toString());\n                assertEquals(\"reverse.of(subSequence(\" + i + \",\" + j + \"))\", orig.subSequence(test.mapIndex(j) + 1, test.mapIndex(j) + 1 + j - i), ReversedCharSequence.of(test.subSequence(i, j)).toString());\n                assertEquals(\"subSequence(\" + i + \",\" + j + \").hashCode()\", reved.subSequence(i, j).hashCode(), test.subSequence(i, j).hashCode());\n                assertEquals(\"subSequence(\" + i + \",\" + j + \").equals()\", true, test.subSequence(i, j).equals(reved.subSequence(i, j)));\n            }\n        }\n    }\n\n}", "prediction": "        final ReversedCharSequence reversed = ReversedCharSequence.of(\"abcdef\");\n        assertEquals(\"abcdef\", reversed.toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 6).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 7).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 8).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 9).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 10).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 11).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 12).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 13).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 14).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 15).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 16).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 17).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 18).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 19).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 20).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 21).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 22).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 23).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 24).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 25).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 26).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 27).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 28).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 29).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 30).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 31).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 32).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 33).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 34).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 35).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 36).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 37).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 38).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 39).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 40).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 41).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 42).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 43).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 44).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 45).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 46).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 47).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 48).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 49).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 50).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 51).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 52).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 53).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 54).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 55).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 56).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 57).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 58).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 59).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 60).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 61).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 62).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 63).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 64).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 65).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 66).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 67).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 68).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 69).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 70).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 71).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 72).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 73).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 74).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 75).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 76).toString());\n        assertEquals(\"abcdef\", reversed.subSequence(0, 77).toString());\n        assertEquals(\"abc", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "78797738_0", "part": [1, 1], "seq": [1, 1], "prompt": "class CtxController {\n\n    @RequestMapping(\"/\")\n    @ResponseBody\n    public String index() {\n        StringBuilder sb = new StringBuilder(\"<html><body>\");\n\n        sb.append(INTRO);\n\n        String[] beanNames = ctx.getBeanDefinitionNames();\n        Arrays.sort(beanNames);\n        for (String beanName : beanNames) {\n            sb.append(\"</br>\").append(beanName);\n        }\n        sb.append(\"</body></htm>\");\n        return sb.toString();\n    }\n\n    @RequestMapping(\"/home\") public String home(ModelMap model);\n\n    @Autowired CtxController ctxController;\n    private ModelMap model;\n\n}\n\nclass CtxControllerTest {\n\n    @Autowired CtxController ctxController;\n    private ModelMap model;\n\n    @Test\n    public void textIndex() {\n", "reference": "        String result = ctxController.index();\n        assertNotNull(result);\n        assertTrue(result.contains(CtxController.INTRO));\n    }\n\n}", "prediction": "        String result = ctxController.index();\n        assertThat(result, containsString(\"home\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "80398085_0", "part": [1, 1], "seq": [1, 1], "prompt": "class SharedPreferencesHelper {\n\n    public boolean saveSortBy(int sortBy) {\n        SharedPreferences.Editor editor = mSharedPreferences.edit();\n        editor.putInt(STATE_CURRENT_SORT, sortBy);\n        return editor.commit();\n    }\n\n    public  SharedPreferencesHelper(SharedPreferences sharedPreferences);\n\n    public int getSortBy();\n    public boolean imageUploading(String itemId);\n    public void setImageUploading(String itemId);\n    public void removeImageUploading(String itemId);\n\n    private SharedPreferencesHelper mMockSharedPreferencesHelper;\n    private SharedPreferencesHelper mMockBrokenSharedPreferencesHelper;\n    @Mock SharedPreferences mMockSharedPreferences;\n    @Mock SharedPreferences mMockBrokenSharedPreferences;\n    @Mock SharedPreferences.Editor mMockEditor;\n    @Mock SharedPreferences.Editor mMockBrokenEditor;\n\n}\n\nclass SharedPreferencesHelperTest {\n\n    private SharedPreferencesHelper mMockSharedPreferencesHelper;\n    private SharedPreferencesHelper mMockBrokenSharedPreferencesHelper;\n    @Mock SharedPreferences mMockSharedPreferences;\n    @Mock SharedPreferences mMockBrokenSharedPreferences;\n    @Mock SharedPreferences.Editor mMockEditor;\n    @Mock SharedPreferences.Editor mMockBrokenEditor;\n\n    @Test\n    public void saveSortByFailed_ReturnsFalse() {\n", "reference": "        boolean success = mMockBrokenSharedPreferencesHelper.saveSortBy(SORT_BY_EXPIRY);\n        assertThat(\"Makes sure writing to a broken SharedPreferencesHelper returns false\", success,\n                is(false));\n    }\n\n}", "prediction": "        when(mMockBrokenEditor.putInt(anyString(), anyInt())).thenReturn(mMockBrokenEditor);\n        when(mMockBrokenEditor.commit()).thenReturn(false);\n        assertFalse(mMockBrokenSharedPreferencesHelper.saveSortBy(1));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "80497637_3", "part": [1, 1], "seq": [1, 1], "prompt": "class UCSClient {\n\n\tpublic Element exec(String command, String... args) {\n\t\treturn exec(command, toMap(args));\n\t}\n\n\tprivate Token refresh(Token token);\n\tpublic void logout();\n\tprotected void forceLogout();\n\tpublic Token getToken();\n\tpublic void logDebug(String message, Element element);\n\tpublic void logInfo(String message, Element element);\n\tpublic List<Element> resolveClass(String classId, boolean inHierarchical);\n\tpublic List<Element> resolveClass(String classId);\n\tpublic Element resolveDn(String dn);\n\tpublic Map<String, String> toMap(String... args);\n\tpublic Element exec(String command, Map<String, String> args);\n\tpublic String getUCSManagerId();\n\tpublic List<Element> resolveChildren(String dn, String classId);\n\n\t@Rule\n\tpublic MockWebServer mockServer;\n\t UCSClient ucs;\n\t String cookie;\n\n}\n\nclass UCSClientTest {\n\n\t@Rule\n\tpublic MockWebServer mockServer;\n\t UCSClient ucs;\n\t String cookie;\n\n\t@Test\n\tpublic void testDummyExchange() {\n", "reference": "\t\tmockServer.enqueue(new MockResponse().setBody(\"<foo response=\\\"yes\\\"> </foo>\"));\n\t\tElement element = ucs.exec(\"foo\", \"fizz\",\"buzz\");\n\t\t\n\t\tAssertions.assertThat(element.getName()).isEqualTo(\"foo\");\n\t\tAssertions.assertThat(element.getAttributeValue(\"response\")).isEqualTo(\"yes\");\n\t}\n\n}", "prediction": "\t\tmockServer.enqueue(new MockResponse().setBody(\"dummy\"));\n\t\tassertEquals(\"dummy\", ucs.exec(\"dummy\").getTextContent());\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "80868140_26", "part": [1, 1], "seq": [1, 1], "prompt": "class LoessInterpolator {\n\n\tDouble smoothOnePoint(final double x, final int left, final int right) {\n\n\t\t// Ordinarily, one doesn't do linear regression one x-value at a time, but LOESS does since\n\t\t// each x-value will typically have a different window. As a result, the weighted linear regression\n\t\t// is recast as a linear operation on the input data, weighted by this.fWeights.\n\n\t\tState state = computeNeighborhoodWeights(x, left, right);\n\n\t\tif (state == State.WEIGHTS_FAILED)\n\t\t\treturn null;\n\n\t\tif (state == State.LINEAR_OK)\n\t\t\tupdateWeights(x, left, right);\n\n\t\tdouble ys = 0.0;\n\t\tfor (int i = left; i <= right; ++i)\n\t\t\tys += fWeights[i] * fData[i];\n\n\t\treturn ys;\n\t}\n\n\t  LoessInterpolator(int width, double[] data, double[] externalWeights);\n\n\tabstract void updateWeights(double x, int left, int right);\n\tprivate State computeNeighborhoodWeights(double x, int left, int right);\n\n}\n\nclass LoessInterpolatorTest {\n\n\t@Test\n\tpublic void constantDataExtrapolatesConstantValues() {\n", "reference": "\n\t\tdouble[] data = createConstantDataArray();\n\n\t\tfor (int degree = 0; degree < 3; ++degree) {\n\t\t\tLoessInterpolator loess = new LoessInterpolator.Builder().setWidth(7).setDegree(degree).interpolate(data);\n\n\t\t\tDouble y = loess.smoothOnePoint(-100, 0, data.length - 1);\n\t\t\tassertNotNull(y);\n\t\t\tassertEquals(\"Bad value extrapolating left\", data[0], y, 3.0e-9);\n\n\t\t\ty = loess.smoothOnePoint(1000.0, 0, data.length - 1);\n\t\t\tassertNotNull(y);\n\t\t\tassertEquals(\"Bad value extrapolating right\", data[0], y, 3.0e-9);\n\t\t}\n\t}\n\n}", "prediction": "\t\tdouble[] data = { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 };\n\t\tLoessInterpolator interpolator = new LoessInterpolator(3, data, null);\n\t\tdouble[] result = interpolator.smooth(0.0, 10.0, 10);\n\t\tassertArrayEquals(data, result, 0.0);\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "81092547_0", "part": [1, 1], "seq": [1, 1], "prompt": "class CitySimulation extends AbstractSimulation {\n\n    WorldState getWorldState(){\n        return world;\n    }\n\n    @Override public Map<String, SimStart> init(int steps, JSONObject config, Set<TeamConfig> matchTeams);\n    @Override public Map<String, RequestAction> preStep(int stepNo);\n    private List<DumpData> buildDumpData();\n    private List<WellData> buildWellData();\n    private List<ChargingStationData> buildChargingStationData();\n    private List<WorkshopData> buildWorkshopData();\n    private List<ShopData> buildShopData();\n    private List<ResourceNodeData> buildResourceNodeData();\n    private Map<String,EntityData> buildEntityData();\n    @Override public void step(int stepNo, Map<String, Action> actions);\n    @Override public Map<String, SimEnd> finish();\n    @Override public JSONObject getResult();\n    private Map<TeamState, Integer> getRankings();\n    @Override public String getName();\n    @Override public DynamicWorldData getSnapshot();\n    @Override public StaticWorldData getStaticData();\n    @Override public void handleCommand(String[] command);\n\n    private static CitySimulation sim;\n    private static int seed;\n    private static int agentsPerTeam;\n    private static int steps;\n    private static int step;\n\n}\n\nclass CitySimulationTest {\n\n    private static CitySimulation sim;\n    private static int seed;\n    private static int agentsPerTeam;\n    private static int steps;\n    private static int step;\n\n    @Test\n    public void chargingStationsWork(){\n", "reference": "        //there is at least one charging station in the simulation\n        assert !sim.getWorldState().getChargingStations().isEmpty();\n    }\n\n}", "prediction": "        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step, Collections.emptyMap());\n        sim.step(step,", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "82291828_29", "part": [1, 1], "seq": [1, 1], "prompt": "class Weights {\n\n    public static double[] buildRleWeights(List<Number> weightList, int limit) {\n        double[] weights = new double[weightList.size() + (weightList.size() / (limit * 2))];\n\n        double latestValue = Double.POSITIVE_INFINITY;\n        int counter = 0;\n\n        int i = 0;\n        for (Number value : weightList) {\n            if (value.doubleValue() == latestValue || (Double.isNaN(latestValue) && Double.isNaN(value.doubleValue()))) {\n                counter++;\n            } else {\n                if (counter > limit) {\n                    weights[i++] = Double.POSITIVE_INFINITY;\n                    weights[i++] = counter;\n                    weights[i++] = latestValue;\n                    counter = 1;\n                } else {\n                    if (counter > 0) {\n                        for (int j = 0; j < counter; j++) {\n                            weights[i++] = latestValue;\n                        }\n                    }\n                    counter = 1;\n                }\n                latestValue = value.doubleValue();\n            }\n        }\n\n        if (counter > limit) {\n            weights[i++] = Double.POSITIVE_INFINITY;\n            weights[i++] = counter;\n            weights[i++] = latestValue;\n        } else {\n            for (int j = 0; j < counter; j++) {\n                weights[i++] = latestValue;\n            }\n        }\n\n        return Arrays.copyOf(weights, i);\n    }\n\n    public static double[] buildWeights(List<Number> weightList);\n    public static double[] buildRleWeights(double[] weightList, int limit);\n\n}\n\nclass WeightsTest {\n\n    @Test\n    public void rleWithMoreThanOneRepeatedValue() throws Exception {\n", "reference": "        Number[] values = {2.0, 2.0, 4.0, 4.0, 6.0, 6.0};\n        List<Number> weightList = Arrays.asList(values);\n        double[] actuals = Weights.buildRleWeights(weightList, 1);\n        System.out.println(\"actuals = \" + Arrays.toString(actuals));\n        assertArrayEquals(new double[]{\n                Double.POSITIVE_INFINITY, 2.0, 2.0,\n                Double.POSITIVE_INFINITY, 2.0, 4.0,\n                Double.POSITIVE_INFINITY, 2.0, 6.0}, actuals, 0.01);\n    }\n\n}", "prediction": "        double[] weights = Weights.buildRleWeights(Arrays.asList(1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "82448747_0", "part": [1, 1], "seq": [1, 1], "prompt": "class UncommonLetterMap {\n\n    public String getMinifiedWord(String word) {\n        Queue<LetterFreqPair> mostInfreq = new LinkedList<LetterFreqPair>();\n        PriorityQueue<LetterFreqPair> infreqHeap = new PriorityQueue<LetterFreqPair>();\n        for (char letter : word.toCharArray()) {\n            letter = this.sofitMap.containsKey(letter) ? this.sofitMap.get(letter) : letter;\n            int ind = letter_freq_list.indexOf(letter);\n            if (ind != -1) {\n                if (infreqHeap.size() <= this.len_min_word || ind > infreqHeap.peek().freq) {\n                    LetterFreqPair lfp = new LetterFreqPair(letter, ind);\n                    mostInfreq.add(lfp);\n                    infreqHeap.add(lfp);\n                }\n                if (mostInfreq.size() > this.len_min_word) {\n                    mostInfreq.remove(infreqHeap.poll());\n                }\n            }\n        }\n\n        String out = \"\";\n        for (LetterFreqPair lfp : mostInfreq) {\n            out += lfp.getLetter();\n        }\n\n        return out;\n    }\n\n    public  UncommonLetterMap(int len_min_word);\n\n}\n\nclass UncommonLetterMapTest {\n\n    @Test\n    public void TestGetMinifiedWord() throws Exception {\n", "reference": "        UncommonLetterMap ulm = new UncommonLetterMap(3);\n        assertEquals(\"\u05d0\u05d1\u05d2\",ulm.getMinifiedWord(\"\u05d0\u05d1\u05d2\"));\n        assertEquals(\"\u05d1\u05d2\u05d3\",ulm.getMinifiedWord(\"\u05d0\u05d1\u05d2\u05d3\"));\n        assertEquals(\"\u05d3\u05d2\u05d1\",ulm.getMinifiedWord(\"\u05d3\u05d2\u05d1\u05d0\"));\n        assertEquals(\"\u05d3\u05d2\u05d1\",ulm.getMinifiedWord(\"\u05d3\u05d2\u05d0\u05d1\"));\n        assertEquals(\"\u05d2\u05d3\u05d1\",ulm.getMinifiedWord(\"\u05d2\u05d0\u05d3\u05d1\"));\n        assertEquals(\"\u05e6\u05e6\u05e6\",ulm.getMinifiedWord(\"\u05d0\u05e7\u05e8\u05d0\u05dc\u05d7\u05d3\u05d2\u05da\u05db\u05dc\u05d7\u05e6\u05e9\u05db\u05d3\u05d2\u05db\u05e6\u05d3\u05d2\u05db\u05e9\u05d3\u05d2\u05db\u05e9\u05d3\u05d2\u05db\u05e6\u05e6\u05d2\u05db\u05e9\u05d3\u05d2\u05db\u05e6\"));\n        assertEquals(\"\u05d3\u05d2\",ulm.getMinifiedWord(\"\u05d3\u05d2\"));\n        assertEquals(\"\",ulm.getMinifiedWord(\"\"));\n        assertEquals(\"\u05d9\",ulm.getMinifiedWord(\"\u05d9\"));\n    }\n\n}", "prediction": "        UncommonLetterMap u = new UncommonLetterMap(2);\n        assertEquals(\"a\", u.getMinifiedWord(\"a\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"ab\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"ba\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abba\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaaaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaaaaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaaaaaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaaaaaaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaaaaaaaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaaaaaaaaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaaaaaaaaaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaaaaaaaaaaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaaaaaaaaaaaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaaaaaaaaaaaaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaaaaaaaaaaaaaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaaaaaaaaaaaaaaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaaaaaaaaaaaaaaaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n        assertEquals(\"ab\", u.getMinifiedWord(\"abbaaaaa", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "82601803_0", "part": [1, 1], "seq": [1, 1], "prompt": "class SimpleTrial {\n\n    public boolean isTrialPeriodFinished() {\n        return new Date().getTime() >= trialStartTimestamp + trialDurationInMilliseconds;\n    }\n\n    public  SimpleTrial(Context context, Config config);\n\n    public Date getTrialStartDate();\n    private void persistTrialStartTimestamp();\n    public void updateTrialStartDate(Date trialStartDate);\n    private long calculateTrialStartTimestamp();\n\n}\n\nclass SimpleTrialTest {\n\n    @Test\n    public void oldTimestampMustCauseTrialToBeOver() {\n", "reference": "        Context context = mock(Context.class);\n        TrialFactor factor = mock(TrialFactor.class);\n        when(factor.readTimestamp(any(Context.class))).thenReturn(123L);\n\n        SimpleTrial trial = new SimpleTrial(context, new SimpleTrial.Config().factors(factor));\n\n        verify(factor).persistTimestamp(123L, context);\n        assertTrue(trial.isTrialPeriodFinished());\n    }\n\n}", "prediction": "        SimpleTrial trial = new SimpleTrial(context, config);\n        trial.updateTrialStartDate(new Date(System.currentTimeMillis() - 1000000000));\n        assertTrue(trial.isTrialPeriodFinished());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "83193705_20", "part": [1, 1], "seq": [1, 1], "prompt": "class BlueTapeDsl {\n\n    public static BindingFunction onClick(@Nullable View.OnClickListener listener) {\n        return view -> view.setOnClickListener(listener);\n    }\n\n    public static BindingFunction composite(@NonNull BindingFunction... functions);\n    public static BindingFunction id(int id, @NonNull BindingFunction... functions);\n    public static BindingFunction text(String text);\n    public static BindingFunction textResource(@StringRes int stringId);\n    public static BindingFunction textColor(@ColorInt int color);\n    public static BindingFunction visible(boolean visible);\n    public static BindingFunction visibility(@Visibility int visibility);\n    public static BindingFunction enabled(boolean enabled);\n    public static BindingFunction checked(boolean checked);\n    public static BindingFunction imageDrawable(@Nullable Drawable drawable);\n    public static BindingFunction imageResource(@DrawableRes int drawableId);\n    public static BindingFunction imageBitmap(@Nullable Bitmap bitmap);\n    @SuppressWarnings(\"deprecation\") public static BindingFunction backgroundDrawable(@Nullable Drawable drawable);\n    public static BindingFunction backgroundResource(@DrawableRes int drawableId);\n    public static BindingFunction onClick(@Nullable ShortenedOnClickListener listener);\n    public static BindingFunction onLongClick(@Nullable View.OnLongClickListener listener);\n    public static BindingFunction onTouch(@Nullable View.OnTouchListener listener);\n    public static BindingFunction onToggle(@Nullable CompoundButton.OnCheckedChangeListener listener);\n    public static BindingFunction onTextChanged(@Nullable OnTextChangedListener listener);\n    public static BindingFunction pass();\n\n    @Mock Context context;\n    @Mock View view;\n    @Mock BindingFunction functionA;\n    @Mock BindingFunction functionB;\n\n}\n\nclass BlueTapeDslTest {\n\n    @Mock Context context;\n    @Mock View view;\n    @Mock BindingFunction functionA;\n    @Mock BindingFunction functionB;\n\n    @Test\n    public void onClick_Shortened() throws Exception {\n", "reference": "        // Given\n        ShortenedOnClickListener listener = mock(ShortenedOnClickListener.class);\n\n        ArgumentCaptor<View.OnClickListener> listenerCaptor = ArgumentCaptor.forClass(View.OnClickListener.class);\n\n        // When\n        BlueTapeDsl\n                .onClick(listener)\n                .bind(view);\n\n        verify(view).setOnClickListener(listenerCaptor.capture());\n        listenerCaptor.getValue().onClick(view);\n\n        // Then\n        verify(listener).onClick();\n    }\n\n}", "prediction": "        when(functionA.apply(view)).thenReturn(view);\n        when(functionB.apply(view)).thenReturn(view);\n\n        BindingFunction onClick = BlueTapeDsl.onClick(new ShortenedOnClickListener() {\n            @Override\n            public void onClick(View view) {\n                functionA.apply(view);\n                functionB.apply(view);\n            }\n        });\n\n        onClick.apply(view);\n\n        verify(functionA).apply(view);\n        verify(functionB).apply(view);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "84286382_23", "part": [1, 1], "seq": [1, 1], "prompt": "class PopUpCoachMarkPresenter {\n\n    protected void setGravityForCoachMarkText(int textAlignmentForPopUpText) {\n        switch (textAlignmentForPopUpText) {\n            case CoachMarkTextGravity.CENTER:\n                mPresentation.setUpGravityForCoachMarkText(CoachMarkTextGravity.CENTER);\n                break;\n            case CoachMarkTextGravity.LEFT:\n                mPresentation.setUpGravityForCoachMarkText(CoachMarkTextGravity.LEFT);\n                break;\n            case CoachMarkTextGravity.RIGHT:\n                mPresentation.setUpGravityForCoachMarkText(CoachMarkTextGravity.RIGHT);\n                break;\n        }\n    }\n\n    public  PopUpCoachMarkPresenter(final IStringResourceProvider stringResourceProvider,\n                                   final IDimensionResourceProvider dimensionResourceProvider,\n                                   final ITypeFaceProvider typeFaceProvider,\n                                   final IScreenInfoProvider screenInfoProvider);\n\n    public void onCreate(CoachMarkBuilder coachMarkBuilder);\n    public void onCreateView(IPopUpCoachMarkPresentation popUpCoachMarkPresentation);\n    public void onViewCreated();\n    public void onDestroyView();\n    public void onDestroy();\n    public void onOkButtonClicked();\n    public void onShimClicked();\n    protected void displayCoachMark();\n    protected void setMessageForCoachMarkText(@StringRes int messageForCoachMarkTextRes);\n    protected void setTypeFaceForDismissButton(@Nullable String fontFileForDismissButton);\n    protected void setTypeFaceForCoachMarkText(@Nullable String fontFileForPopUpText);\n    protected void setNotchDisplayEdge(int position,\n                                     int anchorTopY,\n                                     int anchorBottomY,\n                                     int anchorTopX,\n                                     CoachMarkPixelInfo coachMarkDimenInPixel);\n    protected int getMarginLeftForNotch(double notchPosition, int popUpWidth, int notchDimen);\n    protected int getMarginTopForNotch(double notchPosition, int popUpHeight, int notchDimen);\n    protected void detectAndCreateShimOutViews(@Nullable List<InfoForViewToMask> infoForViewToMaskList);\n    @PopUpPosition protected int findCoachMarkTextPopUpDisplayPosition(Point anchorTop,\n                                                      Point anchorBottom,\n                                                      @PopUpPosition int defaultPopUpPosition,\n                                                      CoachMarkPixelInfo coachMarkDimenInPixel);\n    protected void setImageParamsAndPosition(Point anchorTop, Point anchorBottom,\n                                           int imageWidth, int imageHeight,\n                                           @ColorRes int backGroundTintForImage,\n                                           @DrawableRes int imageDrawableRes);\n    protected void showCoachMark(@DialogDismissButtonPosition int dismissButtonPosition,\n                               @PopUpPosition int popUpPosition);\n    @PopUpPosition protected int getDisplayPosition(Point viewCenterPoint,\n                                   @PopUpPosition int defaultPopUpPosition,\n                                   CoachMarkPixelInfo coachMarkDimenInPixel);\n    protected boolean checkIfLeftPossible(Point viewCenterPoint,\n                                        CoachMarkPixelInfo coachMarkDimenInPixel);\n    protected boolean checkIfRightPossible(Point viewCenterPoint,\n                                         CoachMarkPixelInfo coachMarkDimenInPixel);\n    protected boolean checkIfTopPossible(Point viewCenterPoint,\n                                       CoachMarkPixelInfo coachMarkDimenInPixel);\n    protected boolean checkIfBottomPossible(Point viewCenterPoint,\n                                          CoachMarkPixelInfo coachMarkDimenInPixel);\n    @PopUpPosition protected int getCorrectPositionOfCoachMarkIfDefaultFails(Point viewCenterPoint,\n                                                            CoachMarkPixelInfo coachMarkDimenInPixel);\n    protected CoachMarkPixelInfo createCoachMarkPixelInfo();\n    protected int getActualTopMargin(int centerTopY, CoachMarkPixelInfo coachMarkDimenInPixel);\n    protected int getActualLeftMargin(int anchorTopX, CoachMarkPixelInfo coachMarkDimenInPixel);\n\n    @Mock CoachMarkBuilder mCoachMarkBuilder;\n    @Mock IPopUpCoachMarkPresentation mPopUpCoachMarkPresentation;\n    @Mock IStringResourceProvider mStringResourceProvider;\n    @Mock IDimensionResourceProvider mDimensionResourceProvider;\n    @Mock IScreenInfoProvider mScreenInfoProvider;\n    @Mock ITypeFaceProvider mTypeFaceProvider;\n    @Mock\n    @StringRes int mockedStringRes;\n    @Mock\n    @ColorRes int mockedColorRes;\n    @Mock\n    @DrawableRes int mockedDrawableRes;\n    @Mock CoachMarkLayoutMargin mCoachMarkLayoutMargin;\n    @Mock ImageLayoutInformation mImageLayoutInformation;\n    @Mock\n    @DimenRes int mockedDimenRes;\n    private PopUpCoachMarkPresenter mPopUpCoachMarkPresenter;\n    private CoachMarkPixelInfo mCoachMarkPixelInfo;\n\n}\n\nclass PopUpCoachMarkPresenterTest {\n\n    @Mock CoachMarkBuilder mCoachMarkBuilder;\n    @Mock IPopUpCoachMarkPresentation mPopUpCoachMarkPresentation;\n    @Mock IStringResourceProvider mStringResourceProvider;\n    @Mock IDimensionResourceProvider mDimensionResourceProvider;\n    @Mock IScreenInfoProvider mScreenInfoProvider;\n    @Mock ITypeFaceProvider mTypeFaceProvider;\n    @Mock\n    @StringRes int mockedStringRes;\n    @Mock\n    @ColorRes int mockedColorRes;\n    @Mock\n    @DrawableRes int mockedDrawableRes;\n    @Mock CoachMarkLayoutMargin mCoachMarkLayoutMargin;\n    @Mock ImageLayoutInformation mImageLayoutInformation;\n    @Mock\n    @DimenRes int mockedDimenRes;\n    private PopUpCoachMarkPresenter mPopUpCoachMarkPresenter;\n    private CoachMarkPixelInfo mCoachMarkPixelInfo;\n\n    @Test\n    public void setGravityForCoachMarkTextCenterGravityTest() {\n", "reference": "        mPopUpCoachMarkPresenter.setGravityForCoachMarkText(CoachMarkTextGravity.LEFT);\n\n        Mockito.verify(mPopUpCoachMarkPresentation, Mockito.times(1))\n                .setUpGravityForCoachMarkText(CoachMarkTextGravity.LEFT);\n        Mockito.verifyNoMoreInteractions(mPopUpCoachMarkPresentation);\n    }\n\n}", "prediction": "        mPopUpCoachMarkPresenter.setGravityForCoachMarkText(CoachMarkTextGravity.CENTER);\n        verify(mPopUpCoachMarkPresentation).setUpGravityForCoachMarkText(CoachMarkTextGravity.CENTER);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "84313991_60", "part": [1, 1], "seq": [1, 1], "prompt": "class StandardFunctionFactory {\n\n  public static StandardFunction getByName(String functionName) {\n    StandardFunction standardFunction = ALL.get(functionName.toLowerCase(Locale.ENGLISH));\n    return standardFunction != null ? standardFunction : new UnknownFunction(functionName);\n  }\n\n  private  StandardFunctionFactory();\n\n  public static List<StandardFunction> getAll();\n\n}\n\nclass StandardFunctionFactoryTest {\n\n  @Test\n  public void should_return_a_valid_rotatex_function_object_mix_uppercase_lowercase_test() {\n", "reference": "    StandardFunction function = StandardFunctionFactory.getByName(\"rotateX\");\n    assertEquals(Rotatex.class, function.getClass());\n    assertEquals(function.getName(), \"rotatex\");\n    assertEquals(function.getLinks().size(), 1);\n    assertEquals(function.getLinks().get(0), \"https://drafts.csswg.org/css-transforms/#three-d-transform-functions\");\n    assertEquals(function.isExperimental(), false);\n    assertEquals(function.isObsolete(), false);\n  }\n\n}", "prediction": "    StandardFunction rotatex = StandardFunctionFactory.getByName(\"ROTATEX\");\n    assertThat(rotatex).isInstanceOf(RotateX.class);\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "84487370_45", "part": [1, 1], "seq": [1, 1], "prompt": "class ELTComponentPropertyAdapter implements IPropertyAdapter {\n\n\t@Override\n\tpublic void transform() throws ELTComponentPropertyAdapter.EmptyComponentPropertiesException {\n\t\tvalidateRawProperties();\n\t\tfor(hydrograph.ui.common.component.config.Property property : rawProperties){\n\t\t\tProperty tempProperty = transformProperty(property);\n\t\t\tthis.properties.add(tempProperty);\n\t\t} \n\t}\n\n\tpublic  ELTComponentPropertyAdapter(List<hydrograph.ui.common.component.config.Property> rawProperties);\n\n\tprivate void validateRawProperties();\n\tprivate Property transformProperty(\n\t\t\thydrograph.ui.common.component.config.Property property);\n\t@Override public ArrayList<Property> getProperties();\n\n}\n\nclass ELTComponentPropertyAdapterTest {\n\n\t@Test(expected = ELTComponentPropertyAdapter.EmptyComponentPropertiesException.class)\n\tpublic void itShouldThrowEmptyComponentPropertiesExceptionIfRawPropertiesAreEmptyWhileTransformation() {\n", "reference": "\t\t//Given\n\t\t\n\t\t//when\n\t\t\n\t\t\tELTComponentPropertyAdapter eltComponentPropertyAdapter = new ELTComponentPropertyAdapter(null);\n\t\t\teltComponentPropertyAdapter.transform();\t\n\t\t\n\t\t\n\t\t//Then - expect EmptyComponentPropertiesException\n\t}\n\n}", "prediction": "\t\tELTComponentPropertyAdapter adapter = new ELTComponentPropertyAdapter(new ArrayList<hydrograph.ui.common.component.config.Property>());\n\t\tadapter.transform();\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "84985373_1", "part": [1, 1], "seq": [1, 1], "prompt": "class Particle {\n\n\tpublic Particle() {\n\t\tthis.initParticleWithMass(0.0, 0., 0., 0., 0., 0., 0.);\n\t}\n\n\tpublic  Particle();\n\tpublic  Particle(Particle p);\n\tpublic  Particle(int pid, double px, double py, double pz, double vx, double vy, double vz);\n\tpublic  Particle(int pid, double px, double py, double pz);\n\tpublic  Particle(int pid, double mass, byte charge, double px, double py, double pz, double vx, double vy, double vz);\n\n\tpublic static Particle createWithMassCharge(double mass, int charge ,double px, double py, double pz, double vx, double vy, double vz);\n\tpublic static Particle createWithPid(int pid ,double px, double py, double pz, double vx, double vy, double vz);\n\tpublic final void initParticleWithMass(double mass, double px, double py, double pz, double vx, double vy, double vz);\n\tpublic final void initParticle(int pid, double px, double py, double pz, double vx, double vy, double vz);\n\tpublic void setP(double mom);\n\tpublic void setTheta(double theta);\n\tpublic void changePid(int pid);\n\tpublic void setParticleWithMass(double mass, byte charge, double px, double py, double pz, double vx, double vy, double vz);\n\tpublic void setVector(int pid, double px, double py, double pz, double vx, double vy, double vz);\n\tpublic double px();\n\tpublic double py();\n\tpublic double pz();\n\tpublic double p();\n\tpublic double theta();\n\tpublic double phi();\n\tpublic double e();\n\tpublic double vx();\n\tpublic double vy();\n\tpublic double vz();\n\tpublic void clearProperties();\n\tpublic void setVector(int pid, Vector3 nvect, Vector3 nvert);\n\tpublic double euclideanDistance(Particle part);\n\tpublic double cosTheta(Particle part);\n\t void initParticleWithMassSquare(double mass2, double px, double py, double pz, double vx, double vy, double vz);\n\tpublic void initParticleWithPidMassSquare(int pid, int charge, double mass2, double px, double py, double pz, double vx, double vy,\n\t        double vz);\n\tpublic void setVector(LorentzVector nvec, Vector3 nvert);\n\tpublic double mass();\n\tpublic double mass2();\n\tpublic int charge();\n\tpublic int pid();\n\tpublic int gid();\n\tpublic LorentzVector vector();\n\tpublic Vector3 vertex();\n\tpublic double getProperty(String pname);\n\tpublic Particle inFrame(Particle parent);\n\tpublic double get(String pname);\n\tpublic boolean hasProperty(String pname);\n\tpublic void setProperty(String pname, double value);\n\tpublic String propertyString();\n\tpublic String toLundString();\n\t@Override public String toString();\n\tpublic void copyParticle(Particle part);\n\tpublic void copy(Particle part);\n\tpublic void combine(Particle cpart, int sign);\n\tpublic Vector3 particleDoca(Particle cpart);\n\n}\n\nclass ParticleTest {\n\n\t@Test\n\tpublic void testParticle() {\n", "reference": "\t\tParticle p = new Particle(11, 0.0, 0.0, 11.0, 0.0, 0.0, 0.0);\n\t\tassertEquals(p.mass(), 0.0005, 1e-4);\n\t\tassertEquals(p.mass2(), 0.0005*0.0005, 1e-4);\n\t\tassertEquals(p.charge(), -1);\n\t\tassertEquals(p.px(), 0.0, 1e-6);\n\t\tassertEquals(p.py(), 0.0, 1e-6);\n\t\tassertEquals(p.pz(), 11.0, 1e-6);\n\t\tassertEquals(p.p(), 11.0, 1e-6);\n\t\tassertEquals(p.theta(), 0.0, 1e-6);\n\t\tassertEquals(p.vertex().x(), 0.0, 1e-6);\n\t\tassertEquals(p.vertex().y(), 0.0, 1e-6);\n\t\tassertEquals(p.vertex().z(), 0.0, 1e-6);\n\t\tassertEquals(p.vx(), 0.0, 1e-6);\n\t\tassertEquals(p.vy(), 0.0, 1e-6);\n\t\tassertEquals(p.vz(), 0.0, 1e-6);\n\n\t\tParticle p2 = new Particle(p);\n\t\tassertEquals(p2.mass(), 0.0005, 1e-4);\n\t\tassertEquals(p2.mass2(), 0.0005*0.0005, 1e-4);\n\t\tassertEquals(p2.charge(), -1);\n\t\tassertEquals(p2.px(), 0.0, 1e-6);\n\t\tassertEquals(p2.py(), 0.0, 1e-6);\n\t\tassertEquals(p2.pz(), 11.0, 1e-6);\n\t\tassertEquals(p2.p(), 11.0, 1e-6);\n\t\tassertEquals(p2.theta(), 0.0, 1e-6);\n\t\tassertEquals(p2.vertex().x(), 0.0, 1e-6);\n\t\tassertEquals(p2.vertex().y(), 0.0, 1e-6);\n\t\tassertEquals(p2.vertex().z(), 0.0, 1e-6);\n\t\tassertEquals(p2.vx(), 0.0, 1e-6);\n\t\tassertEquals(p2.vy(), 0.0, 1e-6);\n\t\tassertEquals(p2.vz(), 0.0, 1e-6);\n\t}\n\n}", "prediction": "\n\t\tParticle p = new Particle();\n\t\tassertEquals(0, p.pid());\n\t\tassertEquals(0, p.charge());\n\t\tassertEquals(0, p.mass(), 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "87432809_27", "part": [1, 1], "seq": [1, 1], "prompt": "class ForceDriver implements Driver {\n\n    @Override\n    public Connection connect(String url, Properties properties) throws SQLException {\n        if (!acceptsURL(url)) {\n            /*\n             * According to JDBC spec:\n             * > The driver should return \"null\" if it realizes it is the wrong kind of driver to connect to the given URL.\n             * > This will be common, as when the JDBC driver manager is asked to connect to a given URL it passes the URL to each loaded driver in turn.\n             *\n             * Source: https://docs.oracle.com/javase/8/docs/api/java/sql/Driver.html#connect-java.lang.String-java.util.Properties-\n             */\n            return null;\n        }\n        try {\n            Properties connStringProps = getConnStringProperties(url);\n            properties.putAll(connStringProps);\n            ForceConnectionInfo info = new ForceConnectionInfo();\n            info.setUserName(properties.getProperty(\"user\"));\n            info.setPassword(properties.getProperty(\"password\"));\n            info.setSessionId(properties.getProperty(\"sessionId\"));\n            info.setSandbox(resolveSandboxProperty(properties));\n\n            PartnerConnection partnerConnection = ForceService.createPartnerConnection(info);\n            return new ForceConnection(partnerConnection);\n        } catch (ConnectionException | IOException e) {\n            throw new SQLException(e);\n        }\n    }\n\n    private static Boolean resolveSandboxProperty(Properties properties);\n    protected Properties getConnStringProperties(String url);\n    @Override public boolean acceptsURL(String url);\n    @Override public DriverPropertyInfo[] getPropertyInfo(String url, Properties info);\n    @Override public int getMajorVersion();\n    @Override public int getMinorVersion();\n    @Override public boolean jdbcCompliant();\n    @Override public Logger getParentLogger();\n\n    private ForceDriver driver;\n\n}\n\nclass ForceDriverTest {\n\n    private ForceDriver driver;\n\n    @Test\n    public void testConnect_WhenWrongURL() throws  SQLException {\n", "reference": "        Connection connection = driver.connect(\"jdbc:mysql://localhost/test\", new Properties());\n\n        assertNull(connection);\n    }\n\n}", "prediction": "        Connection connection = driver.connect(\"jdbc:wrong\", new Properties());\n        assertNull(connection);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "87583205_0", "part": [1, 1], "seq": [1, 1], "prompt": "class ServerOption implements Serializable {\n\n\tpublic static Gson getGson() {\n\t\tGson gson = new GsonBuilder().\n\t\t\t\tregisterTypeAdapter(ServerOption.class, new ServerOptionParentDeserializer()).\n\t\t\t\texcludeFieldsWithoutExposeAnnotation().\n\t\t\t\tcreate();\n\t\treturn gson;\n\t}\n\n\tpublic  ServerOption();\n\tpublic  ServerOption(final String title);\n\tpublic  ServerOption(final String title, final String summary);\n\n\tpublic ServerOption getParent();\n\tpublic void setParent(ServerOption parent);\n\tpublic String getTitle();\n\tpublic void setTitle(String title);\n\tpublic String getSummary();\n\tpublic void setSummary(String summary);\n\tpublic List<ServerOption> getEnabledOptionList();\n\tpublic List<ServerOption> getOptionList();\n\tpublic void setOptionList(List<ServerOption> optionList);\n\tpublic void addOption(final ServerOption option);\n\tpublic Map<String, Object> getParameterMap();\n\tpublic void setParameterMap(Map<String, Object> parameterMap);\n\tpublic void addParameter(final String key, final Object value);\n\tpublic List<OptionFunction> getFunctionList();\n\tpublic void setFunctionMap(List<OptionFunction> functionList);\n\tpublic void addFunction(final OptionFunction value);\n\tpublic Map<String, Object> getDependsOnMap();\n\tpublic void setDependsOnMap(Map<String, Object> dependsOnMap);\n\tpublic void addDependsOn(final String key, final Object value);\n\tpublic boolean isEnabled();\n\tpublic void setEnabled(boolean isEnabled);\n\tpublic boolean isChecked();\n\tpublic void setChecked(boolean isChecked);\n\tpublic boolean isDefault();\n\tpublic void setDefault(boolean isDefault);\n\tpublic boolean isInHierarchyBelow(ServerOption option);\n\t@Override public String toString();\n\n}\n\nclass ServerOptionTest  {\n\n\t@Test\n\tpublic void testOptionSelectedParametersWithInheritance() throws Exception {\n", "reference": "\t\tURL url = Thread.currentThread().getContextClassLoader().getResource(\"at/rtr/rmbt/util/model/option/test2.json\");\n\t\tFile file = new File(url.getPath());\n\t\tServerOptionContainer options = new ServerOptionContainer(\n\t\t\t\tnew ArrayList<>(Arrays.asList(ServerOption.getGson().fromJson(new FileReader(file), ServerOption.class))));\n\t\t\n\t\tList<ServerOption> list = options.select(options.getRootOptions().get(0));\n\t\tassertNotNull(\"selected option sublist not null\", list);\n\t\t\n\t\tList<ServerOption> subList = options.select(list.get(0));\n\t\tMap<String, Object> paramMap = options.getSelectedParams();\t\t\n\t\tassertNull(\"selected option 0 sublist is null\", subList);\n\t\tassertEquals(\"selected option 0 param 'option'\", \"a1\", paramMap.get(\"option\"));\n\t\tassertNull(\"selected option 0 dropped param 'title'\", paramMap.get(\"title\"));\n\t\tassertEquals(\"selected option 0 params size\", 2, paramMap.size());\n\t\tassertEquals(\"selected option 0 overriden param 'parent_param'\", true, paramMap.get(\"parent_param\"));\n\n\t\tsubList = options.select(list.get(1));\n\t\tparamMap = options.getSelectedParams();\t\t\n\t\tassertNull(\"selected option 1 sublist is null\", subList);\n\t\tassertEquals(\"selected option 1 param 'option'\", \"a2\", paramMap.get(\"option\"));\n\t\tassertNull(\"selected option 1 dropped param 'title'\", paramMap.get(\"title\"));\n\t\tassertEquals(\"selected option 1 params size\", 2, paramMap.size());\n\t\tassertEquals(\"selected option 1 inherited param 'parent_param'\", false, paramMap.get(\"parent_param\"));\n\n\t\tsubList = options.select(list.get(2));\n\t\tparamMap = options.getSelectedParams();\t\t\n\t\tassertNull(\"selected option 2 sublist is null\", subList);\n\t\tassertEquals(\"selected option 2 param 'option'\", \"a3\", paramMap.get(\"option\"));\n\t\tassertEquals(\"selected option 2 params size\", 4, paramMap.size());\n\t\tassertEquals(\"selected option 2 param 'titles'\", \"a3\", paramMap.get(\"titles\"));\n\t\tassertEquals(\"selected option 2 inherited param 'parent_param'\", false, paramMap.get(\"parent_param\"));\n\t\t\n\t\tsubList = options.select(list.get(3));\n\t\tparamMap = options.getSelectedParams();\t\t\n\t\tassertNull(\"selected option 3 sublist is null\", subList);\n\t\tassertEquals(\"selected option 3 params size\", 1, paramMap.size());\n\t\tassertEquals(\"selected option 3 inherited param 'parent_param'\", false, paramMap.get(\"parent_param\"));\n\t}\n\n}", "prediction": "\t\tServerOption option = new ServerOption(\"test\");\n\t\toption.addParameter(\"test\", \"test\");\n\t\toption.addParameter(\"test2\", \"test2\");\n\t\toption.addParameter(\"test3\", \"test3\");\n\t\toption.addParameter(\"test4\", \"test4\");\n\t\toption.addParameter(\"test5\", \"test5\");\n\t\toption.addParameter(\"test6\", \"test6\");\n\t\toption.addParameter(\"test7\", \"test7\");\n\t\toption.addParameter(\"test8\", \"test8\");\n\t\toption.addParameter(\"test9\", \"test9\");\n\t\toption.addParameter(\"test10\", \"test10\");\n\t\toption.addParameter(\"test11\", \"test11\");\n\t\toption.addParameter(\"test12\", \"test12\");\n\t\toption.addParameter(\"test13\", \"test13\");\n\t\toption.addParameter(\"test14\", \"test14\");\n\t\toption.addParameter(\"test15\", \"test15\");\n\t\toption.addParameter(\"test16\", \"test16\");\n\t\toption.addParameter(\"test17\", \"test17\");\n\t\toption.addParameter(\"test18\", \"test18\");\n\t\toption.addParameter(\"test19\", \"test19\");\n\t\toption.addParameter(\"test20\", \"test20\");\n\t\toption.addParameter(\"test21\", \"test21\");\n\t\toption.addParameter(\"test22\", \"test22\");\n\t\toption.addParameter(\"test23\", \"test23\");\n\t\toption.addParameter(\"test24\", \"test24\");\n\t\toption.addParameter(\"test25\", \"test25\");\n\t\toption.addParameter(\"test26\", \"test26\");\n\t\toption.addParameter(\"test27\", \"test27\");\n\t\toption.addParameter(\"test28\", \"test28\");\n\t\toption.addParameter(\"test29\", \"test29\");\n\t\toption.addParameter(\"test30\", \"test30\");\n\t\toption.addParameter(\"test31\", \"test31\");\n\t\toption.addParameter(\"test32\", \"test32\");\n\t\toption.addParameter(\"test33\", \"test33\");\n\t\toption.addParameter(\"test34\", \"test34\");\n\t\toption.addParameter(\"test35\", \"test35\");\n\t\toption.addParameter(\"test36\", \"test36\");\n\t\toption.addParameter(\"test37\", \"test37\");\n\t\toption.addParameter(\"test38\", \"test38\");\n\t\toption.addParameter(\"test39\", \"test39\");\n\t\toption.addParameter(\"test40\", \"test40\");\n\t\toption.addParameter(\"test41\", \"test41\");\n\t\toption.addParameter(\"test42\", \"test42\");\n\t\toption.addParameter(\"test43\", \"test43\");\n\t\toption.addParameter(\"test44\", \"test44\");\n\t\toption.addParameter(\"test45\", \"test45\");\n\t\toption.addParameter(\"test46\", \"test46\");\n\t\toption.addParameter(\"test47\", \"test47\");\n\t\toption.addParameter(\"test48\", \"test48\");\n\t\toption.addParameter(\"test49\", \"test49\");\n\t\toption.addParameter(\"test50\", \"test50\");\n\t\toption.addParameter(\"test51\", \"test51\");\n\t\toption.addParameter(\"test52\", \"test52\");\n\t\toption.addParameter(\"test53\", \"test53\");\n\t\toption.addParameter(\"test54\", \"test54\");\n\t\toption.addParameter(\"test55\", \"test55\");\n\t\toption.addParameter(\"test56\", \"test56\");\n\t\toption.addParameter(\"test57\", \"test57\");\n\t\toption.addParameter(\"test58\", \"test58\");\n\t\toption.addParameter(\"test59\", \"test59\");\n\t\toption.addParameter(\"test60\", \"test60\");\n\t\toption.addParameter(\"test61\", \"test61\");\n\t\toption.addParameter(\"test62\", \"test62\");\n\t\toption.addParameter(\"test63\", \"test63\");\n\t\toption.addParameter(\"test64\", \"test64\");\n\t\toption.addParameter(\"test65\", \"test65\");\n\t\toption.addParameter(\"test66\", \"test66\");\n\t\toption.addParameter(\"test67\", \"test67\");\n\t\toption.addParameter(\"test68\", \"test68\");\n\t\toption.addParameter(\"test69\", \"test69\");\n\t\toption.addParameter(\"test70\", \"test70\");\n\t\toption.addParameter(\"test71\", \"test71\");\n\t\toption.addParameter(\"test72\", \"test72\");\n\t\toption.addParameter(\"test73\", \"test73\");\n\t\toption.addParameter(\"test74\", \"test74\");\n\t\toption.addParameter(\"test75\", \"test75\");\n\t\toption.addParameter(\"test76\", \"test76\");\n\t\toption.addParameter(\"test77\", \"test77\");\n\t\toption.addParameter(\"test78\", \"test78\");\n\t\toption.addParameter(\"test79\", \"test79\");\n\t\toption.addParameter(\"test80\", \"test80\");\n\t\toption.addParameter(\"test81\", \"test81\");\n\t\toption.addParameter(\"test82\", \"test82\");\n\t\toption.addParameter(\"test83\", \"test83\");\n\t\toption.addParameter(\"test84\", \"test84\");\n\t\toption.addParameter(\"test85\", \"test85\");\n\t\toption.addParameter(\"test86\", \"test86\");\n\t\toption.addParameter(\"test87\", \"test87\");\n\t\toption.addParameter(\"test88\", \"test88\");\n\t\toption.addParameter(\"test89\", \"test89\");\n\t\toption.addParameter(\"test90\", \"test90\");\n\t\toption.addParameter(\"test91\", \"test91\");\n\t\toption.addParameter(\"test92\", \"test92\");\n\t\toption.addParameter(\"test", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "87590916_4", "part": [1, 1], "seq": [1, 1], "prompt": "class AuthenticationService {\n\n    public static AuthenticationManager getAuthenticationManager() {\n        return authManager;\n    }\n\n    public static String extractDN(X509Certificate clientCert);\n\n}\n\nclass AuthenticationServiceTest {\n\n    @Test\n    public void testX509AuthenticationLogin() {\n", "reference": "        PreAuthenticatedAuthenticationToken token = new PreAuthenticatedAuthenticationToken(\"example.com\",\n                \"doesn't matter what I put here\");\n        Authentication auth = AuthenticationService.getAuthenticationManager().authenticate(token);\n        Collection<? extends GrantedAuthority> authorizations = auth.getAuthorities();\n        authorizations.forEach(a -> {\n            Assert.assertTrue(\n                    a.getAuthority().equals(\"D\") || a.getAuthority().equals(\"E\") || a.getAuthority().equals(\"F\"));\n        });\n    }\n\n}", "prediction": "        AuthenticationService.getAuthenticationManager().login(null, null);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "87849739_2058", "part": [1, 1], "seq": [1, 1], "prompt": "class PurgeNamespaceReason implements ShutdownReason {\n\n    @Override\n    public JsonObject toJson() {\n        return toJson(FieldType.REGULAR.and(FieldType.notHidden()));\n    }\n\n    private  PurgeNamespaceReason(final String namespaceToPurge);\n\n    public static PurgeNamespaceReason of(final CharSequence namespace);\n    static PurgeNamespaceReason fromJson(final JsonObject jsonObject);\n    @Override public ShutdownReasonType getType();\n    @Override public boolean isRelevantFor(final Object value);\n    @Override public JsonObject toJson(final JsonSchemaVersion schemaVersion, final Predicate<JsonField> predicate);\n    @Override public boolean equals(final Object o);\n    @Override public int hashCode();\n    @Override public String toString();\n\n    private static ShutdownReasonType purgeNamespaceType;\n    private static String knownNamespace;\n    private static JsonObject knownJsonRepresentation;\n    private PurgeNamespaceReason underTest;\n\n}\n\nclass PurgeNamespaceReasonTest {\n\n    private static ShutdownReasonType purgeNamespaceType;\n    private static String knownNamespace;\n    private static JsonObject knownJsonRepresentation;\n    private PurgeNamespaceReason underTest;\n\n    @Test\n    public void toJsonWithHiddenFieldsOnlyReturnsEmptyJsonObject() {\n", "reference": "        assertThat(underTest.toJson(FieldType.HIDDEN)).isEmpty();\n    }\n\n}", "prediction": "        // given\n        final JsonSchemaVersion schemaVersion = JsonSchemaVersion.V201807;\n        final Predicate<JsonField> predicate = FieldType.HIDDEN.and(FieldType.notHidden());\n\n        // when\n        final JsonObject result = underTest.toJson(schemaVersion, predicate);\n\n        // then\n        assertThat(result).isEmpty();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "89129558_0", "part": [1, 1], "seq": [1, 1], "prompt": "class Token {\n\n    public static boolean isValid(String token) {\n        if (token == null || token.length() == 0) {\n            return false;\n        }\n\n        int len = token.length();\n\n        for (int i = 0; i < len; ++i) {\n            if (isSeparator(token.charAt(i))) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    public static boolean isSeparator(char ch);\n    public static String unquote(String text);\n    public static String unescape(String text);\n\n}\n\nclass TokenTest {\n\n    @Test\n    public void test004() {\n", "reference": "        isValid(\"abc\");\n    }\n\n}", "prediction": "        assertFalse(Token.isValid(\"\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "89679757_8", "part": [1, 1], "seq": [1, 1], "prompt": "class Election {\n\n    @Override\n    public boolean equals(Object obj) {\n        if(obj instanceof Election) {\n            Election that = (Election) obj;\n            return this.getPlace().equals(that.getPlace()) &&\n                    this.getKind().equals(that.getKind()) &&\n                    this.getAsset().getName().equals(that.getAsset().getName());\n        } else {\n            return false;\n        }\n    }\n\n    public  Election(String kind, String place, Asset asset);\n\n    public String getKind();\n    public String getPlace();\n    public Asset getAsset();\n    public static Election parseElection(Asset a, Context context);\n    @Override public int hashCode();\n    @Override public String toString();\n\n    private Sha256Hash mockHash;\n\n}\n\nclass ElectionTest {\n\n    private Sha256Hash mockHash;\n\n    @Test\n    public void equalsNonEqualKind() throws Exception {\n", "reference": "        Election e1 = new Election(\"Delft\", \"Municipal election\", new Asset(\"G_Delft\", mockHash));\n        Election e2 = new Election(\"Delft\", \"Provincial election\", new Asset(\"G_Delft\", mockHash));\n        assertFalse(e1.equals(e2));\n    }\n\n}", "prediction": "        Election e1 = new Election(\"kind\", \"place\", new Asset(\"name\", \"description\", 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 10", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "89956253_0", "part": [1, 1], "seq": [1, 1], "prompt": "class DashboardSerializer {\n\n    public void write(Dashboard dashboard, Writer writer) throws IOException {\n        try {\n            mapper.writeValue(writer, dashboard);\n        } catch (JsonProcessingException e) {\n            throw new IllegalArgumentException(\"dashboard cannot be serialized to JSON.\" +\n                    \"It might contain non-serializable values.\", e);\n        }\n    }\n\n    public  DashboardSerializer();\n\n    public String toString(Dashboard dashboard);\n    public void write(Dashboard dashboard, OutputStream stream);\n\n    private DashboardSerializer serializer;\n\n}\n\nclass DashboardSerializerTest {\n\n    private DashboardSerializer serializer;\n\n    @Test\n    @Ignore\n    public void printTestDashboard() throws IOException {\n", "reference": "        //System.out.println(serializer.toString(testDashboard()));\n        serializer.write(testDashboard(), System.out);\n    }\n\n}", "prediction": "        Dashboard dashboard = new Dashboard();\n        dashboard.setName(\"test\");\n        dashboard.setDescription(\"test\");\n        dashboard.setTags(Arrays.asList(\"tag1\", \"tag2\"));\n        dashboard.setCreatedBy(\"test\");\n        dashboard.setCreatedAt(new Date());\n        dashboard.setUpdatedBy(\"test\");\n        dashboard.setUpdatedAt(new Date());\n        dashboard.setWidgets(Arrays.asList(new Widget()));\n        dashboard.setCharts(Arrays.asList(new Chart()));\n        dashboard.setDashboardFilters(Arrays.asList(new DashboardFilter()));\n        dashboard.setDashboardLayouts(Arrays.asList(new DashboardLayout()));\n        dashboard.setDashboardWidgets(Arrays.asList(new DashboardWidget()));\n        dashboard.setDashboardCharts(Arrays.asList(new DashboardChart()));\n        dashboard.setDashboardLayouts(Arrays.asList(new DashboardLayout()));\n        dashboard.setDashboardFilters(Arrays.asList(new DashboardFilter()));\n        dashboard.setDashboardWidgets(Arrays.asList(new DashboardWidget()));\n        dashboard.setDashboardCharts(Arrays.asList(new DashboardChart()));\n        dashboard.setDashboardLayouts(Arrays.asList(new DashboardLayout()));\n        dashboard.setDashboardFilters(Arrays.asList(new DashboardFilter()));\n        dashboard.setDashboardWidgets(Arrays.asList(new DashboardWidget()));\n        dashboard.setDashboardCharts(Arrays.asList(new DashboardChart()));\n        dashboard.setDashboardLayouts(Arrays.asList(new DashboardLayout()));\n        dashboard.setDashboardFilters(Arrays.asList(new DashboardFilter()));\n        dashboard.setDashboardWidgets(Arrays.asList(new DashboardWidget()));\n        dashboard.setDashboardCharts(Arrays.asList(new DashboardChart()));\n        dashboard.setDashboardLayouts(Arrays.asList(new DashboardLayout()));\n        dashboard.setDashboardFilters(Arrays.asList(new DashboardFilter()));\n        dashboard.setDashboardWidgets(Arrays.asList(new DashboardWidget()));\n        dashboard.setDashboardCharts(Arrays.asList(new DashboardChart()));\n        dashboard.setDashboardLayouts(Arrays.asList(new DashboardLayout()));\n        dashboard.setDashboardFilters(Arrays.asList(new DashboardFilter()));\n        dashboard.setDashboardWidgets(Arrays.asList(new DashboardWidget()));\n        dashboard.setDashboardCharts(Arrays.asList(new DashboardChart()));\n        dashboard.setDashboardLayouts(Arrays.asList(new DashboardLayout()));\n        dashboard.setDashboardFilters(Arrays.asList(new DashboardFilter()));\n        dashboard.setDashboardWidgets(Arrays.asList(new DashboardWidget()));\n        dashboard.setDashboardCharts(Arrays.asList(new DashboardChart()));\n        dashboard.setDashboardLayouts(Arrays.asList(new DashboardLayout()));\n        dashboard.setDashboardFilters(Arrays.asList(new DashboardFilter()));\n        dashboard.setDashboardWidgets(Arrays.asList(new DashboardWidget()));\n        dashboard.setDashboardCharts(Arrays.asList(new DashboardChart()));\n        dashboard.setDashboardLayouts(Arrays.asList(new DashboardLayout()));\n        dashboard.setDashboardFilters(Arrays.asList(new DashboardFilter()));\n        dashboard.setDashboardWidgets(Arrays.asList(new DashboardWidget()));\n        dashboard.setDashboardCharts(Arrays.asList(new DashboardChart()));\n        dashboard.setDashboardLayouts(Arrays.asList(new DashboardLayout()));\n        dashboard.setDashboardFilters(Arrays.asList(new DashboardFilter()));\n        dashboard.setDashboardWidgets(Arrays.asList(new DashboardWidget()));\n        dashboard.setDashboardCharts(Arrays.asList(new DashboardChart()));\n        dashboard.setDashboardLayouts(Arrays.asList(new DashboardLayout()));\n        dashboard.setDashboardFilters(Arrays.asList(new DashboardFilter()));\n        dashboard.setDashboardWidgets(Arrays.asList(new DashboardWidget()));\n        dashboard.setDashboardCharts(Arrays.asList(new DashboardChart()));\n        dashboard.setDashboardLayouts(Arrays.asList(new DashboardLayout()));\n        dashboard.setDashboardFilters(Arrays.asList(new DashboardFilter()));\n        dashboard.setDashboardWidgets(Arrays.asList(new DashboardWidget()));\n        dashboard.setDashboardCharts(Arrays.asList(new DashboardChart()));\n        dashboard.setDashboardLayouts(Arrays.asList(new DashboardLayout()));\n        dashboard.setDashboardFilters(Arrays.asList(new DashboardFilter()));\n        dashboard.setDashboardWidgets(Arrays.asList(new DashboardWidget()));\n        dashboard.setDashboardCharts(Arrays.asList(new DashboardChart()));\n        dashboard.setDashboardLayouts(Arrays.asList(new DashboardLayout()));\n        dashboard.setDashboardFilters(Arrays.asList(new DashboardFilter()));\n        dashboard.setDashboardWidgets(Arrays.asList(new DashboardWidget()));\n        dashboard.setDashboardCharts(Arrays.asList(new DashboardChart()));\n        dashboard.setDashboardLayouts(Arrays.asList(new DashboardLayout()));\n        dashboard.setDashboardFilters(Arrays.asList(new DashboardFilter()));\n        dashboard.setDashboardWidgets(Arrays.asList(new DashboardWidget()));\n        dashboard.setDashboardCharts(Arrays.asList(new DashboardChart()));\n        dashboard.setDashboardLayouts(Arrays.asList(new DashboardLayout()));\n        dashboard.setDashboardFilters(Arrays.asList(new DashboardFilter()));\n        dashboard.setDashboardWidgets(Arrays.asList(new DashboardWidget()));\n        dashboard.setDashboardCharts(Arrays.asList(new DashboardChart()));\n        dashboard.setDashboardLayouts(Arrays.asList(new DashboardLayout()));\n        dashboard.setDashboardFilters(Arrays.asList(new DashboardFilter()));\n        dashboard.setDashboardWidgets(Arrays.asList(new DashboardWidget()));\n        dashboard.setDashboardCharts(Arrays.asList(new DashboardChart()));", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "90016934_2", "part": [1, 1], "seq": [1, 1], "prompt": "class DataStoreManager extends DataStores {\n\n   @Deprecated\n   public DataStoreConf create(DataStoreConf dc, boolean save)\n   {\n      getDataStore().add(dc);\n      if (save)\n      {\n         save();\n      }\n      return dc;\n   }\n\n   public DataStoreConf get(String name);\n   public NamedDataStoreConf getNamed(String name);\n   public void createNamed(NamedDataStoreConf namedDsc);\n   public synchronized void delete(DataStoreConf ds);\n   public synchronized void update(final NamedDataStoreConf update);\n   public List<DataStoreConf> getAllDataStoreConfigurations();\n   public List<NamedDataStoreConf> getNamedDataStoreConfigurations();\n   public List<DataStoreConf> getUnnamedDataStoreConfigurations();\n   public synchronized long varyCurrentSize(String dataStoreName, long amount);\n   private void save();\n\n    DataStoreManager dsManager;\n\n}\n\nclass DataStoreManagerTest extends DataStores {\n\n    DataStoreManager dsManager;\n\n   @Test(dependsOnMethods = \"getDataStoresTest\")\n   public void createTest()\n   {\n", "reference": "      HfsDataStoreConf ds = (HfsDataStoreConf) dsManager.get(\"lambda\");\n      Assert.assertNull(ds);\n      HfsDataStoreConf ds2 = new HfsDataStoreConf();\n      ds2 = (HfsDataStoreConf) dsManager.create(ds2, false);\n      ds2.setName(\"lambda\");\n      ds = (HfsDataStoreConf) dsManager.get(\"lambda\");\n      Assert.assertNotNull(ds);\n      Assert.assertEquals(ds.getName(), \"lambda\");\n   }\n\n}", "prediction": "     DataStoreConf dsc = new DataStoreConf();\n      dsc.setName(\"test\");\n      dsc.setType(\"test\");\n      dsc.setPath(\"test\");\n      dsc.setSize(1000000000000000000L);\n      dsc.setUsed(1000000000000000000L);\n      dsc.setFree(1000000000000000000L);\n      dsc.setPercentage(100);\n      dsc.setDescription(\"test\");\n      dsc.setStatus(DataStoreConf.Status.ONLINE);\n      dsc.setLastUpdate(new Date());\n      dsc.setLastCheck(new Date());\n      dsc.setLastCheckResult(DataStoreConf.CheckResult.OK);\n      dsc.setLastCheckMessage(\"test\");\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheckTime(new Date());\n      dsc.setLastCheck", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "91779577_3", "part": [1, 1], "seq": [1, 1], "prompt": "class Camflake {\n\n    public long next() {\n\n        // elapsedTime\n        long elapsed = getElapsedTime();\n        // sequence\n        int sequence = getSequence(elapsed);\n        log.debug(\"sequence id: {}\", sequence);\n        // If sequence ID exceeded maximum value, it retries once to generate unique ID 2 milliseconds later.\n        if (sequence > SEQUENCE_MAX) {\n            sleep(TimeUnit.MILLISECONDS.toMillis(2L));\n\n            elapsed = getElapsedTime();\n            sequence = getSequence(elapsed);\n            if (sequence > SEQUENCE_MAX) {\n                throw new CamflakeException(\"Failed to issue sequence id.\");\n            }\n        }\n\n        long id = (elapsed << 22) | (sequence << 16) | machineId;\n        log.debug(\"unique id: {}\", id);\n\n        return id;\n    }\n\n    public  Camflake(MachineId machineId, Instant baseTime);\n    public  Camflake(MachineId machineId);\n    public  Camflake();\n\n    private long getElapsedTime();\n    private int getSequence(long elapsed);\n    private void sleep(long durationMillis);\n\n    private static final int SEQUENCE_MAX;\n\n}\n\nclass CamflakeTest {\n\n    private static final int SEQUENCE_MAX;\n\n    @Test\n    public void testNextReturnsExpectedValue() {\n", "reference": "        final Instant baseTime = ZonedDateTime\n            .of(2017, 6, 1, 0, 0, 0, 0, ZoneId.of(\"UTC\"))\n            .toInstant();\n        final Instant execTime = ZonedDateTime\n            .of(2017, 6, 1, 0, 0, 1, 0, ZoneId.of(\"UTC\"))\n            .toInstant();\n        new Expectations(Instant.class) {\n            {\n                Instant.now();\n                returns(\n                    baseTime, // at initialize\n                    execTime  // at runtime\n                );\n            }\n        };\n\n        Camflake camflake = new Camflake(new TestMachineId());\n\n        long id = camflake.next();\n        assertThat(id, is(4194304001L));\n\n    }\n\n}", "prediction": "        Camflake camflake = new Camflake();\n        long id = camflake.next();\n        assertThat(id).isGreaterThan(0L);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "91855299_92", "part": [1, 1], "seq": [1, 1], "prompt": "class ByteArrayAdapter extends TypeAdapter<byte[]> {\n\n  @Override\n  public byte[] deserialize(byte[] buffer, int bufferPosition) {\n    int length = Serialization.readInt(buffer, bufferPosition);\n    return Serialization.subArray(buffer, bufferPosition + SIZE_OF_INT, bufferPosition + SIZE_OF_INT + length);\n  }\n\n  public  ByteArrayAdapter();\n\n  @Override public byte[] serialize(byte[] data);\n  @Override public int getSerializedSize(byte[] value);\n\n  private final ByteArrayAdapter adapter;\n\n}\n\nclass ByteArrayAdapterTest {\n\n  private final ByteArrayAdapter adapter;\n\n  @Test\n  public void testDecodeEmptyArray() {\n", "reference": "    byte[] buffer = {0, 0, 0, 0};\n    byte[] expected = {};\n    assertArrayEquals(expected, adapter.deserialize(buffer, 0));\n  }\n\n}", "prediction": "    byte[] buffer = new byte[SIZE_OF_INT];\n    assertArrayEquals(new byte[0], adapter.deserialize(buffer, 0));\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "92798552_4", "part": [1, 1], "seq": [1, 1], "prompt": "class Kv78Parser {\n\n    public static Kv78Packet parseMessage(String input) {\n        Kv78Packet p = new Kv78Packet();\n        Kv78Table t = null;\n        String[] lines = input.split(CHAR_NEWLINE);\n        String[] headers = null;\n        for (String line : lines) {\n            if (line.startsWith(CHAR_CONTROL)) {\n                String[] columns = line.substring(2).split(\"\\\\|\");\n                switch (line.substring(1,2)) {\n                    case \"G\":\n                        p.setType(columns[0]);\n                        p.setComment(columns[2]);\n                        p.setEncoding(columns[5]);\n                        p.setVersion(columns[6]);\n                        p.setGenerated(ZonedDateTime.parse(columns[7]));\n                        break;\n                    case \"T\":\n                        if (t != null) {\n                            p.addTable(t);\n                        }\n                        t = new Kv78Table();\n                        t.setTableName(columns[0]);\n                        t.setTableComment(columns[2]);\n                        break;\n                    case \"L\":\n                        headers = columns;\n                        break;\n                    default:\n                        break;\n                }\n            } else {\n                if (headers != null) {\n                    Map<String, String> record = new HashMap<>();\n                    String[] cells = line.split(CHAR_SPLIT);\n                    for (int i = 0; i < cells.length; i++) {\n                        if (!CHAR_EMPTY.contentEquals(cells[i])) {\n                            record.put(headers[i], cells[i]);\n                        }\n                    }\n                    if (t == null) {\n                        t = new Kv78Table();\n                    }\n                    t.getRecords().add(record);\n                } else {\n                    // Invalid message!\n                    LOGGER.error(\"Failed to parse message\");\n                }\n            }\n        }\n        p.addTable(t);\n        return p;\n    }\n\n}\n\nclass Kv78ParserTest {\n\n    @Test\n    public void parseGeneralMessage() {\n", "reference": "        String data = \"\\\\GKV8turbo_generalmessages|KV8turbo_generalmessages|openOV RET|||UTF-8|0.1|2017-04-11T21:53:25+02:00|\\uFEFF\\r\\n\" +\n                \"\\\\TGENERALMESSAGEUPDATE|GENERALMESSAGEUPDATE|start object\\r\\n\" +\n                \"\\\\LDataOwnerCode|MessageCodeDate|MessageCodeNumber|TimingPointDataOwnerCode|TimingPointCode|MessageType|MessageDurationType|MessageStartTime|MessageEndTime|MessageContent|ReasonType|SubReasonType|ReasonContent|EffectType|SubEffectType|EffectContent|MeasureType|SubMeasureType|MeasureContent|AdviceType|SubAdviceType|AdviceContent|MessageTimeStamp\\r\\n\" +\n                \"RET|2017-04-11|27|ALGEMEEN|31001347|GENERAL|REMOVE|2017-04-11T21:51:08+02:00|\\\\0|Door defect materieel is er op tram 23 een rit uitgevallen. Houd rekening met een extra reistijd tot 15 min.|0|0|\\\\0|0|0|\\\\0|0|6|\\\\0|0|0|\\\\0|2017-04-11T21:53:24+02:00\\r\\n\";\n        Kv78Packet p = Kv78Parser.parseMessage(data);\n\n        Assert.assertEquals(\"KV8turbo_generalmessages\", p.getType());\n        Assert.assertEquals(\"openOV RET\", p.getComment());\n        Assert.assertEquals(\"UTF-8\", p.getEncoding());\n        Assert.assertEquals(\"0.1\", p.getVersion());\n        Assert.assertEquals(ZonedDateTime.parse(\"2017-04-11T21:53:25+02:00\"), p.getGenerated());\n\n        Assert.assertEquals(\"GENERALMESSAGEUPDATE\", p.getTables().get(0).getTableName());\n        Assert.assertEquals(\"start object\", p.getTables().get(0).getTableComment());\n\n        Assert.assertEquals(1, p.getTables().get(0).getRecords().size());\n        Map<String, String> record = p.getTables().get(0).getRecords().get(0);\n        Assert.assertEquals(18, record.size());\n        Assert.assertEquals(\"RET\", record.get(\"DataOwnerCode\"));\n        Assert.assertEquals(\"2017-04-11\", record.get(\"MessageCodeDate\"));\n        Assert.assertEquals(\"27\", record.get(\"MessageCodeNumber\"));\n        Assert.assertEquals(\"ALGEMEEN\", record.get(\"TimingPointDataOwnerCode\"));\n        Assert.assertEquals(\"31001347\", record.get(\"TimingPointCode\"));\n        Assert.assertEquals(\"GENERAL\", record.get(\"MessageType\"));\n        Assert.assertEquals(\"REMOVE\", record.get(\"MessageDurationType\"));\n        Assert.assertEquals(\"2017-04-11T21:51:08+02:00\", record.get(\"MessageStartTime\"));\n        Assert.assertEquals(\"Door defect materieel is er op tram 23 een rit uitgevallen. Houd rekening met een extra reistijd tot 15 min.\", record.get(\"MessageContent\"));\n        Assert.assertEquals(\"0\", record.get(\"ReasonType\"));\n        Assert.assertEquals(\"0\", record.get(\"SubReasonType\"));\n        Assert.assertEquals(\"0\", record.get(\"EffectType\"));\n        Assert.assertEquals(\"0\", record.get(\"SubEffectType\"));\n        Assert.assertEquals(\"0\", record.get(\"MeasureType\"));\n        Assert.assertEquals(\"6\", record.get(\"SubMeasureType\"));\n        Assert.assertEquals(\"0\", record.get(\"AdviceType\"));\n        Assert.assertEquals(\"0\", record.get(\"SubAdviceType\"));\n        Assert.assertEquals(\"2017-04-11T21:53:24+02:00\", record.get(\"MessageTimeStamp\"));\n\n\n    }\n\n}", "prediction": "        String input = \"G|KV78|KV78|KV78|KV78|KV78|KV78|KV78|2019-01-01T00:00:00+01:00|\";\n        Kv78Packet p = Kv78Parser.parseMessage(input);\n        assertEquals(\"KV78\", p.getType());\n        assertEquals(\"KV78\", p.getComment());\n        assertEquals(\"KV78\", p.getEncoding());\n        assertEquals(\"KV78\", p.getVersion());\n        assertEquals(ZonedDateTime.parse(\"2019-01-01T00:00:00+01:00\"), p.getGenerated());\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "93310060_33", "part": [1, 1], "seq": [1, 1], "prompt": "class SpelKeyGenerator extends CachedExpressionEvaluator implements KeyGenerator {\n\n  @Override\n  public List<String> resolveKeys(final String lockKeyPrefix, final String expression, final Object object, final Method method, final Object[] args) {\n    final Object expressionValue = evaluateExpression(expression, object, method, args);\n    final List<String> keys = convertResultToList(expressionValue);\n\n    if (keys.stream().anyMatch(Objects::isNull)) {\n      throw new EvaluationConvertException(\"null keys are not supported: \" + keys);\n    }\n\n    if (StringUtils.isEmpty(lockKeyPrefix)) {\n      return keys;\n    }\n\n    return keys.stream().map(key -> lockKeyPrefix + key).collect(Collectors.toList());\n  }\n\n  protected List<String> convertResultToList(final Object expressionValue);\n  private Object evaluateExpression(final String expression, final Object object, final Method method, final Object[] args);\n  private List<String> iterableToList(final Object expressionValue);\n  private List<String> arrayToList(final Object expressionValue);\n\n  private final KeyGenerator keyGenerator;\n  private final MessageService service;\n  private final Method sendMessageMethod;\n\n}\n\nclass SpelKeyGeneratorTest {\n\n  private final KeyGenerator keyGenerator;\n  private final MessageService service;\n  private final Method sendMessageMethod;\n\n  @Test\n  public void shouldGenerateMultipleKeysFromContextAndVariablesWithList() {\n", "reference": "    final String expression = \"T(com.github.alturkovic.lock.key.SpelKeyGeneratorTest).generateKeys(#message)\";\n    assertThat(keyGenerator.resolveKeys(\"lock_\", expression, service, sendMessageMethod, new Object[]{\"p_\"}))\n      .containsExactly(\"lock_p_first\", \"lock_p_second\");\n  }\n\n}", "prediction": "    final List<String> keys = keyGenerator.resolveKeys(\"prefix\", \"key\", new Object(), null, new Object[] { \"a\", \"b\" });\n\n    assertThat(keys).containsExactly(\"prefixa\", \"prefixb\");\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "94255167_7", "part": [1, 1], "seq": [1, 1], "prompt": "class TextInstructions {\n\n  public String compile(LegStep step) {\n    if (step.getManeuver() == null) {\n      throw new RuntimeException(\"No step maneuver provided.\");\n    }\n\n    String type = step.getManeuver().getType();\n    String modifier = step.getManeuver().getModifier();\n    String mode = step.getMode();\n\n    if (TextUtils.isEmpty(type)) {\n      throw new RuntimeException(\"Missing step maneuver type.\");\n    }\n\n    if (!type.equals(\"depart\") && !type.equals(\"arrive\") && TextUtils.isEmpty(modifier)) {\n      throw new RuntimeException(\"Missing step maneuver modifier.\");\n    }\n\n    if (getVersionObject().getAsJsonObject(type) == null) {\n      // Log for debugging\n      logger.log(Level.FINE, \"Encountered unknown instruction type: \" + type);\n\n      // OSRM specification assumes turn types can be added without\n      // major version changes. Unknown types are to be treated as\n      // type `turn` by clients\n      type = \"turn\";\n    }\n\n    // Use special instructions if available, otherwise `defaultinstruction`\n    JsonObject instructionObject;\n    JsonObject modeValue = getVersionObject().getAsJsonObject(\"modes\").getAsJsonObject(mode);\n    if (modeValue != null) {\n      instructionObject = modeValue;\n    } else {\n      JsonObject modifierValue = getVersionObject().getAsJsonObject(type).getAsJsonObject(modifier);\n      instructionObject = modifierValue == null\n        ? getVersionObject().getAsJsonObject(type).getAsJsonObject(\"default\")\n        : modifierValue;\n    }\n\n    // Special case handling\n    JsonPrimitive laneInstruction = null;\n    switch (type) {\n      case \"use lane\":\n        laneInstruction = getVersionObject().getAsJsonObject(\"constants\")\n          .getAsJsonObject(\"lanes\").getAsJsonPrimitive(laneConfig(step));\n        if (laneInstruction == null) {\n          // If the lane combination is not found, default to continue straight\n          instructionObject = getVersionObject().getAsJsonObject(\"use lane\")\n            .getAsJsonObject(\"no_lanes\");\n        }\n        break;\n      case \"rotary\":\n      case \"roundabout\":\n        if (!TextUtils.isEmpty(step.getRotaryName())\n          && step.getManeuver().getExit() != null\n          && instructionObject.getAsJsonObject(\"name_exit\") != null) {\n          instructionObject = instructionObject.getAsJsonObject(\"name_exit\");\n        } else if (step.getRotaryName() != null && instructionObject.getAsJsonObject(\"name\") != null) {\n          instructionObject = instructionObject.getAsJsonObject(\"name\");\n        } else if (step.getManeuver().getExit() != null && instructionObject.getAsJsonObject(\"exit\") != null) {\n          instructionObject = instructionObject.getAsJsonObject(\"exit\");\n        } else {\n          instructionObject = instructionObject.getAsJsonObject(\"default\");\n        }\n        break;\n      default:\n        // NOOP, since no special logic for that type\n    }\n\n    // Decide way_name with special handling for name and ref\n    String wayName;\n    String name = TextUtils.isEmpty(step.getName()) ? \"\" : step.getName();\n    String ref = TextUtils.isEmpty(step.getRef()) ? \"\" : step.getRef().split(\";\")[0];\n\n    // Remove hacks from Mapbox Directions mixing ref into name\n    if (name.equals(step.getRef())) {\n      // if both are the same we assume that there used to be an empty name, with the ref being filled in for it\n      // we only need to retain the ref then\n      name = \"\";\n    }\n    name = name.replace(\" (\" + step.getRef() + \")\", \"\");\n\n    if (!TextUtils.isEmpty(name) && !TextUtils.isEmpty(ref) && !name.equals(ref)) {\n      wayName = name + \" (\" + ref + \")\";\n    } else if (TextUtils.isEmpty(name) && !TextUtils.isEmpty(ref)) {\n      wayName = ref;\n    } else {\n      wayName = name;\n    }\n\n    // Decide which instruction string to use\n    // Destination takes precedence over name\n    String instruction;\n    if (!TextUtils.isEmpty(step.getDestinations())\n      && instructionObject.getAsJsonPrimitive(\"destination\") != null) {\n      instruction = instructionObject.getAsJsonPrimitive(\"destination\").getAsString();\n    } else if (!TextUtils.isEmpty(wayName)\n      && instructionObject.getAsJsonPrimitive(\"name\") != null) {\n      instruction = instructionObject.getAsJsonPrimitive(\"name\").getAsString();\n    } else {\n      instruction = instructionObject.getAsJsonPrimitive(\"default\").getAsString();\n    }\n\n    if (getTokenizedInstructionHook() != null) {\n      instruction = getTokenizedInstructionHook().change(instruction);\n    }\n\n    // Replace tokens\n    // NOOP if they don't exist\n    String nthWaypoint = \"\"; // TODO, add correct waypoint counting\n    JsonPrimitive modifierValue =\n      getVersionObject().getAsJsonObject(\"constants\").getAsJsonObject(\"modifier\").getAsJsonPrimitive(modifier);\n    instruction = instruction\n      .replace(\"{way_name}\", wayName)\n      .replace(\"{destination}\", TextUtils.isEmpty(step.getDestinations()) ? \"\" : step.getDestinations().split(\",\")[0])\n      .replace(\"{exit_number}\",\n        step.getManeuver().getExit() == null ? ordinalize(1) : ordinalize(step.getManeuver().getExit()))\n      .replace(\"{rotary_name}\", TextUtils.isEmpty(step.getRotaryName()) ? \"\" : step.getRotaryName())\n      .replace(\"{lane_instruction}\", laneInstruction == null ? \"\" : laneInstruction.getAsString())\n      .replace(\"{modifier}\", modifierValue == null ? \"\" : modifierValue.getAsString())\n      .replace(\"{direction}\", directionFromDegree(step.getManeuver().getBearingAfter()))\n      .replace(\"{nth}\", nthWaypoint)\n      .replaceAll(\"\\\\s+\", \" \"); // remove excess spaces\n\n    if (getRootObject().getAsJsonObject(\"meta\").getAsJsonPrimitive(\"capitalizeFirstLetter\").getAsBoolean()) {\n      instruction = capitalizeFirstLetter(instruction);\n    }\n\n    return instruction;\n  }\n\n  public  TextInstructions(String language, String version);\n\n  public TokenizedInstructionHook getTokenizedInstructionHook();\n  public void setTokenizedInstructionHook(TokenizedInstructionHook tokenizedInstructionHook);\n  public JsonObject getRootObject();\n  public JsonObject getVersionObject();\n  public static String capitalizeFirstLetter(String text);\n  public String ordinalize(Integer number);\n  public String directionFromDegree(Double degree);\n  public String laneConfig(LegStep step);\n\n  @Rule\n  public ExpectedException thrown;\n\n}\n\nclass TextInstructionsTest  {\n\n  @Rule\n  public ExpectedException thrown;\n\n  @Test\n  public void testFixturesMatchGeneratedInstructions() throws IOException {\n", "reference": "    for (String fixture : TextInstructionsFixtures.FIXTURES) {\n      String body = loadJsonFixture(fixture);\n      FixtureModel model = new Gson().fromJson(body, FixtureModel.class);\n      for (Object entry : model.getInstructions().entrySet()) {\n        Map.Entry pair = (Map.Entry) entry;\n        String language = (String) pair.getKey();\n        String compiled = (String) pair.getValue();\n        assertEquals(compiled, new TextInstructions(language, \"v5\").compile(model.getStep()));\n      }\n    }\n  }\n\n}", "prediction": "    String language = \"en\";\n    String version = \"v5.1.0\";\n    TextInstructions textInstructions = new TextInstructions(language, version);\n\n    String fixturesPath = \"fixtures/instructions/\" + language + \"/\" + version + \"/\";\n    String fixturesExtension = \".json\";\n\n    File fixturesDirectory = new File(fixturesPath);\n    File[] fixtureFiles = fixturesDirectory.listFiles();\n\n    for (File fixtureFile : fixtureFiles) {\n      String fixtureName = fixtureFile.getName();\n      if (fixtureName.endsWith(fixturesExtension)) {\n        String fixtureNameWithoutExtension = fixtureName.substring(0, fixtureName.length() - fixturesExtension.length());\n        String fixtureJson = FileUtils.readFileToString(fixtureFile, Charset.defaultCharset());\n        JsonObject fixtureObject = new JsonParser().parse(fixtureJson).getAsJsonObject();\n\n        for (Map.Entry<String, JsonElement>", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "94549931_2", "part": [1, 1], "seq": [1, 1], "prompt": "class Main {\n\n    public static <T extends AbstractCommand> T parseCommandLine(String[] args) throws Exception {\n        CommandContext cm = new CommandContext();\n        JCommander jc = JCommander.newBuilder()\n                .programName(\"blobit.sh\")\n                .addObject(cm)\n                .addCommand(\"createbucket\", new CommandCreateBucket(cm))\n                .addCommand(\"deletebucket\", new CommandDeleteBucket(cm))\n                .addCommand(\"gcbucket\", new CommandGcBucket(cm))\n                .addCommand(\"listbuckets\", new CommandListBuckets(cm))\n                .addCommand(\"put\", new CommandPut(cm))\n                .addCommand(\"get\", new CommandGet(cm))\n                .addCommand(\"stat\", new CommandStat(cm))\n                .addCommand(\"ls\", new CommandLs(cm))\n                .addCommand(\"help\", new CommandHelp(cm))\n                .build();\n        cm.jCommander = jc;\n        try {\n            jc.parse(args);\n        } catch (ParameterException err) {\n            System.out.println(\"Error: \" + err.getMessage());\n            return (T) new CommandHelp(cm);\n        }\n        if (jc.getParsedCommand() == null) {\n            return (T) new CommandHelp(cm);\n        }\n        return (T) jc.getCommands().get(jc.getParsedCommand()).getObjects().get(0);\n    }\n\n    public static void main(String... args);\n\n}\n\nclass MainTest {\n\n    @Test\n    public void testNoCommand() throws Exception {\n", "reference": "        CommandHelp cl = Main.parseCommandLine(new String[]{});\n        System.out.println(\"res:\" + cl);\n        assertTrue(cl instanceof CommandHelp);\n    }\n\n}", "prediction": "        Main.parseCommandLine(new String[] {});\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "95081481_1009", "part": [1, 1], "seq": [1, 1], "prompt": "class OspfConfigUtil {\n\n    public static List<OspfProcess> processes(JsonNode jsonNodes) {\n        List<OspfProcess> ospfProcesses = new ArrayList<>();\n        if (jsonNodes == null) {\n            return ospfProcesses;\n        }\n        //From each Process nodes, get area and related interface details.\n        jsonNodes.forEach(jsonNode -> {\n            List<OspfArea> areas = new ArrayList<>();\n            //Get configured areas for the process.\n            for (JsonNode areaNode : jsonNode.path(AREAS)) {\n                List<OspfInterface> interfaceList = new ArrayList<>();\n                for (JsonNode interfaceNode : areaNode.path(INTERFACE)) {\n                    OspfInterface ospfInterface = interfaceDetails(interfaceNode);\n                    if (ospfInterface != null) {\n                        interfaceList.add(ospfInterface);\n                    }\n                }\n                //Get the area details\n                OspfArea area = areaDetails(areaNode);\n                if (area != null) {\n                    area.setOspfInterfaceList(interfaceList);\n                    areas.add(area);\n                }\n            }\n            OspfProcess process = new OspfProcessImpl();\n            process.setProcessId(jsonNode.path(PROCESSID).asText());\n            process.setAreas(areas);\n            ospfProcesses.add(process);\n        });\n\n        return ospfProcesses;\n    }\n\n    private  OspfConfigUtil();\n\n    private static Ip4Address getInterfaceIp(int interfaceIndex);\n    private static String getInterfaceMask(int interfaceIndex);\n    private static boolean isValidDigit(String strInput);\n    private static boolean isPrimitive(String value);\n    private static boolean isBoolean(String value);\n    private static boolean isValidIpAddress(String value);\n    private static OspfArea areaDetails(JsonNode areaNode);\n    private static OspfInterface interfaceDetails(JsonNode interfaceNode);\n\n    private ObjectMapper mapper;\n    private JsonNode jsonNode;\n    private List<OspfProcess> ospfProcessList;\n    private String jsonString;\n\n}\n\nclass OspfConfigUtilTest {\n\n    private ObjectMapper mapper;\n    private JsonNode jsonNode;\n    private List<OspfProcess> ospfProcessList;\n    private String jsonString;\n\n    @Test\n    public void testProcesses() throws Exception {\n", "reference": "        jsonNode.path(\"areas\");\n        ospfProcessList = OspfConfigUtil.processes(jsonNode);\n        assertThat(ospfProcessList, is(notNullValue()));\n    }\n\n}", "prediction": "        ospfProcessList = OspfConfigUtil.processes(jsonNode);\n        assertThat(ospfProcessList, is(notNullValue()));\n        assertThat(ospfProcessList.size(), is(1));\n        assertThat(ospfProcessList.get(0).processId(), is(\"1\"));\n        assertThat(ospfProcessList.get(0).areas().size(), is(1));\n        assertThat(ospfProcessList.get(0).areas().get(0).areaId(), is(1));\n        assertThat(ospfProcessList.get(0).areas().get(0).ospfInterfaceList().size(), is(1));\n        assertThat(ospfProcessList.get(0).areas().get(0).ospfInterfaceList().get(0).interfaceName(), is(\"eth0\"));\n        assertThat(ospfProcessList.get(0).areas().get(0).ospfInterfaceList().get(0).ipAddress(), is(Ip4Address.valueOf(\"10.10.10.1\")));\n        assertThat(", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "95467898_2", "part": [1, 1], "seq": [1, 1], "prompt": "class ConfigurationCommands implements Converter {\n\n\tstatic int compareConfigurations(Configuration a, Configuration b) {\n\t\tString factoryA = a.getFactoryPid();\n\t\tString factoryB = b.getFactoryPid();\n\n\t\tint result = 0;\n\n\t\tif (factoryA != null) {\n\t\t\tif (factoryB == null)\n\t\t\t\tresult = -1;\n\t\t\telse\n\t\t\t\tresult = factoryA.compareTo(factoryB);\n\t\t} else {\n\t\t\tif (factoryB == null)\n\t\t\t\tresult = 0;\n\t\t\telse\n\t\t\t\tresult = 1;\n\t\t}\n\n\t\tif (result == 0)\n\t\t\tresult = a.getPid().compareTo(b.getPid());\n\n\t\treturn result;\n\t}\n\n\tpublic  ConfigurationCommands(ConfigurationAdmin configAdmin);\n\n\t@Descriptor(\"List configurations\") public Configuration[] list();\n\t@Descriptor(\"List confgurations\") public Configuration[] list(@Descriptor(\"PID prefix\") String prefix);\n\tpublic Object info(String pid);\n\t@Override public Object convert(Class<?> desiredType, Object in);\n\t@Override public CharSequence format(Object target, int level, Converter escape);\n\tprivate CharSequence format(Configuration[] configs, int level, Converter escape);\n\tprivate CharSequence format(Configuration config, int level, Converter escape);\n\tprivate String formatType(Object value);\n\n}\n\nclass ConfigurationCommandsTest {\n\n\t@Test\n\tpublic void testCompareConfigs() {\n", "reference": "\t\t// factory before non-factory\n\t\tassertEquals(1, ConfigurationCommands.compareConfigurations(createMockConfig(null, \"\"), createMockConfig(\"\", \"\"))); \n\t\tassertEquals(-1, ConfigurationCommands.compareConfigurations(createMockConfig(\"\", \"\"), createMockConfig(null, \"\"))); \n\t\tassertEquals(0, ConfigurationCommands.compareConfigurations(createMockConfig(null, \"\"), createMockConfig(null, \"\")));\n\t\t\n\t\t// compare factory first\n\t\tassertEquals(-1, ConfigurationCommands.compareConfigurations(createMockConfig(\"aaa\", \"yyy\"), createMockConfig(\"bbb\", \"xxx\"))); \n\t\tassertEquals(1, ConfigurationCommands.compareConfigurations(createMockConfig(\"bbb\", \"xxx\"), createMockConfig(\"aaa\", \"yyy\")));\n\t\t\n\t\t// compare pid second\n\t\tassertEquals(-1, ConfigurationCommands.compareConfigurations(createMockConfig(\"aaa\", \"xxx\"), createMockConfig(\"aaa\", \"yyy\")));\n\t\tassertEquals(1, ConfigurationCommands.compareConfigurations(createMockConfig(\"aaa\", \"yyy\"), createMockConfig(\"aaa\", \"xxx\")));\n\t\tassertEquals(0, ConfigurationCommands.compareConfigurations(createMockConfig(\"aaa\", \"xxx\"), createMockConfig(\"aaa\", \"xxx\")));\n\t}\n\n}", "prediction": "\t\tConfiguration a = new ConfigurationImpl(\"a\", \"a\", null);\n\t\tConfiguration b = new ConfigurationImpl(\"b\", \"a\", null);\n\t\tConfiguration c = new ConfigurationImpl(\"c\", \"a\", null);\n\t\tConfiguration d = new ConfigurationImpl(\"d\", \"a\", null);\n\t\tConfiguration e = new ConfigurationImpl(\"e\", \"a\", null);\n\t\tConfiguration f = new ConfigurationImpl(\"f\", \"a\", null);\n\t\tConfiguration g = new ConfigurationImpl(\"g\", \"a\", null);\n\t\tConfiguration h = new ConfigurationImpl(\"h\", \"a\", null);\n\t\tConfiguration i = new ConfigurationImpl(\"i\", \"a\", null);\n\t\tConfiguration j = new ConfigurationImpl(\"j\", \"a\", null);\n\t\tConfiguration k = new ConfigurationImpl(\"k\", \"a\", null);\n\t\tConfiguration l = new ConfigurationImpl(\"l\", \"a\", null);\n\t\tConfiguration m = new ConfigurationImpl(\"m\", \"a\", null);\n\t\tConfiguration n = new ConfigurationImpl(\"n\", \"a\", null);\n\t\tConfiguration o = new ConfigurationImpl(\"o\", \"a", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "96120606_68", "part": [1, 1], "seq": [1, 1], "prompt": "class Command implements Serializable {\n\n\tpublic void validate() {\n\t\tOptional.ofNullable(getAction())\n\t\t\t.orElseThrow(()->new InvalidConfigException(String.format(MISSING_COMMAND_ARGUMENTS_MSG, getAbsoluteUri(), \"Action\")));\n\t\t\n\t\tif(CollectionUtils.isEmpty(getBehaviors()))\n\t\t\tthrow new InvalidConfigException(String.format(MISSING_COMMAND_ARGUMENTS_MSG, getAbsoluteUri(), \"Behavior\"));\n\t\t\n\t\tvalidateCommandArgument(Type.ClientAlias);\n\t\tvalidateCommandArgument(Type.AppAlias);\n\t\tvalidateCommandArgument(Type.PlatformMarker);\n\t\tvalidateCommandArgument(Type.DomainAlias);\n\t}\n\n\tpublic  Command(String absoluteUri);\n\tpublic  Command(Command source);\n\n\tpublic CollectionsTemplate<List<Behavior>, Behavior> templateBehaviors();\n\tprivate void validateCommandArgument(Type type);\n\tprivate String getMissingArgumentErrorMsg(Type type);\n\tpublic boolean isRootDomainOnly();\n\tpublic CommandElementLinked root();\n\tpublic boolean isEvent();\n\tpublic Command createRootDomainCommand();\n\tpublic String getAliasUri(Type type);\n\tpublic RefId<?> getRefId(Type type);\n\tpublic String getAbsoluteUri(Type type);\n\tpublic String getAlias(Type type);\n\tpublic Optional<CommandElementLinked> getElement(Type type);\n\tpublic CommandElementLinked getElementSafely(Type type);\n\tpublic String getRelativeUri(String input);\n\tpublic boolean isView();\n\tpublic String getAppAlias();\n\tpublic String getRootClientAlias();\n\tpublic CommandElement getRootDomainElement();\n\tpublic String getRootDomainAlias();\n\tpublic String getRootDomainUri();\n\tpublic String getAbsoluteDomainAlias();\n\tpublic String getAbsoluteDomainUri();\n\tpublic String getProcessAlias();\n\tpublic String getProcessUri();\n\tpublic String getAbsoluteAlias();\n\tpublic String getAbsoluteAliasWithAction();\n\tpublic String getAbsoluteAliasTillRootDomain();\n\tpublic String buildAlias(CommandElementLinked startElem);\n\tpublic String buildAlias(Type endWhentype);\n\tpublic String buildAlias(CommandElementLinked startElem, Type endWhentype);\n\tpublic String buildUri(CommandElementLinked startElem);\n\tpublic String buildUri(Type endWhenType);\n\tpublic String buildUri(CommandElementLinked startElem, Type endWhenType);\n\tpublic String traverseElements(CommandElementLinked startElem, BiConsumer<CommandElement, StringBuilder> cb);\n\tpublic void traverseElements(CommandElementLinked startElem, Consumer<CommandElement> cb);\n\tpublic String traverseElements(CommandElementLinked startElem, Type type, BiConsumer<CommandElement, StringBuilder> cb);\n\tpublic void traverseElements(CommandElementLinked startElem, Type type, Consumer<CommandElement> cb);\n\tpublic CommandElementLinked createRoot(Type type, String uri);\n\tpublic String toUri();\n\tpublic String toRemoteUri(Type endWhenType, Action withAction, Behavior withBehavior);\n\tprivate void addRequestParamsToUri(StringBuilder sb);\n\tpublic String[] getParameterValue(String requestParameter);\n\tpublic String getFirstParameterValue(String requestParameter);\n\tpublic boolean hasRawPayload();\n\tpublic String getRawPayload();\n\tpublic boolean containsFunction();\n\n\t@Rule\n\tpublic ExpectedException expectedEx;\n\n}\n\nclass CommandTest {\n\n\t@Rule\n\tpublic ExpectedException expectedEx;\n\n\t@Test\n\tpublic void testInvalidCommandMissingBehavior() throws Exception {\n", "reference": "\t\texpectedEx.expect(InvalidConfigException.class);\n\t\texpectedEx.expectMessage(\"Command with URI: /anthem/org/fep/p/umcase_view:100/_get cannot have null Behavior.\");\n\t\tCommand cmd = CommandBuilder.withUri(\"/anthem/org/fep/p/umcase_view:100/_get\").getCommand();\n\t\tcmd.setBehaviors(null);\n\t\tcmd.validate();\n\t}\n\n}", "prediction": "\t\tCommand command = new Command(\"http://localhost:8080/app/client/domain/process/view\");\n\t\tcommand.setAction(Action.View);\n\t\tcommand.setBehaviors(null);\n\t\texpectedEx.expect(InvalidConfigException.class);\n\t\tcommand.validate();\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "96122408_14", "part": [1, 1], "seq": [1, 1], "prompt": "class UserUtil {\n\n  public static void setUserDefaultValueForV3(Map<String, Object> userMap) {\n    List<String> roles = new ArrayList<>();\n    roles.add(ProjectUtil.UserRole.PUBLIC.getValue());\n    userMap.put(JsonKey.ROLES, roles);\n    userMap.put(\n        JsonKey.COUNTRY_CODE, propertiesCache.getProperty(JsonKey.SUNBIRD_DEFAULT_COUNTRY_CODE));\n    // Since global settings are introduced, profile visibility map should be empty during user\n    // creation\n    userMap.put(JsonKey.PROFILE_VISIBILITY, new HashMap<String, String>());\n    userMap.put(JsonKey.IS_DELETED, false);\n    userMap.put(JsonKey.CREATED_DATE, ProjectUtil.getFormattedDate());\n    userMap.put(JsonKey.STATUS, ProjectUtil.Status.ACTIVE.getValue());\n\n    if (StringUtils.isBlank((String) userMap.get(JsonKey.USERNAME))) {\n      String firstName = (String) userMap.get(JsonKey.FIRST_NAME);\n      firstName = firstName.split(\" \")[0];\n      userMap.put(JsonKey.USERNAME, firstName + \"_\" + generateUniqueString(4));\n    } else {\n      if (!userService.checkUsernameUniqueness((String) userMap.get(JsonKey.USERNAME), false)) {\n        ProjectCommonException.throwClientErrorException(ResponseCode.userNameAlreadyExistError);\n      }\n    }\n  }\n\n  private  UserUtil();\n\n  @SuppressWarnings(\"unchecked\") public static void checkPhoneUniqueness(User user, String opType);\n  @SuppressWarnings(\"unchecked\") public static void checkPhoneUniqueness(String phone);\n  public static boolean identifierExists(String type, String value);\n  public static void checkEmailUniqueness(String email);\n  public static Map<String, Object> validateExternalIdsAndReturnActiveUser(\n      Map<String, Object> userMap);\n  @SuppressWarnings(\"unchecked\") public static Map<String, Object> getUserFromExternalId(Map<String, Object> userMap);\n  public static String getUserIdFromExternalId(Map<String, Object> userMap);\n  @SuppressWarnings(\"unchecked\") public static void checkEmailUniqueness(User user, String opType);\n  public static void validateUserPhoneEmailAndWebPages(User user, String operationType);\n  public static String getEncryptedData(String value);\n  public static List<Map<String, String>> copyAndConvertExternalIdsToLower(\n      List<Map<String, String>> externalIds);\n  public static void storeOriginalExternalIdsValue(List<Map<String, String>> externalIds);\n  public static List<Map<String, String>> convertExternalIdsValueToLowerCase(\n      List<Map<String, String>> externalIds);\n  @SuppressWarnings(\"unchecked\") public static void checkExternalIdUniqueness(User user, String operation);\n  private static void throwUserAlreadyExistsException(\n      String externalId, String idType, String provider);\n  private static void throwExternalIDNotFoundException(\n      String externalId, String idType, String provider);\n  public static String encryptData(String value);\n  public static boolean updatePassword(Map<String, Object> userMap);\n  public static void addMaskEmailAndPhone(Map<String, Object> userMap);\n  public static void addMaskEmailAndMaskPhone(Map<String, Object> userMap);\n  @SuppressWarnings(\"unchecked\") public static Map<String, Object> encryptUserData(Map<String, Object> userMap);\n  public static Map<String, Object> checkProfileCompleteness(Map<String, Object> userMap);\n  public static String generateUniqueString(int length);\n  private static String baseN(BigDecimal num, int base);\n  public static void setUserDefaultValue(Map<String, Object> userMap, String callerId);\n  private static String getUsername(String name);\n  public static void validateExternalIds(User user, String operationType);\n  public static void checkEmailSameOrDiff(\n      Map<String, Object> userRequestMap, Map<String, Object> userDbRecord);\n  private static Optional<Map<String, String>> checkExternalID(\n      List<Map<String, String>> dbResExternalIds, Map<String, String> extIdMap);\n  public static void validateUserExternalIds(User user);\n  @SuppressWarnings(\"unchecked\") private static List<Map<String, String>> getUserExternalIds(String userId);\n  public static List<Map<String, Object>> getActiveUserOrgDetails(String userId);\n  @SuppressWarnings(\"unchecked\") private static List<Map<String, Object>> getUserOrgDetails(boolean isdeleted, String userId);\n  public static List<Map<String, Object>> getAllUserOrgDetails(String userId);\n  public static void toLower(Map<String, Object> userMap);\n\n  private static Response response;\n  public static CassandraOperationImpl cassandraOperationImpl;\n\n}\n\nclass UserUtilTest {\n\n  private static Response response;\n  public static CassandraOperationImpl cassandraOperationImpl;\n\n  @Test\n  public void setUserDefaultValueForV3() {\n", "reference": "    Map<String, Object> userMap = new HashMap<String, Object>();\n    userMap.put(JsonKey.FIRST_NAME, \"Test User\");\n    UserUtil.setUserDefaultValueForV3(userMap);\n    assertNotNull(userMap.get(JsonKey.USERNAME));\n    assertNotNull(userMap.get(JsonKey.STATUS));\n    assertNotNull(userMap.get(JsonKey.ROLES));\n  }\n\n}", "prediction": "    Map<String, Object> userMap = new HashMap<>();\n    UserUtil.setUserDefaultValueForV3(userMap);\n    assertNotNull(userMap.get(JsonKey.COUNTRY_CODE));\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "96518561_0", "part": [1, 1], "seq": [1, 1], "prompt": "class Utils {\n\n  static float getDimenFromString(String value) {\n    int end = value.charAt(value.length() - 3) == 'd' ? 3 : 2;\n    return Float.parseFloat(value.substring(0, value.length() - end));\n  }\n\n  static float dpToPixel(Context context, float dp);\n  static int getColorFromString(String value);\n\n}\n\nclass UtilsTest {\n\n    @Test\n    public void testGetDimenFromString() throws Exception {\n", "reference": "\n        assertEquals(22.0, Utils.getDimenFromString(\"22dip\"), 0);\n        assertEquals(1.5f, Utils.getDimenFromString(\"1.5dp\"), 0);\n        assertEquals(0.7f, Utils.getDimenFromString(\"0.7sp\"), 0);\n        assertEquals(2f, Utils.getDimenFromString(\"2in\"), 0);\n        assertEquals(22f, Utils.getDimenFromString(\"22px\"), 0);\n\n    }\n\n}", "prediction": "        assertEquals(10.0f, Utils.getDimenFromString(\"10dp\"));\n        assertEquals(10.0f, Utils.getDimenFromString(\"10dip\"));\n        assertEquals(10.0f, Utils.getDimenFromString(\"10px\"));\n        assertEquals(10.0f, Utils.getDimenFromString(\"10sp\"));\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "97642523_19", "part": [1, 1], "seq": [1, 1], "prompt": "class CoffeeHouse extends AbstractLoggingActor {\n\n    public static Props props(int caffeineLimit) {\n        return Props.create(CoffeeHouse.class, () -> new CoffeeHouse(caffeineLimit));\n    }\n\n    public  CoffeeHouse(int caffeineLimit);\n\n    @Override public Receive createReceive();\n    private boolean coffeeApproved(ApproveCoffee approveCoffee);\n    private void addGuestToBookkeeper(ActorRef guest);\n    protected ActorRef createBarista();\n    protected ActorRef createWaiter();\n    protected ActorRef createGuest(Coffee favoriteCoffee);\n\n}\n\nclass CoffeeHouseTest extends AbstractLoggingActor {\n\n    @Test\n    public void shouldLogMessageWhenCreated() {\n", "reference": "        new JavaTestKit(system) {{\n            interceptDebugLogMessage(this, \".*[Oo]pen.*\", 1, () -> system.actorOf(CoffeeHouse.props(Integer.MAX_VALUE)));\n        }};\n    }\n\n}", "prediction": "        new TestKit(system) {{\n            new CoffeeHouse(10);\n            expectMsgEquals(\"CoffeeHouse is ready!\");\n        }};\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "99569378_39", "part": [1, 1], "seq": [1, 1], "prompt": "class ActorsPackageDescriptionImpl implements ActorsPackageDescription {\n\n    @NotNull\n    @Override\n    public String getBuilderClassName() {\n        assert mElement != null;\n        ActorsPackage annotation = mElement.getAnnotation(ActorsPackage.class);\n        return annotation.builderName();\n    }\n\n      ActorsPackageDescriptionImpl(@NotNull Element element);\n\n    @Override public boolean validate();\n    @Override public void describeProblems(@NotNull List<GenerationError> errors);\n    @NotNull @Override public String getPackageName();\n    @NotNull @Override public ActorsPackage.AccessLevel getAccessLevel();\n\n    private static final String PACKAGE_NAME;\n    private static final String BUILDER_CLASS_NAME;\n    @Mock\n    private PackageElement mElement;\n    @Mock\n    private ActorsPackage mAnnotation;\n\n}\n\nclass ActorsPackageDescriptionImplTest {\n\n    private static final String PACKAGE_NAME;\n    private static final String BUILDER_CLASS_NAME;\n    @Mock\n    private PackageElement mElement;\n    @Mock\n    private ActorsPackage mAnnotation;\n\n    @Test\n    public void getBuilderClassName_sameObject_provideConfiguredAnnotation() {\n", "reference": "        ActorsPackageDescriptionImpl impl = new ActorsPackageDescriptionImpl(mElement);\n        Assert.assertEquals(BUILDER_CLASS_NAME, impl.getBuilderClassName());\n    }\n\n}", "prediction": "        when(mAnnotation.builderName()).thenReturn(BUILDER_CLASS_NAME);\n        ActorsPackageDescriptionImpl description = new ActorsPackageDescriptionImpl(mElement);\n        assertEquals(BUILDER_CLASS_NAME, description.getBuilderClassName());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "99890719_56", "part": [1, 1], "seq": [1, 1], "prompt": "class AlternativePatternInstancePredicate {\n\n    public boolean test(Overlap violation, Collection<Overlap> instances) {\n        for (Overlap instance : instances) {\n            if (violation.isInTargetOverlap(instance)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n}\n\nclass AlternativePatternInstancePredicateTest {\n\n    @Test\n    public void keepsViolation_isInstanceOfRelatedPatternButViolationOverlapExtendsInstance() {\n", "reference": "        final TestAUGBuilder target = buildAUG().withActionNodes(\"a\", \"b\", \"c\");\n        final TestAUGBuilder violatedPattern = buildAUG().withActionNodes(\"a\", \"b\", \"d\");\n        final TestAUGBuilder satisfiedPattern = buildAUG().withActionNodes(\"a\", \"c\");\n        final Overlap violation = buildOverlap(violatedPattern, target).withNodes(\"a\", \"b\").build();\n        final Overlap instance = buildOverlap(satisfiedPattern, target).withNodes(\"a\", \"c\").build();\n        final AlternativePatternInstancePredicate filter = new AlternativePatternInstancePredicate();\n\n        assertFalse(filter.test(violation, Collections.singleton(instance)));\n    }\n\n}", "prediction": "        Overlap violation = new Overlap(1, 10, 10, 20);\n        Overlap instance = new Overlap(1, 10, 10, 20);\n        AlternativePatternInstancePredicate predicate = new AlternativePatternInstancePredicate();\n        assertTrue(predicate.test(violation, Collections.singletonList(instance)));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "99997703_207", "part": [1, 1], "seq": [1, 1], "prompt": "class ConstantSpeedTraversalSection implements TraversalSection, Serializable {\n\n    @Override\n    public double getDuration() {\n        return time;\n    }\n\n      ConstantSpeedTraversalSection(double distance, double speed, double time);\n\n    @Override public double getTotalDistance();\n    @Override public double getDistanceAtTime(@Nonnegative double time);\n    @Override public double getTimeAtDistance(@Nonnegative double distance);\n    @Override public double getSpeedAtTime(@Nonnegative double time);\n    @Override public double getAccelerationAtDistance(@Nonnegative double distance);\n    @Override public double getAccelerationAtTime(@Nonnegative double time);\n    @Override public boolean isConstantSpeed();\n    @Override public String toString();\n    @Override public boolean equals(Object o);\n    @Override public int hashCode();\n\n    private static final double DURATION;\n    private static final double DISTANCE;\n    private static final double SPEED;\n    private final ConstantSpeedTraversalSection traversalSection;\n\n}\n\nclass ConstantSpeedTraversalSectionTest {\n\n    private static final double DURATION;\n    private static final double DISTANCE;\n    private static final double SPEED;\n    private final ConstantSpeedTraversalSection traversalSection;\n\n    @Test\n    @DisplayName(\"getDuration() method\")\n    void testGetDuration_returnsFullDuration() {\n", "reference": "        assertThat(traversalSection.getDuration()).isEqualTo(DURATION);\n    }\n\n}", "prediction": "        assertEquals(DURATION, traversalSection.getDuration());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "100069523_35", "part": [1, 1], "seq": [1, 1], "prompt": "class TextUtil {\n\n\tpublic static String formatByteCountSI(long bytes) {\n\n\t\tlong b = bytes == Long.MIN_VALUE ? Long.MAX_VALUE : Math.abs(bytes);\n\t\treturn b < 1000L ? bytes + \" B\"\n\t\t\t\t: b < 999_950L ? String.format(\"%.1f kB\", b / 1e3)\n\t\t\t\t\t\t: (b /= 1000) < 999_950L ? String.format(\"%.1f MB\", b / 1e3)\n\t\t\t\t\t\t\t\t: (b /= 1000) < 999_950L ? String.format(\"%.1f GB\", b / 1e3)\n\t\t\t\t\t\t\t\t\t\t: (b /= 1000) < 999_950L ? String.format(\"%.1f TB\", b / 1e3)\n\t\t\t\t\t\t\t\t\t\t\t\t: (b /= 1000) < 999_950L ? String.format(\"%.1f PB\", b / 1e3)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t: String.format(\"%.1f EB\", b / 1e6);\n\t}\n\n\tpublic static String formatByteCount(long bytes);\n\tpublic static long unformatByteCount(String count);\n\n}\n\nclass TextUtilTest {\n\n\t@Test\n\t@DisplayName(\"Format byte counts in SI system\")\n\tvoid formatByteCountSI_1() {\n", "reference": "\n\t\tassertEquals(\"0 B\", formatByteCountSI(0L));\n\t\tassertEquals(\"27 B\", formatByteCountSI(27L));\n\t\tassertEquals(\"999 B\", formatByteCountSI(999L));\n\t\tassertEquals(\"1.0 kB\", formatByteCountSI(1000L));\n\t\tassertEquals(\"1.0 kB\", formatByteCountSI(1023L));\n\t\tassertEquals(\"1.0 kB\", formatByteCountSI(1024L));\n\t\tassertEquals(\"1.7 kB\", formatByteCountSI(1728L));\n\t\tassertEquals(\"110.6 kB\", formatByteCountSI(110592L));\n\t\tassertEquals(\"7.1 MB\", formatByteCountSI(7077888L));\n\t\tassertEquals(\"453.0 MB\", formatByteCountSI(452984832L));\n\t\tassertEquals(\"29.0 GB\", formatByteCountSI(28991029248L));\n\t\tassertEquals(\"1.9 TB\", formatByteCountSI(1855425871872L));\n\t\tassertEquals(\"9.2 EB\", formatByteCountSI(9223372036854775807L));\n\t}\n\n}", "prediction": "\t\tassertEquals(\"1 B\", TextUtil.formatByteCountSI(1));\n\t\tassertEquals(\"1 kB\", TextUtil.formatByteCountSI(1000));\n\t\tassertEquals(\"1.0 kB\", TextUtil.formatByteCountSI(1023));\n\t\tassertEquals(\"1.0 MB\", TextUtil.formatByteCountSI(1_000_000));\n\t\tassertEquals(\"1.0 GB\", TextUtil.formatByteCountSI(1_000_000_000));\n\t\tassertEquals(\"1.0 TB\", TextUtil.formatByteCountSI(1_000_000_000_000L));\n\t\tassertEquals(\"1.0 PB\", TextUtil.formatByteCountSI(1_000_000_000_000_000L));\n\t\tassertEquals(\"1.0 EB\", TextUtil.formatByteCountSI(1_000_000_000_000_000_000L));\n\t}", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "101035547_0", "part": [1, 1], "seq": [1, 1], "prompt": "class VavrHammingEncoder implements HammingEncoder {\n\n    @Override\n    public EncodedString encode(BinaryString input) {\n        String result = helper.getHammingCodewordIndices(input.getValue().length())\n          .map(i -> toHammingCodeValue(i, input))\n          .reduce(String::concat);\n\n        return EncodedString.of(result);\n    }\n\n    private String toHammingCodeValue(int it, BinaryString input);\n\n    private HammingEncoder sut;\n\n}\n\nclass VavrHammingEncoderTest {\n\n    private HammingEncoder sut;\n\n    @Test\n    @DisplayName(\"should always encode zeros to zeros\")\n    void shouldEncodeZeros() {\n", "reference": "        Stream.iterate(\"0\", i -> i + \"0\")\n          .take(1000)\n          .map(it -> sut.encode(BinaryString.of(it)).getValue())\n          .forEach(msg -> assertThat(msg).doesNotContain(\"1\"));\n    }\n\n}", "prediction": "        // given\n        BinaryString input = BinaryString.of(\"00000000000000000000000000000000\");\n\n        // when\n        EncodedString result = sut.encode(input);\n\n        // then\n        assertThat(result.getValue()).isEqualTo(\"00000000000000000000000000000000\");\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "101264271_1", "part": [1, 1], "seq": [1, 1], "prompt": "class DeviceListActivity extends AppCompatActivity implements DeviceListPresenter.View {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        RLog.d();\n        binding = DataBindingUtil.setContentView(this, R.layout.activity_device_list);\n\n        // setup scan recyclerView\n        setupScanRecyclerView();\n\n        // create presenter\n        createPresenter();\n\n        // setup rx event\n        setupConnectEvent();\n\n    }\n\n    @Override protected void onResume();\n    @Override protected void onPause();\n    @Override protected void onDestroy();\n    private void setupScanRecyclerView();\n    private void createPresenter();\n    @Override public void showToast(String s);\n    @Override public void checkPermission(String rationaleMessage, String... permissions);\n    @Override public void startActionRequestEnable();\n    @Override public void addBluetoothDevice(BluetoothItem item);\n    @Override protected void onActivityResult(int requestCode, int resultCode, Intent data);\n    private void setupConnectEvent();\n\n    private DeviceListPresenter presenter;\n\n}\n\nclass DeviceListActivityTest implements DeviceListPresenter.View {\n\n    private DeviceListPresenter presenter;\n\n    @Test\n    public void onCreate() throws Exception {\n", "reference": "        presenter.startBluetooth();\n    }\n\n}", "prediction": "        presenter.onCreate();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "102137829_24", "part": [1, 1], "seq": [1, 1], "prompt": "class KeyFileXmlParser implements KeyFileParser {\n\n    public KeyFile fromXml(byte[] inputBytes) {\n        try {\n            ByteArrayInputStream inputStream = new ByteArrayInputStream(inputBytes);\n            return parser.fromXml(inputStream, null, KeyFile.class);\n        } catch (KeePassDatabaseUnreadableException e) {\n            return new KeyFile(false);\n        }\n    }\n\n    public  KeyFileXmlParser(XmlParser parser);\n\n    @Override public KeyFileBytes readKeyFile(byte[] keyFile);\n    private byte[] getBytesFromKeyFile(KeyFile keyFile);\n\n}\n\nclass KeyFileXmlParserTest {\n\n    @Test\n    public void whenInputIsKeyFileShouldParseFileAndReturnCorrectData() throws IOException {\n", "reference": "        FileInputStream fileInputStream = new FileInputStream(ResourceUtils.getResource(\"DatabaseWithKeyfile.key\"));\n        byte[] keyFileContent = StreamUtils.toByteArray(fileInputStream);\n\n        SimpleXmlParser parser = new SimpleXmlParser();\n        KeyFile keyFile = new KeyFileXmlParser(parser).fromXml(keyFileContent);\n\n        Assert.assertEquals(\"RP+rYNZL4lrGtDMBPzOuctlh3NAutSG5KGsT38C+qPQ=\", keyFile.getKey().getData());\n    }\n\n}", "prediction": "        KeyFile keyFile = new KeyFile(true);\n        keyFile.setKeyFileVersion(KeyFileVersion.V3);\n        keyFile.setKeyFileCreationTime(new Date());\n        keyFile.setKeyFileLastModificationTime(new Date());\n        keyFile.setKeyFileLastAccessTime(new Date());\n        keyFile.setKeyFileExpirationTime(new Date());\n        keyFile.setKeyFilePassword(new KeyFilePassword(\"password\"));\n        keyFile.setKeyFileCompression(KeyFileCompression.GZip);\n        keyFile.setKeyFileEncryption(KeyFileEncryption.AES256);\n        keyFile.setKeyFileEncryptionKey(new KeyFileEncryptionKey(\"encryptionKey\"));\n        keyFile.setKeyFileEncryptionKeySalt(new KeyFileEncryptionKeySalt(\"encryptionKeySalt\"));\n        keyFile.setKeyFileEncryptionKeyIterations(1000);\n        keyFile.setKeyFileEncryptionKeyDerivationFunction(KeyFileEncryptionKeyDerivationFunction.PBKDF2);\n        keyFile.setKeyFileEncryptionKeyDerivationSalt(new KeyFileEncryptionKeyDerivationSalt(\"encryptionKeyDerivationSalt\"));\n        keyFile.setKeyFileEncryptionKeyDerivationIterations(1000);\n        keyFile.setKeyFileEncryptionKeyDerivationPrf(KeyFileEncryptionKeyDerivationPrf.HMACSHA256);\n        keyFile.setKeyFileEncryptionKeyDerivationPrfIterations(1000);\n        keyFile.setKeyFileEncryptionKeyDerivationPrfSalt(new KeyFileEncryptionKeyDerivationPrfSalt(\"encryptionKeyDerivationPrfSalt\"));\n        keyFile.setKeyFileEncryptionKeyDerivationPrfIterations(1000);\n        keyFile.setKeyFileEncryptionKeyDerivationPrfSalt(new KeyFileEncryptionKeyDerivationPrfSalt(\"encryptionKeyDerivationPrfSalt\"));\n        keyFile.setKeyFileEncryptionKeyDerivationPrfIterations(1000);\n        keyFile.setKeyFileEncryptionKeyDerivationPrfSalt(new KeyFileEncryptionKeyDerivationPrfSalt(\"encryptionKeyDerivationPrfSalt\"));\n        keyFile.setKeyFileEncryptionKeyDerivationPrfIterations(1000);\n        keyFile.setKeyFileEncryptionKeyDerivationPrfSalt(new KeyFileEncryptionKeyDerivationPrfSalt(\"encryptionKeyDerivationPrfSalt\"));\n        keyFile.setKeyFileEncryptionKeyDerivationPrfIterations(1000);\n        keyFile.setKeyFileEncryptionKeyDerivationPrfSalt(new KeyFileEncryptionKeyDerivationPrfSalt(\"encryptionKeyDerivationPrfSalt\"));\n        keyFile.setKeyFileEncryptionKeyDerivationPrfIterations(1000);\n        keyFile.setKeyFileEncryptionKeyDerivationPrfSalt(new KeyFileEncryptionKeyDerivationPrfSalt(\"encryptionKeyDerivationPrfSalt\"));\n        keyFile.setKeyFileEncryptionKeyDerivationPrfIterations(1000);\n        keyFile.setKeyFileEncryptionKeyDerivationPrfSalt(new KeyFileEncryptionKeyDerivationPrfSalt(\"encryptionKeyDerivationPrfSalt\"));\n        keyFile.setKeyFileEncryptionKeyDerivationPrfIterations(1000);\n        keyFile.setKeyFileEncryptionKeyDerivationPrfSalt(new KeyFileEncryptionKeyDerivationPrfSalt(\"encryptionKeyDerivationPrfSalt\"));\n        keyFile.setKeyFileEncryptionKeyDerivationPrfIterations(1000);\n        keyFile.setKeyFileEncryptionKeyDerivationPrfSalt(new KeyFileEncryptionKeyDerivationPrfSalt(\"encryptionKeyDerivationPrfSalt\"));\n        keyFile.setKeyFileEncryptionKeyDerivationPrfIterations(1000);\n        keyFile.setKeyFileEncryptionKeyDerivationPrfSalt(new KeyFileEncryptionKeyDerivationPrfSalt(\"encryptionKeyDerivationPrfSalt\"));\n        keyFile.setKeyFileEncryptionKeyDerivationPrfIterations(1000);\n        keyFile.setKeyFileEncryptionKeyDerivationPrfSalt(new KeyFileEncryptionKeyDerivationPrfSalt(\"encryptionKeyDerivationPrfSalt\"));\n        keyFile.setKeyFileEncryptionKeyDerivationPrfIterations(1000);\n        keyFile.setKeyFileEncryptionKeyDerivationPrfSalt(new KeyFileEncryptionKeyDerivationPrfSalt(\"encryptionKeyDerivationPrfSalt\"));\n        keyFile.setKeyFileEncryptionKeyDerivationPrfIterations(1000);\n        keyFile.setKeyFileEncryptionKeyDerivationPrfSalt(new KeyFileEncryptionKeyDerivationPrfSalt(\"encryptionKeyDerivationPrfSalt\"));\n        keyFile.setKeyFileEncryptionKeyDerivationPrfIterations(1000);\n        keyFile.setKeyFileEncryptionKeyDerivationPrfSalt(new KeyFileEncryptionKeyDerivationPrfSalt(\"encryptionKeyDerivationPrfSalt\"));\n        keyFile.setKeyFileEncryptionKeyDerivationPrfIterations(1000);\n        keyFile.setKeyFileEncryptionKeyDerivationPrfSalt(new KeyFileEncryptionKeyDerivationPrfSalt(\"encryptionKeyDerivationPrfSalt\"));\n        keyFile.setKeyFileEncryptionKeyDerivationPrfIterations(1000);\n        keyFile.setKeyFileEncryptionKeyDerivationPrfSalt(new KeyFileEncryptionKeyDerivationPrfSalt(\"encryptionKeyDerivationPrfSalt\"));\n        keyFile.setKeyFileEncryptionKeyDerivationPrfIterations(1000);\n        keyFile.setKeyFileEncryptionKeyDerivationPrfSalt(new KeyFileEncryptionKeyDerivationPrfSalt(\"encryptionKeyDerivationPrfSalt\"));\n        keyFile.setKeyFileEncryptionKeyDerivationPrfIterations(1000);\n        keyFile.setKeyFileEncryptionKeyDerivationPrfSalt(new KeyFileEncryptionKeyDerivationPrfSalt(\"encryptionKeyDerivationPrfSalt\"));\n        keyFile.setKeyFileEncryptionKeyDerivationPrfIterations(1000);\n        keyFile.setKeyFileEncryptionKeyDerivationPrfSalt(new KeyFileEncryptionKeyDerivationPrfSalt(\"encryptionKeyDerivationPrfSalt\"));\n        keyFile.setKeyFileEncryptionKeyDerivationPrfIterations(1000);\n        keyFile.setKeyFileEncryptionKeyDerivationPrfSalt(new KeyFileEncryptionKeyDerivationPrfSalt(\"encryptionKeyDerivationPrfSalt\"));\n        keyFile.setKeyFileEncryptionKeyDerivationPrfIterations(1000);\n        keyFile.", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "102597994_4", "part": [1, 1], "seq": [1, 1], "prompt": "class FstSerializer implements Serializer {\n\n    public static FstSerializer create() {\n        return new FstSerializer();\n    }\n\n    private  FstSerializer();\n\n    @Override public byte[] serialize(Serializable object);\n    @Override public Object deserialize(byte[] bytes);\n\n    private FstSerializer serializer;\n\n}\n\nclass FstSerializerTest {\n\n    private FstSerializer serializer;\n\n    @Test\n    public void create() throws Exception {\n", "reference": "        assertNotNull(FstSerializer.create());\n    }\n\n}", "prediction": "        assertNotNull(serializer);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "104025215_5", "part": [1, 1], "seq": [1, 1], "prompt": "class SafeIterableMap implements Iterable<Map.Entry<K, V>> {\n\n    @Override\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof SafeIterableMap)) {\n            return false;\n        }\n        SafeIterableMap map = (SafeIterableMap) obj;\n        if (this.size() != map.size()) {\n            return false;\n        }\n        Iterator<Map.Entry<K, V>> iterator1 = iterator();\n        Iterator iterator2 = map.iterator();\n        while (iterator1.hasNext() && iterator2.hasNext()) {\n            Map.Entry<K, V> next1 = iterator1.next();\n            Object next2 = iterator2.next();\n            if ((next1 == null && next2 != null)\n                    || (next1 != null && !next1.equals(next2))) {\n                return false;\n            }\n        }\n        return !iterator1.hasNext() && !iterator2.hasNext();\n    }\n\n    protected Entry<K, V> get(K k);\n    public V putIfAbsent(@NonNull K key, @NonNull V v);\n    protected Entry<K, V> put(@NonNull K key, @NonNull V v);\n    public V remove(@NonNull K key);\n    public int size();\n    @NonNull @Override public Iterator<Map.Entry<K, V>> iterator();\n    public Iterator<Map.Entry<K, V>> descendingIterator();\n    public IteratorWithAdditions iteratorWithAdditions();\n    public Map.Entry<K, V> eldest();\n    public Map.Entry<K, V> newest();\n    @Override public String toString();\n\n}\n\nclass SafeIterableMapTest {\n\n    @Test\n    public void testEquality3() {\n", "reference": "        SafeIterableMap<Integer, Boolean> map = mapOf(1, 2, 3, 4);\n        //noinspection EqualsBetweenInconvertibleTypes\n        assertThat(map.equals(new ArrayList<>()), is(false));\n    }\n\n}", "prediction": "        SafeIterableMap<String, String> map = new SafeIterableMap<>();\n        map.put(\"a\", \"b\");\n        map.put(\"c\", \"d\");\n        assertEquals(map, map);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "104078932_0", "part": [1, 1], "seq": [1, 1], "prompt": "class UserService {\n\n    @Transactional(\"slaveTransactionManager\")\n    public void inserUser(String username, String password) {\n        User user = new User(username, password);\n        userMapper.insert(user);\n        School school = new School(username, password);\n        schoolMapper.insert(school);\n    }\n\n    public User selectUser(int id);\n\n    @Autowired\n    private UserService userService;\n\n}\n\nclass UserServiceTest  {\n\n    @Autowired\n    private UserService userService;\n\n    @Test\n    public void addSchool() {\n", "reference": "\n        userService.inserUser(\"root2\", \"root2\");\n    }\n\n}", "prediction": "        userService.inserUser(\"test\", \"test\");\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "104141049_0", "part": [1, 1], "seq": [1, 1], "prompt": "class JdbcSessionRepository implements\n        SessionRepository<JdbcSessionRepository.JdbcSession> {\n\n    @Override\n    public void save(JdbcSession session) {\n        if (session.isNew()) {\n            try (final Connection connection = dataSource.getConnection()) {\n                connection.setAutoCommit(false);\n\n                PreparedStatement stmt = connection.prepareStatement(this.createSessionQuery);\n                stmt.setString(1, session.getId());\n                stmt.setLong(2, session.getCreationTime());\n                stmt.setLong(3, session.getLastAccessedTime());\n                stmt.setInt(4, session.getMaxInactiveInterval());\n                stmt.setLong(5, session.getExpiryTime());\n                stmt.setString(6, session.getPrincipalName());\n                int count = stmt.executeUpdate();\n                if (!session.getAttributeNames().isEmpty()) {\n                    final List<String> attributeNames = new ArrayList<>(session.getAttributeNames());\n                    try (PreparedStatement psAtt = connection.prepareStatement(this.createSessionAttributeQuery)) {\n                        for (String attributeName : attributeNames) {\n                            psAtt.setString(1, session.getId());\n                            psAtt.setString(2, attributeName);\n                            serialize(psAtt, 3, session.getAttribute(attributeName));\n                            psAtt.addBatch();\n                        }\n                        psAtt.executeBatch();\n                    }\n                }\n                connection.commit();\n\n                if (count != 1) {\n                    logger.error(\"Failed to insert session: {}\", session.getId());\n                }\n            } catch (SQLException e) {\n                logger.error(\"SqlException:\", e);\n            }\n        } else {\n            try (final Connection connection = dataSource.getConnection()) {\n\n                connection.setAutoCommit(false);\n                PreparedStatement stmt = connection.prepareStatement(this.updateSessionQuery);\n                stmt.setString(1, session.getId());\n                stmt.setLong(2, session.getLastAccessedTime());\n                stmt.setInt(3, session.getMaxInactiveInterval());\n                stmt.setLong(4, session.getExpiryTime());\n                stmt.setString(5, session.getPrincipalName());\n                stmt.setString(6, session.getId());\n                int count = stmt.executeUpdate();\n\n                Map<String, Object> delta = session.getDelta();\n                if (!delta.isEmpty()) {\n                    for (final Map.Entry<String, Object> entry : delta.entrySet()) {\n                        if (entry.getValue() == null) {\n                            try (PreparedStatement psAtt = connection.prepareStatement(this.deleteSessionAttributeQuery)) {\n                                psAtt.setString(1, session.getId());\n                                psAtt.setString(2, entry.getKey());\n                                psAtt.executeUpdate();\n                            }\n                        } else {\n                            int updatedCount = 0;\n                            try (PreparedStatement psAtt = connection.prepareStatement(this.updateSessionAttributeQuery)) {\n                                serialize(psAtt, 1, entry.getValue());\n                                psAtt.setString(2, session.getId());\n                                psAtt.setString(3, entry.getKey());\n                                updatedCount = psAtt.executeUpdate();\n                            }\n                            if (updatedCount == 0) {\n                                try (PreparedStatement psAtt = connection.prepareStatement(this.createSessionAttributeQuery)) {\n                                    psAtt.setString(1, session.getId());\n                                    psAtt.setString(2, entry.getKey());\n                                    serialize(psAtt, 3, entry.getValue());\n\n                                    psAtt.executeUpdate();\n                                }\n                            }\n\n                        }\n                    }\n                }\n                connection.commit();\n            } catch (SQLException e) {\n                logger.error(\"SqlException:\", e);\n            }\n        }\n        session.clearChangeFlags();\n    }\n\n    public  JdbcSessionRepository(DataSource dataSource);\n\n    public void setDefaultMaxInactiveInterval(int defaultMaxInactiveInterval);\n    @Override public JdbcSession createSession();\n    public Map<String, Session> getSessions();\n    @Override public JdbcSession findById(final String id);\n    @Override public void deleteById(final String id);\n    public void cleanUpExpiredSessions();\n    public void updateSessionLastAccessTime(final String id);\n    private String getQuery(String base);\n    private void prepareQueries();\n    private void serialize(PreparedStatement ps, int paramIndex, Object attributeValue);\n    private Object deserialize(ResultSet rs, String columnName);\n    public List<JdbcSession> extractData(ResultSet rs);\n    private JdbcSession getLast(List<JdbcSession> sessions);\n\n    public static DataSource ds;\n    private static Session session;\n    private static SessionConfig sessionConfig;\n    private static SessionRepository sessionRepository;\n\n}\n\nclass JdbcSessionRepositoryTest {\n\n    public static DataSource ds;\n    private static Session session;\n    private static SessionConfig sessionConfig;\n    private static SessionRepository sessionRepository;\n\n    @Test\n    public void testSave() {\n", "reference": "        session = sessionRepository.createSession();\n\n    }\n\n}", "prediction": "        sessionRepository.save(session);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "104217624_49", "part": [1, 1], "seq": [1, 1], "prompt": "class TrustAnchorValidationService {\n\n    public void validate(long trustAnchorId) {\n        Optional<TrustAnchor> maybeTrustAnchor = storage.readTx(tx -> trustAnchors.get(tx, Key.of(trustAnchorId)));\n        if (!maybeTrustAnchor.isPresent()) {\n            log.error(\"Trust anchor {} doesn't exist.\", trustAnchorId);\n            return;\n        }\n\n        TrustAnchor trustAnchor = maybeTrustAnchor.get();\n        log.info(\"trust anchor {} located at {} with subject public key info {}\", trustAnchor.getName(), trustAnchor.getLocations(), trustAnchor.getSubjectPublicKeyInfo());\n\n        TrustAnchorValidationRun validationRun = storage.readTx(tx -> {\n            final Ref<TrustAnchor> trustAnchorRef = trustAnchors.makeRef(tx, Key.of(trustAnchorId));\n            return new TrustAnchorValidationRun(trustAnchorRef, trustAnchor.getLocations().get(0));\n        });\n\n        final ValidationLocation trustAnchorValidationLocation = new ValidationLocation(validationRun.getTrustAnchorCertificateURI());\n        ValidationResult validationResult = newValidationResult(trustAnchorValidationLocation);\n\n        boolean updatedTrustAnchor = false;\n        try {\n            final Optional<Tuple2<URI, byte[]>> maybeTrustAnchorCertificate = fetchPreferredTrustAnchorCertificate(trustAnchor, validationResult);\n\n            if (maybeTrustAnchorCertificate.isPresent()) {\n                final Tuple2<URI, byte[]> res = maybeTrustAnchorCertificate.get();\n                updatedTrustAnchor = readTrustAnchorFromLocation(res.v2, trustAnchor, res.v1, validationResult);\n            } else {\n                validationResult.error(\n                        ErrorCodes.TRUST_ANCHOR_FETCH,\n                        \"any location\",\n                        String.format(\"None of the locations (%s) could be loaded.\", Joiner.on(\", \").join(trustAnchor.getLocations())));\n                validationRun.setFailed();\n            }\n\n            if (validationResult.hasFailures()) {\n                log.warn(\"Validation result for the TA {} has failures: {}\", trustAnchor.getName(),\n                        validationResult.getFailuresForAllLocations());\n            }\n\n            if (trustAnchor.getRsyncPrefetchUri() != null) {\n                storage.writeTx0(tx -> {\n                    final Ref<TrustAnchor> trustAnchorRef = trustAnchors.makeRef(tx, trustAnchor.key());\n                    rpkiRepositories.register(tx, trustAnchorRef,\n                            trustAnchor.getRsyncPrefetchUri(), RpkiRepository.Type.RSYNC_PREFETCH);\n                });\n            }\n\n            validationRun.completeWith(validationResult);\n            if (!validatedAtLeastOnce.contains(trustAnchor.getId()) || updatedTrustAnchor) {\n                if (updatedTrustAnchor) {\n                    storage.writeTx0(tx -> trustAnchors.update(tx, trustAnchor));\n                }\n                final Set<TrustAnchor> affectedTrustAnchors = Sets.newHashSet(trustAnchor);\n                if (trustAnchor.getRsyncPrefetchUri() != null) {\n                    storage.readTx(tx ->\n                            rpkiRepositories.findByURI(tx, trustAnchor.getRsyncPrefetchUri()))\n                            .ifPresent(r ->\n                                    affectedTrustAnchors.addAll(repositoryValidationService.prefetchRepository(r)));\n                }\n                affectedTrustAnchors.forEach(validationScheduler::triggerCertificateTreeValidation);\n            }\n        } catch (CommandExecutionException | IOException e) {\n            log.error(\"validation run for trust anchor {} failed\", trustAnchor, e);\n            validationRun.addCheck(new ValidationCheck(validationRun.getTrustAnchorCertificateURI(), ValidationCheck.Status.ERROR, ErrorCodes.UNHANDLED_EXCEPTION, e.toString()));\n            validationRun.setFailed();\n        } finally {\n            validatedAtLeastOnce.add(trustAnchor.getId());\n            storage.writeTx0(tx -> validationRuns.add(tx, validationRun));\n        }\n    }\n\n    @Autowired public  TrustAnchorValidationService(\n        TrustAnchors trustAnchors,\n        RpkiRepositories rpkiRepositories,\n        ValidationRuns validationRuns,\n        ValidationScheduler validationScheduler,\n        RpkiRepositoryValidationService repositoryValidationService,\n        Storage storage,\n        TrustAnchorMetricsService trustAnchorMetricsService,\n        TrustAnchorRetrievalService trustAnchorRetrievalService);\n\n    public Optional<Tuple2<URI, byte[]>> fetchPreferredTrustAnchorCertificate(TrustAnchor trustAnchor, ValidationResult validationResult);\n    private boolean readTrustAnchorFromLocation(byte[] trustAnchorCertificate, TrustAnchor trustAnchor, URI trustAnchorCertificateURI, ValidationResult validationResult);\n    private X509ResourceCertificate parseCertificate(TrustAnchor trustAnchor, byte[] certificateData, URI trustAnchorCertificateURI, ValidationResult validationResult);\n\n    private static final String DUMMY_RSYNC_URI;\n    @Autowired\n    private TrustAnchors trustAnchors;\n    @Autowired\n    private TrustAnchorValidationService subject;\n    @Autowired\n    private ValidationRuns validationRuns;\n    @Autowired\n    private TrustAnchorRetrievalService trustAnchorRetrievalService;\n\n}\n\nclass TrustAnchorValidationServiceTest  {\n\n    private static final String DUMMY_RSYNC_URI;\n    @Autowired\n    private TrustAnchors trustAnchors;\n    @Autowired\n    private TrustAnchorValidationService subject;\n    @Autowired\n    private ValidationRuns validationRuns;\n    @Autowired\n    private TrustAnchorRetrievalService trustAnchorRetrievalService;\n\n    @Test\n    public void test_empty_file() throws IOException {\n", "reference": "        TrustAnchor ta = createRipeNccTrustAnchor();\n        wtx0(tx -> trustAnchors.add(tx, ta));\n\n        ta.setLocations(ImmutableList.of(new ClassPathResource(\"empty-file.cer\").getURI().toString()));\n        wtx0(tx -> trustAnchors.update(tx, ta));\n        subject.validate(ta.key().asLong());\n\n        X509ResourceCertificate certificate = rtx(tx -> trustAnchors.get(tx, ta.key()).get().getCertificate());\n        assertThat(certificate).isNull();\n\n        Optional<TrustAnchorValidationRun> validationRun = rtx(tx -> validationRuns.findLatestCompletedForTrustAnchor(tx, ta));\n        assertThat(validationRun).isPresent();\n\n        List<ValidationCheck> validationChecks = validationRun.get().getValidationChecks();\n        assertThat(validationChecks).hasSize(1);\n        assertThat(validationChecks.get(0).getKey()).isEqualTo(ErrorCodes.REPOSITORY_OBJECT_MINIMUM_SIZE);\n    }\n\n}", "prediction": "        final TrustAnchor trustAnchor = new TrustAnchorBuilder().build();\n        final URI trustAnchorCertificateURI = new URI(\"rsync://dummy/ta.cer\");\n        final byte[] trustAnchorCertificate = new byte[0];\n        final X509ResourceCertificate certificate = parseCertificate(trustAnchor, trustAnchorCertificate, trustAnchorCertificateURI, newValidationResult(trustAnchorCertificateURI));\n        assertThat(certificate, is(nullValue()));\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "105081364_2", "part": [1, 1], "seq": [1, 1], "prompt": "class LogCompilation extends DefaultHandler implements ErrorHandler {\n\n    public static void main(String[] args) throws Exception {\n        Comparator<LogEvent> sort = LogParser.sortByStart;\n        boolean statistics = false;\n        boolean printInlining = false;\n        boolean cleanup = false;\n        boolean trapHistory = false;\n        boolean printTimeStamps = false;\n        boolean printID = true;\n        int index = 0;\n\n        while (args.length > index) {\n            String a = args[index];\n            if (a.equals(\"-e\")) {\n                sort = LogParser.sortByElapsed;\n                index++;\n            } else if (a.equals(\"-n\")) {\n                sort = LogParser.sortByNameAndStart;\n                index++;\n            } else if (a.equals(\"-s\")) {\n                sort = LogParser.sortByStart;\n                index++;\n            } else if (a.equals(\"-t\")) {\n                printTimeStamps = true;\n                index++;\n            } else if (a.equals(\"-c\")) {\n                cleanup = true;\n                index++;\n            } else if (a.equals(\"-S\")) {\n                statistics = true;\n                index++;\n            } else if (a.equals(\"-U\")) {\n                trapHistory = true;\n                index++;\n            } else if (a.equals(\"-h\")) {\n                usage(0);\n            } else if (a.equals(\"-i\")) {\n                printInlining = true;\n                index++;\n            } else if (a.equals(\"-C\")) {\n                compare = true;\n                index++;\n            } else if (a.equals(\"-d\")) {\n                printID = false;\n                index++;\n            } else {\n                if (a.charAt(0) == '-') {\n                    System.out.println(\"Unknown option '\" + a + \"', assuming file name.\");\n                }\n                break;\n            }\n        }\n\n        if (index >= args.length) {\n            usage(1);\n        }\n\n        if (compare) {\n            compareLogs(index, args);\n            return;\n        }\n\n        while (index < args.length) {\n            ArrayList<LogEvent> events = null;\n            try {\n                events = LogParser.parse(args[index], cleanup);\n            } catch (FileNotFoundException fnfe) {\n                System.out.println(\"File not found: \" + args[index]);\n                System.exit(1);\n            }\n\n            Collections.sort(events, sort);\n\n            if (statistics) {\n                printStatistics(events, System.out);\n            } else if (trapHistory) {\n                printTrapHistory(events, System.out);\n            } else {\n                for (LogEvent c : events) {\n                    if (c instanceof NMethod) {\n                        // skip these\n                        continue;\n                    }\n                    if (printTimeStamps) {\n                        System.out.print(c.getStart() + \": \");\n                    }\n                    if (c instanceof Compilation) {\n                        Compilation comp = (Compilation) c;\n                        comp.print(System.out, printID, printInlining);\n                    } else {\n                        c.print(System.out, printID);\n                    }\n                }\n            }\n            index++;\n        }\n    }\n\n    public static void usage(int exitcode);\n    public static void printStatistics(ArrayList<LogEvent> events, PrintStream out);\n    @SuppressWarnings(\"unchecked\") static void compareLogs(int index, String[] args);\n    public static void printTrapHistory(ArrayList<LogEvent> events, PrintStream out);\n\n     String logFile;\n    static final String setupArgsTieredVersion;\n    static final String setupArgsTiered;\n    static final String setupArgsTieredBatch;\n    static final String setupArgsNoTiered;\n    static final String setupArgsNoTieredBatch;\n    static final String allSetupArgs;\n\n}\n\nclass TestLogCompilation {\n\n     String logFile;\n    static final String setupArgsTieredVersion;\n    static final String setupArgsTiered;\n    static final String setupArgsTieredBatch;\n    static final String setupArgsNoTiered;\n    static final String setupArgsNoTieredBatch;\n    static final String allSetupArgs;\n\n    @Test\n    public void testDefault() throws Exception {\n", "reference": "        String[] args = {\n            logFile\n        };\n\n        LogCompilation.main(args);\n    }\n\n}", "prediction": "        LogCompilation.main(new String[] { logFile });\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "105284146_230", "part": [1, 1], "seq": [1, 1], "prompt": "class XMLImporter implements Importer {\n\n    @Override\n    public String getFormat() {\n        return \"XIIDM\";\n    }\n\n    public  XMLImporter();\n    public  XMLImporter(PlatformConfig platformConfig);\n\n    @Override public List<Parameter> getParameters();\n    @Override public String getComment();\n    private String findExtension(ReadOnlyDataSource dataSource);\n    @Override public boolean exists(ReadOnlyDataSource dataSource);\n    private boolean exists(ReadOnlyDataSource dataSource, String ext);\n    @Override public void copy(ReadOnlyDataSource fromDataSource, DataSource toDataSource);\n    @Override public Network importData(ReadOnlyDataSource dataSource, NetworkFactory networkFactory, Properties parameters);\n    private ImportOptions createImportOptions(Properties parameters);\n\n    private XMLImporter importer;\n\n}\n\nclass XMLImporterTest  {\n\n    private XMLImporter importer;\n\n    @Test\n    public void getFormat() {\n", "reference": "        assertEquals(\"XIIDM\", importer.getFormat());\n    }\n\n}", "prediction": "        assertEquals(\"XIIDM\", importer.getFormat());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "106042361_0", "part": [1, 1], "seq": [1, 1], "prompt": "class SPIDIntegrationUtil {\n\n\tpublic Element xmlStringToElement(String xmlData) throws SAXException, IOException, ParserConfigurationException {\n\t\tInputStream xmlByteArrayInputStream = new ByteArrayInputStream(xmlData.getBytes());\n\t\tElement node = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(xmlByteArrayInputStream).getDocumentElement();\n\n\t\treturn node;\n\t}\n\n\tpublic  SPIDIntegrationUtil();\n\n\tpublic String encodeAndPrintAuthnRequest(AuthnRequest authnRequest);\n\tpublic String printAuthnRequest(AuthnRequest authnRequest);\n\tpublic Credential getCredential();\n\tpublic KeyStore getKeyStore();\n\tpublic Signature getSignature();\n\n      @Autowired\n      private SPIDIntegrationUtil spidIntegrationUtil;\n\n}\n\nclass SPIDIntegrationUtilTest {\n\n      @Autowired\n      private SPIDIntegrationUtil spidIntegrationUtil;\n\n      @Test\n      public void xmlStringToXMLObjectTest() {\n", "reference": "\n            ClassLoader classLoader = getClass().getClassLoader();\n            File xmlFile = new File(classLoader.getResource(\"metadata/idp/telecom-metadata.xml\").getFile());\n            try (Scanner scanner = new Scanner(xmlFile)) {\n                  String xmlData = scanner.useDelimiter(\"\\\\Z\").next();\n                  Element node = spidIntegrationUtil.xmlStringToElement(xmlData);\n\n                  Assert.assertEquals(\"md:EntityDescriptor\", node.getNodeName());\n\n            } catch (SAXException | IOException | ParserConfigurationException e) {\n                  e.printStackTrace();\n                  Assert.fail();\n            }\n      }\n\n}", "prediction": "        String xmlData = \"<samlp:AuthnRequest xmlns:samlp=\\\"urn:oasis:names:tc:SAML:2.0:protocol\\\" ID=\\\"_1234567890\\\" Version=\\\"2.0\\\" IssueInstant=\\\"2014-02-18T12:44:20Z\\\" Destination=\\\"https://spid.gov.it/metadata\\\" AssertionConsumerServiceURL=\\\"https://spid.gov.it/acs\\\" ProtocolBinding=\\\"urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST\\\" xmlns:saml=\\\"urn:oasis:names:tc:SAML:2.0:assertion\\\" xmlns:samlp=\\\"urn:oasis:names:tc:SAML:2.0:protocol\\\">\" +\n                  \"<saml:Issuer>https://spid.gov.it/metadata</saml:Issuer>\" +\n                  \"<samlp:NameIDPolicy Format=\\\"urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress\\\" AllowCreate=\\\"true\\\"/>\" +\n                  \"<samlp:RequestedAuthnContext Comparison=\\\"exact\\\">\" +\n                  \"<saml:AuthnContextClassRef>https://www.spid.gov.it/SpidL1</saml:AuthnContextClassRef>\" +\n                  \"</samlp:RequestedAuthnContext>\" +\n                  \"</samlp:AuthnRequest>\";\n\n         Element element = spidIntegrationUtil.xmlStringToElement(xmlData);\n\n         Assert.assertNotNull(element);\n      }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "106082622_27", "part": [1, 1], "seq": [1, 1], "prompt": "class ViewCustomizer {\n\n    public StartingPosition getStartingPosition() {\n        final String requestedAction = consumeRequest.getAction();\n\n        switch (requestedAction) {\n            case \"head\":\n                return StartingPosition.newHeadPosition();\n            case \"tail\":\n                return StartingPosition.newTailPosition();\n            case \"timestamp\":\n                return StartingPosition.newPositionFromTimestamp(consumeRequest.getTimestamp());\n            case \"offsets\":\n                // todo\n            default:\n                // Fall back to resume from existing\n                return StartingPosition.newResumeFromExistingState();\n        }\n    }\n\n    public  ViewCustomizer(final View view, final ConsumeRequest consumeRequest);\n\n    public View overrideViewSettings();\n    public List<FilterDefinition> getFilterDefinitions();\n    private void overrideResultPerPartition();\n    private void overridePartitions();\n\n}\n\nclass ViewCustomizerTest {\n\n    @Test\n    public void testStartingPositionTimestamp() {\n", "reference": "        final long timestamp = 2432323L;\n\n        // Create consume request\n        final ConsumeRequest consumeRequest = new ConsumeRequest();\n        consumeRequest.setAction(\"timestamp\");\n        consumeRequest.setTimestamp(timestamp);\n\n        // Create instance & override\n        final ViewCustomizer viewCustomizer = new ViewCustomizer(new View(), consumeRequest);\n        final StartingPosition startingPosition = viewCustomizer.getStartingPosition();\n\n        // validate\n        assertNotNull(startingPosition);\n        assertFalse(startingPosition.isStartFromTail());\n        assertFalse(startingPosition.isStartFromOffsets());\n        assertTrue(startingPosition.isStartFromTimestamp());\n        assertFalse(startingPosition.isStartFromHead());\n        assertEquals(\"Has expected timestamp\", timestamp, startingPosition.getTimestamp());\n    }\n\n}", "prediction": "        final ConsumeRequest consumeRequest = new ConsumeRequest();\n        consumeRequest.setAction(\"timestamp\");\n        consumeRequest.setTimestamp(1234567890L);\n\n        final ViewCustomizer viewCustomizer = new ViewCustomizer(view, consumeRequest);\n        final StartingPosition startingPosition = viewCustomizer.getStartingPosition();\n\n        assertThat(startingPosition.getTimestamp(), is(1234567890L));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "107740230_11", "part": [1, 1], "seq": [1, 1], "prompt": "class Table implements Comparable<Table> {\n\n    public final String getName()\n    {\n        return name;\n    }\n\n    public  Table(final DBSchema schema, final String name);\n    public  Table(final DBSchema schema, final DBTableInfo tableInfo);\n    public  Table(final String name, final Table toCopy);\n\n    @Override public boolean equals(Object tableObj);\n    public int compareTo(Table tbl);\n    public final Collection<Field> getFields();\n    public final Vector<Relationship> getRelationships();\n    public void addField(final Field field);\n    public Field getField(String fldName);\n    public Field getKey();\n    public final DBTableInfo getTableInfo();\n    public final DBSchema getSchema();\n\n\tprotected static Table testtable;\n\n}\n\nclass TableTest {\n\n\tprotected static Table testtable;\n\n\t@Test\n\tpublic void testGetName() {\n", "reference": "\t\tassertTrue(testtable.getName().equals(\"testtable\"));\n\t}\n\n}", "prediction": "\t\tassertEquals(\"testtable\", testtable.getName());\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "107872025_2", "part": [1, 1], "seq": [1, 1], "prompt": "class JaroWinkler {\n\n    public final double similarity(@NonNull final String s1, @NonNull final String s2) {\n        if (s1 == null) {\n            throw new NullPointerException(\"s1 must not be null\");\n        }\n\n        if (s2 == null) {\n            throw new NullPointerException(\"s2 must not be null\");\n        }\n\n        if (s1.equals(s2)) {\n            return 1;\n        }\n\n        int[] mtp = matches(s1, s2);\n        float m = mtp[0];\n        if (m == 0) {\n            return 0f;\n        }\n        double j = ((m / s1.length() + m / s2.length() + (m - mtp[1]) / m))\n                / THREE;\n        double jw = j;\n\n        if (j > getThreshold()) {\n            jw = j + Math.min(JW_COEF, 1.0 / mtp[THREE]) * mtp[2] * (1 - j);\n        }\n        return jw;\n    }\n\n    public  JaroWinkler();\n    public  JaroWinkler(final double threshold);\n\n    public final double getThreshold();\n    public final double distance(@NonNull final String s1, @NonNull final String s2);\n    private int[] matches(@NonNull final String s1, @NonNull final String s2);\n\n     JaroWinkler jw;\n\n}\n\nclass JaroWinklerTest {\n\n     JaroWinkler jw;\n\n    @Test\n    public void testShort() {\n", "reference": "        String s = \"sl\";\n        String s2 = \"s\";\n        assert(jw.similarity(s,s2) > .8);\n    }\n\n}", "prediction": "        assertEquals(0.0, jw.similarity(\"a\", \"b\"), 0.0001);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "108101992_3", "part": [1, 1], "seq": [1, 1], "prompt": "class IRIBuilder {\n\n    public IRI buildCanvasIRI(final String canvasIdString) {\n        return rdf.createIRI(canvasIdString);\n    }\n\n    public  IRIBuilder(final Config config);\n    private  IRIBuilder();\n\n    public IRI buildResourceIRI(final String resourceIdString);\n    public IRI buildServiceIRI(final String imageServiceContext, final String resourceIdString);\n    public String buildImageServiceContext(final String viewId);\n    public String buildCanvasIRIfromPhysical(final String physical);\n    public String buildAnnotationId();\n\n}\n\nclass IRIBuilderTest {\n\n    @Test\n    void testBuildCanvasIRI() {\n", "reference": "        final Config config = new Config();\n        config.setBaseUrl(\"http://example.org/\");\n        config.setViewId(\"12345\");\n        config.setImageServiceBaseUrl(\"https://iiif.ub.uni-leipzig.de/iiif\");\n        config.setImageServiceImageDirPrefix(\"/j2k/\");\n        config.setCanvasContext(\"/canvas\");\n        final IRIBuilder iriBuilder = new IRIBuilder(config);\n        final String viewId = \"12345\";\n        final String resourceFileId = \"00000001\";\n        final String resourceIdString = config.getBaseUrl() + viewId + config.getCanvasContext() + \"/\" + resourceFileId;\n        final IRI canvasIRI = iriBuilder.buildCanvasIRI(resourceIdString);\n        assertEquals(\"http://example.org/12345/canvas/00000001\", canvasIRI.getIRIString());\n    }\n\n}", "prediction": "        final IRIBuilder iriBuilder = new IRIBuilder();\n        final IRI iri = iriBuilder.buildCanvasIRI(\"http://example.org/canvas/1\");\n        assertEquals(\"http://example.org/canvas/1\", iri.stringValue());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "108563514_0", "part": [1, 1], "seq": [1, 1], "prompt": "class TrainerPresenter implements UseCaseCallback<FederatedRepository> {\n\n    public void retrieveData() {\n        UseCase useCase = new GetTrainingData(this, repository);\n        executor.execute(useCase);\n    }\n\n    @Inject public  TrainerPresenter(TrainerView view,\n                            ModelConfiguration modelConfiguration,\n                            FederatedRepository repository,\n                            UseCaseExecutor executor,\n                            UseCaseThreadExecutor threadExecutor,\n                            @Named(\"dataset_splits\")\n                            int dataSetSplits);\n\n    @Override public void onSuccess(FederatedRepository result);\n    @Override public void onError(UseCaseError error);\n    public void sendGradient();\n    public void getUpdatedGradient();\n    public void trainNewModel();\n    private void train(int modelNumber);\n    private FederatedDataSet getTrainingSubDataSet(Integer modelNumber, FederatedDataSet trainingData);\n    public void predict();\n\n}\n\nclass TrainerPresenterTest {\n\n    @Test\n    public void testGetTrainingDataIsPassedToTheView() {\n", "reference": "        // Given\n        int numberClients = 3;\n        UseCaseExecutor executor = mock(UseCaseExecutor.class);\n        FederatedRepository repository = mock(FederatedRepository.class);\n        TrainerView view = mock(TrainerView.class);\n        ModelConfiguration modelConfiguration = mock(ModelConfiguration.class);\n        UseCaseThreadExecutor threadExecutor = mock(UseCaseThreadExecutor.class);\n\n        // When\n        TrainerPresenter cut = new TrainerPresenter(view,\n                modelConfiguration,\n                repository,\n                executor,\n                threadExecutor,\n                numberClients);\n        cut.retrieveData();\n\n        // Then\n        Mockito.verify(executor).execute(any(GetTrainingData.class));\n    }\n\n}", "prediction": "        // Given\n        TrainerPresenter presenter = new TrainerPresenter(view, modelConfiguration, repository, executor, threadExecutor, 10);\n\n        // When\n        presenter.retrieveData();\n\n        // Then\n        verify(view).showLoading();\n        verify(view).hideLoading();\n        verify(view).showTrainingData(any(FederatedDataSet.class));\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "109554428_28", "part": [1, 1], "seq": [1, 1], "prompt": "class BrokerInterceptor implements Interceptor {\n\n    @Override\n    public void notifyClientConnected(final MqttConnectMessage msg) {\n        for (final InterceptHandler handler : this.handlers.get(InterceptConnectMessage.class)) {\n            LOG.debug(\"Sending MQTT CONNECT message to interceptor. CId={}, interceptorId={}\",\n                    msg.payload().clientIdentifier(), handler.getID());\n            executor.execute(() -> handler.onConnect(new InterceptConnectMessage(msg)));\n        }\n    }\n\n    private  BrokerInterceptor(int poolSize, List<InterceptHandler> handlers);\n      BrokerInterceptor(List<InterceptHandler> handlers);\n      BrokerInterceptor(IConfig props, List<InterceptHandler> handlers);\n\n     void stop();\n    @Override public void notifyClientDisconnected(final String clientID, final String username);\n    @Override public void notifyClientConnectionLost(final String clientID, final String username);\n    @Override public void notifyTopicPublished(final MqttPublishMessage msg, final String clientID, final String username);\n    @Override public void notifyTopicSubscribed(final Subscription sub, final String username);\n    @Override public void notifyTopicUnsubscribed(final String topic, final String clientID, final String username);\n    @Override public void notifyMessageAcknowledged(final InterceptAcknowledgedMessage msg);\n    @Override public void addInterceptHandler(InterceptHandler interceptHandler);\n    @Override public void removeInterceptHandler(InterceptHandler interceptHandler);\n    private static Class<?>[] getInterceptedMessageTypes(InterceptHandler interceptHandler);\n\n    private static final AtomicInteger n;\n    private static final BrokerInterceptor interceptor;\n\n}\n\nclass BrokerInterceptorTest {\n\n    private static final AtomicInteger n;\n    private static final BrokerInterceptor interceptor;\n\n    @Test\n    public void testNotifyClientConnected() throws Exception {\n", "reference": "        interceptor.notifyClientConnected(MqttMessageBuilders.connect().build());\n        interval();\n        assertEquals(40, n.get());\n    }\n\n}", "prediction": "        final MqttConnectMessage msg = createConnectMessage();\n        interceptor.notifyClientConnected(msg);\n        Thread.sleep(1000);\n        assertEquals(1, n.get());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "109667968_43", "part": [1, 1], "seq": [1, 1], "prompt": "class MBTilesHelper {\n\n    public void setMBTileLayers(Context context, BaseLayerSwitcherPlugin baseLayerSwitcherPlugin) {\n        if (mbtilesDir.exists() && mbtilesDir.exists() && mbtilesDir.listFiles() != null) {\n            for (File mbTile : mbtilesDir.listFiles()) {\n                MBTilesLayer mbTilesLayer = new MBTilesLayer(context, mbTile, this);\n                if (!TextUtils.isEmpty(mbTilesLayer.getDisplayName())) {\n                    baseLayerSwitcherPlugin.addBaseLayer(mbTilesLayer, false);\n                }\n            }\n        }\n\n    }\n\n    private void init(List<File> offlineFiles);\n    public void initializeMbTileslayers(@NonNull Style style, List<File> offlineFiles);\n    public Pair<Set<Source>, Set<Layer>> initializeMbTileslayers(File offlineFile);\n    private void initializeMbTilesServer();\n    public void onDestroy();\n    private void addMbtiles(Style style, String id, File file);\n    private Pair<Source, List<Layer>> addMbtiles(String id, File file);\n    private TileSet createTileSet(MbtilesFile mbtiles, String urlTemplate);\n\n    @Rule\n    public MockitoRule rule;\n    private Context context;\n    @Mock\n    private Style style;\n    @Mock\n    private BaseLayerSwitcherPlugin switcherPlugin;\n    private MBTilesHelper mbTilesHelper;\n\n}\n\nclass MBTilesHelperTest  {\n\n    @Rule\n    public MockitoRule rule;\n    private Context context;\n    @Mock\n    private Style style;\n    @Mock\n    private BaseLayerSwitcherPlugin switcherPlugin;\n    private MBTilesHelper mbTilesHelper;\n\n    @Test\n    public void testSetMBTileLayers() {\n", "reference": "        ReflectionHelpers.setField(mbTilesHelper, \"mbtilesDir\", new File(\"src/test/resources/\"));\n        mbTilesHelper.setMBTileLayers(context, switcherPlugin);\n        verify(switcherPlugin, times(2)).addBaseLayer(any(MBTilesLayer.class), eq(false));\n    }\n\n}", "prediction": "        mbTilesHelper.setMBTileLayers(context, switcherPlugin);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "109986674_101", "part": [1, 1], "seq": [1, 1], "prompt": "class PropertyManager {\n\n    public void setCustomParametersFile(String customParametersFile) throws CluecumberPluginException {\n        this.customParametersFile = customParametersFile;\n        if (!isSet(customParametersFile)) {\n            return;\n        }\n        if (!fileIO.isExistingFile(customParametersFile)) {\n            throw new MissingFileException(customParametersFile + \" (customParametersFile)\");\n        }\n        Map<String, String> customParameters = propertiesFileLoader.loadPropertiesMap(customParametersFile);\n        this.customParameters.putAll(customParameters);\n    }\n\n    @Inject public  PropertyManager(\n            final CluecumberLogger logger,\n            FileIO fileIO,\n            final PropertiesFileLoader propertiesFileLoader\n    );\n\n    public String getSourceJsonReportDirectory();\n    public void setSourceJsonReportDirectory(final String sourceJsonReportDirectory);\n    public String getGeneratedHtmlReportDirectory();\n    public void setGeneratedHtmlReportDirectory(final String generatedHtmlReportDirectory);\n    public Map<String, String> getCustomParameters();\n    public void setCustomParameters(final Map<String, String> customParameters);\n     String getCustomParametersFile();\n    public boolean isFailScenariosOnPendingOrUndefinedSteps();\n    public void setFailScenariosOnPendingOrUndefinedSteps(final boolean failScenariosOnPendingOrUndefinedSteps);\n    public boolean isExpandBeforeAfterHooks();\n    public void setExpandBeforeAfterHooks(final boolean expandBeforeAfterHooks);\n    public boolean isExpandStepHooks();\n    public void setExpandStepHooks(final boolean expandStepHooks);\n    public boolean isExpandDocStrings();\n    public void setExpandDocStrings(final boolean expandDocStrings);\n    public String getCustomCssFile();\n    public void setCustomCssFile(final String customCssFile);\n    public String getCustomStatusColorPassed();\n    public void setCustomStatusColorPassed(final String customStatusColorPassed);\n    public String getCustomStatusColorFailed();\n    public void setCustomStatusColorFailed(final String customStatusColorFailed);\n    public String getCustomStatusColorSkipped();\n    public void setCustomStatusColorSkipped(final String customStatusColorSkipped);\n    public String getCustomPageTitle();\n    public void setCustomPageTitle(final String customPageTitle);\n    public void logProperties();\n    private boolean isSet(final String string);\n    private void checkHexColorValidity(String color, String colorPropertyName);\n    public PluginSettings.StartPage getStartPage();\n    public void setStartPage(final String startPage);\n\n    private PropertyManager propertyManager;\n    private CluecumberLogger logger;\n    private FileIO fileIO;\n\n}\n\nclass PropertyManagerTest {\n\n    private PropertyManager propertyManager;\n    private CluecumberLogger logger;\n    private FileIO fileIO;\n\n    @Test(expected = MissingFileException.class)\n    public void setCustomParametersFileNonExistingTest() throws CluecumberPluginException {\n", "reference": "        String customParametersFile = \"customParametersFile\";\n        when(fileIO.isExistingFile(customParametersFile)).thenReturn(false);\n        propertyManager.setCustomParametersFile(customParametersFile);\n    }\n\n}", "prediction": "        propertyManager.setCustomParametersFile(\"nonExistingFile\");\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "110417923_0", "part": [1, 1], "seq": [1, 1], "prompt": "class CoffeeMachine {\n\n\tpublic Coffee brewCoffee(CoffeeSelection selection) throws CoffeeException {\n\t\tswitch (selection) {\n\t\t\tcase FILTER_COFFEE:\n\t\t\t\treturn brewFilterCoffee();\n\t\t\t\t\n\t\t\tcase ESPRESSO:\n\t\t\t\treturn brewEspresso();\n\t\t\t\t\t\t\t\n\t\t\tdefault:\n\t\t\t\tthrow new CoffeeException(\"CoffeeSelection [\"+selection+\"] not supported!\");\n\t\t}\n\t}\n\n\tpublic  CoffeeMachine(Map<CoffeeSelection, CoffeeBean> beans);\n\n\tprivate Coffee brewEspresso();\n\tprivate Coffee brewFilterCoffee();\n\n}\n\nclass TestCoffeeMachine {\n\n\t@Test\n\tpublic void testEspresso() throws CoffeeException {\n", "reference": "\t\t// create a Map of available coffee beans\n\t\tMap<CoffeeSelection, CoffeeBean> beans = new HashMap<CoffeeSelection, CoffeeBean>();\n\t\tbeans.put(CoffeeSelection.ESPRESSO, new CoffeeBean(\"My favorite espresso bean\", 1000));\n\t\tbeans.put(CoffeeSelection.FILTER_COFFEE, new CoffeeBean(\"My favorite filter coffee bean\", 1000));\n\t\t\n\t\t// get a new CoffeeMachine object\n\t\tCoffeeMachine machine = new CoffeeMachine(beans);\n\t\t// brew a fresh coffee\n\t\tCoffee espresso = machine.brewCoffee(CoffeeSelection.ESPRESSO);\n\t\t\n\t\tAssert.assertEquals(CoffeeSelection.ESPRESSO, espresso.getSelection());\n\t\tAssert.assertEquals(28d, espresso.getQuantity(), 0.01);\n\t}\n\n}", "prediction": "\t\tCoffeeMachine coffeeMachine = new CoffeeMachine(new HashMap<CoffeeSelection, CoffeeBean>());\n\t\tCoffee coffee = coffeeMachine.brewCoffee(CoffeeSelection.ESPRESSO);\n\t\tassertEquals(CoffeeSelection.ESPRESSO, coffee.getSelection());\n\t}", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "113878762_12", "part": [1, 1], "seq": [1, 1], "prompt": "class Volume {\n\nabstract public long getLong(final long offset)abstract public long getLong(final long offset);\n\nabstract public long getLong(final long offset)abstract public void ensureAvailable(final long offset);\nabstract public long getLong(final long offset)abstract public void putLong(final long offset, final long value);\nabstract public long getLong(final long offset)abstract public void putInt(long offset, int value);\nabstract public long getLong(final long offset)abstract public void putByte(final long offset, final byte value);\nabstract public long getLong(final long offset)abstract public void putData(final long offset, final byte[] value, int size);\nabstract public long getLong(final long offset)abstract public void putData(final long offset, final ByteBuffer buf);\nabstract public long getLong(final long offset)abstract public int getInt(long offset);\nabstract public long getLong(final long offset)abstract public byte getByte(final long offset);\nabstract public long getLong(final long offset)abstract public DataInput2 getDataInput(final long offset, final int size);\nabstract public long getLong(final long offset)abstract public void close();\nabstract public long getLong(final long offset)abstract public void sync();\nabstract public long getLong(final long offset)public abstract boolean isEmpty();\nabstract public long getLong(final long offset)public abstract void deleteFile();\nabstract public long getLong(final long offset)public abstract boolean isSliced();\nabstract public long getLong(final long offset)public final void putUnsignedShort(final long offset, final int value);\nabstract public long getLong(final long offset)public final int getUnsignedShort(long offset);\nabstract public long getLong(final long offset)public int getUnsignedByte(long offset);\nabstract public long getLong(final long offset)public void putUnsignedByte(long offset, int b);\nabstract public long getLong(final long offset)abstract public File getFile();\nabstract public long getLong(final long offset)public static Volume volumeForFile(File f, boolean useRandomAccessFile, boolean readOnly);\nabstract public long getLong(final long offset)public static Factory fileFactory(final boolean readOnly, final boolean RAF, final File indexFile);\nabstract public long getLong(final long offset)public static Factory fileFactory(final boolean readOnly,\n                                      final boolean RAF,\n                                      final File indexFile,\n                                      final File physFile,\n                                      final File transLogFile);\nabstract public long getLong(final long offset)public static Factory memoryFactory(final boolean useDirectBuffer);\n\n    final int beyondInc;\n     Volume b;\n\n}\n\nclass VolumeTest {\n\n    final int beyondInc;\n     Volume b;\n\n    @Test\n    public void read_beyond_end_raf_long(){\n", "reference": "        try{\n            Volume v = new Volume.RandomAccessFileVol(Utils.tempDbFile(), false);\n            v.getLong(1000000);\n            fail();\n        }catch(IOError e){\n            assertTrue(e.getCause() instanceof  EOFException);\n        }\n    }\n\n}", "prediction": "\n         long v = b.getLong(b.getCapacity() + beyondInc);\n        Assert.assertEquals(0, v);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "114777829_217", "part": [1, 1], "seq": [1, 1], "prompt": "class HttpFilter extends GenericFilter {\n\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n            throws IOException, ServletException {\n        if (request instanceof HttpServletRequest && response instanceof HttpServletResponse) {\n            HttpServletRequest httpServletRequest = (HttpServletRequest) request;\n            HttpServletResponse httpServletResponse = (HttpServletResponse) response;\n            this.doFilter(httpServletRequest, httpServletResponse, chain);\n        } else {\n            throw new ServletException(\"not a HTTP request or a HTTP response\");\n        }\n\n    }\n\n    protected void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain);\n\n}\n\nclass HttpFilterTest {\n\n    @Test\n    void testDoFilter() throws Exception {\n", "reference": "        HttpServletRequest request = null;\n        HttpServletResponse response = null;\n        FilterChain chain = new TestFilterChain();\n        HttpFilter filter = new TestHttpFilter();\n        filter.doFilter(request, response, chain);\n    }\n\n}", "prediction": "        HttpFilter filter = new HttpFilter() {\n            @Override\n            protected void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) {\n                assertThat(request).isNotNull();\n                assertThat(response).isNotNull();\n                assertThat(chain).isNotNull();\n            }\n        };\n        filter.doFilter(mock(HttpServletRequest.class), mock(HttpServletResponse.class), mock(FilterChain.class));\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "115029573_1", "part": [1, 1], "seq": [1, 1], "prompt": "class IfcSpfReader {\n\n    public static String slurp(InputStream in) throws IOException {\n        StringBuilder out = new StringBuilder();\n        byte[] b = new byte[4096];\n        for (int n; (n = in.read(b)) != -1;) {\n            out.append(new String(b, 0, n));\n        }\n        return out.toString();\n    }\n\n    public static void main(String[] args);\n    public static List<String> showFiles(String dir);\n    private static String getExpressSchema(String ifcFile);\n    @SuppressWarnings(\"unchecked\") public void setup(String ifcFileIn);\n    public void convert(String ifcFile, String outputFile, String baseURI);\n    public void setRemoveDuplicates(boolean val);\n    public Map<String, EntityVO> getEntityMap();\n    public Map<String, TypeVO> getTypeMap();\n    public String getOntURI();\n\n    private IfcSpfReader reader;\n\n}\n\nclass TestIfcSpfReader {\n\n    private IfcSpfReader reader;\n\n    @Test\n    public final void testSlurp() {\n", "reference": "        // reader.slurp(in)\n    }\n\n}", "prediction": "        InputStream in = getClass().getResourceAsStream(\"test.ifc\");\n        String s = IfcSpfReader.slurp(in);\n        assertTrue(s.length() > 0);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "115276927_0", "part": [1, 1], "seq": [1, 1], "prompt": "class Log4jAuditor implements Auditor {\n\n    @SuppressWarnings(\"unchecked\")\n    public void audit(AuditEvent event) {\n        initFromMDC(event);\n\n        // create the logging event from audit event\n        LoggingEvent loggingEvent = new LoggingEvent(log.getName(), log, Level.DEBUG, event.getAction(), null);\n        loggingEvent.setProperty(\"username\", event.getUsername());\n        loggingEvent.setProperty(\"session\", event.getSession());\n        loggingEvent.setProperty(\"ip\", event.getIp());\n\n        // add the logging event to all appenders\n        Enumeration<Appender> en = log.getAllAppenders();\n        while (en.hasMoreElements()) {\n            en.nextElement().doAppend(loggingEvent);\n        }\n    }\n\n    public  Log4jAuditor();\n    public  Log4jAuditor(String loggerName);\n\n    protected void initFromMDC(AuditEvent event);\n\n    private Auditor auditor;\n\n}\n\nclass Log4jAuditorTest {\n\n    private Auditor auditor;\n\n    @Test\n    public void logEvent() {\n", "reference": "        auditor.audit(new AuditEvent(\"Login\").setUsername(\"decebal1\").setSession(getUUID()).setIp(\"localhost\"));\n    }\n\n}", "prediction": "        auditor.audit(new AuditEvent(\"test\", \"test\", \"test\", \"test\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "117949407_1", "part": [1, 1], "seq": [1, 1], "prompt": "class ZuulFiltersModule extends AbstractModule {\n\n    @VisibleForTesting\n    String[] findFilterLocations(AbstractConfiguration config) {\n        String[] locations = config.getStringArray(\"zuul.filters.locations\");\n        if (locations == null) {\n            locations = new String[]{\"inbound\",\"outbound\",\"endpoint\"};\n        }\n        String[] filterLocations = Arrays.stream(locations)\n                .map(String::trim)\n                .filter(blank.negate())\n                .toArray(String[]::new);\n\n        if (filterLocations.length != 0) {\n            LOG.info(\"Using filter locations: \");\n            for (String location : filterLocations) {\n                LOG.info(\"  \" + location);\n            }\n        }\n        return filterLocations;\n    }\n\n    @Override protected void configure();\n    @Provides FilterFileManagerConfig provideFilterFileManagerConfig();\n    @VisibleForTesting String[] findClassNames(AbstractConfiguration config);\n\n    @Mock AbstractConfiguration configuration;\n     ZuulFiltersModule module;\n\n}\n\nclass ZuulFiltersModuleTest {\n\n    @Mock AbstractConfiguration configuration;\n     ZuulFiltersModule module;\n\n    @Test\n    public void testEmptyFilterLocations() {\n", "reference": "        when(configuration.getStringArray(eq(\"zuul.filters.locations\"))).thenReturn(new String[0]);\n\n        String[] filterLocations = module.findFilterLocations(configuration);\n\n        assertThat(filterLocations.length, equalTo(0));\n    }\n\n}", "prediction": "        when(configuration.getStringArray(\"zuul.filters.locations\")).thenReturn(new String[0]);\n        String[] filterLocations = module.findFilterLocations(configuration);\n        assertThat(filterLocations).isEqualTo(new String[]{\"inbound\",\"outbound\",\"endpoint\"});\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "118006325_0", "part": [1, 1], "seq": [1, 1], "prompt": "class PlanetConverter {\n\n    public PlanetDTO convertPlanet(Planet planet) {\n        PlanetDTO dto = objectMapper.convertValue(planet, PlanetDTO.class);\n\n        dto.films = planet.filmsUrls.stream()\n                .map(filmUrl -> restTemplate.getForObject(filmUrl, FilmDTO.class))\n                .collect(Collectors.toList());\n\n        dto.residents = planet.residentsUrls.stream()\n                .map(filmUrl -> restTemplate.getForObject(filmUrl, PeopleDTO.class))\n                .collect(Collectors.toList());\n\n        return dto;\n    }\n\n    @Mock\n    private RestTemplate restTemplate;\n    @Autowired\n    @InjectMocks\n    private PlanetConverter converter;\n    private PeopleDTO lukeSkywalker;\n    private FilmDTO attackOfTheClones;\n    private Planet tatooine;\n\n}\n\nclass PlanetConverterTest {\n\n    @Mock\n    private RestTemplate restTemplate;\n    @Autowired\n    @InjectMocks\n    private PlanetConverter converter;\n    private PeopleDTO lukeSkywalker;\n    private FilmDTO attackOfTheClones;\n    private Planet tatooine;\n\n    @Test\n    public void converterTest() {\n", "reference": "        PlanetDTO planet = converter.convertPlanet(tatooine);\n\n        assertThat(planet, matchesSnapshot());\n    }\n\n}", "prediction": "        PlanetDTO planetDTO = converter.convertPlanet(tatooine);\n\n        assertThat(planetDTO.name).isEqualTo(tatooine.name);\n        assertThat(planetDTO.diameter).isEqualTo(tatooine.diameter);\n        assertThat(planetDTO.rotationPeriod).isEqualTo(tatooine.rotationPeriod);\n        assertThat(planetDTO.orbitalPeriod).isEqualTo(tatooine.orbitalPeriod);\n        assertThat(planetDTO.gravity).isEqualTo(tatooine.gravity);\n        assertThat(planetDTO.population).isEqualTo(tatooine.population);\n        assertThat(planetDTO.climate).isEqualTo(tatooine.climate);\n        assertThat(planetDTO.terrain).isEqualTo(tatooine.terrain);\n        assertThat(planetDTO.surfaceWater).isEqualTo(tatooine.surfaceWater);\n        assertThat(planetDTO.films).hasSize(1);\n        assertThat(planetDTO.residents).hasSize(1);\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "118132535_73", "part": [1, 1], "seq": [1, 1], "prompt": "class MessageDispatcher implements Consumer<M>, Disposable {\n\n  @Override\n  public void accept(final M message) {\n    if (disposed) {\n      return;\n    }\n\n    runner.post(\n        () -> {\n          try {\n            consumer.accept(message);\n          } catch (Throwable throwable) {\n            MobiusHooks.handleError(\n                new RuntimeException(\n                    \"Consumer threw an exception when accepting message: \" + message, throwable));\n          }\n        });\n  }\n\n    MessageDispatcher(WorkRunner runner, Consumer<M> consumer);\n\n  @Override public void dispose();\n\n  private List<String> messages;\n\n}\n\nclass MessageDispatcherTest {\n\n  private List<String> messages;\n\n  @Test\n  public void shouldSendErrorsFromConsumerToMobiusHooks() throws Exception {\n", "reference": "    // given an error handler\n    TestErrorHandler errorHandler = new TestErrorHandler();\n\n    MobiusHooks.setErrorHandler(errorHandler);\n\n    final RuntimeException expected = new RuntimeException(\"boo\");\n\n    // and a message consumer that throws an exception,\n    // when a message is dispatched\n    new MessageDispatcher<String>(\n            WorkRunners.immediate(),\n            s -> {\n              throw expected;\n            })\n        .accept(\"here's an event that should be reported as the cause of failure\");\n\n    // then the exception gets sent to the error handler.\n    assertThat(errorHandler.handledErrors).extracting(Throwable::getCause).contains(expected);\n    assertThat(errorHandler.handledErrors)\n        .extracting(Throwable::getMessage)\n        .has(\n            matching(\n                containsString(\"here's an event that should be reported as the cause of failure\")),\n            atIndex(0));\n  }\n\n}", "prediction": "    final Consumer<String> consumer = message -> {\n      throw new RuntimeException(\"Test exception\");\n    };\n\n    final MessageDispatcher dispatcher = new MessageDispatcher(runner, consumer);\n    dispatcher.accept(\"test\");\n\n    assertThat(MobiusHooks.getLastError()).isNotNull();\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "118570108_0", "part": [1, 1], "seq": [1, 1], "prompt": "class SessionVote {\n\n    @POST\n    @Path(\"/attendee\")\n    @Produces(APPLICATION_JSON)\n    @Consumes(APPLICATION_JSON)\n    public Attendee registerAttendee(Attendee name) {\n        Attendee attendee = selectedAttendeeDAO.createNewAttendee(name);\n        return attendee;\n    }\n\n    @PostConstruct private void connectToDAO();\n    @GET @Path(\"/\") @Produces(TEXT_HTML) public String info();\n    @GET @Path(\"/nessProbe\") @Produces(TEXT_PLAIN) public Response nessProbe();\n    public void setAttendeeSessionRating(AttendeeDAO attendee, SessionRatingDAO rating);\n    @PUT @Path(\"/attendee/{id}\") @Produces(APPLICATION_JSON) @Consumes(APPLICATION_JSON) public Attendee updateAttendee(@PathParam(\"id\") String id, Attendee attendee);\n    @GET @Path(\"/attendee\") @Produces(APPLICATION_JSON) public Collection<Attendee> getAllAttendees();\n    @GET @Path(\"/attendee/{id}\") @Produces(APPLICATION_JSON) public Attendee getAttendee(@PathParam(\"id\") String id);\n    @DELETE @Path(\"/attendee/{id}\") @Produces(APPLICATION_JSON) public void deleteAttendee(@PathParam(\"id\") String id);\n    @POST @Path(\"/rate\") @Produces(APPLICATION_JSON) @Consumes(APPLICATION_JSON) public SessionRating rateSession(SessionRating sessionRating);\n    @GET @Path(\"/rate\") @Produces(APPLICATION_JSON) public Collection<SessionRating> getAllSessionRatings();\n    @PUT @Path(\"/rate/{id}\") @Produces(APPLICATION_JSON) @Consumes(APPLICATION_JSON) public SessionRating updateRating(@PathParam(\"id\") String id, SessionRating newRating);\n    @GET @Path(\"/rate/{id}\") @Produces(APPLICATION_JSON) public SessionRating getRating(@PathParam(\"id\") String id);\n    @DELETE @Path(\"/rate/{id}\") @Produces(APPLICATION_JSON) public void deleteRating(@PathParam(\"id\") String id);\n    @GET @Path(\"/ratingsBySession\") @Produces(APPLICATION_JSON) @Consumes(APPLICATION_JSON) public Collection<SessionRating> allSessionVotes(@QueryParam(\"sessionId\") String sessionId);\n    @GET @Path(\"/averageRatingBySession\") @Produces(APPLICATION_JSON) @Consumes(APPLICATION_JSON) public double sessionRatingAverage(@QueryParam(\"sessionId\") String sessionId);\n    @GET @Path(\"/ratingsByAttendee\") @Produces(APPLICATION_JSON) @Consumes(APPLICATION_JSON) public Collection<SessionRating> votesByAttendee(@QueryParam(\"attendeeId\") String attendeeId);\n     void clearAllAttendees();\n     void clearAllRatings();\n\n    private static SessionVote sessionVote;\n\n}\n\nclass SessionVoteTest {\n\n    private static SessionVote sessionVote;\n\n    @Test\n    public void testRegisterAttendee() {\n", "reference": "        // API method under test:\n        Attendee johnDoe = sessionVote.registerAttendee(new Attendee(\"John Doe\"));\n        assertEquals(\"Unexpected name returned for registered attendee\", \"John Doe\", johnDoe.getName());\n\n        Attendee janeDoe = sessionVote.registerAttendee(new Attendee(\"Jane Doe\"));\n        assertEquals(\"Unexpected name returned for second registered attendee\", \"Jane Doe\", janeDoe.getName());\n        assertNotEquals(\"Both attendees have the same ID\", johnDoe.getId(), janeDoe.getId());\n\n        // Verify that both attendees are registered using a non-public method\n        Collection<Attendee> attendees = sessionVote.getAllAttendees();\n        assertTrue(\"The session vote service is missing the first registered attendee\", attendees.contains(johnDoe));\n        assertTrue(\"The session vote service is missing the second registered attendee\", attendees.contains(janeDoe));\n\n    }\n\n}", "prediction": "        Attendee attendee = new Attendee(\"John Doe\");\n        Attendee registeredAttendee = sessionVote.registerAttendee(attendee);\n        assertEquals(attendee.getName(), registeredAttendee.getName());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "120205336_2", "part": [1, 1], "seq": [1, 1], "prompt": "class SplitMap {\n\n  public long getCardinality() {\n    return index.reduceLong(0L, Container::getCardinality, (x, y) -> x + y);\n  }\n\n  public  SplitMap(PrefixIndex<Container> index, KeyInvolution involution);\n  public  SplitMap(PrefixIndex<Container> index);\n  public  SplitMap(KeyInvolution involution);\n\n  public void insert(short key, Container region);\n  public boolean contains(int value);\n  public boolean isEmpty();\n  public Stream<PrefixIndex<Container>> stream();\n   PrefixIndex<Container> getIndex();\n\n}\n\nclass SplitMapTest {\n\n  @Test\n  public void testCardinality() {\n", "reference": "    SplitMapPageWriter writer = new SplitMapPageWriter();\n    writer.add(1);\n    writer.add(1 << 14);\n    writer.add(1 << 16 | 1);\n    writer.add(1 << 17);\n    assertEquals(writer.toSplitMap().getCardinality(), 4);\n  }\n\n}", "prediction": "    SplitMap<Container> map = new SplitMap<>(new PrefixIndex<>(new Container()), new KeyInvolution());\n    assertEquals(0, map.getCardinality());\n    map.insert((short) 1, new Container().add((short) 1));\n    assertEquals(1, map.getCardinality());\n    map.insert((short) 2, new Container().add((short) 2));\n    assertEquals(2, map.getCardinality());\n  }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "120310124_1", "part": [1, 1], "seq": [1, 1], "prompt": "class Baz {\n\n    public int bazMethod() {\n        return i;\n    }\n\n    public String anotherBazMethod();\n\n}\n\nclass BazTest {\n\n    @Test\n    void testBazMethod() {\n", "reference": "        Baz testee = new Baz();\n        assertThat(testee.bazMethod(), is(6));\n    }\n\n}", "prediction": "        Baz baz = new Baz();\n        assertEquals(0, baz.bazMethod());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "120339465_12", "part": [1, 1], "seq": [1, 1], "prompt": "class HostRequestIntervalRegistry {\n\n    public long tick(String clientHostId) {\n        if (whiteList.contains(clientHostId)) {\n            return 0;\n        } else if (blackList.contains(clientHostId)) {\n            return Long.MAX_VALUE;\n        }\n        IntervalCount intervalCount = hostCounts.computeIfAbsent(clientHostId, s -> new IntervalCount(intervalDurationMs));\n        return intervalCount.resetIfExpiredAndTick();\n    }\n\n    public  HostRequestIntervalRegistry(@Value(\"${quota.host.intervalMs}\") long intervalDurationMs,\n                                       @Value(\"${quota.host.ttlMs}\") long ttlMs,\n                                       @Value(\"${quota.host.whitelist}\") String whiteList,\n                                       @Value(\"${quota.host.blacklist}\") String blackList);\n\n    @PostConstruct public void init();\n    public void clean();\n    public Map<String, Long> getContent();\n\n    private HostRequestIntervalRegistry registry;\n\n}\n\nclass HostRequestIntervalRegistryTest {\n\n    private HostRequestIntervalRegistry registry;\n\n    @Test\n    public void emptyBlacklistParsedOk(){\n", "reference": "        registry = new HostRequestIntervalRegistry(10000L, 100L,\"\", \"\");\n        assertEquals(1L, registry.tick(\"aaa\"));\n    }\n\n}", "prediction": "        assertThat(registry.getBlacklist()).isEmpty();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "120580458_0", "part": [1, 1], "seq": [1, 1], "prompt": "class Utils {\n\n    static String toJsonStr(final Map<String, String> map) {\n        if (null == map || map.isEmpty()) {\n            return null;\n        }\n\n        final StringBuilder sb = new StringBuilder();\n        sb.append('{');\n        for (final Map.Entry<String, String> entry : map.entrySet()) {\n            sb.append('\"')\n                    .append(entry.getKey().replace(\"\\\"\", \"\\\\\\\"\"))\n                    .append('\"')\n                    .append(':')\n                    .append('\"')\n                    .append(entry.getValue().replace(\"\\\"\", \"\\\\\\\"\"))\n                    .append('\"')\n                    .append(',');\n        }\n        sb.deleteCharAt(sb.length() - 1);\n        sb.append('}');\n        return sb.toString();\n    }\n\n    static int randomCode();\n    static void checkSmsTemplate(final SmsTemplate template);\n    static void checkBatchSmsTemplate(final BatchSmsTemplate template);\n    static void checkSmsResponse(final CommonResponse response);\n    static void checkPhoneNumber(final String phoneNumber);\n    static void checkNotEmpty(final String str, final String message);\n    static void checkNotEmpty(final Collection coll, final String message);\n\n}\n\nclass UtilsTest {\n\n    @Test\n    public void toJsonStr() {\n", "reference": "        final Map<String, String> map = new HashMap<>();\n        map.put(\"k1\", \"v1\");\n        map.put(\"k2\", \"v2\");\n        map.put(\"k3\", \"v3\");\n        map.put(\"k\\\"\", \"v\\\"\");\n        assertEquals(\"{\\\"k1\\\":\\\"v1\\\",\\\"k2\\\":\\\"v2\\\",\\\"k\\\\\\\"\\\":\\\"v\\\\\\\"\\\",\\\"k3\\\":\\\"v3\\\"}\", Utils.toJsonStr(map));\n    }\n\n}", "prediction": "        Map<String, String> map = new HashMap<>();\n        map.put(\"key1\", \"value1\");\n        map.put(\"key2\", \"value2\");\n        assertEquals(\"{\\\"key1\\\":\\\"value1\\\",\\\"key2\\\":\\\"value2\\\"}\", Utils.toJsonStr(map));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "122794079_3", "part": [1, 1], "seq": [1, 1], "prompt": "class KeyguardFeatures {\n\n    static int setFingerprintDisabled(\n            int currentDisabledFeatures,\n            boolean fingerprintDisabled) {\n                int keyguardDisabledFeatures;\n        if(fingerprintDisabled){\n            keyguardDisabledFeatures =\n                    currentDisabledFeatures | DevicePolicyManager.KEYGUARD_DISABLE_FINGERPRINT;\n        } else {\n            keyguardDisabledFeatures =\n                    currentDisabledFeatures & (~DevicePolicyManager.KEYGUARD_DISABLE_FINGERPRINT);\n        }\n        return keyguardDisabledFeatures;\n    }\n\n}\n\nclass KeyguardFeaturesTest {\n\n    @Test\n    public void test_changeOneKeyguardFeaturesDisabled() throws Exception {\n", "reference": "        int expected = DevicePolicyManager.KEYGUARD_DISABLE_TRUST_AGENTS\n                + DevicePolicyManager.KEYGUARD_DISABLE_FINGERPRINT;\n        int result = KeyguardFeatures.setFingerprintDisabled(\n                DevicePolicyManager.KEYGUARD_DISABLE_TRUST_AGENTS, true);\n        assertEquals(expected, result);\n    }\n\n}", "prediction": "        int currentDisabledFeatures = 0;\n        int keyguardDisabledFeatures = KeyguardFeatures.setFingerprintDisabled(\n                currentDisabledFeatures, true);\n        assertEquals(DevicePolicyManager.KEYGUARD_DISABLE_FINGERPRINT, keyguardDisabledFeatures);\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "123233499_8", "part": [1, 1], "seq": [1, 1], "prompt": "class ForumService {\n\n\tpublic void removePost(int postId){\n\t\tPost post = postDao.get(postId);\n\t\tpostDao.remove(post);\n\t\t\n\t\tTopic topic = topicDao.get(post.getTopic().getTopicId());\n\t\ttopic.setReplies(topic.getReplies() - 1);\n\t\t\n\t\tUser user =post.getUser();\n\t\tuser.setCredit(user.getCredit() - 20);\n\t\t\n\t\t//topic\u5904\u4e8eHibernate\u53d7\u7ba1\u72b6\u6001\uff0c\u65e0\u987b\u663e\u793a\u66f4\u65b0\n\t\t//topicDao.update(topic);\n\t\t//userDao.update(user);\n\t}\n\n\t@Autowired public void setTopicDao(TopicDao topicDao);\n\t@Autowired public void setUserDao(UserDao userDao);\n\t@Autowired public void setBoardDao(BoardDao boardDao);\n\t@Autowired public void setPostDao(PostDao postDao);\n\tpublic void addTopic(Topic topic);\n\tpublic void removeTopic(int topicId);\n\tpublic void addPost(Post post);\n\tpublic void addBoard(Board board);\n\tpublic void removeBoard(int boardId);\n\tpublic void makeDigestTopic(int topicId);\n\tpublic List<Board> getAllBoards();\n\tpublic Page getPagedTopics(int boardId,int pageNo,int pageSize);\n\tpublic Page getPagedPosts(int topicId,int pageNo,int pageSize);\n\tpublic Page queryTopicByTitle(String title,int pageNo,int pageSize);\n\tpublic Board getBoardById(int boardId);\n\tpublic Topic getTopicByTopicId(int topicId);\n\tpublic Post getPostByPostId(int postId);\n\tpublic void addBoardManager(int boardId,String userName);\n\tpublic void updateTopic(Topic topic);\n\tpublic void updatePost(Post post);\n\n    @SpringBean(\"forumService\")\n\tprivate ForumService forumService;\n    @SpringBean(\"userService\")\n\tprivate UserService userService;\n\n}\n\nclass ForumServiceTest  {\n\n    @SpringBean(\"forumService\")\n\tprivate ForumService forumService;\n    @SpringBean(\"userService\")\n\tprivate UserService userService;\n\n    @Test\n\t@DataSet(\"XiaoChun.DataSet.xls\")\n    public void removePost()\n    {\n", "reference": "\t\tforumService.removePost(1);\n\t\t\n\t\tPost postDb = forumService.getPostByPostId(1);\n\t\tUser userDb = userService.getUserByUserName(\"tom\");\n\t\tTopic topicDb = forumService.getTopicByTopicId(1);\n\t\t\n\t\tassertNull(postDb);\n\t\tassertEquals(userDb.getCredit(), 80);\n\t\tassertEquals(topicDb.getReplies(), 0);\n    }\n\n}", "prediction": "   \tforumService.removePost(1);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "123649054_2", "part": [1, 1], "seq": [1, 1], "prompt": "class SQSPoller {\n\n    public void poll(final int remainingTimeInMillis) {\n        Instant cutoff = Instant.now(clock)\n                .plusMillis(remainingTimeInMillis)\n                .minusMillis(TIMEOUT_BUFFER_IN_MILLIS);\n        messageDispatcher.reset();\n        int estimatedCapacity;\n        while ((estimatedCapacity = messageDispatcher.getEstimatedCapacity(cutoff)) > 0) {\n            List<Message> toProcess = sqsProxy.receiveMessages(estimatedCapacity);\n\n            if (toProcess.isEmpty()) {\n                log.info(\"No messages received from queue. Returning until next polling cycle to save cost.\");\n                return;\n            }\n\n            messageDispatcher.dispatch(toProcess);\n        }\n    }\n\n    public  SQSPoller(final SQSProxy sqsProxy, final MessageDispatcher messageDispatcher);\n\n    private static final Instant NOW;\n    @Mock\n    private SQSProxy sqsProxy;\n    @Mock\n    private MessageDispatcher messageDispatcher;\n    private SQSPoller poller;\n\n}\n\nclass SQSPollerTest {\n\n    private static final Instant NOW;\n    @Mock\n    private SQSProxy sqsProxy;\n    @Mock\n    private MessageDispatcher messageDispatcher;\n    private SQSPoller poller;\n\n    @Test\n    public void poll_noMessagesReceived() throws Exception {\n", "reference": "        when(messageDispatcher.getEstimatedCapacity(any())).thenReturn(1);\n        when(sqsProxy.receiveMessages(anyInt())).thenReturn(Collections.emptyList());\n\n        poller.poll(SQSPoller.TIMEOUT_BUFFER_IN_MILLIS * 2);\n\n        verify(messageDispatcher, never()).dispatch(any());\n    }\n\n}", "prediction": "        when(sqsProxy.receiveMessages(anyInt())).thenReturn(Collections.emptyList());\n\n        poller.poll(1000);\n\n        verify(messageDispatcher, never()).dispatch(anyList());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "124624258_2", "part": [1, 1], "seq": [1, 1], "prompt": "class TasksRepository implements TasksDataSource {\n\n    @Override\n    public Flowable<List<Task>> getTasks() {\n        // Respond immediately with cache if available and not dirty\n        if (mCachedTasks != null && !mCacheIsDirty) {\n            return Flowable.fromIterable(mCachedTasks.values()).toList().toFlowable();\n        } else if (mCachedTasks == null) {\n            mCachedTasks = new LinkedHashMap<>();\n        }\n\n        Flowable<List<Task>> remoteTasks = getAndSaveRemoteTasks();\n\n        if (mCacheIsDirty) {\n            return remoteTasks;\n        } else {\n            // Query the local storage if available. If not, query the network.\n            Flowable<List<Task>> localTasks = getAndCacheLocalTasks();\n            return Flowable.concat(localTasks, remoteTasks)\n                    .filter(tasks -> !tasks.isEmpty())\n                    .firstOrError()\n                    .toFlowable();\n        }\n    }\n\n    private  TasksRepository(@NonNull TasksDataSource tasksRemoteDataSource,\n                            @NonNull TasksDataSource tasksLocalDataSource);\n\n    public static TasksRepository getInstance(@NonNull TasksDataSource tasksRemoteDataSource,\n                                              @NonNull TasksDataSource tasksLocalDataSource);\n    public static void destroyInstance();\n    private Flowable<List<Task>> getAndCacheLocalTasks();\n    private Flowable<List<Task>> getAndSaveRemoteTasks();\n    @Override public void saveTask(@NonNull Task task);\n    @Override public void completeTask(@NonNull Task task);\n    @Override public void completeTask(@NonNull String taskId);\n    @Override public void activateTask(@NonNull Task task);\n    @Override public void activateTask(@NonNull String taskId);\n    @Override public void clearCompletedTasks();\n    @Override public Flowable<Optional<Task>> getTask(@NonNull final String taskId);\n    @Override public void refreshTasks();\n    @Override public void deleteAllTasks();\n    @Override public void deleteTask(@NonNull String taskId);\n    @Nullable private Task getTaskWithId(@NonNull String id);\n    @NonNull Flowable<Optional<Task>> getTaskWithIdFromLocalRepository(@NonNull final String taskId);\n\n    private final static String TASK_TITLE;\n    private final static String TASK_TITLE2;\n    private final static String TASK_TITLE3;\n    private static List<Task> TASKS;\n    private TasksRepository mTasksRepository;\n    private TestSubscriber<List<Task>> mTasksTestSubscriber;\n    @Mock\n    private TasksDataSource mTasksRemoteDataSource;\n    @Mock\n    private TasksDataSource mTasksLocalDataSource;\n    @Mock\n    private Context mContext;\n\n}\n\nclass TasksRepositoryTest {\n\n    private final static String TASK_TITLE;\n    private final static String TASK_TITLE2;\n    private final static String TASK_TITLE3;\n    private static List<Task> TASKS;\n    private TasksRepository mTasksRepository;\n    private TestSubscriber<List<Task>> mTasksTestSubscriber;\n    @Mock\n    private TasksDataSource mTasksRemoteDataSource;\n    @Mock\n    private TasksDataSource mTasksLocalDataSource;\n    @Mock\n    private Context mContext;\n\n    @Test\n    public void getTasks_requestsAllTasksFromLocalDataSource() {\n", "reference": "        // Given that the local data source has data available\n        setTasksAvailable(mTasksLocalDataSource, TASKS);\n        // And the remote data source does not have any data available\n        setTasksNotAvailable(mTasksRemoteDataSource);\n\n        // When tasks are requested from the tasks repository\n        mTasksRepository.getTasks().subscribe(mTasksTestSubscriber);\n\n        // Then tasks are loaded from the local data source\n        Mockito.verify(mTasksLocalDataSource).getTasks();\n        mTasksTestSubscriber.assertValue(TASKS);\n    }\n\n}", "prediction": "        // When tasks are requested from the tasks repository\n        mTasksRepository.getTasks().test();\n\n        // Then tasks are loaded from the local data source\n        verify(mTasksLocalDataSource).getTasks();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "126354357_2", "part": [1, 1], "seq": [1, 1], "prompt": "class Member {\n\n    public void setCoupons(List<Coupon> coupons) {\n        this.coupons = coupons;\n    }\n\n    @Builder public  Member(String email, String name);\n\n}\n\nclass MemberTest {\n\n    @Test\n    public void test_01() {\n", "reference": "\n        final Member member = new Member(\"asd@asd.com\", \"name\");\n        final Coupon coupon = new Coupon(member);\n        final List<Coupon> coupons = new ArrayList<>();\n        coupons.add(coupon);\n        member.setCoupons(coupons);\n\n        System.out.println(member.toString());\n    }\n\n}", "prediction": "        Member member = Member.builder().email(\"test@gmail.com\").name(\"test\").build();\n        assertEquals(\"test@gmail.com\", member.getEmail());\n        assertEquals(\"test\", member.getName());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "126875323_9", "part": [1, 1], "seq": [1, 1], "prompt": "class ManagedExecutors {\n\n    public static Runnable managedTask(Runnable task, ManagedTaskListener taskListener)\n        throws IllegalArgumentException {\n        return managedTask(task, null, taskListener);\n    }\n\n    private  ManagedExecutors();\n\n    public static boolean isCurrentThreadShutdown();\n    public static Runnable managedTask(Runnable task, Map<String, String> executionProperties, ManagedTaskListener taskListener);\n    public static Callable<V> managedTask(Callable<V> task, ManagedTaskListener taskListener);\n    public static Callable<V> managedTask(Callable<V> task, Map<String, String> executionProperties, ManagedTaskListener taskListener);\n\n}\n\nclass ManagedExecutorsTest {\n\n    @Test (expected = IllegalArgumentException.class)\n    public void testManagedTask_null_Runnable_task_2() {\n", "reference": "        Runnable task = null;\n        ManagedExecutors.managedTask(task, new HashMap<String, String>(), new ManagedTaskListenerImpl());\n    }\n\n}", "prediction": "        ManagedExecutors.managedTask(null, null);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "128274093_472", "part": [1, 1], "seq": [1, 1], "prompt": "class FlowableReplay extends ConnectableFlowable<T> implements HasUpstreamPublisher<T>, Disposable {\n\n    public static <T> ConnectableFlowable<T> create(Flowable<T> source,\n            final int bufferSize) {\n        if (bufferSize == Integer.MAX_VALUE) {\n            return createFrom(source);\n        }\n        return create(source, new ReplayBufferTask<T>(bufferSize));\n    }\n\n    private  FlowableReplay(Publisher<T> onSubscribe, Flowable<T> source,\n            final AtomicReference<ReplaySubscriber<T>> current,\n            final Callable<? extends ReplayBuffer<T>> bufferFactory);\n\n    public static Flowable<R> multicastSelector(\n            final Callable<? extends ConnectableFlowable<U>> connectableFactory,\n            final Function<? super Flowable<U>, ? extends Publisher<R>> selector);\n    public static ConnectableFlowable<T> observeOn(final ConnectableFlowable<T> cf, final Scheduler scheduler);\n    @SuppressWarnings(\"unchecked\") public static ConnectableFlowable<T> createFrom(Flowable<? extends T> source);\n    public static ConnectableFlowable<T> create(Flowable<T> source,\n            long maxAge, TimeUnit unit, Scheduler scheduler);\n    public static ConnectableFlowable<T> create(Flowable<T> source,\n            final long maxAge, final TimeUnit unit, final Scheduler scheduler, final int bufferSize);\n    static ConnectableFlowable<T> create(Flowable<T> source,\n            final Callable<? extends ReplayBuffer<T>> bufferFactory);\n    @Override public Publisher<T> source();\n    @Override protected void subscribeActual(Subscriber<? super T> s);\n    @Override public void dispose();\n    @Override public boolean isDisposed();\n    @Override public void connect(Consumer<? super Disposable> connection);\n\n}\n\nclass FlowableReplayTest {\n\n    @Test\n    public void reentrantOnNext() {\n", "reference": "        final PublishProcessor<Integer> pp = PublishProcessor.create();\n\n        TestSubscriber<Integer> ts = new TestSubscriber<Integer>() {\n            @Override\n            public void onNext(Integer t) {\n                if (t == 1) {\n                    pp.onNext(2);\n                    pp.onComplete();\n                }\n                super.onNext(t);\n            }\n        };\n\n        pp.replay().autoConnect().subscribe(ts);\n\n        pp.onNext(1);\n\n        ts.assertResult(1, 2);\n    }\n\n}", "prediction": "        final AtomicInteger count = new AtomicInteger();\n        Flowable.range(1, 5)\n        .doOnNext(new Consumer<Integer>() {\n            @Override\n            public void accept(Integer t) {\n                if (count.getAndIncrement() == 0) {\n                    Flowable.range(1, 5).subscribe();\n                }\n            }\n        })\n        .replay(1)\n        .autoConnect()\n        .test()\n        .assertResult(1, 2, 3, 4, 5);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "128527927_17", "part": [1, 1], "seq": [1, 1], "prompt": "class IntList {\n\n    public static IntList catenate(IntList A, IntList B) {\n        IntList res = new IntList(A.first, null);\n        IntList ptr = res;\n        A = A.rest;\n        while (A != null) {\n            ptr.rest = new IntList(A.first, null);\n            ptr = ptr.rest;\n            A = A.rest;\n        }\n        ptr.rest = B;\n        return res;\n    }\n\n    public  IntList(int first0, IntList rest0);\n    public  IntList();\n\n    public static void dSquareList(IntList L);\n    public static IntList squareListIterative(IntList L);\n    public static IntList squareListRecursive(IntList L);\n    public static IntList dcatenate(IntList A, IntList B);\n    public static IntList reverse(IntList A);\n    @Override public int hashCode();\n    public static IntList of(Integer... args);\n    public boolean equals(Object x);\n    private int detectCycles(IntList A);\n    @Override /** Outputs the IntList as a String. You are not expected to read * or understand this method. */ public String toString();\n\n}\n\nclass IntListTest {\n\n    @Test\n    public void testCatenate() {\n", "reference": "        IntList A = IntList.of(1, 2, 3);\n        IntList B = IntList.of(4, 5, 6);\n        IntList exp = IntList.of(1, 2, 3, 4, 5, 6);\n        assertEquals(exp, IntList.catenate(A, B));\n        assertEquals(IntList.of(1, 2, 3), A);\n    }\n\n}", "prediction": "        IntList A = new IntList(1, new IntList(2, new IntList(3, null)));\n        IntList B = new IntList(4, new IntList(5, null));\n        IntList C = IntList.catenate(A, B);\n        assertEquals(C.first, 1);\n        assertEquals(C.rest.first, 2);\n        assertEquals(C.rest.rest.first, 3);\n        assertEquals(C.rest.rest.rest.first, 4);\n        assertEquals(C.rest.rest.rest.rest.first, 5);\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "129255460_21", "part": [1, 1], "seq": [1, 1], "prompt": "class VoteCountJob {\n\n    @Scheduled(cron = \"00 00 23 * * ?\")\n    public void executeVoteCount() {\n\n        System.err.println(\"begin to start Job\");\n        List<RunningRecordWithInfo> runningRecordWithInfos = runningRecordMapper.selectRunningRecordWithInfoScoreIn24hours();\n\n        List<MailBean> mailBeanList = new ArrayList();\n        for (RunningRecordWithInfo runningRecordWithInfo : runningRecordWithInfos) {\n            System.out.println(runningRecordWithInfo);\n\n            MailBean mailBean = new MailBean();\n            mailBean.setDistance(runningRecordWithInfo.getDistance());\n            mailBean.setUsername(runningRecordWithInfo.getUsername());\n            mailBean.setCreationTime(DateUtils.parseForFrontEnd2(runningRecordWithInfo.getCreationTime()));\n\n\n            RunningRecord runningRecord = runningRecordWithInfo;\n            runningRecord.setScore(runningRecordWithInfo.getFinalScore());\n            if (runningRecord.getScore() == null) {\n                runningRecord.setStatus(1);\n                mailBean.setStatus(\"Expired\");\n            } else if (runningRecord.getScore() <= 0) {\n                runningRecord.setStatus(2);\n                mailBean.setStatus(\"Rejected\");\n            } else if (runningRecord.getScore() > 0) {\n                runningRecord.setStatus(3);\n                mailBean.setStatus(\"Passed\");\n                mailBean.setEarnedCoins(runningRecordWithInfo.getEarnedCoins());\n            }\n\n            mailBeanList.add(mailBean);\n            runningRecordMapper.updateByPrimaryKey(runningRecord);\n        }\n\n\n        mostVotedJob.insertDailyVotedCount();\n\n\n        List<DailyVotedCountVo> dailyVotedCountVos = mostVotedRecordMapper.selectByVotedDate(new Date());\n\n        dailyVotedCountVos.stream().sorted((Comparator.comparing(DailyVotedCountVo::getVotedDate)));\n\n        ThisLocalizedWeek thisLocalizedWeek = new ThisLocalizedWeek(Locale.CHINA);\n        List<WeeklyAwardedReportVo> weeklyAwardedReportVos = dailyMostVotedRecordMapper.selectWeeklyAwardedRecord(thisLocalizedWeek.getFirstDay(), thisLocalizedWeek.getLastDay());\n\n        List<UserInfoBatchBean> userInfoBatchBeans = userInfoMapper.selectUserTotalInfo();\n        for (UserInfoBatchBean userInfoBatchBean : userInfoBatchBeans) {\n            UserInfo userInfo = userInfoMapper.selectByOpenId(userInfoBatchBean.getUserOpenId());\n            userInfo.setTotalDistance(userInfoBatchBean.getTotalDistance());\n            userInfo.setCoins(userInfoBatchBean.getTotalCoins());\n            userInfoMapper.updateByPrimaryKey(userInfo);\n        }\n        List<UserInfo> userInfos = userInfoMapper.selectAllUser();\n        try {\n            mailService.sendMessageMail(mailBeanList,userInfos,dailyVotedCountVos,weeklyAwardedReportVos, \"RunningClub Report\", \"message.ftl\");\n        }catch (Exception e){\n            e.printStackTrace();\n        }\n        System.err.println(\"send email finished\");\n    }\n\n    @Autowired\n    private VoteCountJob voteCountjob;\n\n}\n\nclass VoteCountjobTest {\n\n    @Autowired\n    private VoteCountJob voteCountjob;\n\n    @Test\n    public void executeVoteCount() {\n", "reference": "       voteCountjob.executeVoteCount();\n    }\n\n}", "prediction": "        voteCountjob.executeVoteCount();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "129274227_0", "part": [1, 1], "seq": [1, 1], "prompt": "class PosterUtils {\n\n    public static File getMoviePosterFileWithName(File rootPath, String movieName) {\n        movieName = movieName.replaceAll(\"\\\\\\\\\", \"-\");\n        movieName = movieName.replaceAll(\" \", \"-\");\n        return new File(rootPath, String.format(\"%s.jpg\", movieName));\n    }\n\n    public static File getMoviePosterFileWithName(String movieName);\n    public static File getMusicFileWithName(String albumName, String musicName, String userName);\n\n}\n\nclass PosterUtilsTest {\n\n    @Test\n    public void getMoviePosterFileWithName() throws Exception {\n", "reference": "        Assert.assertEquals(\"C:\\\\\u8fd9\u4e2a--\u6740\u624b-\u4e0d-\u592a\u51b7.jgp\",\n                PosterUtils.getMoviePosterFileWithName(\n                        new File(\"C:\\\\\"),\n                        \"\u8fd9\u4e2a \\\\\u6740\u624b \u4e0d\\\\\u592a\u51b7\").getPath());\n    }\n\n}", "prediction": "        File rootPath = new File(\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\test\");\n        File posterFile = PosterUtils.getMoviePosterFileWithName(rootPath, \"test\");\n        System.out.println(posterFile.getAbsolutePath());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "129463208_1", "part": [1, 1], "seq": [1, 1], "prompt": "class SkelNode {\n\n    void addChild(SkelNode child) {\n        this.children.add(child);\n    }\n\n    public  SkelNode(Long associatedBodyId, List<Integer> location, Double radius, int type, SkelNode parent, int rowNumber);\n    public  SkelNode(Long associatedBodyId, List<Integer> location, Double radius, int rowNumber);\n    public  SkelNode();\n\n    public static String getSkelNodeListJson(List<SkelNode> skelNodeList);\n    @Override public String toString();\n    @Override public boolean equals(Object o);\n    @Override public int hashCode();\n    public List<SkelNode> getChildren();\n    public SkelNode getParent();\n    public List<Integer> getLocation();\n    public Integer getX();\n    public Integer getY();\n    public Integer getZ();\n    public int getRowNumber();\n    private String locationToStringKey(List<Integer> location);\n    public String getLocationString();\n    public Point getLocationAsPoint();\n    public String getSkelNodeId(String dataset);\n    public Double getRadius();\n    public int getType();\n    public Long getAssociatedBodyId();\n\n}\n\nclass SkelNodeTest {\n\n    @Test\n    public void testAddChild() {\n", "reference": "\n        List<Integer> location1 = new ArrayList<>();\n        location1.add(0);\n        location1.add(1);\n        location1.add(5);\n        SkelNode skelNode1 = new SkelNode(10L, location1, 3.0D, 2, new SkelNode(), 1);\n        List<Integer> location2 = new ArrayList<>();\n        location2.add(0);\n        location2.add(1);\n        location2.add(5);\n        SkelNode skelNode2 = new SkelNode(13L, location2, 34.0D, 1, new SkelNode(), 2);\n        SkelNode skelNode3 = new SkelNode(13L, location2, 34.0D, 1, new SkelNode(), 3);\n\n        skelNode1.addChild(skelNode2);\n        skelNode1.addChild(skelNode3);\n        List<SkelNode> childList = new ArrayList<>();\n        childList.add(skelNode2);\n        childList.add(skelNode3);\n\n        Assert.assertEquals(childList, skelNode1.getChildren());\n        Assert.assertEquals(2, skelNode1.getChildren().size());\n        Assert.assertEquals(0, skelNode2.getChildren().size());\n\n    }\n\n}", "prediction": "        SkelNode parent = new SkelNode();\n        SkelNode child = new SkelNode();\n        parent.addChild(child);\n        assertEquals(1, parent.getChildren().size());\n        assertEquals(child, parent.getChildren().get(0));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "129493743_0", "part": [1, 1], "seq": [1, 1], "prompt": "class PasswordEncoderImpl implements PasswordEncoder {\n\n    @Override\n    public String encode(@NonNull String rawPassword) {\n        String encodedPassword = this.updatableBCrypt.hash(rawPassword, this.keyStore.decryptString(this.customPreference.getSalt(), Constants.ALIAS_SALT));\n        return keyStore.encryptString(encodedPassword, Constants.ALIAS_PASSWORD_KEY);\n    }\n\n    public  PasswordEncoderImpl(CustomPreference customPreference, KeyStore keyStore, UpdatableBCrypt updatableBCrypt);\n\n    public void init();\n    @Override public boolean matches(@NonNull String rawPassword, @NonNull String encodedPassword);\n\n    private static final String TESTABLE_PASSWORD;\n    private static final String ENCODED_PASSWORD;\n    private static final String SALT;\n    private PasswordEncoderImpl passwordEncoder;\n    @Mock\n    private CustomPreference customPreference;\n    @Mock\n    private KeyStore keyStore;\n    @Mock\n    private UpdatableBCrypt updatableBCrypt;\n\n}\n\nclass PasswordEncoderImplTest {\n\n    private static final String TESTABLE_PASSWORD;\n    private static final String ENCODED_PASSWORD;\n    private static final String SALT;\n    private PasswordEncoderImpl passwordEncoder;\n    @Mock\n    private CustomPreference customPreference;\n    @Mock\n    private KeyStore keyStore;\n    @Mock\n    private UpdatableBCrypt updatableBCrypt;\n\n    @Test\n    public void encodeTestSuccess() {\n", "reference": "        String result = passwordEncoder.encode(TESTABLE_PASSWORD);\n\n        assertNotNull(result);\n        assertEquals(ENCODED_PASSWORD, result);\n    }\n\n}", "prediction": "        when(updatableBCrypt.hash(TESTABLE_PASSWORD, SALT)).thenReturn(ENCODED_PASSWORD);\n        String encodedPassword = passwordEncoder.encode(TESTABLE_PASSWORD);\n        assertEquals(ENCODED_PASSWORD, encodedPassword);\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "133357466_126", "part": [1, 1], "seq": [1, 1], "prompt": "class UlordSerializer extends MessageSerializer {\n\n    @Override\n    public void serialize(String name, byte[] message, OutputStream out) throws IOException {\n        byte[] header = new byte[4 + COMMAND_LEN + 4 + 4 /* checksum */];\n        uint32ToByteArrayBE(params.getPacketMagic(), header, 0);\n\n        // The header array is initialized to zero by Java so we don't have to worry about\n        // NULL terminating the string here.\n        for (int i = 0; i < name.length() && i < COMMAND_LEN; i++) {\n            header[4 + i] = (byte) (name.codePointAt(i) & 0xFF);\n        }\n\n        Utils.uint32ToByteArrayLE(message.length, header, 4 + COMMAND_LEN);\n\n        byte[] hash = Sha256Hash.hashTwice(message);\n        System.arraycopy(hash, 0, header, 4 + COMMAND_LEN + 4, 4);\n        out.write(header);\n        out.write(message);\n\n        if (log.isDebugEnabled())\n            log.debug(\"Sending {} message: {}\", name, HEX.encode(header) + HEX.encode(message));\n    }\n\n    public  UlordSerializer(NetworkParameters params, boolean parseRetain);\n\n    @Override public void serialize(Message message, OutputStream out);\n    @Override public Message deserialize(ByteBuffer in);\n    @Override public BitcoinPacketHeader deserializeHeader(ByteBuffer in);\n    @Override public Message deserializePayload(BitcoinPacketHeader header, ByteBuffer in);\n    private Message makeMessage(String command, int length, byte[] payloadBytes, byte[] hash, byte[] checksum);\n    public NetworkParameters getParameters();\n    @Override public AddressMessage makeAddressMessage(byte[] payloadBytes, int length);\n    @Override public Message makeAlertMessage(byte[] payloadBytes);\n    @Override public Block makeBlock(final byte[] payloadBytes, final int offset, final int length);\n    @Override public Message makeBloomFilter(byte[] payloadBytes);\n    @Override public FilteredBlock makeFilteredBlock(byte[] payloadBytes);\n    @Override public InventoryMessage makeInventoryMessage(byte[] payloadBytes, int length);\n    @Override public Transaction makeTransaction(byte[] payloadBytes, int offset,\n        int length, byte[] hash);\n    @Override public void seekPastMagicBytes(ByteBuffer in);\n    @Override public boolean isParseRetainMode();\n\n    private static final NetworkParameters MAINNET;\n    private static final byte[] ADDRESS_MESSAGE_BYTES;\n    private static final byte[] TRANSACTION_MESSAGE_BYTES;\n\n}\n\nclass UlordSerializerTest {\n\n    private static final NetworkParameters MAINNET;\n    private static final byte[] ADDRESS_MESSAGE_BYTES;\n    private static final byte[] TRANSACTION_MESSAGE_BYTES;\n\n    @Test(expected = Error.class)\n    public void testSerializeUnknownMessage() throws Exception {\n", "reference": "        MessageSerializer serializer = MAINNET.getDefaultSerializer();\n\n        Message unknownMessage = new Message() {\n            @Override\n            protected void parse() throws ProtocolException {\n            }\n        };\n        ByteArrayOutputStream bos = new ByteArrayOutputStream(ADDRESS_MESSAGE_BYTES.length);\n        serializer.serialize(unknownMessage, bos);\n    }\n\n}", "prediction": "        UlordSerializer serializer = new UlordSerializer(MAINNET, false);\n        serializer.serialize(new UnknownMessage(MAINNET, new byte[] { 0x01, 0x02, 0x03 }), new ByteArrayOutputStream());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "133381280_49", "part": [1, 1], "seq": [1, 1], "prompt": "class TagSet implements Iterable<Tag> {\n\n    TagSet addAll(Iterable<Tag> ts) {\n        if (ts instanceof TagSet) {\n            TagSet data = (TagSet) ts;\n            return addAll(data.tags.values());\n        }\n        Iterator<Tag> it = ts.iterator();\n        TreeMap<String, Tag> newTags = new TreeMap<String, Tag>(tags);\n        while (it.hasNext()) {\n            BasicTag tag = BasicTag.of(it.next());\n            newTags.put(tag.key(), tag);\n        }\n        return new TagSet(newTags);\n    }\n\n    public  TagSet(TreeMap<String, Tag> tags);\n\n    static TagSet create(Iterable<Tag> tags);\n    static TagSet create(Map<String, String> tags);\n    @Override public Iterator<Tag> iterator();\n     boolean isEmpty();\n     TagSet add(String k, String v);\n     TagSet add(Tag tag);\n     TagSet addAll(Map<String, String> ts);\n     TagSet addAll(String[] ts);\n     TagSet addAll(Tag[] ts);\n    @Override public boolean equals(Object o);\n    @Override public int hashCode();\n    @Override public String toString();\n\n}\n\nclass TagSetTest {\n\n    @Test\n    public void testAddAll() {\n", "reference": "        TagSet raw = new TagSet(new TreeMap<String, Tag>());\n        TagSet ts1 = raw.add(new BasicTag(\"k1\", \"k1\")).addAll(new Tag[] {})\n            .addAll(new ArrayList<Tag>()).addAll(new HashMap<String, String>());\n        System.out.println(ts1);\n        Assert.assertEquals(\"[k1=k1]\", ts1.toString());\n        Tag tag1 = new BasicTag(\"k1\", \"v1\");\n        Tag tag2 = new BasicTag(\"k2\", \"v2\");\n        Tag tag3 = new BasicTag(\"k3\", \"v3\");\n        Map<String, String> map = Maps.newTreeMap();\n        map.put(\"k3\", \"v33\");\n        map.put(\"k4\", \"v4\");\n        TagSet ts2 = raw.addAll(new Tag[] { tag1, tag2 })\n            .addAll(Lists.<Tag> newArrayList(tag2, tag3)).addAll(map);\n        System.out.println(ts2.toString());\n        Assert.assertEquals(\"[k1=v1, k2=v2, k3=v33, k4=v4]\", ts2.toString());\n\n    }\n\n}", "prediction": "        TagSet ts = TagSet.create(new BasicTag(\"k1\", \"v1\"), new BasicTag(\"k2\", \"v2\"));\n        TagSet ts2 = ts.addAll(new BasicTag(\"k3\", \"v3\"), new BasicTag(\"k4\", \"v4\"));\n        assertEquals(ts2.tags.size(), 4);\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "133799133_50", "part": [1, 1], "seq": [1, 1], "prompt": "class RequestSession {\n\n  private static String getReqProviderName(EidasRequest eidasRequest)\n  {\n    if (eidasRequest.getSectorType() == EidasRequestSectorType.PRIVATE)\n    {\n      if (eidasRequest.getRequesterId() != null)\n      {\n        return eidasRequest.getRequesterId();\n      }\n      if (eidasRequest.getProviderName() != null)\n      {\n        return eidasRequest.getProviderName();\n      }\n    }\n    return null;\n  }\n\n    RequestSession(String relayState,\n                 String reqId,\n                 String reqDestination,\n                 String reqProviderName,\n                 String reqProviderEntityId);\n  public  RequestSession(String reqId,\n                        String reqDestination,\n                        String reqProviderName,\n                        String reqProviderEntityId);\n  public  RequestSession(String relayState, EidasRequest eidasRequest);\n  public  RequestSession(EidasRequest eidasRequest);\n\n  public Optional<String> getRelayState();\n\n  private static EidasRequest eidasRequest;\n\n}\n\nclass RequestSessionTest {\n\n  private static EidasRequest eidasRequest;\n\n  @Test\n  void whenRequestTypePrivateAndRequesterIdNullThenProviderNameIsProviderName()\n  {\n", "reference": "    Mockito.when(eidasRequest.getSectorType()).thenReturn(EidasRequestSectorType.PRIVATE);\n    Mockito.when(eidasRequest.getRequesterId()).thenReturn(null);\n    Mockito.when(eidasRequest.getProviderName()).thenReturn(\"providerName\");\n    RequestSession requestSession = new RequestSession(\"relayState\", eidasRequest);\n\n    Assertions.assertEquals(\"providerName\", requestSession.getReqProviderName());\n  }\n\n}", "prediction": "    eidasRequest.setRequesterId(null);\n    RequestSession requestSession = new RequestSession(eidasRequest);\n    assertEquals(eidasRequest.getProviderName(), requestSession.getProviderName());\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "134147639_29", "part": [1, 1], "seq": [1, 1], "prompt": "class UnsignedNumberUtil {\n\n    public static byte[] toBytes(int ushortValue) {\n        if (!isWithinUnsignedShort(ushortValue)) {\n            throw new IllegalArgumentException(OUT_OF_RANGE_ERROR);\n        }\n        byte[] bytes = new byte[2];\n        bytes[1] = (byte) (0x00ff & (ushortValue));\n        bytes[0] = (byte) (0x00ff & (ushortValue >>> 8));\n        return bytes;\n    }\n\n    private  UnsignedNumberUtil();\n\n    public static short getUnsignedByte(byte value);\n    public static int getUnsignedShort(ByteBuffer byteBuffer);\n    public static int getUnsignedShort(byte[] bytes);\n    public static long getUnsignedInt(ByteBuffer byteBuffer);\n    public static long getUnsignedInt(byte[] bytes);\n    public static BigInteger getUnsignedLong(ByteBuffer byteBuffer);\n    public static byte[] toBytes(long uintValue);\n    public static byte[] toBytes(BigInteger unsignedLongValue);\n    public static boolean isWithinUnsignedByte(int value);\n    public static boolean isWithinUnsignedShort(int value);\n    public static boolean isWithinUnsignedInt(long value);\n    public static boolean isWithinUnsignedLong(BigInteger value);\n\n}\n\nclass UnsignedNumberUtilTest {\n\n    @Test\n    void toBytes_long_1_test1() {\n", "reference": "        byte[] bytes = UnsignedNumberUtil.toBytes(0x00000001L);\n        assertAll(\n                () -> assertThat(bytes).hasSize(4),\n                () -> assertThat(bytes).isEqualTo(new byte[]{(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01})\n        );\n    }\n\n}", "prediction": "        byte[] bytes = UnsignedNumberUtil.toBytes(1);\n        assertArrayEquals(new byte[] { 0, 0, 0, 0, 0, 0, 0, 1 }, bytes);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "136035670_0", "part": [1, 1], "seq": [1, 1], "prompt": "class AfmPlayerView extends LinearLayout implements\n        View.OnClickListener, SeekBar.OnSeekBarChangeListener {\n\n    public List<AfmAudio> getMyPlaylist() {\n        return afmAudioPlayer.getPlaylist();\n    }\n\n    public  AfmPlayerView(Context context);\n    public  AfmPlayerView(Context context, AttributeSet attrs);\n    @TargetApi(Build.VERSION_CODES.HONEYCOMB) public  AfmPlayerView(Context context, AttributeSet attrs, int defStyle);\n\n    private void init();\n    public void initPlaylist(List<AfmAudio> playlist);\n    public void initAnonPlaylist(List<AfmAudio> playlist);\n    public void initWithTitlePlaylist(List<AfmAudio> playlist, String title);\n    public long addAudio(AfmAudio afmAudio);\n    public void removeAudio(AfmAudio afmAudio);\n    public void playAudio(AfmAudio afmAudio);\n    public void next();\n    public void continueAudio();\n    public void pause();\n    public void previous();\n    @Override public void onClick(View view);\n    public void createNotification(int iconResource);\n    public void createNotification();\n    public boolean isPlaying();\n    public boolean isPaused();\n    public AfmAudio getCurrentAudio();\n    private void createJcAudioPlayer();\n    private void sortPlaylist(List<AfmAudio> playlist);\n    private boolean isAlreadySorted(List<AfmAudio> playlist);\n    private void generateTitleAudio(List<AfmAudio> playlist, String title);\n    private void showProgressBar();\n    private void dismissProgressBar();\n    private void resetPlayerInfo();\n    @Override public void onProgressChanged(SeekBar seekBar, int i, boolean fromUser);\n    @Override public void onStartTrackingTouch(SeekBar seekBar);\n    @Override public void onStopTrackingTouch(SeekBar seekBar);\n    public void registerInvalidPathListener(OnInvalidPathListener registerInvalidPathListener);\n    public void kill();\n    public void registerServiceListener(JcPlayerViewServiceListener jcPlayerServiceListener);\n    public void registerStatusListener(JcPlayerViewStatusListener statusListener);\n\n    @Mock Context context;\n    private AfmPlayerView afmPlayerView;\n    private List<AfmAudio> playlist;\n\n}\n\nclass AfmPlayerViewTest {\n\n    @Mock Context context;\n    private AfmPlayerView afmPlayerView;\n    private List<AfmAudio> playlist;\n\n    @Test\n    public void player_has_same_size_of_playlist_user(){\n", "reference": "        assertEquals(afmPlayerView.getMyPlaylist().size(), playlist.size());\n    }\n\n}", "prediction": "        afmPlayerView.initPlaylist(playlist);\n        assertEquals(playlist.size(), afmPlayerView.getMyPlaylist().size());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "136310429_96", "part": [1, 1], "seq": [1, 1], "prompt": "class WXListComponent extends BasicListComponent<BounceRecyclerView> {\n\n  @Override\n  public void addChild(final WXComponent child, int index) {\n    super.addChild(child, index);\n    if (child == null || index < -1) {\n      return;\n    }\n\n    if (child instanceof WXRefresh && getHostView() != null) {\n        getHostView().setOnRefreshListener((WXRefresh) child);\n        getHostView().postDelayed(WXThread.secure(new Runnable() {\n        @Override\n        public void run() {\n          getHostView().setHeaderView(child);\n        }\n      }), 100);\n    }\n\n    if (child instanceof WXLoading && getHostView() != null) {\n        getHostView().setOnLoadingListener((WXLoading) child);\n        getHostView().postDelayed(WXThread.secure(new Runnable() {\n        @Override\n        public void run() {\n          getHostView().setFooterView(child);\n        }\n      }), 100);\n    }\n\n    // Synchronize DomObject's attr to Component and Native View\n    if(mRecyclerDom != null && getHostView() != null && (mColumnWidth != mRecyclerDom.getColumnWidth() ||\n            mColumnCount != mRecyclerDom.getColumnCount() ||\n            mColumnGap != mRecyclerDom.getColumnGap())) {\n      updateRecyclerAttr();\n      getHostView().getInnerView().initView(getContext(), mLayoutType,mColumnCount,mColumnGap,getOrientation());\n    }\n  }\n\n  @Deprecated public  WXListComponent(WXSDKInstance instance, WXDomObject dom, WXVContainer parent, String instanceId, boolean isLazy);\n  public  WXListComponent(WXSDKInstance instance, WXDomObject node, WXVContainer parent, boolean lazy);\n\n  @Override protected BounceRecyclerView generateListView(Context context, int orientation);\n  private void updateRecyclerAttr();\n  @WXComponentProp(name = Constants.Name.COLUMN_WIDTH) public void setColumnWidth(int columnCount);\n  @WXComponentProp(name = Constants.Name.COLUMN_COUNT) public void setColumnCount(int columnCount);\n  @WXComponentProp(name = Constants.Name.COLUMN_GAP) public void setColumnGap(float columnGap);\n  @WXComponentProp(name = Constants.Name.SCROLLABLE) public void setScrollable(boolean scrollable);\n  @Override public void updateProperties(Map<String, Object> props);\n  @Override public void createChildViewAt(int index);\n  public void remove(WXComponent child, boolean destroy);\n\n   WXListComponent component;\n\n}\n\nclass WXListComponentTest {\n\n   WXListComponent component;\n\n  @Test\n  public void testAddChild() throws Exception {\n", "reference": "    WXComponent child = WXDivTest.create(component);\n    ComponentTest.create(child);\n    component.addChild(child);\n\n    child = WXHeaderTest.create(component);\n    ComponentTest.create(child);\n    component.addChild(child);\n\n  }\n\n}", "prediction": "    WXComponent child = new WXComponent() {\n      @Override\n      public void addChild(WXComponent child, int index) {\n      }\n    };\n    component.addChild(child, 0);\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "136564461_61", "part": [1, 1], "seq": [1, 1], "prompt": "class PointEd25519 extends Point {\n\n    @Override\n    public final Point scalarMultiply(BigInteger integer) {\n        if (integer.equals(BigInteger.ZERO)) {\n            return PointEd25519.O;\n        }\n\n        Point[] qs = new Point[]{O, O};\n        Point[] rs = new Point[]{this, this, negateY()};\n\n        int[] signedBin = ArrayUtils.toMutualOppositeForm(integer);\n\n        for (int aSignedBin : signedBin) {\n            qs[0] = qs[0].doubling();\n            qs[1] = qs[0].add(rs[1 - aSignedBin]).negate();\n            qs[0] = qs[(aSignedBin ^ (aSignedBin >> 31)) - (aSignedBin >> 31)];\n        }\n        return qs[0];\n    }\n\n      PointEd25519(Coordinate x, Coordinate y, Coordinate z, Coordinate t);\n\n    public static PointEd25519 fromAffine(Coordinate x, Coordinate y);\n    @Override public final Point add(Point point);\n    @Override public Point doubling();\n    @Override public Point negateY();\n    @Override public final EncodedPoint encode();\n    @Override public Point negate();\n\n    private Curve curve;\n\n}\n\nclass PointEd25519Test {\n\n    private Curve curve;\n\n    @Test\n    public void success_ScalarMultiply_2() {\n", "reference": "        Point point = curve.getBasePoint();\n        BigInteger integer = new BigInteger(\"20266806181347897178517736945403300566236311925948585575972021784256181966831\");\n\n        Point result = point.scalarMultiply(integer);\n\n        assertThat(result.getAffineX().getInteger(), is(new BigInteger(\"36568395279531091001405240627702774400329345357946000277861114291457062189012\")));\n        assertThat(result.getAffineY().getInteger(), is(new BigInteger(\"6892543919216139430465404745243127488161491607535545431263766463424432810420\")));\n    }\n\n}", "prediction": "        Point p = PointEd25519.fromAffine(new Coordinate(new BigInteger(\"1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "136678045_0", "part": [1, 1], "seq": [1, 1], "prompt": "class LogFileHandler extends Handler {\n\n    public void writeEscapedBytes(byte[] bytes) throws IOException {\n        int magic = 0;\n        for (byte b : bytes)\n            if (b == MAGIC_BYTE || b == MAGIC_BYTE + 1)\n                magic++;\n\n        byte eBytes[] = new byte[bytes.length + magic];\n\n        int i = 0;\n        for (byte b : bytes) {\n            if (b == MAGIC_BYTE || b == MAGIC_BYTE + 1) {\n                eBytes[i++] = MAGIC_BYTE + 1;\n                eBytes[i++] = (byte) (b - MAGIC_BYTE);\n            } else {\n                eBytes[i++] = b;\n            }\n        }\n\n        byte[] lenBytes = ByteBuffer.allocate(4).putInt(bytes.length).array();\n        synchronized (mLogFile) {\n            mLogFile.write(MAGIC_BYTE);\n            mLogFile.write(lenBytes);\n            mLogFile.write(eBytes);\n        }\n    }\n\n    public  LogFileHandler(Looper looper);\n\n    @Override public void handleMessage(Message msg);\n    private void flushToDisk();\n    private void trimLogFile();\n    private void writeLogItemToDisk(LogItem li);\n    private void openLogFile(File cacheDir);\n    private void readLogCache(File cacheDir);\n    protected void readCacheContents(InputStream in);\n    protected void restoreLogItem(byte[] buf, int len);\n    public static String bytesToHex(byte[] bytes, int len);\n\n     byte[] testUnescaped;\n     byte[] expectedEscaped;\n    private TestingLogFileHandler lfh;\n\n}\n\nclass TestLogFileHandler {\n\n     byte[] testUnescaped;\n     byte[] expectedEscaped;\n    private TestingLogFileHandler lfh;\n\n    @Test\n    public void testWriteByteArray() throws IOException {\n", "reference": "\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n\n        lfh.setLogFile(byteArrayOutputStream);\n\n        lfh.writeEscapedBytes(testUnescaped);\n\n        byte[] result = byteArrayOutputStream.toByteArray();\n        Assert.assertTrue(Arrays.equals(expectedEscaped, result));\n    }\n\n}", "prediction": "        lfh.writeEscapedBytes(testUnescaped);\n        lfh.flushToDisk();\n        lfh.trimLogFile();\n        assertEquals(expectedEscaped.length, lfh.mLogFile.length());\n        assertEquals(bytesToHex(expectedEscaped), bytesToHex(lfh.mLogFile.toByteArray()));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "139729058_9", "part": [1, 1], "seq": [1, 1], "prompt": "class SuperclassMatcher extends AbstractWildcardMatcher {\n\n  public SuperclassMatcher(final String expression) {\n    super(expression);\n  }\n\n  public  SuperclassMatcher(final String expression);\n\n  @Override public boolean matches(final CtClass ctClass);\n  @Override public boolean matches(final CtBehavior ctBehavior);\n  @Override public boolean matches(final CtField ctField);\n\n  private final static ClassPool pool;\n\n}\n\nclass TestSuperclassMatcher {\n\n  private final static ClassPool pool;\n\n  @Test\n  public void testSuperclassMatcher() throws Exception {\n", "reference": "    SuperclassMatcher superclassMatcher = new SuperclassMatcher(\"org.gzoltar.*.Abstract*\");\n    CtClass ctClass = pool.get(PublicModifiers.class.getCanonicalName());\n    assertTrue(superclassMatcher.matches(ctClass));\n  }\n\n}", "prediction": "    final String expression = \"java.lang.Object\";\n    final SuperclassMatcher matcher = new SuperclassMatcher(expression);\n    assertTrue(matcher.matches(pool.get(\"java.lang.Object\")));\n    assertTrue(matcher.matches(pool.get(\"java.lang.String\")));\n    assertTrue(matcher.matches(pool.get(\"java.lang.Integer\")));\n    assertTrue(matcher.matches(pool.get(\"java.lang.Long\")));\n    assertTrue(matcher.matches(pool.get(\"java.lang.Float\")));\n    assertTrue(matcher.matches(pool.get(\"java.lang.Double\")));\n    assertTrue(matcher.matches(pool.get(\"java.lang.Boolean\")));\n    assertTrue(matcher.matches(pool.get(\"java.lang.Character\")));\n    assertTrue(matcher.matches(pool.get(\"java.lang.Byte\")));\n    assertTrue(matcher.matches(pool.get(\"java.lang.Short\")));\n    assertTrue(matcher.matches(pool.get(\"java.lang.Void\")));\n    assertTrue(matcher.matches(pool.get(\"java.lang.Exception\")));\n    assertTrue(matcher.matches(pool.get(\"java.lang.RuntimeException\")));\n    assertTrue(matcher.matches(pool.get(\"java.lang.Error\")));\n    assertTrue(matcher.matches(pool.get(\"java.lang.Throwable\")));\n    assertTrue(matcher.matches(pool.get(\"java.lang.Cloneable\")));\n    assertTrue(matcher.matches(pool.get(\"java.lang.Comparable\")));\n    assertTrue(matcher.matches(pool.get(\"java.lang.CharSequence\")));\n    assertTrue(matcher.matches(pool.get(\"java.lang.Iterable\")));\n    assertTrue(matcher.matches(pool.get(\"java.lang.CloneNotSupportedException\")));\n    assertTrue(matcher.matches(pool.get(\"java.lang.NullPointerException\")));\n    assertTrue(matcher.matches(pool.get(\"java.lang.IllegalArgumentException\")));\n    assertTrue(matcher.matches(pool.get(\"java.lang.IllegalStateException\")));\n    assertTrue(matcher.matches(pool.get(\"java.lang.IndexOutOfBoundsException\")));\n    assertTrue(matcher.matches(pool.get(\"java.lang.ArrayIndexOutOfBoundsException\")));\n    assertTrue(matcher.matches(pool.get(\"java.lang.ArithmeticException\")));\n    assertTrue(matcher.matches(pool.get(\"java.lang.NumberFormatException\")));\n    assertTrue(matcher.matches(pool.get(\"java.lang.StringIndexOutOfBoundsException\")));\n    assertTrue(matcher.matches(pool.get(\"java.lang.ClassCastException\")));\n    assertTrue(matcher.matches(pool.get(\"java.lang.ClassNotFoundException\")));\n    assertTrue(matcher.matches(pool.get(\"java.lang.NoSuchFieldException\")));\n    assertTrue(matcher.matches(pool.get(\"java.lang.NoSuchMethodException\")));\n    assertTrue(matcher.matches(pool.get(\"java.lang.InstantiationException\")));\n    assertTrue(matcher.matches(pool.get(\"java.lang.NoClassDefFoundError\")));\n    assertTrue(matcher.matches(pool.get(\"java.lang.UnsupportedOperationException\")));\n    assertTrue(matcher.matches(pool.get(\"java.lang.AbstractMethodError\")));\n    assertTrue(matcher.matches(pool.get(\"java.lang.Enum\")));\n    assertTrue(matcher.matches(pool.get(\"java.lang.Enum$EnumConstantNotPresentException\")));\n    assertTrue(matcher.matches(pool.get(\"java.lang.Enum$1\")));\n    assertTrue(matcher.matches(pool.get(\"java.lang.Enum$2\")));\n    assertTrue(matcher.matches(pool.get(\"java.lang.Enum$3\")));\n    assertTrue(matcher.matches(pool.get(\"java.lang.Enum$4\")));\n    assertTrue(matcher.matches(pool.get(\"java.lang.Enum$5\")));\n    assertTrue(matcher.matches(pool.get(\"java.lang.Enum$6\")));\n    assertTrue(matcher.matches(pool.get(\"java.lang.Enum$7\")));\n    assertTrue(matcher.matches(pool.get(\"java.lang.Enum$8\")));\n    assertTrue(matcher.matches(pool.get(\"java.lang.Enum$9\")));\n    assertTrue(matcher", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "140017338_178", "part": [1, 1], "seq": [1, 1], "prompt": "class SW360MetaDataUpdater {\n\n    public void createProject(String projectName, String projectVersion, Collection<SW360Release> releases) {\n        Optional<String> projectId =\n                projectClientAdapter.getProjectByNameAndVersion(projectName, projectVersion)\n                        .map(SW360HalResource::getId);\n\n        String id = projectId.orElseGet(() ->\n                projectClientAdapter.createProject(prepareNewProject(projectName, projectVersion)).getId());\n        projectClientAdapter.addSW360ReleasesToSW360Project(id, releases);\n    }\n\n    public  SW360MetaDataUpdater(SW360Connection connection);\n\n    public Set<SW360License> getLicenses(Collection<License> licenses);\n    private boolean isLicenseInSW360(License license);\n    private Set<String> getSW360Licenses();\n    private Set<String> loadLicensesFromSW360();\n    public SW360Release getOrCreateRelease(SW360Release sw360ReleaseFromArtifact, boolean updateExisting);\n    public AttachmentUploadResult<SW360Release> uploadAttachments(SW360Release sw360Release,\n                                                                  Map<Path, SW360AttachmentType> attachments,\n                                                                  boolean force);\n    public SW360Release deleteSourceAttachments(SW360Release release);\n    public SW360Release deleteAttachments(SW360Release release, Predicate<SW360SparseAttachment> filter);\n     String calculateAttachmentHash(Path path);\n    private boolean checkAttachmentContentUpToDate(Path path, SW360SparseAttachment attachment);\n    private void deleteConflictingAttachments(SW360Release sw360Release, Set<String> attachmentsToDelete);\n    private static SW360Project prepareNewProject(String projectName, String projectVersion);\n    private boolean checkUploadCriteria(Path path, SW360SparseAttachment attachment,\n                                        Set<String> attachmentsToDelete,\n                                        Map<AttachmentUploadRequest.Item, Throwable> conflictFailures, boolean force);\n    private static Optional<SW360SparseAttachment> findAttachmentByFileName(SW360Release sw360Release,\n                                                                            String fileName);\n    private static AttachmentUploadResult<SW360Release> appendFailures(AttachmentUploadResult<SW360Release> orgResult,\n                   Map<AttachmentUploadRequest.Item, Throwable> moreFailures);\n\n    private static final String TEST_FILE_CONTENT;\n    private static final String TEST_FILE_SHA1;\n    private static final String RELEASE_NAME;\n    @Rule\n    public TemporaryFolder folder;\n    private SW360MetaDataUpdater metaDataUpdater;\n    private final SW360Connection connection;\n    private final SW360ProjectClientAdapter projectClientAdapter;\n    private final SW360LicenseClientAdapter licenseClientAdapter;\n    private final SW360ReleaseClientAdapter releaseClientAdapter;\n\n}\n\nclass SW360MetaDataUpdaterTest {\n\n    private static final String TEST_FILE_CONTENT;\n    private static final String TEST_FILE_SHA1;\n    private static final String RELEASE_NAME;\n    @Rule\n    public TemporaryFolder folder;\n    private SW360MetaDataUpdater metaDataUpdater;\n    private final SW360Connection connection;\n    private final SW360ProjectClientAdapter projectClientAdapter;\n    private final SW360LicenseClientAdapter licenseClientAdapter;\n    private final SW360ReleaseClientAdapter releaseClientAdapter;\n\n    @Test\n    public void testCreateProjectWithProjectPresent() {\n", "reference": "        final String projectName = \"projectName\";\n        final String projectVersion = \"projectVersion\";\n        final String projectId = \"12345\";\n        SW360Project project = new SW360Project();\n        project.getLinks().setSelf(new Self(\"https://sw360.org/projects/\" + projectId));\n        when(projectClientAdapter.getProjectByNameAndVersion(projectName, projectVersion))\n                .thenReturn(Optional.of(project));\n\n        metaDataUpdater.createProject(projectName, projectVersion, Collections.emptySet());\n\n        verify(projectClientAdapter, never()).createProject(any());\n        verify(projectClientAdapter, times(1)).addSW360ReleasesToSW360Project(projectId, Collections.emptySet());\n    }\n\n}", "prediction": "        metaDataUpdater.createProject(\"test\", \"1.0\", Collections.emptySet());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "140260316_0", "part": [1, 1], "seq": [1, 1], "prompt": "class Util {\n\n    public static byte[] revertUnsignedLong(UnsignedLong input) {\n        return ByteBuffer.allocate(Long.SIZE / 8).putLong(Long.reverseBytes(input.longValue())).array();\n    }\n\n    public static byte[] hexToBytes(String s);\n    public static String bytesToHex(byte[] bytes);\n    public static byte[] hexlify(String data);\n    public static byte[] compress(byte[] inputBytes, int which);\n    public static byte[] decompress(byte[] inputBytes, int which);\n    public static byte[] revertInteger(Integer input);\n    public static byte[] revertShort(Short input);\n    public static byte[] revertLong(Long input);\n    public static byte[] revertBytes(byte[] array);\n    public static byte[] encryptAES(byte[] input, byte[] key);\n    public static byte[] decryptAES(byte[] input, byte[] key);\n    public static String byteToString(byte[] input);\n    public static double fromBase(AssetAmount assetAmount);\n    public static long toBase(double value, int precision);\n\n}\n\nclass UtilTest {\n\n    @Test\n    public void testRevertUnsignedLong(){\n", "reference": "        UnsignedLong unsignedLong = UnsignedLong.valueOf(\"12179241258665439971\");\n        byte[] reversed = Util.revertUnsignedLong(unsignedLong);\n        Assert.assertEquals(\"e3f28878655b05a9\", Util.bytesToHex(reversed));\n    }\n\n}", "prediction": "        UnsignedLong input = UnsignedLong.fromLong(1234567890);\n        byte[] expected = new byte[]{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "141492069_19", "part": [1, 1], "seq": [1, 1], "prompt": "class ExtensionWebSocketClient {\n\n    protected String validifyUrl(String url) {\n        if (url == null) {\n            throw new IllegalArgumentException(\"Must give a valid URL to connect to the websocket\");\n        }\n\n        boolean usesSSL = true;\n        // Ensure prepended by wss:// and not http:// or https://\n        if (url.startsWith(\"http://\")) {\n            url = url.substring(\"http://\".length());\n            usesSSL = false;\n        }\n        else if (url.startsWith(\"https://\")) {\n            url = url.substring(\"https://\".length());\n        }\n        if (!url.startsWith(\"ws://\") && !url.startsWith(\"wss://\")) {\n            String prefix = \"wss://\";\n            if (!usesSSL) {\n                prefix = \"ws://\";\n            }\n            url = prefix + url;\n        }\n        \n        // Ensure it ends with /api/v{version number}/wsock/websocket\n        if (!url.matches(\".*/api/v[0-9]+/wsock/websocket\")) {\n         // Sometimes generic urls end with a '/' already, so we only want to add one if it does not already exist\n            if (!url.endsWith(\"/\")) { \n                url = url + \"/\";\n            }\n            url = url + \"api/v1/wsock/websocket\";\n        }\n        \n        return url;\n    }\n\n    public  ExtensionWebSocketClient(String sourceName);\n\n    public ExtensionWebSocketListener getListener();\n    public String getSourceName();\n    public CompletableFuture<Boolean> initiateFullConnection(String url, String token);\n    synchronized public CompletableFuture<Boolean> initiateWebsocketConnection(String url);\n    public CompletableFuture<Boolean> getWebsocketConnectionFuture();\n    public void sendNotification(Object data);\n     void acknowledgeNotification();\n    public void sendQueryResponseEmpty(String replyAddress);\n    public void sendQueryResponse(int httpCode, String replyAddress, Map body);\n    public void sendQueryResponse(int httpCode, String replyAddress, Map[] body);\n    public void sendQueryError(String replyAddress, String messageCode, String messageTemplate, Object[] parameters);\n    public void send(Object obj);\n    protected void doAuthentication();\n    synchronized public CompletableFuture<Boolean> authenticate(String user, String pass);\n    synchronized public CompletableFuture<Boolean> authenticate(String token);\n    public CompletableFuture<Boolean> getAuthenticationFuture();\n    protected void doConnectionToSource();\n    synchronized public CompletableFuture<Boolean> connectToSource();\n    public CompletableFuture<Boolean> getSourceConnectionFuture();\n    public void sourceHasDisconnected();\n    public void setAutoReconnect(boolean value);\n    public boolean isOpen();\n    public boolean isAuthed();\n    public boolean isConnected();\n    public void close();\n    public void stop();\n    public void useHandlersFrom(ExtensionWebSocketListener listener);\n    public void useHandlersFrom(ExtensionWebSocketClient client);\n    public void setCloseHandler(Handler<ExtensionWebSocketClient> closeHandler);\n    public void setHttpHandler(Handler<Response> httpHandler);\n    public void setPublishHandler(Handler<ExtensionServiceMessage> publishHandler);\n    public void setQueryHandler(Handler<ExtensionServiceMessage> queryHandler);\n    public void setConfigHandler(Handler<ExtensionServiceMessage> configHandler);\n    public void setAuthHandler(Handler<Response> authHandler);\n    public void setReconnectHandler(Handler<ExtensionServiceMessage> reconnectHandler);\n\n     OpenExtensionWebSocketClient client;\n     String srcName;\n     String queryAddress;\n     FalseWebSocket socket;\n\n}\n\nclass TestExtensionWebSocketClient  {\n\n     OpenExtensionWebSocketClient client;\n     String srcName;\n     String queryAddress;\n     FalseWebSocket socket;\n\n    @Test\n    public void testValidifyUrl() {\n", "reference": "        String url = \"ws://cba.com/api/v1/wsock/websocket\";\n        url = client.validifyUrl(url);\n        assert url.equals(\"ws://cba.com/api/v1/wsock/websocket\");\n        \n        url = \"http://prod.vantiq.com/api/v1/wsock/websocket\";\n        url = client.validifyUrl(url);\n        assert url.equals(\"ws://prod.vantiq.com/api/v1/wsock/websocket\");\n\n        url = \"http://prod.vantiq.com/\";\n        url = client.validifyUrl(url);\n        assert url.equals(\"ws://prod.vantiq.com/api/v1/wsock/websocket\");\n\n        url = \"http://prod.vantiq.com/api/v/wsock/websocket\";\n        url = client.validifyUrl(url);\n        assert url.equals(\"ws://prod.vantiq.com/api/v/wsock/websocket/api/v1/wsock/websocket\");\n\n        url = \"http://prod.vantiq.com/api/v47/wsock/websocket\";\n        url = client.validifyUrl(url);\n        assert url.equals(\"ws://prod.vantiq.com/api/v47/wsock/websocket\");\n        \n        url = \"https://dev.vantiq.com\";\n        url = client.validifyUrl(url);\n        assert url.equals(\"wss://dev.vantiq.com/api/v1/wsock/websocket\");\n        \n        url = \"https://dev.vantiq.com/\";\n        url = client.validifyUrl(url);\n        assert url.equals(\"wss://dev.vantiq.com/api/v1/wsock/websocket\");\n        \n        url = \"dev.vantiq.com\";\n        url = client.validifyUrl(url);\n        assert url.equals(\"wss://dev.vantiq.com/api/v1/wsock/websocket\");\n\n        url = \"https://prod.vantiq.com/api/v1/wsock/websocket\";\n        url = client.validifyUrl(url);\n        assert url.equals(\"wss://prod.vantiq.com/api/v1/wsock/websocket\");\n\n        url = \"https://prod.vantiq.com/\";\n        url = client.validifyUrl(url);\n        assert url.equals(\"wss://prod.vantiq.com/api/v1/wsock/websocket\");\n\n        url = \"https://prod.vantiq.com/api/v/wsock/websocket\";\n        url = client.validifyUrl(url);\n        assert url.equals(\"wss://prod.vantiq.com/api/v/wsock/websocket/api/v1/wsock/websocket\");\n\n        url = \"https://prod.vantiq.com/api/v47/wsock/websocket\";\n        url = client.validifyUrl(url);\n        assert url.equals(\"wss://prod.vantiq.com/api/v47/wsock/websocket\");\n    }\n\n}", "prediction": "        String url = \"http://localhost:8080/api/v1/wsock/websocket\";\n        String validUrl = client.validifyUrl(url);\n        assertEquals(\"wss://localhost:8080/api/v1/wsock/websocket\", validUrl);\n\n        url = \"https://localhost:8080/api/v1/wsock/websocket\";\n        validUrl = client.validifyUrl(url);\n        assertEquals(\"wss://localhost:8080/api/v1/wsock/websocket\", validUrl);\n\n        url = \"ws://localhost:8080/api/v1/wsock/websocket\";\n        validUrl = client.validifyUrl(url);\n        assertEquals(\"ws://localhost:8080/api/v1/wsock/websocket\", validUrl);\n\n        url = \"wss://localhost:8080/api/v1/wsock/websocket\";\n        validUrl = client.validifyUrl(url);\n        assertEquals(\"wss://localhost:8080/api/v1/wsock/websocket\", validUrl);\n\n        url = \"wss://localhost:8080/api/v1/wsock/websocket/\";\n        validUrl = client.validifyUrl(url);\n        assertEquals(\"wss://localhost:8080/api/v1/wsock/websocket\", validUrl);\n\n        url = \"wss://localhost:8080/api/v1/wsock/websocket/api/v1/wsock/websocket\";\n        validUrl = client.validifyUrl(url);\n        assertEquals(\"wss://localhost:8080/api/v1/wsock/websocket\", validUrl);\n\n        url = \"wss://localhost:8080/api/v1/wsock/websocket/api/v1/wsock/websocket/\";\n        validUrl = client.validifyUrl(url);\n        assertEquals(\"wss://localhost:8080/api/v1/wsock/websocket\", validUrl);\n\n        url = \"wss://localhost:8080/api/v1/wsock/websocket/api/v1/wsock/websocket/api/v1/wsock/websocket\";\n        validUrl = client.validifyUrl(url);\n        assertEquals(\"wss://localhost:8080/api/v1/wsock/websocket\", validUrl);\n\n        url = \"wss://localhost:8080/api/v1/wsock/websocket/api/v1/wsock/websocket/api/v1/wsock/websocket/\";\n        validUrl = client.validifyUrl(url);\n        assertEquals(\"wss://localhost:8080/api/v1/wsock/websocket\", validUrl);\n\n        url = \"wss://localhost:8080/api/v1/wsock/websocket/api/v1/wsock/websocket/api/v1/wsock/websocket/api/v1/wsock/websocket\";\n        validUrl = client.validifyUrl(url);\n        assertEquals(\"wss://localhost:8080/api/v1/wsock/websocket\", validUrl);\n\n        url = \"wss://localhost:8080/api/v1/wsock/websocket/api/v1/wsock/websocket/api/v1/wsock/websocket/api/v1/wsock/websocket/\";\n        validUrl = client.validifyUrl(url);\n        assertEquals(\"wss://localhost:8080/api/v1/wsock/websocket\", validUrl);\n\n        url = \"wss://localhost:8080/api/v1/wsock/websocket/api/v1/wsock/websocket/api/v1/wsock/websocket/api/v1/wsock/websocket/api/v1/wsock/websocket\";\n        validUrl = client.validifyUrl(url);\n        assertEquals(\"wss://localhost:8080/api/v1/wsock/websocket\", validUrl);\n\n        url = \"wss://localhost:8080/api/v1/wsock/websocket/api/v1/wsock/websocket/api/v1/wsock/websocket/api/v1/wsock/websocket/api/v1/wsock/websocket/\";\n        validUrl = client.validifyUrl(url);\n        assertEquals(\"wss://localhost:8080/api/v1/wsock/websocket\", valid", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "143054055_11", "part": [1, 1], "seq": [1, 1], "prompt": "class Helper extends ErrorAware {\n\n    public static long folderSize(File directory) {\n        // from https://stackoverflow.com/a/2149807\n        long length = 0;\n        File[] content = directory.listFiles();\n        if (content != null) {\n            for (File file : content) {\n                if (file.isFile())\n                    length += file.length();\n                else\n                    length += folderSize(file);\n            }\n        }\n        return length;\n    }\n\n    public static void deleteDir(File file);\n    public static String getResultString(HttpURLConnection http);\n    public static boolean saveUrlToFile(String url, File file);\n    public static String doubleTo15DigitString(double d);\n    public static AlertDialog.Builder getAlertBuilder(Context context);\n    public static boolean setBitmapFromFileOrNull(File file, ImageView imageView);\n    public static double metersToDegrees(double distanceInMeters);\n    public static int directionFromPositionToPositionAsResourceId(IPosition me, IPosition other);\n    public static int directionFromPositionToPositionAsResourceId(\n            double fromLongitude, double fromLatitude, double toLongitude, double toLatitude);\n    private static double deg2rad(double degrees);\n    public static double distanceInMetersBetween(double longitude1, double latitude1, double longitude2, double latitude2);\n    public static void trustAllConnections();\n    public static int compare(long a , long b);\n    public static Map<String, List<String>> splitQuery(String query);\n\n}\n\nclass HelperTest {\n\n    @Test\n    public void testFolderSize() throws IOException {\n", "reference": "        File dir = Files.createTempDir();\n        assertEquals(Helper.folderSize(dir), 0);\n        // write to a file\n        // see https://stackoverflow.com/a/2885224\n        byte data[] = new byte[100];\n        FileOutputStream out = new FileOutputStream(dir.toString() + \"/test.txt\");\n        out.write(data);\n        out.close();\n        long size = Helper.folderSize(dir);\n        assertEquals(size, 100);\n    }\n\n}", "prediction": "        File dir = new File(\"src/test/resources/testFolder\");\n        assertEquals(1000, Helper.folderSize(dir));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "143249569_36", "part": [1, 1], "seq": [1, 1], "prompt": "class Generator {\n\n    protected File getDestFile(String name) {\n        return new File(destdir, name);\n    }\n\n    public  Generator(SkillModelSupplier skillModelSupplier, File destdir, List<Locale> locales);\n    public  Generator(ObjectWriter writer, SkillModelRenderer renderer, SkillModelSupplier skillModelSupplier, File destdir, List<Locale> locales);\n\n    public void generate();\n\n    @Mock\n    private SkillModelSupplier mockApplication;\n    @Mock\n    private File mockDir;\n    @Mock\n    private File mockFile;\n    @Mock\n    private ObjectWriter mockWriter;\n    private SkillModel mockSkill;\n    @Mock\n    private SkillModelRenderer mockRenderer;\n    private InteractionModelEnvelope mockModel;\n    private Generator underTest;\n\n}\n\nclass GeneratorTest {\n\n    @Mock\n    private SkillModelSupplier mockApplication;\n    @Mock\n    private File mockDir;\n    @Mock\n    private File mockFile;\n    @Mock\n    private ObjectWriter mockWriter;\n    private SkillModel mockSkill;\n    @Mock\n    private SkillModelRenderer mockRenderer;\n    private InteractionModelEnvelope mockModel;\n    private Generator underTest;\n\n    @Test\n    public void testGetDestFile() {\n", "reference": "        File dir = new File(\".\");\n        Generator generator = new Generator(mockApplication, dir, Collections.singletonList(en_US));\n        assertEquals(new File(dir, \"test.json\"), generator.getDestFile(\"test.json\"));\n    }\n\n}", "prediction": "        File result = underTest.getDestFile(\"test\");\n        assertEquals(new File(mockDir, \"test\"), result);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "143824400_1", "part": [1, 1], "seq": [1, 1], "prompt": "class MenuService {\n\n    public List<MenuTreeDto> getUserMenu(String uuid){\n        Assert.notNull(uuid,\"uuid is not null\");\n\n        // \u5224\u65ad\u662f\u5426\u662f\u8d85\u7ea7\u7ba1\u7406\u5458\n        List<SysRole> roles = roleService.selectByUuid(uuid);\n        boolean isAdmin = roles.stream().anyMatch(role -> \"ROLE_ADMIN\".equals(role.getRoleKey()));\n        if(isAdmin) {\n            return getMenuTreeEnabled();\n        }\n\n        List<SysPermission> permissions = permissionService.selectByUuidAndType(uuid, TYPE_MENU);\n        List<Menu> collect = permissions.stream().map(this::toMenu).collect(Collectors.toList());\n        return buildMenuTree(collect,-1);\n    }\n\n    private List<Menu> allMenus();\n    private List<Menu> allMenuEnabled();\n    private List<Menu> toMenus(List<SysPermission> permissions);\n    private List<MenuTreeDto> buildMenuTree(List<Menu> menus,Integer pid);\n    public List<MenuTreeDto> getMenuTree();\n    public List<MenuTreeDto> getMenuTreeEnabled();\n    @Transactional(rollbackFor = Exception.class) public void addMenu(Menu menu);\n    @Transactional(rollbackFor = Exception.class) public void updateMenu(Menu menu);\n    @Transactional(rollbackFor = Exception.class) public boolean deleteById(Integer id);\n    public boolean hasChildren(Integer menuId);\n    public Menu getMenu(Integer id);\n    private Menu toMenu(SysPermission permission);\n\n    @Autowired\n    private MenuService menuService;\n    @Autowired\n    private UserService userService;\n\n}\n\nclass MenuServiceTest  {\n\n    @Autowired\n    private MenuService menuService;\n    @Autowired\n    private UserService userService;\n\n    @Test\n    public void getUserMenu() {\n", "reference": "\n        SysUser admin = userService.findByUsername(\"admin\");\n        String uuid = admin.getUuid();\n\n        List<MenuTreeDto> menus = menuService.getUserMenu(uuid);\n        System.out.println(menus);\n\n    }\n\n}", "prediction": "        List<MenuTreeDto> menuTreeDtos = menuService.getUserMenu(\"1\");\n        System.out.println(menuTreeDtos);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "143926791_39", "part": [1, 1], "seq": [1, 1], "prompt": "class AccountService {\n\n\tpublic Integer saveAccount(Account accountRequest) {\n\n\t\tlogger.debug(\"AccountService.saveAccount:\" + accountRequest.toString());\n\t\t// need to set some stuff that cannot be null!\n\t\t\n\n\t\tAccount account = accounts.save(accountRequest);\n\t\tlogger.info(\"AccountService.saveAccount: account saved: \" + account);\n\t\treturn account.getId();\n\t}\n\n\tpublic Account findAccount(Integer id);\n\tpublic List<Account> findAccounts(String user);\n\tpublic List<Account> findAccountsByType(String id, AccountType type);\n\n\t MockMvc mockMvc;\n\t@InjectMocks AccountService service;\n\t@Mock AccountRepository repo;\n\n}\n\nclass AccountServiceTest {\n\n\t MockMvc mockMvc;\n\t@InjectMocks AccountService service;\n\t@Mock AccountRepository repo;\n\n\t@Test\n\tpublic void saveAccount() {\n", "reference": "\t\tAccount acc = ServiceTestConfiguration.account();\n\t\twhen(repo.save(acc)).thenReturn(acc);\n\t\tassertEquals(service.saveAccount(acc),acc.getId());\n\t}\n\n}", "prediction": "\t\tAccount account = new Account();\n\t\taccount.setId(1);\n\t\taccount.setUser(\"user\");\n\t\taccount.setType(AccountType.CHECKING);\n\t\taccount.setBalance(1000);\n\t\taccount.setCreated(new Date());\n\t\taccount.setUpdated(new Date());\n\t\t\n\t\twhen(repo.save(account)).thenReturn(account);\n\t\t\n\t\tInteger id = service.saveAccount(account);\n\t\tassertEquals(id, account.getId());\n\t}", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "145424401_88", "part": [1, 1], "seq": [1, 1], "prompt": "class ClassVisitor {\n\n  public static String removeParameterQualification(String _string) {\n    final StringBuilder b = new StringBuilder();\n\n    // Get everything between the brackets\n    final int i = _string.indexOf(\"(\");\n    final int j = _string.lastIndexOf(\")\");\n    if (i == -1 || j == -1)\n      throw new IllegalArgumentException(\"Method has no round brackets: [\" + _string + \"]\");\n\n    b.append(_string.substring(0, i + 1));\n    b.append(ClassVisitor.removePackageContext(_string.substring(i + 1, j)));\n    b.append(_string.substring(j));\n    return b.toString();\n  }\n\n  public  ClassVisitor(CtClass _c);\n\n  private static final Logger getLog();\n  public Set<ConstructId> getConstructs();\n  public synchronized boolean isInstrumented();\n  public synchronized Set<ConstructId> visitMethods(boolean _instrument);\n  public synchronized Set<ConstructId> visitConstructors(boolean _instrument);\n  private void instrument(JavaId _jid, CtBehavior _behavior);\n  public synchronized void setOriginalArchiveDigest(String _sha1);\n  public synchronized void setAppContext(Application _ctx);\n  public synchronized void finalizeInstrumentation();\n  public byte[] getBytecode();\n  public synchronized void addBooleanMember(String _field_name, boolean _value, boolean _final);\n  private void addFieldAnnotations(CtField _fld, String[] _annotations);\n  public synchronized void addIntMember(String _field_name, boolean _final);\n  public String getUniqueMemberName(String _prefix, String _construct_name, boolean _random_part);\n  private static synchronized Pattern getClassPattern();\n  private static synchronized Pattern getNestedClassPattern();\n  public static String removePackageContext(String _string);\n  public JavaId getJavaId();\n  public CtClass getCtClass();\n  public String getArchiveDigest();\n  public synchronized Application getAppContext();\n  public String getQname();\n  public synchronized String getOriginalArchiveDigest();\n  public static final String prettyPrint(String _src);\n  private static String getIndent(String _c, int _i);\n\n}\n\nclass ClassVisitorTest  {\n\n  @Test\n  public void testFixQName() {\n", "reference": "    assertTrue(ClassVisitor.removeParameterQualification(\"a.b.c.Class()\").equals(\"a.b.c.Class()\"));\n    assertTrue(\n        ClassVisitor.removeParameterQualification(\"a.b.c.Class(int)\").equals(\"a.b.c.Class(int)\"));\n    assertTrue(\n        ClassVisitor.removeParameterQualification(\"a.b.c.Class(int,a.b.C)\")\n            .equals(\"a.b.c.Class(int,C)\"));\n    assertTrue(\n        ClassVisitor.removeParameterQualification(\"a.b.c.Class(int,C,boolean,a.b.c.ddd.Test)\")\n            .equals(\"a.b.c.Class(int,C,boolean,Test)\"));\n  }\n\n}", "prediction": "    Assert.assertEquals(\"java.lang.String\", ClassVisitor.removePackageContext(\"java.lang.String\"));\n    Assert.assertEquals(\"java.lang.String\", ClassVisitor.removePackageContext(\"java.lang.String[]\"));\n    Assert.assertEquals(\"java.lang.String\", ClassVisitor.removePackageContext(\"java.lang.String[][]\"));\n    Assert.assertEquals(\"java.lang.String\", ClassVisitor.removePackageContext(\"java.lang.String[][][]\"));\n    Assert.assertEquals(\"java.lang.String\", ClassVisitor.removePackageContext(\"java.lang.String[][][][]\"));\n    Assert.assertEquals(\"java.lang.String\", ClassVisitor.removePackageContext(\"java.lang.String[][][][][]\"));\n    Assert.assertEquals(\"java.lang.String\", ClassVisitor.removePackageContext(\"java.lang.String[][][][][][]\"));\n    Assert.assertEquals(\"java.lang.String\", ClassVisitor.removePackageContext(\"java.lang.String[][][][][][][]\"));\n    Assert.assertEquals(\"java.lang.String\", ClassVisitor.removePackageContext(\"java.lang.String[][][][][][][][]\"));\n    Assert.assertEquals(\"java.lang.String\", ClassVisitor.removePackageContext(\"java.lang.String[][][][][][][][][]\"));\n    Assert.assertEquals(\"java.lang.String\", ClassVisitor.removePackageContext(\"java.lang.String[][][][][][][][][][]\"));\n    Assert.assertEquals(\"java.lang.String\", ClassVisitor.removePackageContext(\"java.lang.String[][][][][][][][][][][]\"));\n    Assert.assertEquals(\"java.lang.String\", ClassVisitor.removePackageContext(\"java.lang.String[][][][][][][][][][][][]\"));\n    Assert.assertEquals(\"java.lang.String\", ClassVisitor.removePackageContext(\"java.lang.String[][][][][][][][][][][][][]\"));\n    Assert.assertEquals(\"java.lang.String\", ClassVisitor.removePackageContext(\"java.lang.String[][][][][][][][][][][][][][]\"));\n    Assert.assertEquals(\"java.lang.String\", ClassVisitor.removePackageContext(\"java.lang.String[][][][][][][][][][][][][][][]\"));\n    Assert.assertEquals(\"java.lang.String\", ClassVisitor.removePackageContext(\"java.lang.String[][][][][][][][][][][][][][][][]\"));\n    Assert.assertEquals(\"java.lang.String\", ClassVisitor.removePackageContext(\"java.lang.String[][][][][][][][][][][][][][][][][]\"));\n    Assert.assertEquals(\"java.lang.String\", ClassVisitor.removePackageContext(\"java.lang.String[][][][][][][][][][][][][][][][][][]\"));\n    Assert.assertEquals(\"java.lang.String\", ClassVisitor.removePackageContext(\"java.lang.String[][][][][][][][][][][][][][][][][][][]\"));\n    Assert.assertEquals(\"java.lang.String\", ClassVisitor.removePackageContext(\"java.lang.String[][][][][][][][][][][][][][][][][][][][]\"));\n    Assert.assertEquals(\"java.lang.String\", ClassVisitor.removePackageContext(\"java.lang.String[][][][][][][][][][][][][][][][][][][][][]\"));\n    Assert.assertEquals(\"java.lang.String\", ClassVisitor.removePackageContext(\"java.lang.String[][][][][][][][][][][][][][][][][][][][][][]\"));\n    Assert.assertEquals(\"java.lang.String\", ClassVisitor.removePackageContext(\"java.lang.String[][][][][][][][][][][][][][][][][][][][][][][]\"));\n    Assert.assertEquals(\"java.lang.String\", ClassVisitor.removePackageContext(\"java.lang.String[][][][][][][][][][][][][][][][][][][][][][][][]\"));\n    Assert.assertEquals(\"java.lang.String\", ClassVisitor.removePackageContext(\"java.lang.String[][][][][][][][][][][][][][][][][][][][][][][][][]\"));\n    Assert.assertEquals(\"java.lang.String\", ClassVisitor.removePackageContext(\"java.lang.String[][][][][][][][][][][][][][][][][][][][][][][][][][]\"));\n    Assert.assertEquals(\"java.lang.String\", ClassVisitor.removePackageContext(\"java.lang.String[][][][][][][][][][][][][][][][][][][][][][][][][][][]\"));\n    Assert.assertEquals(\"java.lang.String\", ClassVisitor.removePackageContext(\"java.lang.String[][][][][][][][][][][][][][][][][][][][][][][][][][][][]\"));\n    Assert.assertEquals(\"java.lang.String\", ClassVisitor.removePackageContext(\"java.lang.String[][][][][][][][][][][][][][][][][][][][][][][][][][][][][]\"));\n    Assert.assertEquals(\"java.lang.String\", ClassVisitor.removePackageContext(\"java.lang.String[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]\"));\n    Assert.assertEquals(\"java.lang.String\", ClassVisitor.removePackageContext(\"java.lang.String[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]\"));\n    Assert.assertEquals(\"java.lang.String\", ClassVisitor.removePackageContext(\"java.lang.String[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]\"));\n    Assert.assertEquals(\"java.lang.String\", ClassVisitor.removePackageContext(\"java.lang.String[][][][][][][][][][][][][][][][][][][][][][]", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "145957544_46", "part": [1, 1], "seq": [1, 1], "prompt": "class BundleNormalizer {\n\n  protected static String normalize(String s) {\n    Require.nonNull(s, \"parameter s may not be null or empty.\");\n\n    // first replace umlauts with two-characters\n    s= replaceUmlauts(s);\n\n    // then replace some special characters\n    s= s.replaceAll(\"[\\\\ \\\\.\\\\-\\n/]+\", \"_\");\n\n    // then remove all diacritics and all characters not US_ASCII or numbers\n    s= Normalizer\n            .normalize(s, Normalizer.Form.NFKD)\n            .replaceAll(\"[^\\\\P{M}]\", \"\")\n            .replaceAll(\"[^\\\\p{Alnum}\\\\_\\\\-\\\\ ]\", \"\");\n\n    // then replace multiple underscores with only one underscore\n    s= s.replaceAll(\"[_]+\", \"_\");\n\n    // remove all leading and trailing underscores\n    s= s.replaceAll(\"^_\", \"\").replaceAll(\"_$\", \"\");\n\n    return s;\n  }\n\n  public static String toClassName(String s);\n  public static String toFieldName(String s);\n  public static String toConstName(String s);\n  public static String toBundleName(String s);\n  protected static String replaceUmlauts(final String s);\n\n}\n\nclass BundleNormalizerTest {\n\n  @Test\n  public void testNormalize() {\n", "reference": "    final String input = \"T\u0125\u00ef\u015d-\u0129\u0161 \u00e2__f\u016f\u0148\u0137\u0177_\u0160\u0165\u0155\u012d\u0144\u0121.\u00e4\u00c4\u00fc\u00ff\u00c6\u00bc.!/\\\\?+*]{[}$#@@!$%^&&\u00df!$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\\\"\";\n    final String expected= \"This_is_a_funky_String_aeAEueyAE14_ss\";\n\n    final String actual= BundleNormalizer.normalize(input);\n\n    assertThat(actual).isEqualTo(expected);\n  }\n\n}", "prediction": "    assertEquals(\"\", BundleNormalizer.normalize(\"\"));\n    assertEquals(\"a\", BundleNormalizer.normalize(\"a\"));\n    assertEquals(\"a_b\", BundleNormalizer.normalize(\"a b\"));\n    assertEquals(\"a_b\", BundleNormalizer.normalize(\"a.b\"));\n    assertEquals(\"a_b\", BundleNormalizer.normalize(\"a-b\"));\n    assertEquals(\"a_b\", BundleNormalizer.normalize(\"a/b\"));\n    assertEquals(\"a_b\", BundleNormalizer.normalize(\"a\\\\b\"));\n    assertEquals(\"a_b\", BundleNormalizer.normalize(\"a.b.c\"));\n    assertEquals(\"a_b\", BundleNormalizer.normalize(\"a.b.c.d\"));\n    assertEquals(\"a_b\", BundleNormalizer.normalize(\"a.b.c.d.e\"));\n    assertEquals(\"a_b\", BundleNormalizer.normalize(\"a.b.c.d.e.f\"));\n    assertEquals(\"a_b\", BundleNormalizer.normalize(\"a.b.c.d.e.f.g\"));\n    assertEquals(\"a_b\", BundleNormalizer.normalize(\"a.b.c.d.e.f.g.h\"));\n    assertEquals(\"a_b\", BundleNormalizer.normalize(\"a.b.c.d.e.f.g.h.i\"));\n    assertEquals(\"a_b\", BundleNormalizer.normalize(\"a.b.c.d.e.f.g.h.i.j\"));\n    assertEquals(\"a_b\", BundleNormalizer.normalize(\"a.b.c.d.e.f.g.h.i.j.k\"));\n    assertEquals(\"a_b\", BundleNormalizer.normalize(\"a.b.c.d.e.f.g.h.i.j.k.l\"));\n    assertEquals(\"a_b\", BundleNormalizer.normalize(\"a.b.c.d.e.f.g.h.i.j.k.l.m\"));\n    assertEquals(\"a_b\", BundleNormalizer.normalize(\"a.b.c.d.e.f.g.h.i.j.k.l.m.n\"));\n    assertEquals(\"a_b\", BundleNormalizer.normalize(\"a.b.c.d.e.f.g.h.i.j.k.l.m.n.o\"));\n    assertEquals(\"a_b\", BundleNormalizer.normalize(\"a.b.c.d.e.f.g.h.i.j.k.l.m.n.o.p\"));\n    assertEquals(\"a_b\", BundleNormalizer.normalize(\"a.b.c.d.e.f.g.h.i.j.k.l.m.n.o.p.q\"));\n    assertEquals(\"a_b\", BundleNormalizer.normalize(\"a.b.c.d.e.f.g.h.i.j.k.l.m.n.o.p.q.r\"));\n    assertEquals(\"a_b\", BundleNormalizer.normalize(\"a.b.c.d.e.f.g.h.i.j.k.l.m.n.o.p.q.r.s\"));\n    assertEquals(\"a_b\", BundleNormalizer.normalize(\"a.b.c.d.e.f.g.h.i.j.k.l.m.n.o.p.q.r.s.t\"));\n    assertEquals(\"a_b\", BundleNormalizer.normalize(\"a.b.c.d.e.f.g.h.i.j.k.l.m.n.o.p.q.r.s.t.u\"));\n    assertEquals(\"a_b\", BundleNormalizer.normalize(\"a.b.c.d.e.f.g.h.i.j.k.l.m.n.o.p.q.r.s.t.u.v\"));\n    assertEquals(\"a_b\", BundleNormalizer.normalize(\"a.b.c.d.e.f.g.h.i.j.k.l.m.n.o.p.q.r.s.t.u.v.w\"));\n    assertEquals(\"a_b\", BundleNormalizer.normalize(\"a.b.c.d.e.f.g.h.i.j.k.l.m.n.o.p.q.r.s.t.u.v.w.x\"));\n    assertEquals(\"a_b\", BundleNormalizer.normalize(\"a.b.c.d.e.f.g.h.i.j.k.l.m.n.o.p.q.r.s.t.u.v.w.x.y\"));\n    assertEquals(\"a_b\", BundleNormalizer.normalize(\"a.b.c.d.e.f.g.h.i.j.k.l.m.n.o.p.q.r.s.t.u.v.w.x.y.z\"));\n    assertEquals(\"a_b\", BundleNormalizer.normalize(\"a.b.c.d.e.f.g.h.i.j.k.l.m.n.o.p.q.r.s.t.u.v.w.x.y.z.a\"));\n    assertEquals(\"a_b\", BundleNormalizer.normalize(\"a.b.c.d.e.f.g.h.i.j.k.l.m.n.o.p.q.r.s.t.u.v.w.x.y.z.a.b\"));\n    assertEquals(\"a_b\", BundleNormalizer.normalize(\"a.b.c.d.e.f.g.h.i.j.k.l.m.n.o.p.q.r.s.t.u.v.w.x.y.z.a.b.c\"));\n    assertEquals(\"a_b\", BundleNormalizer.normalize(\"a.b.c.d.e.f.g.h.i.j.k.l.m.", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "146177746_35", "part": [1, 1], "seq": [1, 1], "prompt": "class SwaggerBasePathRewritingFilter extends SendResponseFilter {\n\n    @Override\n    public boolean shouldFilter() {\n        return RequestContext.getCurrentContext().getRequest().getRequestURI().endsWith(Swagger2Controller.DEFAULT_URL);\n    }\n\n    public  SwaggerBasePathRewritingFilter();\n\n    @Override public String filterType();\n    @Override public int filterOrder();\n    @Override public Object run();\n    @SuppressWarnings(\"unchecked\") private String rewriteBasePath(RequestContext context);\n\n    private SwaggerBasePathRewritingFilter filter;\n\n}\n\nclass SwaggerBasePathRewritingFilterTest {\n\n    private SwaggerBasePathRewritingFilter filter;\n\n    @Test\n    public void shouldNotFilter_on_wrong_url() {\n", "reference": "\n        MockHttpServletRequest request = new MockHttpServletRequest(\"GET\", \"/management/info\");\n        RequestContext.getCurrentContext().setRequest(request);\n\n        assertFalse(filter.shouldFilter());\n    }\n\n}", "prediction": "        RequestContext context = new RequestContext();\n        context.setRequest(new MockHttpServletRequest(\"GET\", \"/api/swagger\"));\n        assertFalse(filter.shouldFilter());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "147378679_2", "part": [1, 1], "seq": [1, 1], "prompt": "class MathUtil {\n\n    public static double[] powerSumsToChebyMoments(\n            double min,\n            double max,\n            double[] powerSums\n    ) {\n        int k = powerSums.length - 1;\n        double r = (max - min) / 2;\n        double xc = (max + min) / 2;\n        // First rescale the variables so that they lie in [-1,1]\n        double[] scaledPowerSums = MathUtil.shiftPowerSum(\n                powerSums,r,xc\n        );\n\n        double count = powerSums[0];\n        int[][] cCoeffs = MathUtil.getChebyCoefficients(k);\n        // Then convert from power sums to chebyshev moments\n        double[] scaledChebyMoments = new double[k+1];\n        for (int i = 0; i <=k; i++) {\n            double sum = 0.0;\n            for (int j = 0; j <= i; j++) {\n                sum += cCoeffs[i][j]*scaledPowerSums[j];\n            }\n            scaledChebyMoments[i] = sum / count;\n        }\n\n        return scaledChebyMoments;\n    }\n\n    public static long[][] getBinomials(int m);\n    public static int[][] getChebyCoefficients(int k);\n    public static double[] shiftPowerSum(\n            double[] powerSums,\n            double r,\n            double xc\n    );\n    public static double[] powerSumsToZerodMoments(\n            double[] powerSums,\n            double min,\n            double max\n    );\n    public static double arrayMean(double[] xs);\n    public static void calcPowers(double x, double[] powers);\n    public static double entropy(double[] ps);\n    public static double getMSE(double[] error);\n\n}\n\nclass MathUtilTest {\n\n    @Test\n    public void testConvertMoments() {\n", "reference": "        // integers from 0...1000\n        double[] uniformPowerSums = {1001,500500,333833500,250500250000L};\n        double[] convertedChebyshevMoments = MathUtil.powerSumsToChebyMoments(0, 1000, uniformPowerSums);\n\n        double[] expectedChebyshevMoments = {1.0, 0, -.332, 0};\n        assertArrayEquals(expectedChebyshevMoments, convertedChebyshevMoments, 1e-14);\n    }\n\n}", "prediction": "        double[] moments = new double[] {\n                1.0,\n                2.0,\n                3.0,\n                4.0,\n                5.0\n        };\n        double[] powerSums = MathUtil.powerSumsToChebyMoments(\n                0.0,\n                1.0,\n                moments\n        );\n        double[] moments2 = MathUtil.powerSumsToZerodMoments(\n                powerSums,\n                0.0,\n                1.0\n        );\n        assertArrayEquals(moments, moments2, 1e-10);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "149736342_247", "part": [1, 1], "seq": [1, 1], "prompt": "class Contract extends ManagedTransaction {\n\n    protected EventValuesWithLog extractEventParametersWithLog(Event event, Log log) {\n        final EventValues eventValues = staticExtractEventParameters(event, log);\n        return (eventValues == null) ? null : new EventValuesWithLog(eventValues, log);\n    }\n\n    protected  Contract(String contractBinary, String contractAddress,\n                       Web3j web3j, TransactionManager transactionManager,\n                       BigInteger gasPrice, BigInteger gasLimit);\n    protected  Contract(String contractBinary, String contractAddress,\n                       Web3j web3j, Credentials credentials,\n                       BigInteger gasPrice, BigInteger gasLimit);\n    @Deprecated protected  Contract(String contractAddress,\n                       Web3j web3j, TransactionManager transactionManager,\n                       BigInteger gasPrice, BigInteger gasLimit);\n    @Deprecated protected  Contract(String contractAddress,\n                       Web3j web3j, Credentials credentials,\n                       BigInteger gasPrice, BigInteger gasLimit);\n\n    public void setContractAddress(String contractAddress);\n    public String getContractAddress();\n    public void setTransactionReceipt(TransactionReceipt transactionReceipt);\n    public String getContractBinary();\n    public void setGasPrice(BigInteger newPrice);\n    public BigInteger getGasPrice();\n    public boolean isValid();\n    public TransactionReceipt getTransactionReceipt();\n    private List<Type> executeCall(\n            Function function);\n    @SuppressWarnings(\"unchecked\") protected T executeCallSingleValueReturn(\n            Function function);\n    @SuppressWarnings(\"unchecked\") protected R executeCallSingleValueReturn(\n            Function function, Class<R> returnType);\n    protected List<Type> executeCallMultipleValueReturn(\n            Function function);\n    protected TransactionReceipt executeTransaction(\n            Function function);\n    private TransactionReceipt executeTransaction(\n            Function function, BigInteger weiValue);\n     TransactionReceipt executeTransaction(\n            String data, BigInteger weiValue);\n    protected RemoteCall<T> executeRemoteCallSingleValueReturn(\n            final Function function);\n    protected RemoteCall<T> executeRemoteCallSingleValueReturn(\n            final Function function, final Class<T> returnType);\n    protected RemoteCall<List<Type>> executeRemoteCallMultipleValueReturn(final Function function);\n    protected RemoteCall<TransactionReceipt> executeRemoteCallTransaction(final Function function);\n    protected RemoteCall<TransactionReceipt> executeRemoteCallTransaction(\n            final Function function, final BigInteger weiValue);\n    private static T create(\n            T contract, String binary, String encodedConstructor, BigInteger value);\n    protected static T deploy(\n            Class<T> type,\n            Web3j web3j, Credentials credentials,\n            BigInteger gasPrice, BigInteger gasLimit,\n            String binary, String encodedConstructor, BigInteger value);\n    protected static T deploy(\n            Class<T> type,\n            Web3j web3j, TransactionManager transactionManager,\n            BigInteger gasPrice, BigInteger gasLimit,\n            String binary, String encodedConstructor, BigInteger value);\n    protected static RemoteCall<T> deployRemoteCall(\n            final Class<T> type,\n            final Web3j web3j, final Credentials credentials,\n            final BigInteger gasPrice, final BigInteger gasLimit,\n            final String binary, final String encodedConstructor, final BigInteger value);\n    protected static RemoteCall<T> deployRemoteCall(\n            Class<T> type,\n            Web3j web3j, Credentials credentials,\n            BigInteger gasPrice, BigInteger gasLimit,\n            String binary, String encodedConstructor);\n    protected static RemoteCall<T> deployRemoteCall(\n            final Class<T> type,\n            final Web3j web3j, final TransactionManager transactionManager,\n            final BigInteger gasPrice, final BigInteger gasLimit,\n            final String binary, final String encodedConstructor, final BigInteger value);\n    protected static RemoteCall<T> deployRemoteCall(\n            Class<T> type,\n            Web3j web3j, TransactionManager transactionManager,\n            BigInteger gasPrice, BigInteger gasLimit,\n            String binary, String encodedConstructor);\n    public static EventValues staticExtractEventParameters(\n            Event event, Log log);\n    protected EventValues extractEventParameters(Event event, Log log);\n    protected List<EventValues> extractEventParameters(\n            Event event, TransactionReceipt transactionReceipt);\n    protected List<EventValuesWithLog> extractEventParametersWithLog(\n            Event event, TransactionReceipt transactionReceipt);\n    protected String getStaticDeployedAddress(String networkId);\n    public final void setDeployedAddress(String networkId, String address);\n    public final String getDeployedAddress(String networkId);\n    @SuppressWarnings(\"unchecked\") protected static List<T> convertToNative(List<S> arr);\n\n    private static final String TEST_CONTRACT_BINARY;\n    private TestContract contract;\n\n}\n\nclass ContractTest extends ManagedTransaction {\n\n    private static final String TEST_CONTRACT_BINARY;\n    private TestContract contract;\n\n    @Test\n    public void testExtractEventParametersWithLogGivenATransactionReceipt() {\n", "reference": "\n        final Event testEvent1 = new Event(\n                \"TestEvent1\",\n                Collections.<TypeReference<?>>emptyList(),\n                Collections.<TypeReference<?>>emptyList());\n\n        final Event testEvent2 = new Event(\n                \"TestEvent2\",\n                Collections.<TypeReference<?>>emptyList(),\n                Collections.<TypeReference<?>>emptyList());\n\n        final List<Log> logs = Arrays.asList(\n                new Log(false, \"\" + 0, \"0\", \"0x0\", \"0x0\", \"0\", \"0x1\", \"\", \"\",\n                        singletonList(EventEncoder.encode(testEvent1))),\n                new Log(false, \"\" + 0, \"0\", \"0x0\", \"0x0\", \"0\", \"0x2\", \"\", \"\",\n                        singletonList(EventEncoder.encode(testEvent2)))\n        );\n\n        final TransactionReceipt transactionReceipt = new TransactionReceipt();\n        transactionReceipt.setLogs(logs);\n\n        final List<Contract.EventValuesWithLog> eventValuesWithLogs1 =\n                contract.extractEventParametersWithLog(testEvent1, transactionReceipt);\n\n        assertThat(eventValuesWithLogs1.size(), equalTo(1));\n        assertThat(eventValuesWithLogs1.get(0).getLog(), equalTo(logs.get(0)));\n\n        final List<Contract.EventValuesWithLog> eventValuesWithLogs2 =\n                contract.extractEventParametersWithLog(testEvent2, transactionReceipt);\n\n        assertThat(eventValuesWithLogs2.size(), equalTo(1));\n        assertThat(eventValuesWithLogs2.get(0).getLog(), equalTo(logs.get(1)));\n    }\n\n}", "prediction": "        final TransactionReceipt transactionReceipt = createReceipt();\n        final EventValuesWithLog eventValuesWithLog = extractEventParametersWithLog(\n                TestContract.EVENT_WITH_LOG, transactionReceipt);\n        assertThat(eventValuesWithLog.getEvent(), is(TestContract.EVENT_WITH_LOG));\n        assertThat(eventValuesWithLog.getLog(), is(transactionReceipt.getLogs().get(0)));\n        assertThat(eventValuesWithLog.getIndexedValues(), is(eventValues.getIndexedValues()));\n        assertThat(eventValuesWithLog.getNonIndexedValues(), is(eventValues.getNonIndexedValues()));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "149780295_33", "part": [1, 1], "seq": [1, 1], "prompt": "class CoverageMetrics {\n\n  public float f(int i) {\n   int k = 0; /* default */\n   if (i != 0) {\n      k = 1;\n   }\n   return (float)i/(k+1);\n  }\n\n}\n\nclass CoverageMetricsTest {\n\n  @Test\n  public void test2() throws Exception {\n", "reference": "    CoverageMetrics c = new CoverageMetrics();\n    assertEquals(0.0, c.f(0), 0.0);\n  }\n\n}", "prediction": "    CoverageMetrics cm = new CoverageMetrics();\n    assertEquals(0.0f, cm.f(0), 0.001f);\n    assertEquals(0.5f, cm.f(1), 0.001f);\n    assertEquals(1.0f, cm.f(2), 0.001f);\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "150668624_2", "part": [1, 1], "seq": [1, 1], "prompt": "class StorageJetCache extends SimpleJpaRepository<E,PK> implements IStorage<PK,E> {\n\n    @Override\n    @Transactional(rollbackFor = Exception.class)\n    public void update(E entity) {\n        PK id = entity.getId();\n        Preconditions.checkNotNull(id,\"id\u4e0d\u80fd\u4e3anull\");\n        CacheGetResult<E> cacheGetResult = cache.GET(id);\n        if (cacheGetResult.isSuccess()){\n            E entityFromCache = cacheGetResult.getValue();\n            // \u7f13\u5b58\u4e2d\u7f13\u5b58\u4e86\u5176null\u503c\uff0c\u8bf4\u660e\u6570\u636e\u5e93\u4e2d\u6ca1\u6709\n            if (entityFromCache == null) {\n                throw new EntityNotFoundException(\"\u6570\u636e\u5e93\u4e2d\u4e0d\u5b58\u5728\u8be5\u5b9e\u4f53\uff0c\u5148create\u4e00\u4e0b\uff1f\");\n            }\n            // \u7f13\u5b58\u4e2d\u6709\uff0c\u8bf4\u660e\u6570\u636e\u5e93\u4e2d\u4e5f\u6709\n            else {\n                executeUpdate(entity);\n            }\n        }else {\n            if (exists(entity.getId())){\n                executeUpdate(entity);\n            }else {\n                throw new EntityNotFoundException(\"\u6570\u636e\u5e93\u4e2d\u4e0d\u5b58\u5728\u8be5\u5b9e\u4f53\uff0c\u5148create\u4e00\u4e0b\uff1f\");\n            }\n        }\n    }\n\n    public  StorageJetCache(JpaEntityInformation<E, ?> entityInformation, EntityManager entityManager);\n\n    @Override @Transactional(rollbackFor = Exception.class) public E create(E entity);\n    private E doInsert(E entity);\n    private void doUpdate(E entity);\n    private void executeUpdate(E entity);\n    @Override public void mergeUpdate(E entity);\n    @Override public E get(PK id);\n    @Override @Transactional(rollbackFor = Exception.class) public E getOrCreate(PK id, EntityCreator<PK, E> entityCreator);\n    @Override @Transactional(rollbackFor = Exception.class) public E remove(PK id);\n    public void setDelay(int delay);\n    public void setProxy(IStorage<PK, E> proxy);\n    public void setCache(Cache<PK, E> cache);\n\n    private static final Logger logger;\n    @Autowired IStorage<String, AccountEntity> iStorage;\n    @Autowired\n    private IStorage<Long, ContainerEntity> containerEntityIStorage;\n    @Test void entity;\n     Container packContainer;\n     entity.getType2ContainerMap().put PACK;\n     containerEntityIStorage.create entity;\n     containerEntityIStorage.update entity;\n\n}\n\nclass StorageJetCacheTest extends SimpleJpaRepository<E,PK> {\n\n    private static final Logger logger;\n    @Autowired IStorage<String, AccountEntity> iStorage;\n    @Autowired\n    private IStorage<Long, ContainerEntity> containerEntityIStorage;\n    @Test void entity;\n     Container packContainer;\n     entity.getType2ContainerMap().put PACK;\n     containerEntityIStorage.create entity;\n     containerEntityIStorage.update entity;\n\n    @Test\n    void update() {\n", "reference": "        AccountEntity accountEntity = createNotExists();\n        accountEntity.setPassword(\"passWordUpdate\");\n        iStorage.update(accountEntity);\n        iStorage.remove(accountEntity.getId());\n        Assertions.assertEquals(\"passWordUpdate\",iStorage.get(accountEntity.getAccount()).getPassword());\n    }\n\n}", "prediction": "        Container container = new Container();\n        container.setId(1L);\n        container.setName(\"test\");\n        container.setType(ContainerType.PACK);\n        containerEntityIStorage.create(container);\n        container.setName(\"test2\");\n        containerEntityIStorage.update(container);\n        Container container2 = containerEntityIStorage.get(1L);\n        Assertions.assertEquals(\"test2\", container2.getName());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "150938406_239", "part": [1, 1], "seq": [1, 1], "prompt": "class SparseVector extends Vector {\n\n    @Override\n    public double get(int i) {\n        int pos = Arrays.binarySearch(indices, i);\n        if (pos >= 0) {\n            return values[pos];\n        }\n        return 0.;\n    }\n\n    public  SparseVector();\n    public  SparseVector(int n);\n    public  SparseVector(int n, int[] indices, double[] values);\n    public  SparseVector(int n, Map<Integer, Double> kv);\n\n    private void checkSizeAndIndicesRange();\n    private static void sortImpl(int[] indices, double[] values, int low, int high);\n    private void sortIndices();\n    @Override public SparseVector clone();\n    @Override public SparseVector prefix(double d);\n    @Override public SparseVector append(double d);\n    public int[] getIndices();\n    public double[] getValues();\n    @Override public int size();\n    public void setSize(int n);\n    public int numberOfValues();\n    @Override public void set(int i, double val);\n    @Override public void add(int i, double val);\n    private void insert(int pos, int index, double val);\n    @Override public String toString();\n    @Override public double normL2();\n    @Override public double normL1();\n    @Override public double normInf();\n    @Override public double normL2Square();\n    @Override public SparseVector slice(int[] indices);\n    @Override public Vector plus(Vector vec);\n    @Override public Vector minus(Vector vec);\n    @Override public SparseVector scale(double d);\n    @Override public void scaleEqual(double d);\n    public void removeZeroValues();\n    private double dot(SparseVector other);\n    private double dot(DenseVector other);\n    @Override public double dot(Vector other);\n    @Override public DenseMatrix outer();\n    public DenseMatrix outer(SparseVector other);\n    public DenseVector toDenseVector();\n    @Override public void standardizeEqual(double mean, double stdvar);\n    @Override public void normalizeEqual(double p);\n    @Override public boolean equals(Object o);\n    @Override public int hashCode();\n    public void forEach(BiConsumer<Integer, Double> action);\n    @Override public VectorIterator iterator();\n\n    private static final double TOL;\n    private SparseVector v1;\n    private SparseVector v2;\n\n}\n\nclass SparseVectorTest {\n\n    private static final double TOL;\n    private SparseVector v1;\n    private SparseVector v2;\n\n    @Test\n    public void testGet() throws Exception {\n", "reference": "        Assert.assertEquals(v1.get(5), 2.0, TOL);\n        Assert.assertEquals(v1.get(6), 0.0, TOL);\n    }\n\n}", "prediction": "        assertEquals(0., v1.get(0), TOL);\n        assertEquals(1., v1.get(1), TOL);\n        assertEquals(2., v1.get(2), TOL);\n        assertEquals(3., v1.get(3), TOL);\n        assertEquals(4., v1.get(4), TOL);\n        assertEquals(5., v1.get(5), TOL);\n        assertEquals(6., v1.get(6), TOL);\n        assertEquals(7., v1.get(7), TOL);\n        assertEquals(8., v1.get(8), TOL);\n        assertEquals(9., v1.get(9), TOL);\n        assertEquals(10., v1.get(10), TOL);\n        assertEquals(11., v1.get(11), TOL);\n        assertEquals(12., v1.get(12), TOL);\n        assertEquals(13., v1.get(13), TOL);\n        assertEquals(14., v1.get(14), TOL);\n        assertEquals(15., v1.get(15), TOL);\n        assertEquals(16., v1.get(16), TOL);\n        assertEquals(17., v1.get(17), TOL);\n        assertEquals(18., v1.get(18), TOL);\n        assertEquals(19., v1.get(19), TOL);\n        assertEquals(20., v1.get(20), TOL);\n        assertEquals(21., v1.get(21), TOL);\n        assertEquals(22., v1.get(22), TOL);\n        assertEquals(23., v1.get(23), TOL);\n        assertEquals(24., v1.get(24), TOL);\n        assertEquals(25., v1.get(25), TOL);\n        assertEquals(26., v1.get(26), TOL);\n        assertEquals(27., v1.get(27), TOL);\n        assertEquals(28., v1.get(28), TOL);\n        assertEquals(29., v1.get(29), TOL);\n        assertEquals(30., v1.get(30), TOL);\n        assertEquals(31., v1.get(31), TOL);\n        assertEquals(32., v1.get(32), TOL);\n        assertEquals(33., v1.get(33), TOL);\n        assertEquals(34., v1.get(34), TOL);\n        assertEquals(35., v1.get(35), TOL);\n        assertEquals(36., v1.get(36), TOL);\n        assertEquals(37., v1.get(37), TOL);\n        assertEquals(38., v1.get(38), TOL);\n        assertEquals(39., v1.get(39), TOL);\n        assertEquals(40., v1.get(40), TOL);\n        assertEquals(41., v1.get(41), TOL);\n        assertEquals(42., v1.get(42), TOL);\n        assertEquals(43", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "153155267_8", "part": [1, 1], "seq": [1, 1], "prompt": "class EventBusSink {\n\n    SubscriberBuilder<? extends Message<?>, Void> sink() {\n        DeliveryOptions options = new DeliveryOptions();\n        if (this.codec != null) {\n            options.setCodecName(this.codec);\n        }\n        if (this.timeout != -1) {\n            options.setSendTimeout(this.timeout);\n        }\n\n        return ReactiveStreams.<Message<?>> builder()\n                .flatMapCompletionStage(msg -> {\n                    // TODO support getting an EventBusMessage as message.\n                    if (!this.publish) {\n                        if (expectReply) {\n                            return vertx.eventBus().request(address, msg.getPayload(), options).subscribeAsCompletionStage()\n                                    .thenApply(m -> msg);\n                        } else {\n                            vertx.eventBus().sendAndForget(address, msg.getPayload(), options);\n                            return CompletableFuture.completedFuture(msg);\n                        }\n                    } else {\n                        vertx.eventBus().publish(address, msg.getPayload(), options);\n                        return CompletableFuture.completedFuture(msg);\n                    }\n                })\n                .ignore();\n    }\n\n      EventBusSink(Vertx vertx, VertxEventBusConnectorOutgoingConfiguration config);\n\n    private WeldContainer container;\n\n}\n\nclass EventBusSinkTest  {\n\n    private WeldContainer container;\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testExpectReply() {\n", "reference": "        String topic = UUID.randomUUID().toString();\n\n        List<Integer> integers = new ArrayList<>();\n        AtomicReference<io.vertx.mutiny.core.eventbus.Message<Integer>> last = new AtomicReference<>();\n        vertx.eventBus().<Integer> consumer(topic, m -> {\n            last.set(m);\n            if (m.body() < 8) {\n                integers.add(m.body());\n                m.replyAndForget(\"foo\");\n            }\n        });\n\n        Map<String, Object> config = new HashMap<>();\n        config.put(\"address\", topic);\n        config.put(\"expect-reply\", true);\n        EventBusSink sink = new EventBusSink(vertx,\n                new VertxEventBusConnectorOutgoingConfiguration(new MapBasedConfig(config)));\n\n        SubscriberBuilder<? extends Message<?>, Void> subscriber = sink.sink();\n        Multi.createFrom().range(0, 10)\n                .map(Message::of)\n                .subscribe((Subscriber<Message<?>>) subscriber.build());\n\n        await().until(() -> integers.size() == 8 && last.get().body() == 8);\n        last.get().replyAndForget(\"bar\");\n        await().until(() -> last.get().body() == 9);\n        assertThat(last.get().body()).isEqualTo(9);\n        last.get().replyAndForget(\"baz\");\n    }\n\n}", "prediction": "        EventBusSink sink = container.select(EventBusSink.class).get();\n        SubscriberBuilder<? extends Message<?>, Void> subscriber = sink.sink();\n        Message<String> message = Message.of(\"hello\");\n        subscriber.build().subscribe(new Subscriber<Message<?>>() {\n\n            @Override\n            public void onSubscribe(Subscription s) {\n                s.request(1);\n            }\n\n            @Override\n            public void onNext(Message<?> message) {\n                assertEquals(\"hello\", message.getPayload());\n            }\n\n            @Override\n            public void onError(Throwable t) {\n                fail(t);\n            }\n\n            @Override\n            public void onComplete() {\n\n            }\n        });\n        subscriber.buildRs().request(1).toCompletableFuture().join();\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "153608306_1", "part": [1, 1], "seq": [1, 1], "prompt": "class Vehiculo {\n\n\tpublic void setMatricula(String matricula) {\n\t\tthis.matricula = matricula;\n\t}\n\n\tpublic  Vehiculo();\n\tpublic  Vehiculo(int id, String numeroBastidor, String matricula, Combustible combustible, Modelo modelo);\n\n\tpublic Persona getPropietario();\n\tpublic void setPropietario(Persona propietario);\n\tpublic int getId();\n\tpublic void setId(int id);\n\tpublic String getNumeroBastidor();\n\tpublic void setNumeroBastidor(String numeroBastidor);\n\tpublic String getMatricula();\n\tpublic Combustible getCombustible();\n\tpublic void setCombustible(Combustible combustible);\n\tpublic Modelo getModelo();\n\tpublic void setModelo(Modelo modelo);\n\t@Override public String toString();\n\n}\n\nclass VehiculoTest {\n\n\t@Test\n\tpublic void test() {\n", "reference": "\t\t\n\t\tValidatorFactory factory = Validation.buildDefaultValidatorFactory();\n\t\tValidator validator = factory.getValidator();\n\t\t\n\t\tVehiculo vCompleteCheck = new Vehiculo();\n\t\tVehiculo vPostCheck = new Vehiculo();\n\t\t\t\t\n\t\tSet<ConstraintViolation<Vehiculo>> vComplete = validator.validate(vCompleteCheck, VehiculoCompleteCheck.class );\n\t\tSet<ConstraintViolation<Vehiculo>> vPost = validator.validate(vPostCheck, VehiculosPostCheck.class );\n\t\t\n\t\tassertEquals(\"Deberia haber 5 violaciones\", 5 , vComplete.size() );\n\t\tassertEquals(\"Deberia haber 4 violaciones\", 4 , vPost.size() );\n\t\t\n\t\tvCompleteCheck.setMatricula(\"12\");\n\t\tvComplete = validator.validate(vCompleteCheck, VehiculoCompleteCheck.class );\n\t\tassertEquals(\"quitamos viloacion NotEmpty\", 4 , vComplete.size() );\n\t\t\n\t\t\n\t\tvCompleteCheck.setMatricula(\"12345678\");\n\t\tvComplete = validator.validate(vCompleteCheck, VehiculoCompleteCheck.class );\n\t\tassertEquals(\"quitamos viloacion Size(min=8, max =10)\", 3 , vComplete.size() );\n\t\t\n\t\t\n\t\t\n\t}\n\n}", "prediction": "\t\tfail(\"Not yet implemented\");\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "154253610_0", "part": [1, 1], "seq": [1, 1], "prompt": "class FastSharedPreferences implements EnhancedSharedPreferences {\n\n    public static FastSharedPreferences get(String name) {\n        if (name == null || name.length() == 0) {\n            return null;\n        }\n        synchronized (FastSharedPreferences.class) {\n            return FSP_CACHE.get(name);\n        }\n    }\n\n    private  FastSharedPreferences(String name);\n\n    public static void init(Context context);\n    public static void setMaxSize(int maxSize);\n    @Override public Map<String, ?> getAll();\n    @Nullable @Override public String getString(String s, @Nullable String s1);\n    @Override public Serializable getSerializable(String key, @Nullable Serializable defValue);\n    @Nullable @Override public Set<String> getStringSet(String s, @Nullable Set<String> set);\n    @Override public int getInt(String s, int i);\n    @Override public long getLong(String s, long l);\n    @Override public float getFloat(String s, float v);\n    @Override public boolean getBoolean(String s, boolean b);\n    @Override public boolean contains(String s);\n    @Override public EnhancedEditor edit();\n    @Override public void registerOnSharedPreferenceChangeListener(OnSharedPreferenceChangeListener onSharedPreferenceChangeListener);\n    @Override public void unregisterOnSharedPreferenceChangeListener(OnSharedPreferenceChangeListener onSharedPreferenceChangeListener);\n    private void reload();\n    private int sizeOf();\n\n    @Mock Context context;\n    @Mock Context appContext;\n\n}\n\nclass FastSharedPreferencesTest {\n\n    @Mock Context context;\n    @Mock Context appContext;\n\n    @Test\n    public void testLoad() {\n", "reference": "        FastSharedPreferences sharedPreferences = FastSharedPreferences.get(\"test_load\");\n        assertNotNull(sharedPreferences);\n    }\n\n}", "prediction": "        FastSharedPreferences.init(context);\n        FastSharedPreferences fsp = FastSharedPreferences.get(\"test\");\n        assertNotNull(fsp);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "154302277_67", "part": [1, 1], "seq": [1, 1], "prompt": "class TimestampMeasurementElement implements MeasurementElement, Serializable {\n\n    public ZonedDateTime asZonedDateTime() {\n        return ZonedDateTime.ofInstant(Instant.ofEpochMilli(this.value), ZoneOffset.UTC);\n    }\n\n    public  TimestampMeasurementElement(final long value);\n    public  TimestampMeasurementElement(final ZonedDateTime zonedDateTime);\n\n    public Long getValue();\n    @Override public boolean equals(final Object obj);\n    @Override public int hashCode();\n    @Override public String toString();\n\n}\n\nclass TimestampMeasurementElementTest {\n\n    @Test\n    public void AsZonedDateTimeShouldReturnCorrectZonedDateTimeWhenConstructedUsingZonedDateTime() {\n", "reference": "        // Arrange\n        final ZonedDateTime expected = ZonedDateTime.of(2020, 2, 20, 21, 59, 59, 0, ZoneOffset.UTC);\n\n        // Act\n        final TimestampMeasurementElement element = new TimestampMeasurementElement(expected);\n        final ZonedDateTime actual = element.asZonedDateTime();\n\n        // Assert\n        assertThat(actual).isEqualTo(expected);\n    }\n\n}", "prediction": "        // Given\n        final ZonedDateTime zonedDateTime = ZonedDateTime.now();\n\n        // When\n        final TimestampMeasurementElement timestampMeasurementElement = new TimestampMeasurementElement(zonedDateTime);\n\n        // Then\n        assertThat(timestampMeasurementElement.asZonedDateTime()).isEqualTo(zonedDateTime);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "156757718_5", "part": [1, 1], "seq": [1, 1], "prompt": "class ItemMapper {\n\n    public Map<PrimaryKey, Item> mergeItems(List<ByteBuffer> list) {\n        return  list.stream()\n                .map( r -> new AbstractMap.SimpleEntry<>(\n                                key(r),\n                                fromByteBuffer(r)\n                        )\n                ).collect(\n                        Collectors.toMap(\n                                AbstractMap.SimpleEntry::getKey,\n                                AbstractMap.SimpleEntry::getValue,\n                                (left,right) -> mergeItem(\n                                        primaryKey(left),\n                                        left,\n                                        right\n                                )\n                        )\n                );\n    }\n\n    public PrimaryKey key(ByteBuffer byteBuffer);\n    public PrimaryKey key(JsonNode node);\n    public PrimaryKey primaryKey(Item item);\n    public List<Item> mergeItems(Collection<Item> created, Collection<Item> read);\n    public Item mergeItem(PrimaryKey primaryKey, Item newItem, Item oldItem);\n    private void mergeOneWay(Item newItem, Item oldItem, Item resultItem, Set<String> visited);\n    public Object mergeValue(Object newObject, Object oldValue);\n    public Item fromByteBuffer(ByteBuffer byteBuffer);\n\n    private static final ObjectMapper mapper;\n    private List<Aggregation> aggregations;\n    private ItemMapper itemMapper;\n\n}\n\nclass ItemMapperTest {\n\n    private static final ObjectMapper mapper;\n    private List<Aggregation> aggregations;\n    private ItemMapper itemMapper;\n\n    @Test\n    public void mergeItems() {\n", "reference": "        Map<PrimaryKey, Item> merged = itemMapper.mergeItems(\n                aggregations.stream()\n                        .map(this::serialize)\n                        .collect(Collectors.toList())\n        );\n        assertEquals(1, merged.size());\n        Item mergedItem = merged.values().iterator().next();\n        Aggregation aggregation1 = aggregations.get(0);\n        Aggregation aggregation2 = aggregations.get(1);\n\n        assertEquals(aggregation1.getClicks() + aggregation2.getClicks(), mergedItem.getLong(\"clicks\"));\n        assertEquals(aggregation1.getBids() + aggregation2.getBids(), mergedItem.getLong(\"bids\"));\n        assertEquals(aggregation1.getImps() + aggregation2.getImps(), mergedItem.getLong(\"imps\"));\n    }\n\n}", "prediction": "        List<Item> created = new ArrayList<>();\n        created.add(new Item().withPrimaryKey(\"id\", \"1\").with(\"name\", \"name1\"));\n        created.add(new Item().withPrimaryKey(\"id\", \"2\").with(\"name\", \"name2\"));\n        created.add(new Item().withPrimaryKey(\"id\", \"3\").with(\"name\", \"name3\"));\n\n        List<Item> read = new ArrayList<>();\n        read.add(new Item().withPrimaryKey(\"id\", \"1\").with(\"name\", \"name1\").with(\"age\", 10));\n        read.add(new Item().withPrimaryKey(\"id\", \"2\").with(\"name\", \"name2\").with(\"age\", 20));\n        read.add(new Item().withPrimaryKey(\"id\", \"3\").with(\"name\", \"name3\").with(\"age\", 30));\n\n        Map<PrimaryKey, Item> result = itemMapper.mergeItems(created, read);\n        assertThat(result.size(), is(3));\n        assertThat(result.get(new PrimaryKey().with(\"id\", \"1\")).get(\"name\"), is(\"name1\"));\n        assertThat(result.get(new PrimaryKey().with(\"id\", \"1\")).get(\"age\"), is(10));\n        assertThat(result.get(new PrimaryKey().with(\"id\", \"2\")).get(\"name\"), is(\"name2\"));\n        assertThat(result.get(new PrimaryKey().with(\"id\", \"2\")).get(\"age\"), is(20));\n        assertThat(result.get(new PrimaryKey().with(\"id\", \"3\")).get(\"name\"), is(\"name3\"));\n        assertThat(result.get(new PrimaryKey().with(\"id\", \"3\")).get(\"age\"), is(30));\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "157791342_6", "part": [1, 1], "seq": [1, 1], "prompt": "class MailService {\n\n\tpublic void sendInlineResourceMail(String toMail,String subject,String content,List<InlineResource> resourceist) {\n\t\tMimeMessage message = sender.createMimeMessage();\n\t\ttry {\n\t\t\tMimeMessageHelper helper = new MimeMessageHelper(message, true);\n\t\t\thelper.setFrom(formMail);\n\t\t\thelper.setCc(formMail);// \u90ae\u4ef6\u6284\u9001\u7ed9\u81ea\u5df1\u9632\u6b62\u53d1\u9001\u4e0d\u6210\u529f\uff01com.sun.mail.smtp.SMTPSendFailedException: 554 DT:SPM 126 smtp9\n\t\t\thelper.setTo(toMail);\n\t\t\thelper.setSubject(subject);\n\t\t\thelper.setText(content, true);\n\t\t\tfor (InlineResource inlineResource : resourceist) {\n\t\t\t\tFileSystemResource res = new FileSystemResource(new File(inlineResource.getPath()));\n\t\t\t\thelper.addInline(inlineResource.getCid(),res);\n\t\t\t}\n\t\t\tsender.send(message);\n\t\t\tlogger.info(\"\u5d4c\u5165\u9759\u6001\u8d44\u6e90\u7684\u90ae\u4ef6\u5df2\u7ecf\u53d1\u9001\u3002\");\n\t\t} catch (MessagingException e) {\n\t\t\tlogger.error(\"\u53d1\u9001\u5d4c\u5165\u9759\u6001\u8d44\u6e90\u7684\u90ae\u4ef6\u65f6\u53d1\u751f\u5f02\u5e38\uff01\", e);\n\t\t\te.printStackTrace();\n\t\t}catch (Exception e) {\n\t\t\tlogger.error(\"\u53d1\u9001\u5d4c\u5165\u9759\u6001\u8d44\u6e90\u7684\u90ae\u4ef6\u65f6\u53d1\u751f\u5f02\u5e38\uff01\", e);\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic void sendSimpleMail(String toMail,String subject,String content);\n\tpublic void sendHtmlMail(String toMail,String subject,String content);\n\tpublic void sendInlineResourceMailForGroupSending(String[] toMail,String subject,String content,List<InlineResource> resourceist);\n\tpublic void sendAttachmentsMail(String toMail,String subject,String content,String filePath);\n\n\t@Autowired\n\tprivate MailService mailService;\n\n}\n\nclass MailServiceTest {\n\n\t@Autowired\n\tprivate MailService mailService;\n\n\t@Test\n\tpublic void sendInlineResourceMail() {\n", "reference": "\t\tString html= \"<!DOCTYPE html>\\r\\n\" + \n\t\t\t\t\"<html>\\r\\n\" + \n\t\t\t\t\"<head>\\r\\n\" + \n\t\t\t\t\"<meta charset=\\\"UTF-8\\\">\\r\\n\" + \n\t\t\t\t\"<title>Insert title here</title>\\r\\n\" + \n\t\t\t\t\"</head>\\r\\n\" + \n\t\t\t\t\"<body>\\r\\n\" + \n\t\t\t\t\"<img src=\\\"cid:image1\\\"/> \"+\n\t\t\t\t\"<img src=\\\"cid:image2\\\"/> \"+\n\t\t\t\t\"\t<font color=\\\"red\\\">\u53d1\u9001html</font>\\r\\n\" + \n\t\t\t\t\"</body>\\r\\n\" + \n\t\t\t\t\"</html>\";\n\t\tList<InlineResource> list = new ArrayList<InlineResource>();\n\t\tString path = MailServiceTest.class.getClassLoader().getResource(\"image.jpg\").getPath();\n\t\t\n\t\tInlineResource resource = new InlineResource(\"image1\",path);\n\t\tInlineResource resource2 = new InlineResource(\"image2\",path);\n\t\t\n\t\tlist.add(resource2);\n\t\tlist.add(resource);\n\t\tmailService.sendInlineResourceMail(\"ljk163wy@163.com\", \"\u5934\u50cf\u56fe\u7247\", html,list);\n\t\t//mailService.sendInlineResourceMail(\"******@163.com\", \"\u8fd9\u662f\u4e00\u4e2a\u6d4b\u8bd5\u90ae\u4ef6\", html,list);\n\t}\n\n}", "prediction": "\t\tString toMail = \"123456789@qq.com\";\n\t\tString subject = \"\u6d4b\u8bd5\u90ae\u4ef6\";\n\t\tString content = \"\u6d4b\u8bd5\u5185\u5bb9\";\n\t\tList<InlineResource> resourceist = new ArrayList<InlineResource>();\n\t\tresourceist.add(new InlineResource(\"logo.png\",\"logo\"));\n\t\tresourceist.add(new InlineResource(\"bg.jpg\",\"bg\"));\n\t\tmailService.sendInlineResourceMail(toMail, subject, content, resourceist);\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "158126654_15", "part": [1, 1], "seq": [1, 1], "prompt": "class VAT implements ValueObject {\n\n    public double toDouble() {\n        return percentage / 100d;\n    }\n\n    @JsonCreator public  VAT(int percentage);\n\n    public static VAT valueOf(Integer percentage);\n    @JsonValue public int toInteger();\n    @NonNull public Money addTax(@NonNull Money amount);\n    @NonNull public Money subtractTax(@NonNull Money amount);\n    @NonNull public Money calculateTax(@NonNull Money amount);\n    @Override public boolean equals(Object o);\n    @Override public int hashCode();\n    @Override public String toString();\n\n}\n\nclass VATTest {\n\n    @Test\n    public void toDouble_returnedAsFraction() {\n", "reference": "        assertThat(new VAT(24).toDouble()).isEqualTo(0.24);\n    }\n\n}", "prediction": "        VAT vat = new VAT(10);\n        assertEquals(0.1d, vat.toDouble(), 0.00001d);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "158588129_26", "part": [1, 1], "seq": [1, 1], "prompt": "class HelloWorldController {\n\n  public HelloWorldController(TaskExecutor taskExecutor) {\n    this.taskExecutor = taskExecutor;\n  }\n\n  public  HelloWorldController(TaskExecutor taskExecutor);\n\n  @GetMapping public CompletableFuture<String> hello();\n  private void randomDelay();\n\n\t@Autowired\n\tprivate MockMvc mockMvc;\n\n}\n\nclass HelloWorldControllerTest {\n\n\t@Autowired\n\tprivate MockMvc mockMvc;\n\n\t@Test\n\tpublic void testHelloWorldController() throws Exception {\n", "reference": "    MvcResult mvcResult = mockMvc.perform(MockMvcRequestBuilders.get(\"/\"))\n            .andExpect(request().asyncStarted())\n            .andDo(MockMvcResultHandlers.print())\n            .andReturn();\n\n    mockMvc.perform(asyncDispatch(mvcResult))\n            .andExpect(status().isOk())\n            .andExpect(content().contentTypeCompatibleWith(MediaType.TEXT_PLAIN))\n            .andExpect(content().string(\"Hello World, from Spring Boot 2!\"));\n\t}\n\n}", "prediction": "\t\tmockMvc.perform(get(\"/hello\")).andExpect(status().isOk())\n\t\t\t\t.andExpect(content().string(\"Hello World\"));\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "160919607_5", "part": [1, 1], "seq": [1, 1], "prompt": "class RequestFilter {\n\n    public boolean isMatch(@NonNull String url) {\n        for (String r : regex) {\n            String trimUrl = url.split(\"\\\\?\")[0];\n            if (!trimUrl.endsWith(\"/\")) {\n                trimUrl = trimUrl + \"/\";\n            }\n            if (trimUrl.matches(r)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public  RequestFilter(@NonNull List<String> rules);\n\n    private List<String> constructRegex(List<String> rules);\n    @Override public boolean equals(Object o);\n    @Override public int hashCode();\n    @Override public String toString();\n\n}\n\nclass RequestFilterTest {\n\n    @Test\n    public void isMatch_exact() {\n", "reference": "        RequestFilter requestFilter = new RequestFilter(Collections.singletonList(\"https://www.test.com/todos\"));\n        assertFalse(requestFilter.isMatch(\"https://www.test.com/todos/1\"));\n        assertFalse(requestFilter.isMatch(\"https://www.test.com/todos/1/\"));\n        assertTrue(requestFilter.isMatch(\"https://www.test.com/todos/\"));\n        assertTrue(requestFilter.isMatch(\"https://www.test.com/todos\"));\n        assertTrue(requestFilter.isMatch(\"https://www.test.com/todos?query=1\"));\n    }\n\n}", "prediction": "        RequestFilter filter = new RequestFilter(Arrays.asList(\"http://example.com/\"));\n        assertTrue(filter.isMatch(\"http://example.com/\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "161133770_47", "part": [1, 1], "seq": [1, 1], "prompt": "class Matchers {\n\n  public static void checkUpperSnakeCase(String input, String resource)\n      throws IllegalArgumentException {\n    if (!UPPER_SNAKE_CASE_REGEX.matcher(input).matches()) {\n      throw new IllegalArgumentException(\n          String.format(\n              ERROR_MESSAGE_TEMPLATE,\n              resource,\n              input,\n              \"argument must be in upper snake case, and cannot include any special characters.\"));\n    }\n  }\n\n  public static void checkLowerSnakeCase(String input, String resource);\n  public static void checkValidCharacters(String input, String resource);\n  public static void checkValidCharactersAllowAsterisk(String input, String resource);\n  public static void checkValidBigQueryTableRef(String input, String resource);\n  public static boolean hasDuplicates(Collection<String> strings);\n\n  @Rule public final ExpectedException exception;\n\n}\n\nclass MatchersTest {\n\n  @Rule public final ExpectedException exception;\n\n  @Test\n  public void checkUpperSnakeCaseShouldPassForLegitUpperSnakeCase() {\n", "reference": "    String in = \"REDIS_DB\";\n    checkUpperSnakeCase(in, \"featureset\");\n  }\n\n}", "prediction": "    Matchers.checkUpperSnakeCase(\"VALID_UPPER_SNAKE_CASE\", \"test\");\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "162548942_22", "part": [1, 1], "seq": [1, 1], "prompt": "class ProtobufRpcMethodInfo extends RpcMethodInfo {\n\n    public Object inputDecode(byte[] input) throws IOException {\n        return inputInstance.getParserForType().parseFrom(input);\n    }\n\n    public  ProtobufRpcMethodInfo(Method method);\n\n    @Override public byte[] inputEncode(Object input);\n    @Override public void inputWriteToStream(Object input, CodedOutputStream stream);\n    @Override public Object outputDecode(byte[] output);\n    @Override public Object outputDecode(ByteBuf output);\n    @Override public Object outputDecode(DynamicCompositeByteBuf output);\n    public Object outputDecode(InputStream stream);\n    public Object inputDecode(byte[] input, int offset, int len);\n    public Object inputDecode(ByteBuf input);\n    public Object inputDecode(DynamicCompositeByteBuf input);\n    public Object inputDecode(InputStream stream);\n    public byte[] outputEncode(Object output);\n    @Override public void outputWriteToStream(Object output, CodedOutputStream stream);\n    @Override public int getInputSerializedSize(Object input);\n    @Override public int getOutputSerializedSize(Object output);\n\n}\n\nclass TestProtobufRpcMethodInfo {\n\n    @Test\n    public void testInputDecode3() throws Exception {\n", "reference": "        Method method = EchoService.class.getMethod(\"echo\", Echo.EchoRequest.class);\n        ProtobufRpcMethodInfo rpcMethodInfo = new ProtobufRpcMethodInfo(method);\n\n        Echo.EchoRequest request = Echo.EchoRequest.newBuilder().setMessage(\"hello\").build();\n        byte[] bytes = request.toByteArray();\n        ByteBuf byteBuf = Unpooled.wrappedBuffer(bytes);\n        Echo.EchoRequest request1 = (Echo.EchoRequest) rpcMethodInfo.inputDecode(byteBuf);\n        Assert.assertTrue(request1.getMessage().equals(request.getMessage()));\n    }\n\n}", "prediction": "        ProtobufRpcMethodInfo methodInfo = new ProtobufRpcMethodInfo(TestProtobufRpcMethodInfo.class.getMethod(\"testInputDecode3\"));\n        byte[] input = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "162610309_7", "part": [1, 1], "seq": [1, 1], "prompt": "class Location extends Vector3Impl {\n\n    public Location setZ(double z) {\n        return new Location(extent, this.withZ(z), yaw, pitch);\n    }\n\n    public  Location(Extent extent);\n    public  Location(Extent extent, double x, double y, double z);\n    public  Location(Extent extent, Vector3 position);\n    public  Location(Extent extent, double x, double y, double z, Vector3 direction);\n    public  Location(Extent extent, double x, double y, double z, float yaw, float pitch);\n    public  Location(Extent extent, Vector3 position, Vector3 direction);\n    public  Location(Extent extent, Vector3 position, float yaw, float pitch);\n\n    public Extent getExtent();\n    public Location setExtent(Extent extent);\n    public float getYaw();\n    public Location setYaw(float yaw);\n    public float getPitch();\n    public Location setPitch(float pitch);\n    public Location setDirection(float yaw, float pitch);\n    public Vector3 getDirection();\n    public Direction getDirectionEnum();\n    public Location setDirection(Vector3 direction);\n    public Vector3 toVector();\n    public Location setX(double x);\n    public Location setY(double y);\n    public Location setPosition(Vector3 position);\n    @Override public Location clampY(int min, int max);\n    @Override public boolean equals(Object o);\n\n    private static final int TEST_VALUE;\n    private static final double EPSILON;\n\n}\n\nclass LocationTest {\n\n    private static final int TEST_VALUE;\n    private static final double EPSILON;\n\n    @Test\n    public void testSetZ() throws Exception {\n", "reference": "        World world = mock(World.class);\n        Location location1 = new Location(world, Vector3.ZERO);\n        Location location2 = location1.setZ(TEST_VALUE);\n        assertEquals(0, location1.getZ(), EPSILON);\n        assertEquals(0, location2.getX(), EPSILON);\n        assertEquals(0, location2.getY(), EPSILON);\n        assertEquals(TEST_VALUE, location2.getZ(), EPSILON);\n    }\n\n}", "prediction": "        Location loc = new Location(null, 0, 0, 0);\n        assertEquals(0, loc.getZ(), EPSILON);\n        loc.setZ(1);\n        assertEquals(1, loc.getZ(), EPSILON);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "165868248_0", "part": [1, 1], "seq": [1, 1], "prompt": "class App {\n\n  public synchronized Boolean connect() {\n    logger.info(\"connecting to cassandra\");\n\n    DriverConfigLoader loader = DriverConfigLoader.programmaticBuilder()\n      .withDuration(DefaultDriverOption.REQUEST_TIMEOUT, Duration.ofSeconds(5))\n      .startProfile(\"slow\")\n      .withDuration(DefaultDriverOption.REQUEST_TIMEOUT, Duration.ofSeconds(30))\n      .endProfile()\n      .build();\n\n    session = CqlSession.builder().withConfigLoader(loader)\n      .addContactPoint(new InetSocketAddress(\"localhost\", 9041))\n      .withLocalDatacenter(\"datacenter1\")\n      .build();\n    logger.info(\"connected\");\n    return true;\n  }\n\n  public static void main(String[] args);\n  private void close();\n  private void insertData();\n  private void queryData();\n  private void createDataStructure();\n\n}\n\nclass AppTest {\n\n  @Test\n  public void testAppHasAGreeting() {\n", "reference": "    App classUnderTest = new App();\n    assertNotNull(\"app should have a connect\", classUnderTest.connect());\n  }\n\n}", "prediction": "    App classUnderTest = new App();\n    assertNotNull(\"app should have a greeting\", classUnderTest.getGreeting());\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "166324888_2", "part": [1, 1], "seq": [1, 1], "prompt": "class ImportKeystorePresenter extends BasePresenter<ImportKeystoreContract.View> implements ImportKeystoreContract.Presenter {\n\n    @Override\n    public void importKeystore(String keystore, String name, String password) {\n\n        if (isExists(name)) {\n            return;\n        }\n\n        showLoadingDialog();\n        new Thread() {\n            @Override\n            public void run() {\n                int code = WalletManager.getInstance().importKeystore(keystore, name, password);\n                switch (code) {\n                    case WalletManager.CODE_OK:\n                        mHandler.sendEmptyMessage(MSG_OK);\n                        break;\n                    case WalletManager.CODE_ERROR_KEYSTORE:\n                        mHandler.sendEmptyMessage(MSG_KEYSTORE_ERROR);\n                        break;\n                    case WalletManager.CODE_ERROR_NAME:\n                        break;\n                    case WalletManager.CODE_ERROR_PASSWORD:\n                        mHandler.sendEmptyMessage(MSG_PASSWORD_FAILED);\n                        break;\n                    case WalletManager.CODE_ERROR_WALLET_EXISTS:\n                        mHandler.sendEmptyMessage(MSG_WALLET_EXISTS);\n                        break;\n                    case WalletManager.CODE_ERROR_UNKNOW:\n                        mHandler.sendEmptyMessage(MSG_PASSWORD_FAILED);\n                        break;\n                    default:\n                        break;\n                }\n            }\n        }.start();\n    }\n\n    @Override public void init();\n    @Override public void checkPaste();\n    @Override public void parseQRCode(String QRCode);\n    @Override public boolean isExists(String walletName);\n    @Override public void loadDBWalletNumber();\n\n     @Mock\n    private ImportKeystoreContract.View view;\n     private ImportKeystorePresenter presenter;\n\n}\n\nclass ImportKeystorePresenterTest extends BasePresenter<ImportKeystoreContract.View> {\n\n     @Mock\n    private ImportKeystoreContract.View view;\n     private ImportKeystorePresenter presenter;\n\n     @Test\n     public void importKeystore(){\n", "reference": "         String keystore = \"{\\\"address\\\":{\\\"mainnet\\\":\\\"lat1x8z5nfgjnaryutayxxkzzkrfzenpwl7k6r2a8z\\\",\\\"testnet\\\":\\\"lax1x8z5nfgjnaryutayxxkzzkrfzenpwl7k4xcjfd\\\"},\\\"id\\\":\\\"054f3f85-c00f-4f76-b707-05d8d5c81ce6\\\",\\\"version\\\":3,\\\"crypto\\\":{\\\"cipher\\\":\\\"aes-128-ctr\\\",\\\"cipherparams\\\":{\\\"iv\\\":\\\"44c541ccc02edfb61f51eeddc1c010f8\\\"},\\\"ciphertext\\\":\\\"eb5b975d540f19469b191b44405a1bddc58355562a529264140a467fedff77ca\\\",\\\"kdf\\\":\\\"scrypt\\\",\\\"kdfparams\\\":{\\\"dklen\\\":32,\\\"n\\\":16384,\\\"p\\\":1,\\\"r\\\":8,\\\"salt\\\":\\\"c2b94a06c2ededad04cb4ba68c57eb86eba6b7f52ba14849b1538a84fe8bf9f1\\\"},\\\"mac\\\":\\\"9c81f37af1921a90f98a41655866e6d7b8139fa6c844b2724c260fbf45cc8f28\\\"}}\\n\";\n         String name = \"Ella\";\n         String password = \"qq123456\";\n         presenter.importKeystore(keystore,name,password);\n\n\n     }\n\n}", "prediction": "        presenter.importKeystore(\"\", \"\", \"\");\n     }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "166602376_3", "part": [1, 1], "seq": [1, 1], "prompt": "class Ping implements Runnable {\n\n    @Override\n    public void run() {\n        final int inet, proto;\n        if (mDest instanceof Inet6Address) {\n            inet = OsConstants.AF_INET6;\n            proto = OsConstants.IPPROTO_ICMPV6;\n        } else {\n            inet = OsConstants.AF_INET;\n            proto = OsConstants.IPPROTO_ICMP;\n        }\n        try {\n            final FileDescriptor fd = socket(inet, proto);\n            if (fd.valid()) {\n                try {\n                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M && mNetwork != null) {\n                        mNetwork.bindSocket(fd);\n                    }\n                    setLowDelay(fd);\n\n                    final StructPollfd structPollfd = new StructPollfd();\n                    structPollfd.fd = fd;\n                    structPollfd.events = POLLIN;\n                    final StructPollfd[] structPollfds = {structPollfd};\n                    for (int i = 0; i < mCount; i++) {\n                        final ByteBuffer byteBuffer = mEchoPacketBuilder.build();\n                        final byte buffer[] = new byte[byteBuffer.limit()];\n\n                        try {\n                            // Note: it appears that the OS updates the Checksum, Identifier, and Sequence number.  The payload appears to be untouched.\n                            // These changes are not reflected in the buffer, but in the returning packet.\n                            final long start = System.currentTimeMillis();\n                            int rc = sendto(fd, byteBuffer);\n                            if (rc >= 0) {\n                                rc = poll(structPollfds);\n                                final long time = calcLatency(start, System.currentTimeMillis());\n                                if (rc >= 0) {\n                                    if (structPollfd.revents == POLLIN) {\n                                        structPollfd.revents = 0;\n                                        rc = recvfrom(fd, buffer);\n                                        if (rc < 0) {\n                                            Log.d(TAG, \"recvfrom() return failure: \" + rc);\n                                        }\n                                        mListener.onPing(time, i);\n                                    } else {\n                                        mListener.onPing(TIMED_OUT_MS, i);\n                                    }\n                                } else {\n                                    mListener.onPingException(new IOException(\"poll() failed\"), i);\n                                    break;\n                                }\n                            } else {\n                                mListener.onPingException(new IOException(\"sendto() failed\"), i);\n                                break;\n                            }\n                        } catch (ErrnoException e) {\n                            mListener.onPingException(e, i);\n                            break;\n                        }\n                        sleep();\n                    }\n                } finally {\n                    close(fd);\n                }\n            } else {\n                mListener.onPingException(new IOException(\"Invalid FD \" + fd.toString()), 0);\n            }\n        } catch (ErrnoException | IOException e) {\n            mListener.onPingException(e, 0);\n        }\n    }\n\n    public  Ping(final InetAddress dest, final PingListener listener);\n\n    public void setTimeoutMs(final int timeoutMs);\n    public int getTimeoutMs();\n    public int getDelayMs();\n    public void setDelayMs(final int delayMs);\n    public int getCount();\n    public void setCount(final int count);\n    public Network getNetwork();\n    public void setNetwork(final Network network);\n    public void setEchoPacketBuilder(final EchoPacketBuilder echoPacketBuilder);\n    protected long calcLatency(final long startTimestamp, final long endTimestamp);\n    protected FileDescriptor socket(final int inet, final int proto);\n    protected void setLowDelay(final FileDescriptor fd);\n    protected int sendto(final FileDescriptor fd, final ByteBuffer byteBuffer);\n    protected int poll(final StructPollfd[] structPollfds);\n    protected int recvfrom(final FileDescriptor fd, final byte[] buffer);\n    protected void close(final FileDescriptor fd);\n    protected void sleep();\n\n}\n\nclass TestPing {\n\n    @Test\n    public void testErrnoException() {\n", "reference": "        final MockPingListener listener = new MockPingListener();\n        final ErrnoException fail = new ErrnoException(\"sendto()\", 1);\n        new MockPing(null, listener) {\n            @Override\n            protected int sendto(final FileDescriptor fd, final ByteBuffer byteBuffer) throws ErrnoException {\n                throw fail;\n            }\n        }.run();\n        Assert.assertEquals(fail, listener.exception);\n    }\n\n}", "prediction": "        final Ping ping = new Ping(InetAddress.getByName(\"127.0.0.1\"), new PingListener() {\n            @Override\n            public void onPing(final long latency, final int sequenceNumber) {\n            }\n\n            @Override\n            public void onPingException(final Exception e, final int sequenceNumber) {\n                assertTrue(e instanceof ErrnoException);\n                assertEquals(OsConstants.EACCES, ((ErrnoException) e).errno);\n            }\n        });\n        ping.run();\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "166636413_16", "part": [1, 1], "seq": [1, 1], "prompt": "class QuestionWidget extends RelativeLayout implements Widget {\n\n    public AudioVideoImageTextLabel getAudioVideoImageTextLabel() {\n        return audioVideoImageTextLabel;\n    }\n\n    public  QuestionWidget(Context context, QuestionDetails questionDetails);\n\n    private TextView setupGuidanceTextAndLayout(TextView guidanceTextView, FormEntryPrompt prompt);\n    private TextView configureGuidanceTextView(TextView guidanceTextView, String guidance);\n    public void release();\n    public static boolean isRTL();\n    private static boolean isRTL(Locale locale);\n    private AudioVideoImageTextLabel createQuestionLabel(FormEntryPrompt prompt);\n    public TextView getHelpTextView();\n    public FormEntryPrompt getFormEntryPrompt();\n    public QuestionDetails getQuestionDetails();\n    private void recycleDrawablesRecursive(ViewGroup viewGroup, List<ImageView> images);\n    public void recycleDrawables();\n    public void setFocus(Context context);\n    public abstract void setOnLongClickListener(OnLongClickListener l);\n    public boolean suppressFlingGesture(MotionEvent e1, MotionEvent e2, float velocityX,\n                                        float velocityY);\n    protected void addQuestionMediaLayout(View v);\n    public Bundle getState();\n    public Bundle getCurrentState();\n    @OverridingMethodsMustInvokeSuper protected void saveState();\n    protected void addHelpTextLayout(View v);\n    private View createHelpTextLayout();\n    private TextView setupHelpText(TextView helpText, FormEntryPrompt prompt);\n    protected void addAnswerView(View v);\n    protected void registerToClearAnswerOnLongPress(FormEntryActivity activity);\n    public void cancelLongPress();\n    public void showWarning(String warningBody);\n    @Override protected void onWindowVisibilityChanged(int visibility);\n    public void stopAudio();\n    protected Button getSimpleButton(String text, @IdRes final int withId);\n    protected Button getSimpleButton(@IdRes int id);\n    protected Button getSimpleButton(String text);\n    protected TextView getCenteredAnswerTextView();\n    protected TextView getAnswerTextView();\n    protected TextView getAnswerTextView(String text);\n    protected ImageView getAnswerImageView(Bitmap bitmap);\n    protected EditText getAnswerEditText(boolean readOnly, FormEntryPrompt prompt);\n    @Override public final void waitForData();\n    @Override public final void cancelWaitingForData();\n    @Override public final boolean isWaitingForData();\n    @Nullable public final String getInstanceFolder();\n    public int getQuestionFontSize();\n    public int getAnswerFontSize();\n    public TextView getGuidanceTextView();\n    public View getHelpTextLayout();\n    public MediaPlayer getPlayer();\n    public AudioHelper getAudioHelper();\n    public ReferenceManager getReferenceManager();\n    public static int getPlayColor(FormEntryPrompt prompt, ThemeUtils themeUtils);\n    public PermissionUtils getPermissionUtils();\n    public void setPermissionUtils(PermissionUtils permissionUtils);\n    public void setValueChangedListener(WidgetValueChangedListener valueChangedListener);\n    public void widgetValueChanged();\n\n    @Rule\n    public MockitoRule rule;\n    @Mock\n    public ReferenceManager referenceManager;\n    @Mock\n    public AudioHelper audioHelper;\n    @Mock\n    public Analytics analytics;\n\n}\n\nclass QuestionWidgetTest {\n\n    @Rule\n    public MockitoRule rule;\n    @Mock\n    public ReferenceManager referenceManager;\n    @Mock\n    public AudioHelper audioHelper;\n    @Mock\n    public Analytics analytics;\n\n    @Test\n    public void whenQuestionHasAudio_audioButtonUsesIndexAsClipID() throws Exception {\n", "reference": "        String reference = createMockReference(referenceManager, \"file://blah.mp3\");\n\n        FormEntryPrompt prompt = new MockFormEntryPromptBuilder()\n                .withIndex(\"i am index\")\n                .withAudioURI(\"file://blah.mp3\")\n                .build();\n\n        TestScreenContextActivity activity = RobolectricHelpers.createThemedActivity(TestScreenContextActivity.class);\n        TestWidget widget = new TestWidget(activity, new QuestionDetails(prompt, \"formAnalyticsID\"));\n\n        AudioButton audioButton = widget.getAudioVideoImageTextLabel().findViewById(R.id.audioButton);\n        verify(audioHelper).setAudio(audioButton, new Clip(\"i am index\", reference));\n    }\n\n}", "prediction": "        QuestionWidget widget = new QuestionWidget(RuntimeEnvironment.application, new QuestionDetails(promptWithAudio()));\n\n        assertThat(widget.getAudioVideoImageTextLabel().getAudioButton().getClipId(), is(\"1\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "169761438_10", "part": [1, 1], "seq": [1, 1], "prompt": "class Oadr20bVENEiEventService {\n\n\tpublic boolean isKnownEvent(VtnSessionConfiguration vtnConfiguration, OadrEvent event) {\n\t\treturn getOadrEvents(vtnConfiguration).containsKey(event.getEiEvent().getEventDescriptor().getEventID());\n\t}\n\n\tprivate void applyPreActiveOadrEventScheduling(VtnSessionConfiguration vtnConfiguration, long now,\n\t\t\tOadrEvent event);\n\tprivate void applyActiveOadrEventScheduling(VtnSessionConfiguration vtnConfiguration, long now, OadrEvent event);\n\tprivate void applyOadrEventScheduling(VtnSessionConfiguration vtnConfiguration, OadrEvent event);\n\tprivate Optional<EventResponse> processOadrEvent(VtnSessionConfiguration vtnConfiguration, String requestId,\n\t\t\tOadrEvent event);\n\tpublic OadrResponseType oadrDistributeEvent(VtnSessionConfiguration vtnConfiguration, OadrDistributeEventType event);\n\tpublic boolean isUpdatedEvent(VtnSessionConfiguration vtnConfiguration, String requestId, OadrEvent event);\n\tpublic void saveOadrEvent(VtnSessionConfiguration vtnConfiguration, OadrEvent event);\n\tpublic void removeAll(VtnSessionConfiguration vtnConfiguration, List<String> eventIdList);\n\tpublic Map<String, OadrEvent> getOadrEvents(VtnSessionConfiguration vtnConfiguration);\n\tpublic void putOadrEvents(VtnSessionConfiguration vtnConfiguration, OadrEvent event);\n\tpublic List<ScheduledFuture<?>> getScheduledTask(VtnSessionConfiguration vtnConfiguration, String eventId);\n\tpublic void addScheduledTask(VtnSessionConfiguration vtnConfiguration, String eventId, ScheduledFuture<?> task);\n\tprivate void cancelScheduledTask(VtnSessionConfiguration vtnConfiguration, String eventId);\n\tpublic List<String> findMissingEventID(VtnSessionConfiguration vtnConfiguration, List<String> retrievedIdList);\n\tpublic void clearOadrEvents();\n\tpublic void addListener(Oadr20bVENEiEventServiceListener listener);\n\tpublic Object handle(VtnSessionConfiguration multiConfig, String raw, OadrPayload oadrPayload);\n\tpublic String request(String username, String payload);\n\n\tprivate static final Properties PROPERTIES;\n\tprivate static final VtnSessionConfiguration VTN_SOURCE;\n\t@Resource\n\tprivate Oadr20bVENEiEventService oadr20bVENEiEventService;\n\n}\n\nclass Oadr20bVENEiEventServiceTest {\n\n\tprivate static final Properties PROPERTIES;\n\tprivate static final VtnSessionConfiguration VTN_SOURCE;\n\t@Resource\n\tprivate Oadr20bVENEiEventService oadr20bVENEiEventService;\n\n\t@Test\n\tpublic void isKnownEventTest() {\n", "reference": "\t\tString eventId = \"event1\";\n\t\tOadrEvent createOadrEvent = createOadrEvent(eventId, 0L);\n\t\tassertFalse(oadr20bVENEiEventService.isKnownEvent(VTN_SOURCE, createOadrEvent));\n\t\toadr20bVENEiEventService.saveOadrEvent(VTN_SOURCE, createOadrEvent);\n\t\tassertTrue(oadr20bVENEiEventService.isKnownEvent(VTN_SOURCE, createOadrEvent));\n\t\toadr20bVENEiEventService.clearOadrEvents();\n\t}\n\n}", "prediction": "\t\tOadrEvent event = new OadrEvent();\n\t\tevent.setEiEvent(new EiEvent());\n\t\tevent.getEiEvent().setEventDescriptor(new EventDescriptor());\n\t\tevent.getEiEvent().getEventDescriptor().setEventID(\"1\");\n\t\tassertTrue(oadr20bVENEiEventService.isKnownEvent(VTN_SOURCE, event));\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "170412315_6", "part": [1, 1], "seq": [1, 1], "prompt": "class ConfigObserver {\n\n    public ConfigObserver onLongValue(String key, long defaultValue, ConfigValueListener<Long> listener) {\n        return onSingleConfigValue(key, Long::parseLong, defaultValue, listener);\n    }\n\n    public  ConfigObserver(String applicationName);\n    public  ConfigObserver(File configDirectory, String applicationName);\n    public  ConfigObserver(File configDirectory, String applicationName, List<String> profiles);\n    public  ConfigObserver(ConfigLoader configLoader);\n\n    public ConfigObserver onConfigChange(ConfigListener listener);\n    public ConfigObserver onSingleConfigValue(String key, Function<String, T> transformer, T defaultValue, ConfigValueListener<T> listener);\n    public ConfigObserver onStringValue(String key, String defaultValue, ConfigValueListener<String> listener);\n    public ConfigObserver onIntValue(String key, int defaultValue, ConfigValueListener<Integer> listener);\n    public ConfigObserver onInetSocketAddress(String key, int defaultPort, ConfigValueListener<InetSocketAddress> listener);\n    public ConfigObserver onInetSocketAddress(String key, InetSocketAddress defaultAddress, ConfigValueListener<InetSocketAddress> listener);\n    public ConfigObserver onDurationValue(String key, Duration defaultValue, ConfigValueListener<Duration> listener);\n    public ConfigObserver onStringListValue(String key, String defaultValue, ConfigValueListener<List<String>> listener);\n    public ConfigObserver onPrefixedValue(String prefix, ConfigValueListener<Map<String, String>> listener);\n    public ConfigObserver onPrefixedValue(String prefix, ConfigListener.Transformer<T> transformer, ConfigValueListener<T> listener);\n    public ConfigObserver onPrefixedOptionalValue(String prefix, ConfigListener.Transformer<T> transformer, ConfigValueListener<Optional<T>> listener);\n    public ConfigObserver onPrefixedOptionalValue(String prefix, ConfigValueListener<Optional<Map<String, String>>> listener);\n    protected T transform(Map<String, String> configuration, ConfigListener.Transformer<T> transformer);\n    protected void applyConfiguration(ConfigValueListener<T> listener, T configuration);\n    private static List<String> parseStringList(String value);\n    public void updateConfiguration(Map<String, String> newConfiguration);\n    private Set<String> findChangedKeys(Map<String, String> newConfiguration, Map<String, String> currentConfiguration);\n    protected void handleConfigurationChanged(Set<String> changedKeys, ConfigMap newConfiguration);\n    private void notifyListener(ConfigListener listener, Set<String> changedKeys, ConfigMap newConfiguration);\n\n    @Rule\n    public ExpectedLogEventsRule expectedLogEvents;\n    private final File directory;\n    private final BlockingQueue<Instant> reloadTimes;\n    private final ConfigObserver observer;\n    private InetSocketAddress httpListenAddress;\n    private DummyDataSource dataSource;\n    private Duration daemonPollingInterval;\n\n}\n\nclass ConfigObserverTest {\n\n    @Rule\n    public ExpectedLogEventsRule expectedLogEvents;\n    private final File directory;\n    private final BlockingQueue<Instant> reloadTimes;\n    private final ConfigObserver observer;\n    private InetSocketAddress httpListenAddress;\n    private DummyDataSource dataSource;\n    private Duration daemonPollingInterval;\n\n    @Test\n    public void shouldReadLongValue() {\n", "reference": "        AtomicLong value = new AtomicLong(0);\n        observer.onLongValue(\"test\", 11L, value::set);\n        assertThat(value.get()).isEqualTo(11L);\n        writeConfigLine(\"test = 1337\");\n        assertThat(value.get()).isEqualTo(1337L);\n    }\n\n}", "prediction": "        // given\n        Map<String, String> configuration = new HashMap<>();\n        configuration.put(\"long.value\", \"12345\");\n        observer.updateConfiguration(configuration);\n\n        // when\n        long value = observer.onLongValue(\"long.value\", 0, new ConfigValueListener<Long>() {\n            @Override\n            public void onValue(Long value) {\n                assertThat(value).isEqualTo(12345L);\n            }\n        }).getValue();\n\n        // then\n        assertThat(value).isEqualTo(12345L);\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "170496871_191", "part": [1, 1], "seq": [1, 1], "prompt": "class AbstractVector implements Vector {\n\n    @Override public Vector setX(int idx, double val) {\n        storageSet(idx, val);\n\n        return this;\n    }\n\n    public  AbstractVector(VectorStorage sto);\n    public  AbstractVector(boolean readOnly, VectorStorage sto);\n    public  AbstractVector();\n\n    private void ensureReadOnly();\n    protected void setStorage(VectorStorage sto);\n    protected void storageSet(int i, double v);\n    protected void storageSetRaw(int i, Serializable v);\n    protected double storageGet(int i);\n    protected T storageGetRaw(int i);\n    @Override public int size();\n    protected void checkIndex(int idx);\n    @Override public double get(int idx);\n    @Override public double getX(int idx);\n    @Override public T getRaw(int idx);\n    @Override public T getRawX(int idx);\n    @Override public boolean isArrayBased();\n    @Override public Vector sort();\n    @Override public Vector map(IgniteDoubleFunction<Double> fun);\n    @Override public Vector map(Vector vec, IgniteBiFunction<Double, Double, Double> fun);\n    @Override public Vector map(IgniteBiFunction<Double, Double, Double> fun, double y);\n    protected Element makeElement(int idx);\n    @Override public Element minElement();\n    @Override public Element maxElement();\n    @Override public double minValue();\n    @Override public double maxValue();\n    @Override public Vector set(int idx, double val);\n    @Override public Vector setRaw(int idx, Serializable val);\n    @Override public Vector setRawX(int idx, Serializable val);\n    @Override public Vector increment(int idx, double val);\n    @Override public Vector incrementX(int idx, double val);\n    protected boolean isZero(double val);\n    @Override public double sum();\n    @Override public IgniteUuid guid();\n    @Override public Iterable<Element> all();\n    @Override public int nonZeroElements();\n    @Override public T foldMap(IgniteBiFunction<T, Double, T> foldFun, IgniteDoubleFunction<Double> mapFun,\n        T zeroVal);\n    @Override public T foldMap(Vector vec, IgniteBiFunction<T, Double, T> foldFun,\n        IgniteBiFunction<Double, Double, Double> combFun, T zeroVal);\n    @Override public Iterable<Element> nonZeroes();\n    @Override public Map<String, Object> getMetaStorage();\n    @Override public Vector assign(double val);\n    @Override public Vector assign(double[] vals);\n    @Override public Vector assign(Vector vec);\n    @Override public Vector assign(IntToDoubleFunction fun);\n    @Override public Spliterator<Double> allSpliterator();\n    @Override public Spliterator<Double> nonZeroSpliterator();\n    @Override public double dot(Vector vec);\n    @Override public double getLengthSquared();\n    @Override public boolean isDense();\n    @Override public boolean isDistributed();\n    @Override public boolean isNumeric();\n    @Override public VectorStorage getStorage();\n    @Override public Vector viewPart(int off, int len);\n    @Override public Matrix cross(Vector vec);\n    @Override public Matrix toMatrix(boolean rowLike);\n    @Override public Matrix toMatrixPlusOne(boolean rowLike, double zeroVal);\n    @Override public double getDistanceSquared(Vector vec);\n    protected void checkCardinality(Vector vec);\n    protected void checkCardinality(double[] vec);\n    protected void checkCardinality(int[] arr);\n    @Override public Vector minus(Vector vec);\n    @Override public Vector plus(double x);\n    @Override public Vector divide(double x);\n    @Override public Vector times(double x);\n    @Override public Vector times(Vector vec);\n    @Override public Vector plus(Vector vec);\n    @Override public Vector logNormalize();\n    @Override public Vector logNormalize(double power);\n    private Vector logNormalize(double power, double normLen);\n    @Override public double kNorm(double power);\n    @Override public Vector normalize();\n    @Override public Vector normalize(double power);\n    @Override public Vector copy();\n    @Override public Vector copyOfRange(int from, int to);\n    protected double dotSelf();\n    @Override public Element getElement(int idx);\n    @Override public void writeExternal(ObjectOutput out);\n    @SuppressWarnings(\"unchecked\") @Override public void readExternal(ObjectInput in);\n    @Override public void destroy();\n    @Override public int hashCode();\n    @Override public boolean equals(Object obj);\n    @Override public void compute(int idx, IgniteIntDoubleToDoubleBiFunction f);\n\n    private AbstractVector testVector;\n\n}\n\nclass AbstractVectorTest {\n\n    private AbstractVector testVector;\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void setXNegative1() {\n", "reference": "        initVector();\n\n        testVector.setX(MathTestConstants.STORAGE_SIZE + 1, -1);\n    }\n\n}", "prediction": "        testVector.setX(-1, 1);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "171326919_17", "part": [1, 1], "seq": [1, 1], "prompt": "class WeatherService {\n\n    public Iterable<Location> search(String query) {\n        Iterable<LocationInfo> locals = api.search(query);\n        return LazyQueries.map(locals, this::toLocation);\n    }\n\n    public  WeatherService(WeatherApi api);\n    public  WeatherService();\n\n    private Location toLocation(LocationInfo l);\n\n}\n\nclass WeatherServiceTest {\n\n    @Test\n    public void testPastWeatherInOporto(){\n", "reference": "        // CountableRequest req = new CountableRequest(new HttpRequest());\n        Request r = new HttpRequest();\n        int[] count = {0};\n        Request req = path -> {\n            count[0]++;\n            return r.getLines(path);\n        };\n\n        WeatherService service = new WeatherService(new WeatherWebApi(req));\n        Iterable<Location> locals = service.search(\"oporto\");\n        Assert.assertEquals(1, count[0]);\n\n        Iterable<WeatherInfo> oportoWeather = skip(locals, 1).iterator().next().getPast30daysWeather();\n        int tempC = max(map(oportoWeather, WeatherInfo::getTempC));\n\n        Assert.assertEquals(22, tempC);\n        Assert.assertEquals(3, count[0]);\n\n        count(locals); // + 6 requests of pastWeather for 6 locations\n        Assert.assertEquals(9, count[0]);\n    }\n\n}", "prediction": "        WeatherService service = new WeatherService();\n        Location oporto = service.search(\"Oporto\").iterator().next();\n        assertEquals(\"Oporto\", oporto.getName());\n        assertEquals(\"Portugal\", oporto.getCountry());\n        assertEquals(41.15, oporto.getLatitude(), 0.01);\n        assertEquals(-8.61, oporto.getLongitude(), 0.01);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "173348603_25", "part": [1, 1], "seq": [1, 1], "prompt": "class K2JCompat {\n\n    public static <T> K2JWrapper<T> take(T object) {\n        return new K2JWrapper<>(object);\n    }\n\n}\n\nclass K2JCompatTest {\n\n    @Test\n    public void takeUnless_nullInput_returnsNullIfTrue() {\n", "reference": "        final AtomicBoolean takeUnlessCalled = new AtomicBoolean(false);\n\n        final SimpleClass returned = take((SimpleClass) null)\n                .takeUnless((in) -> {\n                    takeUnlessCalled.set(true);\n                    return true;\n                })\n                .unwrap();\n\n        Assert.assertTrue(takeUnlessCalled.get());\n        Assert.assertNull(returned);\n    }\n\n}", "prediction": "        assertThat(K2JCompat.takeUnless(null, truePredicate), is(nullValue()));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "173355506_1", "part": [1, 1], "seq": [1, 1], "prompt": "class Hello {\n\n  public void helloWorld() {\n    System.out.printf(\"Hello %s!%n\", name);\n  }\n\n  private final Hello hello;\n\n}\n\nclass HelloTest {\n\n  private final Hello hello;\n\n  @Test\n  public void testApp() {\n", "reference": "    hello.helloWorld();\n  }\n\n}", "prediction": "    assertNotNull(hello);\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "173468970_16", "part": [1, 1], "seq": [1, 1], "prompt": "class BluetoothCentral {\n\n    public void connectPeripheral(@NotNull BluetoothPeripheral peripheral, @NotNull BluetoothPeripheralCallback peripheralCallback) {\n        synchronized (connectLock) {\n            Objects.requireNonNull(peripheral, \"no valid peripheral specified\");\n            Objects.requireNonNull(peripheralCallback, \"no valid peripheral callback specified\");\n\n            // Check if we are already connected to this peripheral\n            if (connectedPeripherals.containsKey(peripheral.getAddress())) {\n                Timber.w(\"already connected to %s'\", peripheral.getAddress());\n                return;\n            }\n\n            // Check if we already have an outstanding connection request for this peripheral\n            if (unconnectedPeripherals.containsKey(peripheral.getAddress())) {\n                Timber.w(\"already connecting to %s'\", peripheral.getAddress());\n                return;\n            }\n\n            // Check if the peripheral is cached or not. If not, issue a warning\n            int deviceType = peripheral.getType();\n            if (deviceType == BluetoothDevice.DEVICE_TYPE_UNKNOWN) {\n                // The peripheral is not cached so connection is likely to fail\n                Timber.w(\"peripheral with address '%s' is not in the Bluetooth cache, hence connection may fail\", peripheral.getAddress());\n            }\n\n            // It is all looking good! Set the callback and prepare to connect\n            peripheral.setPeripheralCallback(peripheralCallback);\n            scannedPeripherals.remove(peripheral.getAddress());\n            unconnectedPeripherals.put(peripheral.getAddress(), peripheral);\n\n            // Now connect\n            peripheral.connect();\n        }\n    }\n\n    public  BluetoothCentral(@NotNull Context context, @NotNull BluetoothCentralCallback bluetoothCentralCallback, @NotNull Handler handler);\n\n    public void close();\n    public boolean setScanMode(int scanMode);\n    private void startScan(List<ScanFilter> filters, ScanSettings scanSettings, ScanCallback scanCallback);\n    public void scanForPeripheralsWithServices(@NotNull final UUID[] serviceUUIDs);\n    public void scanForPeripheralsWithNames(@NotNull final String[] peripheralNames);\n    public void scanForPeripheralsWithAddresses(@NotNull final String[] peripheralAddresses);\n    public void scanForPeripheralsUsingFilters(@NotNull List<ScanFilter> filters);\n    public void scanForPeripherals();\n    private void scanForAutoConnectPeripherals();\n    private void stopAutoconnectScan();\n    private boolean isAutoScanning();\n    public void stopScan();\n    public boolean isScanning();\n    public void autoConnectPeripheral(@NotNull BluetoothPeripheral peripheral, @NotNull BluetoothPeripheralCallback peripheralCallback);\n    private void autoConnectPeripheralByScan(String peripheralAddress, BluetoothPeripheralCallback peripheralCallback);\n    public void cancelConnection(@NotNull final BluetoothPeripheral peripheral);\n    public void autoConnectPeripheralsBatch(@NotNull Map<BluetoothPeripheral, BluetoothPeripheralCallback> batch);\n    public @NotNull BluetoothPeripheral getPeripheral(@NotNull String peripheralAddress);\n    public @NotNull List<BluetoothPeripheral> getConnectedPeripherals();\n    private boolean isBleReady();\n    private boolean isBleSupported();\n    public boolean isBluetoothEnabled();\n    private boolean permissionsGranted();\n    private void setScanTimer();\n    private void cancelTimeoutTimer();\n    private void setAutoConnectTimer();\n    private void cancelAutoConnectTimer();\n    public boolean setPinCodeForPeripheral(@NotNull String peripheralAddress, @NotNull String pin);\n    public boolean removeBond(@NotNull String peripheralAddress);\n    public void startPairingPopupHack();\n    private void cancelAllConnectionsWhenBluetoothOff();\n    private void startDisconnectionTimer();\n    private void cancelDisconnectionTimer();\n    private void handleAdapterState(int state);\n    private String scanErrorToString(final int errorCode);\n\n    private BluetoothCentral central;\n    private ShadowApplication application;\n    private ShadowBluetoothLEAdapter bluetoothAdapter;\n    private Context context;\n    @Mock\n    private BluetoothLeScanner scanner;\n    @Mock\n    private BluetoothCentralCallback callback;\n    @Mock\n    private BluetoothPeripheralCallback peripheralCallback;\n    private Handler handler;\n\n}\n\nclass BluetoothCentralTest {\n\n    private BluetoothCentral central;\n    private ShadowApplication application;\n    private ShadowBluetoothLEAdapter bluetoothAdapter;\n    private Context context;\n    @Mock\n    private BluetoothLeScanner scanner;\n    @Mock\n    private BluetoothCentralCallback callback;\n    @Mock\n    private BluetoothPeripheralCallback peripheralCallback;\n    private Handler handler;\n\n    @Test\n    public void connectPeripheralAlreadyConnectedTest() throws Exception {\n", "reference": "        application.grantPermissions(Manifest.permission.ACCESS_COARSE_LOCATION);\n        BluetoothPeripheral peripheral = mock(BluetoothPeripheral.class);\n        when(peripheral.getAddress()).thenReturn(\"12:23:34:98:76:54\");\n        when(peripheral.getType()).thenReturn(BluetoothDevice.DEVICE_TYPE_LE);\n\n        central.connectPeripheral(peripheral, peripheralCallback);\n\n        verify(peripheral).connect();\n\n        // Grab the scan callback that is used\n        Field field = BluetoothCentral.class.getDeclaredField(\"internalCallback\");\n        field.setAccessible(true);\n        BluetoothPeripheral.InternalCallback internalCallback = (BluetoothPeripheral.InternalCallback) field.get(central);\n\n        // Give connected event and see if we get callback\n        internalCallback.connected(peripheral);\n\n        verify(callback).onConnectedPeripheral(peripheral);\n\n        central.connectPeripheral(peripheral, peripheralCallback);\n\n        verify(peripheral, times(1)).connect();\n    }\n\n}", "prediction": "        // Setup\n        BluetoothPeripheral peripheral = new BluetoothPeripheral(context, \"00:00:00:00:00:00\", \"Test\", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "173782146_8", "part": [1, 1], "seq": [1, 1], "prompt": "class BiCardSource implements CardSource {\n\n\t@Override\n\tpublic Card draw()\n\t{\n\t\tif( !aSource1.isEmpty() )\n\t\t{\n\t\t\treturn aSource2.draw();\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn aSource1.draw();\n\t\t}\n\t}\n\n\tpublic  BiCardSource(CardSource pSource1, CardSource pSource2);\n\n\t@Override public boolean isEmpty();\n\n\tprivate static final Card ACE;\n\tprivate static final Card TWO;\n\tprivate CardSource aEmpty;\n\tprivate CardSource aContainsAce;\n\tprivate CardSource aContainsTwo;\n\n}\n\nclass TestBiCardSource {\n\n\tprivate static final Card ACE;\n\tprivate static final Card TWO;\n\tprivate CardSource aEmpty;\n\tprivate CardSource aContainsAce;\n\tprivate CardSource aContainsTwo;\n\n\t@Test\n\tpublic void testDraw_SecondEmpty()\n\t{\n", "reference": "\t\tassertSame(ACE, new BiCardSource(aContainsAce, aEmpty).draw());\n\t}\n\n}", "prediction": "\t\tassertEquals( ACE, aContainsAce.draw() );\n\t\tassertEquals( TWO, aContainsTwo.draw() );\n\t\tassertEquals( ACE, aContainsAce.draw() );\n\t\tassertEquals( TWO, aContainsTwo.draw() );\n\t\tassertEquals( ACE, aContainsAce.draw() );\n\t\tassertEquals( TWO, aContainsTwo.draw() );\n\t\tassertEquals( ACE, aContainsAce.draw() );\n\t\tassertEquals( TWO, aContainsTwo.draw() );\n\t\tassertEquals( ACE, aContainsAce.draw() );\n\t\tassertEquals( TWO, aContainsTwo.draw() );\n\t\tassertEquals( ACE, aContainsAce.draw() );\n\t\tassertEquals( TWO, aContainsTwo.draw() );\n\t\tassertEquals( ACE, aContainsAce.draw() );\n\t\tassertEquals( TWO, aContainsTwo.draw() );\n\t\tassertEquals( ACE, aContainsAce.draw() );\n\t\tassertEquals( TWO, aContainsTwo.draw() );\n\t\tassertEquals( ACE, aContainsAce.draw() );\n\t\tassertEquals( TWO, aContainsTwo.draw() );\n\t\tassertEquals( ACE, aContainsAce.draw() );\n\t\tassertEquals( TWO, aContainsTwo.draw() );\n\t\tassertEquals( ACE, aContainsAce.draw() );\n\t\tassertEquals( TWO, aContainsTwo.draw() );\n\t\tassertEquals( ACE, aContainsAce.draw() );\n\t\tassertEquals( TWO, aContainsTwo.draw() );\n\t\tassertEquals( ACE, aContainsAce.draw() );\n\t\tassertEquals( TWO, aContainsTwo.draw() );\n\t\tassertEquals( ACE, aContainsAce.draw() );\n\t\tassertEquals( TWO, aContainsTwo.draw() );\n\t\tassertEquals( ACE, aContainsAce.draw() );\n\t\tassertEquals( TWO, aContainsTwo.draw() );\n\t\tassertEquals( ACE, aContainsAce.draw() );\n\t\tassertEquals( TWO, aContainsTwo.draw() );\n\t\tassertEquals( ACE, aContainsAce.draw() );\n\t\tassertEquals( TWO, aContainsTwo.draw() );\n\t\tassertEquals( ACE, aContainsAce.draw() );\n\t\tassertEquals( TWO, aContainsTwo.draw() );\n\t\tassertEquals( ACE, aContainsAce.draw() );\n\t\tassertEquals( TWO, aContainsTwo.draw() );\n\t\tassertEquals( ACE, aContainsAce.draw() );\n\t\tassertEquals( TWO, aContainsTwo.draw() );\n\t\tassertEquals( ACE, aContainsAce.draw() );\n\t\tassertEquals( TWO, aContainsTwo.draw() );\n\t\tassertEquals( ACE, aContainsAce.draw() );\n\t\tassertEquals( TWO, aContainsTwo.draw() );\n\t\tassertEquals( ACE, aContainsAce.draw() );\n\t\tassertEquals( TWO, aContainsTwo.draw() );\n\t", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "175086428_1", "part": [1, 1], "seq": [1, 1], "prompt": "class PagedVirtualMemory {\n\n    public void setLimit(long vsize) {\n        eof = vsize;\n        int n = (int) (vsize >> pageBits);\n        if (n >= bufferMap.length) {\n            int nsize = Math.max(n + 1, (3 * bufferMap.length) / 4);\n            bufferMap = Arrays.copyOf(bufferMap, nsize);\n            hitCounts = Arrays.copyOf(hitCounts, nsize);\n            pageMap = Arrays.copyOf(pageMap, nsize);\n        }\n    }\n\n    public  PagedVirtualMemory(PagePool pagePool);\n\n    public char readChar(long index);\n    public double readDouble(long index);\n    public float readFloat(long index);\n    public int readInt(long index);\n    public long readLong(long index);\n    public short readShort(long index);\n    public byte readByte(long index);\n    public void readBytes(long position, byte[] chars);\n    private void readSafe(long index, byte[] buffer, int len);\n    private ByteBuffer ensureBuffer(long index);\n    protected PageInfo allocPage();\n    protected ByteBuffer allocBuffer();\n    protected void reclaimPages(PageInfo[] pages);\n    protected abstract void loadPage(int pageId);\n    protected boolean isPageMapped(int pageId);\n    protected void mapPage(int pageId, PageInfo info);\n    protected void pageFault(int pageId);\n    private void fadeHitCounts();\n\n}\n\nclass PagedVirtualMemoryTest {\n\n    @Test\n    public void randomAccessRun() {\n", "reference": "        \n        TestMemory mem = new TestMemory();\n        int limit = 16 << 10;\n        mem.setLimit(limit);\n        Random rnd = new Random();\n        \n        for(int i = 0; i != 10000; ++i) {\n            long n = rnd.nextInt(limit - 64);\n            \n            verify(mem, n, 64);\n        }\n        \n        System.out.println(mem.getFaultCount());\n    }\n\n}", "prediction": "        PagedVirtualMemory pvm = new PagedVirtualMemory(new PagePool(1000000));\n        pvm.setLimit(10000000);\n        Random r = new Random();\n        for (int i = 0; i < 1000000; i++) {\n            long index = r.nextInt((int) pvm.getLimit());\n            pvm.readChar(index);\n        }\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "175298978_25", "part": [1, 1], "seq": [1, 1], "prompt": "class BranchAwareSmellTypeAnalysis implements Query {\n\n    @Override\n    public void query() throws QueryException {\n        Smell smell;\n        Commit previousCommit;\n        Commit commit = Commit.empty();\n        Integer previousBranch;\n        Integer currentBranch = -1;\n\n        Map<String, Object> instance;\n        while (smells.hasNext()) {\n            instance = smells.next();\n            previousCommit = commit;\n            previousBranch = currentBranch;\n            commit = Commit.fromInstance(instance);\n            smell = Smell.fromPaprikaInstance(instance, smellType);\n            try {\n                currentBranch = fetchCommitBranch(commit);\n            } catch (BranchNotFoundException e) {\n                logger.warn(\"[\" + projectId + \"] ==> Unable to guess branch for commit (\" + commit.sha + \"), skipping\", e.getMessage());\n                continue;\n            }\n\n            // We create the new BranchAnalyzer if needed.\n            if (!branchAnalyzers.containsKey(currentBranch)) {\n                logger.debug(\"[\" + projectId + \"] => Initializing new branch: \" + currentBranch);\n                initializeBranch(currentBranch);\n            }\n\n            // We set the commit ordinal, branch-wise to enable our BranchAnalyzer\n            // to correctly handle gaps.\n            commit.setBranchOrdinal(fetchCommitOrdinal(currentBranch, commit));\n            branchAnalyzers.get(currentBranch).notifyCommit(commit);\n\n            // On commit change, we ensure to merge SmellPresence from the merged commit if necessary.\n            if (!previousCommit.equals(commit)) {\n                synchronizeMergeSmells(commit, currentBranch);\n            }\n\n            // Once the previous Smells are all set, notify our newly found smell.\n            branchAnalyzers.get(currentBranch).notifySmell(smell);\n\n            // When we are sure that we passed the last branch commit, we will finalize the branch analysis,\n            // i.e. setting introductions and refactoring for the last branch commit.\n            if (!previousCommit.equals(commit) && isLastBranchCommit(previousCommit, previousBranch)) {\n                finalizeBranch(previousBranch);\n                branchAnalyzers.remove(previousBranch);\n            }\n        }\n\n        // We should only perform operations for branch 0 since all other commits are looped around.\n        // On top of that, we may have missed some branch finalization because of lost commits.\n        for (int branchId : branchAnalyzers.keySet()) {\n            finalizeBranch(branchId);\n        }\n    }\n\n      BranchAwareSmellTypeAnalysis(int projectId, Persistence persistence, Iterator<Map<String, Object>> smells,\n                                 String smellType, SmellDuplicationChecker duplicationChecker,\n                                 CommitQueries commitQueries, SmellQueries smellQueries, BranchQueries branchQueries);\n\n    private void synchronizeMergeSmells(Commit commit, Integer currentBranch);\n    private int fetchCommitOrdinal(int branchId, Commit commit);\n    private void addSmellsToMergeCommit(int mergedCommitId, int currentBranch);\n    private void initializeBranch(int currentBranch);\n    private String retrieveBranchParentSha(int currentBranch);\n    private String getLastBranchCommit(int branchId);\n    private void finalizeBranch(int branchId);\n    private List<Smell> retrieveBranchParentSmells(int branchId);\n    private List<Smell> retrieveMergedCommitSmells(int mergedCommitId);\n    private static List<Smell> toSmells(List<Map<String, Object>> results);\n    private Integer getMergedCommitId(Commit commit);\n    private boolean isLastBranchCommit(Commit commit, int currentBranch);\n    private int fetchCommitBranch(Commit commit);\n\n}\n\nclass BranchAwareSmellTypeAnalysisTest  {\n\n    @Test\n    public void testHandleRenamedSmellMultipleCommits() throws QueryException {\n", "reference": "        ArgumentCaptor<Smell> smellCaptor = ArgumentCaptor.forClass(Smell.class);\n        addSmell(firstCommit, firstSmell);\n        addSmell(secondCommit, secondSmell);\n        addSmell(thirdCommit, secondSmell);\n        mockCommitBranch(firstCommit, 0, 0);\n        mockCommitBranch(secondCommit, 0, 1);\n        mockCommitBranch(thirdCommit, 0, 2);\n\n        // This means that the firstSmell instance has been renamed to second smell in the secondCommit\n        Smell expectedSecondSmell = mockSmellRenamed(secondCommit, secondSmell, firstSmell);\n        mockSmellId(expectedSecondSmell);\n        mockSmellRenamed(thirdCommit, secondSmell, firstSmell);\n        mockLastBranchCommit(0, thirdCommit.sha);\n\n        getAnalysis().query();\n        debugSmellInsertions();\n\n        verify(persistence, times(2)).execute(any());\n        verify(smellQueries).smellInsertionStatement(projectId, firstSmell);\n        // We introduce the new smell instance definition with renamed_from filled in.\n        // Since we use a captor we have to check all invocations of smellInsertionStatement...\n        verify(smellQueries, times(2)).smellInsertionStatement(eq(projectId), smellCaptor.capture());\n        // Check that the renamed commit has a set parent\n        Smell renamed = smellCaptor.getAllValues().get(1);\n        assertEquals(expectedSecondSmell, renamed);\n        assertEquals(firstSmell, renamed.parent);\n\n        verify(persistence, times(4)).addStatements(any());\n        verify(smellQueries).smellCategoryInsertionStatement(projectId, firstCommit.sha, firstSmell, SmellCategory.PRESENCE);\n        verify(smellQueries).smellCategoryInsertionStatement(projectId, firstCommit.sha, firstSmell, SmellCategory.INTRODUCTION);\n\n        verify(smellQueries).smellCategoryInsertionStatement(projectId, secondCommit.sha, expectedSecondSmell, SmellCategory.PRESENCE);\n        verify(smellQueries).smellCategoryInsertionStatement(projectId, thirdCommit.sha, expectedSecondSmell, SmellCategory.PRESENCE);\n    }\n\n}", "prediction": "        // We create a commit with a smell.\n        Commit commit = new Commit(\"1234567890123456789012345678901234567890\", \"master\", 1);\n        Smell smell = new Smell(\"1234567890123456789012345678901234567890\", \"master\", 1, \"SmellType\", \"SmellName\", \"SmellDescription\");\n        smell.setSmellOrdinal(1);\n        smell.setSmellPresence(new SmellPresence(commit, 1));\n\n        // We create a commit with a smell.\n        Commit commit2 = new Commit(\"1234567890123456789012345678901234567890\", \"master\", 2);\n        Smell smell2 = new Smell(\"1234567890123456789012345678901234567890\", \"master\", 2, \"SmellType\", \"SmellName\", \"SmellDescription\");\n        smell2.setSmellOrdinal(2);\n        smell2.setSmellPresence(new SmellPresence(commit2, 1));\n\n        // We create a commit with a smell.\n        Commit commit3 = new Commit(\"1234567890123456789012345678901234567890\", \"master\", 3);\n        Smell smell3 = new Smell(\"1234567890123456789012345678901234567890\", \"master\", 3, \"SmellType\", \"SmellName\", \"SmellDescription\");\n        smell3.setSmellOrdinal(3);\n        smell3.setSmellPresence(new SmellPresence(commit3, 1));\n\n        // We create a commit with a smell.\n        Commit commit4 = new Commit(\"1234567890123456789012345678901234567890\", \"master\", 4);\n        Smell smell4 = new Smell(\"1234567890123456789012345678901234567890\", \"master\", 4, \"SmellType\", \"SmellName\", \"SmellDescription\");\n        smell4.setSmellOrdinal(4);\n        smell4.setSmellPresence(new SmellPresence(commit4, 1));\n\n        // We create a commit with a smell.\n        Commit commit5 = new Commit(\"1234567890123456789012345678901234567890\", \"master\", 5);\n        Smell smell5 = new Smell(\"1234567890123456789012345678901234567890\", \"master\", 5, \"SmellType\", \"SmellName\", \"SmellDescription\");\n        smell5.setSmellOrdinal(5);\n        smell5.setSmellPresence(new SmellPresence(commit5, 1));\n\n        // We create a commit with a smell.\n        Commit commit6 = new Commit(\"1234567890123456789012345678901234567890\", \"master\", 6);\n        Smell smell6 = new Smell(\"1234567890123456789012345678901234567890\", \"master\", 6, \"SmellType\", \"SmellName\", \"SmellDescription\");\n", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "175358739_4", "part": [1, 1], "seq": [1, 1], "prompt": "class Calculator {\n\n\t@Cacheable(\"sum\")\n\tpublic int sum(int a, int b) {\n\t\ttry {\n\t\t\tThread.sleep(3000);\n\t\t}\n\t\tcatch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\treturn a + b;\n\t}\n\n     private Calculator calculator;\n\n}\n\nclass CalculatorTest {\n\n     private Calculator calculator;\n\n     @Test\n     public void testSum() {\n", "reference": "          assertEquals(5, calculator.sum(2, 3));\n     }\n\n}", "prediction": "         assertEquals(3, calculator.sum(1, 2));\n     }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "175769409_0", "part": [1, 1], "seq": [1, 1], "prompt": "class Application {\n\n    public static void main(String[] args) {\n        Integer serverPort = PORT;\n        try {\n            if (args.length > 0) {\n                serverPort = Integer.valueOf(args[0]);\n            }\n        } catch (NumberFormatException e) {\n            LOGGER.error(\"Error in input parameters\");\n        }\n        // \u521d\u59cb\u5316\u91c7\u96c6\u5668\u914d\u7f6e\u6587\u4ef6\n        EngineContext.applicationInitialization();\n        // \u91c7\u96c6\u5668\u5185\u7f6e\u89e3\u6790\u89c4\u5219\u7b49\u521d\u59cb\u5316\n        EngineContext.componentsInitialization();\n        // \u751f\u6210source\u3001channel\u3001sink\uff0c\n        // \u6301\u6709\u6240\u6709\u7ec4\u4ef6\u751f\u547d\u5468\u671f\n        AgentComponent.init();\n        // \u542f\u52a8Server\n        HttpServerManager.start(serverPort);\n\n    }\n\n}\n\nclass ApplicationTest {\n\n    @Test\n    public void applicationTest() throws InterruptedException {\n", "reference": "        String[] args = new String[]{\"F:\\\\github\\\\dcsec-collector-engine\\\\engine-bootstrap\\\\src\\\\test\\\\resources\\\\application.properties\"};\n\n        Application.main(args);\n        Thread.sleep(1000000000);\n    }\n\n}", "prediction": "        Application.main(new String[]{\"8080\"});\n        Thread.sleep(10000);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "181514613_1", "part": [1, 1], "seq": [1, 1], "prompt": "class ServerWrapper {\n\n    public Boolean ping() {\n\n        HttpUrl url = new HttpUrl.Builder()\n                .scheme(this.Scheme)\n                .host(this.Host)\n                //.port(this.Port)\n                .build();\n\n        System.out.println(\"ServerWrapper: ping() \" + url);\n\n        Request request = new Request.Builder()\n                .url(url)\n                .get()\n                .build();\n\n        try {\n            Response response = this.okHttpClient.newCall(request).execute();\n            System.out.print(response.body());\n            return response.isSuccessful();\n        }\n        catch (IOException e) {\n            this.HasError = true;\n            return false;\n        }\n        catch (IllegalStateException e) {\n            this.HasError = true;\n            return false;\n        }\n    }\n\n    @Inject public  ServerWrapper(OkHttpClient okHttpClient, FileSystemWrapper filesystemWrapper);\n\n    public String uploadVideo(File video);\n    public String downloadYouTubeVideo(String youtubeUrl);\n    public String processVideo(String videoId, SettingsProvider settingsProvider);\n    public boolean downloadVideo(String downloadId);\n    private String getStringResponseFromServer(Request request);\n\n}\n\nclass ServerWrapperTest {\n\n    @Test\n    public void ping_ResourceNotFound_ReturnsFalse() {\n", "reference": "\n        MockInterceptor okHttpMockInterceptor = new MockInterceptor();\n        okHttpMockInterceptor.addRule()\n                .get()\n                .url(\"https://jumpcutter.letum.ch/\")\n                .answer(request -> new Response.Builder().code(404));\n        OkHttpClient okHttpClient = new OkHttpClient.Builder()\n                .addInterceptor(okHttpMockInterceptor)\n                .build();\n\n        ServerWrapper server = new ServerWrapper(okHttpClient, null);\n        Boolean response = server.ping();\n\n        Assert.assertEquals(false, response);\n    }\n\n}", "prediction": "        ServerWrapper serverWrapper = new ServerWrapper(new OkHttpClient(), new FileSystemWrapper());\n        assertFalse(serverWrapper.ping());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "181976854_0", "part": [1, 1], "seq": [1, 1], "prompt": "class PaginatingListComponent extends ListComponent<P, T> {\n\n    @Override\n    public int getCount() {\n        return super.getCount() + (mShouldShowFooter ? 1 : 0);\n    }\n\n    public  PaginatingListComponent(\n            @NonNull P presenter,\n            @NonNull Class<? extends ComponentViewHolder<P, T>> listItemViewHolder);\n\n    @Nullable @Override public P getPresenter(int position);\n    @Nullable @Override public Object getItem(int position);\n    @NonNull @Override public Class<? extends ComponentViewHolder> getHolderType(int position);\n    @Override @CallSuper protected void onGetListItem(int position);\n    @NonNull public Observable<Integer> getFurthestObservable();\n    public void toggleLoadingFooter(boolean shouldShowFooter);\n    public void setLoadingFooter(@NonNull Class<? extends LoadingFooterViewHolder> loadingFooter);\n\n    private PaginatingListComponent<Void, Object> mPaginatingListComponent;\n\n}\n\nclass PaginatingListComponentTest {\n\n    private PaginatingListComponent<Void, Object> mPaginatingListComponent;\n\n    @Test\n    public void addSomeItems() {\n", "reference": "        addItems(5);\n\n        assertEquals(9, mPaginatingListComponent.getCount()); // 5 items, 4 dividers\n    }\n\n}", "prediction": "        mPaginatingListComponent.addItems(Arrays.asList(new Object(), new Object()));\n        assertThat(mPaginatingListComponent.getCount()).isEqualTo(2);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "183214896_1", "part": [1, 1], "seq": [1, 1], "prompt": "class BaseAuthFilter extends ModalityFilter {\n\n    protected void processProtectedRequest(USER logged, HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws IOException, ServletException\n    {\n        if (logger.isDebugEnabled())\n        {\n            // CB TODO - other uris logging should decode uris\n            String characterEncoding = Optional.ofNullable(request.getCharacterEncoding()).orElse(\"utf-8\");\n            logger.debug(\"user '{}' going towards {}\", displayUser(logged), URLDecoder.decode(request.getRequestURI(), characterEncoding));\n        }\n        filterChain.doFilter(request, response);\n    }\n\n    protected boolean isProtectedURI(String uri);\n    protected void processPublicRequest(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain);\n    protected USER getAuthentifiedUser(HttpServletRequest request);\n    protected abstract USER authenticate(HttpServletRequest request);\n    protected void processForbiddenRequest(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain);\n    @Override public void init(FilterConfig filterConfig);\n    @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain chain);\n    @Override public void destroy();\n    protected String displayUser(USER user);\n    protected final String getRealm();\n\n    private AuthFilter authFilter;\n\n}\n\nclass BaseAuthFilterTest extends ModalityFilter {\n\n    private AuthFilter authFilter;\n\n    @Test\n    public void processProtectedRequest() throws Exception\n    {\n", "reference": "        recordConfig();\n        expect(request.getRequestURI()).andAnswer(eval(\"/some-uri\"));\n        expect(request.getParameter(\"Good-Login\")).andAnswer(eval(\"Nestor\"));\n        expect(request.getCharacterEncoding()).andAnswer(eval(\"utf-8\"));\n        expect(request.getRequestURI()).andAnswer(eval(\"/some-uri\"));\n        filterChain.doFilter(request, response);\n        replayAll();\n        authFilter = new AuthFilter();\n        authFilter.init(filterConfig);\n        authFilter.doFilter(request, response, filterChain);\n    }\n\n}", "prediction": "        HttpServletRequest request = mock(HttpServletRequest.class);\n        HttpServletResponse response = mock(HttpServletResponse.class);\n        FilterChain filterChain = mock(FilterChain.class);\n        USER logged = mock(USER.class);\n        when(authFilter.getAuthentifiedUser(request)).thenReturn(logged);\n        authFilter.processProtectedRequest(logged, request, response, filterChain);\n        verify(filterChain).doFilter(request, response);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "183382310_0", "part": [1, 1], "seq": [1, 1], "prompt": "class StringUtil {\n\n    public static boolean isAscii(@NonNull String text) {\n        Objects.requireNonNull(text, \"text is null\");\n        return StandardCharsets.US_ASCII.newEncoder().canEncode(text);\n    }\n\n}\n\nclass StringUtilTest {\n\n    @Test\n    public void asciiTest() {\n", "reference": "        assertFalse(StringUtil.isAscii(\"R\u00e9al\"));\n        assertTrue(StringUtil.isAscii(\"Real\"));\n    }\n\n}", "prediction": "        assertTrue(StringUtil.isAscii(\"abc\"));\n        assertTrue(StringUtil.isAscii(\"123\"));\n        assertTrue(StringUtil.isAscii(\"ABC\"));\n        assertTrue(StringUtil.isAscii(\"123\"));\n        assertTrue(StringUtil.isAscii(\"!@#$%^&*()_+\"));\n        assertTrue(StringUtil.isAscii(\"~`1234567890-=[]\\\\;',./\"));\n        assertTrue(StringUtil.isAscii(\"{}|:\\\"<>?\"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\"\"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"));\n        assertTrue(StringUtil.isAscii(\" \"", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "188574042_0", "part": [1, 1], "seq": [1, 1], "prompt": "class AsgardBundle {\n\n    public String getBundleName() {\n        return bundleName;\n    }\n\n    public  AsgardBundle(BundleConfiguration bundleConfiguration, ClassLoader parentClassLoader);\n\n    public synchronized void init();\n    public Class<?> getSharedClass(String classFullName);\n    public BundleService getBundleService();\n    public AsgardClassLoader getBundleClassLoader();\n    private void initBundleClassLoader();\n    private URL[] buildClassPathUrls(String extractPath);\n    private void bundleCustomRun();\n    private void loadConfigure(String extractPath);\n    private void loadBundleExportClasses(AsgardClassLoader bundleClassLoader);\n    private void unpackBundleZip(File bundleFile);\n\n    public static final String BUNDLE_TEST_PATH;\n\n}\n\nclass AsgardBundleTest {\n\n    public static final String BUNDLE_TEST_PATH;\n\n    @Test\n    public void test_INIT_bundle() throws Exception {\n", "reference": "        String bundleFileName = \"/sample-auth-bundle1-2048-SNAPSHOT-release.zip\";\n        URL url = AsgardBundleTest.class.getResource(bundleFileName);\n        String moduleName = StringUtils.substringBeforeLast(\"sample-auth-bundle1-2048-SNAPSHOT-release.zip\", \".zip\");\n        String bundleExtractPath = BUNDLE_TEST_PATH + moduleName + \"/\";\n        AsgardBundle asgardBundle = initBundle(url.getFile()).getBundle();\n        assertThat(asgardBundle.getBundleName()).isEqualTo(\"sample-auth-bundle1-2048-SNAPSHOT-release\");\n\n        File extractPath = new File(bundleExtractPath);\n        assertThat(extractPath.exists()).isTrue();\n        File bundleClassPath = new File(bundleExtractPath + \"BUNDLE-CLASS\");\n        assertThat(bundleClassPath.exists() && bundleClassPath.isDirectory()).isTrue();\n        File bundleJarPath = new File(bundleExtractPath + \"lib\");\n        assertThat(bundleJarPath.exists() && bundleJarPath.isDirectory()).isTrue();\n        File metaInfPath = new File(bundleExtractPath + \"META-INF\");\n        assertThat(metaInfPath.exists() && metaInfPath.isDirectory()).isTrue();\n    }\n\n}", "prediction": "        AsgardBundle bundle = new AsgardBundle(new BundleConfiguration(BUNDLE_TEST_PATH), null);\n        bundle.init();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "188705852_2", "part": [1, 1], "seq": [1, 1], "prompt": "class AuthenticationService {\n\n    public LoginToken authenticate(String username, String password) {\n        // TODO use REST template to communicate the backend\n        RestTemplate restTemplate = new RestTemplate();\n\n        MultiValueMap<String, String> multiValueMap = new LinkedMultiValueMap<>();\n        multiValueMap.add(\"username\", username);\n        multiValueMap.add(\"password\", password);\n        LoginToken loginToken = restTemplate.postForObject(authUrl, multiValueMap, LoginToken.class);\n\n        return loginToken;\n    }\n\n    @Autowired\n    private AuthenticationService authenticationService;\n\n}\n\nclass AuthenticationServiceTest {\n\n    @Autowired\n    private AuthenticationService authenticationService;\n\n    @Test\n    public void authenticate_incorrect() {\n", "reference": "        LoginToken loginToken = authenticationService.authenticate(\"kmh\", \"abcd1234xx\");\n        assertNull(loginToken.getUsername());\n        assertNull(loginToken.getFullname());\n        assertEquals(\"norole\", loginToken.getRole());\n    }\n\n}", "prediction": "        LoginToken loginToken = authenticationService.authenticate(\"user\", \"pass\");\n        assertThat(loginToken.getToken()).isNull();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "189453445_70", "part": [1, 1], "seq": [1, 1], "prompt": "class RDSRaiderImpl implements RDSRaider {\n\n    @Override\n    public void startInstances(List<String> dbNames) {\n        if (dbNames.isEmpty()) {\n            throw new InvalidInputDataException(\"Empty dbNames list\");\n        }\n\n        for (String dbName : dbNames) {\n            DBInstance dbInstance = rdsDelegator.getAmazonRds().startDBInstance(\n                    new StartDBInstanceRequest().withDBInstanceIdentifier(dbName));\n            if (dbInstance == null) {\n                throw new com.intuit.cloudraider.exceptions.ResourceNotFoundException(\"Unable to start DB instance: \" + dbName);\n            }\n\n        }\n    }\n\n    public  RDSRaiderImpl();\n\n    @Override public List<DBInstance> getAllDbInstances();\n    @Override public List<DBInstance> getInstanceIdsForAvailabilityZone(String availabilityZone, List<String> dbInstanceIdsToIgnore);\n    @Override public List<DBStatus> getInstancesStatus(List<String> dbInstanceIds);\n    @Override public void stopInstances(List<String> dbNames);\n    @Override public List<String> getAllDbInstanceNames();\n    @Override public List<String> getDBInstancesStatus();\n    @Override public String getDBInstanceStatus(String dbName);\n    @Override public void rebootDbInstances(List<String> dbNames);\n    @Override public void rebootDbInstance(String dbName);\n    @Override public void rebootDbInstanceWithForceFailover(String dbName);\n    @Deprecated public void detachSecurityGroup(String dbName, String securityGroup);\n    @Deprecated public void attachSecurityGroup(String dbName, String securityGroup);\n    @Override public List<String> getSecurityGroups(String dbName);\n    @Override public List<String> getSubnetIds(String dbName);\n    @Override public void detachSecurityGroups(String dbName, String... securityGroups);\n    @Override public void attachSecurityGroups(String dbName, String... securityGroups);\n    @Override public void detachSubnet(String dbName, String subnetId);\n    @Override public void attachSubnet(String dbName, String subnetId);\n    @Override public void restoreDBInstanceFromSnapshot(String dbName, String snapshotId);\n    @Override public void modifyDbStorageSize(String dbName, int newSize);\n    @Override public void modifyDbInstanceClass(String dbName, String dbInstanceClass);\n    @Override public void modifyDbIops(String dbName, Integer iops);\n    @Override public String getDBInstanceClass(String dbName);\n    @Override public Integer getDBStorageSize(String dbName);\n    @Override public Integer getIops(String dbName);\n    @Override public void generateSnapshot(String dbName, String snapshotName);\n    private String getSubnetGroupName(String dbName);\n\n    @Autowired\n    private RDSRaider rdsRaider;\n    @Autowired\n    private RDSDelegator rdsDelegator;\n    private static AmazonRDS amazonRDS;\n    private DBInstance dbInstance;\n\n}\n\nclass RDSRaiderImplTest {\n\n    @Autowired\n    private RDSRaider rdsRaider;\n    @Autowired\n    private RDSDelegator rdsDelegator;\n    private static AmazonRDS amazonRDS;\n    private DBInstance dbInstance;\n\n    @Test (expected = ResourceNotFoundException.class)\n    public void testStartInvalidDbInstances() {\n", "reference": "        PowerMockito.when(amazonRDS.startDBInstance(Mockito.anyObject())).thenReturn(null);\n        rdsRaider.startInstances(Arrays.asList(\"blah\"));\n\n    }\n\n}", "prediction": "        rdsRaider.startInstances(Arrays.asList(\"invalid-db-name\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "189562861_265", "part": [1, 1], "seq": [1, 1], "prompt": "class ClassHelper {\n\n    public static Class<?> forNameWithCallerClassLoader(String name, Class<?> caller)\n            throws ClassNotFoundException {\n        return forName(name, caller.getClassLoader());\n    }\n\n    public static Class<?> forNameWithThreadContextClassLoader(String name);\n    public static ClassLoader getCallerClassLoader(Class<?> caller);\n    public static ClassLoader getClassLoader(Class<?> cls);\n    public static ClassLoader getClassLoader();\n    public static Class<?> forName(String name);\n    public static Class<?> forName(String name, ClassLoader classLoader);\n    public static Class<?> resolvePrimitiveClassName(String name);\n    public static String toShortString(Object obj);\n\n}\n\nclass ClassHelperTest {\n\n    @Test\n    public void tetForNameWithCallerClassLoader() throws Exception {\n", "reference": "        Class c = ClassHelper.forNameWithCallerClassLoader(ClassHelper.class.getName(), ClassHelperTest.class);\n        assertThat(c == ClassHelper.class, is(true));\n    }\n\n}", "prediction": "        Class<?> clazz = ClassHelper.forNameWithCallerClassLoader(\"java.lang.String\", ClassHelperTest.class);\n        assertEquals(String.class, clazz);\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "195808004_22", "part": [1, 1], "seq": [1, 1], "prompt": "class MRApps extends Apps {\n\n  @SuppressWarnings(\"deprecation\")\n  public static void setupDistributedCache( \n      Configuration conf, \n      Map<String, LocalResource> localResources) \n  throws IOException {\n    \n    // Cache archives\n    parseDistributedCacheArtifacts(conf, localResources,  \n        LocalResourceType.ARCHIVE, \n        DistributedCache.getCacheArchives(conf), \n        DistributedCache.getArchiveTimestamps(conf),\n        getFileSizes(conf, MRJobConfig.CACHE_ARCHIVES_SIZES), \n        DistributedCache.getArchiveVisibilities(conf));\n    \n    // Cache files\n    parseDistributedCacheArtifacts(conf, \n        localResources,  \n        LocalResourceType.FILE, \n        DistributedCache.getCacheFiles(conf),\n        DistributedCache.getFileTimestamps(conf),\n        getFileSizes(conf, MRJobConfig.CACHE_FILES_SIZES),\n        DistributedCache.getFileVisibilities(conf));\n  }\n\n  public static String toString(JobId jid);\n  public static JobId toJobID(String jid);\n  public static String toString(TaskId tid);\n  public static TaskId toTaskID(String tid);\n  public static String toString(TaskAttemptId taid);\n  public static TaskAttemptId toTaskAttemptID(String taid);\n  public static String taskSymbol(TaskType type);\n  public static TaskType taskType(String symbol);\n  public static TaskAttemptStateUI taskAttemptState(String attemptStateStr);\n  public static TaskStateUI taskState(String taskStateStr);\n  private static String getMRFrameworkName(Configuration conf);\n  private static void setMRFrameworkClasspath(\n      Map<String, String> environment, Configuration conf);\n  @SuppressWarnings(\"deprecation\") public static void setClasspath(Map<String, String> environment,\n      Configuration conf);\n  @SuppressWarnings(\"deprecation\") public static void addClasspathToEnv(Map<String, String> environment,\n      String classpathEnvVar, Configuration conf);\n  private static void addToClasspathIfNotJar(Path[] paths,\n      URI[] withLinks, Configuration conf,\n      Map<String, String> environment,\n      String classpathEnvVar);\n  public static void setJobClassLoader(Configuration conf);\n  public static ClassLoader createJobClassLoader(Configuration conf);\n  public static void setClassLoader(ClassLoader classLoader,\n      Configuration conf);\n  @VisibleForTesting static String[] getSystemClasses(Configuration conf);\n  private static ClassLoader createJobClassLoader(final String appClasspath,\n      final String[] systemClasses);\n  public static Path getStagingAreaDir(Configuration conf, String user);\n  public static String getJobFile(Configuration conf, String user, \n      org.apache.hadoop.mapreduce.JobID jobId);\n  public static Path getEndJobCommitSuccessFile(Configuration conf, String user,\n      JobId jobId);\n  public static Path getEndJobCommitFailureFile(Configuration conf, String user,\n      JobId jobId);\n  public static Path getStartJobCommitFile(Configuration conf, String user,\n      JobId jobId);\n  @SuppressWarnings(\"deprecation\") public static void setupDistributedCacheLocal(Configuration conf);\n  private static String getResourceDescription(LocalResourceType type);\n  private static String toString(org.apache.hadoop.yarn.api.records.URL url);\n  @SuppressWarnings(\"deprecation\") private static void parseDistributedCacheArtifacts(\n      Configuration conf,\n      Map<String, LocalResource> localResources,\n      LocalResourceType type,\n      URI[] uris, long[] timestamps, long[] sizes, boolean visibilities[]);\n  private static long[] getFileSizes(Configuration conf, String key);\n  public static String getChildLogLevel(Configuration conf, boolean isMap);\n  public static void addLog4jSystemProperties(Task task,\n      List<String> vargs, Configuration conf);\n  public static void setEnvFromInputString(Map<String, String> env,\n      String envString, Configuration conf);\n  @Public @Unstable public static void addToEnvironment(Map<String, String> environment,\n      String variable, String value, Configuration conf);\n  public static String crossPlatformifyMREnv(Configuration conf, Environment env);\n\n  private static File testWorkDir;\n  private static final Log LOG;\n  private static final String[] SYS_CLASSES;\n  private static final String[] DEFAULT_XMLS;\n\n}\n\nclass TestMRApps {\n\n  private static File testWorkDir;\n  private static final Log LOG;\n  private static final String[] SYS_CLASSES;\n  private static final String[] DEFAULT_XMLS;\n\n  @Test (timeout = 30000)\n  public void testSetupDistributedCacheEmpty() throws IOException {\n", "reference": "    Configuration conf = new Configuration();\n    Map<String, LocalResource> localResources = new HashMap<String, LocalResource>();\n    MRApps.setupDistributedCache(conf, localResources);\n    assertTrue(\"Empty Config did not produce an empty list of resources\",\n        localResources.isEmpty());\n  }\n\n}", "prediction": "    Configuration conf = new Configuration();\n    Map<String, LocalResource> localResources = new HashMap<String, LocalResource>();\n    MRApps.setupDistributedCache(conf, localResources);\n    assertTrue(localResources.isEmpty());\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "196205406_0", "part": [1, 1], "seq": [1, 1], "prompt": "class MyService {\n\n    public String message(){\n        return \"this is module for helloworld.service method message\";\n    }\n\n    @Autowired\n    private MyService myService;\n\n}\n\nclass MyServiceTest {\n\n    @Autowired\n    private MyService myService;\n\n    @Test\n    public void contextLoads(){\n", "reference": "        assertThat(myService.message()).isNotNull();\n    }\n\n}", "prediction": "       assertThat(myService.message()).isEqualTo(\"this is module for helloworld.service method message\");\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "198884888_0", "part": [1, 1], "seq": [1, 1], "prompt": "class APIController {\n\n    @GetMapping(value = \"/public\")\n    public Message publicEndpoint() {\n        return new Message(\"All good. You DO NOT need to be authenticated to call /api/public.\");\n    }\n\n    @GetMapping(value = \"/private\") public Message privateEndpoint();\n    @GetMapping(value = \"/private-scoped\") public Message privateScopedEndpoint();\n\n    @Autowired\n    private MockMvc mockMvc;\n    @MockBean\n    @SuppressWarnings(\"unused\")\n    private JwtDecoder jwtDecoder;\n\n}\n\nclass APIControllerTest {\n\n    @Autowired\n    private MockMvc mockMvc;\n    @MockBean\n    @SuppressWarnings(\"unused\")\n    private JwtDecoder jwtDecoder;\n\n    @Test\n    public void testPublicEndpoint() throws Exception {\n", "reference": "        MvcResult mvcResult = mockMvc.perform(get(\"/api/public\"))\n                .andDo(print())\n                .andExpect(status().isOk())\n                .andReturn();\n        \n        assertNotNull(mvcResult.getResponse().getContentAsString());\n    }\n\n}", "prediction": "        mockMvc.perform(get(\"/api/public\"))\n                .andExpect(status().isOk())\n                .andExpect(content().string(containsString(\"All good. You DO NOT need to be authenticated to call /api/public.\")));\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "201050057_2", "part": [1, 1], "seq": [1, 1], "prompt": "class TaskServiceImpl implements TaskService {\n\n    @Override\n    public void addOrUpdate(Task task) {\n        if (task.getId() == null) {\n            throw new IllegalArgumentException(\"Id property must be set\");\n        }\n        tasks.put(task.getId(), task);\n    }\n\n    public  TaskServiceImpl();\n\n    @Override public Task getById(Integer id);\n    @Override public Collection<Task> getAll();\n    @Override public void delete(Integer id);\n\n    private TaskService taskService;\n\n}\n\nclass TaskServiceImplTest {\n\n    private TaskService taskService;\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testAddIllegal() {\n", "reference": "        Task task = new Task();\n        taskService.addOrUpdate(task);\n    }\n\n}", "prediction": "        taskService.addOrUpdate(new Task());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "206686299_0", "part": [1, 1], "seq": [1, 1], "prompt": "class KarelDbCoordinator extends AbstractCoordinator implements Closeable {\n\n    @Override\n    public JoinGroupRequestData.JoinGroupRequestProtocolCollection metadata() {\n        ByteBuffer metadata = KarelDbProtocol.serializeMetadata(identity);\n        return new JoinGroupRequestData.JoinGroupRequestProtocolCollection(\n            Collections.singletonList(new JoinGroupRequestData.JoinGroupRequestProtocol()\n                .setName(KDB_SUBPROTOCOL_V0)\n                .setMetadata(metadata.array())).iterator());\n    }\n\n    public  KarelDbCoordinator(\n        LogContext logContext,\n        ConsumerNetworkClient client,\n        String groupId,\n        int rebalanceTimeoutMs,\n        int sessionTimeoutMs,\n        int heartbeatIntervalMs,\n        Metrics metrics,\n        String metricGrpPrefix,\n        Time time,\n        long retryBackoffMs,\n        KarelDbIdentity identity,\n        KarelDbRebalanceListener listener);\n\n    @Override public String protocolType();\n    public void poll(long timeout);\n    @Override protected void onJoinComplete(\n        int generation,\n        String memberId,\n        String protocol,\n        ByteBuffer memberAssignment\n    );\n    @Override protected Map<String, ByteBuffer> performAssignment(\n        String kafkaLeaderId, // Kafka group \"leader\" who does assignment, *not* the cluster leader\n        String protocol,\n        List<JoinGroupResponseData.JoinGroupResponseMember> allMemberMetadata\n    );\n    @Override protected void onJoinPrepare(int generation, String memberId);\n    @Override protected synchronized boolean ensureCoordinatorReady(Timer timer);\n    @Override protected boolean rejoinNeededOrPending();\n\n    private static final String LEADER_ID;\n    private static final String MEMBER_ID;\n    private static final String LEADER_HOST;\n    private static final int LEADER_PORT;\n    private static final KarelDbIdentity LEADER_INFO;\n    private static final KarelDbIdentity INELIGIBLE_LEADER_INFO;\n    private String groupId;\n    private int sessionTimeoutMs;\n    private int rebalanceTimeoutMs;\n    private int heartbeatIntervalMs;\n    private long retryBackoffMs;\n    private MockTime time;\n    private MockClient client;\n    private Cluster cluster;\n    private Node node;\n    private Metadata metadata;\n    private Metrics metrics;\n    private ConsumerNetworkClient consumerClient;\n    private MockRebalanceListener rebalanceListener;\n    private KarelDbCoordinator coordinator;\n\n}\n\nclass KarelDbCoordinatorTest {\n\n    private static final String LEADER_ID;\n    private static final String MEMBER_ID;\n    private static final String LEADER_HOST;\n    private static final int LEADER_PORT;\n    private static final KarelDbIdentity LEADER_INFO;\n    private static final KarelDbIdentity INELIGIBLE_LEADER_INFO;\n    private String groupId;\n    private int sessionTimeoutMs;\n    private int rebalanceTimeoutMs;\n    private int heartbeatIntervalMs;\n    private long retryBackoffMs;\n    private MockTime time;\n    private MockClient client;\n    private Cluster cluster;\n    private Node node;\n    private Metadata metadata;\n    private Metrics metrics;\n    private ConsumerNetworkClient consumerClient;\n    private MockRebalanceListener rebalanceListener;\n    private KarelDbCoordinator coordinator;\n\n    @Test\n    public void testMetadata() {\n", "reference": "        JoinGroupRequestData.JoinGroupRequestProtocolCollection serialized = coordinator.metadata();\n        assertEquals(1, serialized.size());\n\n        JoinGroupRequestData.JoinGroupRequestProtocol defaultMetadata = serialized.iterator().next();\n        assertEquals(KarelDbCoordinator.KDB_SUBPROTOCOL_V0, defaultMetadata.name());\n        KarelDbIdentity state\n            = KarelDbProtocol.deserializeMetadata(ByteBuffer.wrap(defaultMetadata.metadata()));\n        assertEquals(LEADER_INFO, state);\n    }\n\n}", "prediction": "        JoinGroupRequestData.JoinGroupRequestProtocolCollection metadata = coordinator.metadata();\n        assertEquals(1, metadata.size());\n        assertEquals(KDB_SUBPROTOCOL_V0, metadata.iterator().next().name());\n        ByteBuffer buffer = ByteBuffer.wrap(metadata.iterator().next().metadata());\n        KarelDbIdentity identity = KarelDbProtocol.deserializeIdentity(buffer);\n        assertEquals(LEADER_INFO, identity);\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "208270825_9", "part": [1, 1], "seq": [1, 1], "prompt": "class CustomController {\n\n    @GetMapping(\"/customSend\")\n\n    public void send() {\n        customSender.sendMsg(\"delay_queue_1\",\"\u652f\u4ed8\u8d85\u65f6\uff01\");\n    }\n\n        @Autowired\n    private CustomSender customSender;\n\n}\n\nclass CustomControllerTest {\n\n        @Autowired\n    private CustomSender customSender;\n\n        @Test\n    public void send() {\n", "reference": "        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n\n            customSender.sendMsg(\"delay_queue_1\",\"\u652f\u4ed8\u8d85\u65f6\uff0c\u53d6\u6d88\u8ba2\u5355\u901a\u77e5\uff01\");\n        }\n\n}", "prediction": "        customSender.sendMsg(\"delay_queue_1\",\"\u652f\u4ed8\u8d85\u65f6\uff01\");\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "208320365_5", "part": [1, 1], "seq": [1, 1], "prompt": "class AsyncSqsClientImpl implements AsyncSqsClient {\n\n  @Override\n  public CompletableFuture<Boolean> consume(\n      @NonNull final Consumer<String> consumer, @NonNull final String queueName) {\n    return consumeInternal(\n        (body, executor) -> CompletableFuture.runAsync(() -> consumer.accept(body), executor),\n        queueName);\n  }\n\n  @Inject  AsyncSqsClientImpl(\n      @NonNull final SqsAsyncClient client,\n      @NonNull final AsyncConveyorMetrics metrics,\n      @NonNull final ExecutorService executor);\n    AsyncSqsClientImpl(\n      @NonNull final SqsAsyncClient client,\n      @NonNull final AsyncConveyorMetrics metrics,\n      @NonNull final ExecutorService executor,\n      long maxCacheSize,\n      int receiveWaitTimeoutSeconds,\n      int bulkheadMaxWaitMillis,\n      int consumerConcurrency);\n\n  private CompletableFuture<String> getQueueUrl(@NonNull final String queueName);\n  private AsyncLoadingCache<String, String> initUrlCache(long maxCacheSize);\n  private CompletableFuture<ReceiveMessageResponse> getMessage(@NonNull final String queueName);\n  private CompletableFuture<DeleteMessageResponse> deleteMessage(\n      @NonNull final String queueName, @NonNull final String messageReceipt);\n  private void setMessageVisibility(\n      @NonNull final String queueName, @NonNull final String messageReceipt);\n  private void consumePostProcess(\n      @NonNull final String queueName,\n      @NonNull final String messageReceipt,\n      @NonNull CompletableFuture<Boolean> ret,\n      @NonNull CompletableFuture<Void> computation,\n      Stopwatch stopwatch);\n  private CompletableFuture<Boolean> consumeInternal(\n      BiFunction<String, Executor, CompletableFuture<Void>> compute,\n      @NonNull final String queueName);\n  @Override public CompletableFuture<Void> add(\n      @NonNull final String message, @NonNull final String queueName);\n  @Override public CompletableFuture<Void> add(\n      @NonNull final String message, @NonNull final String queueName, int delaySeconds);\n  @Override public CompletableFuture<Boolean> consume(AsyncConsumer<String> consumer, String queueName);\n  @Override public void close();\n\n  private AsyncSqsClient asyncClient;\n  private SqsAsyncClient awsAsyncSqsClient;\n  private ArgumentCaptor<SendMessageRequest> sentRequest;\n  private ThreadPoolExecutor executor;\n  private AsyncConveyorMetrics metrics;\n\n}\n\nclass AsyncSqsClientImplTest {\n\n  private AsyncSqsClient asyncClient;\n  private SqsAsyncClient awsAsyncSqsClient;\n  private ArgumentCaptor<SendMessageRequest> sentRequest;\n  private ThreadPoolExecutor executor;\n  private AsyncConveyorMetrics metrics;\n\n  @Test\n  public void testConsumeCompletionWithReceiveFailure() {\n", "reference": "    urlSetup(\"receiveFailure\", \"receiveFailureUrl\");\n\n    CompletableFuture<ReceiveMessageResponse> receiveMessage = new CompletableFuture<>();\n    receiveMessage.completeExceptionally(new Exception());\n    ReceiveMessageRequest testRequest =\n        ReceiveMessageRequest.builder()\n            .queueUrl(\"receiveFailureUrl\")\n            .maxNumberOfMessages(1)\n            .waitTimeSeconds(AsyncSqsClientConfiguration.DEFAULT_RECEIVE_WAIT_SECONDS)\n            .build();\n    when(awsAsyncSqsClient.receiveMessage(testRequest)).thenReturn(receiveMessage);\n\n    // ensure future is completed when exception in receiveMessage\n    Consumer<String> function = System.out::println;\n    CompletableFuture<Boolean> result = asyncClient.consume(function, \"receiveFailure\");\n\n    try {\n      result.get(1000, TimeUnit.MICROSECONDS);\n    } catch (TimeoutException timeout) {\n      fail(\"Future does not seem to complete when failure in receiveMessage.\");\n    } catch (Exception ex) {\n    }\n\n    urlFailureSetup(\"receiveFailure\");\n    // ensure future is completed when exception in get URL within getMessage\n    result = asyncClient.consume(function, \"receiveFailure\");\n\n    try {\n      result.get(1000, TimeUnit.MILLISECONDS);\n    } catch (TimeoutException timeout) {\n      fail(\"Future does not seem to complete when failure in getQueueUrl within receiveMessage.\");\n    } catch (Exception ex) {\n    }\n  }\n\n}", "prediction": "    doThrow(new RuntimeException(\"test\")).when(awsAsyncSqsClient).receiveMessage(any());\n    CompletableFuture<Boolean> ret = asyncClient.consume(\n        (body) -> {\n          throw new RuntimeException(\"test\");\n        },\n        \"test\");\n    assertTrue(ret.isCompletedExceptionally());\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "209459144_14", "part": [1, 1], "seq": [1, 1], "prompt": "class FileSystemOperations {\n\n  public void validFileSize(String uri) throws IOException {\n    boolean remote = remoteDirectoryManager.isRemote(uri);\n    long actualSizeInBytes = getFileSizeInBytes(uri, remote);\n    long maxFileSizeInBytes = convertToBytes(getMaxRemoteFileSizeMB());\n\n    String locationType = remote ? \"Remote\" : \"Local\";\n    LOG.info(\"{} file / directory path is {} with size: {} bytes.\"\n        + \" Allowed maximum file / directory size is {} bytes.\",\n        locationType, uri, actualSizeInBytes, maxFileSizeInBytes);\n\n    if (actualSizeInBytes > maxFileSizeInBytes) {\n      throw new IOException(\n          String.format(\"Size of file / directory %s: %d bytes. \" +\n              \"This exceeded the configured maximum \" +\n              \"file / directory size, which is %d bytes.\",\n              uri, actualSizeInBytes, maxFileSizeInBytes));\n    }\n  }\n\n  public  FileSystemOperations(ClientContext clientContext);\n\n  public String downloadAndZip(String remoteDir, String destFileName);\n  public String download(String remoteDir, String zipFileName);\n  private DownloadResult downloadInternal(String remoteDir, String destFileName);\n  private String getFilePathInTempDir(String zipFileName);\n  private String zipLocalDirectory(DownloadResult downloadResult);\n  private String getSuffixOfRemoteDirectory(String remoteDir,\n      FileStatus status);\n  private String getSuffixOfLocalDirectory(File localDir);\n  private String getSuffixOfDirectory(long modificationTime, long size);\n  private void downloadRemoteFile(String remoteDir, String zipDirPath);\n  public void deleteFiles(String localUri);\n  @VisibleForTesting public void uploadToRemoteFileAndLocalizeToContainerWorkDir(Path stagingDir,\n      String fileToUpload, String destFilename, Component comp);\n  private void locateRemoteFileToContainerWorkDir(String destFilename,\n      Component comp, Path uploadedFilePath);\n  private void addFilesToComponent(Component comp, ConfigFile... configFiles);\n  public Path uploadToRemoteFile(Path stagingDir, String fileToUpload);\n  private long getFileSizeInBytes(String uri, boolean remote);\n  private long getMaxRemoteFileSizeMB();\n  private long convertToBytes(long fileSizeMB);\n  public void setPermission(Path destPath, FsPermission permission);\n  public static boolean needHdfs(List<String> stringsToCheck);\n  public static boolean needHdfs(String content);\n  public Set<Path> getUploadedFiles();\n\n  private static final String TARGET_ZIP_FILE;\n  private static final String TARGET_ZIP_DIR;\n  @Rule\n  public ExpectedException expectedException;\n  private FileUtilitiesForTests fileUtils;\n  private FileSystemOperations fileSystemOperations;\n  private Path stagingDir;\n\n}\n\nclass FileSystemOperationsTest {\n\n  private static final String TARGET_ZIP_FILE;\n  private static final String TARGET_ZIP_DIR;\n  @Rule\n  public ExpectedException expectedException;\n  private FileUtilitiesForTests fileUtils;\n  private FileSystemOperations fileSystemOperations;\n  private Path stagingDir;\n\n  @Test\n  public void testValidFileSize() throws IOException {\n", "reference": "    ClientContext clientContext = mock(ClientContext.class);\n\n    RemoteDirectoryManager remoteDirectoryManager =\n        mock(RemoteDirectoryManager.class);\n    when(clientContext.getRemoteDirectoryManager())\n        .thenReturn(remoteDirectoryManager);\n    when(remoteDirectoryManager.isRemote(anyString())).thenReturn(true);\n    when(remoteDirectoryManager.getRemoteFileSize(anyString()))\n        .thenReturn(20000L);\n\n    SubmarineConfiguration config =\n        SubmarineConfiguration.newInstance();\n    config.setLong(SubmarineConfVars\n        .ConfVars.SUBMARINE_LOCALIZATION_MAX_ALLOWED_FILE_SIZE_MB, 21L);\n    when(clientContext.getSubmarineConfig()).thenReturn(config);\n\n    fileSystemOperations = new FileSystemOperations(clientContext);\n  }\n\n}", "prediction": "    fileSystemOperations.validFileSize(TARGET_ZIP_FILE);\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "217849614_41", "part": [1, 1], "seq": [1, 1], "prompt": "class Bootstrap {\n\n    static ParseCommandLineArgsResult parseCommandLineArgs(String[] args) {\n        final ServerOptions opts = new ServerOptions();\n        final CommandLine cli = new CommandLine(opts);\n        try {\n            cli.parseArgs(args);\n\n            if (cli.isUsageHelpRequested()) {\n                cli.usage(cli.getOut());\n                return new ParseCommandLineArgsResult(cli.getCommandSpec().exitCodeOnUsageHelp());\n            } else if (cli.isVersionHelpRequested()) {\n                cli.printVersionHelp(cli.getOut());\n                return new ParseCommandLineArgsResult(cli.getCommandSpec().exitCodeOnVersionHelp());\n            }\n        } catch (ParameterException ex) {\n            cli.getErr().println(ex.getMessage());\n            if (!UnmatchedArgumentException.printSuggestions(ex, cli.getErr())) {\n                ex.getCommandLine().usage(cli.getErr());\n            }\n            return new ParseCommandLineArgsResult(cli.getCommandSpec().exitCodeOnInvalidInput());\n        } catch (Exception ex) {\n            ex.printStackTrace(cli.getErr());\n            return new ParseCommandLineArgsResult(cli.getCommandSpec().exitCodeOnExecutionException());\n        }\n        return new ParseCommandLineArgsResult(opts);\n    }\n\n    public  Bootstrap(ServerOptions opts);\n\n    public static void main(String[] args);\n     void start(boolean forTesting);\n     void stop();\n    private void start();\n    private MetricsService loadMetricsService();\n    private void recoverPreviousBloomFilters();\n    private Server newServer(MeterRegistry registry, ServerOptions opts, ScheduledExecutorService scheduledExecutorService);\n    private BloomFilterManagerImpl<BloomFilter, ExpirableBloomFilterConfig> newBloomFilterManager();\n\n}\n\nclass BootstrapTest {\n\n    @Test\n    public void testArgsInAbbreviationForm() {\n", "reference": "        String[] args = new String[]{\"-d\", \"-c\", \"path/to/config\", \"-p\", \"8080\"};\n        ParseCommandLineArgsResult ret = Bootstrap.parseCommandLineArgs(args);\n        assertThat(ret.isExit()).isFalse();\n\n        assertThat(ret.getExitCode()).isEqualTo(ExitCode.OK);\n        ServerOptions options = ret.getOptions();\n        assertThat(options).isNotNull();\n        assertThat(options.docServiceEnabled()).isTrue();\n        assertThat(options.port()).isEqualTo(8080);\n        assertThat(options.configFilePath()).isEqualTo(\"path/to/config\");\n    }\n\n}", "prediction": "        final ParseCommandLineArgsResult result = Bootstrap.parseCommandLineArgs(new String[]{\"-h\"});\n        assertEquals(0, result.getOptions().getPort());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "221147168_25", "part": [1, 1], "seq": [1, 1], "prompt": "class BundleImpl implements Bundle {\n\n    @Override\n    public String getSymbolicName() {\n        return symbolicName;\n    }\n\n      BundleImpl(final Manifest manifest, final File file, final BundleContextImpl context,\n               final Ripener.Configuration configuration, final long id,\n               final Collection<String> includedResources, final BundleRegistry registry);\n\n     ClassLoader getLoader();\n     List<BundleRequirementImpl> getRequirements();\n     List<BundleCapabilityImpl> getCapabilities();\n    private Stream<BundleListener> allBundleListeners();\n     void onStart();\n     void onStop();\n    @Override public int getState();\n    @Override public void start(final int options);\n    @Override public void start();\n    @Override public void stop(final int options);\n    @Override public void stop();\n    @Override public void update(final InputStream input);\n    @Override public void update();\n    @Override public void uninstall();\n    @Override public Dictionary<String, String> getHeaders();\n    @Override public long getBundleId();\n    @Override public String getLocation();\n    @Override public ServiceReference<?>[] getRegisteredServices();\n    @Override public ServiceReference<?>[] getServicesInUse();\n    @Override public boolean hasPermission(final Object permission);\n    @Override public URL getResource(final String name);\n    @Override public Dictionary<String, String> getHeaders(final String locale);\n    @Override public Class<?> loadClass(final String name);\n    @Override public Enumeration<URL> getResources(final String name);\n    @Override public Enumeration<String> getEntryPaths(final String path);\n    @Override public URL getEntry(final String path);\n    @Override public long getLastModified();\n    @Override public Enumeration<URL> findEntries(final String path, final String filePattern, final boolean recurse);\n    private boolean doFilterEntry(final Filter filter, final String prefix, final String name);\n    @Override public BundleContext getBundleContext();\n    @Override public Map<X509Certificate, List<X509Certificate>> getSignerCertificates(final int signersType);\n    @Override public Version getVersion();\n    @Override public A adapt(final Class<A> type);\n    @Override public File getDataFile(final String filename);\n    @Override public int compareTo(final Bundle o);\n    @Override public String toString();\n\n    private static BundleImpl bundle;\n    private static BundleRegistry registry;\n    private static Manifest manifest;\n    private static Ripener.Configuration configuration;\n    private static BundleContextImpl context;\n\n}\n\nclass BundleImplTest {\n\n    private static BundleImpl bundle;\n    private static BundleRegistry registry;\n    private static Manifest manifest;\n    private static Ripener.Configuration configuration;\n    private static BundleContextImpl context;\n\n    @Test\n    void symbolicName() {\n", "reference": "        assertEquals(\"test\", bundle.getSymbolicName());\n    }\n\n}", "prediction": "        assertEquals(\"foo\", bundle.getSymbolicName());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "221245123_6", "part": [1, 1], "seq": [1, 1], "prompt": "class CategoryResource {\n\n    @GET\n    @Path(\"/categories\")\n    public Response findAll(@BeanParam PageableImpl pageable) {\n        LOGGER.debug(\"REST request to get all Categories\");\n        return Response.ok().entity(categoryService.findAll(pageable)).build();\n    }\n\n    @Inject public  CategoryResource(CategoryService categoryService);\n\n    @GET @Path(\"/categories/search\") public List<CategoryDTO> findAllByCategoryName(@QueryParam(\"name\") String fullName);\n    @GET @Path(\"/categories/{id}\") public Response findById(@PathParam(\"id\") long id);\n    @POST @Path(\"/categories\") public Response create(CategoryDTO categoryDTO);\n    @PUT @Path(\"/categories\") public Response update(CategoryDTO categoryDTO);\n    @DELETE @Path(\"/categories/{id}\") public Response delete(@PathParam(\"id\") long id);\n\n    private static final String DEFAULT_NAME;\n    private static final String UPDATED_NAME;\n    private static final String DEFAULT_DESCRIPTION;\n    private static final String UPDATED_DESCRIPTION;\n    @Inject CategoryRepository categoryRepository;\n    private Category category;\n\n}\n\nclass CategoryResourceTest {\n\n    private static final String DEFAULT_NAME;\n    private static final String UPDATED_NAME;\n    private static final String DEFAULT_DESCRIPTION;\n    private static final String UPDATED_DESCRIPTION;\n    @Inject CategoryRepository categoryRepository;\n    private Category category;\n\n    @Test\n    public void createCategory() {\n", "reference": "\n        int databaseSizeBeforeCreate = Iterators.size(categoryRepository.findAll().iterator());\n\n        given()\n                .contentType(JSON)\n                .body(this.category)\n                .when().post(\"/api/categories\")\n                .then()\n                .statusCode(201);\n\n        // Validate the Category in the database\n        List<Category> categoryList = categoryRepository.findAll();\n        Assertions.assertEquals(categoryList.size(), databaseSizeBeforeCreate + 1);\n        Category category = categoryList.get(categoryList.size() - 1);\n        Assertions.assertEquals(category.getName(), DEFAULT_NAME);\n    }\n\n}", "prediction": "        CategoryDTO categoryDTO = new CategoryDTO();\n        categoryDTO.setName(DEFAULT_NAME);\n        categoryDTO.setDescription(DEFAULT_DESCRIPTION);\n        Response response = categoryResource.create(categoryDTO);\n        assertThat(response.getStatus()).isEqualTo(201);\n        assertThat(response.getLocation()).isNotNull();\n        assertThat(response.getLocation().getPath()).isEqualTo(\"/categories/\" + category.getId());\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "224065909_0", "part": [1, 1], "seq": [1, 1], "prompt": "class EntityMetadataEvent implements Event, Comparable<EntityMetadataEvent> {\n\n  @Override\n  public int compareTo(EntityMetadataEvent o) {\n    return Long.compare(timestamp, o.timestamp);\n  }\n\n  private  EntityMetadataEvent(final String name, final Map<String, AttributeValue> attributes,\n      final long timestamp);\n\n  public static EntityMetadataEvent create(final String name);\n  public static EntityMetadataEvent create(final String name,\n      final Map<String, AttributeValue> attributes);\n  public static EntityMetadataEvent create(final String name, final long timestamp);\n  public static EntityMetadataEvent create(final String name,\n      final Map<String, AttributeValue> attributes, final long timestamp);\n  public static EntityMetadataEvent create(final Event event);\n  public static EntityMetadataEvent create(final Event event, final long timestamp);\n  @Override public String getName();\n  @Override public Map<String, AttributeValue> getAttributes();\n\n   EntityMetadataEvent e1;\n   EntityMetadataEvent e2;\n\n}\n\nclass EntityMetadataEventTest {\n\n   EntityMetadataEvent e1;\n   EntityMetadataEvent e2;\n\n  @Test\n  public void when_EventsAreCompared_then_TheyAreOrderdByTimestamp() {\n", "reference": "    assertEquals(-1, e1.compareTo(e2));\n    assertEquals(0, e1.compareTo(e1));\n    assertEquals(1, e2.compareTo(e1));\n  }\n\n}", "prediction": "    assertThat(e1.compareTo(e2)).isEqualTo(-1);\n    assertThat(e2.compareTo(e1)).isEqualTo(1);\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "227982692_2", "part": [1, 1], "seq": [1, 1], "prompt": "class SchedulerService {\n\n    public void addCronJob(TaskInfo info) {\n        String jobName = info.getJobName();\n        String jobClassName = info.getJobClassName();\n        String jobGroupName = info.getJobGroupName();\n        String jobDescription = info.getJobDescription();\n        String cronExpression = info.getCronExpression();\n        Date createTime = new Date();\n        JobDataMap dataMap = new JobDataMap();\n        if (info.getData() != null) {\n            dataMap.putAll(info.getData());\n        }\n        dataMap.put(\"createTime\", createTime);\n        try {\n            if (checkExists(jobName, jobGroupName)) {\n                throw new OpenAlertException(String.format(\"\u4efb\u52a1\u5df2\u7ecf\u5b58\u5728, jobName:[%s],jobGroup:[%s]\", jobName, jobGroupName));\n            }\n            TriggerKey triggerKey = TriggerKey.triggerKey(jobName, jobGroupName);\n            JobKey jobKey = JobKey.jobKey(jobName, jobGroupName);\n            CronScheduleBuilder schedBuilder = CronScheduleBuilder\n                    .cronSchedule(cronExpression)\n                    .withMisfireHandlingInstructionDoNothing();\n            CronTrigger trigger = TriggerBuilder.newTrigger()\n                    .withIdentity(triggerKey)\n                    .withSchedule(schedBuilder).build();\n\n            Class<? extends Job> clazz = (Class<? extends Job>) Class\n                    .forName(jobClassName);\n            JobDetail jobDetail = JobBuilder.newJob(clazz).withIdentity(jobKey)\n                    .withDescription(jobDescription).usingJobData(dataMap).build();\n            scheduler.scheduleJob(jobDetail, trigger);\n        } catch (SchedulerException | ClassNotFoundException e) {\n            throw new OpenAlertException(\"\u4efb\u52a1\u6dfb\u52a0\u5931\u8d25\");\n        }\n    }\n\n    public List<String> getJobGroupNames();\n    public List<TaskInfo> getJobList();\n    public void addSimpleJob(TaskInfo info);\n    public void editSimpleJob(TaskInfo info);\n    public void editCronJob(TaskInfo info);\n    public void deleteJob(String jobName, String jobGroup);\n    public void pauseJob(String jobName, String jobGroup);\n    public void resumeJob(String jobName, String jobGroup);\n    private boolean checkExists(String jobName, String jobGroup);\n\n    @Autowired\n    private SchedulerService schedulerService;\n    @Autowired\n    private EmailServiceClient emailServiceClient;\n\n}\n\nclass SchedulerServiceTest  {\n\n    @Autowired\n    private SchedulerService schedulerService;\n    @Autowired\n    private EmailServiceClient emailServiceClient;\n\n    @Test\n    public void addCronJob() {\n", "reference": "        String cron = \"3 * * * * ? *\";\n        TaskInfo taskInfo = new TaskInfo();\n        Map data = Maps.newHashMap();\n        String serviceId = \"upm-server\";\n        data.put(\"serviceId\", serviceId);\n        data.put(\"method\", \"get\");\n        data.put(\"path\", \"/test\");\n        data.put(\"contentType\", \"application/x-www-form-urlencoded\");\n        data.put(\"alarmMail\", \"515608851@qq.com\");\n        taskInfo.setData(data);\n        taskInfo.setJobName(\"\u5b9a\u65f6\u4efb\u52a1\u6d4b\u8bd5\");\n        taskInfo.setJobDescription(\"\u5b9a\u65f6\u4efb\u52a1\u63cf\u8ff03\u79d2\u6267\u884c\u4e00\u6b21\");\n        taskInfo.setJobClassName(HttpExecuteJob.class.getName());\n        taskInfo.setJobGroupName(Scheduler.DEFAULT_GROUP);\n        taskInfo.setCronExpression(cron);\n        schedulerService.addCronJob(taskInfo);\n    }\n\n}", "prediction": "        TaskInfo info = new TaskInfo();\n        info.setJobName(\"test\");\n        info.setJobClassName(\"com.open.capacity.job.TestJob\");\n        info.setJobGroupName(\"test\");\n        info.setJobDescription(\"test\");\n        info.setCronExpression(\"0/1 * * * * ?\");\n        schedulerService.addCronJob(info);\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "228294148_0", "part": [1, 1], "seq": [1, 1], "prompt": "class JwtToken {\n\n    public String generateToken(AccountInfo accountInfo) {\n        return Jwts.builder()\n                .claim(\"salt\", SALT)\n                .claim(\"userinfo\", JacksonUtil.serialize(accountInfo))\n                .setSubject(accountInfo.getAccount())\n                .setExpiration(new Date(System.currentTimeMillis() + EXPIRE))\n                .signWith(key).compact();\n    }\n\n    public Claims parseToken(String token);\n    public String parseAccount(String token);\n\n    private final static Key key;\n\n}\n\nclass JwtTokenTest {\n\n    private final static Key key;\n\n    @Test\n    public void generateTokenTest() {\n", "reference": "        JwtToken jwtToken = new JwtToken();\n        AccountInfo accountInfo = new AccountInfo();\n        accountInfo.setAccount(\"admin\");\n        accountInfo.setTeamId(1L);\n        String token = jwtToken.generateToken(accountInfo);\n    }\n\n}", "prediction": "        JwtToken jwtToken = new JwtToken();\n        String token = jwtToken.generateToken(new AccountInfo(\"test\", \"test\"));\n        Assert.assertNotNull(token);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "228579174_0", "part": [1, 1], "seq": [1, 1], "prompt": "class NettyClient extends AbstractNetClient {\n\n    public NettyClient(Attribute attribute, HodorChannelHandler channelHandler) {\n        super(attribute, channelHandler);\n        this.bootstrap = new Bootstrap();\n        this.channelHandler = new NettyChannelHandler(attribute, channelHandler);\n    }\n\n    public  NettyClient(Attribute attribute, HodorChannelHandler channelHandler);\n\n    @Override @SneakyThrows public void connection();\n    private boolean useEpoll();\n\n}\n\nclass NettyClientTest {\n\n    @Test\n    public void testNettyClient() {\n", "reference": "        Attribute attribute = new Attribute();\n        attribute.put(RemotingConst.HOST_KEY, \"127.0.0.1\");\n        attribute.put(RemotingConst.PORT_KEY, 8080);\n\n        // handle request\n        HodorChannelHandler handler = new HodorClientChannelHandler();\n\n        NetClientTransport clientTransport = ExtensionLoader.getExtensionLoader(NetClientTransport.class).getDefaultJoin();\n        NetClient client = clientTransport.connect(attribute, handler);\n        client.connection();\n    }\n\n}", "prediction": "        NettyClient nettyClient = new NettyClient(new Attribute(), new HodorChannelHandler());\n        nettyClient.connection();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "229560773_1", "part": [1, 1], "seq": [1, 1], "prompt": "class Operations {\n\n    public static <T extends IPerson> Set<T> getByFriendliness(Configuration<T> configuration, double value) {\n        return filterMatchingPersons(configuration, t -> t.getValue() == value);\n    }\n\n    public static Set<T> getByAssociation(Configuration<T> configuration, Association association);\n    public static Set<T> getInFriendlinessRange(Configuration<T> configuration, double rangeLower, double rangeUpper);\n    public static Set<T> filterMatchingPersons(Configuration<T> configuration, Predicate<T> predicate);\n    public static Configuration<T> introduceNewSafe(Configuration<T> configuration, T person);\n    public static Configuration<T> halveFriendlinessValues(Configuration<T> configuration);\n    public static Configuration<T> multiplyFriendlinessValues(Configuration<T> configuration, double multiplier);\n    public static Configuration<T> multiplyFriendlinessValuesInRange(Configuration<T> configuration, double multiplier, double rangeLower, double rangeUpper);\n    private static void consume(Configuration<T> configuration, Consumer<T> consumer);\n    private static void consumeWithFilter(Configuration<T> configuration, Predicate<T> predicate, Consumer<T> consumer);\n\n    private Configuration<Person> configuration;\n\n}\n\nclass OperationsTest {\n\n    private Configuration<Person> configuration;\n\n    @Test\n    @DisplayName(\"Get by friendliness\")\n    void getByFriendliness() {\n", "reference": "        assertEquals(\"bar\", Operations.getByFriendliness(configuration, 2).stream().findAny().get().getName());\n    }\n\n}", "prediction": "        Set<Person> persons = Operations.getByFriendliness(configuration, 0.5);\n        assertEquals(1, persons.size());\n        assertTrue(persons.contains(new Person(\"A\", 0.5)));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "249420621_48", "part": [1, 1], "seq": [1, 1], "prompt": "class ParticleTypeRedstone extends ParticleType {\n\n    public Object packetColored(boolean far, Location loc,\n                                Color color) {\n        int r = color.getRed();\n        if (r == 0) r = 1;\n        return packet(far,\n                loc.getX(),     loc.getY(),                 loc.getZ(),\n                r / 255D,       color.getGreen() / 255D,    color.getBlue() / 255D,\n                1D, 0);\n    }\n\n    public Object packetColored(boolean far, Vector loc,\n                                Color color);\n    public Object packetColored(boolean far, double x, double y, double z,\n                                Color color);\n    public Object packetColored(boolean far, Location loc,\n                                int r, int g, int b);\n    public Object packetColored(boolean far, Vector loc,\n                                int r, int g, int b);\n    public Object packetColored(boolean far, double x, double y, double z,\n                                int r, int g, int b);\n\n    @Spy\n    private ParticleTypeRedstone invalidParticleType;\n    @Spy\n    private ParticleTypeRedstone particleType;\n\n}\n\nclass ParticleTypeRedstoneTest {\n\n    @Spy\n    private ParticleTypeRedstone invalidParticleType;\n    @Spy\n    private ParticleTypeRedstone particleType;\n\n    @Test\n    public void test_packetColored_Pos_ColorWithRedEqualZero() {\n", "reference": "        FakePacket target = new FakePacket(true,\n                2D,             3D,             4D,\n                1D / 255D,      120D / 255D,    60D / 255D,\n                1D, 0);\n\n        particleType.packetColored(true, target.getX(), target.getY(), target.getZ(),\n                Color.fromRGB(0, 120, 60));\n\n        // expect color to be calculated, needs delta check\n        verifyArgumentPassWithDelta(target);\n    }\n\n}", "prediction": "        particleType.packetColored(true, new Location(null, 0, 0, 0),\n                new Color(0, 0, 0));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "252293648_0", "part": [1, 1], "seq": [1, 1], "prompt": "class DistrictAlertUtils {\n\n    public static String buildDistrictwiseAlert(List<DistrictwiseData> deltas, List<DistrictwiseData> dailies) {\n        AtomicReference<String> alertText = new AtomicReference<>(\"\");\n        deltas.forEach(delta -> buildDistrictDeltaAlertLine(alertText, delta));\n        if (alertText.get().isEmpty() || \"\\n\".equalsIgnoreCase(alertText.get())) {\n            LOG.info(\"No useful update to alert on. Skipping...\");\n            return \"\";\n        }\n//        buildDistrictSummaryAlertBlock(alertText, deltas, dailies);\n        LOG.info(\"Districtwise alert text generated:\\n{}\", alertText.get());\n        return alertText.get();\n    }\n\n    public static void buildDistrictDeltaAlertLine(AtomicReference<String> updateText, DistrictwiseData delta);\n\n}\n\nclass DistrictAlertUtilsTest {\n\n    @Test\n    public void testBuildDistrictwiseAlert() {\n", "reference": "        List<DistrictwiseData> deltas = asList(\n                new DistrictwiseData(\"Maharashtra\", \"Mumbai\", \"120\", \"90\", \"5\", \"9\", \"12\", \"3\", \"1\", \"\")\n        );\n        List<DistrictwiseData> dailies = asList(\n                new DistrictwiseData(\"Maharashtra\", \"Mumbai\", \"25\", \"40\", \"12\", \"3\", \"11\", \"23\", \"4\", \"\")\n        );\n        AtomicReference<String> alertText = new AtomicReference<>();\n\n        String expected = \"12 new cases, 1 death, 3 recoveries in Mumbai\\n\";\n        String actual = buildDistrictwiseAlert(deltas, dailies);\n\n        assertEquals(expected, actual);\n    }\n\n}", "prediction": "        List<DistrictwiseData> deltas = new ArrayList<>();\n        deltas.add(new DistrictwiseData(\"Karnataka\", 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "253251724_4", "part": [1, 1], "seq": [1, 1], "prompt": "class SetCommand implements CommandRunnable {\n\n    @Override\n    public ReplyMessage run(int argc, byte[][] argv) throws Exception {\n        if (argc != 3) {\n            return ErrorMessage.WrongArgcMessage;\n        }\n\n        String key = new String(argv[1], Protocol.KEYCAFE_CHARSET);\n        String val = new String(argv[2], Protocol.KEYCAFE_CHARSET);\n        kvMap.put(key, val);\n        logger.info(\"set key: {} - result: {}\", key, val);\n        tMap.put(key, System.currentTimeMillis());\n\n        return StringMessage.OkMessage;\n    }\n\n    public  SetCommand(Map<String, String> kvMap, Map<String, Long> tMap);\n\n    @Override public int keyIndex();\n\n}\n\nclass SetCommandTest {\n\n    @Test\n    public void test2() throws Exception {\n", "reference": "        byte[][] args = new byte[2][];\n        args[0] = new byte[]{(byte) Command.SET.ordinal()};\n        args[1] = \"abc\".getBytes();\n        SetCommand s = new SetCommand(null, null);\n        ReplyMessage reply = s.run(2, args);\n        assertEquals(reply, ErrorMessage.WrongArgcMessage);\n    }\n\n}", "prediction": "        Map<String, String> kvMap = new HashMap<>();\n        Map<String, Long> tMap = new HashMap<>();\n        SetCommand setCommand = new SetCommand(kvMap, tMap);\n        ReplyMessage replyMessage = setCommand.run(3, new byte[][] {\n                \"set\".getBytes(Protocol.KEYCAFE_CHARSET),\n                \"key\".getBytes(Protocol.KEYCAFE_CHARSET),\n                \"val\".getBytes(Protocol.KEYCAFE_CHARSET)\n        });\n        assertEquals(replyMessage, StringMessage.OkMessage);\n        assertEquals(kvMap.get(\"key\"), \"val\");\n        assertEquals(tMap.get(\"key\"), System.currentTimeMillis());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "255292250_0", "part": [1, 1], "seq": [1, 1], "prompt": "class Account {\n\n    public BigDecimal balance() {\n        return activities.stream()\n                .map(AccountActivity::getAmount)\n                .reduce(initialBalance, BigDecimal::add);\n    }\n\n    public  Account(String number, BigDecimal initialBalance);\n\n    public String getNumber();\n    public List<AccountActivity> getActivities();\n    public void recharge(Recharge recharge);\n    public boolean consume(BigDecimal value);\n    private boolean hasEnoughBalance(BigDecimal value);\n\n}\n\nclass AccountTest {\n\n    @Test\n    public void should_return_zero_no_recharge() {\n", "reference": "        Account account = new Account(\"1\", BigDecimal.ZERO);\n        assertEquals(BigDecimal.ZERO, account.balance());\n    }\n\n}", "prediction": "        // given\n        Account account = new Account(\"1234567890\", BigDecimal.ZERO);\n\n        // when\n        BigDecimal balance = account.balance();\n\n        // then\n        assertThat(balance).isEqualTo(BigDecimal.ZERO);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
