{"id": "440622_6", "part": [1, 1], "seq": [1, 1], "prompt": "class EsperStatement implements EsperStatementOperations {\n\n\tpublic <T> List<T> concurrentUnsafeQuery(ParameterizedEsperRowMapper<T> rm) {\n\t\tLOG.info(\"Concurrent unsafe query being executed\");\n\n\t\tif (epStatement.isStopped() || epStatement.isDestroyed()) {\n\t\t\tLOG\n\t\t\t\t\t.error(\"Concurrent unsafe query was attempted when the statement was stopped or destroyed\");\n\t\t\tthrow new EsperStatementInvalidStateException(\n\t\t\t\t\t\"Attempted to execute a concurrent unsafe query when esper statement resource had state of \"\n\t\t\t\t\t\t\t+ epStatement.getState());\n\t\t}\n\n\t\tIterator<EventBean> safeIter = this.epStatement.iterator();\n\n\t\tList<T> objectList = new ArrayList<T>();\n\t\tfor (; safeIter.hasNext();) {\n\t\t\tEventBean event = safeIter.next();\n\t\t\tobjectList.add(rm.mapRow(event));\n\t\t}\n\n\t\tLOG.info(\"Concurrent unsafe query was completed\");\n\t\treturn objectList;\n\t}\n\n\tpublic  EsperStatement(String epl);\n\tpublic  EsperStatement(String id, String epl);\n\n\tpublic String getEPL();\n\tpublic EPStatementState getState();\n\tpublic void start();\n\tpublic void stop();\n\tpublic void destroy();\n\tpublic void doWithNativeEPStatement(NativeEPStatementCallback callback);\n\tpublic void setListeners(Set<UpdateListener> listeners);\n\tpublic Set<UpdateListener> getListeners();\n\tpublic void setSubscriber(Object subscriber);\n\tpublic void addListener(UpdateListener listener);\n\tprivate void refreshEPStatmentListeners();\n\tprivate void addEPStatementListener(UpdateListener listener);\n\t void setEPStatement(EPStatement epStatement);\n\tpublic List<T> concurrentSafeQuery(ParameterizedEsperRowMapper<T> rm);\n\tpublic T concurrentSafeQueryForObject(ParameterizedEsperRowMapper<T> rm);\n\tpublic T concurrentUnsafeQueryForObject(\n\t\t\tParameterizedEsperRowMapper<T> rm);\n\tpublic String getId();\n\t@Override public boolean equals(Object o);\n\t@Override public int hashCode();\n\t@Override public String toString();\n\n    private EsperTemplate template;\n    private EsperStatement statement;\n    private ParameterizedEsperRowMapper<SampleEvent> rowMapper;\n\n}\n\nclass TestEsperStatement {\n\n    private EsperTemplate template;\n    private EsperStatement statement;\n    private ParameterizedEsperRowMapper<SampleEvent> rowMapper;\n\n    @Test\n    public void testConcurrencyUnsafeQuery() throws Exception {\n", "reference": "\n        SampleEvent event = new SampleEvent();\n        template.sendEvent(event);\n\n        List<SampleEvent> events = statement.concurrentUnsafeQuery(this.rowMapper);\n\n        assertEquals(events.size(), 1);\n        assertEquals(events.get(0), event);\n    }\n\n}", "prediction": "        List<SampleEvent> results = statement.concurrentUnsafeQuery(rowMapper);\n        assertEquals(100, results.size());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "466142_72", "part": [1, 1], "seq": [1, 1], "prompt": "class ConnectionPartition implements Serializable {\n\n\tprotected void trackConnectionFinalizer(ConnectionHandle connectionHandle) {\n\t\tif (!this.disableTracking){\n\t\t//\tassert !connectionHandle.getPool().getFinalizableRefs().containsKey(connectionHandle) : \"Already tracking this handle\";\n\t\t\tConnection con = connectionHandle.getInternalConnection();\n\t\t\tif (con != null && con instanceof Proxy && Proxy.getInvocationHandler(con) instanceof MemorizeTransactionProxy){\n\t\t\t\ttry {\n\t\t\t\t\t// if this is a proxy, get the correct target so that when we call close we're actually calling close on the database\n\t\t\t\t\t// handle and not a proxy-based close.\n\t\t\t\t\tcon = (Connection) Proxy.getInvocationHandler(con).invoke(con, ConnectionHandle.class.getMethod(\"getProxyTarget\"), null);\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\tlogger.error(\"Error while attempting to track internal db connection\", t); // should never happen\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinal Connection internalDBConnection = con;\n\t\t\tfinal BoneCP pool = connectionHandle.getPool();\n\t\t\tconnectionHandle.getPool().getFinalizableRefs().put(internalDBConnection, new FinalizableWeakReference<ConnectionHandle>(connectionHandle, connectionHandle.getPool().getFinalizableRefQueue()) {\n\t\t\t\t@SuppressWarnings(\"synthetic-access\")\n\t\t\t\tpublic void finalizeReferent() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tpool.getFinalizableRefs().remove(internalDBConnection);\n\t\t\t\t\t\tif (internalDBConnection != null && !internalDBConnection.isClosed()){ // safety!\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tlogger.warn(\"BoneCP detected an unclosed connection \"+ConnectionPartition.this.poolName + \"and will now attempt to close it for you. \" +\n\t\t\t\t\t\t\t\"You should be closing this connection in your application - enable connectionWatch for additional debugging assistance or set disableConnectionTracking to true to disable this feature entirely.\");\n\t\t\t\t\t\t\tinternalDBConnection.close();\n\t\t\t\t\t\t\tupdateCreatedConnections(-1);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\t\tlogger.error(\"Error while closing off internal db connection\", t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tpublic  ConnectionPartition(BoneCP pool);\n\n\tprotected BlockingQueue<Object> getPoolWatchThreadSignalQueue();\n\tprotected void updateCreatedConnections(int increment);\n\tprotected void addFreeConnection(ConnectionHandle connectionHandle);\n\tprotected BlockingQueue<ConnectionHandle> getFreeConnections();\n\tprotected void setFreeConnections(BlockingQueue<ConnectionHandle> freeConnections);\n\tprotected int getAcquireIncrement();\n\tprotected int getMinConnections();\n\tprotected int getMaxConnections();\n\tprotected int getCreatedConnections();\n\tprotected String getUrl();\n\tprotected String getUsername();\n\tprotected String getPassword();\n\tprotected boolean isUnableToCreateMoreTransactions();\n\tprotected void setUnableToCreateMoreTransactions(boolean unableToCreateMoreTransactions);\n\tprotected int getAvailableConnections();\n\tpublic int getRemainingCapacity();\n\tprotected long getQueryExecuteTimeLimitinNanoSeconds();\n\t@Override public String toString();\n\n\tprivate BoneCP mockPool;\n\tprivate Logger mockLogger;\n\tprivate BoneCPConfig mockConfig;\n\tprivate ConnectionPartition testClass;\n\n}\n\nclass TestConnectionPartition {\n\n\tprivate BoneCP mockPool;\n\tprivate Logger mockLogger;\n\tprivate BoneCPConfig mockConfig;\n\tprivate ConnectionPartition testClass;\n\n\t@Test\n\tpublic void testFinalizerException2() throws SQLException, InterruptedException, SecurityException, NoSuchFieldException, IllegalArgumentException, IllegalAccessException{\n", "reference": "\t\tConnectionHandle mockConnectionHandle = createNiceMock(ConnectionHandle.class); \n\t\texpect(mockConnectionHandle.isInReplayMode()).andReturn(true).anyTimes();\n\t\tConnection mockConnection = createNiceMock(Connection.class);\n\t\tConnection connection = new MemorizeTransactionProxyDummy(null,null).memorizeDummy(mockConnection, mockConnectionHandle);\n\t\texpect(mockConnectionHandle.getInternalConnection()).andReturn(connection).anyTimes();\n\t\tmakeThreadSafe(mockConnectionHandle, true);\n\t\tmakeThreadSafe(mockConnection, true);\n\t\tmockLogger = TestUtils.mockLogger(testClass.getClass());\n\t\t\n\t\treset(mockLogger);\n\t\tmakeThreadSafe(mockLogger, true);\n\t\treset(this.mockPool);\n\t\tMap<Connection, Reference<ConnectionHandle>> refs = new HashMap<Connection, Reference<ConnectionHandle>>();\n\t\texpect(this.mockPool.getFinalizableRefs()).andReturn(refs).anyTimes();\n\t\tFinalizableReferenceQueue finalizableRefQueue = new FinalizableReferenceQueue();\n\t\texpect(this.mockPool.getFinalizableRefQueue()).andReturn(finalizableRefQueue).anyTimes();\n\t\texpect(mockConnectionHandle.getPool()).andReturn(this.mockPool).anyTimes();\n\n\t\treplay(mockConnection, mockConnectionHandle, this.mockPool);\n\n\t\ttestClass.trackConnectionFinalizer(mockConnectionHandle);\n\t\treset(mockConnectionHandle);\n\t\tmockConnectionHandle = null; // prompt GC to kick in\n\t\tfor (int i=0; i < 100; i++){\n\t\t\tSystem.gc();System.gc();System.gc();\n\t\t\tThread.sleep(20);\n\t\t\ttry{\n\t\t\t\tverify(mockConnection);\n\t\t\t\tbreak; // we succeeded\n\t\t\t} catch (Throwable t){\n\t\t\t\tt.printStackTrace();\n\t\t\t\t// do nothing, try again\n\t\t\t\tThread.sleep(20);\n\t\t\t}\n\t\t}\n\t}\n\n}", "prediction": "\t\tConnectionHandle connectionHandle = new ConnectionHandle(mockPool, mockConfig, mockLogger);\n\t\tconnectionHandle.setInternalConnection(mock(Connection.class));\n\t\ttestClass.trackConnectionFinalizer(connectionHandle);\n\t\tconnectionHandle.getPool().getFinalizableRefs().clear();\n\t\tconnectionHandle.getPool().getFinalizableRefQueue().clear();\n\t\tconnectionHandle.getPool().getFinalizableRefs().put(connectionHandle.getInternalConnection(), new FinalizableWeakReference<ConnectionHandle>(connectionHandle, connectionHandle.getPool().getFinalizableRefQueue()) {\n\t\t\t@Override\n\t\t\tpublic void finalizeReferent() {\n\t\t\t\tthrow new RuntimeException(\"Test\");\n\t\t\t}\n\t\t});\n\t\tconnectionHandle.getPool().getFinalizableRefQueue().add(connectionHandle.getInternalConnection());\n\t\tThread.sleep(1000);\n\t\tassertEquals(0, connectionHandle.getPool().getFinalizableRefs().size());\n\t\tassertEquals(0, connectionHandle.getPool().getFinalizableRefQueue().size());\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "486214_0", "part": [1, 1], "seq": [1, 1], "prompt": "class CommonSource extends ReflectiveExpressionSource {\n\n\t@Property\n\tpublic Object emit()\n\t{\n\t\treturn Attribute.ATTR_EMIT;\n\t}\n\n\t@Inject public  CommonSource(Stage stage);\n\n\t@Property public Object skip();\n\t@Method public String urlencode(String in);\n\t@Method(\"urlencode\") public String urlencodeInput(@Instance String in);\n\t@Method public String htmlencode(String in);\n\t@Method(\"htmlencode\") public String htmlencodeInput(@Instance String in);\n\n}\n\nclass CommonSourceTest extends ReflectiveExpressionSource {\n\n\t@Test\n\tpublic void testEmit()\n\t{\n", "reference": "\t\tAssert.assertEquals(Attribute.ATTR_EMIT, execute(\"t:emit\", \"\"));\n\t\tAssert.assertEquals(Attribute.ATTR_EMIT, execute(\"true ? t:emit\", \"\"));\n\t}\n\n}", "prediction": "\t\tassertEquals(Attribute.ATTR_EMIT, source.emit());\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "526150_13", "part": [1, 1], "seq": [1, 1], "prompt": "class WorldFireReader extends AbstractProductReader {\n\n    @Override\n    public TreeNode<File> getProductComponents() {\n        final File inputFile = new File(getInput().toString());\n        final File parent = inputFile.getParentFile();\n        final TreeNode<File> result = new TreeNode<File>(parent.getName());\n        result.setContent(parent);\n\n        final TreeNode<File> productFile = new TreeNode<File>(inputFile.getName());\n        productFile.setContent(inputFile);\n        result.addChild(productFile);\n\n        return result;\n    }\n\n    protected  WorldFireReader(WorldFireReaderPlugIn readerPlugIn);\n\n    @Override protected Product readProductNodesImpl();\n    private void attachGeoCoding(Product product);\n    private MultiLevelImage createFireImage(List<Placemark> fireList, final Product product);\n    private List<Placemark> getFireSpotList(File inputFile, GeoCoding geoCoding);\n     String getProductType(File inputFile);\n    @Override protected void readBandRasterDataImpl(int sourceOffsetX, int sourceOffsetY,\n                                          int sourceWidth, int sourceHeight,\n                                          int sourceStepX, int sourceStepY,\n                                          Band destBand,\n                                          int destOffsetX, int destOffsetY,\n                                          int destWidth, int destHeight,\n                                          ProductData destBuffer, ProgressMonitor pm);\n    @Override public WorldFireReaderPlugIn getReaderPlugIn();\n    private static Placemark parseLine(String text, int index, GeoCoding geoCoding);\n\n    private WorldFireReader reader;\n\n}\n\nclass WorldFireReaderTest {\n\n    private WorldFireReader reader;\n\n    @Test\n    public void testReader() throws IOException {\n", "reference": "        final File file = TestResourceHelper.getAatsrAlgo1AsFile();\n        reader.readProductNodes(file, null);\n        assertNotNull(reader.getInput());\n        assertNull(reader.getSubsetDef());\n        assertSame(file, reader.getInput());\n        final TreeNode<File> productComponents = reader.getProductComponents();\n        assertNotNull(productComponents);\n        assertEquals(1, productComponents.getChildren().length);\n    }\n\n}", "prediction": "        final File input = new File(\"src/test/resources/worldfire/worldfire.kml\");\n        final Product product = reader.readProduct(input);\n        assertNotNull(product);\n        assertEquals(\"WorldFire\", product.getName());\n        assertEquals(\"WorldFire\", product.getProductType());\n        assertEquals(new Date(1298112000000L), product.getAcquisitionDate());\n        assertEquals(new Date(1298112000000L), product.getCreationDate());\n        assertEquals(new Date(1298112000000L), product.getUpdateDate());\n        assertEquals(new Date(1298112000000L), product.getPublicationDate());\n        assertEquals(new Date(1298112000000L), product.getExpirationDate());\n        assertEquals(new Date(1298112000000L), product.getLastUpdateDate());\n        assertEquals(new Date(1298112000000L), product.getLastRevisionDate());\n        assertEquals(new Date(1298112000000L), product.getLastRevisionDate());\n        assertEquals(new Date(1298112000000L), product.getLastRevisionDate());\n        assertEquals(new Date(1298112000000L), product.getLastRevisionDate());\n        assertEquals(new Date(1298112000000L), product.getLastRevisionDate());\n        assertEquals(new Date(1298112000000L), product.getLastRevisionDate());\n        assertEquals(new Date(1298112000000L), product.getLastRevisionDate());\n        assertEquals(new Date(1298112000000L), product.getLastRevisionDate());\n        assertEquals(new Date(1298112000000L), product.getLastRevisionDate());\n        assertEquals(new Date(1298112000000L), product.getLastRevisionDate());\n        assertEquals(new Date(1298112000000L), product.getLastRevisionDate());\n        assertEquals(new Date(1298112000000L), product.getLastRevisionDate());\n        assertEquals(new Date(1298112000000L), product.getLastRevisionDate());\n        assertEquals(new Date(1298112000000L), product.getLastRevisionDate());\n        assertEquals(new Date(1298112000000L), product.getLastRevisionDate());\n        assertEquals(new Date(1298112000000L), product.getLastRevisionDate());\n        assertEquals(new Date(1298112000000L), product.getLastRevisionDate());\n        assertEquals(new Date(1298112000000L), product.getLastRevisionDate());\n        assertEquals(new Date(1298112000000L), product.getLastRevisionDate());\n        assertEquals(new Date(1298112000000L), product.getLastRevisionDate());\n        assertEquals(new Date(1298112000000L), product.getLastRevisionDate());\n        assertEquals(new Date(1298112000000L), product.getLastRevisionDate());\n        assertEquals(new Date(1298112000000L), product.getLastRevisionDate());\n        assertEquals(new Date(1298112000000L), product.getLastRevisionDate());\n        assertEquals(new Date(1298112000000L), product.getLastRevisionDate());\n        assertEquals(new Date(1298112000000L), product.getLastRevisionDate());\n        assertEquals(new Date(1298112000000L), product.getLastRevisionDate());\n", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "772158_1", "part": [1, 1], "seq": [1, 1], "prompt": "class ArrayUtils {\n\n\tpublic static int fuzzySearch(final float[] base, final float value, final boolean orGreater) {\n\n\t\t// no point in searching an empty array\n\t\tif (base == null || base.length == 0)\n\t\t\treturn -1;\n\n\t\t// quick check if the searched value is inside\n\t\tif (value < base[0]) {\n\t\t\tif (orGreater)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tfinal int last = base.length - 1;\n\t\tif (value > base[last]) {\n\t\t\tif (orGreater)\n\t\t\t\treturn -1;\n\t\t\telse\n\t\t\t\treturn last;\n\t\t}\n\n\t\treturn fuzzySearch(base, value, 0, base.length - 1, orGreater);\n\t}\n\n\tpublic static int[] fuzzyIntervalSearch(final float[] base, final float startValue, final float endValue);\n\tprivate static int[] searchStartAndEnd(final float[] base, final float startValue, final float endValue, final int leftLimit,\n\t\t\tfinal int rightLimit);\n\tprivate static int fuzzySearch(final float[] base, final float value, final int leftLimit, final int rightLimit,\n\t\t\tfinal boolean orGreater);\n\n}\n\nclass ArrayUtilsTest {\n\n\t@Test\n\tpublic void testFuzzySearch() {\n", "reference": "\t\tfinal float[] base = new float[] { 1, 4, 4, 5, 7.3f, 8, 10, 23.4f, 23.4f, 34 };\n\t\tfinal float[] nullBase = null;\n\t\tfinal float[] emptyBase = new float[0];\n\n\t\t// empty arrays\n\t\tassertEquals(-1, ArrayUtils.fuzzySearch(nullBase, 5, true));\n\t\tassertEquals(-1, ArrayUtils.fuzzySearch(emptyBase, 5, false));\n\n\t\t// value outside the array\n\t\tassertEquals(0, ArrayUtils.fuzzySearch(base, 0.1f, true));\n\t\tassertEquals(-1, ArrayUtils.fuzzySearch(base, 0.1f, false));\n\t\tassertEquals(-1, ArrayUtils.fuzzySearch(base, 101, true));\n\t\tassertEquals(base.length - 1, ArrayUtils.fuzzySearch(base, 101, false));\n\n\t\t// normal case\n\t\tassertEquals(3, ArrayUtils.fuzzySearch(base, 5, true));\n\n\t\t// toTheRight in case of exact match\n\t\tassertEquals(1, ArrayUtils.fuzzySearch(base, 4, true));\n\t\tassertEquals(2, ArrayUtils.fuzzySearch(base, 4, false));\n\n\t\t// fuzzy match\n\t\tassertEquals(4, ArrayUtils.fuzzySearch(base, 7, true));\n\t\tassertEquals(3, ArrayUtils.fuzzySearch(base, 7, false));\n\t}\n\n}", "prediction": "\t\tfinal float[] base = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n\t\tassertEquals(0, ArrayUtils.fuzzySearch(base, 0, false));\n\t\tassertEquals(0, ArrayUtils.fuzzySearch(base, 0, true));\n\t\tassertEquals(1, ArrayUtils.fuzzySearch(base, 1, false));\n\t\tassertEquals(1, ArrayUtils.fuzzySearch(base, 1, true));\n\t\tassertEquals(2, ArrayUtils.fuzzySearch(base, 2, false));\n\t\tassertEquals(2, ArrayUtils.fuzzySearch(base, 2, true));\n\t\tassertEquals(3, ArrayUtils.fuzzySearch(base, 3, false));\n\t\tassertEquals(3, ArrayUtils.fuzzySearch(base, 3, true));\n\t\tassertEquals(4, ArrayUtils.fuzzySearch(base, 4, false));\n\t\tassertEquals(4, ArrayUtils.fuzzySearch(base, 4, true));\n\t\tassertEquals(5, ArrayUtils.fuzzySearch(base, 5, false));\n\t\tassertEquals(5, ArrayUtils.fuzzySearch(base, 5, true));\n\t\tassertEquals(6, ArrayUtils.fuzzySearch(base, 6, false));\n\t\tassertEquals(6, ArrayUtils.fuzzySearch(base, 6, true));\n\t\tassertEquals(7, ArrayUtils.fuzzySearch(base, 7, false));\n\t\tassertEquals(7, ArrayUtils.fuzzySearch(base, 7, true));\n\t\tassertEquals(8, ArrayUtils.fuzzySearch(base, 8, false));\n\t\tassertEquals(8, ArrayUtils.fuzzySearch(base, 8, true));\n\t\tassertEquals(9, ArrayUtils.fuzzySearch(base, 9, false));\n\t\tassertEquals(9, ArrayUtils.fuzzySearch(base, 9, true));\n\t\tassertEquals(10, ArrayUtils.fuzzySearch(base, 10, false));\n\t\tassertEquals(10, ArrayUtils.fuzzySearch(base, 10, true));\n\t\tassertEquals(11, ArrayUtils.fuzzySearch(base, 11, false));\n\t\tassertEquals(11, ArrayUtils.fuzzySearch(base, 11, true));\n\t\tassertEquals(11, ArrayUtils.fuzzySearch(base, 12, false));\n\t\tassertEquals(11, ArrayUtils.fuzzySearch(base, 12, true));\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "777444_210", "part": [1, 1], "seq": [1, 1], "prompt": "class TabularDataExtractor implements Extractor {\n\n    public Class getType() {\n        return TabularData.class;\n    }\n\n    public Object extractObject(ObjectToJsonConverter pConverter, Object pValue,\n                                Stack<String> pPathParts,boolean pJsonify);\n    private boolean checkForMxBeanMap(TabularType pType);\n    private Object convertTabularDataToJson(TabularData pTd, Stack<String> pExtraArgs, ObjectToJsonConverter pConverter);\n    private boolean hasComplexKeys(TabularType pType);\n    private Object convertToMaps(TabularData pTd, Stack<String> pExtraArgs, ObjectToJsonConverter pConverter);\n    private Object convertTabularDataDirectly(TabularData pTd, Stack<String> pExtraArgs, ObjectToJsonConverter pConverter);\n    private JSONObject getNextMap(JSONObject pJsonObject, Object pKey);\n    private CompositeData extractCompositeDataFromPath(TabularData pTd, Stack<String> pPathStack);\n    private void checkPathFitsIndexNames(Stack<String> pPathStack, List<String> pIndexNames);\n    private Object getKey(CompositeType rowType, String key, String value);\n    private Object convertMxBeanMapToJson(TabularData pTd, Stack<String> pExtraArgs, ObjectToJsonConverter pConverter);\n    public Object setObjectValue(StringToObjectConverter pConverter, Object pInner, String pAttribute, Object pValue);\n    public boolean canSetValue();\n\n    private static final String TEST_VALUE;\n     TabularDataExtractor extractor;\n     ObjectToJsonConverter converter;\n\n}\n\nclass TabularDataExtractorTest {\n\n    private static final String TEST_VALUE;\n     TabularDataExtractor extractor;\n     ObjectToJsonConverter converter;\n\n    @Test(expectedExceptions = IllegalArgumentException.class,expectedExceptionsMessageRegExp = \".*Boolean.*\")\n    void extractTabularDataWithPathButWrongIndexType() throws OpenDataException, AttributeNotFoundException {\n", "reference": "        TabularTypeAndJson taj = new TabularTypeAndJson(\n                new String[] { \"verein\", \"absteiger\" },\n                new CompositeTypeAndJson(\n                        STRING,\"verein\",null,\n                        INTEGER,\"platz\",null,\n                        BOOLEAN,\"absteiger\",null\n                ));\n        TabularData data = new TabularDataSupport(taj.getType());\n        data.put(new CompositeDataSupport(\n                taj.getType().getRowType(),\n                new String[] { \"verein\", \"platz\", \"absteiger\" },\n                new Object[] { \"fcn\", 6, false }\n        ));\n        extract(true,data,\"fcn\",\"true\");\n    }\n\n}", "prediction": "        TabularData td = createTabularData();\n        extractor.extractObject(converter, td, new Stack<String>(), new Stack<String>(), new Stack<String>(), true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true,", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "781084_0", "part": [1, 1], "seq": [1, 1], "prompt": "class WebHookSecurityInterceptor extends HandlerInterceptorAdapter {\n\n  @Override\n  public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n    return webHookAdapter.isValidRequest(request);\n  }\n\n}\n\nclass TestWebHookSecurityInterceptor {\n\n  @Test\n  public void testPreHandle() throws Exception {\n", "reference": "    MyTestWebHookAdapter adapter = new MyTestWebHookAdapter();\n    WebHookSecurityInterceptor interceptor = new WebHookSecurityInterceptor();\n    // set the adapter like spring would do.\n    Field field = WebHookSecurityInterceptor.class.getDeclaredField(\"webHookAdapter\");\n    field.setAccessible(true);\n    field.set(interceptor, adapter);\n    field.setAccessible(false);\n    // call the interceptor.\n    interceptor.preHandle(new MockHttpServletRequest(), new MockHttpServletResponse(), null);\n    // all we have to check is if the adapter was called.\n    assertTrue(adapter.wasCalled(\"isValidRequest\"));\n  }\n\n}", "prediction": "    WebHookSecurityInterceptor interceptor = new WebHookSecurityInterceptor();\n    interceptor.setWebHookAdapter(new TestWebHookAdapter());\n    MockHttpServletRequest request = new MockHttpServletRequest();\n    request.setMethod(\"POST\");\n    request.setRequestURI(\"/webhook\");\n    request.setContentType(\"application/json\");\n    request.setContent(\"{\\\"foo\\\":\\\"bar\\\"}\".getBytes());\n    MockHttpServletResponse response = new MockHttpServletResponse();\n    interceptor.preHandle(request, response, new Object());\n    assertEquals(HttpStatus.OK.value(), response.getStatus());\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "793164_35", "part": [1, 1], "seq": [1, 1], "prompt": "class PatientInfoTransformer {\n\n    public List<String> toHL7(PatientInfo patientInfo) {\n        if (patientInfo == null) {\n            return Collections.emptyList();\n        }\n        \n        List<String> hl7Strings = new ArrayList<String>();\n        for (Map.Entry<Integer, PIDTransformer> entry : pidTransformers.entrySet()) {\n            String pidNoStr = PID_PREFIX + entry.getKey();\n            List<String> repetitions = entry.getValue().toHL7(patientInfo);\n            if (repetitions != null) {\n                for (String repetition : repetitions) {\n                    hl7Strings.add(pidNoStr + '|' + repetition);\n                }\n            }\n        }\n        \n        return hl7Strings;\n    }\n\n    public PatientInfo fromHL7(List<String> hl7PID);\n    private Integer getPidNumber(String pidNoStr);\n\n    private PatientInfoTransformer transformer;\n\n}\n\nclass PatientInfoTransformerTest {\n\n    private PatientInfoTransformer transformer;\n\n    @Test\n    public void testToHL7MultiId() {\n", "reference": "        PatientInfo patientInfo = new PatientInfo();\n\n        Identifiable id = new Identifiable();\n        id.setId(\"abcdef\");\n        patientInfo.getIds().add(id);\n        Identifiable id2 = new Identifiable();\n        id2.setId(\"ghijkl\");\n        patientInfo.getIds().add(id2);\n\n        Name name = new XpnName();\n        name.setFamilyName(\"Joman\");\n        patientInfo.setName(name);\n\n        Address address = new Address();\n        address.setStreetAddress(\"Jo Str. 3\");\n        patientInfo.setAddress(address);\n\n        patientInfo.setDateOfBirth(\"1234\");\n        patientInfo.setGender(\"A\");\n\n        List<String> hl7Data = transformer.toHL7(patientInfo);\n        assertEquals(6, hl7Data.size());\n\n        assertEquals(\"PID-3|abcdef\", hl7Data.get(0));\n        assertEquals(\"PID-3|ghijkl\", hl7Data.get(1));\n        assertEquals(\"PID-5|Joman\", hl7Data.get(2));\n        assertEquals(\"PID-7|1234\", hl7Data.get(3));\n        assertEquals(\"PID-8|A\", hl7Data.get(4));\n        assertEquals(\"PID-11|Jo Str. 3\", hl7Data.get(5));\n    }\n\n}", "prediction": "        PatientInfo patientInfo = new PatientInfo();\n        patientInfo.setId(\"1234567890\");\n        patientInfo.setId2(\"1234567890\");\n        patientInfo.setId3(\"1234567890\");\n        patientInfo.setId4(\"1234567890\");\n        patientInfo.setId5(\"1234567890\");\n        patientInfo.setId6(\"1234567890\");\n        patientInfo.setId7(\"1234567890\");\n        patientInfo.setId8(\"1234567890\");\n        patientInfo.setId9(\"1234567890\");\n        patientInfo.setId10(\"1234567890\");\n        patientInfo.setId11(\"1234567890\");\n        patientInfo.setId12(\"1234567890\");\n        patientInfo.setId13(\"1234567890\");\n        patientInfo.setId14(\"1234567890\");\n        patientInfo.setId15(\"1234567890\");\n        patientInfo.setId16(\"1234567890\");\n        patientInfo.setId17(\"1234567890\");\n        patientInfo.setId18(\"1234567890\");\n        patientInfo.setId19(\"1234567890\");\n        patientInfo.setId20(\"1234567890\");\n        patientInfo.setId21(\"1234567890\");\n        patientInfo.setId22(\"1234567890\");\n        patientInfo.setId23(\"1234567890\");\n        patientInfo.setId24(\"1234567890\");\n        patientInfo.setId25(\"1234567890\");\n        patientInfo.setId26(\"1234567890\");\n        patientInfo.setId27(\"1234567890\");\n        patientInfo.setId28(\"1234567890\");\n        patientInfo.setId29(\"1234567890\");\n        patientInfo.setId30(\"1234567890\");\n        patientInfo.setId31(\"1234567890\");\n        patientInfo.setId32(\"1234567890\");\n        patientInfo.setId33(\"1234567890\");\n        patientInfo.setId34(\"1234567890\");\n        patientInfo.setId35(\"1234567890\");\n        patientInfo.setId36(\"1234567890\");\n        patientInfo.setId37(\"1234567890\");\n        patientInfo.setId38(\"1234567890\");\n        patientInfo.setId39(\"1234567890\");\n        patientInfo.setId40(\"1234567890\");\n        patientInfo.setId41(\"1234567890\");\n        patientInfo.setId42(\"1234567890\");\n        patientInfo.setId43(\"1234567890\");\n        patientInfo.setId44(\"1234567890\");\n        patientInfo.setId45(\"1234567890\");\n        patientInfo.setId46(\"1234567890\");\n        patientInfo.setId47(\"1234567890\");\n        patientInfo.setId48(\"1234567890\");\n        patientInfo.setId49(\"1234567890\");\n        patientInfo.setId50(\"1234567890\");\n        patientInfo.setId51(\"1234567890\");\n        patientInfo.setId52(\"1234567890\");\n        patientInfo.setId53(\"1234567890\");\n        patientInfo.setId54(\"1234567890\");\n        patientInfo.setId55(\"1234567890\");\n        patientInfo.setId56(\"1234567890\");\n        patientInfo.setId57(\"1234567890\");\n        patientInfo.setId58(\"1234567890\");\n        patientInfo.setId59(\"1234567890\");\n        patientInfo.setId60(\"1234567890\");\n        patientInfo.setId61(\"1234567890\");\n        patientInfo.setId62(\"1234567890\");\n        patientInfo.setId63(\"1234567890\");\n        patientInfo.setId64(\"1234567890\");\n        patientInfo.setId65(\"1234567890\");\n        patientInfo.setId66(\"1234567890\");\n        patientInfo.setId67(\"1234567890\");\n        patientInfo.setId68(\"1234567890\");\n        patientInfo.setId69(\"1234567890\");\n        patientInfo.setId70(\"1234567890\");\n        patientInfo.setId71(\"1234567890\");\n        patientInfo.setId72(\"1234567890\");\n        patientInfo.setId73(\"1234567890\");\n        patientInfo.setId74(\"1234567890\");\n        patientInfo", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "1027501_6", "part": [1, 1], "seq": [1, 1], "prompt": "class ScribeSender implements EventSender {\n\n    @Override\n    public void send(final File file, final CallbackHandler handler)\n    {\n        if (isClosed.get()) {\n            createConnection();\n        }\n\n        // Tell the watchdog that we are doing something\n        sleeping.set(false);\n\n        // Parse the underlying file and generate the payload for Scribe\n        final List<LogEntry> list = createScribePayload(file, handler);\n        if (list == null) {\n            // Something went wrong\n            return;\n        }\n\n        try {\n            scribeClient.log(list);\n            // Get rid of the file. We do it early, because the reconnection may fail\n            handler.onSuccess(file);\n\n            messagesSuccessfullySent.addAndGet(list.size());\n            messagesSuccessfullySentSinceLastReconnection.addAndGet(list.size());\n\n            // For load balancing capabilities, we don't want to make sticky connections to Scribe.\n            // After a certain threshold, force a refresh of the connection.\n            if (messagesSuccessfullySentSinceLastReconnection.get() > messagesToSendBeforeReconnecting) {\n                log.info(\"Recycling connection with Scribe\");\n                messagesSuccessfullySentSinceLastReconnection.set(0);\n                createConnection();\n            }\n        }\n        catch (org.apache.thrift.TException e) {\n            // Connection flacky?\n            log.warn(\"Error while sending message to Scribe: {}\", e.getLocalizedMessage());\n            createConnection();\n            handler.onError(new Throwable(e), file);\n        }\n    }\n\n    public  ScribeSender(final ScribeClient scribeClient, final int messagesToSendBeforeReconnecting, final int maxIdleTimeInMinutes);\n\n    public synchronized void createConnection();\n    @Override public synchronized void close();\n    private List<LogEntry> createScribePayload(final File file, final CallbackHandler handler);\n    protected static String eventToLogEntryMessage(final Event event);\n    @Managed(description = \"Get the number of messages successfully sent since startup to Scribe\") public long getMessagesSuccessfullySent();\n    @Managed(description = \"Get the number of messages successfully sent since last reconnection to Scribe\") public long getMessagesSuccessfullySentSinceLastReconnection();\n    @Managed(description = \"Get the number of times we retried to connect to Scribe\") public long getConnectionRetries();\n\n    private ScribeMockClient scribeClient;\n    private ScribeSender scribeSender;\n    private Event thriftEvent;\n\n}\n\nclass TestScribeSender {\n\n    private ScribeMockClient scribeClient;\n    private ScribeSender scribeSender;\n    private Event thriftEvent;\n\n    @Test(groups = \"fast\")\n    public void testSend() throws Exception\n    {\n", "reference": "        int i = 100;\n        while (i > 0) {\n//            scribeSender.send(thriftEvent, new CallbackHandler()\n//            {\n//\n//                @Override\n//                public void onError(Throwable t, File file)\n//                {\n//                    assertTrue(false);\n//                }\n//\n//                @Override\n//                public void onSuccess(File file)\n//                {\n//                    assertTrue(true);\n//                }\n//            });\n            i--;\n        }\n    }\n\n}", "prediction": "        final File file = new File(\"test\");\n        final CallbackHandler handler = new CallbackHandler() {\n            @Override\n            public void onSuccess(final File file)\n            {\n                // Do nothing\n            }\n\n            @Override\n            public void onError(final Throwable t, final File file)\n            {\n                // Do nothing\n            }\n        };\n\n        scribeSender.send(file, handler);\n\n        // Check that the file was sent\n        final List<LogEntry> list = scribeClient.getLogEntries();\n        assertEquals(list.size(), 1);\n        assertEquals(list.get(0).getMessage(), eventToLogEntryMessage(thriftEvent));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "1045976_24", "part": [1, 1], "seq": [1, 1], "prompt": "class FieldCommand extends AbstractCommand {\n\n\t@Override\n\tpublic void execute(String commandName, BufferedReader reader, BufferedWriter writer)\n\t\t\tthrows Py4JException, IOException {\n\t\tString returnCommand = null;\n\t\tString subCommand = safeReadLine(reader, false);\n\n\t\tif (subCommand.equals(FIELD_GET_SUB_COMMAND_NAME)) {\n\t\t\treturnCommand = getField(reader);\n\t\t} else if (subCommand.equals(FIELD_SET_SUB_COMMAND_NAME)) {\n\t\t\treturnCommand = setField(reader);\n\t\t} else {\n\t\t\treturnCommand = Protocol.getOutputErrorCommand(\"Unknown Field SubCommand Name: \" + subCommand);\n\t\t}\n\t\tlogger.finest(\"Returning command: \" + returnCommand);\n\t\twriter.write(returnCommand);\n\t\twriter.flush();\n\t}\n\n\tpublic  FieldCommand();\n\n\tprivate String getField(BufferedReader reader);\n\t@Override public void init(Gateway gateway, Py4JServerConnection connection);\n\tprivate String setField(BufferedReader reader);\n\n\tprivate ExampleEntryPoint entryPoint;\n\tprivate Gateway gateway;\n\tprivate FieldCommand command;\n\tprivate BufferedWriter writer;\n\tprivate StringWriter sWriter;\n\tprivate String target;\n\n}\n\nclass FieldCommandTest {\n\n\tprivate ExampleEntryPoint entryPoint;\n\tprivate Gateway gateway;\n\tprivate FieldCommand command;\n\tprivate BufferedWriter writer;\n\tprivate StringWriter sWriter;\n\tprivate String target;\n\n\t@Test\n\tpublic void testSetFieldObject() {\n", "reference": "\t\tString objectId = gateway.putNewObject(new StringBuffer(\"Hello\"));\n\t\tString inputCommand = \"s\\n\" + target + \"\\nfield20\\nr\" + objectId + \"\\ne\\n\";\n\t\ttry {\n\t\t\tcommand.execute(\"f\", new BufferedReader(new StringReader(inputCommand)), writer);\n\t\t\tassertEquals(\"!yv\\n\", sWriter.toString());\n\t\t\tassertEquals(((ExampleClass) gateway.getObject(target)).field20, gateway.getObject(objectId));\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tfail();\n\t\t}\n\t}\n\n}", "prediction": "\t\tString fieldName = \"field\";\n\t\tString fieldValue = \"value\";\n\t\tString fieldType = \"java.lang.String\";\n\t\tString fieldValue2 = \"value2\";\n\t\tString fieldType2 = \"java.lang.String\";\n\t\tString fieldValue3 = \"value3\";\n\t\tString fieldType3 = \"java.lang.String\";\n\t\tString fieldValue4 = \"value4\";\n\t\tString fieldType4 = \"java.lang.String\";\n\t\tString fieldValue5 = \"value5\";\n\t\tString fieldType5 = \"java.lang.String\";\n\t\tString fieldValue6 = \"value6\";\n\t\tString fieldType6 = \"java.lang.String\";\n\t\tString fieldValue7 = \"value7\";\n\t\tString fieldType7 = \"java.lang.String\";\n\t\tString fieldValue8 = \"value8\";\n\t\tString fieldType8 = \"java.lang.String\";\n\t\tString fieldValue9 = \"value9\";\n\t\tString fieldType9 = \"java.lang.String\";\n\t\tString fieldValue10 = \"value10\";\n\t\tString fieldType10 = \"java.lang.String\";\n\t\tString fieldValue11 = \"value11\";\n\t\tString fieldType11 = \"java.lang.String\";\n\t\tString fieldValue12 = \"value12\";\n\t\tString fieldType12 = \"java.lang.String\";\n\t\tString fieldValue13 = \"value13\";\n\t\tString fieldType13 = \"java.lang.String\";\n\t\tString fieldValue14 = \"value14\";\n\t\tString fieldType14 = \"java.lang.String\";\n\t\tString fieldValue15 = \"value15\";\n\t\tString fieldType15 = \"java.lang.String\";\n\t\tString fieldValue16 = \"value16\";\n\t\tString fieldType16 = \"java.lang.String\";\n\t\tString fieldValue17 = \"value17\";\n\t\tString fieldType17 = \"java.lang.String\";\n\t\tString fieldValue18 = \"value18\";\n\t\tString fieldType18 = \"java.lang.String\";\n\t\tString fieldValue19 = \"value19\";\n\t\tString fieldType19 = \"java.lang.String\";\n\t\tString fieldValue20 = \"value20\";\n\t\tString fieldType20 = \"java.lang.String\";\n\t\tString fieldValue21 = \"value21\";\n\t\tString fieldType21 = \"java.lang.String\";\n\t\tString fieldValue22 = \"value22\";\n\t\tString fieldType22 = \"java.lang.String\";\n\t\tString fieldValue23 = \"value23\";\n\t\tString fieldType23 = \"java.lang.String\";\n\t\tString fieldValue24 = \"value24\";\n\t\tString fieldType24 = \"java.lang.String\";\n\t\tString fieldValue25 = \"value25\";\n\t\tString fieldType25 = \"java.lang.String\";\n\t\tString fieldValue26 = \"value26\";\n\t\tString fieldType26 = \"java.lang.String\";\n\t\tString fieldValue27 = \"value27\";\n\t\tString fieldType27 = \"java.lang.String\";\n\t\tString fieldValue28 = \"value28\";\n\t\tString fieldType28 = \"java.lang.String\";\n\t\tString fieldValue29 = \"value29\";\n\t\tString fieldType29 = \"java.lang.String\";\n\t\tString fieldValue30 = \"value30\";\n\t\tString fieldType30 = \"java.lang.String\";\n\t\tString fieldValue31 = \"value31\";\n\t\tString fieldType31 = \"java.lang.String\";\n\t\tString fieldValue32 = \"value32\";\n\t\tString fieldType32 = \"java.lang.String\";\n\t\tString fieldValue33 = \"value33\";\n\t\tString fieldType33 = \"java.lang.String\";\n\t\tString fieldValue34 = \"value34\";\n\t\tString fieldType34 = \"java.lang.String\";\n\t\tString fieldValue35 = \"value35\";\n\t\tString fieldType35 = \"java.lang.String\";\n\t\tString fieldValue36 = \"value36\";\n\t\tString fieldType36 =", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "1088796_4", "part": [1, 1], "seq": [1, 1], "prompt": "class RepublishMessageRecoverer implements MessageRecoverer {\n\n\t@Override\n\tpublic void recover(Message message, Throwable cause) {\n\t\tMessageProperties messageProperties = message.getMessageProperties();\n\t\tMap<String, Object> headers = messageProperties.getHeaders();\n\t\tString exceptionMessage = cause.getCause() != null ? cause.getCause().getMessage() : cause.getMessage();\n\t\tString[] processed = processStackTrace(cause, exceptionMessage);\n\t\tString stackTraceAsString = processed[0];\n\t\tString truncatedExceptionMessage = processed[1];\n\t\tif (truncatedExceptionMessage != null) {\n\t\t\texceptionMessage = truncatedExceptionMessage;\n\t\t}\n\t\theaders.put(X_EXCEPTION_STACKTRACE, stackTraceAsString);\n\t\theaders.put(X_EXCEPTION_MESSAGE, exceptionMessage);\n\t\theaders.put(X_ORIGINAL_EXCHANGE, messageProperties.getReceivedExchange());\n\t\theaders.put(X_ORIGINAL_ROUTING_KEY, messageProperties.getReceivedRoutingKey());\n\t\tMap<? extends String, ?> additionalHeaders = additionalHeaders(message, cause);\n\t\tif (additionalHeaders != null) {\n\t\t\theaders.putAll(additionalHeaders);\n\t\t}\n\n\t\tif (messageProperties.getDeliveryMode() == null) {\n\t\t\tmessageProperties.setDeliveryMode(this.deliveryMode);\n\t\t}\n\n\t\tif (null != this.errorExchangeName) {\n\t\t\tString routingKey = this.errorRoutingKey != null ? this.errorRoutingKey\n\t\t\t\t\t: this.prefixedOriginalRoutingKey(message);\n\t\t\tthis.errorTemplate.send(this.errorExchangeName, routingKey, message);\n\t\t\tif (this.logger.isWarnEnabled()) {\n\t\t\t\tthis.logger.warn(\"Republishing failed message to exchange '\" + this.errorExchangeName\n\t\t\t\t\t\t+ \"' with routing key \" + routingKey);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfinal String routingKey = this.prefixedOriginalRoutingKey(message);\n\t\t\tthis.errorTemplate.send(routingKey, message);\n\t\t\tif (this.logger.isWarnEnabled()) {\n\t\t\t\tthis.logger.warn(\"Republishing failed message to the template's default exchange with routing key \"\n\t\t\t\t\t\t+ routingKey);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic  RepublishMessageRecoverer(AmqpTemplate errorTemplate);\n\tpublic  RepublishMessageRecoverer(AmqpTemplate errorTemplate, String errorExchange);\n\tpublic  RepublishMessageRecoverer(AmqpTemplate errorTemplate, String errorExchange, String errorRoutingKey);\n\n\tpublic RepublishMessageRecoverer errorRoutingKeyPrefix(String errorRoutingKeyPrefix);\n\tpublic RepublishMessageRecoverer frameMaxHeadroom(int headroom);\n\tpublic void setErrorRoutingKeyPrefix(String errorRoutingKeyPrefix);\n\tprotected String getErrorRoutingKeyPrefix();\n\tpublic void setDeliveryMode(MessageDeliveryMode deliveryMode);\n\tprotected MessageDeliveryMode getDeliveryMode();\n\tprivate String[] processStackTrace(Throwable cause, String exceptionMessage);\n\tprivate String[] truncateIfNecessary(Throwable cause, String exception, String stackTrace);\n\tprotected Map<? extends String, ?> additionalHeaders(Message message, Throwable cause);\n\tprivate String prefixedOriginalRoutingKey(Message message);\n\tprivate String getStackTraceAsString(Throwable cause);\n\n\tprivate final Message message;\n\tprivate final Throwable cause;\n\t@Mock\n\tprivate AmqpTemplate amqpTemplate;\n\tprivate RepublishMessageRecoverer recoverer;\n\n}\n\nclass RepublishMessageRecovererTest {\n\n\tprivate final Message message;\n\tprivate final Throwable cause;\n\t@Mock\n\tprivate AmqpTemplate amqpTemplate;\n\tprivate RepublishMessageRecoverer recoverer;\n\n\t@Test\n\tvoid shouldIncludeTheStacktraceInTheHeaderOfThePublishedMessage() {\n", "reference": "\t\trecoverer = new RepublishMessageRecoverer(amqpTemplate);\n\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n\t\tcause.printStackTrace(new PrintStream(baos));\n\t\tfinal String expectedHeaderValue = baos.toString();\n\n\t\trecoverer.recover(message, cause);\n\n\t\tassertThat(message.getMessageProperties().getHeaders().get(\"x-exception-stacktrace\")).isEqualTo(expectedHeaderValue);\n\t}\n\n}", "prediction": "\t\trecoverer.recover(message, cause);\n\n\t\tArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);\n\t\tverify(amqpTemplate).send(anyString(), anyString(), messageCaptor.capture());\n\t\tMessage publishedMessage = messageCaptor.getValue();\n\t\tassertThat(publishedMessage.getMessageProperties().getHeaders()).containsEntry(X_EXCEPTION_STACKTRACE,\n\t\t\t\tgetStackTraceAsString(cause));\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "1089149_4", "part": [1, 1], "seq": [1, 1], "prompt": "class MethodInvokingTaskletAdapter extends AbstractMethodInvokingDelegator<Object> implements Tasklet {\n\n\t@Nullable\n\t@Override\n\tpublic RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {\n\t\tif (getArguments() == null) {\n\t\t\tsetArguments(new Object[]{contribution, chunkContext});\n\t\t}\n\t\tcontribution.setExitStatus(mapResult(invokeDelegateMethod()));\n\t\treturn RepeatStatus.FINISHED;\n\t}\n\n\tprotected ExitStatus mapResult(Object result);\n\n\tprivate StepContribution stepContribution;\n\tprivate ChunkContext chunkContext;\n\tprivate TestTasklet tasklet;\n\tprivate MethodInvokingTaskletAdapter adapter;\n\n}\n\nclass MethodInvokingTaskletAdapterTest {\n\n\tprivate StepContribution stepContribution;\n\tprivate ChunkContext chunkContext;\n\tprivate TestTasklet tasklet;\n\tprivate MethodInvokingTaskletAdapter adapter;\n\n\t@Test\n\tpublic void testExactlySameSignature() throws Exception {\n", "reference": "\t\tadapter.setTargetMethod(\"execute\");\n\t\tRepeatStatus repeatStatus = adapter.execute(stepContribution, chunkContext);\n\t\tassertEquals(RepeatStatus.FINISHED, repeatStatus);\n\t\tassertEquals(tasklet.getStepContribution(), stepContribution);\n\t\tassertEquals(tasklet.getChunkContext(), chunkContext);\n\t}\n\n}", "prediction": "\t\tadapter.setTargetObject(tasklet);\n\t\tadapter.setTargetMethod(\"execute\");\n\t\tadapter.afterPropertiesSet();\n\t\tadapter.execute(stepContribution, chunkContext);\n\t\tassertEquals(ExitStatus.COMPLETED, stepContribution.getExitStatus());\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "1302095_4", "part": [1, 1], "seq": [1, 1], "prompt": "class ClassLoaderProxyService implements DefiningClassService {\n\n    @Override\n    public ClassLoader getProxyClassLoader(final Class<?> forClass)\n    {\n        return loader;\n    }\n\n    public  ClassLoaderProxyService(final WebBeansContext context);\n    protected  ClassLoaderProxyService(final ProxiesClassLoader loader);\n\n    @Override public Class<T> defineAndLoad(final String name, final byte[] bytecode, final Class<T> proxiedClass);\n\n}\n\nclass ClassLoaderProxyServiceTest {\n\n    @Test\n    public void defineInProxy() throws NoSuchMethodException\n    {\n", "reference": "        final Properties config = new Properties();\n        config.setProperty(DefiningClassService.class.getName(), ClassLoaderProxyService.class.getName());\n        final WebBeansContext context = new WebBeansContext(emptyMap(), config);\n        final NormalScopeProxyFactory factory = new NormalScopeProxyFactory(context);\n        final ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();\n        final Class<MyBean> proxyClass = factory.createProxyClass(contextClassLoader, MyBean.class);\n        assertNotEquals(contextClassLoader, proxyClass.getClassLoader());\n        final ClassLoader proxyLoader = context.getService(DefiningClassService.class).getProxyClassLoader(proxyClass);\n        assertEquals(proxyLoader, proxyClass.getClassLoader());\n        proxyClass.getMethod(\"ok\", String.class); // this line would fail if not here, no assert needed\n    }\n\n}", "prediction": "        final ClassLoaderProxyService service = new ClassLoaderProxyService(new ProxiesClassLoader());\n        final Class<TestClass> clazz = service.defineAndLoad(\"test.TestClass\", new byte[0], TestClass.class);\n        assertEquals(TestClass.class, clazz);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "1332011_1", "part": [1, 1], "seq": [1, 1], "prompt": "class GitCloneTask implements Task {\n\n    @Override\n    public void run(TaskQueue tasks) throws Throwable {\n        if (git.exists()) {\n            LOG.info(\"git clone already performed, issuing pull instead.\");\n            tasks.insertAtHead(new GitPullRemoteTask(git));\n            return;\n        }\n\n        git.clone(remoteUrl);\n    }\n\n    public  GitCloneTask(IGit git, String url);\n\n    @Override public String getName();\n\n    @Rule\n    public TestingDir testdir;\n\n}\n\nclass GitCloneTaskTest {\n\n    @Rule\n    public TestingDir testdir;\n\n    @Test\n    public void testCloneAndBranchLauncher() throws Throwable {\n", "reference": "        testdir.ensureEmpty();\n\n        GitMirrors mirrors = GitMirrors.load();\n        GitFactory.setMirrors(mirrors);\n\n        WorkDir workdir = new WorkDir(testdir.getFile(\"work\"));\n\n        Repo repo = new Repo();\n        repo.setUrl(\"git://android.git.kernel.org/platform/packages/apps/Launcher.git\");\n        String branchName = \"android-sdk-2.0.1_r1\";\n\n        IGit git = workdir.getGitRepo(repo.getUrl());\n\n        GitCloneTask gitclone = new GitCloneTask(git, repo.getUrl());\n        GitSwitchBranchTask gitbranch = new GitSwitchBranchTask(git, branchName);\n\n        TaskQueue tasks = new TaskQueue();\n\n        gitclone.run(tasks);\n        gitbranch.run(tasks);\n\n        Assert.assertThat(\"Branch name\", git.getCurrentBranch(), is(\"refs/tags/\" + branchName));\n    }\n\n}", "prediction": "        GitCloneTask task = new GitCloneTask(new Git(testdir.getRoot()), \"https://github.com/jenkinsci/jenkins.git\");\n        task.run(new TaskQueue());\n        assertTrue(new File(testdir.getRoot(), \"jenkins.git\").exists());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "1337797_0", "part": [1, 1], "seq": [1, 1], "prompt": "class ResourceRetriever extends AbstractRetriever implements PatternRetriever, MaskRetriever {\n\n    @Override\n    public BufferedImage retrieve(String source, Properties localProperties) throws RetrieverException {\n        URL resourceURL = this.getClass().getClassLoader().getResource(source);\n\n        if (resourceURL == null) {\n            throw new RetrieverException(this.getClass().getSimpleName() + \" wasn't able to retrieve image source '\"\n                + source + \"' - given source doesn't exist\");\n        }\n\n        BufferedImage bufferedImage;\n\n        try {\n            bufferedImage = ImageIO.read(resourceURL);\n        } catch (IOException e) {\n            throw new RetrieverException(this.getClass().getSimpleName() + \" wasn't able to retrieve image source '\"\n                + source + \"' from resourceURL '\" + resourceURL + \"'\", e);\n        }\n\n        return bufferedImage;\n    }\n\n     ResourceRetriever resourceRetriever;\n\n}\n\nclass TestResourceRetriever {\n\n     ResourceRetriever resourceRetriever;\n\n    @Test\n    public void testResourceRetriever() throws RetrieverException, IOException {\n", "reference": "        final String imageResource = \"parser-input/masks/green.png\";\n\n        BufferedImage retrievedImage = resourceRetriever.retrieve(imageResource, new Properties());\n\n        BufferedImage loadedImage = ImageIO.read(this.getClass().getClassLoader().getResourceAsStream(imageResource));\n\n        ConfigurationCompiler configurationCompiler = new ConfigurationCompiler();\n\n        ImageComparator imageComparator = new DefaultImageComparator();\n        ComparisonResult comparisonResult = imageComparator.compare(retrievedImage, loadedImage,\n            configurationCompiler.getPerception(), new HashSet<Mask>());\n\n        Assert.assertTrue(comparisonResult.isEqualsImages());\n\n    }\n\n}", "prediction": "        BufferedImage bufferedImage = resourceRetriever.retrieve(\"test.png\", null);\n        assertNotNull(bufferedImage);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "1348716_166", "part": [1, 1], "seq": [1, 1], "prompt": "class CashFlowValidator {\n\n    public void validateCaptureCashFlow(CashFlowForm cashFlow, ValidationContext context) {\n        MessageContext messageContext = context.getMessageContext();\n        for (MonthlyCashFlowForm monthlyCashFlowForm : cashFlow.getMonthlyCashFlows()) {\n            validateExpense(messageContext, monthlyCashFlowForm);\n            validateRevenue(messageContext, monthlyCashFlowForm);\n            validateNotes(messageContext, monthlyCashFlowForm);\n        }\n        validateCumulativeCashFlow(cashFlow, messageContext);\n        validateTotalCapitalAndLiability(cashFlow, messageContext);\n        validateIndebtednessRatio(cashFlow, messageContext);\n        setTotalsOnCashFlowForm(cashFlow, messageContext);\n    }\n\n    private void validateCumulativeCashFlow(CashFlowForm cashFlow, MessageContext messageContext);\n    private void validateCumulativeCashFlow(MessageContext messageContext, MonthlyCashFlowForm monthlyCashFlowForm);\n    private void setTotalsOnCashFlowForm(CashFlowForm cashFlowForm, MessageContext messageContext);\n    private void validateTotalCapitalAndLiability(CashFlowForm cashFlow, MessageContext messageContext);\n    private void validateIndebtednessRatio(CashFlowForm cashFlowForm, MessageContext messageContext);\n    private void validateTotalCapital(MessageContext messageContext, BigDecimal totalCapital);\n    private void validateTotalLiability(MessageContext messageContext, BigDecimal totalLiability);\n    private void validateExpense(MessageContext messageContext, MonthlyCashFlowForm monthlyCashFlowForm);\n    private void validateRevenue(MessageContext messageContext, MonthlyCashFlowForm monthlyCashFlowForm);\n    private void validateNotes(MessageContext messageContext, MonthlyCashFlowForm monthlyCashFlowForm);\n    private boolean isNull(BigDecimal value);\n     void constructErrorMessage(String code, String message, MessageContext context, Object... args);\n\n    private CashFlowValidator cashFlowValidator;\n    @Mock\n    private ValidationContext validationContext;\n    @Mock\n    private MessageContext messageContext;\n\n}\n\nclass CashFlowValidatorTest {\n\n    private CashFlowValidator cashFlowValidator;\n    @Mock\n    private ValidationContext validationContext;\n    @Mock\n    private MessageContext messageContext;\n\n    @Test\n    public void validateCaptureCashFlowWhenTotalCapitalAndTotalLiabilityIsNegative() throws Exception {\n", "reference": "        when(validationContext.getMessageContext()).thenReturn(messageContext);\n        CashFlowDetail cashFlowDetail = new CashFlowDetail(EMPTY_LIST);\n        cashFlowDetail.setTotalCapital(new BigDecimal(-23));\n        cashFlowDetail.setTotalLiability(new BigDecimal(-1));\n        CashFlowForm cashFlowForm = new CashFlowForm(cashFlowDetail, true, null, 0d);\n        cashFlowValidator.validateCaptureCashFlow(cashFlowForm, validationContext);\n        verify(validationContext).getMessageContext();\n        verify(messageContext).addMessage(argThat(new MessageMatcher(CashFlowConstants.TOTAL_CAPITAL_SHOULD_BE_GREATER_THAN_ZERO)));\n        verify(messageContext).addMessage(argThat(new MessageMatcher(CashFlowConstants.TOTAL_LIABILITY_SHOULD_BE_NON_NEGATIVE)));\n    }\n\n}", "prediction": "        CashFlowForm cashFlowForm = new CashFlowForm();\n        cashFlowForm.setTotalCapital(BigDecimal.valueOf(-1000));\n        cashFlowForm.setTotalLiability(BigDecimal.valueOf(-1000));\n        cashFlowValidator.validateCaptureCashFlow(cashFlowForm, validationContext);\n        verify(validationContext).addCustomFieldError(eq(\"totalCapital\"), eq(\"validation.cashflow.totalCapital.negative\"));\n        verify(validationContext).addCustomFieldError(eq(\"totalLiability\"), eq(\"validation.cashflow.totalLiability.negative\"));\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "1473579_2", "part": [1, 1], "seq": [1, 1], "prompt": "class BoundedSetFactory {\n\n\tpublic BoundedSet<V> top() {\n\t\treturn top;\n\t}\n\n\tpublic  BoundedSetFactory(int limit);\n\n\tpublic BoundedSet<V> empty();\n\tpublic BoundedSet<V> singleton(V el);\n\n\tpublic int[] TEST_BOUNDS;\n\n}\n\nclass BoundedSetFactoryTest {\n\n\tpublic int[] TEST_BOUNDS;\n\n\t@Test\n\tpublic void testUnsaturatedAdd() {\n", "reference": "\t\tfor(int i : TEST_BOUNDS) {\n\t\t\tBoundedSetFactory<String> bsf = new BoundedSetFactory<String>(i);\n\t\t\tBoundedSet<String> bs = boundedSet(bsf,0,i-1);\n\t\t\tString t = getElement(i-1);\n\t\t\tbs.add(t);\n\t\t\tassert(bs.isSaturated() == false);\n\t\t\tassert(bs.getSize() == i);\n\t\t\tassert(! bsf.top().equals(bs));\t\t\t\t\t\t\n\t\t}\t\t\n\t}\n\n}", "prediction": "\t\tBoundedSetFactory<Integer> factory = new BoundedSetFactory<Integer>(10);\n\t\tBoundedSet<Integer> set = factory.empty();\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tset = set.add(i);\n\t\t}\n\t\tassertEquals(10, set.size());\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "1513115_4", "part": [1, 1], "seq": [1, 1], "prompt": "class HttpRequest {\n\n    public String getEncodedParameter(String name) {\n        Matcher matcher = Pattern.compile(Pattern.quote(name) + \"=([^&#]+)\").matcher(queryString);\n        if (matcher.find()) {\n            return matcher.group(1);\n        } else {\n            return Util.urlEncoder(getParameter(name));\n        }\n    }\n\n    @Deprecated public  HttpRequest(String requestURL);\n    public  HttpRequest(String requestURL, String queryString);\n    @Deprecated public  HttpRequest(String requestURL, Map<String, List<String>> parameters);\n    public  HttpRequest(String requestURL, Map<String, List<String>> parameters, String queryString);\n\n    public HttpRequest addParameter(String name, String value);\n    public HttpRequest removeParameter(String name);\n    public String getRequestURL();\n    public String getParameter(String name);\n    public List<String> getParameters(String name);\n    public Map<String, List<String>> getParameters();\n    public String getEncodedParameter(String name, String defaultValue);\n    @Override public boolean equals(Object o);\n    @Override public int hashCode();\n    @Override public String toString();\n    private static Map<String, List<String>> unmodifiableCopyOf(Map<String, List<String>> orig);\n\n}\n\nclass HttpRequestTest {\n\n    @Test\n    public void testGetEncodedParameter_stopsAtUrlFragment() throws Exception {\n", "reference": "        final String url = \"url\";\n        final String queryString = \"first=&foo=bar#ignore\";\n\n        final HttpRequest request = new HttpRequest(url, queryString);\n\n        assertThat(request.getEncodedParameter(\"foo\"), equalTo(\"bar\"));\n    }\n\n}", "prediction": "        HttpRequest request = new HttpRequest(\"http://example.com/foo?bar=baz#fragment\", \"bar=baz&baz=qux\");\n        assertEquals(\"baz\", request.getEncodedParameter(\"bar\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "1547148_17", "part": [1, 1], "seq": [1, 1], "prompt": "class StockOp {\n\n    @CoGroup\n    public void cutoff(\n            // \u5728\u5eab\u306f\u5546\u54c1\u3054\u3068\u306b\u30b0\u30eb\u30fc\u30d4\u30f3\u30b0\u3057\u3066\u3001\u3055\u3089\u306b\u5165\u8377\u9806\u306b\u4e26\u3079\u308b\n            @Key(group = \"ITEM_CODE\", order = \"PURCHASED_DATE ASC\") List<Stock> stocks,\n            // \u6ce8\u6587\u3082\u5546\u54c1\u3054\u3068\u306b\u30b0\u30eb\u30fc\u30d4\u30f3\u30b0\u3057\u3066\u3001\u3055\u3089\u306b\u51fa\u8377\u9806\u306b\u4e26\u3079\u308b\n            @Key(group = \"ITEM_CODE\", order = \"SHIPPED_DATE ASC\") List<Shipment> shipments,\n            Result<Stock> newStocks,\n            Result<Shipment> newShipments) {\n        Iterator<Stock> eachStock = stocks.iterator();\n        Iterator<Shipment> eachShipment = shipments.iterator();\n        \n        // \u5728\u5eab\u304c\u7a7a\u306b\u306a\u308b\u307e\u3067\n        while (eachStock.hasNext()) {\n            Stock stock = eachStock.next();\n            \n            // \u6ce8\u6587\u3092\u51e6\u7406\u3057\u304d\u308b\u307e\u3067\n            while (eachShipment.hasNext()) {\n                // \u3053\u306e\u5728\u5eab\u30ec\u30b3\u30fc\u30c9\u304c\u7d42\u308f\u3063\u305f\u3089\u6b21\u3078\n                if (stock.getQuantity() == 0) {\n                    break;\n                }\n                // \u6ce8\u6587\u3092\u3072\u3068\u3064\u53d6\u308a\u51fa\u3057\u3066\u51e6\u7406\n                Shipment shipment = eachShipment.next();\n                shipment.setCost(stock.getCost());\n                newShipments.add(shipment);\n                \n                // \u5728\u5eab\u3092\u6e1b\u3089\u3059\n                stock.getQuantityOption().add(-1);\n            }\n            \n            // \u73fe\u5728\u306e\u5728\u5eab\u60c5\u5831\u3092\u51fa\u529b\n            newStocks.add(stock);\n        }\n        \n        // \u51fa\u8377\u3057\u305f\u306f\u305a\u304c\u5728\u5eab\u304c\u8db3\u308a\u3066\u306a\u3044\u3067\u3059\u3088...\n        // (\u66f8\u304d\u623b\u3055\u306a\u304f\u3066\u3082\u3088\u304f\u3001\u305d\u306e\u5834\u5408\u306f\u66f4\u65b0\u3055\u308c\u306a\u3044\u3060\u3051)\n        while (eachShipment.hasNext()) {\n            Shipment shipment = eachShipment.next();\n            newShipments.add(shipment);\n        }\n    }\n\n    @Branch public ShipmentStatus checkShipment(Shipment shipment);\n\n}\n\nclass StockOpTest {\n\n    @Test\n    public void testCutoff() {\n", "reference": "        StockOpImpl operator = new StockOpImpl();\n\n        List<Stock> stocks = new ArrayList<Stock>();\n        stocks.add(StockFactory.create(new DateTime(), 0, 100, 10));\n\n        List<Shipment> shipments = new ArrayList<Shipment>();\n        shipments.add(ShipmentFactory.create(new DateTime(), 10, 100));\n\n        MockResult<Stock> newStocks = new MockResult<Stock>();\n        MockResult<Shipment> newShipments = new MockResult<Shipment>();\n\n        operator.cutoff(stocks, shipments, newStocks, newShipments);\n\n        assertThat(newStocks.getResults().size(), is(1));\n        assertThat(newShipments.getResults().size(), is(1));\n    }\n\n}", "prediction": "       \n        // \u5728\u5eab\u30c7\u30fc\u30bf\n        Stock stock1 = new Stock();\n        stock1.setItemCode(\"10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "1552601_0", "part": [1, 1], "seq": [1, 1], "prompt": "class FilePublicKeyProvider extends AbstractKeyPairProvider {\n\n  public Iterable<KeyPair> loadKeys() {\n    if (!SecurityUtils.isBouncyCastleRegistered()) {\n      throw new IllegalStateException(\"BouncyCastle must be registered as a JCE provider\");\n    }\n    List<KeyPair> keys = new ArrayList<KeyPair>();\n    for (String file : files) {\n      try {\n          Object o = KeyPairUtils.readKey(new InputStreamReader(new FileInputStream(file)));\n          if (o instanceof KeyPair) {\n            keys.add(new KeyPair(((KeyPair)o).getPublic(), null));\n          } else if (o instanceof PublicKey) {\n            keys.add(new KeyPair((PublicKey)o, null));\n          } else if (o instanceof PEMKeyPair) {\n            PEMKeyPair keyPair = (PEMKeyPair)o;\n            keys.add(convertPemKeyPair(keyPair));\n          } else if (o instanceof SubjectPublicKeyInfo) {\n            PEMKeyPair keyPair = new PEMKeyPair((SubjectPublicKeyInfo) o, null);\n            keys.add(convertPemKeyPair(keyPair));\n          } else {\n            throw new UnsupportedOperationException(String.format(\"Key type %s not supported.\", o.getClass().getName()));\n          }\n      }\n      catch (Exception e) {\n        LOG.info(\"Unable to read key {}: {}\", file, e);\n      }\n    }\n    return keys;\n  }\n\n    FilePublicKeyProvider(String[] files);\n\n  private KeyPair convertPemKeyPair(PEMKeyPair pemKeyPair);\n\n}\n\nclass FilePublicKeyProviderTest {\n\n  @Test\n  public void test() {\n", "reference": "    String pubKeyFile = Thread.currentThread().getContextClassLoader().getResource(\"test_authorized_key.pem\").getFile();\n    assertTrue(new File(pubKeyFile).exists());\n    FilePublicKeyProvider SUT = new FilePublicKeyProvider(new String[]{pubKeyFile});\n    assertTrue(SUT.loadKeys().iterator().hasNext());\n  }\n\n}", "prediction": "    FilePublicKeyProvider provider = new FilePublicKeyProvider(new String[] { \"src/test/resources/public.pem\" });\n    Iterable<KeyPair> keys = provider.loadKeys();\n    assertEquals(1, Iterables.size(keys));\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "1616402_3", "part": [1, 1], "seq": [1, 1], "prompt": "class ActionFactory {\n\n    public static BaseSpellAction construct(String actionClassName)\n            throws ActionFactoryException {\n        List<String> attempts = new ArrayList<>();\n\n        for (ActionResolver resolver : resolvers) {\n            ActionConstructor constructor = resolver.resolve(actionClassName,\n                    attempts);\n\n            if (constructor != null) {\n                return constructor.construct();\n            }\n        }\n\n        throw new ActionFactoryException(\n                \"Failed to resolve class: \" + actionClassName + \"\\nTried: \"\n                        + attempts);\n    }\n\n    private  ActionFactory();\n\n    public static List<ActionResolver> getActionResolvers();\n    public static void registerResolver(ActionResolver actionResolver);\n    public static void registerResolver(ActionResolver actionResolver,\n            boolean highPriority);\n    public static void removeResolver(ActionResolver actionResolver);\n    public static void registerActionClass(String name, Class<?> clazz);\n\n}\n\nclass ActionFactoryTest {\n\n    @Test\n    public void testInternalClass() throws ActionFactoryException {\n", "reference": "        assertTrue(ActionFactory.construct(\n                \"Absorb\") instanceof AbsorbAction);\n        assertTrue(ActionFactory.construct(\n                \"AbsorbAction\") instanceof AbsorbAction);\n        assertTrue(ActionFactory.construct(\n                \"com.elmakers.mine.bukkit.action.builtin.Absorb\") instanceof AbsorbAction);\n        assertTrue(ActionFactory.construct(\n                \"com.elmakers.mine.bukkit.action.builtin.AbsorbAction\") instanceof AbsorbAction);\n    }\n\n}", "prediction": "        ActionFactory.registerResolver(new ActionResolver() {\n\n            @Override\n            public ActionConstructor resolve(String actionClassName,\n                    List<String> attempts) {\n                if (actionClassName.equals(\"com.example.ActionFactoryTest$TestAction\")) {\n                    return new ActionConstructor() {\n\n                        @Override\n                        public BaseSpellAction construct() {\n                            return new TestAction();\n                        }\n                    };\n                }\n\n                return null;\n            }\n\n        });\n\n        BaseSpellAction action = ActionFactory.construct(\"com.example.ActionFactoryTest$TestAction\");\n\n        assertTrue(action instanceof TestAction);\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "1641128_5", "part": [1, 1], "seq": [1, 1], "prompt": "class JanbaneryFactory {\n\n  public JanbaneryToWorkspace connectUsing(Configuration configuration) {\n    RestClient restClient = getRestClient(configuration);\n    return new JanbaneryToWorkspace(new Janbanery(configuration, restClient));\n  }\n\n  public  JanbaneryFactory();\n  public  JanbaneryFactory(AsyncHttpClient asyncHttpClient);\n  public  JanbaneryFactory(RestClient restClient);\n\n  public JanbaneryToWorkspace connectUsing(String apiKey);\n  public JanbaneryToWorkspace connectUsing(String user, String password);\n  private String getCurrentUserApiKey(Janbanery janbanery);\n  public Janbanery connectAndKeepUsing(String user, String password);\n  private RestClient getRestClient(Configuration configuration);\n  public void setAsyncHttpClient(AsyncHttpClient asyncHttpClient);\n  public void setEncodedBodyGenerator(ReflectionBodyGenerator encodedBodyGenerator);\n  public void setGson(Gson gson);\n\n   AsyncHttpClient asyncHttpClient;\n   Configuration configuration;\n   JanbaneryFactory janbaneryFactory;\n   Janbanery janbanery;\n\n}\n\nclass JanbaneryFactoryTest {\n\n   AsyncHttpClient asyncHttpClient;\n   Configuration configuration;\n   JanbaneryFactory janbaneryFactory;\n   Janbanery janbanery;\n\n  @Test\n  public void shouldLoginWithUserPassButThenFallbackToApiKeyMode() throws Exception {\n", "reference": "    // given\n    Properties properties = new Properties();\n    properties.load(new FileInputStream(VALID_CONF_FILE_LOCATION));\n    String user = (String) properties.get(\"username\");\n    String password = (String) properties.get(\"password\");\n\n    // when\n    janbanery = janbaneryFactory.connectUsing(user, password).toWorkspace(EXISTING_WORKSPACE);\n\n    // then, should use API key mode\n    AuthProvider usedAuthProvider = janbanery.getAuthMode();\n    assertThat(usedAuthProvider).isInstanceOf(ApiKeyAuthProvider.class);\n  }\n\n}", "prediction": "    // given\n    String apiKey = \"apiKey\";\n    String user = \"user\";\n    String password = \"password\";\n    given(janbanery.getCurrentUserApiKey()).willReturn(apiKey);\n\n    // when\n    JanbaneryToWorkspace janbaneryToWorkspace = janbaneryFactory.connectUsing(user, password);\n\n    // then\n    assertThat(janbaneryToWorkspace.getWorkspace().getConfiguration().getApiKey(), is(apiKey));\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "1644710_0", "part": [1, 1], "seq": [1, 1], "prompt": "class RestBuilder {\n\n    public Model buildModel(Iterable<NamedInputSupplier> suppliers) throws IOException {\n        List<Model> models = Lists.newArrayList();\n        for (NamedInputSupplier supplier : suppliers) {\n            Model model = buildModel(supplier);\n            models.add(model);\n        }\n\n        return new MultiModel(models).resolve();\n    }\n\n    public boolean isTracingEnabled();\n    public void setTracingEnabled(boolean tracingEnabled);\n    private Model buildModel(NamedInputSupplier supplier);\n\n    private Model model;\n\n}\n\nclass RestBuilderTest {\n\n    private Model model;\n\n    @Test\n    public void testBuildModel() throws Exception {\n", "reference": "\n        assertThat(model)\n                .describedAs(\"A restbuilder model object\")\n                .isNotNull()\n                .isInstanceOf(Model.class);\n\n        assertThat(model.getNamespace()).isEqualTo(\"example\");\n        assertThat(model.getOperations()).isNotEmpty().hasSize(2);\n\n        Resource accountResource = model.getResources().get(\"account\");\n        assertThat(accountResource.getPreamble()).isNotEmpty();\n        assertThat(accountResource.getComment()).isNotEmpty();\n\n        Operation cancellationOperation = accountResource.getOperations().get(\"cancellation\");\n        assertThat(cancellationOperation.getAttributes()).isNotEmpty();\n\n    }\n\n}", "prediction": "        model = new RestBuilder().buildModel(new NamedInputSupplier() {\n            @Override\n            public String getName() {\n                return \"test\";\n            }\n\n            @Override\n            public InputSupplier getInputSupplier() {\n                return new InputSupplier() {\n                    @Override\n                    public InputStream getInput() throws IOException {\n                        return new ByteArrayInputStream(\"test\".getBytes());\n                    }\n                };\n            }\n        });\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "1654390_2", "part": [1, 1], "seq": [1, 1], "prompt": "class GWTIO {\n\n    public static Streamable.Input newInput (Serializer szer, String data) {\n        return new ClientInput(szer, data);\n    }\n\n    private  GWTIO();\n\n    public static Streamable.Output newOutput(Serializer szer, StringBuffer output);\n\n    protected final IOTester.Checker CHECKER;\n\n}\n\nclass GwtTestIO  {\n\n    protected final IOTester.Checker CHECKER;\n\n    @Test\n    public void testValueInput () {\n", "reference": "        IOTester.checkValue(\n            GWTIO.newInput(new TestSerializer(), IOTester.VALUE_IN_PAYLOAD), CHECKER);\n    }\n\n}", "prediction": "        String data = \"1234567890\";\n        Streamable.Input in = GWTIO.newInput(new ValueSerializer(), data);\n        assertEquals(data, in.readString());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "1973010_6", "part": [1, 1], "seq": [1, 1], "prompt": "class NaiveIndex extends Index {\n\n  @Override\n  public SeekingCurrentIterator handleGet(byte[] indexRangeStart,\n      byte[] indexRangeEnd) {\n\n    TableAdapter dataTable = getIndexTable();\n\n    // Just need to return a SelectRowId on the rowId and use its\n    // getResultsIterator\n    // to return the row IDs\n    KeyOnlyFilter selectRowId = new KeyOnlyFilter(dataTable, new CRange(\n        indexRangeStart, indexRangeEnd));\n    return selectRowId.getResultIterator();\n  }\n\n  @Override public void handlePut(Put put);\n\n  private final String tableName;\n  private NaiveIndex naiveIndex;\n  private final byte[] aaaRowId;\n  private final byte[] bbbRowId;\n  private final byte[] cccRowId;\n  private final ArrayList<byte[]> rowIdList;\n  private final byte[] colFam;\n  private final byte[] colQual;\n  private final byte[] value;\n\n}\n\nclass NaiveIndexTest {\n\n  private final String tableName;\n  private NaiveIndex naiveIndex;\n  private final byte[] aaaRowId;\n  private final byte[] bbbRowId;\n  private final byte[] cccRowId;\n  private final ArrayList<byte[]> rowIdList;\n  private final byte[] colFam;\n  private final byte[] colQual;\n  private final byte[] value;\n\n  @Test\n  public void testGetRange() {\n", "reference": "    SeekingCurrentIterator indexIterator = naiveIndex.handleGet(cccRowId,\n        cccRowId);\n\n    // Test the returned data\n    int count = 0;\n    while (indexIterator.hasNext()) {\n      Result result = indexIterator.next();\n      count++;\n\n      assertTrue(Bytes.compareTo(result.getRecordId(), cccRowId) == 0);\n    }\n\n    // Test if we have the expected number of results\n    assertTrue(count == 1);\n  }\n\n}", "prediction": "    SeekingCurrentIterator iterator = naiveIndex.handleGet(aaaRowId, bbbRowId);\n    assertTrue(iterator.hasNext());\n    assertEquals(aaaRowId, iterator.next());\n    assertTrue(iterator.hasNext());\n    assertEquals(bbbRowId, iterator.next());\n    assertFalse(iterator.hasNext());\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "2017533_6", "part": [1, 1], "seq": [1, 1], "prompt": "class FlacAudioFileReader extends AudioFileReader {\n\n    public AudioInputStream getAudioInputStream(File file) throws UnsupportedAudioFileException, IOException {\n        InputStream inputStream = new FileInputStream(file);\n        try {\n            return getAudioInputStream(inputStream, (int) file.length());\n        } catch (UnsupportedAudioFileException e) {\n            try {\n                inputStream.close();\n            } catch (IOException e1) {\n                e1.printStackTrace();\n            }\n            throw e;\n        } catch (IOException e) {\n            try {\n                inputStream.close();\n            } catch (IOException e1) {\n                e1.printStackTrace();\n            }\n            throw e;\n        }\n    }\n\n    public AudioFileFormat getAudioFileFormat(File file);\n    public AudioFileFormat getAudioFileFormat(URL url);\n    public AudioFileFormat getAudioFileFormat(InputStream stream);\n    protected AudioFileFormat getAudioFileFormat(InputStream bitStream, int mediaLength);\n    public AudioInputStream getAudioInputStream(URL url);\n    public AudioInputStream getAudioInputStream(final InputStream stream);\n    protected AudioInputStream getAudioInputStream(InputStream inputStream, int medialength);\n\n}\n\nclass FlacAudioFileReaderTest {\n\n    @Test\n    public void testGetAudioInputStreamWithUnsupportedFile() throws IOException {\n", "reference": "        final FlacAudioFileReader flacAudioFileReader = new FlacAudioFileReader();\n        final File file = File.createTempFile(\"flacTest\", \".wav\");\n        final OutputStream out = new FileOutputStream(file);\n        out.write(new byte[2048]);\n        out.close();\n        try {\n            flacAudioFileReader.getAudioInputStream(file);\n            fail(\"Expected UnsupportedAudioFileException\");\n        } catch (UnsupportedAudioFileException e) {\n            // expected this\n        } finally {\n            file.delete();\n        }\n    }\n\n}", "prediction": "        try {\n            FlacAudioFileReader reader = new FlacAudioFileReader();\n            reader.getAudioInputStream(new File(\"src/test/resources/unsupported.txt\"));\n            fail(\"UnsupportedAudioFileException expected\");\n        } catch (UnsupportedAudioFileException e) {\n            // expected\n        }\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "2045140_24", "part": [1, 1], "seq": [1, 1], "prompt": "class RequireOsgiCompatibleVersionRule implements EnforcerRule {\n\n    public void ensureValidOsgiVersion(String version) throws EnforcerRuleException\n    {\n        if (version.endsWith(\"SNAPSHOT\"))\n        {\n            // Skip check on SNAPSHOT versions.\n            return;\n        }\n        \n        String parts[] = version.split(\"\\\\.\");\n        if (parts.length > 4)\n        {\n            throw new EnforcerRuleException(\"The version \\\"\" + version + \"\\\" does not conform to the OSGi version requirements.  \"\n                    + \"It can't have more than 4 parts (#.#.#.*)\" + \" - The '.' character has a special meaning\");\n        }\n\n        if (parts.length < 3)\n        {\n            throw new EnforcerRuleException(\"The version \\\"\" + version + \"\\\" does not conform to the OSGi version requirements.  \"\n                    + \"It must have 3 (or 4) parts (#.#.#.*)\");\n        }\n\n        for (int i = 0; i < 3; i++)\n        {\n            if (!StringUtils.isNumeric(parts[i]))\n            {\n                throw new EnforcerRuleException(\"The version \\\"\" + version + \"\\\" does not conform to the OSGi version requirements.  \" + \"Part #\" + (i + 1)\n                        + \" \\\"\" + parts[i] + \"\\\" of an OSGi version must be a non-negative number (#.#.#.*).\");\n            }\n            if (Integer.parseInt(parts[i]) < 0)\n            {\n                throw new EnforcerRuleException(\"The version \\\"\" + version + \"\\\" does not conform to the OSGi version requirements.  \" + \"Part #\" + (i + 1)\n                        + \" \\\"\" + parts[i] + \"\\\" of an OSGi version must be a non-negative number (#.#.#.*).\");\n            }\n        }\n\n        if (parts.length == 4)\n        {\n            for (char c : parts[3].toCharArray())\n            {\n                if ((c >= '0') && (c <= '9'))\n                {\n                    continue; // numbers are acceptable\n                }\n                if ((c >= 'A') && (c <= 'Z'))\n                {\n                    continue; // upper case letters are acceptable\n                }\n                if ((c >= 'a') && (c <= 'z'))\n                {\n                    continue; // lower case letters are acceptable\n                }\n                if ((c == '-') || (c == '_'))\n                {\n                    continue; // underscore and dash are also acceptable\n                }\n                // All other characters are invalid for the qualifier\n                throw new EnforcerRuleException(\"The OSGi qualifier of \\\"\" + version + \"\\\" does not conform to the OSGi version requirements.  \" + \n                        \"Only Letters (upper and lower), numbers, dash '-', and underscore '_' are allowed.\");\n            }\n        }\n    }\n\n    public void execute(EnforcerRuleHelper helper);\n    public String getCacheId();\n    public boolean isCacheable();\n    public boolean isResultValid(EnforcerRule rule);\n\n}\n\nclass RequireOsgiCompatibleVersionRuleTest {\n\n    @Test\n    public void testInvalidQualifierOsgiVersion()\n        throws EnforcerRuleException\n    {\n", "reference": "        Assertions.assertThrows( EnforcerRuleException.class, () -> {\n            RequireOsgiCompatibleVersionRule rule = new RequireOsgiCompatibleVersionRule();\n            rule.ensureValidOsgiVersion( \"1.0.2.2009:05:12\" );\n        } );\n    }\n\n}", "prediction": "       RequireOsgiCompatibleVersionRule rule = new RequireOsgiCompatibleVersionRule();\n        try\n        {\n            rule.ensureValidOsgiVersion(\"1.0.0.1-SNAPSHOT\");\n            fail(\"Should have thrown an exception\");\n        }\n        catch (EnforcerRuleException e)\n        {\n            assertThat(e.getMessage(), containsString(\"The OSGi qualifier of \\\"1.0.0.1-SNAPSHOT\\\" does not conform to the OSGi version requirements.\"));\n        }\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "2108481_1", "part": [1, 1], "seq": [1, 1], "prompt": "class IssuerClaimVerifier implements JwtClaimsSetVerifier {\n\n\t@Override\n\tpublic void verify(Map<String, Object> claims) throws InvalidTokenException {\n\t\tif (!CollectionUtils.isEmpty(claims) && claims.containsKey(ISS_CLAIM)) {\n\t\t\tString jwtIssuer = (String)claims.get(ISS_CLAIM);\n\t\t\tif (!jwtIssuer.equals(this.issuer.toString())) {\n\t\t\t\tthrow new InvalidTokenException(\"Invalid Issuer (iss) claim: \" + jwtIssuer);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic  IssuerClaimVerifier(URL issuer);\n\n\tprivate static final String DEFAULT_ISSUER;\n\tprivate IssuerClaimVerifier issuerClaimVerifier;\n\n}\n\nclass IssuerClaimVerifierTest {\n\n\tprivate static final String DEFAULT_ISSUER;\n\tprivate IssuerClaimVerifier issuerClaimVerifier;\n\n\t@Test\n\tpublic void verifyWhenJwtClaimsSetContainsValidIssuerThenVerificationSucceeds() throws Exception {\n", "reference": "\t\tMap<String, Object> claims = new HashMap<String, Object>();\n\t\tclaims.put(\"iss\", DEFAULT_ISSUER);\n\t\tthis.issuerClaimVerifier.verify(claims);\n\t}\n\n}", "prediction": "\t\tMap<String, Object> claims = new HashMap<>();\n\t\tclaims.put(IssuerClaimVerifier.ISS_CLAIM, DEFAULT_ISSUER);\n\t\tissuerClaimVerifier.verify(claims);\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "2199098_75", "part": [1, 1], "seq": [1, 1], "prompt": "class DefaultRightLoader extends AbstractLogEnabled implements RightLoader {\n\n    @Override\n    public AccessLevel load(DocumentReference user, EntityReference entity)\n        throws RightServiceException\n    {\n        int retries = 0;\n    RETRY: \n        while (true) {\n            rightCacheInvalidator.suspend();\n\n            try {\n                retries++;\n                return loadRequiredEntries(user, entity);\n            } catch (ParentEntryEvictedException e) {\n                if (retries < MAX_RETRIES) {\n                    getLogger().debug(\"The parent entry was evicted. Have tried \" \n                                      + retries\n                                      + \" times.  Trying again...\");\n                    continue RETRY;\n                }\n            } catch (ConflictingInsertionException e) {\n                if (retries < MAX_RETRIES) {\n                    getLogger().debug(\"There were conflicting insertions.  Have tried \"\n                                      + retries\n                                      + \" times.  Retrying...\");\n                    continue RETRY;\n                }\n            } finally {\n                rightCacheInvalidator.resume();\n            }\n            getLogger().error(\"Failed to load the cache in \"\n                              + retries\n                              + \" attempts.  Giving up.\");\n            throw new RightServiceException();\n        }\n    }\n\n    private AccessLevel loadRequiredEntries(DocumentReference user, EntityReference entity);\n    private AccessLevel loadUserAtEntity(DocumentReference user, EntityReference entity);\n    private Collection<DocumentReference> loadGroupEntries(DocumentReference user);\n    private List<Collection<RightsObject>> getRightsObjects(RightCacheKey entityKey, EntityReference entity);\n    private RightCacheEntry loadRightsObjects(EntityReference entity);\n\n}\n\nclass DefaultRightLoaderTest extends AbstractLogEnabled {\n\n    @Test \n    public void testRightLoader()\n    {\n", "reference": "        DocumentReference userX = docRefResolver.resolve(\"wikiY:XWiki.userX\");\n        DocumentReference userY = docRefResolver.resolve(\"wikiY:XWiki.userY\");\n        DocumentReference userZ = docRefResolver.resolve(\"xwiki:XWiki.userZ\");\n        DocumentReference admin = docRefResolver.resolve(\"xwiki:XWiki.Admin\");\n\n        MockDocument wikiDocument = new MockDocument(\"xwiki:XWiki.XWikiPreferences\", \"xwiki:XWiki.Admin\");\n        MockDocument allGroupDocument = MockDocument.newGroupDocument(\"xwiki:XWiki.XWikiAllGroup\", \n                                                                      new String[]{\"wikiY:XWiki.userX\", \n                                                                                   \"wikiY:XWiki.userY\" });\n        wiki.add(new MockDocument(userX, \"xwiki:XWiki.Admin\")\n                 .allowLocal(asList(new Right[]{EDIT }),\n                             asList(new String[]{\"wikiY:XWiki.userX\"}),\n                             EMPTY_LIST ))\n            .add(new MockDocument(userY, \"xwiki:XWiki.Admin\")\n                 .allowLocal(asList(new Right[]{EDIT }),\n                             asList(new String[]{\"wikiY:XWiki.userY\"}),\n                             EMPTY_LIST ))\n            .add(wikiDocument)\n            .add(allGroupDocument);\n\n        try {\n            mockery.checking(new Expectations() {{\n                allowing(mockGroupService)\n                    .getAllGroupsNamesForMember(\"wikiY:XWiki.userX\", Integer.MAX_VALUE, 0, xwikiContext);\n                will(returnValue(asList(new String[]{\"XWiki.XWikiAllGroup\"})));\n                allowing(mockGroupService)\n                    .getAllGroupsNamesForMember(\"wikiY:XWiki.userY\", Integer.MAX_VALUE, 0, xwikiContext);\n                will(returnValue(asList(new String[]{\"XWiki.XWikiAllGroup\"})));\n            }});\n\n            RightLoader loader = getComponentManager().lookup(RightLoader.class);\n            RightCache  cache  = getComponentManager().lookup(RightCache.class);\n            RightCacheInvalidator invalidator = getComponentManager().lookup(RightCacheInvalidator.class);\n\n            AccessLevel edit = AccessLevel.DEFAULT_ACCESS_LEVEL.clone();\n            edit.allow(EDIT);\n\n            AccessLevel level = loader.load(userX, userX);\n            System.out.println(\"Level is \" + level + \", expected \" + edit);\n            assertTrue(level.equals(edit));\n\n            RightCacheEntry entry = cache.get(cache.getRightCacheKey(userX), cache.getRightCacheKey(userX));\n            assertTrue(entry != null);\n            assertTrue(entry.equals(level));\n\n            entry = cache.get(cache.getRightCacheKey(userX));\n            assertTrue(entry != null);\n            assertTrue(entry.getType() == RightCacheEntry.Type.HAVE_OBJECTS);\n\n            entry = cache.get(cache.getRightCacheKey(userX.getParent()));\n            assertTrue(entry != null);\n            assertTrue(entry.getType() == RightCacheEntry.Type.HAVE_NO_OBJECTS);\n\n            entry = cache.get(cache.getRightCacheKey(userX.getParent().getParent()));\n            assertTrue(entry != null);\n            assertTrue(entry.getType() == RightCacheEntry.Type.HAVE_OBJECTS);\n\n            ((EventListener) invalidator).onEvent(null, wikiDocument, null);\n\n            entry = cache.get(cache.getRightCacheKey(userX), cache.getRightCacheKey(userX));\n            assertTrue(entry == null);\n\n            entry = cache.get(cache.getRightCacheKey(userX));\n            assertTrue(entry == null);\n\n            entry = cache.get(cache.getRightCacheKey(userX.getParent()));\n            assertTrue(entry == null);\n\n            entry = cache.get(cache.getRightCacheKey(userX.getParent().getParent()));\n            assertTrue(entry == null);\n\n            wikiDocument.denyGlobal(asList(new Right[]{COMMENT }),\n                                    EMPTY_LIST,\n                                    asList(new String[]{\"wikiY:XWiki.XWikiAllGroup\" }));\n\n            AccessLevel editNoComment = edit.clone();\n            editNoComment.deny(COMMENT);\n            level = loader.load(userX, userX);\n            assertTrue(level.equals(editNoComment));\n\n            mockery.checking(new Expectations() {{\n                allowing(mockGroupService).getAllMembersNamesForGroup(\"xwiki:XWiki.GroupX\", 100, 0, xwikiContext);\n                will(returnValue(asList(new String[]{\"wikiY:XWiki.userX\"})));\n            }});\n            MockDocument group = MockDocument.newGroupDocument(\"XWiki.GroupX\", new String[] {\"wikiY:XWiki.userX\" } );\n            wiki.add(group);\n            ((EventListener) invalidator).onEvent(null, group, null);\n\n            entry = cache.get(cache.getRightCacheKey(userX));\n            assertTrue(\"Invalidating cache after group update\", entry == null);\n\n            entry = cache.get(cache.getRightCacheKey(userX), cache.getRightCacheKey(userX));\n            assertTrue(\"Invalidating cache after group update\", entry == null);\n\n            entry = cache.get(cache.getRightCacheKey(userX.getParent()));\n            assertTrue(\"Invalidating cache after group update\", entry != null);\n\n            entry = cache.get(cache.getRightCacheKey(userX.getParent().getParent()));\n            assertTrue(\"Invalidating cache after group update\", entry != null);\n            \n\n        } catch (Exception e) {\n            LOG.error(\"Caught exception.\", e);\n            assert false;\n        }\n    }\n\n}", "prediction": "        RightLoader loader = new DefaultRightLoader();\n        DocumentReference user = new DocumentReference(\"user\");\n        EntityReference entity = new EntityReference(\"entity\");\n        AccessLevel accessLevel = loader.load(user, entity);\n        assertEquals(AccessLevel.NONE, accessLevel);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "2254581_8", "part": [1, 1], "seq": [1, 1], "prompt": "class DMZSyncServiceImpl extends RemoteServiceServlet implements\n\t\tDMZSyncService {\n\n\tprotected String sendData(String json,String url) throws DMZSyncException {\n\n\t\tHttpClient httpClient = new HttpClient();\n\t\tString ret = \"\";\t\n\t    \n\t\tPostMethod postMethod = new PostMethod(url);\n\n\t\tNameValuePair[] registerInform = new NameValuePair[1];\n\t\tregisterInform[0] = new NameValuePair(\"data\", json);\n\n\t\tpostMethod.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded; charset=utf-8\");\n\t\tpostMethod.setRequestBody(registerInform);\n\t\t\n\t\tauthenticate(httpClient, postMethod);\n\n\t\tint statusCode = 0;\n\t\ttry {\n\t\t\tstatusCode = httpClient.executeMethod(postMethod);\n\t\t\t\n\t\t\t\tret = postMethod.getResponseBodyAsString();\n\t\t\t\t\n\t\t\t\t\n\t\t} catch (HttpException e) {\n\t\t\tthrow new DMZSyncException(DMZSyncExceptionType.HTTP_EXCEPTION,url+\": \"+e.getMessage());\n\t\t} catch (IOException e1) {\n\t\t\tthrow new DMZSyncException(DMZSyncExceptionType.CONNECT_HOST_ADDRESS_EXCEPTION,url+\": \"+e1.getMessage());\n\t\t}\n\t\tif(ret.equals(\"Data Error\")){\n\t\t\tthrow new DMZSyncException(DMZSyncExceptionType.RUN_TIME_EXCEPTION,\": \"+ret);\n\t\t}\n\n\t\tif (!(statusCode == HttpStatus.SC_MOVED_PERMANENTLY || statusCode == HttpStatus.SC_MOVED_TEMPORARILY)) {\n\t\t\tSystem.err.println(\"field.\");\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\n\t@Override public List<String> pushToDMZ(Long standardizedPatientId,String locale);\n\tprivate String processSendJson(String json,String locale);\n\tprotected List<String> getSendReturnErrorMessage(String json);\n\t@Override public void pullFromDMZ(Long standardizedPatientId);\n\t@Override public String sendSync(String locale);\n\t@Override public void getSync(String locale);\n\tprivate String getReturnMessage(JSONObject myjson);\n\tprivate void syncOsceDayAndTraining(JSONObject myjson);\n\tprivate void syncOsceDay(JSONObject myjson);\n\tprivate void syncPatientInSemester(JSONObject myjson);\n\tprivate void setOsceDays(JSONObject jsonObject,PatientInSemester semester);\n\tprotected String getSyncJsonData(String locale);\n\tprivate String getOsceDayJsonStr(OsceDay osceDay);\n\tprivate String getSemesterJsonStr(Semester semester);\n\tprivate String getPatientInSemester(PatientInSemester pis);\n\tprivate String getOscesJsonStr(Osce osce);\n\tprivate String getStandardizedPatientJsonStr(PatientInSemester patient);\n\tprivate String convertToString(Date date);\n\tprivate Date convertToDate(String dateStr);\n\tprivate void setDMZSyncExceptionTypeAndErrorMsg(String type,String msg);\n\tprivate void updatePatient(StandardizedPatient patient,StandardizedPatient newPatient);\n\tprivate void updateChecksValue(AnamnesisChecksValue checksValue,AnamnesisChecksValue newChecksValue,AnamnesisForm anamnesisForm);\n\tprivate void saveChecksValue(AnamnesisChecksValue newChecksValue,AnamnesisForm anamnesisForm);\n\tpublic String preProcessData(String data);\n\tprotected StandardizedPatient findPatient(Long objectId);\n\tprotected String getDMZData(String url);\n\tprotected String getHostAddress();\n\tprivate void authenticate(HttpClient client, HttpMethodBase method);\n\tprotected void savePatient(StandardizedPatient patient);\n\t HttpServletRequest getRequest();\n\n    private MyDMZSyncServiceImpl instance;\n    private StandardizedPatient currentSP;\n    private String dataFromDMZ;\n    private String expectedURL;\n    private String locale;\n    private StandardizedPatient testData;\n    private StandardizedPatient patient1;\n    private StandardizedPatient patient2;\n    private String returnData;\n\n}\n\nclass DMZSyncServiceImplTest extends RemoteServiceServlet {\n\n    private MyDMZSyncServiceImpl instance;\n    private StandardizedPatient currentSP;\n    private String dataFromDMZ;\n    private String expectedURL;\n    private String locale;\n    private StandardizedPatient testData;\n    private StandardizedPatient patient1;\n    private StandardizedPatient patient2;\n    private String returnData;\n\n    @Test\n    public void testSendData() {\n", "reference": "        MyDMZSyncServiceImpl instance2 = new MyDMZSyncServiceImpl();\n\n        returnData = \"{\\\"class\\\":\\\"sp_portal.local.StandardizedPatient\\\",\\\"id\\\":23,\\\"anamnesisForm\\\":{\\\"class\\\":\\\"sp_portal.local.AnamnesisForm\\\",\\\"id\\\":5,\\\"createDate\\\":\\\"2009-09-18T16:00:00Z\\\",\\\"origId\\\":6,\\\"standardizedPatients\\\":[{\\\"_ref\\\":\\\"../..\\\",\\\"class\\\":\\\"sp_portal.local.StandardizedPatient\\\"}]},\\\"bankaccount\\\":{\\\"class\\\":\\\"sp_portal.local.Bankaccount\\\",\\\"id\\\":5,\\\"bankName\\\":\\\"KTS\\\",\\\"bic\\\":\\\"BENDSFF1JEV\\\",\\\"city\\\":null,\\\"iban\\\":\\\"CH78 5685 7565 4364 7\\\",\\\"origId\\\":31,\\\"ownerName\\\":null,\\\"postalCode\\\":null,\\\"standardizedPatients\\\":[{\\\"_ref\\\":\\\"../..\\\",\\\"class\\\":\\\"sp_portal.local.StandardizedPatient\\\"}]},\\\"birthday\\\":\\\"1965-09-23T16:00:00Z\\\",\\\"city\\\":\\\"PaulVille\\\",\\\"description\\\":null,\\\"email\\\":\\\"beddebu@hss.ch\\\",\\\"gender\\\":1,\\\"height\\\":182,\\\"immagePath\\\":null,\\\"maritalStatus\\\":null,\\\"mobile\\\":\\\"078 586 29 84\\\",\\\"name\\\":\\\"Buser\\\",\\\"nationality\\\":{\\\"class\\\":\\\"sp_portal.local.Nationality\\\",\\\"id\\\":2,\\\"nationality\\\":\\\"Deutschland\\\",\\\"origId\\\":6},\\\"origId\\\":23,\\\"postalCode\\\":4051,\\\"preName\\\":\\\"Bettina\\\",\\\"profession\\\":{\\\"class\\\":\\\"sp_portal.local.Profession\\\",\\\"id\\\":5,\\\"origId\\\":6,\\\"profession\\\":\\\"Florist/in\\\"},\\\"socialInsuranceNo\\\":null,\\\"street\\\":\\\"Rankenbergweg 1\\\",\\\"telephone\\\":\\\"9999999999\\\",\\\"telephone2\\\":null,\\\"videoPath\\\":null,\\\"weight\\\":82,\\\"workPermission\\\":null}\";\n\t\tString excptedData = null;\n\t\ttry {\n\t\t    String url = instance2.getHostAddress() + \"/DataImportExport/importSP\";\n\t\t\texcptedData = instance2.sendData(returnData,url);\n\t\t} catch (Exception e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t\te.getCause().printStackTrace();\n\t\t\tAssert.fail(\"error occured \" + e.getMessage());\t\t\t\n\t\t}\n\n\t\tassertEquals(excptedData,returnData);\n    }\n\n}", "prediction": "       \n        String json = \"{\\\"name\\\":\\\"test\\\"}\";\n        String url = \"http://localhost:8888/dmz/sync\";\n        String ret = instance.sendData(json,url);\n        assertEquals(ret, \"{\\\"name\\\":\\\"test\\\"}\");\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "2280644_8", "part": [1, 1], "seq": [1, 1], "prompt": "class GraalReflectionFileGenerator {\n\n    public void generateReflection(CommandLineParser<CommandInvocation> parser, Writer w) throws IOException {\n        w.append('[').append(getLineSeparator());\n        processCommand(parser, w);\n        appendOptions(w);\n        w.append(getLineSeparator()).append(\"]\");\n    }\n\n    public  GraalReflectionFileGenerator();\n\n    private void processCommand(CommandLineParser<CommandInvocation> parser, Writer w);\n    private void parseCommand(ProcessedCommand<Command<CommandInvocation>, CommandInvocation> command, Writer w);\n    private void appendOptions(Writer w);\n    private void appendDefaults(Writer w);\n    private void appendCommand(ProcessedCommand<Command<CommandInvocation>, CommandInvocation> command, Writer w);\n\n}\n\nclass GraalReflectionFileGeneratorTest {\n\n    @Test\n    public void testCommandWithFileOption() throws IOException {\n", "reference": "\n        GraalReflectionFileGenerator generator = new GraalReflectionFileGenerator();\n        CommandLineParser<CommandInvocation> parser = getParser(TestCommand3.class);\n\n        StringWriter writer = new StringWriter();\n        generator.generateReflection(parser, writer);\n        assertEquals(readFile(\"src/test/resources/graal3\"), writer.toString());\n    }\n\n}", "prediction": "        CommandLineParser<CommandInvocation> parser = new CommandLineParser<>(new CommandInvocation());\n        parser.addCommand(\"test\", new TestCommand());\n        StringWriter w = new StringWriter();\n        new GraalReflectionFileGenerator().generateReflection(parser, w);\n        assertEquals(\"[test.file=java.io.File, test.file.name=java.lang.String, test.file.path=java.lang.String, test.file.absolute=boolean, test.file.absolutePath=java.lang.String, test.file.canonicalPath=java.lang.String, test.file.canRead=boolean, test.file.canWrite=boolean, test.file.createNewFile=boolean, test.file.delete=boolean, test.file.deleteOnExit=boolean, test.file.exists=boolean, test.file.extension=java.lang.String, test.file.isAbsolute=boolean, test.file.isDirectory=boolean, test.file.isFile=boolean, test.file.isHidden=boolean, test.file.lastModified=long, test.file.length=long, test.file.list=java.util.List, test.file.listFiles=java.io.File[], test.file.listFiles(java.io.FileFilter)=java.io.File[], test.file.listFiles(java.io.FilenameFilter)=java.io.File[], test.file.listFiles(java.io.FileFilter, java.io.FilenameFilter)=java.io.File[], test.file.mkdir=boolean, test.file.mkdirs=boolean, test.file.name=java.lang.String, test.file.parent=java.io.File, test.file.parentFile=java.io.File, test.file.path=java.lang.String, test.file.renameTo(java.io.File)=boolean, test.file.setExecutable(boolean, boolean)=boolean, test.file.setExecutable(boolean)=boolean, test.file.setLastModified(long)=boolean, test.file.setReadable(boolean, boolean)=boolean, test.file.setReadable(boolean)=boolean, test.file.setReadOnly=boolean, test.file.setWritable(boolean, boolean)=boolean, test.file.setWritable(boolean)=boolean, test.file.toPath=java.nio.file.Path, test.file.toURI=java.net.URI, test.file.toURL=java.net.URL, test.file.toURL(java.lang.String)=java.net.URL, test.file.toURI(java.lang.String)=java.net.URI, test.file.toURI(java.lang.String, java.lang.String)=java.net.URI, test.file.toURI(java.lang.String, java.lang.String, java.lang.String)=java.net.URI, test.file.toURI(java.lang.String, java.lang.String, java.lang.String, java.lang.String)=java.net.URI, test.file.toURI(java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String)=java.net.URI, test.file.toURI(java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String)=java.net.URI, test.file.toURI(java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String)=java.net.URI, test.file.toURI(java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "2310387_46", "part": [1, 1], "seq": [1, 1], "prompt": "class XcodeBuilder extends Builder implements Script {\n\n    public Element getElementFromLine(String line) {\n        if (hitBuildFailedMessage) {\n            return messageAtLevel(line, \"error\");\n        }\n        \n        Element e = messageAtLevelIfContains(line, \"warn\", \" warning: \");\n        if (e != null) {\n            return e;\n        }\n        \n        e = messageAtLevelIfContains(line, \"error\", \" error: \");\n        if (e != null) {\n            return e;\n        }\n        \n        e = messageAtLevelIfContains(line, \"error\", \"** BUILD FAILED **\");\n        if (e != null) {\n            hitBuildFailedMessage = true;\n            return e;\n        }\n\n        return null;\n    }\n\n    @Override public Element build(Map<String, String> properties, Progress progressIn);\n     void setProperties(Map<String, String> properties);\n    private void runScript(OutputFile file);\n     ScriptRunner createScriptRunner();\n     OutputFile createOutputFile(Directory d, String filename);\n     Element elementFromFile(OutputFile file);\n    @Override public Element buildWithTarget(Map<String, String> properties, String target, Progress progress);\n    @Override public void validate();\n    public Commandline buildCommandline();\n    public int getExitCode();\n    public void setExitCode(int result);\n    public void setDirectory(String path);\n    private Element messageAtLevelIfContains(String line, String messageLevel, String semaphore);\n    private Element messageAtLevel(String line, String messageLevel);\n    public void setTimeout(long timeout);\n    @Description(\"Pass specified argument to xcodebuild. The element has the required attribute: value.\") public Arg createArg();\n\n    private XcodeBuilder builder;\n    private Directory directoryDoesntFailValidation;\n    private Map<String, String> buildProperties;\n    private static final String COMPILE_LINE;\n    private static final String WARNING_LINE;\n    private static final String ERROR_LINE;\n    private static final String BUILD_FAILED_LINE;\n    private static final String COMMANDS_FAILED_LINE;\n\n}\n\nclass XcodeBuilderTest {\n\n    private XcodeBuilder builder;\n    private Directory directoryDoesntFailValidation;\n    private Map<String, String> buildProperties;\n    private static final String COMPILE_LINE;\n    private static final String WARNING_LINE;\n    private static final String ERROR_LINE;\n    private static final String BUILD_FAILED_LINE;\n    private static final String COMMANDS_FAILED_LINE;\n\n    @Test\n    public void errorLineShouldReturnErrorElement() {\n", "reference": "        Element e = builder.getElementFromLine(ERROR_LINE);\n        assertMessageAtLevel(ERROR_LINE, e, \"error\");\n    }\n\n}", "prediction": "        Element e = builder.getElementFromLine(ERROR_LINE);\n        assertThat(e.getLevel(), is(Level.ERROR));\n        assertThat(e.getMessage(), is(\"error: error\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "2503314_13", "part": [1, 1], "seq": [1, 1], "prompt": "class AuthenticationManagerLdapImpl extends AuthenticationManager {\n\n    public String resetPassword(User user, String[] rnd0, String[] rnd1, String[] rnd2, String[] rnd3, String[] rnd4) {\n        String changedPassword = generateRandomPassword(rnd0, rnd1, rnd2, rnd3, rnd4);\n        final User userAdmin = AuthenticationManager.getDefault().getCurrentPrincipal().getUser();\n        \n        changePassword(user, changedPassword, userAdmin);\n        activateLdapUserPasswordResetFlag(user, userAdmin);\n        return changedPassword;\n\n    }\n\n    public  AuthenticationManagerLdapImpl(ConfigurationUtil cfg, IUserRolesService userRolesService,\n            AuthenticationManagerLdapTemplate authenticationManagerLdapTemplate);\n\n    public static AuthenticationManager getDefault();\n    public boolean checkPassword(User user, String password);\n    public String resetPasswordExternal(User user, String[] rnd0, String[] rnd1, String[] rnd2, String[] rnd3, String[] rnd4);\n    private void activateLdapUserPasswordResetFlag(final User user,final User userAdmin);\n    public void changePassword(final User user, final String password);\n    protected void changePassword(final User user, final String password, User userAdmin);\n\n    private static final String PASSWORD;\n    private static final String NEW_PASSWORD;\n    private static final String[] RANDOM;\n    private AuthenticationManagerLdapImpl sut;\n    private ConfigurationUtil cfg;\n    private IUserRolesService userRolesService;\n    private CustomBindAuthenticator customBindAuthenticator;\n    private InitialDirContextFactory initialDirContextFactory;\n    private AuthenticationManagerLdapTemplate authManagerLdapTemplate;\n    private ConfigurationUtil configurationUtil;\n    private ApplicationContext ctx;\n    private AuthenticationManager authenticationManager;\n    private User user;\n\n}\n\nclass AuthenticationManagerLdapImplTest {\n\n    private static final String PASSWORD;\n    private static final String NEW_PASSWORD;\n    private static final String[] RANDOM;\n    private AuthenticationManagerLdapImpl sut;\n    private ConfigurationUtil cfg;\n    private IUserRolesService userRolesService;\n    private CustomBindAuthenticator customBindAuthenticator;\n    private InitialDirContextFactory initialDirContextFactory;\n    private AuthenticationManagerLdapTemplate authManagerLdapTemplate;\n    private ConfigurationUtil configurationUtil;\n    private ApplicationContext ctx;\n    private AuthenticationManager authenticationManager;\n    private User user;\n\n    @Test\n    public void resetPassword() throws Exception {\n", "reference": "\n        User userAdmin = getUserAdmin();\n\n        Principal principal = mock(Principal.class);\n        when(principal.getUser()).thenReturn(userAdmin);\n\n        when(authenticationManager.getCurrentPrincipal()).thenReturn(principal);\n\n        final String randomPassword = sut.generateRandomPassword(RANDOM, RANDOM, RANDOM, RANDOM, RANDOM);\n\n        doNothing().when(authManagerLdapTemplate).modifyAttributes(any(DirContext.class), eq(user), any(ModificationItem[].class));\n\n        sut.resetPassword(user, RANDOM, RANDOM, RANDOM, RANDOM, RANDOM);\n        verify(authManagerLdapTemplate).changePassword(user, randomPassword, userAdmin);\n        verify(authManagerLdapTemplate, times(2)).getTemplate(userAdmin);\n        verify(authManagerLdapTemplate).getCallback(user, randomPassword);\n        verify(authManagerLdapTemplate).getCallback(user);\n        verify(authManagerLdapTemplate).changeLdapUserPassword(any(DirContext.class), eq(randomPassword), eq(user));\n        verify(authManagerLdapTemplate).setLdapUserPasswordResetFlag(any(DirContext.class), eq(user));\n\n    }\n\n}", "prediction": "        String changedPassword = sut.resetPassword(user, RANDOM, RANDOM, RANDOM, RANDOM, RANDOM);\n        assertThat(changedPassword, is(notNullValue()));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "2595446_0", "part": [1, 1], "seq": [1, 1], "prompt": "class JerseyClientJsonParser implements Parser {\n\n    @Override\n    public <T> T parse(byte[] data, Type type) {\n        ObjectMapper mapper = new ObjectMapper();\n        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n        JavaType javaType = mapper.constructType(type);\n        try {\n            return mapper.readValue(data, javaType);\n        } catch (IOException e) {\n            throw new ParseException(\"Unable to parse data.\", e);\n        }\n    }\n\n    @Override public String encode(Object object);\n\n}\n\nclass JerseyClientJsonParserTest {\n\n    @Test\n    public void testParse() throws Exception {\n", "reference": "        Parser p = new JerseyClientJsonParser();\n        Something expected = new Something(\"coffee\");\n        Something actual = p.parse(\"{\\\"name\\\":\\\"coffee\\\"}\".getBytes(), Something.class);\n        assertEquals(actual, expected);\n    }\n\n}", "prediction": "        Parser parser = new JerseyClientJsonParser();\n        String json = \"{\\\"name\\\":\\\"John\\\"}\";\n        Person person = parser.parse(json.getBytes(), Person.class);\n        assertEquals(\"John\", person.getName());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "2641714_123", "part": [1, 1], "seq": [1, 1], "prompt": "class DigesterDefinitionsReader implements DefinitionsReader {\n\n    public Map<String, Definition> read(Object source) {\n        // This is an instance variable instead of a local variable because\n        // we want to be able to call the addDefinition method to populate it.\n        // But we reset the Map here, which, of course, has threading implications.\n        definitions = new LinkedHashMap<String, Definition>();\n\n        if (source == null) {\n            // Perhaps we should throw an exception here.\n            return null;\n        }\n\n        InputStream input;\n        try {\n            input = (InputStream) source;\n        } catch (ClassCastException e) {\n            throw new DefinitionsFactoryException(\n                \"Invalid source type.  Requires java.io.InputStream.\", e);\n        }\n\n        try {\n            // set first object in stack\n            //digester.clear();\n            digester.push(this);\n            // parse\n            digester.parse(input);\n\n        } catch (SAXException e) {\n            throw new DefinitionsFactoryException(\n                \"XML error reading definitions.\", e);\n        } catch (IOException e) {\n            throw new DefinitionsFactoryException(\n                \"I/O Error reading definitions.\", e);\n        } finally {\n            digester.clear();\n        }\n\n        return definitions;\n    }\n\n    public  DigesterDefinitionsReader();\n\n    public void setValidating(boolean validating);\n    protected void initSyntax(Digester digester);\n    private void initDigesterForTilesDefinitionsSyntax(Digester digester);\n    public void addDefinition(Definition definition);\n    protected String[] getRegistrations();\n    protected String getNextUniqueDefinitionName(\n            Map<String, Definition> definitions);\n\n    private final Logger log;\n    private DigesterDefinitionsReader reader;\n\n}\n\nclass TestDigesterDefinitionsReader {\n\n    private final Logger log;\n    private DigesterDefinitionsReader reader;\n\n    @Test\n    public void testBadXml() {\n", "reference": "        try {\n            URL configFile = this.getClass().getClassLoader().getResource(\n                    \"org/apache/tiles/config/malformed-defs.xml\");\n            assertNotNull(\"Config file not found\", configFile);\n\n            InputStream source = configFile.openStream();\n            reader.read(source);\n            fail(\"Should've thrown an exception.\");\n        } catch (DefinitionsFactoryException e) {\n            // correct.\n            if (log.isDebugEnabled()) {\n                log.debug(\"Exception caught, it is OK\", e);\n            }\n        } catch (Exception e) {\n            fail(\"Exception reading configuration.\" + e);\n        }\n    }\n\n}", "prediction": "        InputStream input = getClass().getResourceAsStream(\"bad.xml\");\n        try {\n            reader.read(input);\n            fail(\"Should have thrown an exception\");\n        } catch (DefinitionsFactoryException e) {\n            assertTrue(e.getMessage().contains(\"XML error reading definitions.\"));\n        }\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "2666698_73", "part": [1, 1], "seq": [1, 1], "prompt": "class JGitSourceReferencesProvider implements SourceReferencesProvider {\n\n    String getRelativePath(File subDir, File parentDir) throws MojoExecutionException {\n        URI subDirUri;\n        URI relativeUri;\n        try {\n            // have to canonicalize before comparing on case-insensitive filesystems\n            subDirUri = subDir.getCanonicalFile().toURI();\n            relativeUri = parentDir.getCanonicalFile().toURI().relativize(subDirUri);\n        } catch (IOException e) {\n            throw new MojoExecutionException(e.getMessage(), e);\n        }\n        if (relativeUri.equals(subDirUri)) {\n            throw new MojoExecutionException(subDir + \" is not a subdir of \" + parentDir);\n        }\n        String relative = relativeUri.getPath();\n        // remove surrounding slashes\n        if (relative.startsWith(\"/\")) {\n            relative = relative.substring(1);\n        }\n        if (relative.endsWith(\"/\")) {\n            relative = relative.substring(0, relative.length() - 1);\n        }\n        return relative;\n    }\n\n    @Override public String getSourceReferencesHeader(MavenProject project, ScmUrl scmUrl);\n    private ObjectId resolveHead(Repository repo);\n    private String findTagForHead(Git git, ObjectId head);\n\n}\n\nclass JGitSourceReferencesProviderTest {\n\n    @Test\n    public void testGetRelativePathNoCommonBasedir() throws MojoExecutionException {\n", "reference": "        JGitSourceReferencesProvider provider = new JGitSourceReferencesProvider();\n        File projectBasedir = new File(\"/foo/test/bar\");\n        File repoRoot = new File(\"/baz\");\n        assertThrows(MojoExecutionException.class, () -> provider.getRelativePath(projectBasedir, repoRoot));\n    }\n\n}", "prediction": "        File subDir = new File(\"subdir\");\n        File parentDir = new File(\"parentdir\");\n        assertEquals(\"subdir\", JGitSourceReferencesProvider.getRelativePath(subDir, parentDir));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "2819986_0", "part": [1, 1], "seq": [1, 1], "prompt": "class NotificationUtils implements Serializable {\n\n    public boolean isHashValid(Map<String, String> parameterMap, String secret) {\n        Map<String, String> map = new HashMap<String, String>(parameterMap);\n        map.put(\"notification_secret\", secret);\n\n        checkAllParametersNotNull(map);\n\n        String realHash = calculateHash(map);\n        String sha1HashParam = map.get(\"sha1_hash\");\n\n        boolean equals = realHash.equalsIgnoreCase(sha1HashParam);\n        if (!equals) {\n            LOG.debug(\"the hashes are not equals. expected: \" + realHash + \", but received: \" + sha1HashParam);\n        }\n        return equals;\n    }\n\n    private void checkAllParametersNotNull(Map<String, String> map);\n    public String calculateHash(Map<String, String> parameterMap, String secret);\n    private String calculateHash(Map<String, String> parameterMap);\n     String createStringForHash(Map<String, String> parameterMap);\n\n    public static final NotificationUtils NOTIFICATION_UTILS;\n    public static final String SECRET;\n     String string;\n\n}\n\nclass NotificationUtilsTest {\n\n    public static final NotificationUtils NOTIFICATION_UTILS;\n    public static final String SECRET;\n     String string;\n\n    @Test\n    public void testCheckHash() throws Exception {\n", "reference": "        assertTrue(NOTIFICATION_UTILS.isHashValid(createParamsMap(), SECRET));\n    }\n\n}", "prediction": "        Map<String, String> parameterMap = new HashMap<String, String>();\n        parameterMap.put(\"sha1_hash\", \"1234567890\");\n        parameterMap.put(\"notification_secret\", SECRET);\n        parameterMap.put(\"notification_type\", \"order_status_changed\");\n        parameterMap.put(\"order_id\", \"1234567890\");\n        parameterMap.put(\"order_status\", \"shipped\");\n        parameterMap.put(\"order_date\", \"2013-01-01 00:00:00\");\n        parameterMap.put(\"order_total\", \"100.00\");\n        parameterMap.put(\"order_currency\", \"USD\");\n        parameterMap.put(\"order_shipping\", \"10.00\");\n        parameterMap.put(\"order_tax\", \"10.00\");\n        parameterMap.put(\"order_shipping_method\", \"UPS Ground\");\n        parameterMap.put(\"order_shipping_tracking_number\", \"1234567890\");\n        parameterMap.put(\"order_shipping_tracking_url\", \"http://www.ups.com/track?loc=en_US&tracknum=1234567890\");\n        parameterMap.put(\"order_shipping_tracking_carrier\", \"UPS\");\n        parameterMap.put(\"order_shipping_tracking_carrier_url\", \"http://www.ups.com\");\n        parameterMap.put(\"order_shipping_tracking_carrier_phone\", \"1-800-555-UPS\");\n        parameterMap.put(\"order_shipping_tracking_carrier_email\", \"tracking@ups.com\");\n        parameterMap.put(\"order_shipping_tracking_carrier_logo\", \"http://www.ups.com/images/ups_logo.gif\");\n        parameterMap.put(\"order_shipping_tracking_carrier_logo_small\", \"http://www.ups.com/images/ups_logo_small.gif\");\n        parameterMap.put(\"order_shipping_tracking_carrier_logo_large\", \"http://www.ups.com/images/ups_logo_large.gif\");\n        parameterMap.put(\"order_shipping_tracking_carrier_logo_full\", \"http://www.ups.com/images/ups_logo_full.gif\");\n        parameterMap.put(\"order_shipping_tracking_carrier_logo_thumb\", \"http://www.ups.com/images/ups_logo_thumb.gif\");\n        parameterMap.put(\"order_shipping_tracking_carrier_logo_thumb_small\", \"http://www.ups.com/images/ups_logo_thumb_small.gif\");\n        parameterMap.put(\"order_shipping_tracking_carrier_logo_thumb_large\", \"http://www.ups.com/images/ups_logo_thumb_large.gif\");\n        parameterMap.put(\"order_shipping_tracking_carrier_logo_thumb_full\", \"http://www.ups.com/images/ups_logo_thumb_full.gif\");\n        parameterMap.put(\"order_shipping_tracking_carrier_logo_thumb_small_small\", \"http://www.ups.com/images/ups_logo_thumb_small_small.gif\");\n        parameterMap.put(\"order_shipping_tracking_carrier_logo_thumb_large_large\", \"http://www.ups.com/images/ups_logo_thumb_large_large.gif\");\n        parameterMap.put(\"order_shipping_tracking_carrier_logo_thumb_full_full\", \"http://www.ups.com/images/ups_logo_thumb_full_full.gif\");\n        parameterMap.put(\"order_shipping_tracking_carrier_logo_thumb_small_full\", \"http://www.ups.com/images/ups_logo_thumb_small_full.gif\");\n        parameterMap.put(\"order_shipping_tracking_carrier_logo_thumb_large_small\", \"http://www.ups.com/images/ups_logo_thumb_large_small.gif\");\n        parameterMap.put(\"order_shipping_tracking_carrier_logo_thumb_full_large\", \"http://www.ups.com/images/ups_logo_thumb_full_large.gif\");\n        parameterMap.put(\"order_shipping_tracking_carrier_logo_thumb_small_large\", \"http://www.ups.com/images/ups_logo_thumb_small_large.gif\");\n        parameterMap.put(\"order_shipping_tracking_carrier_logo_thumb_large_small\", \"http://www.ups.com/images/ups_logo_thumb_large_small.gif\");\n        parameterMap.put(\"order_shipping_tracking_carrier_logo_thumb_full_small\", \"http://www.ups.com/images/ups_logo_thumb_full_small.gif\");\n        parameterMap.put(\"order_shipping_tracking_carrier_logo_thumb_small_full\", \"http://www.ups.com/images/ups_logo_thumb_small_full.gif\");", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "2827764_0", "part": [1, 1], "seq": [1, 1], "prompt": "class App {\n\n\tpublic String getMessage() {\n\t\treturn message;\n\t}\n\n\tpublic  App();\n\tpublic  App(String message);\n\n\tpublic static void main(String[] args);\n\tpublic void setMessage(String message);\n\tpublic void run();\n\tprotected void readMessageFromFile(String file);\n\n\tprivate static final Logger LOG;\n\tprivate App app;\n\n}\n\nclass AppTest {\n\n\tprivate static final Logger LOG;\n\tprivate App app;\n\n\t@Test\n\tpublic void testDefaultMessage() {\n", "reference": "\t\tString message = app.getMessage();\n\t\tassertEquals(\"Hello, world!\", message);\n\t\tLOG.debug(message);\n\t}\n\n}", "prediction": "\t\tassertEquals(\"Hello World\", app.getMessage());\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "2836228_31", "part": [1, 1], "seq": [1, 1], "prompt": "class ProcessEntityParser extends EntityParser<Process> {\n\n    @Override\n    public void validate(Process process) throws IvoryException {\n        if(process.getTimezone() == null)\n            process.setTimezone(TimeZone.getTimeZone(\"UTC\"));\n\n        // check if dependent entities exists\n        Set<String> clusters = new HashSet<String>();\n        for (org.apache.ivory.entity.v0.process.Cluster cluster : process.getClusters().getClusters()) {\n            String clusterName = cluster.getName();\n\t\t\tif (!clusters.add(cluster.getName())) {\n\t\t\t\tthrow new ValidationException(\"Cluster: \" + cluster.getName()\n\t\t\t\t\t\t+ \" is defined more than once for process: \"+process.getName());\n\t\t\t}\n            validateEntityExists(EntityType.CLUSTER, clusterName);\n            validateProcessValidity(cluster.getValidity().getStart(), cluster.getValidity().getEnd());\n            validateHDFSpaths(process, clusterName);\n\n            if (process.getInputs() != null) {\n                for (Input input : process.getInputs().getInputs()) {\n                    validateEntityExists(EntityType.FEED, input.getFeed());\n                    Feed feed = (Feed) ConfigurationStore.get().get(EntityType.FEED, input.getFeed());\n                    CrossEntityValidations.validateFeedDefinedForCluster(feed, clusterName);\n                    CrossEntityValidations.validateFeedRetentionPeriod(input.getStart(), feed, clusterName);\n                    CrossEntityValidations.validateInstanceRange(process, input, feed);\n                    if (input.getPartition() != null) {\n                        CrossEntityValidations.validateInputPartition(input, feed);\n                    }\n                }\n            }\n\n            if (process.getOutputs() != null) {\n                for (Output output : process.getOutputs().getOutputs()) {\n                    validateEntityExists(EntityType.FEED, output.getFeed());\n                    Feed feed = (Feed) ConfigurationStore.get().get(EntityType.FEED, output.getFeed());\n                    CrossEntityValidations.validateFeedDefinedForCluster(feed, clusterName);\n                    CrossEntityValidations.validateInstance(process, output, feed);\n                }\n            }\n        }\n        validateDatasetName(process.getInputs(), process.getOutputs());\n        validateLateInputs(process);\n    }\n\n    public  ProcessEntityParser();\n\n    private void validateHDFSpaths(Process process, String clusterName);\n    private String getNameNode(Cluster cluster, String clusterName);\n    private void validateProcessValidity(Date start, Date end);\n    private void validateDatasetName(Inputs inputs, Outputs outputs);\n    private void validateLateInputs(Process process);\n\n\tprivate final ProcessEntityParser parser;\n\tprivate String INVALID_PROCESS_XML;\n\n}\n\nclass ProcessEntityParserTest extends EntityParser<Process> {\n\n\tprivate final ProcessEntityParser parser;\n\tprivate String INVALID_PROCESS_XML;\n\n\t@Test(expectedExceptions = ValidationException.class)\n\tpublic void testInvalidProcessValidity() throws Exception {\n", "reference": "\t\tProcess process = parser\n\t\t\t\t.parseAndValidate((ProcessEntityParserTest.class\n\t\t\t\t\t\t.getResourceAsStream(PROCESS_XML)));\n\t\tprocess.getClusters().getClusters().get(0).getValidity().setStart(SchemaHelper.parseDateUTC(\"2011-12-31T00:00Z\"));\n\t\tparser.validate(process);\n\t}\n\n}", "prediction": "\t\tparser.validate(getProcessEntity(INVALID_PROCESS_XML));\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "2846293_39", "part": [1, 1], "seq": [1, 1], "prompt": "class ActionsGenerator {\n\n    public Actions builder() {\n        return new Actions();\n    }\n\n    public  ActionsGenerator(String mouseObject, String keyboardObject, String actionObject);\n\n    public Keyboard keyboard();\n    public Mouse mouse();\n\n    private ActionsGenerator action;\n    private String webElement;\n    private String altWebElement;\n\n}\n\nclass ActionsGeneratorTest {\n\n    private ActionsGenerator action;\n    private String webElement;\n    private String altWebElement;\n\n    @Test\n    public void generateCodeActionClick() throws Exception {\n", "reference": "        assertThat(this.action.builder().click(), is(equalTo(\"builder.click()\")));\n    }\n\n}", "prediction": "        action.click(webElement);\n        assertEquals(\"Actions action = new Actions(driver);\\n\"\n                + \"action.click(driver.findElement(By.id(\\\"\" + webElement + \"\\\")));\\n\"\n                + \"action.perform();\", action.builder().toString());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "3145735_8", "part": [1, 1], "seq": [1, 1], "prompt": "class DummyReader implements ProfileVersionReader {\n\n  public String getObjectsAvgSize() {\n    final Element size = this.getSizePropertyElement();\n    return this.getAttributeValue(size, \"avg\");\n  }\n\n  public void setStream(final InputStream is);\n  public String getCollectionName();\n  public String getObjectsCount();\n  public String getCollectionSize();\n  public String getObjectsMaxSize();\n  public String getObjectsMinSize();\n  public Map<String, String> getDistribution(final String name);\n  private Element getCollectionElement();\n  private Element getSizePropertyElement();\n  private Element getPropertyElement(final String name);\n  private String getAttributeValue(final Element element, final String name);\n  private void getDocument(final InputStream is);\n\n  private DummyReader reader;\n\n}\n\nclass DummyReaderTest {\n\n  private DummyReader reader;\n\n  @Test\n  public void shouldObtainObjectsAvgSize() throws Exception {\n", "reference": "    final String size = this.reader.getObjectsAvgSize();\n    Assert.assertEquals(\"35000.42\", size);\n  }\n\n}", "prediction": "    final String expected = \"1000\";\n    final String actual = reader.getObjectsAvgSize();\n    assertEquals(expected, actual);\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "3173086_42", "part": [1, 1], "seq": [1, 1], "prompt": "class ExporterImpl implements Exporter {\n\n    public List<File> exportReport(ExportSettings settings, List<Participant> participants, Trip trip,\n                                   ResourceResolver resourceResolver, ActivityResolver activityResolver, AmountFactory amountFactory) {\n\n        List<File> filesCreated = new ArrayList<>();\n\n        StringBuilder fileNamePrefix = new StringBuilder(resourceResolver.resolve(R.string.fileExportPrefix))\n                .append(FILE_NAME_SEPARATOR)\n                .append(ExporterFileNameUtils.clean(trip.getName()));\n        StringBuilder timestamp = new StringBuilder(ExporterFileNameUtils.getTimeStamp(resourceResolver.getLocale()));\n\n        HtmlExportCharResolver htmlExportCharResolver = null;\n        CsvExportCharResolver csvExportCharResolver = null;\n        TxtExportCharResolver txtExportCharResolver = null;\n\n        if (settings.isFormatHtml()) {\n            htmlExportCharResolver = new HtmlExportCharResolver();\n            htmlExportCharResolver.setLang(resourceResolver.getLocale().getLanguage());\n        }\n        if (settings.isFormatCsv()) {\n            csvExportCharResolver = new CsvExportCharResolver();\n        }\n        if (settings.isFormatTxt()) {\n            txtExportCharResolver = new TxtExportCharResolver();\n        }\n\n        if (participants.size() > 1 && settings.isSeparateFilesForIndividuals()) {\n            ArrayList<Participant> participantsSubset;\n            for (Participant p : participants) {\n                participantsSubset = new ArrayList<>(1);\n                participantsSubset.add(p);\n                createAndWriteFiles(settings,\n                        participantsSubset,\n                        trip,\n                        resourceResolver,\n                        fileWriter,\n                        filesCreated,\n                        fileNamePrefix,\n                        timestamp,\n                        htmlExportCharResolver,\n                        csvExportCharResolver,\n                        txtExportCharResolver,\n                        amountFactory);\n            }\n        } else {\n            createAndWriteFiles(settings,\n                    participants,\n                    trip,\n                    resourceResolver,\n                    fileWriter,\n                    filesCreated,\n                    fileNamePrefix,\n                    timestamp,\n                    htmlExportCharResolver,\n                    csvExportCharResolver,\n                    txtExportCharResolver,\n                    amountFactory);\n        }\n\n        StreamSender streamSender = new StreamSenderImpl();\n        StringBuilder exportSubject = new StringBuilder()\n                .append(resourceResolver.resolve(R.string.fileExportEmailSubjectPrefix))\n                .append(SPACE)\n                .append(trip.getName())\n                .append(SPACE)\n                .append(timestamp);\n\n        if (activityResolver.getActivity() != null) {\n            List<Uri> contentUrisFromFiles = FileUtils.getContentUrisFromFiles(filesCreated, TrickyTripperFileProvider.AUTHORITY);\n            if (settings.getOutputChannel() != null) {\n                streamSender.sendStream(\n                        (Activity) activityResolver.getActivity(),\n                        exportSubject.toString(),\n                        resourceResolver.resolve(R.string.fileExportEmailContent),\n                        contentUrisFromFiles, settings.getOutputChannel());\n            }\n        }\n\n        return filesCreated;\n\n    }\n\n    public  ExporterImpl(FileWriter fileWriter);\n\n    private void createAndWriteFiles(ExportSettings settings, List<Participant> participants, Trip trip,\n                                     ResourceResolver resourceResolver, FileWriter fileWriter, List<File> filesCreated,\n                                     StringBuilder fileNamePrefix, StringBuilder timestamp, HtmlExportCharResolver htmlExportCharResolver,\n                                     CsvExportCharResolver csvExportCharResolver, TxtExportCharResolver txtExportCharResolver,\n                                     AmountFactory amountFactory);\n    private String[] getReportMetaInfo(List<Participant> participants, Trip trip, ResourceResolver resourceResolver);\n    private StringBuilder buildFileName(StringBuilder fileNamePrefix, StringBuilder timestamp,\n                                        List<Participant> participants, ResourceResolver resourceResolver);\n\n    private final Pattern patternCsvIndividual;\n    private final Pattern patternCsvAll;\n    private final Pattern patternHtmlIndividual;\n    private final Pattern patternHtmlAll;\n    private final Pattern patternTxtIndividual;\n    private final Pattern patternTxtAll;\n    @SuppressWarnings(\"FieldCanBeLocal\")\n    private final boolean deleteCreatedFiles;\n    private Exporter exporter;\n    private Trip tripToExport;\n    private ResourceResolver resourceResolver;\n    private Participant participant;\n    private AmountFactory amountFactory;\n    private TestDataFactory factory;\n\n}\n\nclass ExporterImplTest {\n\n    private final Pattern patternCsvIndividual;\n    private final Pattern patternCsvAll;\n    private final Pattern patternHtmlIndividual;\n    private final Pattern patternHtmlAll;\n    private final Pattern patternTxtIndividual;\n    private final Pattern patternTxtAll;\n    @SuppressWarnings(\"FieldCanBeLocal\")\n    private final boolean deleteCreatedFiles;\n    private Exporter exporter;\n    private Trip tripToExport;\n    private ResourceResolver resourceResolver;\n    private Participant participant;\n    private AmountFactory amountFactory;\n    private TestDataFactory factory;\n\n    @Test\n    public void testOutputTxtForAllSplit() {\n", "reference": "        ExportSettings exportSettings = createExportSettings(true, true, true, true, false, false, true, false, true);\n        List<File> result = exporter.exportReport(exportSettings, tripToExport.getParticipant(), tripToExport,\n                resourceResolver,\n                new ActivityResolver() {\n\n                    @Override\n                    public Object getActivity() {\n                        return null;\n                    }\n                },\n                amountFactory);\n\n        Throwable exceptionCaught = null;\n        try {\n            Assert.assertEquals(3, result.size());\n            Assert.assertTrue(patternTxtIndividual.matcher(result.get(0).getName()).matches());\n            Assert.assertTrue(patternTxtIndividual.matcher(result.get(1).getName()).matches());\n            Assert.assertTrue(patternTxtIndividual.matcher(result.get(2).getName()).matches());\n\n            for (int i = 0; i < result.size(); i++) {\n                String name;\n                if (i == 0) {\n                    name = factory.chris.getName();\n                }\n                else if (i == 1) {\n                    name = factory.niko.getName();\n                }\n                else {\n                    name = factory.wolfram.getName();\n                }\n                Assert.assertTrue(nameContains(result.get(i), name));\n            }\n        }\n        catch (Exception e) {\n            exceptionCaught = e;\n        }\n        finally {\n            deleteCreatedFiles(result);\n        }\n        if (exceptionCaught != null) {\n            throw new RuntimeException(exceptionCaught);\n        }\n    }\n\n}", "prediction": "        ExportSettings settings = new ExportSettings();\n        settings.setFormatTxt(true);\n        settings.setSeparateFilesForIndividuals(true);\n        settings.setSplitBy(SplitBy.SPLIT_BY_TRIP);\n        List<Participant> participants = new ArrayList<>();\n        participants.add(participant);\n        participants.add(participant);\n        List<File> filesCreated = exporter.exportReport(settings, participants, tripToExport, resourceResolver, null, amountFactory);\n        assertEquals(2, filesCreated.size());\n        assertTrue(filesCreated.get(0).getName().matches(patternTxtAll.pattern()));\n        assertTrue(filesCreated.get(1).getName().matches(patternTxtAll.pattern()));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "3223269_0", "part": [1, 1], "seq": [1, 1], "prompt": "class GaugesService {\n\n    public List<Gauge> getGauges() throws IOException {\n        try {\n            HttpRequest request = execute(HttpRequest.get(URL_EMBEDDED));\n            GaugesWrapper response = fromJson(request, GaugesWrapper.class);\n            if (response != null && response.gauges != null)\n                return response.gauges;\n            return Collections.emptyList();\n        } catch (HttpRequestException e) {\n            throw e.getCause();\n        }\n    }\n\n    public  GaugesService(final String username, final String password);\n    public  GaugesService(final String apiKey);\n\n    protected HttpRequest execute(HttpRequest request);\n    private HttpRequest configure(final HttpRequest request);\n    private HttpRequest addCredentialsTo(HttpRequest request);\n    private V fromJson(HttpRequest request, Class<V> target);\n    public List<PageContent> getContent(String gaugeId);\n    public List<Referrer> getReferrers(String gaugeId);\n    public Client createClient(String description);\n    public Client getClient(String description);\n    public Gauge getGauge(String gaugeId);\n    public String getPusherAuth(final String socketId, final String channelName);\n\n    @Mock\n    private HttpRequest request;\n    private GaugesService service;\n\n}\n\nclass GaugesServiceTest {\n\n    @Mock\n    private HttpRequest request;\n    private GaugesService service;\n\n    @Test\n    public void getGaugesEmptyResponse() throws IOException {\n", "reference": "        doReturn(createReader(\"\")).when(request).bufferedReader();\n        List<Gauge> gauges = service.getGauges();\n        assertNotNull(gauges);\n        assertTrue(gauges.isEmpty());\n    }\n\n}", "prediction": "        when(request.execute()).thenReturn(new HttpResponse(200, \"{}\"));\n        assertTrue(service.getGauges().isEmpty());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "3384018_43", "part": [1, 1], "seq": [1, 1], "prompt": "class RequestAcceptEncoding implements HttpRequestInterceptor {\n\n    public void process(\n            final HttpRequest request,\n            final HttpContext context) throws HttpException, IOException {\n\n        /* Signal support for Accept-Encoding transfer encodings. */\n        request.addHeader(\"Accept-Encoding\", \"gzip,deflate\");\n    }\n\n}\n\nclass TestRequestAcceptEncoding {\n\n    @Test\n    public void testAcceptEncoding() throws Exception {\n", "reference": "        HttpRequest request = new BasicHttpRequest(\"GET\", \"/\");\n        HttpContext context = new BasicHttpContext();\n\n        HttpRequestInterceptor interceptor = new RequestAcceptEncoding();\n        interceptor.process(request, context);\n        Header header = request.getFirstHeader(\"Accept-Encoding\");\n        Assert.assertNotNull(header);\n        Assert.assertEquals(\"gzip,deflate\", header.getValue());\n    }\n\n}", "prediction": "        HttpClient client = HttpClientBuilder.create().build();\n        HttpGet get = new HttpGet(\"http://httpbin.org/gzip\");\n        HttpResponse response = client.execute(get);\n        assertEquals(200, response.getStatusLine().getStatusCode());\n        HttpEntity entity = response.getEntity();\n        assertNotNull(entity);\n        assertEquals(\"gzip\", entity.getContentEncoding());\n        assertEquals(\"application/json\", entity.getContentType().getValue());\n        assertTrue(entity.getContentLength() > 0);\n        assertTrue(entity.isChunked());\n        assertTrue(entity.isStreaming());\n        assertTrue(entity.isRepeatable());\n        assertFalse(entity.isRepeatable());\n        assertFalse(entity.isStreaming());\n        assertFalse(entity.isChunked());\n        assertEquals(\"gzip\", entity.getContentEncoding());\n        assertEquals(\"application/json\", entity.getContentType().getValue());\n        assertTrue(entity.getContentLength() > 0);\n        assertTrue(entity.isChunked());\n        assertTrue(entity.isStreaming());\n        assertTrue(entity.isRepeatable());\n        assertFalse(entity.isRepeatable());\n        assertFalse(entity.isStreaming());\n        assertFalse(entity.isChunked());\n        assertEquals(\"gzip\", entity.getContentEncoding());\n        assertEquals(\"application/json\", entity.getContentType().getValue());\n        assertTrue(entity.getContentLength() > 0);\n        assertTrue(entity.isChunked());\n        assertTrue(entity.isStreaming());\n        assertTrue(entity.isRepeatable());\n        assertFalse(entity.isRepeatable());\n        assertFalse(entity.isStreaming());\n        assertFalse(entity.isChunked());\n        assertEquals(\"gzip\", entity.getContentEncoding());\n        assertEquals(\"application/json\", entity.getContentType().getValue());\n        assertTrue(entity.getContentLength() > 0);\n        assertTrue(entity.isChunked());\n        assertTrue(entity.isStreaming());\n        assertTrue(entity.isRepeatable());\n        assertFalse(entity.isRepeatable());\n        assertFalse(entity.isStreaming());\n        assertFalse(entity.isChunked());\n        assertEquals(\"gzip\", entity.getContentEncoding());\n        assertEquals(\"application/json\", entity.getContentType().getValue());\n        assertTrue(entity.getContentLength() > 0);\n        assertTrue(entity.isChunked());\n        assertTrue(entity.isStreaming());\n        assertTrue(entity.isRepeatable());\n        assertFalse(entity.isRepeatable());\n        assertFalse(entity.isStreaming());\n        assertFalse(entity.isChunked());\n        assertEquals(\"gzip\", entity.getContentEncoding());\n        assertEquals(\"application/json\", entity.getContentType().getValue());\n        assertTrue(entity.getContentLength() > 0);\n        assertTrue(entity.isChunked());\n        assertTrue(entity.isStreaming());\n        assertTrue(entity.isRepeatable());\n        assertFalse(entity.isRepeatable());\n        assertFalse(entity.isStreaming());\n        assertFalse(entity.isChunked());\n        assertEquals(\"gzip\", entity.getContentEncoding());\n        assertEquals(\"application/json\", entity.getContentType().getValue());\n        assert", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "3865446_27", "part": [1, 1], "seq": [1, 1], "prompt": "class SimplePhenotypeRepresentation implements PhenotypeRepresentation {\n\n    public double[] getDoubleValue() {\n        if (this.representation != null){\n            return Arrays.copyOf(this.representation, this.representation.length);\n        } else {\n            return new double[0];\n        }\n\n    }\n\n    public  SimplePhenotypeRepresentation();\n    public  SimplePhenotypeRepresentation(double[] phenotypeValue);\n    public  SimplePhenotypeRepresentation(SimplePhenotypeRepresentation second);\n\n    public void setDoubleValue(double[] phenotypeValue);\n    public Representation copy();\n\n    protected PhenotypeRepresentation representation;\n\n}\n\nclass SimplePhenotypeRepresentationTest  {\n\n    protected PhenotypeRepresentation representation;\n\n    @Test\n    // test that arrays are equal but not the same\n    public void testGetDoubleValue() throws Exception {\n", "reference": "        double[] input = new double[]{1.2, 4.8, 6.3, 9.9, 10E18};\n        this.representation.setDoubleValue(input);\n        double[] output = this.representation.getDoubleValue();\n        Assert.assertArrayEquals(input, output, 0.0d);\n        Assert.assertNotSame(input, output);\n    }\n\n}", "prediction": "        double[] phenotypeValue = new double[]{1.0, 2.0, 3.0};\n        representation.setDoubleValue(phenotypeValue);\n        double[] phenotypeValue2 = representation.getDoubleValue();\n        assertEquals(phenotypeValue.length, phenotypeValue2.length);\n        for (int i = 0; i < phenotypeValue.length; i++) {\n            assertEquals(phenotypeValue[i], phenotypeValue2[i], 0.0);\n        }\n        assertNotSame(phenotypeValue, phenotypeValue2);\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "3926525_1", "part": [1, 1], "seq": [1, 1], "prompt": "class ValueSetter {\n\n\tpublic void invoke(String aKey, Object anOn, String aWith) {\n\t\ttry {\n\t\t\tif (twoArgSetter) {\n\t\t\t\tsetter.invoke(anOn, aKey, converter.convert(aWith));\n\t\t\t} else {\n\t\t\t\tsetter.invoke(anOn, converter.convert(aWith));\n\t\t\t}\n\t\t} catch (ParsingException anExc) {\n\t\t\tthrow anExc;\n        } catch (IllegalArgumentException anExc) {\n            throw new ParsingException(\n                anExc.getMessage() +\n                \" while trying to invoke \" + setter +\n                \" on \" + anOn +\n                \" with \" + ((aKey != null) ? aKey + \" and \" : \"\") + aWith +\n                \" converted by \" + converter, anExc);\n\t\t} catch (Exception anExc) {\n\t\t\tthrow new RuntimeException(anExc);\n\t\t}\n\t}\n\n\tpublic  ValueSetter(ConverterRegistry aConverters, Class<?> aContextType, String... aMaybeNames);\n\tpublic  ValueSetter(ConverterRegistry aConverters, Class<?> aContextType, Class<?> aValueType, String... aMaybeNames);\n\n\tpublic String toString();\n\tprivate Method getMethod(Class<?> aContextType, String... aMaybeNames);\n\n\tprivate ConverterRegistry converters;\n\tprivate TestModel model;\n\tprivate StringConverter<Integer> integerConverter;\n\tprivate Mockery mockery;\n\n}\n\nclass ValueSetterTest {\n\n\tprivate ConverterRegistry converters;\n\tprivate TestModel model;\n\tprivate StringConverter<Integer> integerConverter;\n\tprivate Mockery mockery;\n\n\t@Test\n\tpublic void introspectsModelClassToFindAndInvokeAddMethods() {\n", "reference": "\t\tmockery.checking(new Expectations() {{\n\t\t\toneOf(converters).getConverter(Integer.class); // parameter to the setFieldOne method is of type Integer\n\t\t\twill(returnValue(integerConverter));\n\t\t\t\n\t\t\toneOf(integerConverter).convert(\"17\");\n\t\t\twill(returnValue(new Integer(17)));\n\t\t\t\n\t\t\toneOf(model).addFieldTwo(new Integer(17));\n\t\t}});\n\t\t\n\t\tValueSetter _s = new ValueSetter(converters, TestModel.class, \"fieldTwo\");\n\t\t_s.invoke(\"fieldTwo\", model, \"17\");\n\t}\n\n}", "prediction": "\t\tValueSetter setter = new ValueSetter(converters, TestModel.class, \"add\", \"add\");\n\t\tsetter.invoke(\"add\", model, \"1\");\n\t\tassertEquals(1, model.getAdds());\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "3933719_1", "part": [1, 1], "seq": [1, 1], "prompt": "class LazyListImpl extends ArrayList<User> implements ListAccess<User> {\n\n   public int getSize() throws Exception\n   {\n      return size();\n   }\n\n   public User[] load(int index, int length);\n\n   private LazyListImpl list;\n\n}\n\nclass TestLazyListImpl {\n\n   private LazyListImpl list;\n\n   @Test\n   public void testGetSize() throws Exception\n   {\n", "reference": "      assertEquals(5, list.getSize());\n   }\n\n}", "prediction": "     assertEquals(0, list.getSize());\n   }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "3937799_15", "part": [1, 1], "seq": [1, 1], "prompt": "class DistributedData implements Writable {\n\n  synchronized public void format() throws IOException {\n    setDataVersion(0);\n    setIsInIncrementRestoreStage(false, false);\n  }\n\n  public  DistributedData();\n\n  public ReentrantReadWriteLockExtension setDataLocker(ReentrantReadWriteLockExtension getDataLocker);\n  protected void initialize();\n  private void createDataPath();\n  public String getDataPath();\n  synchronized public void open();\n  synchronized public final boolean becomeMasterPre(ServerType oldServerType);\n  synchronized public final boolean becomeMasterPost(ServerType oldServerType);\n  synchronized public final boolean leaveMasterPre(ServerType newServerType);\n  synchronized public final boolean leaveMasterPost(ServerType newServerType);\n  public boolean becomeMasterPreInteranl(ServerType oldServerType);\n  public boolean becomeMasterPostInteranl(ServerType oldServerType);\n  public boolean leaveMasterPreInteranl(ServerType newServerType);\n  public boolean leaveMasterPostInteranl(ServerType newServerType);\n  public boolean isValid();\n  public DistributedOperationQueue getOperationQueue();\n   void openElementToTransfer(String key, Object defaultValue);\n  synchronized public void close();\n  synchronized public void backup();\n  public long getDataVersion();\n  public long setDataVersion(long newVersion);\n  public void readFields(DataInput in);\n  public void write(DataOutput out);\n  public Object getElementToTransfer(String key);\n  public Object putElementToTransfer(String key, Object value);\n  public Object removeElementToTransfer(String key);\n  public Class<?>[] getDataProtocols();\n  synchronized public DistributedData getData(DistributedData oldData,\n      ReentrantReadWriteLockExtension.WriteLock writeLock);\n  public DistributedData getDataAll(DistributedData oldData, ReentrantReadWriteLockExtension.WriteLock writeLock);\n  public DistributedData getDataIncrement(DistributedData oldData, ReentrantReadWriteLockExtension.WriteLock writeLock);\n  public void setData(DistributedData newData);\n  public void setDataAll(DistributedData newData);\n  public void setDataIncrement(DistributedData newData);\n  public Object invoke(Invocation invocation);\n  public Object invokeDirectly(Invocation invocation);\n  public boolean getIsInIncrementRestoreStage(boolean onlyReadFromMemory);\n  public void setIsInIncrementRestoreStage(boolean isInIncrementRestoreStage, boolean onlyWriteToMemory);\n  public boolean getIsIncrementRestoreEnabled();\n  public void setIsIncrementRestoreEnabled(boolean isIncrementRestoreEnabled);\n  public static Class<?> getDistributedInvocationType(Method method);\n  public static String getDataClientClassName(String dataClassName);\n\n  static ExampleData exampleData;\n\n}\n\nclass DistributedDataTest {\n\n  static ExampleData exampleData;\n\n  @Test\n  public void format() throws Exception {\n", "reference": "    exampleData.write(\"jiwan@taobao.com\");\n    assertThat(exampleData.getDataVersion() == 1, is(true));\n    assertThat(exampleData.read().equals(\"jiwan@taobao.com\"), is(true));\n    exampleData.format();\n    assertThat(exampleData.getDataVersion() == 0, is(true));\n    assertThat(exampleData.read().isEmpty(), is(true));\n  }\n\n}", "prediction": "    exampleData.format();\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "4089097_0", "part": [1, 1], "seq": [1, 1], "prompt": "class StringUtils {\n\n\tpublic static int countWords(String str, boolean all) {\n\t\tif (str == null || str.length() == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tString[] words;\n\t\tif (all) {\n\t\t\twords = str.split(\"\\\\s+\"); // Splits at whitespaces.\n\t\t} else {\n\t\t\twords = str.split(\"[\\\\s\\\\*\\\\#\\\\_\\\\|]+\");\n\t\t}\n\n\t\tint count = 0;\n\t\tfor (String word : words) {\n\t\t\tif (word.length() > 0) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\n\t\treturn count;\n\t}\n\n\tpublic static String join(String[] array, String delimiter);\n\tpublic static String quoteMetacharacters(String str);\n\tpublic static String stripNasties(String str);\n\n}\n\nclass StringUtilTests {\n\n\t@Test\n\tpublic void testCountWords() {\n", "reference": "\t\tassertThat(StringUtils.countWords(\"Hi\", true), is(equalTo(1)));\n\t\tassertThat(StringUtils.countWords(\"Hi there\", true), is(equalTo(2)));\n\t\tassertThat(StringUtils.countWords(\"Hi  there\", true), is(equalTo(2)));\n\t\tassertThat(StringUtils.countWords(\"The quick brown fox jumps over the lazy dog\", true), is(equalTo(9)));\n\t\tassertThat(StringUtils.countWords(\"The * quick # brown _ fox | jumps over the lazy dog\", true), is(equalTo(13)));\n\t\tassertThat(StringUtils.countWords(\"The * quick # brown _ fox | jumps over the lazy dog\", false), is(equalTo(9)));\n\t}\n\n}", "prediction": "\t\tassertEquals(0, StringUtils.countWords(\"\", false));\n\t\tassertEquals(0, StringUtils.countWords(\"\", true));\n\t\tassertEquals(1, StringUtils.countWords(\"a\", false));\n\t\tassertEquals(1, StringUtils.countWords(\"a\", true));\n\t\tassertEquals(2, StringUtils.countWords(\"a b\", false));\n\t\tassertEquals(2, StringUtils.countWords(\"a b\", true));\n\t\tassertEquals(2, StringUtils.countWords(\"a b \", false));\n\t\tassertEquals(2, StringUtils.countWords(\"a b \", true));\n\t\tassertEquals(2, StringUtils.countWords(\" a b \", false));\n\t\tassertEquals(2, StringUtils.countWords(\" a b \", true));\n\t\tassertEquals(2, StringUtils.countWords(\" a b c \", false));\n\t\tassertEquals(2, StringUtils.countWords(\" a b c \", true));\n\t\tassertEquals(2, StringUtils.countWords(\" a b c d \", false));\n\t\tassertEquals(2, StringUtils.countWords(\" a b c d \", true));\n\t\tassertEquals(2, StringUtils.countWords(\" a b c d e \", false));\n\t\tassertEquals(2, StringUtils.countWords(\" a b c d e \", true));\n\t\tassertEquals(2, StringUtils.countWords(\" a b c d e f \", false));\n\t\tassertEquals(2, StringUtils.countWords(\" a b c d e f \", true));\n\t\tassertEquals(2, StringUtils.countWords(\" a b c d e f g \", false));\n\t\tassertEquals(2, StringUtils.countWords(\" a b c d e f g \", true));\n\t\tassertEquals(2, StringUtils.countWords(\" a b c d e f g h \", false));\n\t\tassertEquals(2, StringUtils.countWords(\" a b c d e f g h \", true));\n\t\tassertEquals(2, StringUtils.countWords(\" a b c d e f g h i \", false));\n\t\tassertEquals(2, StringUtils.countWords(\" a b c d e f g h i \", true));\n\t\tassertEquals(2, StringUtils.countWords(\" a b c d e f g h i j \", false));\n\t\tassertEquals(2, StringUtils.countWords(\" a b c d e f g h i j \", true));\n\t\tassertEquals(2, StringUtils.countWords(\" a b c d e f g h i j k \", false));\n\t\tassertEquals(2, StringUtils.countWords(\" a b c d e f g h i j k \", true));\n\t\tassertEquals(2, StringUtils.countWords(\" a b c d e f g h i j k l \", false));\n\t\tassertEquals(2, StringUtils.countWords(\" a b c d e f g h i j k l \", true));\n\t\tassertEquals(2, StringUtils.countWords(\" a b c d e f g h i j k l m \", false));\n\t\tassertEquals(2, StringUtils.countWords(\" a b c d e f g h i j k l m \", true));\n\t\tassertEquals(2, StringUtils.countWords(\" a b c d e f g h i j k l m n \", false));\n\t\tassertEquals(2, StringUtils.countWords(\" a b c d e f g h i j k l m n \", true));\n\t\tassertEquals(2, StringUtils.countWords(\" a b c d e f g h i j k l m n o \", false));\n\t\tassertEquals(2, StringUtils.countWords(\" a b c d e f g h i j k l m n o \", true));\n\t\tassertEquals(2, StringUtils.countWords(\" a b c d e f g h i j k l m n o p \", false));\n\t\tassertEquals(2, StringUtils.countWords(\" a b c d e f g h i j k l m n o p \", true));\n\t\tassertEquals(2, StringUtils.countWords(\" a b c d e f g h i j k l m n o p q \", false));\n\t\tassertEquals(2, StringUtils.countWords(\" a b c d e f g h i j k l m n o p q \", true));\n\t\tassertEquals(2, StringUtils.countWords(\" a b c d e f g h i j k l m n o p q r \", false));\n\t\tassertEquals(2, StringUtils.countWords(\" a b c d e f g h i j k l m n o p q r \", true));\n\t\tassertEquals(2, StringUtils.countWords(\" a b c d e f g h i j k l m n o p q r s \", false));\n\t\tassertEquals(2, StringUtils.countWords(\" a b c d e f g h i j k l m n o p q r s \", true));\n\t\tassertEquals(2, StringUtils.countWords(\" a b c d e f g h i j k l m n o p q r s t \", false));\n\t\tassertEquals(2, StringUtils.countWords(\" a b c d e f g h i j k l m n o p q r s t \", true));\n\t\tassertEquals(2, StringUtils.countWords(\" a b c d e f g h i j k l m n o p q r s t u \", false));\n\t\tassertEquals(2, StringUtils.countWords(\" a b c d e f g h i j k l m n o p q r s t u \", true));\n\t\tassertEquals(2, StringUtils.countWords(\" a b c d e f g h i j k l m n o p q r s t u v \", false));\n\t\tassertEquals(2, StringUtils.countWords(\" a b c d e f g h i j k l m n o p q r s t u v \", true));\n\t\tassertEquals(2, StringUtils.countWords(\" a b c d e f g h i j k l m n o p q r s t u v w \", false));\n\t\tassertEquals(2, StringUtils.countWords(\" a b c d e f g h i j k l m n o p q r s t u v w \", true));\n\t\tassertEquals(2, StringUtils.countWords(\" a b c d e f g h i j k l m n o p q r s t u v w x \", false));\n\t\tassertEquals(2, StringUtils.countWords(\" a b c d e f g h i j k l m n o p q r s t u v w x \", true));\n\t\tassertEquals(2, StringUtils.countWords(\" a b c d e f g h i j k l m n o p q r s t u v w x y \", false));\n\t\tassertEquals(2, StringUtils.countWords(\" a b c d e f g h i j k l m n o p q r s t u v w x y \", true));\n\t\tassertEquals(2, StringUtils.countWords(\" a b c d e f g h i j k l m n o p q r s t u v w x", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "4114800_10", "part": [1, 1], "seq": [1, 1], "prompt": "class HadoopTwitterTokenTool extends Configured implements Tool {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\ttry {\n\t\t\tToolRunner.run(new HadoopTwitterTokenTool(args), args);\n\t\t} catch (CmdLineException e) {\n\t\t\tSystem.err.print(e);\n\t\t}\n\t}\n\n\tpublic  HadoopTwitterTokenTool(String[] originalArgs);\n\n\t@Override public int run(String[] args);\n\n\t@Rule\n\tpublic TemporaryFolder folder;\n\tprivate String hadoopCommand;\n\tprivate File outputLocation;\n\tprivate File resultsOutputLocation;\n\tprivate File stemmedTweets;\n\tprivate File jsonTweets;\n\tprivate File monthLongTweets;\n\tprivate static final String JSON_TWITTER;\n\tprivate static int counter;\n\n}\n\nclass HadoopTwitterTokenToolTest {\n\n\t@Rule\n\tpublic TemporaryFolder folder;\n\tprivate String hadoopCommand;\n\tprivate File outputLocation;\n\tprivate File resultsOutputLocation;\n\tprivate File stemmedTweets;\n\tprivate File jsonTweets;\n\tprivate File monthLongTweets;\n\tprivate static final String JSON_TWITTER;\n\tprivate static int counter;\n\n\t@Test\n\tpublic void testMonthLongDFIDFCSVByTime() throws Exception {\n", "reference": "//\t\thadoopCommand = \"-i %s -o %s -om %s -ro %s -m %s -j %s -t 1 -wt . -wt !\";\n\t\tString command = String.format(hadoopCommand,\n\t\t\t\tmonthLongTweets.getAbsolutePath(),\n\t\t\t\toutputLocation.getAbsolutePath(), \"CSV\",\n\t\t\t\tresultsOutputLocation.getAbsolutePath(), \"DFIDF\",\n\t\t\t\t\"analysis.stemmed\");\n\t\tcommand += \" -svbt\";\n\t\tString[] args = command.split(\" \");\n\t\targs = (String[]) ArrayUtils.addAll(args, new String[] { \"-pp\",\"-m PORTER_STEM\" });\n\t\tSystem.out.println(Arrays.toString(args));\n\t\tHadoopTwitterTokenTool.main(args);\n\t\tPath p = new Path(resultsOutputLocation.getAbsolutePath());\n\t\tSystem.out.println(p);\n\t}\n\n}", "prediction": "\t\tHadoopTwitterTokenTool tool = new HadoopTwitterTokenTool(new String[] {\n\t\t\t\t\"-i\", JSON_TWITTER, \"-o\", outputLocation.getAbsolutePath(),\n\t\t\t\t\"-r\", resultsOutputLocation.getAbsolutePath(), \"-t\", \"month\",\n\t\t\t\t\"-c\", \"dfidfcsv\" });\n\t\ttool.run(new String[] {});\n\t\tassertTrue(resultsOutputLocation.exists());\n\t\tassertTrue(resultsOutputLocation.listFiles().length > 0);\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "4157021_33", "part": [1, 1], "seq": [1, 1], "prompt": "class PwEncoder {\n\n    public static String encode(String msg) {\n    \treturn encoder.encodePassword(msg.toCharArray(), null);\n    }\n\n    public static String decode(String msg);\n    public static boolean isPasswordValid(String encPass,String rawPass);\n    public static void setEncoder(GeoStorePasswordEncoder e);\n    public static GeoStorePasswordEncoder getEncoder();\n\n}\n\nclass PwEncoderTest {\n\n    @Test\n    public void testEncode() {\n", "reference": "        testString(\"test\");\n        testString(\"topolino\");\n        testString(\"\");\n\n    }\n\n}", "prediction": "\t\tString encoded = PwEncoder.encode(\"test\");\n        assertTrue(encoded.length() > 0);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "4166277_38", "part": [1, 1], "seq": [1, 1], "prompt": "class TagDictionary {\n\n    public int intern(TagCollection tags, TagSetEncoder encoder) {\n        TagSet ts = new TagSet(tags);\n        Integer id = tagSetDic.remove(ts);\n        if (id != null) {\n            tagSetDic.put(ts, id); // TODO garbage hotspot\n            return id;\n        }\n        else if (tagSetDic.size() < limit) {\n            id = tagSetDic.size();\n            encodeTag(id, ts, encoder);\n            return id;\n        }\n        else {\n            id = evict();\n            encodeTag(id, ts, encoder);\n            return id;\n        }\n    }\n\n    public  TagDictionary(int limit);\n\n    protected int evict();\n    private void encodeTag(int id, TagSet ts, TagSetEncoder encoder);\n    private void touch(TagSet baseSet, int baseRef);\n    private int distance(TagSet base, TagSet set, TagSetEncoder encoder);\n    private void encode(TagSet base, TagSet set, TagSetEncoder encoder);\n    protected void encodeRemoveTag(TagSet base, TagSetEncoder encoder, int nb);\n\n     TagDictionary dic;\n     TestEncoder encoder;\n\n}\n\nclass TagDictionaryTest {\n\n     TagDictionary dic;\n     TestEncoder encoder;\n\n    @Test\n    public void tag_key_override() {\n", "reference": "        int id1 = dic.intern(tags(\"A\", \"long\", \"B\", \"2\"), encoder);\n        int id2 = dic.intern(tags(\"A\", \"long\", \"B\", \"1\"), encoder);\n        int id3 = dic.intern(tags(\"A\", \"long\", \"B\", \"3\"), encoder);\n\n        assertThat(id1).isEqualTo(1);\n        assertThat(id2).isEqualTo(2);\n        assertThat(id3).isEqualTo(3);\n        // reader must apply adds before removals\n        assertThat(encoder.toString()).isEqualTo(\n          \"[1,0] +A:long +B:2! [2,1] +B:1 -B! [3,1] -B +B:3!\");\n    }\n\n}", "prediction": "        TagCollection tags = new TagCollection();\n        tags.add(\"a\", \"b\");\n        tags.add(\"a\", \"c\");\n        tags.add(\"a\", \"d\");\n        tags.add(\"a\", \"e\");\n        tags.add(\"a\", \"f\");\n        tags.add(\"a\", \"g\");\n        tags.add(\"a\", \"h\");\n        tags.add(\"a\", \"i\");\n        tags.add(\"a\", \"j\");\n        tags.add(\"a\", \"k\");\n        tags.add(\"a\", \"l\");\n        tags.add(\"a\", \"m\");\n        tags.add(\"a\", \"n\");\n        tags.add(\"a\", \"o\");\n        tags.add(\"a\", \"p\");\n        tags.add(\"a\", \"q\");\n        tags.add(\"a\", \"r\");\n        tags.add(\"a\", \"s\");\n        tags.add(\"a\", \"t\");\n        tags.add(\"a\", \"u\");\n        tags.add(\"a\", \"v\");\n        tags.add(\"a\", \"w\");\n        tags.add(\"a\", \"x\");\n        tags.add(\"a\", \"y\");\n        tags.add(\"a\", \"z\");\n        tags.add(\"a\", \"aa\");\n        tags.add(\"a\", \"ab\");\n        tags.add(\"a\", \"ac\");\n        tags.add(\"a\", \"ad\");\n        tags.add(\"a\", \"ae\");\n        tags.add(\"a\", \"af\");\n        tags.add(\"a\", \"ag\");\n        tags.add(\"a\", \"ah\");\n        tags.add(\"a\", \"ai\");\n        tags.add(\"a\", \"aj\");\n        tags.add(\"a\", \"ak\");\n        tags.add(\"a\", \"al\");\n        tags.add(\"a\", \"am\");\n        tags.add(\"a\", \"an\");\n        tags.add(\"a\", \"ao\");\n        tags.add(\"a\", \"ap\");\n        tags.add(\"a\", \"aq\");\n        tags.add(\"a\", \"ar\");\n        tags.add(\"a\", \"as\");\n        tags.add(\"a\", \"at\");\n        tags.add(\"a\", \"au\");\n        tags.add(\"a\", \"av\");\n        tags.add(\"a\", \"aw\");\n        tags.add(\"a\", \"ax\");\n        tags.add(\"a\", \"ay\");\n        tags.add(\"a\", \"az\");\n        tags.add(\"a\", \"ba\");\n        tags.add(\"a\", \"bb\");\n        tags.add(\"a\", \"bc\");\n        tags.add(\"a\", \"bd\");\n        tags.add(\"a\", \"be\");\n        tags.add(\"a\", \"bf\");\n        tags.add(\"a\", \"bg\");\n        tags.add(\"a\", \"bh\");\n        tags.add(\"a\", \"bi\");\n        tags.add(\"a\", \"bj\");\n        tags.add(\"a\", \"bk\");\n        tags.add(\"a\", \"bl\");\n        tags.add(\"a\", \"bm\");\n        tags.add(\"a\", \"bn\");\n        tags.add(\"a\", \"bo\");\n        tags.add(\"a\", \"bp\");\n        tags.add(\"a\", \"bq\");\n        tags.add(\"a\", \"br\");\n        tags.add(\"a\", \"bs\");\n        tags.add(\"a\", \"bt\");\n        tags.add(\"a\", \"bu\");\n        tags.add(\"a\", \"bv\");\n        tags.add(\"a\", \"bw\");\n        tags.add(\"a\", \"bx\");\n        tags.add(\"a\", \"by\");\n        tags.add(\"a\", \"bz\");\n        tags.add(\"a\", \"ca\");\n        tags.add(\"a\", \"cb\");\n        tags.add(\"a\", \"cc\");\n        tags.add(\"a\", \"cd\");\n        tags.add(\"a\", \"ce\");\n        tags.add(\"a\", \"cf\");\n        tags.add(\"a\", \"cg\");\n        tags.add(\"a\", \"ch\");\n        tags.add(\"a\", \"ci\");\n        tags.add(\"a\", \"cj\");\n        tags.add(\"a\", \"ck\");\n        tags.add(\"a\", \"cl\");\n        tags.add(\"a\", \"cm\");\n        tags.add(\"a\", \"cn\");\n        tags.add(\"a\", \"co\");\n        tags.add(\"a\", \"cp\");\n        tags.add(\"a\", \"cq\");\n        tags.add(\"a\", \"cr\");\n        tags.add(\"a\", \"cs\");\n        tags.add(\"a\", \"ct\");\n        tags.add(\"a\", \"cu\");\n        tags.add(\"a\", \"cv\");\n        tags.add(\"a\", \"cw\");\n        tags.add(\"a\", \"cx\");\n        tags.add(\"a\", \"cy\");\n        tags.add(\"a\", \"cz\");\n        tags.add(\"a\", \"da\");\n        tags.add(\"a\", \"db\");\n        tags.add(\"a\", \"dc\");\n        tags.add(\"a\", \"dd\");\n        tags.add(\"a\", \"de\");\n        tags.add(\"a\", \"df\");\n        tags.add(\"a\", \"dg\");\n        tags.add(\"a\", \"dh\");\n        tags.add(\"a\", \"di\");\n        tags.add(\"a\", \"dj\");\n        tags.add(\"a\", \"dk\");\n        tags.add(\"a\", \"dl\");\n        tags.add(\"a\", \"dm\");\n        tags.add(\"a\", \"dn\");\n        tags.add(\"a\", \"do\");\n        tags.add(\"a\", \"dp\");\n        tags.add(\"a\", \"dq\");\n        tags.add(\"a\", \"dr\");\n        tags.add(\"a\", \"ds\");\n        tags.add(\"a\", \"dt\");\n        tags.add(\"a\", \"du\");\n        tags.add(\"a\", \"dv\");\n        tags.add(\"a\", \"dw\");\n        tags.add(\"a\", \"dx\");\n        tags.add(\"a\", \"dy\");\n        tags.add(\"a\", \"dz\");\n        tags.add(\"a\", \"ea\");\n        tags.add(\"a\", \"eb\");\n        tags.add(\"a\", \"ec\");\n        tags.add(\"a\", \"ed\");\n        tags.add(\"a\", \"ee\");\n        tags.add(\"a\", \"ef\");\n        tags.add(\"a\", \"eg\");\n        tags.add(\"a\", \"eh\");\n        tags.add(\"a\", \"ei\");\n        tags.add(\"a\", \"ej\");\n        tags.add(\"a\", \"ek\");\n        tags.add(\"a\", \"el\");\n        tags.add(\"a\", \"em\");\n        tags.add(\"a\", \"en\");\n        tags.add(\"a\", \"eo\");\n        tags.add(\"a\", \"ep\");\n        tags.add(\"a\", \"eq\");\n        tags.add(\"a\", \"er\");\n        tags.add(\"a\", \"es\");\n        tags.add(\"a\", \"et\");\n        tags.add(\"a\", \"eu\");\n        tags.add(\"a\", \"ev\");\n        tags.add(\"a\", \"ew\");\n        tags.add(\"a\",", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "4269155_325", "part": [1, 1], "seq": [1, 1], "prompt": "class StateAwareParameterMap implements Map<String, String[]> {\n\n    @Override\n    public int size() {\n        return requestMap.size();\n    }\n\n    public  StateAwareParameterMap(Map<String, String[]> requestMap,\n            Map<String, String[]> responseMap);\n\n    @Override public void clear();\n    @Override public boolean containsKey(Object key);\n    @Override public boolean containsValue(Object value);\n    @Override public Set<java.util.Map.Entry<String, String[]>> entrySet();\n    @Override public String[] get(Object key);\n    @Override public boolean isEmpty();\n    @Override public Set<String> keySet();\n    @Override public String[] put(String key, String[] value);\n    @Override public void putAll(Map<? extends String, ? extends String[]> m);\n    @Override public String[] remove(Object key);\n    @Override public Collection<String[]> values();\n\n    private Map<String, String[]> requestMap;\n    private Map<String, String[]> responseMap;\n    private StateAwareParameterMap map;\n\n}\n\nclass StateAwareParameterMapTest {\n\n    private Map<String, String[]> requestMap;\n    private Map<String, String[]> responseMap;\n    private StateAwareParameterMap map;\n\n    @Test\n    public void testSize() {\n", "reference": "        expect(requestMap.size()).andReturn(1);\n\n        replay(requestMap, responseMap);\n        assertEquals(1, map.size());\n        verify(requestMap, responseMap);\n    }\n\n}", "prediction": "        assertEquals(requestMap.size(), map.size());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "4354801_2", "part": [1, 1], "seq": [1, 1], "prompt": "class TaintFrame extends Frame<Taint> {\n\n    public String toString(MethodGen method) {\n        String[] variables = new String[method.getLocalVariables().length];\n        LocalVariableGen[] variablesGen = method.getLocalVariables();\n        for(int i=0; i<variablesGen.length ;i++) {\n            variables[i] = variablesGen[i].getName();\n        }\n        return toString(variables);\n    }\n\n    public  TaintFrame(int numLocals);\n\n    @Override public String toString();\n    public String toString(String[] variableNames);\n\n}\n\nclass TaintFrameTest {\n\n    @Test\n    public void validateSimpleTaintFrameWithLocal() {\n", "reference": "\n        TaintFrame frame = new TaintFrame(4);\n        frame.setValue(0, new Taint(Taint.State.TAINTED));\n        frame.setValue(1, new Taint(Taint.State.TAINTED));\n        frame.setValue(2, new Taint(Taint.State.UNKNOWN));\n        frame.setValue(3, new Taint(Taint.State.UNKNOWN));\n        frame.pushValue(new Taint(Taint.State.TAINTED));\n        frame.pushValue(new Taint(Taint.State.UNKNOWN));\n        frame.pushValue(new Taint(Taint.State.NULL));\n        frame.pushValue(new Taint(Taint.State.SAFE));\n\n        String[] variables = new String[] {\"safe\",\"null_value\",\"external\",\"modifyMe\"};\n        String debugOutput = frame.toString(variables);\n        System.out.println(debugOutput);\n        assertTrue(debugOutput.contains(\"0. SAFE {S}\"));\n        assertTrue(debugOutput.contains(\"1. NULL {N}\"));\n        assertTrue(debugOutput.contains(\"2. UNKNOWN {U}\"));\n        assertTrue(debugOutput.contains(\"3. TAINTED {T}\"));\n\n        for(String variable : variables) {\n            assertTrue(debugOutput.contains(\"| \"+variable));\n        }\n    }\n\n}", "prediction": "        TaintFrame frame = new TaintFrame(1);\n        frame.setTaint(0, new Taint(1));\n        assertEquals(\"TaintFrame{0:1}\", frame.toString());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "4384653_28", "part": [1, 1], "seq": [1, 1], "prompt": "class ReflectionUtils {\n\n    public static List<Method> findMethods(Class<?> clazz, String nameRegex,\n            ParamCount numberOfParams) {\n        // Create the Pattern and Matcher outside the loop to optimize\n        // performance (and possibly memory usage).\n        Pattern p = Pattern.compile(nameRegex);\n        Matcher m = p.matcher(\"\");\n\n        List<Method> methods = new ArrayList<Method>();\n        for (Method method : clazz.getMethods()) {\n            if (numberOfParams.matches(method.getParameterTypes().length)\n                    && m.reset(method.getName()).matches()) {\n                methods.add(method);\n            }\n        }\n        return methods;\n    }\n\n    private  ReflectionUtils();\n\n    public static List<Method> findMethods(Class<?> clazz, String nameRegex,\n            Class<?>... paramTypes);\n    public static boolean isComponent(Class<?> componentClass);\n    public static List<Field> getAllDeclaredFields(Class<?> type);\n    public static List<Field> getAllDeclaredFieldsAnnotatedWith(Class<?> type,\n            Class<? extends Annotation> annotationType);\n    public static List<Method> getAllDeclaredMethods(Class<?> type);\n    public static List<Method> getAllDeclaredMethodsAnnotatedWith(Class<?> type,\n            Class<? extends Annotation> annotationType);\n    private static void filterByAnnotationType(List<? extends AnnotatedElement> fields,\n            Class<? extends Annotation> annotationType);\n\n}\n\nclass ReflectionUtilsTest {\n\n    @Test\n    public void test_findMethodsByConstantParamCount_constant3() {\n", "reference": "        assertEquals(\n                0,\n                findMethods(SubClassToExamine.class, \"setFooBar\",\n                        ParamCount.constant(3)).size());\n    }\n\n}", "prediction": "        List<Method> methods = ReflectionUtils.findMethods(\n                ReflectionUtilsTest.class, \"test_findMethodsByConstantParamCount_constant3\",\n                ParamCount.constant(3));\n        assertEquals(1, methods.size());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "4459604_20", "part": [1, 1], "seq": [1, 1], "prompt": "class HandlebarsException extends RuntimeException {\n\n  public HandlebarsError getError() {\n    return error;\n  }\n\n  public  HandlebarsException(final HandlebarsError error);\n  public  HandlebarsException(final Throwable cause);\n  public  HandlebarsException(final HandlebarsError error,\n      final Throwable cause);\n  public  HandlebarsException(final String message, final Throwable cause);\n\n}\n\nclass HandlebarsExceptionTest {\n\n  @Test\n  public void withError() {\n", "reference": "    HandlebarsError error = createMock(HandlebarsError.class);\n    HandlebarsException ex = new HandlebarsException(error);\n    assertEquals(error, ex.getError());\n  }\n\n}", "prediction": "    HandlebarsException exception = new HandlebarsException(new HandlebarsError(\"foo\", \"bar\", \"baz\"));\n    assertEquals(\"foo\", exception.getError().getTemplateName());\n    assertEquals(\"bar\", exception.getError().getLineNumber());\n    assertEquals(\"baz\", exception.getError().getDescription());\n  }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "4671935_62", "part": [1, 1], "seq": [1, 1], "prompt": "class StringBuilderUtil {\n\n    public static void format2f(@NonNull StringBuilder sb, float x) {\n        final int x100 = Math.round(x * 100);\n        final int whole = x100 / 100;\n        final int tenths = x100 / 10 % 10;\n        final int hundredths = x100 % 10;\n        sb.append(whole);\n        sb.append(\".\");\n        sb.append(tenths);\n        sb.append(hundredths);\n    }\n\n    public static void format3f(@NonNull StringBuilder sb, double x);\n    public static void format2d(@NonNull StringBuilder sb, long x);\n    public static void format3d(@NonNull StringBuilder sb, long x);\n\n    private final double[] testDoubles;\n    private final float[] testFloats;\n    private final long[] testLongs;\n\n}\n\nclass StringBuilderUtilTest {\n\n    private final double[] testDoubles;\n    private final float[] testFloats;\n    private final long[] testLongs;\n\n    @Test\n    public void format2f() {\n", "reference": "        StringBuilder sb = new StringBuilder();\n\n        for (float value : testFloats) {\n            sb.setLength(0);\n            StringBuilderUtil.format2f(sb, value);\n            assertEquals(String.format(\"%.2f\", value), sb.toString());\n        }\n    }\n\n}", "prediction": "        StringBuilder sb = new StringBuilder();\n        StringBuilderUtil.format2f(sb, 1.23456789);\n        assertEquals(\"1.23\", sb.toString());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "4705783_5", "part": [1, 1], "seq": [1, 1], "prompt": "class XmlCredentialsUtil {\n\n    public static XMLConfiguration createXmlConfiguration(final String fileName) {\n        try {\n            return new XMLConfiguration(IntegrityUtil.ensure(fileName, \"Must provide a file name\"));\n        } catch (final ConfigurationException configurationException) {\n            throw new RuntimeException(\"Trouble using file name [\" + fileName + \"]\", configurationException);\n        }\n    }\n\n    public static XMLConfiguration createXmlConfiguration(final File file);\n    public static XMLConfiguration createXmlConfiguration(final URL url);\n    public static Credentials convertToCredentials(final HierarchicalConfiguration hierarchicalConfiguration, final Object url, final String userNameElement, final String passwordElement, final String tokenElement, final Object apiVersion);\n    public static Collection<Credentials> getCredentials(final XMLConfiguration xmlConfiguration, final String rootElement, final String urlElement, final String userNameElement, final String passwordElement, final String tokenElement, final String apiVersionElement);\n    public static Collection<Credentials> getCredentials(final String fileName, final String rootElement, final String urlElement, final String userNameElement, final String passwordElement, final String tokenElement, final String apiVersionElement);\n    public static Collection<Credentials> getCredentials(final File file, final String rootElement, final String urlElement, final String userNameElement, final String passwordElement, final String tokenElement, final String apiVersionElement);\n    public static Collection<Credentials> getCredentials(final URL url, final String rootElement, final String urlElement, final String userNameElement, final String passwordElement, final String tokenElement, final String apiVersionElement);\n\n}\n\nclass XmlCredentialsUtilTest {\n\n    @Test(expected = RuntimeException.class)\n    public void test_createXmlConfiguration_emptyString() {\n", "reference": "        XmlCredentialsUtil.createXmlConfiguration(\"\");\n    }\n\n}", "prediction": "        XmlCredentialsUtil.createXmlConfiguration(\"\");\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "4710920_884", "part": [1, 1], "seq": [1, 1], "prompt": "class AbstractMethodBuilder extends AbstractBuilder<T, B> {\n\n    public B retries(Integer retries) {\n        this.retries = retries;\n        return getThis();\n    }\n\n    public B timeout(Integer timeout);\n    public B actives(Integer actives);\n    public B loadbalance(String loadbalance);\n    public B async(Boolean async);\n    public B sent(Boolean sent);\n    public B mock(String mock);\n    public B mock(Boolean mock);\n    public B merger(String merger);\n    public B cache(String cache);\n    public B validation(String validation);\n    public B appendParameters(Map<String, String> appendParameters);\n    public B appendParameter(String key, String value);\n    public B forks(Integer forks);\n    @Override @SuppressWarnings(\"unchecked\") public void build(T instance);\n\n}\n\nclass AbstractMethodBuilderTest {\n\n    @Test\n    void retries() {\n", "reference": "        MethodBuilder builder = new MethodBuilder();\n        builder.retries(3);\n\n        Assertions.assertEquals(3, builder.build().getRetries());\n    }\n\n}", "prediction": "        MethodConfig methodConfig = new MethodConfig();\n        AbstractMethodBuilder<MethodConfig, AbstractMethodBuilder> builder = new AbstractMethodBuilder<MethodConfig, AbstractMethodBuilder>() {\n            @Override\n            protected AbstractMethodBuilder getThis() {\n                return this;\n            }\n\n            @Override\n            public void build(MethodConfig instance) {\n                assertEquals(1, instance.getRetries());\n            }\n        };\n        builder.retries(1).build(methodConfig);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "4713588_6", "part": [1, 1], "seq": [1, 1], "prompt": "class DrugOrderCohortDefinitionEvaluator implements CohortDefinitionEvaluator {\n\n\tpublic EvaluatedCohort evaluate(CohortDefinition cohortDefinition, EvaluationContext context) {\n\t\tDrugOrderCohortDefinition drugOrderCohortDefinition = (DrugOrderCohortDefinition) cohortDefinition;\n\t\tcontext = ObjectUtil.nvl(context, new EvaluationContext());\n\n\t\tHqlQueryBuilder query = new HqlQueryBuilder();\n\t\tquery.select(\"drugOrder.patient.patientId\");\n\t\tquery.from(DrugOrder.class, \"drugOrder\");\n\n\t\tquery.wherePatientIn(\"drugOrder.patient.patientId\", context);\n\t\t\n\t\tif (drugOrderCohortDefinition.getWhich() == null) drugOrderCohortDefinition.setWhich(Match.ANY); \n\t\t\t\n\t    if (drugOrderCohortDefinition.getDrugSets() != null) {\n\t    \t\n\t    \tif (drugOrderCohortDefinition.getWhich() == Match.ANY) {\n\t\t    \tquery.whereInAny(\"drugOrder.concept\", drugOrderCohortDefinition.getDrugSets().toArray());\n\t    \t} \n\t    \telse if (drugOrderCohortDefinition.getWhich() == Match.ALL) {\n\t\t    \tquery.whereIn(\"drugOrder.concept\", drugOrderCohortDefinition.getDrugSets());\n\t\t    \tquery.groupBy(\n\t\t\t        \t\t\"drugOrder.patient.patientId\" + \" having count(distinct drugOrder.concept.conceptId) = \" + drugOrderCohortDefinition.getDrugSets().size());\n\t    \t} \n\t    \telse if (drugOrderCohortDefinition.getWhich() == Match.NONE) {\n\t\t    \tquery.whereNotInAny(\"drugOrder.concept\", drugOrderCohortDefinition.getDrugSets());\n\t    \t}\n\t    }\n\t\n\t    if (drugOrderCohortDefinition.getDrugConcepts() != null) {\n\t    \tif (drugOrderCohortDefinition.getWhich() == Match.ANY) {\n\t    \t\tquery.whereInAny(\"drugOrder.concept\", drugOrderCohortDefinition.getDrugConcepts().toArray());\n\t    \t} \n\t    \telse if (drugOrderCohortDefinition.getWhich() == Match.ALL) {\n\t    \t\tquery.whereIn(\"drugOrder.concept\", drugOrderCohortDefinition.getDrugConcepts());\n\t    \t\tquery.groupBy(\n\t    \t\t\t\t\"drugOrder.patient.patientId\" + \" having count(distinct drugOrder.concept.conceptId) = \" + drugOrderCohortDefinition.getDrugSets().size());\n\t    \t} \n\t    \telse if (drugOrderCohortDefinition.getWhich() == Match.NONE) {\n\t    \t\tquery.whereNotInAny(\"drugOrder.concept\", drugOrderCohortDefinition.getDrugConcepts());\n\t    \t}\n\t    }\n\t\n\t    if (drugOrderCohortDefinition.getDrugs() != null) {\n\t    \tif (drugOrderCohortDefinition.getWhich() == Match.ANY) {\n\t    \t\tquery.whereInAny(\"drugOrder.drug\", drugOrderCohortDefinition.getDrugs().toArray());\n\t    \t} \n\t    \telse if (drugOrderCohortDefinition.getWhich() == Match.ALL) {\n\t    \t\tquery.whereIn(\"drugOrder.drug\", drugOrderCohortDefinition.getDrugs());\n\t    \t\tquery.groupBy(\n\t    \t\t\t\t\"drugOrder.patient.patientId\" + \" having count(distinct drugOrder.drug.drugId) = \" + drugOrderCohortDefinition.getDrugs().size());\n\t    \t} \n\t    \telse if (drugOrderCohortDefinition.getWhich() == Match.NONE) {\n\t    \t\tquery.whereNotInAny(\"drugOrder.drug\", drugOrderCohortDefinition.getDrugs());\n\t    \t}\n\t    }\n\t \n    \tquery.whereLessOrEqualTo(\"drugOrder.dateActivated\", drugOrderCohortDefinition.getActivatedOnOrBefore());\n    \tquery.whereGreaterOrEqualTo(\"drugOrder.dateActivated\", drugOrderCohortDefinition.getActivatedOnOrAfter());\n    \tquery.whereEqual(\"drugOrder.careSetting\", drugOrderCohortDefinition.getCareSetting());\n    \t\n    \tif (drugOrderCohortDefinition.getActiveOnOrBefore() != null) {\n\t    \tquery.whereNotNull(\"drugOrder.dateActivated\").and()\n\t    \t\t .whereLessOrEqualTo(\"drugOrder.dateStopped\", drugOrderCohortDefinition.getActiveOnOrBefore())\n\t    \t\t .or()\n\t    \t\t .whereLessOrEqualTo(\"drugOrder.autoExpireDate\", drugOrderCohortDefinition.getActiveOnOrBefore());\n    \t}\n    \t\n    \tquery.whereNotNull(\"drugOrder.dateActivated\").and()\n    \t\t .whereGreaterEqualOrNull(\"drugOrder.dateStopped\", drugOrderCohortDefinition.getActiveOnOrAfter())\n    \t\t .and()\n    \t\t .whereGreaterEqualOrNull(\"drugOrder.autoExpireDate\", drugOrderCohortDefinition.getActiveOnOrAfter());\n    \t\t \n    \tquery.whereNotNull(\"drugOrder.dateActivated\").and()\n    \t\t .whereLessOrEqualTo(\"drugOrder.dateActivated\", drugOrderCohortDefinition.getActiveOnDate())    \t\t \n    \t\t .whereGreaterOrNull(\"drugOrder.dateStopped\", drugOrderCohortDefinition.getActiveOnDate())\n    \t\t .and()\n    \t\t .whereGreaterOrNull(\"drugOrder.autoExpireDate\", drugOrderCohortDefinition.getActiveOnDate());\n    \t\t \n\t    List<Integer> patientIds = evaluationService.evaluateToList(query, Integer.class, context);\n\t    Cohort cohort = new Cohort(patientIds);\n\t\n\t    return new EvaluatedCohort(cohort, drugOrderCohortDefinition, context);\n\t}\n\n\tpublic  DrugOrderCohortDefinitionEvaluator();\n\n  \tprotected static final String TEST_DATA;\n  \tprivate DrugOrderCohortDefinition cohortDefinition;\n\n}\n\nclass DrugOrderCohortDefinitionEvaluatorTest  {\n\n  \tprotected static final String TEST_DATA;\n  \tprivate DrugOrderCohortDefinition cohortDefinition;\n\n  \t@Test\n  \tpublic void evaluateShouldReturnAllPatientsThatHaveTakenAnyDrugByDefault() throws Exception {\n", "reference": "  \t\tList drugs = new ArrayList<Drug>();\n  \t\tdrugs.add(new Drug(11));\n  \t\tdrugs.add(new Drug(2));\n  \t\tcohortDefinition.setDrugs(drugs);\n  \t\tCohort cohort = Context.getService(CohortDefinitionService.class).evaluate(cohortDefinition, null);\n  \t\tAssert.assertTrue(cohort.contains(2));\n  \t\tAssert.assertTrue(cohort.contains(8));\n  \t\tAssert.assertTrue(cohort.contains(21));\n  \t\tAssert.assertTrue(cohort.contains(22));\n  \t\tAssert.assertEquals(4, cohort.size());\n  \t\t\n  \t}\n\n}", "prediction": " \t\tEvaluationContext context = new EvaluationContext();\n\t\tcontext.setPatientIds(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));\n\t\tEvaluatedCohort evaluatedCohort = evaluator.evaluate(cohortDefinition, context);\n\t\tassertEquals(10, evaluatedCohort.getCohort().getPatientIds().size());\n\t}", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "4802269_26", "part": [1, 1], "seq": [1, 1], "prompt": "class DXProject extends DXContainer {\n\n    public static Builder newProject() {\n        return new Builder();\n    }\n\n    private  DXProject(String projectId);\n    private  DXProject(String projectId, DXEnvironment env);\n\n    private static void checkProjectId(String projectId);\n    public static DXProject getInstance(String projectId);\n    public static DXProject getInstanceWithEnvironment(String projectId, DXEnvironment env);\n    public static Builder newProjectWithEnvironment(DXEnvironment env);\n    public Describe describe();\n    public void destroy();\n    public void destroy(boolean terminateJobs);\n\n    private DXProject testProject;\n\n}\n\nclass DXProjectTest {\n\n    private DXProject testProject;\n\n    @Test\n    public void testCreatProjectSerialization() throws IOException {\n", "reference": "        Assert.assertEquals(DXJSON.parseJson(\"{\\\"name\\\": \\\"projectname\\\"}\"), DXProject.newProject()\n                .setName(\"projectname\").buildRequestHash());\n    }\n\n}", "prediction": "        String projectId = testProject.getId();\n        DXProject project = DXProject.getInstance(projectId);\n        assertEquals(projectId, project.getId());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "5012085_4", "part": [1, 1], "seq": [1, 1], "prompt": "class NullValuePredicate implements ValuePredicate<Object> {\n\n    @Override\n    public boolean apply(final Object input) {\n\t    return input == null;\n    }\n\n    private  NullValuePredicate();\n\n    @Override public String toString();\n    @Override public final int hashCode();\n    @Override public final boolean equals(Object obj);\n\n}\n\nclass NullValuePredicateTest {\n\n\t@Test\n\tpublic void testNullIsAccepted() {\n", "reference": "\t\tassertTrue(NullValuePredicate.INSTANCE.apply(null));\n\t}\n\n}", "prediction": "\t\tassertTrue(new NullValuePredicate().apply(null));\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "5104614_0", "part": [1, 1], "seq": [1, 1], "prompt": "class JellyHyperlinkProvider implements HyperlinkProviderExt {\n\n    @Override public int[] getHyperlinkSpan(Document doc, int offset, HyperlinkType type) {\n        return hyperlinkSpan(doc, offset);\n    }\n\n    @Override public Set<HyperlinkType> getSupportedHyperlinkTypes();\n    @Override public boolean isHyperlinkPoint(Document doc, int offset, HyperlinkType type);\n    @Override public void performClickAction(Document doc, int offset, HyperlinkType type);\n    @Override public String getTooltipText(Document doc, int offset, HyperlinkType type);\n    static int[] hyperlinkSpan(Document doc, int offset);\n    static @CheckForNull String correspondingJellyResource(Document doc, int offset);\n\n    private Document doc;\n\n}\n\nclass JellyHyperlinkProviderTest {\n\n    private Document doc;\n\n    @Test public void getHyperlinkSpan() throws Exception {\n", "reference": "        assertEquals(\"f:entry\", textFrom(JellyHyperlinkProvider.hyperlinkSpan(doc, offsetOf(\"ntry title=\\\"${\"))));\n        assertEquals(\"f:repeatableDeleteButton\", textFrom(JellyHyperlinkProvider.hyperlinkSpan(doc, offsetOf(\"peatableD\"))));\n        assertEquals(\"f:textbox\", textFrom(JellyHyperlinkProvider.hyperlinkSpan(doc, offsetOf(\"f:textbox\"))));\n        assertEquals(\"p:config-trigger\", textFrom(JellyHyperlinkProvider.hyperlinkSpan(doc, offsetOf(\"ig-tr\"))));\n    }\n\n}", "prediction": "        assertEquals(new int[] { 0, 1 }, JellyHyperlinkProvider.hyperlinkSpan(doc, 0));\n        assertEquals(new int[] { 0, 1 }, JellyHyperlinkProvider.hyperlinkSpan(doc, 1));\n        assertEquals(new int[] { 0, 1 }, JellyHyperlinkProvider.hyperlinkSpan(doc, 2));\n        assertEquals(new int[] { 0, 1 }, JellyHyperlinkProvider.hyperlinkSpan(doc, 3));\n        assertEquals(new int[] { 0, 1 }, JellyHyperlinkProvider.hyperlinkSpan(doc, 4));\n        assertEquals(new int[] { 0, 1 }, JellyHyperlinkProvider.hyperlinkSpan(doc, 5));\n        assertEquals(new int[] { 0, 1 }, JellyHyperlinkProvider.hyperlinkSpan(doc, 6));\n        assertEquals(new int[] { 0, 1 }, JellyHyperlinkProvider.hyperlinkSpan(doc, 7));\n        assertEquals(new int[] { 0, 1 }, JellyHyperlinkProvider.hyperlinkSpan(doc, 8));\n        assertEquals(new int[] { 0, 1 }, JellyHyperlinkProvider.hyperlinkSpan(doc, 9));\n        assertEquals(new int[] { 0, 1 }, JellyHyperlinkProvider.hyperlinkSpan(doc, 10));\n        assertEquals(new int[] { 0, 1 }, JellyHyperlinkProvider.hyperlinkSpan(doc, 11));\n        assertEquals(new int[] { 0, 1 }, JellyHyperlinkProvider.hyperlinkSpan(doc, 12));\n        assertEquals(new int[] { 0, 1 }, JellyHyperlinkProvider.hyperlinkSpan(doc, 13));\n        assertEquals(new int[] { 0, 1 }, JellyHyperlinkProvider.hyperlinkSpan(doc, 14));\n        assertEquals(new int[] { 0, 1 }, JellyHyperlinkProvider.hyperlinkSpan(doc, 15));\n        assertEquals(new int[] { 0, 1 }, JellyHyperlinkProvider.hyperlinkSpan(doc, 16));\n        assertEquals(new int[] { 0, 1 }, JellyHyperlinkProvider.hyperlinkSpan(doc, 17));\n        assertEquals(new int[] { 0, 1 }, JellyHyperlinkProvider.hyperlinkSpan(doc, 18));\n        assertEquals(new int[] { 0, 1 }, JellyHyperlinkProvider.hyperlinkSpan(doc, 19));\n        assertEquals(new int[] { 0, 1 }, JellyHyperlinkProvider.hyperlinkSpan(doc, 20));\n        assertEquals(new int[] { 0, 1 }, JellyHyperlinkProvider.hyperlinkSpan(doc, 21));\n        assertEquals(new int[] { 0, 1 }, JellyHyperlinkProvider.hyperlinkSpan(doc, 22));\n        assertEquals(new int[] { 0, 1 }, JellyHyperlinkProvider.hyperlinkSpan(doc, 23));\n        assertEquals(new int[] { 0, 1 }, JellyHyperlinkProvider.hyperlinkSpan(doc, 24));\n        assertEquals(new int[] { 0, 1 }, JellyHyperlinkProvider.hyperlinkSpan(doc, 25));\n        assertEquals(new int[] { 0, 1 }, JellyHyperlinkProvider.hyperlinkSpan(doc, 26));\n        assertEquals(new int[] { 0, 1 }, JellyHyperlinkProvider.hyperlinkSpan(doc, 27));\n        assertEquals(new int[] { 0, 1 }, JellyHyperlinkProvider.hyperlinkSpan(doc, 28));\n        assertEquals(new int[] { 0, 1 }, JellyHyperlinkProvider.hyperlinkSpan(doc, 29));\n        assertEquals(new int[] { 0, 1 }, JellyHyperlinkProvider.hyperlinkSpan(doc, 30));\n        assertEquals(new int[] { 0, 1 }, JellyHyperlinkProvider.hyperlinkSpan(doc, 31));\n        assertEquals(new int[] { 0, 1 }, JellyHyperlinkProvider.hyperlinkSpan(doc, 32));\n        assertEquals(new int[] { 0, 1 }, JellyHyperlinkProvider.hyperlinkSpan(doc, 33));\n        assertEquals(new int[] { 0, 1 }, JellyHyperlinkProvider.hyperlinkSpan(doc, 34));\n        assertEquals(new int[] { 0, 1 }, JellyHyperlinkProvider.hyperlinkSpan(doc, 35));\n        assertEquals(new int[] { 0, 1 }, JellyHyperlinkProvider.hyperlinkSpan(doc, 36));\n        assertEquals(new int[] { 0, 1 }, JellyHyperlinkProvider.hyperlinkSpan(doc, 37));\n        assertEquals(new int[] { 0, 1 }, JellyHyperlinkProvider.hyperlinkSpan(doc, 38));\n        assertEquals(new int[] { 0, 1 }, JellyHyperlinkProvider.hyperlinkSpan(doc, 39));\n        assertEquals(new int[] { 0, 1 }, JellyHyperlinkProvider.hyperlinkSpan(doc, 40));\n        assertEquals(new int[] { 0, 1 }, JellyHyperlinkProvider.hyperlinkSpan(doc, 41));\n        assertEquals(new int[] { 0, 1 }, JellyHyperlinkProvider.hyperlinkSpan(doc, 42));\n        assertEquals(new int[] { 0, 1 }, JellyHyperlinkProvider.hyperlinkSpan(doc, 43));\n        assertEquals(new int[] { 0", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "5155211_6", "part": [1, 1], "seq": [1, 1], "prompt": "class ParameterService {\n\n\tpublic synchronized void setParam(Parameter param, Object value) {\n\t\t\n\t\t// check either param is registered\n\t\tif (getParam(param.getId()) != param) {\n\t\t\tthrow new IllegalArgumentException(String.format(\"parameter provided with id %s is not the same as the registered one\"));\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tif (recursionOn) {\n\t\t\t\tthrow new IllegalStateException(\"recursion detected - parameter listeners are not allowed to modify parameters from within same thread\");\n\t\t\t}\n\t\t\t\n\t\t\trecursionOn = true;\n\t\t\t\n\t\t\tif (param.setParameterValue(value)) {\n\t\t\t\tonParamChanged(param);\n\t\t\t}\n\t\t} finally {\n\t\t\trecursionOn = false;\n\t\t}\n\t}\n\n\tpublic  ParameterService(RoboStrokeEventBus bus);\n\n\tpublic synchronized void addListener(ParameterListenerRegistration ...value);\n\tpublic synchronized void removeListener(ParameterListenerRegistration ...value);\n\tpublic void addListeners(ParameterListenerOwner listenersOwner);\n\tpublic void removeListeners(ParameterListenerOwner listenersOwner);\n\tpublic synchronized void removeListener(String paramId, ParameterChangeListener listener);\n\tpublic synchronized void addListener(String paramId, ParameterChangeListener listener);\n\tpublic synchronized void registerParam(Parameter ... param);\n\tprivate void onParamChanged(Parameter param);\n\tpublic synchronized void setParam(String id, Object value);\n\t@SuppressWarnings(\"unchecked\") public T getValue(String id);\n\tpublic Map<String, Parameter> getParamMap();\n\tpublic synchronized Parameter getParam(String id);\n\n\tprivate static final ParameterInfo BOOLEAN_PARAM;\n\tprivate static final ParameterInfo INTEGER_PARAM;\n\tprivate static final ParameterInfo FLOAT_PARAM;\n\t Parameter f;\n\t Parameter i;\n\t Parameter b;\n\tprivate ParameterService ps;\n\tprivate final RoboStrokeEventBus bus;\n\tprivate final ParameterListenerRegistration[] listenerRegistration;\n\tprivate int intVal;\n\n}\n\nclass ParameterServiceTest {\n\n\tprivate static final ParameterInfo BOOLEAN_PARAM;\n\tprivate static final ParameterInfo INTEGER_PARAM;\n\tprivate static final ParameterInfo FLOAT_PARAM;\n\t Parameter f;\n\t Parameter i;\n\t Parameter b;\n\tprivate ParameterService ps;\n\tprivate final RoboStrokeEventBus bus;\n\tprivate final ParameterListenerRegistration[] listenerRegistration;\n\tprivate int intVal;\n\n\t@Test\n\tpublic void testSetParamViaListener() {\n", "reference": "\t\tps.setParam(\"int\", \"7\");\n\t\tassertEquals(7, intVal);\n\t\tps.setParam(\"int\", \"8\");\n\t\tassertEquals(8, intVal);\n\t}\n\n}", "prediction": "\t\tps.setParam(b, true);\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t\tassertEquals(true, ps.getValue(b.getId()));\n\t", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "5426789_20", "part": [1, 1], "seq": [1, 1], "prompt": "class CrescentIndexerExecutor {\n\n\tpublic String indexing(CrescentCollection collection, IndexingRequestForm indexingRequestForm) {\n\t\t\n\t\tlogger.info(\"indexingRequestForm : {}\", indexingRequestForm);\n\t\t\n\t\tIndexingType indexingType = IndexingType.valueOf(indexingRequestForm.getIndexingType().toUpperCase());\n\t\tIndexingCommand indexingCommand = IndexingCommand.valueOf(indexingRequestForm.getCommand().toUpperCase());\n\t\tString query = indexingRequestForm.getQuery();\n\t\t\n\t\tlogger.info(\"Indexing type : {} , Indexing command : {} \", indexingType, indexingCommand);\n\t\tlogger.info(\"Query : {}\", query);\n\t\t\n\t\tString resultMessage = \"Nothing To Execute...\";\n\t\t\n\t\t//CrescentIndexer crescentIndexer = new CrescentIndexer(collection.getName());\n\t\t\n\t\tif(IndexingCommand.ADD == indexingCommand) {\n\t\t\tList<Document> documentList = LuceneDocumentBuilder.buildDocumentList(indexingRequestForm.getDocumentList(), collection.getCrescentFieldByName());\n\t\t\tcrescentIndexer.addDocument(documentList, collection.getName());\n\t\t\n\t\t\tresultMessage = documentList.size() + \"\uac74\uc758 \uc0c9\uc778\uc774 \uc644\ub8cc\ub418\uc5c8\uc2b5\ub2c8\ub2e4.\";\n\t\t\t\n\t\t} else if (IndexingCommand.UPDATE == indexingCommand) {\n\t\t\t\n\t\t\tList<Document> documentList = LuceneDocumentBuilder.buildDocumentList(indexingRequestForm.getDocumentList(), collection.getCrescentFieldByName());\n\t\t\t\n\t\t\tif(documentList.size() == 0) {\n\t\t\t\tlogger.error(\"\uc5c5\ub370\uc774\ud2b8 \ud560 document\uac00 \uc5c6\uc2b5\ub2c8\ub2e4.\");\n\t\t\t\tthrow new IllegalStateException(\"\uc5c5\ub370\uc774\ud2b8 \ud560 document\uac00 \uc5c6\uc2b5\ub2c8\ub2e4.\");\n\t\t\t}\n\t\t\t\n\t\t\t//Document updateDoc = documentList.get(0);\n\t\t\t\n\t\t\tString[] splitQuery = query.split(\":\");\n\t\t\tif(splitQuery.length != 2) {\n\t\t\t\tlogger.error(\"Update \ub300\uc0c1 \ubb38\uc11c\ub97c \ucc3e\uc744 Query\uc2dd\uc774 \uc798\ubabb\ub418\uc5c8\uc2b5\ub2c8\ub2e4. [{}]\", query);\n\t\t\t\tthrow new IllegalStateException(\"Update \ub300\uc0c1 \ubb38\uc11c\ub97c \ucc3e\uc744 Query\uc2dd\uc774 \uc798\ubabb\ub418\uc5c8\uc2b5\ub2c8\ub2e4. [\"+query+\"]\");\n\t\t\t}\n\t\t\tString field = query.split(\":\")[0];\n\t\t\tString value = query.split(\":\")[1];\n\t\t\t\n\t\t\tlogger.info(\"field : {}, value : {}\", field, value);\n\t\t\t\n\t\t\tTerm updateTerm = new Term(field, value);\n\t\t\t\n\t\t\tcrescentIndexer.updateDocuments(updateTerm, documentList, collection.getName());\n\t\t\t\n\t\t\tresultMessage = updateTerm.toString() + \"\uc5d0 \ub300\ud55c update\uac00 \uc644\ub8cc\ub418\uc5c8\uc2b5\ub2c8\ub2e4.\";\n\t\t\t\n\t\t} else if (IndexingCommand.UPDATE_BY_FIELD_VALUE == indexingCommand) {\n\t\t\t\n\t\t\tList<Document> documentList = LuceneDocumentBuilder.buildDocumentList(indexingRequestForm.getDocumentList(), collection.getCrescentFieldByName());\n\t\t\t\n\t\t\tif(documentList.size() == 0) {\n\t\t\t\tlogger.error(\"\uc5c5\ub370\uc774\ud2b8 \ud560 document\uac00 \uc5c6\uc2b5\ub2c8\ub2e4.\");\n\t\t\t\tthrow new IllegalStateException(\"\uc5c5\ub370\uc774\ud2b8 \ud560 document\uac00 \uc5c6\uc2b5\ub2c8\ub2e4.\");\n\t\t\t}\n\t\t\t\n\t\t\tString field = query.split(\":\")[0];\n\t\t\tString value = query.split(\":\")[1];\n\t\t\t\n\t\t\tlogger.info(\"field : {}, value : {}\", field, value);\n\t\t\t\n\t\t\tfor(Document document : documentList) {\n\t\t\t\tvalue = document.get(field);\n\t\t\t\t\n\t\t\t\tif(value == null || value.length() == 0) {\n\t\t\t\t\tlogger.error(\"Update \ub300\uc0c1 \ubb38\uc11c\ub97c \ucc3e\uc744 field\uc9c0\uc774 \uc798\ubabb\ub418\uc5c8\uac70\ub098 field : [{}], value\uac00 \uc5c6\uc2b5\ub2c8\ub2e4. value : [{}]\", field, value);\n\t\t\t\t\tthrow new IllegalStateException(\"pdate \ub300\uc0c1 \ubb38\uc11c\ub97c \ucc3e\uc744 field\uc9c0\uc774 \uc798\ubabb\ub418\uc5c8\uac70\ub098 field : [\"+field+\"], value\uac00 \uc5c6\uc2b5\ub2c8\ub2e4. value : [\"+value+\"]\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tTerm updateTerm = new Term(field, value);\n\t\t\t\tcrescentIndexer.updateDocument(updateTerm, document, collection.getName());\n\t\t\t}\n\t\t\t\n\t\t\tresultMessage = query + \"\uc5d0 \ub300\ud55c update\uac00 \uc644\ub8cc\ub418\uc5c8\uc2b5\ub2c8\ub2e4.\";\n\t\t\t\n\t\t} else if (IndexingCommand.DELETE == indexingCommand) {\n\t\t\t\n\t\t\tString[] splitQuery = query.split(\":\");\n\t\t\tif(splitQuery.length != 2) {\n\t\t\t\tlogger.error(\"Delete \ub300\uc0c1 \ubb38\uc11c\ub97c \ucc3e\uc744 Query\uc2dd\uc774 \uc798\ubabb\ub418\uc5c8\uc2b5\ub2c8\ub2e4. [{}]\", query);\n\t\t\t\tthrow new IllegalStateException(\"Delete \ub300\uc0c1 \ubb38\uc11c\ub97c \ucc3e\uc744 Query\uc2dd\uc774 \uc798\ubabb\ub418\uc5c8\uc2b5\ub2c8\ub2e4. [\"+query+\"]\");\n\t\t\t}\n\t\t\tString field = query.split(\":\")[0];\n\t\t\tString value = query.split(\":\")[1];\n\t\t\t\n\t\t\tlogger.info(\"field : {}, value : {}\", field, value);\n\t\t\t\n\t\t\tTerm deleteTerm = new Term(field, value);\n\t\t\tQuery deleteTermQuery = new TermQuery(deleteTerm);\n\t\t\t\n\t\t\tcrescentIndexer.deleteDocument(deleteTermQuery, collection.getName());\n\t\t\t\n\t\t\tresultMessage = deleteTerm.toString() + \"\uc5d0 \ub300\ud55c delete\uac00 \uc644\ub8cc\ub418\uc5c8\uc2b5\ub2c8\ub2e4.\";\n\t\t}\n\t\t\n\t\tif(IndexingType.BULK == indexingType) {\n\t\t\tcrescentIndexer.commit(collection.getName());\n\t\t}\n\t\t\n\t\treturn resultMessage;\n\t}\n\n}\n\nclass CrescentIndexerExecutorTest  {\n\n\t@Test\n\tpublic void addDocument() throws CorruptIndexException, IOException {\n", "reference": "\t\t\n\t\tCrescentCollections crescentCollections = collectionHandler.getCrescentCollections();\n\t\tMap<String, CrescentCollection> collections = crescentCollections.getCrescentCollectionsMap();\n\n\t\tCrescentCollection sampleCollection = collections.get(\"sample\");\n\n\t\tHandler handler = new JsonDataHandler();\n\t\tIndexingRequestForm indexingRequestForm = handler.handledData(FormattedTextBuilder.getAddDocBulkJsonForm());\n\t\t\n\t\tString returnMessage = executor.indexing(sampleCollection, indexingRequestForm);\n\t\t\n\t\tAssert.assertEquals(\"1\uac74\uc758 \uc0c9\uc778\uc774 \uc644\ub8cc\ub418\uc5c8\uc2b5\ub2c8\ub2e4.\", returnMessage);\n\t}\n\n}", "prediction": "\t\t\n\t\tCrescentCollection collection = new CrescentCollection();\n\t\tcollection.setName(\"test\");\n\t\t\n\t\tCrescentField crescentField = new CrescentField();\n\t\tcrescentField.setName(\"testField\");\n\t\tcrescentField.setType(CrescentFieldType.STRING);\n\t\t\n\t\tList<CrescentField> crescentFieldList = new ArrayList<CrescentField>();\n\t\tcrescentFieldList.add(crescentField);\n\t\t\n\t\tcollection.setCrescentFieldList(crescentFieldList);\n\t\t\n\t\tIndexingRequestForm indexingRequestForm = new IndexingRequestForm();\n\t\tindexingRequestForm.setIndexingType(IndexingType.BULK.name());\n\t\tindexingRequestForm.setCommand(IndexingCommand.ADD.name());\n\t\t\n\t\tDocument document = new Document();\n\t\tdocument.add(new StringField(\"testField\", \"testValue\", Field.Store.YES));\n\t\t\n\t\tList<Document> documentList = new ArrayList<Document>();\n\t\tdocumentList.add(document);\n\t\t\n\t\tindexingRequestForm.setDocumentList(documentList);\n\t\t\n\t\tString resultMessage = new CrescentIndexerExecutor().indexing(collection, indexingRequestForm);\n\t\t\n", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "5459107_5", "part": [1, 1], "seq": [1, 1], "prompt": "class Pump {\n\n  public GroupByPump groupby(String... fields) {\n    return new GroupByPump(this, fields);\n  }\n\n  abstract Pump getPrev();\n  abstract Pipe getPipeInternal();\n  public Set<Class> getEmittedClasses();\n  public final Pipe toPipe();\n  public static Pump prime();\n  public static Pump prime(String pipeName);\n  public static Pump prime(Pipe pipe);\n  public CoGroupPump cogroup(Pump other, String... cogroupFields);\n  public CoGroupPump cogroup(Pump other, Joiner joiner, String... cogroupFields);\n  public static CoGroupPump cogroup(Pump left, Pump right, String... cogroupFields);\n  public static CoGroupPump cogroup(Pump left, Pump right, Joiner joiner, String... cogroupFields);\n  static Fields getArgSelector(String... args);\n  static Fields getArgSelector(Fields defaultFields, String... args);\n  public Pump each(Function function, String... args);\n  public Pump each(Filter filter, String... args);\n  public Pump failOnNull(String errorText, String... args);\n  public Pump unique(String... uniqueFields);\n  public Pump aggregateby(AggregateBy.Functor functor, Aggregator aggregator, String... args);\n  public Pump average(String valueField, String averageField);\n  public Pump count(String countField);\n  public Pump first(String... firstFields);\n  public Pump sum(String valueField, String sumField);\n  public AggregatorPump every(Aggregator agg, String... args);\n  public Pump every(Buffer buffer, String... args);\n  public Pump retain(String ... fieldsToKeep);\n  public Pump discard(String ... fieldsToDiscard);\n  public Pump coerce(String field, Class toClass);\n  public Pump coerce(Class toClass, String... fieldsToCoerce);\n  public Pump coerce(String[] fields, Class<?>[] classes);\n  public Pump rename(String field, String toName);\n  public Pump replace(String field, String toName);\n  public Pump getOrElse(String fromField, String toField, Tuple value);\n  public Pump branch();\n  private Pump branch(String branchName);\n\n  private static final String INPUT2_PATH;\n  private static final String NULL_INPUT_PATH;\n  private static final String OUTPUT_PATH2;\n  private static final List<Tuple> INPUT2_TUPLES;\n  private static final List<Tuple> NULL_TUPLES;\n\n}\n\nclass TestPump {\n\n  private static final String INPUT2_PATH;\n  private static final String NULL_INPUT_PATH;\n  private static final String OUTPUT_PATH2;\n  private static final List<Tuple> INPUT2_TUPLES;\n  private static final List<Tuple> NULL_TUPLES;\n\n  @Test\n  public void testGroupBy() throws Exception {\n", "reference": "    Pipe p = Pump.prime()\n        .each(new RegexFilter(\"^[0-9]+$\", false), \"line\")\n        .retain(\"line\")\n        .coerce(\"line\", int.class)\n        .each(new DateFormatter(new Fields(\"date\"), \"yyyy-MM-dd\"))\n        .retain(\"date\")\n        .groupby(\"date\")\n        .toPipe();\n\n    CascadingHelper.get().getFlowConnector().connect(Tests.getInTap(), Tests.getOutTap(), p).complete();\n\n    assertEquals(Arrays.asList(\"1970-01-01\", \"1970-01-02\", \"1970-01-02\"), getOutputStrings());\n  }\n\n}", "prediction": "    Pump pump = Pump.prime().from(INPUT2_PATH).groupBy(\"name\");\n    pump.toPipe().complete();\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "5495723_13", "part": [1, 1], "seq": [1, 1], "prompt": "class InterruptRefPattern extends AbstractCliPattern<Long> {\n\n\t@Override\n\tpublic Long getValue() {\n\t\treturn reference;\n\t}\n\n\t  InterruptRefPattern();\n\n\t@Override protected void setValue(final Matcher matcher);\n\t@Override public void notifyNotFound();\n\t@Override public boolean notFoundIsFatal();\n\n}\n\nclass InterruptRefPatternTest {\n\n\t@Test\n\tpublic void testSuccess1() {\n", "reference": "\t\tString line = \"user interrupt reference id: 3422\";\n\t\tInterruptRefPattern pattern = new InterruptRefPattern();\n\t\tboolean matches = pattern.matchesLine(line);\n\t\tassertTrue(\"Pattern does not match\", matches);\n\t\tassertEquals(Long.valueOf(3422), pattern.getValue());\n\t}\n\n}", "prediction": "\t\tInterruptRefPattern pattern = new InterruptRefPattern();\n\t\tassertTrue(pattern.match(\"interrupt 12345\"));\n\t\tassertEquals(12345L, pattern.getValue().longValue());\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "5518934_16", "part": [1, 1], "seq": [1, 1], "prompt": "class HumanReadableSize {\n\n    public static String parse(final BigDecimal size) throws IllegalArgumentException {\n        return parse(size.longValueExact());\n    }\n\n    private  HumanReadableSize();\n\n    public static String parse(final Long size);\n    public static String parse(final Integer size);\n    public static String parse(final String size);\n    private static String getLargerSizeClass(final String oldSizeClass);\n    public static String[] sanitize(final String size);\n    private static String round(final BigDecimal unrounded, final int precision, final int roundingMode);\n\n}\n\nclass HumanReadableSizeTest {\n\n    @Test\n    public void megabyteLargeSizeFailed() {\n", "reference": "        assertEquals(\"68.44MB\", HumanReadableSize.parse(\"71754584\"));\n    }\n\n}", "prediction": "        assertEquals(\"10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "5900702_20", "part": [1, 1], "seq": [1, 1], "prompt": "class CustomProcessorsCollector {\n\n\tpublic LinkedList<FieldPostProcessor> getLowPriorityFieldPostProcessors() {\n\t\tLinkedList<FieldPostProcessor> result = new LinkedList<FieldPostProcessor>();\n\t\tresult.addAll(sortAndGetNegativePostProcessors(toList(priorityCustomFieldPostProcessors)));\n\t\treturn result;\n\t}\n\n\tpublic LinkedList<FieldProcessor> getFieldProcessors();\n\tpublic LinkedList<FieldPostProcessor> getHighPriorityFieldPostProcessors();\n\tprivate List<? extends FieldPostProcessor> sortAndGetPositivePostProcessors(\n\t\t\tList<PriorityFieldPostProcessor> processors);\n\tprivate List<? extends FieldPostProcessor> sortAndGetNegativePostProcessors(\n\t\t\tList<PriorityFieldPostProcessor> processors);\n\tprivate List<T> toList(Set<T> set);\n\tprivate List<T> sortByPriority(List<T> processors);\n\n\tprivate CustomProcessorsCollector testedObject;\n\n}\n\nclass CustomProcessorsCollectorTest {\n\n\tprivate CustomProcessorsCollector testedObject;\n\n\t@Test\n\tpublic void getLowPriorityFieldPostProcessors_noCustomProcessors_returnsEmptyList() throws Exception {\n", "reference": "\t\tnoProcessors();\n\n\t\tLinkedList<FieldPostProcessor> actualResult = testedObject.getLowPriorityFieldPostProcessors();\n\n\t\tassertThat(actualResult).isEmpty();\n\t}\n\n}", "prediction": "\t\t// given\n\t\t// when\n\t\tList<FieldPostProcessor> result = testedObject.getLowPriorityFieldPostProcessors();\n\t\t// then\n\t\tassertThat(result, is(empty()));\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "5915204_0", "part": [1, 1], "seq": [1, 1], "prompt": "class ExtractorModule extends Module implements IExtractorModule, IExtractorModuleController {\n\n    @Override\n    protected void onNewTurn() {\n        // Mine some resources.\n        Tile location = getGameObject().getLocation().get();\n        Maybe<Integer> availableResources = location.getResourceQuantity( resourceType );\n        if (!availableResources.isPresent())\n            // No resources left to mine.\n            return;\n\n        int newAvailableResources = Math.max( 0, availableResources.get() - speed );\n        int minedResources = availableResources.get() - newAvailableResources;\n        if (!availableResources.isPresent())\n            // No speed left for mining.\n            return;\n\n        // Initialize path finding functions.\n        PredicateNN<IGameObject> foundFunction = gameObject -> {\n            for (final ContainerModule containerModule : gameObject.getModules( ModuleType.CONTAINER ))\n                if (containerModule.getAvailable() > 0)\n                    return true;\n\n            return false;\n        };\n        NNFunctionNN<PathUtils.Step<IGameObject>, Double> costFunction = gameObjectStep -> 1d;\n        NNFunctionNN<IGameObject, Stream<? extends IGameObject>> neighboursFunction = neighbour -> //\n                neighbour.getLocation().get().neighbours().stream() //\n                        .map( new Function<ITile, IGameObject>() {\n                            @Override\n                            public IGameObject apply(final ITile tile) {\n                                return tile.getContents().orNull();\n                            }\n                        } ).filter( gameObject -> gameObject != null );\n\n        // Find paths to containers and deposit mined resources.\n        while (minedResources > 0) {\n            Optional<PathUtils.Path<IGameObject>> path = PathUtils.find( getGameObject(), foundFunction, costFunction,\n                                                                         Constants.MAX_DISTANCE_TO_CONTAINER, neighboursFunction );\n            if (!path.isPresent())\n                // No more containers with available capacity.\n                break;\n\n            for (final ContainerModule containerModule : path.get().getTarget().getModules( ModuleType.CONTAINER ))\n                minedResources -= containerModule.addStock( minedResources );\n        }\n\n        // If we have minedResources left that we weren't able to stock, put them back in the tile (ie. don't extract them).\n        newAvailableResources += minedResources;\n\n        // Update the amount of resources left in the tile after this turn's extraction.\n        location.setResourceQuantity( resourceType, newAvailableResources );\n        logger.trc( \"unstocked resources: %d %s, left in tile: %d\", minedResources, resourceType, newAvailableResources );\n    }\n\n    protected  ExtractorModule(final ImmutableResourceCost resourceCost, final ResourceType resourceType, final int speed);\n\n    static Builder0 createWithStandardResourceCost();\n    static Builder0 createWithExtraResourceCost(final ImmutableResourceCost resourceCost);\n    @Override public ResourceType getResourceType();\n    @Override public int getSpeed();\n    @Override protected void onReset();\n    @Override public IExtractorModuleController getController();\n    @Override public IExtractorModule getModule();\n\n}\n\nclass ExtractorModuleTest extends Module {\n\n    @Test\n    public void testOnNewTurn()\n            throws Exception {\n", "reference": "\n        // Create an extractor unit on a tile with fuel.\n        ExtractorModule extractorModule = ExtractorModule.createWithStandardResourceCost().resourceType( ResourceType.FUEL ).speed( 5 );\n        ContainerModule unconnectedContainerModule = ContainerModule.createWithStandardResourceCost()\n                                                                    .resourceType( ResourceType.FUEL )\n                                                                    .capacity( 3 );\n        createUnit( testUnitType( \"Extractor\", extractorModule ), 0, 0 );\n        createUnit( testUnitType( \"Unconnected Container\", unconnectedContainerModule ), 3, 0 );\n        extractorModule.getGameObject().getLocation().get().setResourceQuantity( ResourceType.FUEL, 10 );\n\n        // There is no connected container yet, mining should fail.\n        assertEquals( (int) extractorModule.getGameObject().getLocation().get().getResourceQuantity( ResourceType.FUEL ).get(), 10 );\n        extractorModule.onNewTurn();\n        assertEquals( (int) extractorModule.getGameObject().getLocation().get().getResourceQuantity( ResourceType.FUEL ).get(), 10 );\n\n        // Create a connected container unit.\n        ContainerModule smallConnectedContainerModule = ContainerModule.createWithStandardResourceCost()\n                                                                       .resourceType( ResourceType.FUEL )\n                                                                       .capacity( 3 );\n        createUnit( testUnitType( \"Small Connected Container\", smallConnectedContainerModule ), 1, 0 );\n\n        // Now we should be able to mine enough to fill the container.\n        assertEquals( smallConnectedContainerModule.getAvailable(), 3 );\n        extractorModule.onNewTurn();\n        assertEquals( (int) extractorModule.getGameObject().getLocation().get().getResourceQuantity( ResourceType.FUEL ).get(), 7 );\n        assertEquals( smallConnectedContainerModule.getAvailable(), 0 );\n        extractorModule.onNewTurn();\n        assertEquals( (int) extractorModule.getGameObject().getLocation().get().getResourceQuantity( ResourceType.FUEL ).get(), 7 );\n        assertEquals( smallConnectedContainerModule.getAvailable(), 0 );\n\n        // Create a bigger connected container unit.\n        ContainerModule bigConnectedContainerModule = ContainerModule.createWithStandardResourceCost()\n                                                                     .resourceType( ResourceType.FUEL )\n                                                                     .capacity( 15 );\n        createUnit( testUnitType( \"Big Connected Container\", bigConnectedContainerModule ), 0, 1 );\n\n        // Now we should be able to mine enough to max out the extractor's speed and then empty the tile.\n        assertEquals( smallConnectedContainerModule.getAvailable(), 0 );\n        assertEquals( bigConnectedContainerModule.getAvailable(), 15 );\n        extractorModule.onNewTurn();\n        assertEquals( (int) extractorModule.getGameObject().getLocation().get().getResourceQuantity( ResourceType.FUEL ).get(), 2 );\n        assertEquals( bigConnectedContainerModule.getAvailable(), 10 );\n        extractorModule.onNewTurn();\n        assertFalse( extractorModule.getGameObject().getLocation().get().getResourceQuantity( ResourceType.FUEL ).isPresent() );\n        assertEquals( bigConnectedContainerModule.getAvailable(), 8 );\n        assertEquals( bigConnectedContainerModule.getStock(), 7 );\n    }\n\n}", "prediction": "        // TODO\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "6035195_3", "part": [1, 1], "seq": [1, 1], "prompt": "class DefaultProviderConfig {\n\n    public Optional<Provider> createProvider() {\n        if (accessKey.isEmpty() || secretKey.isEmpty()) {\n            return Optional.absent();\n        }\n        final ProviderBuilder builder = Provider.builder()\n            .id(AmazonProvisionr.ID)\n            .accessKey(accessKey)\n            .secretKey(secretKey);\n\n        if (!region.isEmpty()) {\n            builder.option(\"region\", region);\n        }\n\n        if (endpoint.isEmpty()) {\n            builder.endpoint(Optional.<String>absent());\n        } else {\n            builder.endpoint(endpoint);\n        }\n\n        return Optional.of(builder.createProvider());\n    }\n\n    public  DefaultProviderConfig(String accessKey, String secretKey, String region, String endpoint);\n\n}\n\nclass DefaultProviderConfigTest {\n\n    @Test\n    public void testProviderWithNoRegionAndEndpoint() {\n", "reference": "        DefaultProviderConfig config = new DefaultProviderConfig(\"access\", \"secret\", \"\", \"\");\n\n        Optional<Provider> provider = config.createProvider();\n        assertThat(provider.isPresent()).isTrue();\n\n        assertThat(provider.get().getEndpoint().isPresent()).isFalse();\n        assertThat(provider.get().getOptions().containsKey(\"region\")).isFalse();\n    }\n\n}", "prediction": "        DefaultProviderConfig config = new DefaultProviderConfig(\"accessKey\", \"secretKey\", \"\", \"\");\n        assertThat(config.createProvider().isPresent(), is(false));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "6157458_70", "part": [1, 1], "seq": [1, 1], "prompt": "class ManifestPluginDescriptorFinder implements PluginDescriptorFinder {\n\n    @Override\n    public PluginDescriptor find(Path pluginPath) {\n        Manifest manifest = readManifest(pluginPath);\n\n        return createPluginDescriptor(manifest);\n    }\n\n    @Override public boolean isApplicable(Path pluginPath);\n    protected Manifest readManifest(Path pluginPath);\n    protected Path getManifestPath(Path pluginPath);\n    protected PluginDescriptor createPluginDescriptor(Manifest manifest);\n    protected DefaultPluginDescriptor createPluginDescriptorInstance();\n\n    private VersionManager versionManager;\n    @TempDir Path pluginsPath;\n\n}\n\nclass ManifestPluginDescriptorFinderTest {\n\n    private VersionManager versionManager;\n    @TempDir Path pluginsPath;\n\n    @Test\n    public void testFind() throws Exception {\n", "reference": "        PluginDescriptorFinder descriptorFinder = new ManifestPluginDescriptorFinder();\n\n        PluginDescriptor plugin1 = descriptorFinder.find(pluginsPath.resolve(\"test-plugin-1\"));\n        PluginDescriptor plugin2 = descriptorFinder.find(pluginsPath.resolve(\"test-plugin-2\"));\n\n        assertEquals(\"test-plugin-1\", plugin1.getPluginId());\n        assertEquals(\"Test Plugin 1\", plugin1.getPluginDescription());\n        assertEquals(\"org.pf4j.plugin.TestPlugin\", plugin1.getPluginClass());\n        assertEquals(\"0.0.1\", plugin1.getVersion());\n        assertEquals(\"Decebal Suiu\", plugin1.getProvider());\n        assertEquals(2, plugin1.getDependencies().size());\n        assertEquals(\"test-plugin-2\", plugin1.getDependencies().get(0).getPluginId());\n        assertEquals(\"test-plugin-3\", plugin1.getDependencies().get(1).getPluginId());\n        assertEquals(\"~1.0\", plugin1.getDependencies().get(1).getPluginVersionSupport());\n        assertEquals(\"Apache-2.0\", plugin1.getLicense());\n        assertTrue(versionManager.checkVersionConstraint(\"1.0.0\", plugin1.getRequires()));\n\n        assertEquals(\"test-plugin-2\", plugin2.getPluginId());\n        assertEquals(\"\", plugin2.getPluginDescription());\n        assertEquals(\"org.pf4j.plugin.TestPlugin\", plugin2.getPluginClass());\n        assertEquals(\"0.0.1\", plugin2.getVersion());\n        assertEquals(\"Decebal Suiu\", plugin2.getProvider());\n        assertEquals(0, plugin2.getDependencies().size());\n        assertTrue(versionManager.checkVersionConstraint(\"1.0.0\", plugin2.getRequires()));\n    }\n\n}", "prediction": "        ManifestPluginDescriptorFinder finder = new ManifestPluginDescriptorFinder(versionManager);\n        PluginDescriptor descriptor = finder.find(pluginsPath);\n\n        assertThat(descriptor.getPluginId(), is(\"plugin\"));\n        assertThat(descriptor.getPluginVersion(), is(\"1.0.0\"));\n        assertThat(descriptor.getPluginClass(), is(\"com.example.Plugin\"));\n        assertThat(descriptor.getPluginArtifact(), is(\"plugin.jar\"));\n        assertThat(descriptor.getPluginDependencies(), is(empty()));\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "6509909_17", "part": [1, 1], "seq": [1, 1], "prompt": "class ChangeGiver {\n\n    public static int getTotalNumberOfWays(int cents) {\n        int ways = 0;\n        if (cents > 5) {\n            ways = getTotalNumberOfWays(cents - 5) \n                + getTotalNumberOfWays(cents - 1);\n        } else if (cents == 5) {\n            ways = 1 + getTotalNumberOfWays(cents - 1) ;\n        } else if (cents > 0) {\n            ways = 1;\n        }  \n        return ways;      \n    }\n\n}\n\nclass ChangeGiverTest {\n\n    @Test\n    public void givenATotalOf5CentsWhenWeGetChangeThenThereIsTwoWays() {\n", "reference": "        int expected = 2;\n        int actual = ChangeGiver.getTotalNumberOfWays(5);\n        assertEquals(expected, actual);\n    }\n\n}", "prediction": "        assertEquals(2, ChangeGiver.getTotalNumberOfWays(5));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "6602723_14", "part": [1, 1], "seq": [1, 1], "prompt": "class StatusController implements Controller {\n\n    public ModelAndView handleRequest(HttpServletRequest req,\n            HttpServletResponse resp) throws Exception {\n        Status currentStatus = monitoredService.getServiceStatus().getStatus();\n        setResponseCode(currentStatus, resp);\n        setAppropriateWarningHeaders(resp, currentStatus);\n        setCachingHeaders(resp);\n        writeOutCurrentStatusInResponseBody(resp, currentStatus);\n        return null;\n    }\n\n    public  StatusController(MonitoredService monitoredService);\n\n    private void setCachingHeaders(HttpServletResponse resp);\n    private void setAppropriateWarningHeaders(HttpServletResponse resp,\n            Status currentStatus);\n    private void writeOutCurrentStatusInResponseBody(HttpServletResponse resp,\n            Status currentStatus);\n    private void setResponseCode(Status currentStatus, HttpServletResponse resp);\n\n    private MonitoredServiceStub monitoredService;\n    private StatusController impl;\n    private MockHttpServletRequest req;\n    private MockHttpServletResponse resp;\n\n}\n\nclass TestStatusController {\n\n    private MonitoredServiceStub monitoredService;\n    private StatusController impl;\n    private MockHttpServletRequest req;\n    private MockHttpServletResponse resp;\n\n    @Test\n    public void setsWarningHeaderIfDegraded() throws Exception {\n", "reference": "        monitoredService.setStatus(Status.DEGRADED);\n        impl.handleRequest(req, resp);\n        boolean found = false;\n        for(Object val : resp.getHeaders(\"Warning\")) {\n            if (\"199 jrugged \\\"Status degraded\\\"\".equals(val)) {\n                found = true;\n            }\n        }\n        assertTrue(found);\n    }\n\n}", "prediction": "        monitoredService.setStatus(Status.DEGRADED);\n        impl.handleRequest(req, resp);\n        assertEquals(\"1\", resp.getHeader(\"Warning\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "6621718_0", "part": [1, 1], "seq": [1, 1], "prompt": "class XWindow implements DisplaySurface {\n\n    @Override\n    public ListenableFuture<Void> destroy() {\n        final int winId = getWindowId();\n        return this.xExecutor.submit(new Runnable() {\n\n            @Override\n            public void run() {\n                LOG.debug(\"[winId={}] destroy.\",\n                        winId);\n                xcb_destroy_window(getConnectionRef(),\n                        winId);\n                xcb_flush(getConnectionRef());\n            }\n        },\n                null);\n    }\n\n    @AssistedInject  XWindow(final XTime xTime,\n            final XConnection xConnection,\n            @Nonnull @Assisted final DisplaySurfaceHandle resourceHandle,\n            @DisplayExecutor final ListeningExecutorService xExecutor);\n\n    @Override public void register(final Object listener);\n    @Override public void post(final Object event);\n    @Override public void unregister(final Object listener);\n    @Override public void register(final Object listener,\n                         final ExecutorService executor);\n    @Override public DisplaySurfaceHandle getDisplaySurfaceHandle();\n    private int getWindowId();\n    private SWIGTYPE_p_xcb_connection_t getConnectionRef();\n    @Override public ListenableFuture<Void> setInputFocus();\n    @Override public ListenableFuture<Void> lower();\n    @Override public ListenableFuture<Void> show();\n    @Override public ListenableFuture<Void> move(final int x,\n                                       final int y);\n    @Override public ListenableFuture<Void> moveResize(final int x,\n                                             final int y,\n                                             final int width,\n                                             final int height);\n    @Override public ListenableFuture<Void> raise();\n    @Override public ListenableFuture<Void> setParent(final DisplayArea parent,\n                                            final int x,\n                                            final int y);\n    @Override public ListenableFuture<Void> resize(final int width,\n                                         final int height);\n    @Override public ListenableFuture<Void> hide();\n    @Override public ListenableFuture<Rectangle> getGeometry();\n    protected ListenableFuture<Rectangle> getGeometryReply(final xcb_get_geometry_cookie_t cookie_t);\n    private void checkError(final xcb_generic_error_t e);\n    @Override public boolean equals(final Object obj);\n    @Override public int hashCode();\n    @Override public String toString();\n\n\tprivate static final String displayName;\n\tprivate static final int screenNr;\n\tpublic static XConnection xConnection;\n\tpublic static xcb_screen_t screen;\n\tprivate static Process xvfb;\n\tprivate XWindow xWindow;\n\tprivate int windowId;\n\t@Mock\n\tprivate XTime xTime;\n\n}\n\nclass XWindowTest {\n\n\tprivate static final String displayName;\n\tprivate static final int screenNr;\n\tpublic static XConnection xConnection;\n\tpublic static xcb_screen_t screen;\n\tprivate static Process xvfb;\n\tprivate XWindow xWindow;\n\tprivate int windowId;\n\t@Mock\n\tprivate XTime xTime;\n\n\t@Test\n\tpublic void testDestroy() {\n", "reference": "\t\tthis.xWindow.destroy();\n\t\t// TODO verify\n\t}\n\n}", "prediction": "\t\tfinal ListenableFuture<Void> future = xWindow.destroy();\n\t\tassertNotNull(future);\n\t\ttry {\n\t\t\tfuture.get();\n\t\t} catch (final InterruptedException e) {\n\t\t\tfail(e.getMessage());\n\t\t} catch (final ExecutionException e) {\n\t\t\tfail(e.getMessage());\n\t\t}\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "6627230_65", "part": [1, 1], "seq": [1, 1], "prompt": "class FieldsTokenResolver implements TokenResolver {\n\n   @SuppressWarnings(\"unchecked\")\n   public String resolve(Token token, QueryContext ctx) {\n      if (token.getType() != TokenType.FIELDS) {\n         throw new DalRuntimeException(\"Internal error: only FIELDS token is supported by \" + getClass());\n      }\n\n      EntityInfo entityInfo = ctx.getEntityInfo();\n      SimpleTagToken fields = (SimpleTagToken) token;\n      String output = fields.getAttribute(\"output\", \"true\");\n      List<String> excludes = split(fields.getAttribute(\"excludes\", \"\"), \",\");\n      StringBuilder sb = new StringBuilder(1024);\n      DataObject proto = ctx.getProto();\n\n      switch (ctx.getQuery().getType()) {\n      case SELECT:\n         SubObjects subobjects = entityInfo.getSubobjects(ctx.getReadset());\n         String[] names;\n         List<Readset<Object>> readsets;\n\n         if (subobjects != null) {\n            names = subobjects.value();\n            readsets = ((Readset<Object>) ctx.getReadset()).getChildren();\n         } else {\n            names = null;\n            readsets = new ArrayList<Readset<Object>>(1);\n            readsets.add((Readset<Object>) ctx.getReadset());\n         }\n\n         int size = readsets.size();\n\n         for (int i = 0; i < size; i++) {\n            Readset<Object> readset = readsets.get(i);\n            Relation relation = (names == null ? null : entityInfo.getRelation(names[i]));\n            String alias = (relation == null ? entityInfo.getAlias() : relation.alias());\n            String subObjectName = (relation == null ? null : names[i]);\n\n            for (DataField field : readset.getFields()) {\n               EntityInfo ei = m_manager.getEntityInfo(field.getEntityClass());\n               Attribute attribute = ei.getAttribute(field);\n\n               if (attribute != null) {\n                  if (excludes.contains(field.getName())) {\n                     continue;\n                  }\n\n                  if (sb.length() > 0) {\n                     sb.append(',');\n                  }\n\n                  if (attribute.selectExpr().length() > 0) {\n                     sb.append(m_expressionResolver.resolve(ctx, attribute.selectExpr()));\n                  } else {\n                     sb.append(alias).append('.').append(m_naming.getField(attribute.field()));\n                  }\n\n                  if (\"true\".equals(output)) {\n                     ctx.addOutField(field);\n                     ctx.addOutSubObjectName(subObjectName);\n                  }\n               } else {\n                  throw new DalRuntimeException(\"Internal error: No Attribute annotation defined for field: \" + field);\n               }\n            }\n         }\n\n         break;\n      case INSERT:\n         for (DataField field : entityInfo.getAttributeFields()) {\n            Attribute attribute = entityInfo.getAttribute(field);\n\n            if (attribute != null) {\n               if (attribute.field().length() > 0 && !(attribute.autoIncrement() && !proto.isFieldUsed(field))) {\n                  if (sb.length() > 0) {\n                     sb.append(',');\n                  }\n\n                  sb.append(m_naming.getField(attribute.field()));\n               }\n            } else {\n               throw new DalRuntimeException(\"Internal error: No Attribute annotation defined for field: \" + field);\n            }\n         }\n\n         break;\n      case UPDATE:\n         for (DataField field : ctx.getUpdateset().getFields()) {\n            Attribute attribute = entityInfo.getAttribute(field);\n\n            if (attribute != null) {\n               if (proto.isFieldUsed(field) || attribute.updateExpr().length() > 0) {\n                  if (sb.length() > 0) {\n                     sb.append(',');\n                  }\n\n                  if (!proto.isFieldUsed(field) && attribute.updateExpr().length() > 0) {\n                     sb.append(m_naming.getField(attribute.field())).append('=').append(m_expressionResolver.resolve(ctx, attribute.updateExpr()));\n                  } else {\n                     sb.append(m_naming.getField(attribute.field())).append(\"=?\");\n                     ctx.addParameter(new Parameter(field));\n                  }\n               }\n            } else {\n               throw new DalRuntimeException(\"Internal error: No Attribute annotation defined for field: \" + field);\n            }\n         }\n\n         break;\n      case DELETE:\n         throw new DalRuntimeException(\"FIELDS token does not support query type: \" + ctx.getQuery().getType());\n      default:\n         throw new DalRuntimeException(\"FIELDS token does not support query type: \" + ctx.getQuery().getType());\n      }\n\n      return sb.toString();\n   }\n\n   private List<String> split(String data, String delimiter);\n\n}\n\nclass FieldsTokenResolverTest  {\n\n   @Test\n   public void testSelect4() throws Exception {\n", "reference": "      QueryDef query = new QueryDef(\"test\", UserEntity.class, QueryType.SELECT, \"<fields/> <fields excludes='user-name,last-modified-date' output='false'/>\");\n      Readset<?> readset = UserEntity.READSET_FULL;\n      User user = new User();\n      QueryContext ctx = getSelectContext(query, user, readset);\n      \n      m_queryResolver.resolve(ctx);\n      Assert.assertEquals(\"u.user_id,u.full_name,u.creation_date,u.last_modified_date u.user_id,u.creation_date\", ctx.getSqlStatement());\n      Assert.assertEquals(4, ctx.getOutSubObjectNames().size());\n      Assert.assertEquals(4, ctx.getOutFields().size());\n      Assert.assertEquals(\"[user-id, user-name, creation-date, last-modified-date]\", ctx.getOutFields().toString());\n   }\n\n}", "prediction": "     QueryContext ctx = new QueryContext();\n      ctx.setQuery(new Query());\n      ctx.getQuery().setType(QueryType.SELECT);\n      ctx.getQuery().setEntityClass(User.class);\n      ctx.getQuery().setSql(\"select * from user where id = ?\");\n      ctx.getQuery().setParameters(new Parameter(1));\n      ctx.getQuery().setFields(new FieldsToken(\"fields\", \"output=false\"));\n      ctx.getQuery().setReadset(new Readset<Object>());\n      ctx.getQuery().getReadset().add(new DataField(\"id\"));\n      ctx.getQuery().getReadset().add(new DataField(\"name\"));\n      ctx.getQuery().getReadset().add(new DataField(\"age\"));\n      ctx.getQuery().getReadset().add(new DataField(\"address\"));\n      ctx.getQuery().getReadset().add(new DataField(\"phone\"));\n      ctx.getQuery().getReadset().add(new DataField(\"email\"));\n      ctx.getQuery().getReadset().add(new DataField(\"birthday\"));\n      ctx.getQuery().getReadset().add(new DataField(\"createTime\"));\n      ctx.getQuery().getReadset().add(new DataField(\"updateTime\"));\n      ctx.getQuery().getReadset().add(new DataField(\"version\"));\n      ctx.getQuery().getReadset().add(new DataField(\"status\"));\n      ctx.getQuery().getReadset().add(new DataField(\"password\"));\n      ctx.getQuery().getReadset().add(new DataField(\"loginTime\"));\n      ctx.getQuery().getReadset().add(new DataField(\"loginIp\"));\n      ctx.getQuery().getReadset().add(new DataField(\"loginCount\"));\n      ctx.getQuery().getReadset().add(new DataField(\"loginLocked\"));\n      ctx.getQuery().getReadset().add(new DataField(\"loginLockedTime\"));\n      ctx.getQuery().getReadset().add(new DataField(\"loginLockedIp\"));\n      ctx.getQuery().getReadset().add(new DataField(\"loginLockedCount\"));\n      ctx.getQuery().getReadset().add(new DataField(\"loginLockedReason\"));\n      ctx.getQuery().getReadset().add(new DataField(\"loginLockedExpireTime\"));\n      ctx.getQuery().getReadset().add(new DataField(\"loginLockedExpireIp\"));\n      ctx.getQuery().getReadset().add(new DataField(\"loginLockedExpireCount\"));\n      ctx.getQuery().getReadset().add(new DataField(\"loginLockedExpireReason\"));\n      ctx.getQuery().getReadset().add(new DataField(\"loginLockedExpireCount\"));\n      ctx.getQuery().getReadset().add(new DataField(\"loginLockedExpireReason\"));\n      ctx.getQuery().getReadset().add(new DataField(\"loginLockedExpireCount\"));\n      ctx.getQuery().getReadset().add(new DataField(\"loginLockedExpireReason\"));\n      ctx.getQuery().getReadset().add(new DataField(\"loginLockedExpireCount\"));\n      ctx.getQuery().getReadset().add(new DataField(\"loginLockedExpireReason\"));\n      ctx.getQuery().getReadset().add(new DataField(\"loginLockedExpireCount\"));\n      ctx.get", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "6935442_164", "part": [1, 1], "seq": [1, 1], "prompt": "class MapUtils {\n\n    public static Map<String, String> mapOf(final String... keyOrValues) {\n        if (keyOrValues.length % 2 != 0) {\n            throw new IllegalArgumentException(\"Must provide an even number of arguments\");\n        }\n        final Map<String, String> map = _Maps.newLinkedHashMap();\n        String key = null;\n        for (final String keyOrValue : keyOrValues) {\n            if (key != null) {\n                map.put(key, keyOrValue);\n                key = null;\n            } else {\n                key = keyOrValue;\n            }\n        }\n        return Collections.unmodifiableMap(map);\n    }\n\n}\n\nclass MapUtilsTest {\n\n    @Test\n    public void emptyList() throws Exception {\n", "reference": "        final Map<String, String> map = MapUtils.mapOf();\n        assertThat(map.size(), is(0));\n    }\n\n}", "prediction": "        assertThat(MapUtils.mapOf()).isEmpty();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "7023911_12", "part": [1, 1], "seq": [1, 1], "prompt": "class NwhinDataRetriever extends AbstractC32DaoAware implements MessageListener {\n\n\t@Override\n\tpublic void onMessage(Message msg) {\n\t\tTextMessage tMsg = (TextMessage)msg;\n\t\tAsyncRetrieveMessage aMsg = null;\n\t\t\n\t\ttry {\n\t\t\taMsg = (AsyncRetrieveMessage)getAsyncMessageFormat().parse(tMsg.getText());\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tlogger.error(\"message parsing error for \" + msg + \": USER CANNOT BE NOTIFIED (users info is not known)\", ex);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tC32DocumentEntity doc = getC32Document(aMsg);\n\n\t\ttry {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Attempting to Persist Domain XML for: \" + aMsg.getPatientId());\n\t\t\t}\n\t\t\tupdateDocumentWithNewDocument(aMsg.getPatientId(), doc);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tlogger.error(\"error saving c32 document: USER NOT NOTIFIED:\" + msg, ex);\n\t\t}\n\t}\n\n\tpublic FormatTS getAsyncMessageFormat();\n\tpublic void setAsyncMessageFormat(FormatTS asyncMessageFormat);\n\tpublic C32DocumentEntityFactory getDocumentFactory();\n\tpublic void setDocumentFactory(C32DocumentEntityFactory documentFactory);\n\tpublic void setWrapperResource(WrapperResource resource);\n\tprotected C32DocumentEntity getC32Document(AsyncRetrieveMessage msg);\n\tprotected java.sql.Timestamp getNowTimestamp();\n\tprotected void updateDocumentWithNewDocument(String patientId, C32DocumentEntity newDoc);\n\tprotected C32DocumentEntity getOldDocument(C32DocumentEntity newDoc);\n\tprotected C32DocumentEntity getOldDocFromList(List<C32DocumentEntity> results, C32DocumentEntity newDoc);\n\tprotected boolean datesEqual(Calendar cal, Timestamp date1, Timestamp date2);\n\tprotected static boolean stringsEqualNullSafe(String s1, String s2);\n\n\t NwhinDataRetriever retriever;\n\t List<C32DocumentEntity> insertedList;\n\t List<C32DocumentEntity> updatedList;\n\t List<C32DocumentEntity> docList;\n\t String returnXml;\n\t String ptNameToAssert;\n\t String ptIdToAssert;\n\t boolean nwhinError;\n\t boolean parsingError;\n\n}\n\nclass NwhinDataRetrieverTest extends AbstractC32DaoAware implements MessageListener {\n\n\t NwhinDataRetriever retriever;\n\t List<C32DocumentEntity> insertedList;\n\t List<C32DocumentEntity> updatedList;\n\t List<C32DocumentEntity> docList;\n\t String returnXml;\n\t String ptNameToAssert;\n\t String ptIdToAssert;\n\t boolean nwhinError;\n\t boolean parsingError;\n\n\t@Test\n\tpublic void onMessage_docEmpty() {\n", "reference": "\t\tptIdToAssert = \"998877v99\";\n\t\tsetupDocList(ptIdToAssert, ptIdToAssert, \"\");\n\t\tretriever.onMessage(new TestTextMessage(\"20120908070605:998877v99:fred\"));\n\t\tAssert.assertEquals(0, insertedList.size());\n\t\tAssert.assertEquals(1, updatedList.size());\n\t\tAssert.assertEquals(BlueButtonConstants.UNAVAILABLE_STATUS_STRING, updatedList.get(0).getDocument());\n\t\tAssert.assertEquals(ptIdToAssert, updatedList.get(0).getDocumentPatientId());\n\t\tAssert.assertEquals(ptIdToAssert, updatedList.get(0).getIcn());\n\t\tassertDatePartEqualsToday(updatedList.get(0).getCreateDate());\n\t}\n\n}", "prediction": "\t\tAsyncRetrieveMessage msg = new AsyncRetrieveMessage();\n\t\tmsg.setPatientId(\"12345\");\n\t\tmsg.setDocumentId(\"12345\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentType(\"C32\");\n\t\tmsg.setDocumentTitle(\"C32\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocumentText(\"\");\n\t\tmsg.setDocument", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "7113288_1", "part": [1, 1], "seq": [1, 1], "prompt": "class JWSHttpServletRequestWrapper extends SecurityContextHolderAwareRequestWrapper {\n\n\t@Override\n\tpublic ServletInputStream getInputStream() throws IOException {\n\t\tfinal ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(body.getBytes());\n\n\t\tServletInputStream inputStream = new ServletInputStream() {\n\t\t\t@Override\n\t\t\tpublic int read() throws IOException {\n\t\t\t\treturn byteArrayInputStream.read();\n\t\t\t}\n\t\t};\n\n\t\treturn inputStream;\n\t}\n\n\tpublic  JWSHttpServletRequestWrapper(final HttpServletRequest request, final String rolePrefix);\n\n    private static final String TEST_CONTENT;\n    @Mock\n    private HttpServletRequest request;\n\n}\n\nclass JWSHttpServletRequestWrapperTest {\n\n    private static final String TEST_CONTENT;\n    @Mock\n    private HttpServletRequest request;\n\n    @Test\n    public void testWrapperObtainContent() throws Exception{\n", "reference": "\n        //environment\n        ServletInputStream sis = new DelegatingServletInputStream(new ByteArrayInputStream( TEST_CONTENT.getBytes()));\n        when(request.getInputStream()).thenReturn(sis);\n\n        //test\n        JWSHttpServletRequestWrapper jwsHttpServletRequestWrapper = new JWSHttpServletRequestWrapper(request, null);\n        InputStream is = jwsHttpServletRequestWrapper.getInputStream();\n\n        //validation\n        String obtainedContent = obtainContent(is);\n        Assert.assertNotNull(\"content should be not be null\",obtainedContent);\n        Assert.assertEquals(\"content should be the same\",TEST_CONTENT,obtainedContent);\n\n\n    }\n\n}", "prediction": "        JWSHttpServletRequestWrapper wrapper = new JWSHttpServletRequestWrapper(request, \"\");\n        assertEquals(TEST_CONTENT, wrapper.getContent());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "7164335_0", "part": [1, 1], "seq": [1, 1], "prompt": "class StandaloneJUnitRunnerMain {\n\n  public static void main(String... args) {\n    PrintStream err = System.err;\n    if (args.length == 0) {\n      err.println(\"Usage:\");\n      err.println(\"  each argument is a comma separated list of junit testclass names to run in it's own thread\");\n      err.println(\"Example:\");\n      err.println(\"  Class1 ClassA,ClassB Class2\");\n      err.println(\"  Will start 3 threads, where ClassA and ClassB are run in sequence in one thread\");\n      err.println(\"System properties:\");\n      err.println(\"  -Doutput.dir\\tOutput directory for results\");\n      exit(1);\n    }\n    try {\n      new StandaloneJUnitRunner().main(args);\n    } catch (Throwable t) {\n      err.println(t.getMessage());\n      exit(1);\n    }\n    exit(0);\n  }\n\n  @Rule\n  public ExpectedException expect;\n\n}\n\nclass StandaloneJUnitRunnerMainTest {\n\n  @Rule\n  public ExpectedException expect;\n\n  @Test\n  public void testUsage() {\n", "reference": "    expect.expectMessage(\"Exit disabled: 1\");\n    StandaloneJUnitRunnerMain.main();\n  }\n\n}", "prediction": "    expect.expect(IllegalArgumentException.class);\n    expect.expectMessage(\"Usage:\");\n    StandaloneJUnitRunnerMain.main();\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "7249073_3", "part": [1, 1], "seq": [1, 1], "prompt": "class Lists {\n\n  public static <X> List<X> distinct(List<X> inputs) {\n    if (null == inputs) {\n      return null;\n    }\n\n    return foldLeft(new ArrayList<X>(), inputs, new Aggregator<X, List<X>>() {\n      private Set<X> mSeen = new HashSet<X>();\n\n      @Override\n      public List<X> eval(X input, List<X> out) {\n        if (!mSeen.contains(input)) {\n          out.add(input);\n          mSeen.add(input);\n        }\n        return out;\n      }\n    });\n  }\n\n  private  Lists();\n\n  public static Y foldLeft(Y initial, List<X> inputList, Aggregator<? super X, Y> op);\n  public static Y foldRight(Y initial, List<X> inputList, Aggregator<? super X, Y> op);\n  public static List<Y> map(List<X> inputs, Func<? super X, ? extends Y> mapper);\n  @SuppressWarnings(\"unchecked\") public static X[] toArray(List<X> inputs, Class<X> klazz);\n\n}\n\nclass TestLists {\n\n  @Test\n  public void testDistinct3() {\n", "reference": "    List<String> inputs = new ArrayList<String>();\n    inputs.add(\"a\");\n    inputs.add(\"b\");\n    inputs.add(\"c\");\n\n    assertTrue(inputs.equals(Lists.distinct(inputs)));\n\n    inputs.clear();\n    assertTrue(inputs.equals(Lists.distinct(inputs)));\n  }\n\n}", "prediction": "    List<Integer> list = Lists.distinct(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));\n    assertEquals(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10), list);\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "7283919_65", "part": [1, 1], "seq": [1, 1], "prompt": "class SqlTimeParseDelegate {\n\n    public static Object parse(String s) throws Exception {\n        return (s == null) ? null : parseTime(s);\n    }\n\n    private static Time parseTime(final String s);\n\n}\n\nclass SqlTimeParseDelegateTest {\n\n    @Test(expected = Exception.class)\n    public void failsOnInvalidInput() throws Exception {\n", "reference": "        parse(\"3.14\");\n    }\n\n}", "prediction": "        SqlTimeParseDelegate.parse(\"invalid\");\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "7292204_6", "part": [1, 1], "seq": [1, 1], "prompt": "class Base64 {\n\n    public static String encode(byte[] data) {\n        if (encoderMethod == null) throw new UnsupportedOperationException(\"Cannot find Base64 encoder.\");\n        try {\n            return (String) encoderMethod.invoke(encoderObject, data);\n        } catch (Exception e) {\n            throw new UnsupportedOperationException(e);\n        }\n    }\n\n    private  Base64();\n\n    private static void reset();\n    public static byte[] decode(String data);\n\n}\n\nclass Base64Test {\n\n    @Test\n    public void testEncode() {\n", "reference": "        String input = \"Hello World!\";\n        String result = Base64.encode(input.getBytes());\n        assertEquals(\"SGVsbG8gV29ybGQh\", result);\n    }\n\n}", "prediction": "        byte[] data = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255 };\n        assertEquals(\"AQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2Nzg5LjEzMjgwMTIzNDU2Nzg5LjEzMjgwMTIzNDU2Nzg5LjEzMjgwMTIzNDU2Nzg5LjEzMjgwMTIzNDU2Nzg5LjEzMjgwMTIzNDU2Nzg5LjEzMjgwMTIzNDU2Nzg5LjEzMjgwMTIzNDU2Nzg5LjEzMjgwMTIzNDU2Nzg5LjEzMjgwMTIzNDU2Nzg5LjEzMjgwMTIzNDU2Nzg5LjEzMjgwMTIzNDU2Nzg5LjEzMjgwMTIzNDU2Nzg5LjEzMjgwMTIzNDU2Nzg5LjEzMjgwMTIzNDU2Nzg5LjEzMjgwMTIzNDU2Nzg5LjEzMjgwMTIzNDU2Nzg5LjEzMjgwMTIzNDU2Nzg5LjEzMj", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "7687890_24", "part": [1, 1], "seq": [1, 1], "prompt": "class CartesianProduct {\n\n  public static <T> List<ArrayList<T>> cartesianProduct(List<List<T>> sets) throws Exception {\n    final BigInteger MAX_LIST_SIZE = BigInteger.valueOf(100000);\n\n    BigInteger productSize = BigInteger.ONE;\n    for (List<T> set : sets) {\n      productSize = productSize.multiply(BigInteger.valueOf(set.size()));\n    }\n\n    if (productSize.compareTo(MAX_LIST_SIZE) == 1) {\n      throw new Exception(\"Will not generate carthesian product for more than \" + MAX_LIST_SIZE\n          + \" elements \" + \"(size would be \" + productSize + \"). Not proceeding.\");\n    }\n\n    List<ArrayList<T>> cartesianProduct = new ArrayList<ArrayList<T>>(productSize.intValue());\n    for (int i = 0; i < productSize.intValue(); i++) {\n      cartesianProduct.add(new ArrayList<T>(sets.size()));\n    }\n    \n    if(productSize.equals(BigInteger.ZERO)) {\n      // Empty product\n      return cartesianProduct;\n    }\n\n    int loopSize = productSize.intValue();\n    for (int i = 0; i < sets.size(); i++) {\n      List<T> set = sets.get(i);\n\n      loopSize /= set.size();\n      Iterator<T> it = set.iterator();\n      T e = null;\n      for (int j = 0; j < productSize.intValue(); j++) {\n        if ((j % loopSize) == 0) {\n          if (it.hasNext()) {\n            e = it.next();\n          } else {\n            it = set.iterator();\n            e = it.next();\n          }\n        }\n\n        cartesianProduct.get(j).add(e);\n      }\n    }\n\n    return cartesianProduct;\n  }\n\n}\n\nclass CartesianProductTest {\n\n  @Test\n  public void testEmptyList() throws Exception {\n", "reference": "    List<String> s1 = new ArrayList<String>();\n    s1.add(\"a\");\n    s1.add(\"b\");\n    List<String> s2 = new ArrayList<String>();\n    s2.add(\"c\");\n    s2.add(\"d\");\n    List<String> s3 = new ArrayList<String>();\n    \n    /*\n     * s3 is empty, therefore the cartesian product should contain zero elements.\n     * (i.e. you would not be able to satisfy the presentation policy in this case)\n     */\n    \n    List<List<String>> l = new ArrayList<List<String>>();\n    l.add(s1);\n    l.add(s2);\n    l.add(s3);\n    \n    List<ArrayList<String>> cp = CartesianProduct.cartesianProduct(l);\n    \n    List<List<String>> resultSet = new ArrayList<List<String>>();\n    assertEquals(resultSet, cp);\n  }\n\n}", "prediction": "   List<List<Integer>> sets = new ArrayList<List<Integer>>();\n    List<ArrayList<Integer>> cartesianProduct = CartesianProduct.cartesianProduct(sets);\n    assertEquals(0, cartesianProduct.size());\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "8023268_13", "part": [1, 1], "seq": [1, 1], "prompt": "class KeenClient {\n\n    public void addEvent(String eventCollection, Map<String, Object> event) {\n        addEvent(eventCollection, event, null);\n    }\n\n    protected  KeenClient(Builder builder);\n      KeenClient(Builder builder, Environment env);\n\n    public static KeenClient client();\n    public static void initialize(KeenClient client);\n    public static boolean isInitialized();\n    public void addEvent(String eventCollection, Map<String, Object> event,\n                         Map<String, Object> keenProperties);\n    public void addEvent(KeenProject project, String eventCollection, Map<String, Object> event,\n                         Map<String, Object> keenProperties, KeenCallback callback);\n    public void addEventAsync(String eventCollection, Map<String, Object> event);\n    public void addEventAsync(String eventCollection, Map<String, Object> event,\n                              final Map<String, Object> keenProperties);\n    public void addEventAsync(final KeenProject project, final String eventCollection,\n                              final Map<String, Object> event,\n                              final Map<String, Object> keenProperties,\n                              final KeenCallback callback);\n    public void queueEvent(String eventCollection, Map<String, Object> event);\n    public void queueEvent(String eventCollection, Map<String, Object> event,\n                           Map<String, Object> keenProperties);\n    public void queueEvent(KeenProject project, String eventCollection, Map<String, Object> event,\n                           Map<String, Object> keenProperties, final KeenCallback callback);\n    public void sendQueuedEvents();\n    public void sendQueuedEvents(KeenProject project);\n    public synchronized void sendQueuedEvents(KeenProject project, KeenCallback callback);\n    public void sendQueuedEventsAsync();\n    public void sendQueuedEventsAsync(final KeenProject project);\n    public void sendQueuedEventsAsync(final KeenProject project, final KeenCallback callback);\n    public KeenJsonHandler getJsonHandler();\n    public KeenEventStore getEventStore();\n    public Executor getPublishExecutor();\n    public KeenProject getDefaultProject();\n    public void setDefaultProject(KeenProject defaultProject);\n    public String getBaseUrl();\n    public void setBaseUrl(String baseUrl);\n    public void setMaxAttempts(int maxAttempts);\n    public int getMaxAttempts();\n    public GlobalPropertiesEvaluator getGlobalPropertiesEvaluator();\n    public void setGlobalPropertiesEvaluator(GlobalPropertiesEvaluator globalPropertiesEvaluator);\n    public Map<String, Object> getGlobalProperties();\n    public void setGlobalProperties(Map<String, Object> globalProperties);\n    public boolean isDebugMode();\n    public void setDebugMode(boolean isDebugMode);\n    public boolean isActive();\n    public void setProxy(String proxyHost, int proxyPort);\n    public void setProxy(Proxy proxy);\n    public Proxy getProxy();\n    protected void setActive(boolean isActive);\n    protected Map<String, Object> validateAndBuildEvent(KeenProject project,\n                                                        String eventCollection, Map<String, Object> event, Map<String, Object> keenProperties);\n    private void mergeGlobalProperties(Map<String, Object> globalProperties, Map<String, Object> keenProperties,\n                                       Map<String, Object> newEvent);\n    private void validateEventCollection(String eventCollection);\n    private void validateEvent(Map<String, Object> event);\n    @SuppressWarnings(\"unchecked\") // cast to generic Map will always be okay in this case private void validateEvent(Map<String, Object> event, int depth);\n    @SuppressWarnings(\"unchecked\") // cast to generic Map will always be okay in this case private void validateEventValue(Object value, int depth);\n    private Map<String, List<Map<String, Object>>> buildEventMap(String projectId,\n            Map<String, List<Object>> eventHandles);\n    private String publish(KeenProject project, String eventCollection, Map<String, Object> event);\n    private URL createURL(KeenProject project, String eventCollection);\n    private String publishAll(KeenProject project,\n                              Map<String, List<Map<String, Object>>> events);\n    private synchronized String publishObject(KeenProject project, URL url,\n                                              final Map<String, ?> requestData);\n    private boolean isNetworkConnected();\n    @SuppressWarnings(\"unchecked\") private void handleAddEventsResponse(Map<String, List<Object>> handles, String response);\n    private void handleSuccess(KeenCallback callback);\n    private void handleSuccess(KeenCallback callback,\n                               KeenProject project,\n                               String eventCollection,\n                               Map<String, Object> event,\n                               Map<String, Object> keenProperties);\n    private void handleFailure(KeenCallback callback, Exception e);\n    private void handleFailure(KeenCallback callback,\n                               KeenProject project,\n                               String eventCollection,\n                               Map<String, Object> event,\n                               Map<String, Object> keenProperties,\n                               Exception e);\n    private void handleLibraryInactive(KeenCallback callback);\n    private Map<String, Object> getEvent(Object handle);\n    private Map<String, Integer> getAttemptsMap(String projectId, String eventCollection);\n    private void setAttemptsMap(String projectId, String eventCollection, Map<String, Integer> attempts);\n\n    private static KeenProject TEST_PROJECT;\n    private static List<Map<String, Object>> TEST_EVENTS;\n    private static final String TEST_COLLECTION;\n    private static final String TEST_COLLECTION_2;\n    private static final String POST_EVENT_SUCCESS;\n    private static ObjectMapper JSON_MAPPER;\n    private KeenClient client;\n    private HttpHandler mockHttpHandler;\n\n}\n\nclass KeenClientTest {\n\n    private static KeenProject TEST_PROJECT;\n    private static List<Map<String, Object>> TEST_EVENTS;\n    private static final String TEST_COLLECTION;\n    private static final String TEST_COLLECTION_2;\n    private static final String POST_EVENT_SUCCESS;\n    private static ObjectMapper JSON_MAPPER;\n    private KeenClient client;\n    private HttpHandler mockHttpHandler;\n\n    @Test\n    public void testAddEventWithPlus() throws Exception{\n", "reference": "        setMockResponse(200, POST_EVENT_SUCCESS);\n\n        client.addEvent(\"Test+test\", TEST_EVENTS.get(0), null);\n\n        ArgumentCaptor<Request> capturedRequest = ArgumentCaptor.forClass(Request.class);\n        verify(mockHttpHandler).execute(capturedRequest.capture());\n        assertThat(capturedRequest.getValue().url.toString(), endsWith(\"Test+test\"));\n    }\n\n}", "prediction": "        Map<String, Object> event = new HashMap<String, Object>();\n        event.put(\"name\", \"test\");\n        event.put(\"age\", 10);\n        client.addEvent(\"test_collection\", event);\n        verify(mockHttpHandler).post(any(URL.class), anyMap());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "8064341_14", "part": [1, 1], "seq": [1, 1], "prompt": "class DelimitedStreamReader {\n\n  public String read(int numBytes) throws IOException {\n    Preconditions.checkArgument(numBytes >= 0);\n    Preconditions.checkArgument(numBytes <= MAX_ALLOWABLE_BUFFER_SIZE);\n    int numBytesRemaining = numBytes;\n    // first read whatever we need from our buffer\n    if (!isReadBufferEmpty()) {\n      int length = Math.min(end - offset, numBytesRemaining);\n      copyToStrBuffer(buffer, offset, length);\n      offset += length;\n      numBytesRemaining -= length;\n    }\n\n    // next read the remaining chars directly into our strBuffer\n    if (numBytesRemaining > 0) {\n      readAmountToStrBuffer(numBytesRemaining);\n    }\n\n    if (strBufferIndex > 0 && strBuffer[strBufferIndex - 1] != LF) {\n      // the last byte doesn't correspond to lf\n      return readLine(false);\n    }\n\n    int strBufferLength = strBufferIndex;\n    strBufferIndex = 0;\n    return new String(strBuffer, 0, strBufferLength, charset);\n  }\n\n  public  DelimitedStreamReader(InputStream stream, Charset charset, int bufferSize);\n\n  public String readLine();\n  private String readLine(boolean trim);\n  private void copyToStrBuffer(byte[] buffer, int offset, int length);\n  private void expandStrBuffer(int minLength);\n  private void readAmountToStrBuffer(int length);\n  private int readStreamToStrBuffer(int length);\n  private boolean isReadBufferEmpty();\n\n}\n\nclass DelimitedStreamReaderTest {\n\n  @Test\n  public void testMultibyteCharacters() throws Exception {\n", "reference": "    String myMessage = \"{this is my message: h\u00e9\u00ff}\\n\";\n    byte[] bytes = myMessage.getBytes(Charsets.UTF_8);\n\n    InputStream stream = new ByteArrayInputStream(bytes);\n    DelimitedStreamReader r = new DelimitedStreamReader(stream, Charsets.UTF_8, myMessage.length() / 3);\n\n    // read less bytes than the actual message, but we're lenient so we'll read up to the newline\n    String msg = r.read(myMessage.length());\n    assertEquals(msg, myMessage);\n  }\n\n}", "prediction": "    String str = \"abc\\u00e4\\u00f6\\u00fc\\u00df\\u00e4\\u00f6\\u00fc\\u00df\\u00e4\\u00f6\\u00fc\\u00df\\u00e4\\u00f6\\u00fc\\u00df\\u00e4\\u00f6\\u00fc\\u00df\\u00e4\\u00f6\\u00fc\\u00df\\u00e4\\u00f6\\u00fc\\u00df\\u00e4\\u00f6\\u00fc\\u00df\\u00e4\\u00f6\\u00fc\\u00df\\u00e4\\u00f6\\u00fc\\u00df\\u00e4\\u00f6\\u00fc\\u00df\\u00e4\\u00f6\\u00fc\\u00df\\u00e4\\u00f6\\u00fc\\u00df\\u00e4\\u00f6\\u00fc\\u00df\\u00e4\\u00f6\\u00fc\\u00df\\u00e4\\u00f6\\u00fc\\u00df\\u00e4\\u00f6\\u00fc\\u00df\\u00e4\\u00f6\\u00fc\\u00df\\u00e4\\u00f6\\u00fc\\u00df\\u00e4\\u00f6\\u00fc\\u00df\\u00e4\\u00f6\\u00fc\\u00df\\u00e4\\u00f6\\u00fc\\u00df\\u00e4\\u00f6\\u00fc\\u00df\\u00e4\\u00f6\\u00fc\\u00df\\u", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "8091481_3", "part": [1, 1], "seq": [1, 1], "prompt": "class LuceneHelper {\n\n\tpublic List<Integer> query(String query, String field, int n) {\n\t\tsearcher = getSearcher();\n\t\tTopScoreDocCollector collector = TopScoreDocCollector.create(n, true);\n\t\tList<Integer> results = new ArrayList<Integer>();\n\t\tQuery q = null;\n\n\t\ttry {\n\t\t\tq = new QueryParser(Version.LUCENE_41, field, new StandardAnalyzer(\n\t\t\t\t\tVersion.LUCENE_41)).parse(\"\\\"\" + query + \"\\\"\");\n\t\t} catch (ParseException e) {\n\t\t\tlogger.error(\"querying the index: {} \", e.toString());\n\t\t\treturn results;\n\t\t}\n\n\t\ttry {\n\t\t\tsearcher.search(q, collector);\n\t\t} catch (IOException e) {\n\t\t\tlogger.error(\"querying the index: {} \", e.toString());\n\t\t\treturn results;\n\t\t}\n\n\t\tScoreDoc[] hits = collector.topDocs().scoreDocs;\n\t\tfor (int i = 0; i < hits.length; ++i) {\n\t\t\tint docId = hits[i].doc;\n\t\t\tresults.add(getWikiId(docId));\n\t\t}\n\n\t\tlogger.debug(\"query {} docs {}\", query, results);\n\t\treturn results;\n\t}\n\n\tprotected  LuceneHelper(File wikiIdtToLuceneIdSerialization, File indexPath);\n\n\tprotected IndexReader getReader();\n\tprotected IndexSearcher getSearcher();\n\tpublic static boolean hasDexterLuceneIndex();\n\tpublic static LuceneHelper getDexterLuceneHelper();\n\tprotected void parseWikiIdToLuceneId();\n\tprotected void dumpWikiIdToLuceneId();\n\t@SuppressWarnings(\"unchecked\") public void loadWikiIdToLuceneId();\n\tprotected int getLuceneId(int wikiId);\n\tpublic float getSimilarity(Query query, int wikiId);\n\tpublic double getCosineSimilarity(int x, int y);\n\tpublic double getCosineSimilarity(int x, int y, String field);\n\tprivate double tfidfVector(Map<String, Double> tfidf,\n\t\t\tMap<String, Integer> freq, String field);\n\tprivate Document toLuceneDocument(Article a);\n\tpublic void addDocument(Article a);\n\tprotected void addDocument(int id, String content);\n\tpublic void clearIndex();\n\tpublic void commit();\n\tprivate Document getDoc(int wikiId);\n\tpublic int getFreq(String query, String field);\n\tpublic int getFreq(String query);\n\tpublic int getFreqFromSummary(String query);\n\tprivate IndexWriter getWriter();\n\tpublic int numDocs();\n\tpublic void closeWriter();\n\tpublic List<Integer> query(String query, String field);\n\tpublic List<Integer> query(String query);\n\tpublic Article getArticle(int id);\n\tpublic Article getArticleSummary(int id);\n\tpublic int getWikiId(int luceneId);\n\t@SuppressWarnings(\"null\") public void rankBySimilarity(SpotMatch spot, EntityMatchList eml,\n\t\t\tString context, String field);\n\tpublic void rankBySimilarity(SpotMatch spot, EntityMatchList eml,\n\t\t\tString context);\n\n\tstatic LuceneHelper helper;\n\tstatic File luceneDir;\n\n}\n\nclass LuceneHelperTest {\n\n\tstatic LuceneHelper helper;\n\tstatic File luceneDir;\n\n\t@Test\n\tpublic void testQuery() {\n", "reference": "\t\tList<Integer> results = helper.query(\"diego\");\n\t\tassertEquals(3, results.size());\n\t\tSet<Integer> expected = new HashSet<Integer>();\n\t\texpected.add(1);\n\t\texpected.add(4);\n\t\texpected.add(5);\n\n\t\tassertEquals(expected, new HashSet<Integer>(results));\n\n\t}\n\n}", "prediction": "\t\tList<Integer> results = helper.query(\"java\", \"content\", 10);\n\t\tassertTrue(results.size() > 0);\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "8103494_8", "part": [1, 1], "seq": [1, 1], "prompt": "class PullNotification {\n\n    public static void main(String[] args) {\n        PullNotification.newInstance(args).run();\n    }\n\n    private  PullNotification();\n    private  PullNotification(String[] args);\n\n    private static PullNotification newInstance(String[] args);\n    private void parameterParser(String[] args);\n    private void displayHelp();\n    private String parameterParser(String param);\n    private void run();\n    private void autoCheckAndChangeGitPullStatus(int buildId);\n    private void changeStatus(String buildStatus);\n    private void addCommitMessage();\n    private void changeStatus(CommitStatus status);\n    private Repository getRepository();\n    private void loginToGitHub();\n\n}\n\nclass PullNotificationTest {\n\n    @Test\n    public void testOptionalError() {\n", "reference": "        String[] args = new String[8];\n        args[0] = \"-ro=branflake2267\";\n        args[1] = \"-rn=Sandbox\";\n        args[2] = \"-sha=2e84e6446df300cd572930869c5ed2be8ee1f614\";\n        args[3] = \"-github=github\";\n        args[4] = \"-teamcity=teamcity-gonevertical\";\n        args[5] = \"-returnurl=http://teamcity.gonevertical.org\";\n        args[6] = \"-status=error\";\n        args[7] = \"-skipcomment=true\";\n        \n        PullNotification.main(args);\n    }\n\n}", "prediction": "        PullNotification.newInstance(new String[] { \"--help\" });\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "8475355_0", "part": [1, 1], "seq": [1, 1], "prompt": "class OrderMailer extends BaseMailer {\n\n\tpublic AsyncToken sendConfirmOrder(final String username) {\n\t\tfinal SimpleMailMessage msg = createConfirmOrder(username);\n\t\t\n\t\t//\u8f6c\u6362\u4e3ahtml\u90ae\u4ef6\u5e76\u53d1\u9001,\u53e6\u6709\u4e00\u4e2a\u53c2\u6570\u53ef\u4ee5\u6307\u5b9a\u53d1\u4ef6\u4eba\u540d\u79f0\n\t\tAsyncToken token = getAsyncJavaMailSender().send(SimpleMailMessageUtils.toHtmlMsg(msg,\"rapid\u5c0f\u660e\")); \n\t\t\n\t\t//\u5904\u7406\u90ae\u4ef6\u53d1\u9001\u7ed3\u679c\n\t\ttoken.addResponder(new IResponder() {\n\t\t\tpublic void onFault(Exception fault) {\n\t\t\t\tSystem.out.println(\"[ERROR] confirmOrder mail send fail,cause:\"+fault);\n\t\t\t}\n\t\t\tpublic void onResult(Object result) {\n\t\t\t\tSystem.out.println(\"[INFO] confirmOrder mail send success\");\n\t\t\t}\n\t\t});\n\t\t\n\t\t//\u8fd4\u56detoken\u53ef\u4ee5\u7528\u4e8e\u5916\u90e8\u7ee7\u7eed\u76d1\u542c\n\t\treturn token;\n\t}\n\n\tpublic SimpleMailMessage createConfirmOrder(String username);\n\n\t OrderMailer orderMailer;\n\n}\n\nclass OrderMailerTest {\n\n\t OrderMailer orderMailer;\n\n\t@Test\n\tpublic void testSendFromOrderMailer() throws TemplateException, IOException, Exception {\n", "reference": "\t\tAsyncToken token = orderMailer.sendConfirmOrder(\"badqiu\");\n\t\t\n\t\t//waitForResult\u4e3b\u8981\u7528\u4e8e\u6d4b\u8bd5\uff0c\u8bf7\u4f7f\u7528\u76f8\u540c\u529f\u80fd\u7684Future.get()\n\t\ttoken.waitForResult();\n\t}\n\n}", "prediction": "\t\tAsyncToken token = orderMailer.sendConfirmOrder(\"rapid\");\n\t\ttoken.waitForResult();\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "8488249_10", "part": [1, 1], "seq": [1, 1], "prompt": "class SendWithUs {\n\n    public SendReceipt send(String emailId, Map<String, Object> recipient,\n            Map<String, Object> emailData) throws SendWithUsException\n    {\n        return this.send(emailId, recipient, null, emailData);\n    }\n\n    public  SendWithUs(String apiKey);\n    public  SendWithUs(String apiKey, SendWithUsApiLocation sendWithUsApiLocation);\n\n    private String getURLEndpoint(String resourceName);\n    private HttpURLConnection createConnection(\n            String url, String method, Map<String, Object> params);\n    private Map<String, String> getHeaders(String apiKey);\n    private String getResponseBody(HttpURLConnection connection);\n    protected String makeURLRequest(String url, String method);\n    protected String makeURLRequest(String url, String method, Map<String, Object> params);\n    @Deprecated public Email[] emails();\n    public Email[] templates();\n    public Email template(String templateId);\n    public Email template(String templateId, String locale);\n    public TemplateVersionDetails templateVersion(String templateId, String versionId);\n    public TemplateVersionDetails templateVersion(String templateId, String versionId, String locale);\n    public SendReceipt send(String emailId, Map<String, Object> recipient,\n            Map<String, Object> sender, Map<String, Object> emailData);\n    public SendReceipt send(String emailId, Map<String, Object> recipient,\n            Map<String, Object> sender, Map<String, Object> emailData,\n            Map<String, Object>[] cc);\n    public SendReceipt send(String emailId, Map<String, Object> recipient,\n            Map<String, Object> sender, Map<String, Object> emailData,\n            Map<String, Object>[] cc, Map<String, Object>[] bcc);\n    public SendReceipt send(String emailId, Map<String, Object> recipient,\n            Map<String, Object> sender, Map<String, Object> emailData,\n            Map<String, Object>[] cc, Map<String, Object>[] bcc,\n            String[] attachment_paths);\n    public SendReceipt send(String emailId, Map<String, Object> recipient,\n            Map<String, Object> sender, Map<String, Object> emailData,\n            Map<String, Object>[] cc, Map<String, Object>[] bcc,\n            String[] attachment_paths, String espAccount);\n    public SendReceipt send(String emailId, Map<String, Object> recipient,\n                            Map<String, Object> sender, Map<String, Object> emailData,\n                            Map<String, Object>[] cc, Map<String, Object>[] bcc,\n                            String[] attachment_paths, String espAccount,\n                            String locale);\n    public SendReceipt send(String emailId, Map<String, Object> recipient,\n                            Map<String, Object> sender, Map<String, Object> emailData,\n                            Map<String, Object>[] cc, Map<String, Object>[] bcc,\n                            String[] attachment_paths, String espAccount,\n                            String locale, Map<String, String> headers);\n    public SendReceipt send(SendWithUsSendRequest request);\n    public RenderedTemplate render(String templateId,\n            Map<String, Object> templateData);\n    public ActivatedDrip startOnDripCampaign(String dripCampaignId, SendWithUsDripRequest dripRequest);\n    public DeactivatedDrip removeFromDripCampaign(String customerEmailAddress, String dripCampaignId );\n    public DeactivatedDrips deactivateDrips(String customerEmailAddress);\n    public CustomerReceipt createUpdateCustomer(String customerEmailAddress,\n            Map<String, Object> customerData);\n    public SendReceipt resend(String logId);\n    public Snippet[] getSnippets();\n    public Snippet getSnippet(String snippetId);\n    public SnippetReceipt createSnippet(String name, String body);\n    public SnippetReceipt updateSnippet(String snippetId, String name, String body);\n    public APIReceipt deleteSnippet(String snippetId);\n\n    public static final String SENDWITHUS_API_KEY;\n    public static final String EMAIL_ID;\n    public static final String TEMPLATE_ID;\n    public static final String VERSION_ID;\n     SendWithUs sendwithusAPI;\n     Map<String, Object> defaultRecipientParams;\n     Map<String, Object> invalidRecipientParams;\n     Map<String, Object> defaultSenderParams;\n     Map<String, Object> defaultDataParams;\n    private static final String TEST_RECIPIENT_ADDRESS;\n\n}\n\nclass SendWithUsTest {\n\n    public static final String SENDWITHUS_API_KEY;\n    public static final String EMAIL_ID;\n    public static final String TEMPLATE_ID;\n    public static final String VERSION_ID;\n     SendWithUs sendwithusAPI;\n     Map<String, Object> defaultRecipientParams;\n     Map<String, Object> invalidRecipientParams;\n     Map<String, Object> defaultSenderParams;\n     Map<String, Object> defaultDataParams;\n    private static final String TEST_RECIPIENT_ADDRESS;\n\n    @Test\n    public void testSendWithHeaders() throws SendWithUsException\n    {\n", "reference": "        Map<String, String> headers = new HashMap<String, String>();\n        headers.put(\"X-Auto-Response-Suppress\", \"header-value\");\n\n        SendWithUsSendRequest request = new SendWithUsSendRequest()\n                .setEmailId(EMAIL_ID).setRecipient(defaultRecipientParams)\n                .setSender(defaultSenderParams).setEmailData(defaultDataParams)\n                .setHeaders(headers);\n\n        SendReceipt sendReceipt = sendwithusAPI.send(request);\n\n        assertSuccessfulAPIReceipt(sendReceipt);\n    }\n\n}", "prediction": "        Map<String, String> headers = new HashMap<String, String>();\n        headers.put(\"X-Test-Header\", \"Test\");\n        SendReceipt receipt = sendwithusAPI.send(EMAIL_ID, defaultRecipientParams, defaultSenderParams, defaultDataParams, headers);\n        assertNotNull(receipt);\n        assertNotNull(receipt.getLogId());\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "8608977_6", "part": [1, 1], "seq": [1, 1], "prompt": "class OpenReport extends BaseTrackingReport {\n\n    public void setOpenDate(Date openDate) {\n        _openDate = openDate;\n    }\n\n    public  OpenReport();\n\n    public Date getOpenDate();\n    @Override public boolean equals(Object obj);\n    @Override public int hashCode();\n\n    private static final String EMAIL;\n    private static final String CAMPAIGN_ID;\n    private static final String CONTACT_ID;\n    private static final TrackingReportType TYPE;\n    private static final Date DATE;\n\n}\n\nclass OpenReportTest {\n\n    private static final String EMAIL;\n    private static final String CAMPAIGN_ID;\n    private static final String CONTACT_ID;\n    private static final TrackingReportType TYPE;\n    private static final Date DATE;\n\n    @Test\n    public void expectThatGettingAndSettingValues_WillReturnSame() {\n", "reference": "        OpenReport openReport = new OpenReport();\n\n        openReport.setEmailAddress(EMAIL);\n        openReport.setCampaignId(CAMPAIGN_ID);\n        openReport.setContactId(CONTACT_ID);\n        openReport.setActivityType(TYPE);\n        openReport.setOpenDate(DATE);\n\n        runAssertions(openReport);\n    }\n\n}", "prediction": "        OpenReport report = new OpenReport();\n        report.setOpenDate(DATE);\n\n        assertEquals(DATE, report.getOpenDate());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "8771890_2", "part": [1, 1], "seq": [1, 1], "prompt": "class AuthenticationUtil {\n\n    public static void authenticate(String userId, String password)\n        throws AuthenticationFailedException, UserIdLockedException, PasswordExpiredException {\n        PasswordAuthenticator authenticator = SystemRepository.get(AUTHENTICATOR);\n        authenticator.authenticate(userId, password);\n    }\n\n    private  AuthenticationUtil();\n\n    public static String encryptPassword(String userId, String password);\n\n    private static PasswordAuthenticator defaultAuthenticator;\n    private static PasswordEncryptor defaultPasswordEncryptor;\n\n}\n\nclass AuthenticationUtilTest {\n\n    private static PasswordAuthenticator defaultAuthenticator;\n    private static PasswordEncryptor defaultPasswordEncryptor;\n\n    @Test\n    public void testAuthenticate() {\n", "reference": "        MockAuthenticator sut = SystemRepository.get(\"authenticator\");\n        sut.called(1);\n        sut.calledWith(\"userId\", \"password\");\n        AuthenticationUtil.authenticate(\"userId\", \"password\");\n        sut.verify(\"1\u5ea6\u3060\u3051\u547c\u3073\u51fa\u3055\u308c\u3001\u5f15\u6570\u304c\u305d\u306e\u307e\u307eauthenticator\u306b\u6e21\u3055\u308c\u3066\u3044\u308b\u3053\u3068\u3002\");\n    }\n\n}", "prediction": "        AuthenticationUtil.authenticate(\"user1\", \"pass1\");\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "9149127_10", "part": [1, 1], "seq": [1, 1], "prompt": "class JsonHandler implements Serializable {\n\n\tpublic Object parse(String str) {\n\t\tObject ret = deserializer.deserialize(str);\n\t\treturn ret;\n\t}\n\n\tpublic  JsonHandler();\n\n\tpublic static JsonHandler instance();\n\tpublic JSONDeserializer<Object> getDeserializer();\n\tpublic JSONSerializer getSerializer();\n\tpublic String format(Object obj);\n\tpublic void format(Object obj, Writer writer);\n\t@SuppressWarnings(\"unchecked\") public T parse(String str, Class<T> clazz);\n\tpublic void setPrettyPrint(boolean prettyPrint);\n\n\tprivate static final Logger LOG;\n\tprivate JsonHandler handler;\n\n}\n\nclass JsonHandlerTest {\n\n\tprivate static final Logger LOG;\n\tprivate JsonHandler handler;\n\n\t@Test\n\tpublic void testParseBasics() {\n", "reference": "\t\tassertEquals(null, handler.parse(\"null\"));\n\n\t\tassertEquals(true, handler.parse(\"true\"));\n\t\tassertEquals(false, handler.parse(\"false\"));\n\n\t\tassertEquals(\"my string\", handler.parse(\"'my string'\"));\n\t\tassertEquals(\"null\", handler.parse(\"'null'\"));\n\t\tassertEquals(\"true\", handler.parse(\"'true'\"));\n\t\tassertEquals(2, handler.parse(\"2\"));\n\t\tassertEquals(2.4, handler.parse(\"2.4\"));\n\n\t\tassertEquals(\"\", handler.parse(\"''\"));\n\t}\n\n}", "prediction": "\t\tObject obj = handler.parse(\"{\\\"a\\\":1,\\\"b\\\":2}\");\n\t\tassertTrue(obj instanceof Map);\n\t\tMap<String, Object> map = (Map<String, Object>) obj;\n\t\tassertEquals(1, map.get(\"a\"));\n\t\tassertEquals(2, map.get(\"b\"));\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "9198697_1", "part": [1, 1], "seq": [1, 1], "prompt": "class Call {\n\n    @Override\n    public boolean equals(final Object o) {\n        return\n            o instanceof Call && commandName.equals(((Call) o).commandName);\n    }\n\n    public  Call(final String commandName, final Completer... completers);\n\n    public static Call call(final String commandName, final Completer... completers);\n    public String commandName();\n    public Completer[] completers();\n    @Override public int hashCode();\n\n}\n\nclass CallTest {\n\n    @Test\n    public void testEquals() throws Exception {\n", "reference": "        final Call call = call(\"cmd\");\n        assertTrue(call.equals(call(\"cmd\")));\n    }\n\n}", "prediction": "        Call call = Call.call(\"foo\");\n        assertEquals(call, call);\n        assertEquals(call, Call.call(\"foo\"));\n        assertNotEquals(call, Call.call(\"bar\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "9221446_15", "part": [1, 1], "seq": [1, 1], "prompt": "class ValidityTools {\n\n\tpublic static String getHostName ( String hostandport ) {\n\t\tString hostname = \"\";\n\t\ttry {\n\t\t\tMatcher m = hostAndPortPattern.matcher( hostandport );\n\t\t\tm.matches( );\n\t\t\thostname = m.group( 1 ).toLowerCase( ).trim( );\n\t\t} catch ( Exception e ) {}\n\t\treturn hostname;\n\t}\n\n\tpublic static boolean isAccessibleSocket( String host , int port );\n\tpublic static boolean isAccessibleSocket( String host , int port, int timeOutInMSec );\n\tpublic static void checkAccessibilityOfDirs( String ... args );\n\tpublic static void checkAccessibilityOfFiles( String... args );\n\tpublic static void isDBAccessible( String driverClass , String url , String user , String password );\n\tpublic static int getPortNumber( String hostandport );\n\tpublic static boolean isLocalhost( String host );\n\tpublic static boolean isInt( String value );\n\tpublic static boolean isValidJavaVariable(CharSequence string);\n\n\tstatic StorageManager sm;\n\n}\n\nclass TestValidityTools {\n\n\tstatic StorageManager sm;\n\n\t@Test\n\tpublic void testGetHostName() {\n", "reference": "\n\t}\n\n\tpublic static boolean isAccessibleSocket( String host , int port );\n\tpublic static boolean isAccessibleSocket( String host , int port, int timeOutInMSec );\n\tpublic static void checkAccessibilityOfDirs( String ... args );\n\tpublic static void checkAccessibilityOfFiles( String... args );\n\tpublic static void isDBAccessible( String driverClass , String url , String user , String password );\n\tpublic static int getPortNumber( String hostandport );\n\tpublic static boolean isLocalhost( String host );\n\tpublic static boolean isInt( String value );\n\tpublic static boolean isValidJavaVariable(CharSequence string);\n\n\tstatic StorageManager sm;\n\n}\n\nclass TestValidityTools {\n\n\tstatic StorageManager sm;\n\n\t@Test\n\tpublic void testGetHostName() {\n\n\t}\n\n}", "prediction": "\t\tassertEquals( \"localhost\", ValidityTools.getHostName( \"localhost:8080\" ) );\n\t\tassertEquals( \"localhost\", ValidityTools.getHostName( \"localhost\" ) );\n\t\tassertEquals( \"localhost\", ValidityTools.getHostName( \"localhost:8080\" ) );\n\t\tassertEquals( \"localhost\", ValidityTools.getHostName( \"localhost:8080\" ) );\n\t\tassertEquals( \"localhost\", ValidityTools.getHostName( \"localhost:8080\" ) );\n\t\tassertEquals( \"localhost\", ValidityTools.getHostName( \"localhost:8080\" ) );\n\t\tassertEquals( \"localhost\", ValidityTools.getHostName( \"localhost:8080\" ) );\n\t\tassertEquals( \"localhost\", ValidityTools.getHostName( \"localhost:8080\" ) );\n\t\tassertEquals( \"localhost\", ValidityTools.getHostName( \"localhost:8080\" ) );\n\t\tassertEquals( \"localhost\", ValidityTools.getHostName( \"localhost:8080\" ) );\n\t\tassertEquals( \"localhost\", ValidityTools.getHostName( \"localhost:8080\" ) );\n\t\tassertEquals( \"localhost\", ValidityTools.getHostName( \"localhost:8080\" ) );\n\t\tassertEquals( \"localhost\", ValidityTools.getHostName( \"localhost:8080\" ) );\n\t\tassertEquals( \"localhost\", ValidityTools.getHostName( \"localhost:8080\" ) );\n\t\tassertEquals( \"localhost\", ValidityTools.getHostName( \"localhost:8080\" ) );\n\t\tassertEquals( \"localhost\", ValidityTools.getHostName( \"localhost:8080\" ) );\n\t\tassertEquals( \"localhost\", ValidityTools.getHostName( \"localhost:8080\" ) );\n\t\tassertEquals( \"localhost\", ValidityTools.getHostName( \"localhost:8080\" ) );\n\t\tassertEquals( \"localhost\", ValidityTools.getHostName( \"localhost:8080\" ) );\n\t\tassertEquals( \"localhost\", ValidityTools.getHostName( \"localhost:8080\" ) );\n\t\tassertEquals( \"localhost\", ValidityTools.getHostName( \"localhost:8080\" ) );\n\t\tassertEquals( \"localhost\", ValidityTools.getHostName( \"localhost:8080\" ) );\n\t\tassertEquals( \"localhost\", ValidityTools.getHostName( \"localhost:8080\" ) );\n\t\tassertEquals( \"localhost\", ValidityTools.getHostName( \"localhost:8080\" ) );\n\t\tassertEquals( \"localhost\", ValidityTools.getHostName( \"localhost:8080\" ) );\n\t\tassertEquals( \"localhost\", ValidityTools.getHostName( \"localhost:8080\" ) );\n\t\tassertEquals( \"localhost\", ValidityTools.getHostName( \"localhost:8080\" ) );\n\t\tassertEquals( \"localhost\", ValidityTools.getHostName( \"localhost:8080\" ) );\n\t\tassertEquals( \"localhost\", ValidityTools.getHostName( \"localhost:8080\" ) );\n\t\tassertEquals( \"localhost\", ValidityTools.getHostName( \"localhost:8080\" ) );\n\t\tassertEquals( \"localhost\", ValidityTools.getHostName( \"localhost:8080\" ) );\n\t\tassertEquals( \"localhost\", ValidityTools.getHostName( \"localhost:8080\" ) );\n\t\tassertEquals( \"localhost\", ValidityTools.getHostName( \"localhost:8080\" ) );\n\t\tassertEquals( \"localhost\", ValidityTools.getHostName( \"localhost:8080\" ) );\n\t\tassertEquals( \"localhost\", ValidityTools.getHostName( \"localhost:8080\" ) );\n\t\tassertEquals( \"localhost\", ValidityTools.getHostName( \"localhost:8080\" ) );\n\t\tassertEquals( \"localhost\", ValidityTools.getHostName( \"localhost:8080\" ) );\n\t\tassertEquals( \"localhost\", ValidityTools.getHostName( \"localhost:8080\" ) );\n\t\tassertEquals( \"localhost\", ValidityTools.getHostName( \"localhost:8080\" ) );\n\t\tassertEquals( \"localhost\", ValidityTools.getHostName( \"localhost:8080\" ) );\n\t\tassertEquals( \"localhost\", ValidityTools.getHostName( \"localhost:8080\" ) );\n\t\tassertEquals( \"localhost\", ValidityTools.getHostName( \"localhost:8080\" ) );\n\t\tassertEquals( \"localhost\", ValidityTools.getHostName( \"localhost:8080\" ) );\n\t\tassertEquals( \"localhost\", ValidityTools.getHostName( \"localhost:8080\" ) );\n\t\tassertEquals( \"localhost\", ValidityTools.getHostName( \"localhost:8080\" ) );\n\t\tassertEquals( \"localhost\", ValidityTools.getHostName( \"localhost:8080\" ) );\n\t\tassertEquals( \"localhost\", ValidityTools.getHostName( \"localhost:8080\" ) );\n\t\tassertEquals( \"localhost\", ValidityTools.getHostName( \"localhost:8080\" ) );\n\t\tassertEquals( \"localhost\", ValidityTools.getHostName( \"localhost:8080\" ) );\n\t\tassertEquals", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "9248683_186", "part": [1, 1], "seq": [1, 1], "prompt": "class HqlQueryTranslator extends\n        AbstractHibernateQueryTranslator<String, String, String> implements\n        QueryTranslator<String, String, String> {\n\n    @Override\n    public String notNull(String fieldName) {\n        return join(fieldName, HibernateOperator.NOT_NULL);\n    }\n\n    public  HqlQueryTranslator(HibernatePropertyResolver propertyResolver,\n            BoxMaker boxMaker,\n            ContainsExpressionHandler<String> containsExpressionHandler);\n    public  HqlQueryTranslator(HibernatePropertyResolver propertyResolver,\n            BoxMaker boxMaker);\n    public  HqlQueryTranslator(HibernatePropertyResolver propertyResolver);\n\n    protected String string(Object o);\n    protected String join(String fieldName, Object... parts);\n    @Override protected String translate(NativeExpression e, Class<T> entityClass);\n    @Override public String eq(String fieldName, Object value);\n    @Override public String ne(String fieldName, Object value);\n    @Override public String lt(String fieldName, Object value);\n    @Override public String lte(String fieldName, Object value);\n    @Override public String gt(String fieldName, Object value);\n    @Override public String gte(String fieldName, Object value);\n    @Override public String between(String fieldName, Object from, Object to);\n    @Override public String in(String fieldName, Object[] values);\n    @Override public String notIn(String fieldName, Object[] values);\n    @Override public String isNull(String fieldName);\n    @Override public String isEmpty(String fieldName);\n    @Override public String notEmpty(String fieldName);\n    @Override public String within(String xFieldName,\n            String yFieldName, Box<N> box);\n    @Override public String and(String... subqueries);\n    @Override public String or(String... subqueries);\n    protected String junction(HibernateOperator operator, String... subqueries);\n    @Override public String order(String fieldName, Order o);\n    @Override public String order(String... orders);\n    @Override public String translateProjection(Query<T, R> query);\n\n    private final HibernatePropertyResolver resolver;\n    private final BoxMaker boxMaker;\n    private final ContainsExpressionHandler<String> containsExpressionHandler;\n    private final HqlQueryTranslator translator;\n    private final String property;\n    private final String value;\n    private final Integer from;\n    private final Integer to;\n    private final String[] values;\n    private final Box<Integer> box;\n\n}\n\nclass HqlQueryTranslatorTest {\n\n    private final HibernatePropertyResolver resolver;\n    private final BoxMaker boxMaker;\n    private final ContainsExpressionHandler<String> containsExpressionHandler;\n    private final HqlQueryTranslator translator;\n    private final String property;\n    private final String value;\n    private final Integer from;\n    private final Integer to;\n    private final String[] values;\n    private final Box<Integer> box;\n\n    @Test\n    public void notNull() {\n", "reference": "        assertEquals(join(property, HibernateOperator.NOT_NULL), translator.notNull(property));\n    }\n\n}", "prediction": "        String query = translator.notNull(property);\n        assertEquals(\"not \" + property + \" is null\", query);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "9836833_41", "part": [1, 1], "seq": [1, 1], "prompt": "class MoreClasses {\n\n\tpublic static Set<Class> getInheritedClasses(Class clazz) {\n\t\tSet<Class> inheritedClasses = Sets.newHashSet();\n\n\t\t// add super class, and add recursively their inherited classes\n\t\tClass superClass = clazz.getSuperclass();\n\t\tif (superClass != null) {\n\t\t\tinheritedClasses.add(superClass);\n\t\t\tinheritedClasses.addAll(getInheritedClasses(superClass));\n\t\t}\n\n\t\t// add all interfaces, and recursively add their inherited classes\n\t\tClass[] interfaces = clazz.getInterfaces();\n\t\tfor (Class anInterface : interfaces) {\n\t\t\tinheritedClasses.add(anInterface);\n\t\t\tinheritedClasses.addAll(getInheritedClasses(anInterface));\n\t\t}\n\n\t\treturn inheritedClasses;\n\t}\n\n\tprivate  MoreClasses();\n\n}\n\nclass MoreClassesTest {\n\n\t@Test\n\tpublic void should_find_inherited_super_classes() {\n", "reference": "\t\tassertThat(getInheritedClasses(B.class)).containsOnly(A.class, Object.class);\n\t\tassertThat(getInheritedClasses(C.class)).containsOnly(B.class, A.class, Object.class);\n\t}\n\n}", "prediction": "\t\tSet<Class> inheritedClasses = MoreClasses.getInheritedClasses(String.class);\n\t\tassertThat(inheritedClasses).containsOnly(Object.class, Serializable.class, Comparable.class, CharSequence.class);\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "10275891_1", "part": [1, 1], "seq": [1, 1], "prompt": "class InnerClassCoverage {\n\n    public boolean delegate() {\n        return new InnerClass().isInner();\n    }\n\n    public void anonymous();\n\n}\n\nclass InnerClassCoverageTest {\n\n    @Test\n    public void testDelegate() {\n", "reference": "        new InnerClassCoverage().delegate();\n    }\n\n}", "prediction": "        assertTrue(new InnerClassCoverage().delegate());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "10306448_0", "part": [1, 1], "seq": [1, 1], "prompt": "class NCXDocument {\n\n\tpublic static Resource read(Book book, EpubReader epubReader) {\n\t\tResource ncxResource = null;\n\t\tif(book.getSpine().getTocResource() == null) {\n//\t\t\tlog.error(\"Book does not contain a table of contents file\");\n\t\t\treturn ncxResource;\n\t\t}\n\t\ttry {\n\t\t\tncxResource = book.getSpine().getTocResource();\n\t\t\tif(ncxResource == null) {\n\t\t\t\treturn ncxResource;\n\t\t\t}\n\t\t\tDocument ncxDocument = ResourceUtil.getAsDocument(ncxResource);\n\t\t\tElement navMapElement = DOMUtil.getFirstElementByTagNameNS(ncxDocument.getDocumentElement(), NAMESPACE_NCX, NCXTags.navMap);\n\t\t\tTableOfContents tableOfContents = new TableOfContents(readTOCReferences(navMapElement.getChildNodes(), book));\n\t\t\tbook.setTableOfContents(tableOfContents);\n\t\t} catch (Exception e) {\n\t\t\tlog.error(e.getMessage(), e);\n\t\t}\n\t\treturn ncxResource;\n\t}\n\n\tprivate static List<TOCReference> readTOCReferences(NodeList navpoints, Book book);\n\tprivate static TOCReference readTOCReference(Element navpointElement, Book book);\n\tprivate static String readNavReference(Element navpointElement);\n\tprivate static String readNavLabel(Element navpointElement);\n\tpublic static void write(EpubWriter epubWriter, Book book, ZipOutputStream resultStream);\n\tpublic static void write(XmlSerializer xmlSerializer, Book book);\n\tpublic static Resource createNCXResource(Book book);\n\tpublic static Resource createNCXResource(List<Identifier> identifiers, DcmesElement title, List<Author> authors, TableOfContents tableOfContents);\n\tpublic static void write(XmlSerializer serializer, List<Identifier> identifiers, DcmesElement title, List<Author> authors, TableOfContents tableOfContents);\n\tprivate static void writeMetaElement(String dtbName, String content, XmlSerializer serializer);\n\tprivate static int writeNavPoints(List<TOCReference> tocReferences, int playOrder,\n\t\t\tXmlSerializer serializer);\n\tprivate static void writeNavPointStart(TOCReference tocReference, int playOrder, XmlSerializer serializer);\n\tprivate static void writeNavPointEnd(TOCReference tocReference, XmlSerializer serializer);\n\n     byte[] ncxData;\n\n}\n\nclass NCXDocumentTest {\n\n     byte[] ncxData;\n\n    @Test\n    public void testReadWithNonRootLevelTOC() {\n", "reference": "        \n        // If the tox.ncx file is not in the root, the hrefs it refers to need to preserve its path.\n        Book book = new Book();\n        Resource ncxResource = new Resource(ncxData, \"xhtml/toc.ncx\");\n        Resource chapterResource = new Resource(\"id1\", \"Hello, world !\".getBytes(), \"xhtml/chapter1.html\", MediatypeService.XHTML);\n        book.addResource(chapterResource);\n        book.getSpine().addResource(chapterResource);\n\n        book.setNcxResource(ncxResource);\n        book.getSpine().setTocResource(ncxResource);\n\n        NCXDocument.read(book, new EpubReader());\n        assertEquals(\"xhtml/chapter1.html\", book.getTableOfContents().getTocReferences().get(0).getCompleteHref());\n    }\n\n}", "prediction": "        Book book = new Book();\n        book.setTitle(\"Test Book\");\n        book.setLanguage(\"en\");\n        book.setUniqueIdentifier(new Identifier(\"urn:uuid:39784d99-f916-4b4b-99a8-100d4w00020f\"));\n        book.setDate(new Date());\n        book.setCreator(\"Test Creator\");\n        book.setPublisher(\"Test Publisher\");\n        book.setDescription(\"Test Description\");\n        book.setSource(\"Test Source\");\n        book.setSubject(\"Test Subject\");\n        book.setType(\"Test Type\");\n        book.setFormat(\"Test Format\");\n        book.setRelation(\"Test Relation\");\n        book.setCoverImage(new Resource(\"cover.jpg\"));\n        book.setSpine(new Spine());\n        book.getSpine().setTocResource(new Resource(\"toc.ncx\"));\n        book.getSpine().addResource(new Resource(\"chap1.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap2.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap3.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap4.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap5.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap6.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap7.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap8.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap9.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap10.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap11.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap12.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap13.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap14.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap15.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap16.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap17.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap18.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap19.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap20.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap21.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap22.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap23.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap24.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap25.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap26.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap27.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap28.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap29.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap30.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap31.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap32.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap33.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap34.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap35.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap36.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap37.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap38.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap39.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap40.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap41.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap42.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap43.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap44.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap45.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap46.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap47.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap48.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap49.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap50.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap51.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap52.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap53.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap54.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap55.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap56.xhtml\"));\n        book.getSpine().addResource(new Resource(\"chap57", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "10459637_4", "part": [1, 1], "seq": [1, 1], "prompt": "class HexString {\n\n    public static byte[] fromHexString(String values) throws NumberFormatException {\n        String[] octets = values.split(\":\");\n        byte[] ret = new byte[octets.length];\n        \n        for(int i = 0; i < octets.length; i++) {\n            if (octets[i].length() > 2)\n                throw new NumberFormatException(\"Invalid octet length\");\n            ret[i] = Integer.valueOf(octets[i], 16).byteValue();\n        }\n        return ret;\n    }\n\n    public static String toHexString(byte[] bytes);\n    public static String toHexString(long val, int padTo);\n    public static String toHexString(long val);\n    public static long toLong(String values);\n\n}\n\nclass HexStringTest  {\n\n    @Test\n    public void testFromHexStringError() {\n", "reference": "        String invalidStr = \"00:00:00:00:00:00:ffff\";\n        try {\n            HexString.fromHexString(invalidStr);\n            fail(\"HexString.fromHexString() should have thrown a NumberFormatException\");\n        }\n        catch (NumberFormatException expected) {\n            // do nothing\n        }\n    }\n\n}", "prediction": "        try {\n            HexString.fromHexString(\"123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "11136641_144", "part": [1, 1], "seq": [1, 1], "prompt": "class LdapRdn implements Serializable, Comparable {\n\n\tpublic int hashCode() {\n\t\treturn this.getClass().hashCode() ^ new HashSet(getComponents()).hashCode();\n\t}\n\n\tpublic  LdapRdn();\n\tpublic  LdapRdn(String string);\n\tpublic  LdapRdn(String key, String value);\n\n\tpublic void addComponent(LdapRdnComponent rdnComponent);\n\tpublic List getComponents();\n\tpublic LdapRdnComponent getComponent();\n\tpublic LdapRdnComponent getComponent(int idx);\n\tpublic String getLdapEncoded();\n\tpublic String encodeUrl();\n\tpublic int compareTo(Object obj);\n\tpublic boolean equals(Object obj);\n\tpublic String toString();\n\tpublic String getValue();\n\tpublic String getKey();\n\tpublic String getValue(String key);\n\tpublic LdapRdn immutableLdapRdn();\n\n}\n\nclass LdapRdnTest {\n\n    @Test\n    public void verifyThatHashcodeDisregardsOrder_Ldap260() throws Exception {\n", "reference": "        LdapRdn rdn1 = new LdapRdn(\"cn=john doe+sn=doe\");\n        LdapRdn rdn2 = new LdapRdn(\"sn=doe+cn=john doe\");\n\n        assertThat(rdn2.hashCode()).as(\"Should be equal\").isEqualTo(rdn1.hashCode());\n    }\n\n}", "prediction": "        LdapRdn rdn1 = new LdapRdn(\"cn=foo\");\n        LdapRdn rdn2 = new LdapRdn(\"cn=foo\");\n        assertEquals(rdn1.hashCode(), rdn2.hashCode());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "11334016_0", "part": [1, 1], "seq": [1, 1], "prompt": "class CommandInterpreter {\n\n\tpublic ProxyCommand interpretCommand(ChannelBuffer buffer) throws Exception {\n\t\treturn this.interpretCommand(new ChannelBufferInputStream(buffer), false);\n\t}\n\n\tpublic ProxyCommand readCommand(InputStream inputStream);\n\tpublic ProxyCommand readCommand(MessageEvent event);\n\tpublic void writeCommandExecutionResponse(ChannelHandlerContext ctx, ChannelEvent event, TaskResult result);\n\tpublic void writeCommandExecutionResponse(OutputStream outputStream, TaskResult result);\n\tprivate ProxyCommand interpretCommand(InputStream inputStream, boolean isFramedTransport);\n\tprivate int getNextCommandFragmentPosition(byte[] arr, int fragmentStart, int lastPos, byte delim);\n\n    private CommandInterpreter commandInterpreter;\n\n}\n\nclass CommandInterpreterTest {\n\n    private CommandInterpreter commandInterpreter;\n\n    @Test\n    public void testInterpretCommand() {\n", "reference": "\n        CommandInterpreter.ProxyCommand command;\n\n        // just command\n        command = getCommand(\"testCommand\\n\");\n        assertTrue(\"Command parsing failed\",command != null && command.getReadFailure() == null);\n        assertTrue(\"Parsed command mismatch: \"+command.getCommand(), \"testCommand\".equals(command.getCommand()));\n        assertTrue(\"Command parameters not empty\", command.getCommandParams().isEmpty());\n        assertTrue(\"Command data not empty\", command.getCommandData() == null);\n\n        // command + params\n        command = getCommand(\"testCommand p1=v1 p2=v2\\n\");\n        assertTrue(\"Command parsing failed\",command != null && command.getReadFailure() == null);\n        assertTrue(\"Parsed command mismatch: \"+command.getCommand(), \"testCommand\".equals(command.getCommand()));\n        assertTrue(\"Command parameters mismatch: \"+command.getCommandParams().size(), command.getCommandParams().size() == 2);\n        assertTrue(\"Command data not empty\", command.getCommandData() == null);\n\n        // command + params + different delim\n        command = getCommand(\"#testCommand#p1=v1#p2=v2\\n\");\n        assertTrue(\"Command parsing failed\",command != null && command.getReadFailure() == null);\n        assertTrue(\"Parsed command mismatch: \"+command.getCommand(), \"testCommand\".equals(command.getCommand()));\n        assertTrue(\"Command parameters mismatch: \"+command.getCommandParams().size(), command.getCommandParams().size() == 2);\n        assertTrue(\"Command data not empty\", command.getCommandData() == null);\n\n        // command + params + data\n        command = getCommand(\"testCommand p1=v1 p2=v2 8\\ntestData\");\n        assertTrue(\"Command parsing failed\",command != null && command.getReadFailure() == null);\n        assertTrue(\"Parsed command mismatch: \"+command.getCommand(), \"testCommand\".equals(command.getCommand()));\n        assertTrue(\"Command parameters mismatch: \"+command.getCommandParams().size(), command.getCommandParams().size() == 2);\n        assertTrue(\"Command data mismatch: \"+command.getCommandData(), \"testData\".equals(new String(command.getCommandData())));\n\n        // incorrect command - no newline\n        command = getCommand(\"testCommand p1=v1 p2=v2\");\n        assertTrue(\"Command parsing passed (which should not)\", command != null && command.getReadFailure() != null);\n\n        // incorrect command - data size mismatch\n        command = getCommand(\"testCommand p1=v1 p2=v2 10\\ntestData\");\n        assertTrue(\"Command parsing passed (which should not)\", command != null && command.getReadFailure() != null);\n\n    }\n\n}", "prediction": "        ProxyCommand command = commandInterpreter.interpretCommand(new ChannelBufferInputStream(\n                ChannelBuffers.wrappedBuffer(new byte[] { 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "11362688_0", "part": [1, 1], "seq": [1, 1], "prompt": "class ProfileCheck implements Command<String, Object, ProfileContext> {\n\n    public Processing execute(ProfileContext context) {\n        Profile profile = context.getProfile();\n\n        if (null == profile) {\n            context.setProfile(newProfile(context));\n        }\n        return Processing.CONTINUE;\n    }\n\n    public Profile newProfile(ProfileContext context);\n\n}\n\nclass ProfileCheckTest {\n\n    @Test\n    public void testProfileCheckNeed() {\n", "reference": "\n        ProfileContext context = new ProfileContext();\n        Command<String, Object, ProfileContext> command = new ProfileCheck();\n\n        command.execute(context);\n\n        Profile profile = context.getProfile();\n        assertNotNull(\"Missing org.apache.commons.chain2.cookbook.profile.Profile\", profile);\n    }\n\n}", "prediction": "        ProfileCheck check = new ProfileCheck() {\n            public Profile newProfile(ProfileContext context) {\n                return new Profile();\n            }\n        };\n\n        ProfileContext context = new ProfileContext();\n        Processing processing = check.execute(context);\n        assertEquals(Processing.CONTINUE, processing);\n        assertNotNull(context.getProfile());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "11383343_0", "part": [1, 1], "seq": [1, 1], "prompt": "class MyAction extends ActionSupport {\n\n    public String view() {\n        id = \"11\";\n        name = \"test-11\";\n        return SUCCESS;\n    }\n\n    public String getId();\n    public void setId(String id);\n    public String getName();\n    public void setName(String name);\n    public String save();\n\n    public static final Logger LOG;\n\n}\n\nclass TestMyAction extends ActionSupport {\n\n    public static final Logger LOG;\n\n    @Test\n    public void testView() throws Exception {\n", "reference": "        ActionProxy proxy = getActionProxy(\"/view\");\n//        actions.MyAction myAct = (actions.MyAction) proxy.getAction();\n        String result = proxy.execute();\n        assertEquals(\"success\", result);\n\n//        System.out.println(ToStringBuilder.reflectionToString(response));\n        System.out.println(response.getContentAsString());\n//        request.setParameter(\"id\", \"1\");\n//        request.setParameter(\"name\", \"Test Desc\");\n    }\n\n}", "prediction": "       MyAction action = new MyAction();\n        action.setId(\"11\");\n        action.setName(\"test-11\");\n        String result = action.view();\n        assertEquals(SUCCESS, result);\n        assertEquals(\"11\", action.getId());\n        assertEquals(\"test-11\", action.getName());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "11799031_108", "part": [1, 1], "seq": [1, 1], "prompt": "class EmailHandler {\n\n\tpublic static void sendMessage(EmailMessage message) throws AddressException, MessagingException {\n\t\tProperties properties = System.getProperties();\n\n                properties.put(\"mail.smtp.host\", AppConstant.EMAIL_HOST.getValue());\n                properties.put(\"mail.smtp.port\", AppConstant.EMAIL_PORT.getValue());\n\n\t\tSession session = Session.getInstance(properties, null);\n\t\tsession.setDebug(true);\n\n\t\tMessage msg = new MimeMessage(session);\n                \n\t\tInternetAddress[] bccList = new InternetAddress[message.getBcc().size()];\n\t\tfor (int counter = 0;counter < message.getBcc().size();counter++)  {\n\t\t\tInternetAddress email = new InternetAddress();\n\t\t\temail.setAddress(message.getBcc().get(counter));\n\t\t\tbccList[counter] = email;\n\t\t}\n\n\t\tInternetAddress[] ccList = new InternetAddress[message.getCc().size()];\n\t\tfor (int counter = 0;counter < message.getCc().size();counter++)  {\n\t\t\tInternetAddress email = new InternetAddress();\n\t\t\temail.setAddress(message.getCc().get(counter));\n\t\t\tccList[counter] = email;\n\t\t}\n\n\t\tmsg.setRecipient(Message.RecipientType.TO, new InternetAddress(message.getTo()));\n\t\tif (bccList.length > 0) {\n\t\t\tmsg.setRecipients(Message.RecipientType.BCC, bccList);\n\t\t}\n\t\tif (ccList.length > 0) {\n\t\t\tmsg.setRecipients(Message.RecipientType.CC, ccList);\n\t\t}\n\t\tmsg.setFrom(new InternetAddress(message.getFrom()));\n\t\tmsg.setSubject(message.getSubject());\n\t\tmsg.setContent(message.getContent(), \"text/plain\");\n                msg.setReplyTo(message.getReplyTo());\n\t\t\n                Transport.send(msg);\n\t\tlog.info(new StringBuilder(\"Sent E-Mail From: \")\n                        .append(message.getFrom())\n                        .append(\" To: \")\n                        .append(message.getTo())\n                        .append(\" Content: \" )\n                        .append(message.getContent()).toString()\n                        );\n\t}\n\n    private static org.slf4j.Logger log;\n\n}\n\nclass EmailHandlerTest {\n\n    private static org.slf4j.Logger log;\n\n    @Test\n    @Ignore\n    public void testSendMessageWithBcc() throws Exception {\n", "reference": "        List<String> bcc = new ArrayList<String>();\n        bcc.add(\"test@test.ing.gov\");\n        bcc.add(\"test@test.ing.gov\");\n        EmailMessage message = new EmailMessage(\"test@test.doesnt.exist.gov\", \"test@testing.purposes.on.ly.gov\", bcc, bcc, \"Test\", \"Test\");\n\n        try {\n            EmailHandler.sendMessage(message);\n        } catch (Exception e) {\n            assert(false);\n        }\n\n        assert(true);\n    }\n\n}", "prediction": "        EmailMessage message = new EmailMessage();\n        message.setFrom(\"test@test.com\");\n        message.setTo(\"test@test.com\");\n        message.setSubject(\"Test\");\n        message.setContent(\"Test\");\n        message.getBcc().add(\"test@test.com\");\n        EmailHandler.sendMessage(message);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "11845993_155", "part": [1, 1], "seq": [1, 1], "prompt": "class Stagemonitor {\n\n\t@Deprecated\n\tpublic static void reset() {\n\t\treset(null);\n\t}\n\n\tprivate  Stagemonitor();\n\n\tpublic static synchronized void init();\n\tprivate static void startMonitoring(MeasurementSession measurementSession);\n\tprivate static void doStartMonitoring();\n\tprivate static void start();\n\tprivate static void logStatus();\n\tprivate static String getJvmAndOsVersionString();\n\tprivate static void initializePlugins();\n\tstatic void initializePluginsInOrder(Collection<String> disabledPlugins, Iterable<StagemonitorPlugin> plugins);\n\tprivate static Set<StagemonitorPlugin> getPluginsToInit(Collection<String> disabledPlugins, Iterable<StagemonitorPlugin> plugins);\n\tprivate static void initializePlugin(final StagemonitorPlugin stagemonitorPlugin);\n\tpublic static synchronized void shutDown();\n\t@Deprecated public static MetricRegistry getMetricRegistry();\n\tpublic static Metric2Registry getMetric2Registry();\n\tpublic static HealthCheckRegistry getHealthCheckRegistry();\n\tpublic static ConfigurationRegistry getConfiguration();\n\tpublic static T getPlugin(Class<T> plugin);\n\t@Deprecated public static T getConfiguration(Class<T> plugin);\n\tstatic void setConfiguration(ConfigurationRegistry configuration);\n\tpublic static MeasurementSession getMeasurementSession();\n\tpublic static boolean isStarted();\n\tstatic boolean isDisabled();\n\tstatic void setLogger(Logger logger);\n\tpublic static List<String> getPathsOfWidgetTabPlugins();\n\tpublic static List<String> getPathsOfWidgetMetricTabPlugins();\n\t@Deprecated public static void reset(MeasurementSession measurementSession);\n\tprivate static void reloadPluginsAndConfiguration();\n\n\tprivate static ConfigurationRegistry originalConfiguration;\n\tprivate final HealthCheckRegistry healthCheckRegistry;\n\tprivate ConfigurationRegistry configuration;\n\tprivate CorePlugin corePlugin;\n\n}\n\nclass StagemonitorTest {\n\n\tprivate static ConfigurationRegistry originalConfiguration;\n\tprivate final HealthCheckRegistry healthCheckRegistry;\n\tprivate ConfigurationRegistry configuration;\n\tprivate CorePlugin corePlugin;\n\n\t@Test\n\tpublic void testDisabledPlugin() throws Exception {\n", "reference": "\t\twhen(corePlugin.isStagemonitorActive()).thenReturn(true);\n\t\twhen(corePlugin.getDisabledPlugins()).thenReturn(Collections.singletonList(\"TestExceptionPlugin\"));\n\n\t\tStagemonitor.reset(new MeasurementSession(\"StagemonitorTest\", \"testHost\", \"testInstance\"));\n\n\t\tassertThat(healthCheckRegistry.runHealthCheck(\"TestPlugin\").isHealthy()).isTrue();\n\t\tassertThat(healthCheckRegistry.runHealthCheck(\"TestExceptionPlugin\").isHealthy()).isFalse();\n\t\tassertThat(healthCheckRegistry.runHealthCheck(\"TestExceptionPlugin\").getMessage()).isEqualTo(\"disabled via configuration\");\n\t}\n\n}", "prediction": "\t\tStagemonitor.init();\n\t\tStagemonitor.getConfiguration(CorePlugin.class).setDisabledPlugins(Arrays.asList(\"stagemonitor.core.metrics.business-transaction-metrics\"));\n\t\tStagemonitor.getConfiguration(CorePlugin.class).setDisabledPlugins(Arrays.asList(\"stagemonitor.core.metrics.business-transaction-metrics\"));\n\t\tStagemonitor.getConfiguration(CorePlugin.class).setDisabledPlugins(Arrays.asList(\"stagemonitor.core.metrics.business-transaction-metrics\"));\n\t\tStagemonitor.getConfiguration(CorePlugin.class).setDisabledPlugins(Arrays.asList(\"stagemonitor.core.metrics.business-transaction-metrics\"));\n\t\tStagemonitor.getConfiguration(CorePlugin.class).setDisabledPlugins(Arrays.asList(\"stagemonitor.core.metrics.business-transaction-metrics\"));\n\t\tStagemonitor.getConfiguration(CorePlugin.class).setDisabledPlugins(Arrays.asList(\"stagemonitor.core.metrics.business-transaction-metrics\"));\n\t\tStagemonitor.getConfiguration(CorePlugin.class).setDisabledPlugins(Arrays.asList(\"stagemonitor.core.metrics.business-transaction-metrics\"));\n\t\tStagemonitor.getConfiguration(CorePlugin.class).setDisabledPlugins(Arrays.asList(\"stagemonitor.core.metrics.business-transaction-metrics\"));\n\t\tStagemonitor.getConfiguration(CorePlugin.class).setDisabledPlugins(Arrays.asList(\"stagemonitor.core.metrics.business-transaction-metrics\"));\n\t\tStagemonitor.getConfiguration(CorePlugin.class).setDisabledPlugins(Arrays.asList(\"stagemonitor.core.metrics.business-transaction-metrics\"));\n\t\tStagemonitor.getConfiguration(CorePlugin.class).setDisabledPlugins(Arrays.asList(\"stagemonitor.core.metrics.business-transaction-metrics\"));\n\t\tStagemonitor.getConfiguration(CorePlugin.class).setDisabledPlugins(Arrays.asList(\"stagemonitor.core.metrics.business-transaction-metrics\"));\n\t\tStagemonitor.getConfiguration(CorePlugin.class).setDisabledPlugins(Arrays.asList(\"stagemonitor.core.metrics.business-transaction-metrics\"));\n\t\tStagemonitor.getConfiguration(CorePlugin.class).setDisabledPlugins(Arrays.asList(\"stagemonitor.core.metrics.business-transaction-metrics\"));\n\t\tStagemonitor.getConfiguration(CorePlugin.class).setDisabledPlugins(Arrays.asList(\"stagemonitor.core.metrics.business-transaction-metrics\"));\n\t\tStagemonitor.getConfiguration(CorePlugin.class).setDisabledPlugins(Arrays.asList(\"stagemonitor.core.metrics.business-transaction-metrics\"));\n\t\tStagemonitor.getConfiguration(CorePlugin.class).setDisabledPlugins(Arrays.asList(\"stagemonitor.core.metrics.business-transaction-metrics\"));\n\t\tStagemonitor.getConfiguration(CorePlugin.class).setDisabledPlugins(Arrays.asList(\"stagemonitor.core.metrics.business-transaction-metrics\"));\n\t\tStagemonitor.getConfiguration(CorePlugin.class).setDisabledPlugins(Arrays.asList(\"stagemonitor.core.metrics.business-transaction-metrics\"));\n\t\tStagemonitor.getConfiguration(CorePlugin.class).setDisabledPlugins(Arrays.asList(\"stagemonitor.core.metrics.business-transaction-metrics\"));\n\t\tStagemonitor.getConfiguration(CorePlugin.class).setDisabledPlugins(Arrays.asList(\"stagemonitor.core.metrics.business-transaction-metrics\"));\n\t\tStagemonitor.getConfiguration(CorePlugin.class).setDisabledPlugins(Arrays.asList(\"stagemonitor.core.metrics.business-transaction-metrics\"));\n\t\tStagemonitor.getConfiguration(CorePlugin.class).setDisabledPlugins(Arrays.asList(\"stagemonitor.core.metrics.business-transaction-metrics\"));\n\t\tStagemonitor.getConfiguration(CorePlugin.class).setDisabledPlugins(Arrays.asList(\"stagemonitor.core.metrics.business-transaction-metrics\"));\n\t\tStagemonitor.getConfiguration(CorePlugin.class).setDisabledPlugins(Arrays.asList(\"stagemonitor.core.metrics.business-transaction-metrics\"));\n\t\tStagemonitor.getConfiguration(CorePlugin.class).setDisabledPlugins(Arrays.asList(\"stagemonitor.core.metrics.business-transaction-metrics\"));\n\t\tStagemonitor.getConfiguration(CorePlugin.class).setDisabledPlugins(Arrays.asList(\"stagemonitor.core.metrics.business-transaction-metrics\"));\n\t\tStagemonitor.getConfiguration(CorePlugin.class).setDisabledPlugins(Arrays.asList(\"stagemonitor.core.metrics.business-transaction-metrics\"));\n\t\tStagemonitor.getConfiguration(CorePlugin.class).setDisabledPlugins(Arrays.asList(\"stagemonitor.core.metrics.business-transaction-metrics\"));\n\t\tStagemonitor.getConfiguration(CorePlugin.class).setDisabledPlugins(Arrays.asList(\"stagemonitor.core.metrics.business-transaction-metrics\"));\n\t\tStagemonitor.getConfiguration(CorePlugin.class).setDisabledPlugins(Arrays.asList(\"stagemonitor.core.metrics.bus", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "11919447_1", "part": [1, 1], "seq": [1, 1], "prompt": "class MimeTypeToExtensionsUtil {\n\n    public static String getExtension(final String mimeType)\n    {\n        if (MIME_TYPES_EXTENSIONS.containsKey(mimeType))\n        {\n            return MIME_TYPES_EXTENSIONS.get(mimeType);\n        }\n        return mimeType.substring(mimeType.indexOf(\"/\") + 1);\n    }\n\n}\n\nclass MimeTypeToExtensionsUtilTest {\n\n    @Test\n    public void mapApplicationZipToZip()\n    {\n", "reference": "        String extension = MimeTypeToExtensionsUtil.getExtension(\"application/zip\");\n        Assert.assertEquals(\"zip\", extension);\n    }\n\n}", "prediction": "        assertEquals(\"zip\", MimeTypeToExtensionsUtil.getExtension(\"application/zip\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "11985762_9", "part": [1, 1], "seq": [1, 1], "prompt": "class ConnectionDescriptor {\n\n    public static ConnectionDescriptor makeConnDesc(String address) {\n        if (address == null || address.trim().length() == 0) {\n            throw new IllegalArgumentException(String.format(ERR_MSG, \"The given address is empty\"));\n        }\n\n        // address used to look like <host>:<port>. now that we switched to an\n        // url-like syntax, we handle those legacy adresses like tcp:// ones\n        address = address.replaceFirst(\"^tcp://\", \"\");\n\n        if (address.startsWith(\"unix://\")) {\n            final String path = address.substring(\"unix://\".length()).trim();\n            // check if the file name is valid\n            if (path.isEmpty()) {\n                throw new IllegalArgumentException(\n                        \"Unix socket file name is empty.\");\n            }\n            final File f = new File(path);\n            if (!f.getAbsolutePath().matches(\"^[^*&%\\\\s]+$\")) {\n                throw new IllegalArgumentException(String.format(ERR_MSG,\"Not a regular file name : \"\n                        + f.getAbsolutePath()));\n            }\n            return new UnixSocketConnectionDescriptor(path);\n        }\n\n        final Matcher ipv4Matcher = PATTERN_HOSTNAME_PORT.matcher(address);\n        final Matcher ipv6Matcher = PATTERN_IPV6_PORT.matcher(address);\n        if (ipv4Matcher.matches()) {\n            try {\n                final InetAddress addr = InetAddress.getByName(ipv4Matcher\n                        .group(1));\n                final int port = Integer.parseInt(ipv4Matcher.group(2));\n                return new TcpConnectionDescriptor(addr, port);\n            }\n            catch (final UnknownHostException e) {\n                throw new IllegalArgumentException(e);\n            }\n        }\n        else if (ipv6Matcher.matches()) {\n            try {\n                final InetAddress addr = InetAddress.getByName(ipv6Matcher\n                        .group(1));\n                final int port = Integer.parseInt(ipv6Matcher.group(2));\n                return new TcpConnectionDescriptor(addr, port);\n            }\n            catch (final UnknownHostException e) {\n                throw new IllegalArgumentException(e);\n            }\n        }\n        else {\n            throw new IllegalArgumentException(String.format(ERR_MSG, \"Not a valid address\"));\n        }\n    }\n\n    public abstract ISocket makeSocket();\n\n}\n\nclass ConnectionDescriptorTest {\n\n    @Test\n    public void testMakeConnDesc_unixSock() {\n", "reference": "        final ConnectionDescriptor desc = ConnectionDescriptor\n                .makeConnDesc(\"unix://var/run/application.sock\");\n        Assert.assertTrue(desc instanceof UnixSocketConnectionDescriptor);\n    }\n\n}", "prediction": "        final ConnectionDescriptor cd = ConnectionDescriptor.makeConnDesc(\"unix:///tmp/foo\");\n        assertTrue(cd instanceof UnixSocketConnectionDescriptor);\n        assertEquals(\"/tmp/foo\", ((UnixSocketConnectionDescriptor) cd).getPath());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "12504536_4", "part": [1, 1], "seq": [1, 1], "prompt": "class BallExecutorDelivery implements BallResponseDelivery {\n\n    @Override\n    public void postEmptyIntermediateResponse(BallRequest request, BallResponse.ResponseSource responseSource) {\n        request.addMarker(MARKER_POST_EMPTY_INTERMEDIATE_RESPONSE);\n        mResponsePoster.execute(new EmptyIntermediateDeliveryRunnable(request, responseSource, mNetworkQueue));\n    }\n\n    public  BallExecutorDelivery(final Handler handler, PriorityBlockingQueue<BallRequest> networkQueue);\n    public  BallExecutorDelivery(Executor executor);\n\n    @Override public void postResponse(BallRequest<?> request, BallResponse<?> response);\n    @Override public void postResponseAndForwardToNetwork(BallRequest<?> request, BallResponse<?> response);\n    @Override public void postError(BallRequest<?> request, VolleyError error);\n\n    private BallResponseDelivery mResponseDelivery;\n    private BallRequest mRequest;\n    private BallResponse mResponse;\n\n}\n\nclass BallExecutorDeliveryTest {\n\n    private BallResponseDelivery mResponseDelivery;\n    private BallRequest mRequest;\n    private BallResponse mResponse;\n\n    @Test\n    public void shouldIgnoreEmptyIntermediateResponseWhenFinalIsNotDelivered() {\n", "reference": "        when(mRequest.isFinished()).thenReturn(false);\n        when(mRequest.isIntermediateResponseDelivered()).thenReturn(false);\n        when(mRequest.isFinalResponseDelivered()).thenReturn(false);\n\n        mResponseDelivery.postEmptyIntermediateResponse(mRequest, BallResponse.ResponseSource.LOCAL);\n\n        verify(mRequest).setIntermediateResponseDelivered(true);\n        verify(mRequest, never()).deliverError(any(VolleyError.class));\n        verify(mRequest, never()).finish(anyString());\n    }\n\n}", "prediction": "        mResponseDelivery.postEmptyIntermediateResponse(mRequest, BallResponse.ResponseSource.NETWORK);\n        verify(mResponsePoster, never()).execute(any(Runnable.class));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "12652963_1", "part": [1, 1], "seq": [1, 1], "prompt": "class ApacheHttpdLogfileInputFormat extends\n        FileInputFormat<LongWritable, ParsedRecord> {\n\n    public ApacheHttpdLogfileRecordReader createRecordReader() {\n        try {\n            return new ApacheHttpdLogfileRecordReader(getLogFormat(), getRequestedFields(), getTypeRemappings(), getAdditionalDissectors());\n        } catch (IOException e) {\n            return null;\n        }\n    }\n\n    public  ApacheHttpdLogfileInputFormat();\n    public  ApacheHttpdLogfileInputFormat(\n            String logformat,\n            Collection<String> requestedFields,\n            Map<String, Set<String>> typeRemappings,\n            List<Dissector> additionalDissectors);\n\n    public List<String> listPossibleFields(String logformat);\n    public static List<String> listPossibleFields(String logformat, Map<String, Set<String>> typeRemappings, List<Dissector> additionalDissectors);\n    public String getLogFormat();\n    public Set<String> getRequestedFields();\n    public Map<String, Set<String>> getTypeRemappings();\n    public List<Dissector> getAdditionalDissectors();\n    public ApacheHttpdLogfileRecordReader getRecordReader();\n    @Override public RecordReader<LongWritable, ParsedRecord> createRecordReader(\n            final InputSplit split, final TaskAttemptContext context);\n    @Override protected boolean isSplitable(JobContext context, Path file);\n    public void setTypeRemappings(Map<String, Set<String>> newTypeRemappings);\n\n     String logformat;\n\n}\n\nclass TestApacheHttpdLogfileInputFormat {\n\n     String logformat;\n\n    @Test\n    public void checkAllOutputTypes() throws IOException, InterruptedException {\n", "reference": "        Configuration conf = new Configuration(false);\n        conf.set(\"fs.default.name\", \"file:///\");\n\n        // A ',' separated list of fields\n        List<String> fields = Arrays.asList(\n                \"ANY:any\",\n                \"ANY:any\",\n                \"ANY:any\",\n                \"STRING:string\",\n                \"STRING:string\",\n                \"STRING:string\",\n                \"INT:int\",\n                \"INT:int\",\n                \"INT:int\",\n                \"LONG:long\",\n                \"LONG:long\",\n                \"LONG:long\",\n                \"FLOAT:float\",\n                \"FLOAT:float\",\n                \"FLOAT:float\",\n                \"DOUBLE:double\",\n                \"DOUBLE:double\",\n                \"DOUBLE:double\");\n\n        File testFile = new File(\"src/test/resources/access.log\");\n        Path path = new Path(testFile.getAbsoluteFile().toURI());\n        FileSplit split = new FileSplit(path, 0, testFile.length(), null);\n\n        Map<String, Set<String>> typeRemappings = new HashMap<>();\n        List<Dissector> dissectors = new ArrayList<>();\n        dissectors.add(new NormalValuesDissector(HttpdLogFormatDissector.INPUT_TYPE));\n\n        InputFormat inputFormat = new ApacheHttpdLogfileInputFormat(\n            logformat,\n            fields,\n            typeRemappings,\n            dissectors);\n        TaskAttemptContext context = new TaskAttemptContextImpl(conf, new TaskAttemptID());\n        RecordReader reader = inputFormat.createRecordReader(split, context);\n\n        reader.initialize(split, context);\n\n        assertTrue(reader.nextKeyValue());\n\n        Object value = reader.getCurrentValue();\n        if (value instanceof ParsedRecord) {\n            ParsedRecord record = (ParsedRecord)value;\n            assertEquals(\"42\",          record.getString(\"ANY:any\"));             // any_string\n            assertEquals(42L,           record.getLong(\"ANY:any\").longValue());   // any_long\n            assertEquals(42D,           record.getDouble(\"ANY:any\"), 0.1D);       // any_double\n            assertEquals(\"FortyTwo\",    record.getString(\"STRING:string\"));       // string_string\n            assertEquals(null,          record.getLong(\"STRING:string\"));         // string_long\n            assertEquals(null,          record.getDouble(\"STRING:string\"));       // string_double\n            assertEquals(\"42\",          record.getString(\"INT:int\"));             // int_string\n            assertEquals(42L,           record.getLong(\"INT:int\").longValue());   // int_long\n            assertEquals(null,          record.getDouble(\"INT:int\"));             // int_double\n            assertEquals(\"42\",          record.getString(\"LONG:long\"));           // long_string\n            assertEquals(42L,           record.getLong(\"LONG:long\").longValue()); // long_long\n            assertEquals(null,          record.getDouble(\"LONG:long\"));           // long_double\n            assertEquals(\"42.0\",        record.getString(\"FLOAT:float\"));         // float_string\n            assertEquals(null,          record.getLong(\"FLOAT:float\"));           // float_long\n            assertEquals(42D,           record.getDouble(\"FLOAT:float\"), 0.1D);   // float_double\n            assertEquals(\"42.0\",        record.getString(\"DOUBLE:double\"));       // double_string\n            assertEquals(null,          record.getLong(\"DOUBLE:double\"));         // double_long\n            assertEquals(42D,           record.getDouble(\"DOUBLE:double\"), 0.1D);  // double_double\n        } else {\n            fail(\"Wrong return class type\");\n        }\n    }\n\n}", "prediction": "        ApacheHttpdLogfileInputFormat format = new ApacheHttpdLogfileInputFormat();\n        format.setLogFormat(logformat);\n        format.setRequestedFields(new HashSet<String>(Arrays.asList(\"output\")));\n        format.setTypeRemappings(new HashMap<String, Set<String>>());\n        format.setAdditionalDissectors(new ArrayList<Dissector>());\n        Job job = new Job();\n        job.setInputFormatClass(ApacheHttpdLogfileInputFormat.class);\n        FileInputFormat.setInputPaths(job, new Path(getClass().getResource(\"/apache_combined.log\").getFile()));\n        InputSplit[] splits = format.getSplits(job);\n        assertEquals(1, splits.length);\n        RecordReader<LongWritable, ParsedRecord> reader = format.createRecordReader(splits[0], null);\n        reader.initialize(splits[0], null);\n        LongWritable key = new LongWritable();\n        ParsedRecord value = new ParsedRecord();\n        while (reader.next(key, value)) {\n            assertEquals(1, value.getValues().size());\n            assertEquals(\"output\", value.getValues().get(0).getField());\n        }\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "12666574_0", "part": [1, 1], "seq": [1, 1], "prompt": "class LsofParametersBuilder {\n\n    public String build(Preferences preferences) {\n        final StringBuilder sb1 = new StringBuilder(COMMAND);\n        final StringBuilder sb2 = new StringBuilder(); // Path\n        for (Filter tv : preferences.getFilters()) {\n            final String type = tv.getType();\n            final boolean isPathType = type.equals(PATH.getId());\n            getParameterType(type).appendParameter(isPathType ? sb2 : sb1, tv);\n        }\n        preferences.getOtherPreferences().toParameters(sb1);\n        if (sb2.length() > 0) sb1.append(\" --\").append(sb2);\n        return sb1.toString();\n    }\n\n    private LsofParametersBuilder _builder;\n\n}\n\nclass LsofParametersBuilderTest  {\n\n    private LsofParametersBuilder _builder;\n\n    @Test\n    public void createParametersForDefaultQueryPreferences() {\n", "reference": "        checkLsofParameters(\"lsof -F -T +c0 -o -n -P\", _builder.build(Preferences.from(\"dummyQuery\")));\n    }\n\n}", "prediction": "        final String expected = \"lsof -i -n -P -a -u -F\";\n        final String actual = _builder.build(new DefaultQueryPreferences());\n        assertEquals(expected, actual);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "12849994_97", "part": [1, 1], "seq": [1, 1], "prompt": "class RedisCache extends AbstractCache<K, V> {\n\n  @Override\n  public long size() {\n    try {\n      return client.dbsize();\n    } catch (ConnectionException|IOException e) {\n      throw new RedisCacheException(e);\n    }\n  }\n\n  public  RedisCache(final String name, final CacheLoader<K, V> cacheLoader,\n      final EvictionListener<K, V> evictionListener,\n      Serializer<Object> serializer, Client client);\n\n  @Override public void put(final K key, final V value);\n  @Override public void put(final K key, final V value, final TimeUnit timeUnit, final long duration);\n  @Override @SuppressWarnings(\"unchecked\") public V get(final K key);\n  @Override @SuppressWarnings(\"unchecked\") public V invalidate(final K key);\n  @Override public boolean contains(final K key);\n  @Override public void clear();\n  @Override public CacheStats stats();\n\n  @Mock Client client;\n   Serializer<Object> serializer;\n  @Mock CacheLoader<Integer, Integer> cacheLoader;\n  @Mock EvictionListener<Integer, Integer> evictionListener;\n   RedisCache<Integer, Integer> cache;\n\n}\n\nclass RedisCacheTest {\n\n  @Mock Client client;\n   Serializer<Object> serializer;\n  @Mock CacheLoader<Integer, Integer> cacheLoader;\n  @Mock EvictionListener<Integer, Integer> evictionListener;\n   RedisCache<Integer, Integer> cache;\n\n  @Test\n  public void size() throws ConnectionException, IOException {\n", "reference": "    int size = 3;\n    doReturn(size).when(client).dbsize();\n    long actualSize = cache.size();\n    assertEquals(size, actualSize);\n  }\n\n}", "prediction": "    when(client.dbsize()).thenReturn(10L);\n    assertEquals(10L, cache.size());\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "13218559_6", "part": [1, 1], "seq": [1, 1], "prompt": "class SpaceBattleSimulation {\n\n\tpublic static void engagement(Ship enemy, Ship friend){\n\t\twhile(!enemy.isDestroyed && friend.isDestroyed == false){\n\t\t\t//Friendly attacks enemy\n\t\t\tint friendAtkVal = friend.attack((Class<Ship>) enemy.getClass());\n\t\t\tenemy.attacked(friendAtkVal);\n\t\t\t\n\t\t\t//Enemy attacks Friendly\n\t\t\tint enemyAttackVal = enemy.attack((Class<Ship>) friend.getClass());\n\t\t\tfriend.attacked(enemyAttackVal);\n\t\t\t\n\t\t}\n\t}\n\n\tpublic static void main(String[] args);\n\tprotected static List<Ship> convertInputToList(String commaDelem);\n\tprotected static Ship mapAbbreviationToShip(String shipAbbreviation);\n\tprotected static boolean battle(List<Ship> friendly, List<Ship> enemy);\n\n}\n\nclass SpaceBattleSimulationTest {\n\n\t@Test\n\tpublic void fighterAttacksCruiser(){\n", "reference": "\t\tSpaceBattleSimulation sim = new SpaceBattleSimulation();\n\t\t//One fighter should do 200 dmg per round.\n\t\t//A Cruiser will do 1,000 dmg against a fighter.\n\t\t//A Cruiser with full health will destroy a fighter in 3 rounds\n\t\t\n\t\tFighter fighter = sim.new Fighter();\n\t\tCruiser cruiser = sim.new Cruiser();\n\t\t\n\t\tint startingHealth = cruiser.getHp();\n\t\t\n\t\tSpaceBattleSimulation.engagement(fighter, cruiser);\n\t\t\n\t\tint endingHealth = cruiser.getHp();\n\t\tAssert.assertEquals(600, (startingHealth - endingHealth));\n\t\t\n\t}\n\n}", "prediction": "\t\tShip fighter = new Fighter();\n\t\tShip cruiser = new Cruiser();\n\t\tint fighterAtkVal = fighter.attack((Class<Ship>) cruiser.getClass());\n\t\tassertEquals(1, fighterAtkVal);\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "13385254_1", "part": [1, 1], "seq": [1, 1], "prompt": "class CSVToARFFHeaderMapTask implements OptionHandler, Serializable {\n\n  public Instances getHeader() {\n\n    return makeStructure();\n  }\n\n  @Override public Enumeration<Option> listOptions();\n  @Override public void setOptions(String[] options);\n  @Override public String[] getOptions();\n  public void setTreatZerosAsMissing(boolean t);\n  public boolean getTreatZerosAsMissing();\n  public void setCompressionLevelForQuartileEstimation(double compression);\n  public double getCompressionLevelForQuartileEstimation();\n  public String compressionLevelForQuartileEstimationTipText();\n  public void setComputeQuartilesAsPartOfSummaryStats(boolean c);\n  public boolean getComputeQuartilesAsPartOfSummaryStats();\n  public String computeQuartilesAsPartOfSummaryStatsTipText();\n  public void setMissingValue(String value);\n  public String getMissingValue();\n  public String missingValueTipText();\n  public void setStringAttributes(String value);\n  public String getStringAttributes();\n  public String stringAttributesTipText();\n  public void setNominalAttributes(String value);\n  public String getNominalAttributes();\n  public String nominalAttributesTipText();\n  public void setDateFormat(String value);\n  public String getDateFormat();\n  public String dateFormatTipText();\n  public void setDateAttributes(String value);\n  public String getDateAttributes();\n  public String dateAttributesTipText();\n  public String enclosureCharactersTipText();\n  public void setEnclosureCharacters(String enclosure);\n  public String getEnclosureCharacters();\n  public void setFieldSeparator(String value);\n  public String getFieldSeparator();\n  public String fieldSeparatorTipText();\n  public String nominalDefaultLabelSpecsTipText();\n  public void setNominalDefaultLabelSpecs(Object[] specs);\n  public Object[] getNominalDefaultLabelSpecs();\n  public String nominalLabelSpecsTipText();\n  public void setNominalLabelSpecs(Object[] specs);\n  public Object[] getNominalLabelSpecs();\n  public void generateNames(int initial, int numAtts);\n  public void generateNames(int numAtts);\n  public void initParserOnly(List<String> attNames);\n  public String[] parseRowOnly(String row);\n  public void processRow(String row, List<String> attNames);\n  public static void updateSummaryStats(Map<String, Stats> summaryStats,\n    String attName, double value, String nominalLabel, boolean isNominal,\n    boolean isString,\n    boolean treatZeroAsMissing, boolean estimateQuantiles,\n    double quantileCompression);\n  public HeaderAndQuantileDataHolder getHeaderAndQuantileEstimators();\n  public boolean headerAvailableImmediately(int numFields,\n    List<String> attNames, StringBuffer problems);\n  public Instances getHeader(int numFields, List<String> attNames);\n  private void processRanges(int numFields, TYPE defaultType);\n  private void processNominalSpecs(int numFields);\n  protected Instances makeStructure();\n  public Instance makeInstance(Instances trainingHeader,\n    boolean setStringValues, String[] parsed);\n  public Instance makeInstance(Instances trainingHeader,\n    boolean setStringValues, String[] parsed, boolean sparse);\n  public String getDefaultValue(int attIndex);\n  public static List<String> instanceHeaderToAttributeNameList(Instances header);\n  public static void main(String[] args);\n\n  public static final String IRIS_HEADER;\n  public static final String IRIS;\n  public static final double TOL;\n\n}\n\nclass CSVToARFFHeaderMapTaskTest {\n\n  public static final String IRIS_HEADER;\n  public static final String IRIS;\n  public static final double TOL;\n\n  @Test\n  public void testGetHeaderWithoutProcessing() throws Exception {\n", "reference": "    // tests getting a header without any processing of incoming\n    // CSV data - i.e. all attributes are assumed to be numeric\n\n    CSVToARFFHeaderMapTask task = new CSVToARFFHeaderMapTask();\n    // task.setOptions(args);\n\n    Instances i = task.getHeader(10, null);\n    for (int j = 0; j < i.numAttributes(); j++) {\n      assertTrue(i.attribute(j).isNumeric());\n    }\n  }\n\n}", "prediction": "    CSVToARFFHeaderMapTask task = new CSVToARFFHeaderMapTask();\n    task.setHeader(IRIS_HEADER);\n    Instances header = task.getHeader();\n    assertEquals(5, header.numAttributes());\n    assertEquals(\"sepal length\", header.attribute(0).name());\n    assertEquals(\"sepal width\", header.attribute(1).name());\n    assertEquals(\"petal length\", header.attribute(2).name());\n    assertEquals(\"petal width\", header.attribute(3).name());\n    assertEquals(\"class\", header.attribute(4).name());\n    assertEquals(0, header.attribute(0).index());\n    assertEquals(1, header.attribute(1).index());\n    assertEquals(2, header.attribute(2).index());\n    assertEquals(3, header.attribute(3).index());\n    assertEquals(4, header.attribute(4).index());\n    assertEquals(Attribute.NOMINAL, header.attribute(4).type());\n    assertEquals(4, header.numInstances());\n    assertEquals(0.0, header.instance(0).value(0), TOL);\n    assertEquals(3.4, header.instance(1).value(0), TOL);\n    assertEquals(3.0, header.instance(2).value(0), TOL);\n    assertEquals(3.2, header.instance(3).value(0), TOL);\n    assertEquals(1.0, header.instance(0).value(1), TOL);\n    assertEquals(1.0, header.instance(1).value(1), TOL);\n    assertEquals(4.0, header.instance(2).value(1), TOL);\n    assertEquals(4.0, header.instance(3).value(1), TOL);\n    assertEquals(0.0, header.instance(0).value(2), TOL);\n    assertEquals(1.4, header.instance(1).value(2), TOL);\n    assertEquals(1.0, header.instance(2).value(2), TOL);\n    assertEquals(1.5, header.instance(3).value(2), TOL);\n    assertEquals(0.0, header.instance(0).value(3), TOL);\n    assertEquals(0.2, header.instance(1).value(3), TOL);\n    assertEquals(0.2, header.instance(2).value(3), TOL);\n    assertEquals(0.2, header.instance(3).value(3), TOL);\n    assertEquals(\"Iris-setosa\", header.instance(0).stringValue(4));\n    assertEquals(\"Iris-versicolor\", header.instance(1).stringValue(4));\n    assertEquals(\"Iris-versicolor\", header.instance(2).stringValue(4));\n    assertEquals(\"Iris-virginica\", header.instance(3).stringValue(4));\n  }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "13505122_6", "part": [1, 1], "seq": [1, 1], "prompt": "class ThreadsComponentFactory implements ComponentFactory {\n\n\t@Override\n\tpublic ProcessingItem createPi(Processor processor) {\n\t\treturn this.createPi(processor, 1);\n\t}\n\n\t@Override public ProcessingItem createPi(Processor processor, int paralellism);\n\t@Override public EntranceProcessingItem createEntrancePi(EntranceProcessor entranceProcessor);\n\t@Override public Stream createStream(IProcessingItem sourcePi);\n\t@Override public Topology createTopology(String topoName);\n\n\t@Tested private ThreadsComponentFactory factory;\n\t@Mocked private Processor processor;\n\t@Mocked private EntranceProcessor entranceProcessor;\n\tprivate final int parallelism;\n\tprivate final String topoName;\n\n}\n\nclass ThreadsComponentFactoryTest {\n\n\t@Tested private ThreadsComponentFactory factory;\n\t@Mocked private Processor processor;\n\t@Mocked private EntranceProcessor entranceProcessor;\n\tprivate final int parallelism;\n\tprivate final String topoName;\n\n\t@Test\n\tpublic void testCreatePiWithParallelism() {\n", "reference": "\t\tnew NonStrictExpectations() {\n\t\t\t{\n\t\t\t\tprocessor.newProcessor(processor);\n\t\t\t\tresult=processorReplica;\n\t\t\t}\n\t\t};\n\t\tProcessingItem pi = factory.createPi(processor,parallelism);\n\t\tassertNotNull(\"ProcessingItem created is null.\",pi);\n\t\tassertEquals(\"ProcessingItem created is not a ThreadsProcessingItem.\",ThreadsProcessingItem.class,pi.getClass());\n\t\tassertEquals(\"Parallelism of PI is not \",parallelism,pi.getParallelism(),0);\n\t}\n\n}", "prediction": "\t\tfactory.createPi(processor, parallelism);\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "13736359_36", "part": [1, 1], "seq": [1, 1], "prompt": "class DateRangeAndType {\n\n  public static DateRangeAndType fromString(final String dateRange) {\n    Preconditions.checkNotNull(dateRange, \"DateRange cannot be null.\");\n    Preconditions.checkArgument(!dateRange.isEmpty(), \"DateRange cannot be empty.\");\n\n    return dateRange.contains(\",\") ? parseCustomFormat(dateRange) : parseEnumFormat(dateRange);\n  }\n\n  private  DateRangeAndType(\n      LocalDate startDate, LocalDate endDate, ReportDefinitionDateRangeType type);\n\n  public String getStartDateStr();\n  public String getEndDateStr();\n  public String getTypeStr();\n  public LocalDate getStartDate();\n  public LocalDate getEndDate();\n  public ReportDefinitionDateRangeType getType();\n  public DateRange getDateRange();\n  public static DateRangeAndType fromValues(LocalDate startDate, LocalDate endDate,\n      ReportDefinitionDateRangeType type);\n  private static DateRangeAndType parseCustomFormat(final String dateRange);\n  private static DateRangeAndType parseEnumFormat(ReportDefinitionDateRangeType type);\n  private static DateRangeAndType parseEnumFormat(final String dateRange);\n\n  private LocalDate date;\n\n}\n\nclass DateRangeAndTypeTest {\n\n  private LocalDate date;\n\n  @Test(expected = IllegalArgumentException.class)\n  public void testEmptyRange() {\n", "reference": "    DateRangeAndType.fromString(\"\");\n  }\n\n}", "prediction": "    DateRangeAndType.fromString(\"\");\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "14109623_1", "part": [1, 1], "seq": [1, 1], "prompt": "class ConverterUtil {\n\n\tpublic static float convertCelsiusToFahrenheit(float celsius) {\n\t\treturn ((celsius * 9) / 5) + 32;\n\t}\n\n\tpublic static float convertFahrenheitToCelsius(float fahrenheit);\n\n}\n\nclass ConverterUtilTest {\n\n    @Test\n    public void testConvertCelsiusToFahrenheit() {\n", "reference": "        float actual = ConverterUtil.convertFahrenheitToCelsius(212);\n// expected value is 100\n        float expected = 100;\n// use this method because float is not precise\n        assertEquals(\"Conversion from celsius to fahrenheit failed\", expected,\n                actual, 0.001);\n    }\n\n}", "prediction": "\t\tassertEquals(32.0f, ConverterUtil.convertCelsiusToFahrenheit(0.0f), 0.001f);\n\t\tassertEquals(37.2f, ConverterUtil.convertCelsiusToFahrenheit(10.0f), 0.001f);\n\t\tassertEquals(41.6f, ConverterUtil.convertCelsiusToFahrenheit(20.0f), 0.001f);\n\t\tassertEquals(46.8f, ConverterUtil.convertCelsiusToFahrenheit(30.0f), 0.001f);\n\t\tassertEquals(52.0f, ConverterUtil.convertCelsiusToFahrenheit(40.0f), 0.001f);\n\t\tassertEquals(56.2f, ConverterUtil.convertCelsiusToFahrenheit(50.0f), 0.001f);\n\t\tassertEquals(60.4f, ConverterUtil.convertCelsiusToFahrenheit(60.0f), 0.001f);\n\t\tassertEquals(64.6f, ConverterUtil.convertCelsiusToFahrenheit(70.0f), 0.001f);\n\t\tassertEquals(68.8f, ConverterUtil.convertCelsiusToFahrenheit(80.0f), 0.001f);\n\t\tassertEquals(73.0f, ConverterUtil.convertCelsiusToFahrenheit(90.0f), 0.001f);\n\t\tassertEquals(77.2f, ConverterUtil.convertCelsiusToFahrenheit(100.0f), 0.001f);\n\t}", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "14117014_2", "part": [1, 1], "seq": [1, 1], "prompt": "class SetPropertyMethod extends AbstractPropertyMethod {\n\n    @Override\n    public <T extends Annotation> T getAnnotation(Class<T> type) {\n        if (super.getAnnotation(type) != null) {\n            reportInvalidAnnotationLocation();\n        }\n        return getter.getAnnotation(type);\n    }\n\n    public  SetPropertyMethod(Method setter, GetPropertyMethod getter, String name, Class<?> type, Type genericType);\n\n    @Override public T getByMetaAnnotation(Class<M> type);\n    @Override public Annotation[] getAnnotations();\n    private T reportInvalidAnnotationLocation();\n\n    private SetPropertyMethod setPropertyMethod;\n    private SetPropertyMethod setInvalidPropertyMethod;\n\n}\n\nclass SetPropertyMethodTest {\n\n    private SetPropertyMethod setPropertyMethod;\n    private SetPropertyMethod setInvalidPropertyMethod;\n\n    @Test\n    public void getAnnotation() {\n", "reference": "        TestAnnotation annotation = setPropertyMethod.getAnnotation(TestAnnotation.class);\n        assertThat(annotation, notNullValue());\n    }\n\n}", "prediction": "        assertThat(setPropertyMethod.getAnnotation(TestAnnotation.class)).isNotNull();\n        assertThat(setInvalidPropertyMethod.getAnnotation(TestAnnotation.class)).isNull();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "14247776_14", "part": [1, 1], "seq": [1, 1], "prompt": "class Presenter {\n\n  public final void takeView(V view) {\n    if (view == null) throw new NullPointerException(\"new view must not be null\");\n\n    if (this.view != view) {\n      if (this.view != null) dropView(this.view);\n\n      this.view = view;\n      extractBundleService(view).register(registration);\n    }\n  }\n\n  public void dropView(V view);\n  protected String getMortarBundleKey();\n  protected abstract BundleService extractBundleService(V view);\n  protected final V getView();\n  protected final boolean hasView();\n  protected void onEnterScope(MortarScope scope);\n  protected void onLoad(Bundle savedInstanceState);\n  protected void onSave(Bundle outState);\n  protected void onExitScope();\n\n   MortarScope root;\n   MortarScope activityScope;\n\n}\n\nclass PresenterTest {\n\n   MortarScope root;\n   MortarScope activityScope;\n\n  @Test public void onRegisteredIsFired() {\n", "reference": "    SimplePresenter presenter = new SimplePresenter();\n    SomeView viewOne = new SomeView();\n\n    presenter.takeView(viewOne);\n    assertThat(presenter.registered).isSameAs(activityScope);\n  }\n\n}", "prediction": "    final boolean[] fired = new boolean[1];\n    final BundleService service = new BundleService() {\n      @Override public void register(Registration registration) {\n        fired[0] = true;\n      }\n    };\n    Presenter<View> presenter = new Presenter<View>() {\n      @Override protected BundleService extractBundleService(View view) {\n        return service;\n      }\n    };\n    presenter.takeView(mock(View.class));\n    assertTrue(fired[0]);\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "14505280_5", "part": [1, 1], "seq": [1, 1], "prompt": "class SimpleTmsUrlBuilder implements TileUrlBuilder {\n\n\t@Override\n\tpublic String buildUrl(TileCode tileCode, String baseTmsUrl) {\n\t\tStringBuilder builder = new StringBuilder(baseTmsUrl);\n\t\tif (!baseTmsUrl.endsWith(\"/\")) {\n\t\t\tbuilder.append(\"/\");\n\t\t}\n\t\tbuilder.append(tileCode.getTileLevel());\n\t\tbuilder.append(\"/\");\n\t\tbuilder.append(tileCode.getX());\n\t\tbuilder.append(\"/\");\n\t\tbuilder.append(tileCode.getY());\n\t\tbuilder.append(extension);\n\t\treturn builder.toString();\n\t}\n\n\tpublic  SimpleTmsUrlBuilder(String extension);\n\n\tprivate static final String BASE_TMS_URL;\n\tprivate static final String EXTENSION;\n\tprivate static final String EXPECTED;\n\n}\n\nclass SimpleTmsUrlBuilderTest {\n\n\tprivate static final String BASE_TMS_URL;\n\tprivate static final String EXTENSION;\n\tprivate static final String EXPECTED;\n\n\t@Test\n\tpublic void testBuildUrl1() {\n", "reference": "\t\tTileUrlBuilder builder = new SimpleTmsUrlBuilder(EXTENSION);\n\t\tString url = builder.buildUrl(new TileCode(1, 2, 3), BASE_TMS_URL);\n\t\tAssert.assertEquals(EXPECTED, url);\n\t}\n\n}", "prediction": "\t\tTileCode tileCode = new TileCode(1, 1, 1);\n\t\tString url = new SimpleTmsUrlBuilder(EXTENSION).buildUrl(tileCode, BASE_TMS_URL);\n\t\tassertEquals(EXPECTED, url);\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "14858974_357", "part": [1, 1], "seq": [1, 1], "prompt": "class ArtifactHandler {\n\n    public List<String> getArtifactVersions(final String gavc) {\n        final DbArtifact artifact = getArtifact(gavc);\n        return repositoryHandler.getArtifactVersions(artifact);\n    }\n\n    public  ArtifactHandler(final RepositoryHandler repositoryHandler,\n                           final LicenseMatcher matcher);\n\n    public void store(final DbArtifact dbArtifact);\n    public void storeIfNew(final DbArtifact fromClient);\n    public void addLicense(final String gavc, final String licenseId);\n    public List<String> getArtifactGavcs(final FiltersHolder filters);\n    public List<String> getArtifactGroupIds(final FiltersHolder filters);\n    public String getArtifactLastVersion(final String gavc);\n    public DbArtifact getArtifact(final String gavc);\n    public DbArtifact getArtifactUsingSHA256(final String sha256);\n    public DbModule getModule(final DbArtifact dbArtifact);\n    public DbOrganization getOrganization(final DbArtifact dbArtifact);\n    public void updateDownLoadUrl(final String gavc, final String downLoadUrl);\n    public void updateProvider(final String gavc, final String provider);\n    public void deleteArtifact(final String gavc);\n    public void updateDoNotUse(final String gavc, final Boolean doNotUse);\n    public List<DbModule> getAncestors(final String gavc, final FiltersHolder filters);\n    public List<DbLicense> getArtifactLicenses(final String gavc, final FiltersHolder filters);\n    public void addLicenseToArtifact(final String gavc, final String licenseId);\n    public void removeLicenseFromArtifact(final String gavc, final String licenseId);\n    public List<DbArtifact> getArtifacts(final FiltersHolder filters);\n    public String getModuleJenkinsJobInfo(final DbArtifact dbArtifact);\n\n}\n\nclass ArtifactHandlerTest {\n\n    @Test\n    public void checkAvailableVersionsOfAnArtifactThatDoesNotExist(){\n", "reference": "        final DbArtifact artifact = new DbArtifact();\n        artifact.setArtifactId(\"test\");\n        artifact.setVersion(\"1.0.0-SNAPSHOT\");\n\n        final RepositoryHandler repositoryHandler = mock(RepositoryHandler.class);\n        final ArtifactHandler handler = new ArtifactHandler(repositoryHandler, mock(LicenseMatcher.class));\n        WebApplicationException exception = null;\n\n        try {\n            handler.getArtifactVersions(artifact.getGavc());\n        }catch (WebApplicationException e){\n            exception = e;\n        }\n\n        assertNotNull(exception);\n        assertEquals(Response.Status.NOT_FOUND.getStatusCode(), exception.getResponse().getStatus());\n    }\n\n}", "prediction": "        final List<String> versions = artifactHandler.getArtifactVersions(\"com.google.guava:guava:1.0\");\n        assertThat(versions).isEmpty();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "14892248_72", "part": [1, 1], "seq": [1, 1], "prompt": "class PdfDictionary extends PdfObject {\n\n    public void remove(final PdfName key) {\n        hashMap.remove(key);\n    }\n\n    public  PdfDictionary();\n    public  PdfDictionary(int capacity);\n    public  PdfDictionary(final PdfName type);\n\n    @Override public void toPdf(final PdfWriter writer, final OutputStream os);\n    @Override public String toString();\n    public void put(final PdfName key, final PdfObject object);\n    public void putEx(final PdfName key, final PdfObject value);\n    public void putAll(final PdfDictionary dic);\n    public void clear();\n    public PdfObject get(final PdfName key);\n    public PdfObject getDirectObject(final PdfName key);\n    public Set<PdfName> getKeys();\n    public int size();\n    public boolean contains(final PdfName key);\n    public boolean isFont();\n    public boolean isPage();\n    public boolean isPages();\n    public boolean isCatalog();\n    public boolean isOutlineTree();\n    public boolean checkType(PdfName type);\n    public void merge(final PdfDictionary other);\n    public void mergeDifferent(final PdfDictionary other);\n    public PdfDictionary getAsDict(final PdfName key);\n    public PdfArray getAsArray(final PdfName key);\n    public PdfStream getAsStream(final PdfName key);\n    public PdfString getAsString(final PdfName key);\n    public PdfNumber getAsNumber(final PdfName key);\n    public PdfName getAsName(final PdfName key);\n    public PdfBoolean getAsBoolean(final PdfName key);\n    public PdfIndirectReference getAsIndirectObject(final PdfName key);\n\n}\n\nclass PdfDictionaryTest {\n\n    @Test\n    public void pdfDictionaryRemoveDoesNothingIfKeyIsNull() {\n", "reference": "        PdfDictionary dictionary = new PdfDictionary();\n\n        dictionary.remove(null);\n    }\n\n}", "prediction": "        PdfDictionary dictionary = new PdfDictionary();\n        dictionary.remove(null);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "14960307_335", "part": [1, 1], "seq": [1, 1], "prompt": "class CompressionUtil {\n\n    public static boolean isAlgorithmSupported(String algorithm) {\n        return (Algorithm.findByName(algorithm) != null);\n    }\n\n    public static boolean isFileExtensionSupported(String fileExt);\n    public static File compress(File sourceFile, String algorithm, boolean deleteSourceFileAfterCompressed);\n    public static File compress(File sourceFile, File targetDir, String algorithm, boolean deleteSourceFileAfterCompressed);\n    public static File uncompress(File sourceFile, boolean deleteSourceFileAfterUncompressed);\n    public static File uncompress(File sourceFile, File targetDir, boolean deleteSourceFileAfterUncompressed);\n    private static void compress(Algorithm a, File sourceFile, File targetFile, boolean deleteSourceFileAfterCompressed);\n    private static void uncompress(Algorithm a, File sourceFile, File targetFile, boolean deleteSourceFileAfterUncompressed);\n    private static void uncompress(Algorithm a, InputStream srcIn, OutputStream destOut);\n\n    private static final String TEST_FILE;\n\n}\n\nclass CompressionUtilTest {\n\n    private static final String TEST_FILE;\n\n    @Test\n    public void isAlgorithmSupported() throws Exception {\n", "reference": "        Assert.assertEquals(true, CompressionUtil.isAlgorithmSupported(\"gzip\"));\n        Assert.assertEquals(true, CompressionUtil.isAlgorithmSupported(\"zip\"));\n        Assert.assertEquals(false, CompressionUtil.isAlgorithmSupported(\"gzip2\"));\n        //Assert.assertEquals(true, CompressionUtil.isAlgorithmSupported(\"lzma\"));\n    }\n\n}", "prediction": "        assertTrue(CompressionUtil.isAlgorithmSupported(\"gzip\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"bzip2\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"deflate\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"zip\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.gz\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.bz2\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.Z\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lzma\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lz4\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.sz\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.xz\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lz\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lzo\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lz4\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lz4hc\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lz4hc2\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lz4hc3\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lz4hc4\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lz4hc5\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lz4hc6\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lz4hc7\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lz4hc8\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lz4hc9\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lz4hc10\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lz4hc11\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lz4hc12\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lz4hc13\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lz4hc14\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lz4hc15\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lz4hc16\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lz4hc17\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lz4hc18\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lz4hc19\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lz4hc20\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lz4hc21\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lz4hc22\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lz4hc23\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lz4hc24\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lz4hc25\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lz4hc26\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lz4hc27\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lz4hc28\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lz4hc29\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lz4hc30\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lz4hc31\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lz4hc32\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lz4hc33\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lz4hc34\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lz4hc35\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lz4hc36\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lz4hc37\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lz4hc38\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lz4hc39\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lz4hc40\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lz4hc41\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lz4hc42\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lz4hc43\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lz4hc44\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lz4hc45\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lz4hc46\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lz4hc47\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lz4hc48\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lz4hc49\"));\n        assertTrue(CompressionUtil.isAlgorithmSupported(\"tar.lz4hc50\"));\n        assert", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "14989619_32", "part": [1, 1], "seq": [1, 1], "prompt": "class NotificationManager extends AbstractDataSourcePropertyManager<Client, NotificationClientRepository> implements DataSink {\n\n\t@Override\n\tpublic void onNewDataStart(DataSource source) {\n\t\tfor (Client client : getAll(source)) {\n\t\t\tsenderCache.get(source, client).onNewDataStart();\n\t\t}\n\t}\n\n\t@Inject  NotificationManager(\n\t\t\tCache<NotificationClientRepository> repositoryCache,\n\t\t\tRepositoryFactory repositoryFactory,\n\t\t\tSenderCache senderCache);\n\n\t@Override public void onNewDataItem(DataSource source, ObjectNode data);\n\t@Override public void onNewDataComplete(DataSource source);\n\t@Override protected void doAdd(DataSource source, DataRepository dataRepository, Client client);\n\t@Override protected void doRemove(DataSource source, DataRepository dataRepository, Client client);\n\t@Override protected void doRemoveAll(DataSource source);\n\t@Override protected NotificationClientRepository createNewRepository(String sourceId, RepositoryFactory repositoryFactory);\n\n\t@Mocked private SenderCache senderCache;\n\t@Mocked private Cache<NotificationClientRepository> clientRepositoryCache;\n\t@Mocked private RepositoryFactory repositoryFactory;\n\t@Mocked private NotificationClientRepository clientRepository;\n\t@Mocked private Sender<HttpClient> httpSender;\n\t@Mocked private Sender<GcmClient> gcmSender;\n\tprivate final DataSource source;\n\tprivate final HttpClient httpClient;\n\tprivate final GcmClient gcmClient;\n\tprivate NotificationManager notificationManager;\n\n}\n\nclass NotificationManagerTest {\n\n\t@Mocked private SenderCache senderCache;\n\t@Mocked private Cache<NotificationClientRepository> clientRepositoryCache;\n\t@Mocked private RepositoryFactory repositoryFactory;\n\t@Mocked private NotificationClientRepository clientRepository;\n\t@Mocked private Sender<HttpClient> httpSender;\n\t@Mocked private Sender<GcmClient> gcmSender;\n\tprivate final DataSource source;\n\tprivate final HttpClient httpClient;\n\tprivate final GcmClient gcmClient;\n\tprivate NotificationManager notificationManager;\n\n\t@Test\n\tpublic void testOnNewDataStart() {\n", "reference": "\t\tnew Expectations(notificationManager) {{\n\t\t\tsenderCache.get(source, httpClient); result = httpSender;\n\t\t\tnotificationManager.getAll(source); result = Arrays.asList(httpClient, gcmClient);\n\t\t}};\n\n\t\tnotificationManager.onNewDataStart(source);\n\n\t\tnew Verifications() {{\n\t\t\thttpSender.onNewDataStart();\n\t\t\tgcmSender.onNewDataStart();\n\t\t}};\n\t}\n\n}", "prediction": "\t\tnew Expectations() {{\n\t\t\tsenderCache.get(source, httpClient);\n\t\t\tresult = httpSender;\n\t\t\tsenderCache.get(source, gcmClient);\n\t\t\tresult = gcmSender;\n\t\t}};\n\n\t\tnotificationManager.onNewDataStart(source);\n\n\t\tnew Verifications() {{\n\t\t\thttpSender.onNewDataStart();\n\t\t\tgcmSender.onNewDataStart();\n\t\t}};\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "15197084_8", "part": [1, 1], "seq": [1, 1], "prompt": "class MemoizationListImpl extends LiveListBase<E> implements MemoizationList<E>, UnmodifiableByDefaultLiveList<E> {\n\n    @Override\n    public void force(int from, int to) {\n        if(!isObservingInputs()) { // memoization is off\n            throw new IllegalStateException(\n                    \"Cannot force items when memoization is off.\"\n                    + \" To turn memoization on, you have to be observing this\"\n                    + \" list or its memoizedItems.\");\n        }\n\n        Lists.checkRange(from, to, size());\n        for(int i = from; i < to; ++i) {\n            if(!sparseList.isPresent(i)) {\n                E elem = source.get(i);\n                if(sparseList.setIfAbsent(i, elem)) {\n                    int presentBefore = sparseList.getPresentCountBefore(i);\n                    memoizedItems.prepareNotifications(ProperLiveList.elemInsertion(presentBefore));\n                }\n            }\n        }\n        memoizedItems.publishNotifications();\n    }\n\n      MemoizationListImpl(ObservableList<E> source);\n\n    @Override protected Subscription observeInputs();\n    private void sourceChanged(QuasiListChange<? extends E> qc);\n    @Override public E get(int index);\n    @Override public int size();\n    @Override public LiveList<E> memoizedItems();\n    @Override public boolean isMemoized(int index);\n    @Override public Optional<E> getIfMemoized(int index);\n    @Override public int getMemoizedCountBefore(int position);\n    @Override public int getMemoizedCountAfter(int position);\n    @Override public int getMemoizedCount();\n    @Override public void forget(int from, int to);\n    @Override public int indexOfMemoizedItem(int index);\n    @Override public IndexRange getMemoizedItemsRange();\n\n}\n\nclass MemoizationListTest {\n\n    @Test(expected=IllegalStateException.class)\n    public void testForceIsNotAllowedWhenUnobserved() {\n", "reference": "        MemoizationList<Integer> list = new LiveArrayList<>(0, 1, 2, 3, 4, 5, 6).memoize();\n\n        list.force(2, 4);\n    }\n\n}", "prediction": "        LiveList<String> source = LiveArrayList.empty();\n        MemoizationList<String> memoized = MemoizationList.memoize(source);\n        memoized.force(0, 1);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "15566188_15", "part": [1, 1], "seq": [1, 1], "prompt": "class RepositoryTodoCrudService implements TodoCrudService {\n\n    @Transactional\n    @Override\n    public TodoDTO update(TodoDTO dto) {\n        LOGGER.info(\"Updating the information of a todo entry: {}\", dto);\n\n        Todo newInformation = createModel(dto);\n        Todo updated = repository.update(newInformation);\n\n        LOGGER.debug(\"Updated the information of a todo entry: {}\", updated);\n\n        return transformer.convert(updated, new TodoDTO());\n    }\n\n    @Autowired public  RepositoryTodoCrudService(TodoRepository repository, JTransfo transformer);\n\n    @Transactional @Override public TodoDTO add(TodoDTO dto);\n    @Transactional @Override public TodoDTO delete(Long id);\n    @Transactional(readOnly = true) @Override public List<TodoDTO> findAll();\n    @Transactional(readOnly = true) @Override public TodoDTO findById(Long id);\n    private Todo createModel(TodoDTO dto);\n\n    private static final String CREATION_TIME_STRING;\n    private static final Timestamp CREATION_TIME;\n    private static final String DESCRIPTION;\n    private static final Long ID;\n    private static final String MODIFICATION_TIME_STRING;\n    private static final Timestamp MODIFICATION_TIME;\n    private static final String TITLE;\n    @Mock\n    private TodoRepository repositoryMock;\n    private RepositoryTodoCrudService service;\n    @Autowired\n    private JTransfo transformer;\n\n}\n\nclass RepositoryTodoCrudServiceTest {\n\n    private static final String CREATION_TIME_STRING;\n    private static final Timestamp CREATION_TIME;\n    private static final String DESCRIPTION;\n    private static final Long ID;\n    private static final String MODIFICATION_TIME_STRING;\n    private static final Timestamp MODIFICATION_TIME;\n    private static final String TITLE;\n    @Mock\n    private TodoRepository repositoryMock;\n    private RepositoryTodoCrudService service;\n    @Autowired\n    private JTransfo transformer;\n\n    @Test\n    public void update_TodoEntryNotFound_ShouldThrowException() {\n", "reference": "        TodoDTO updatedTodoEntry = new TodoDTOBuilder()\n                .id(ID)\n                .description(DESCRIPTION)\n                .title(TITLE)\n                .build();\n\n        when(repositoryMock.update(isA(Todo.class))).thenThrow(new TodoNotFoundException(\"\"));\n\n        catchException(service).update(updatedTodoEntry);\n        assertThat(caughtException()).isExactlyInstanceOf(TodoNotFoundException.class);\n\n        ArgumentCaptor<Todo> repositoryMethodArgument = ArgumentCaptor.forClass(Todo.class);\n\n        verify(repositoryMock, times(1)).update(repositoryMethodArgument.capture());\n        verifyNoMoreInteractions(repositoryMock);\n\n        Todo repositoryMethodArgumentValue = repositoryMethodArgument.getValue();\n\n        assertThatTodo(repositoryMethodArgumentValue)\n                .hasDescription(DESCRIPTION)\n                .hasId(ID)\n                .hasTitle(TITLE)\n                .creationTimeIsNotSet()\n                .modificationTimeIsNotSet();\n    }\n\n}", "prediction": "        TodoDTO dto = new TodoDTO();\n        dto.setId(ID);\n\n        when(repositoryMock.findById(ID)).thenReturn(null);\n\n        assertThatThrownBy(() -> service.update(dto))\n                .isInstanceOf(TodoNotFoundException.class)\n                .hasMessage(\"Todo entry with id \" + ID + \" not found\");\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "15592774_1", "part": [1, 1], "seq": [1, 1], "prompt": "class ComparableDependency extends AbstractDependency {\n\n    @Override\n    public final CheckResult call() throws Exception {\n        // TODO Replace this with a SimpleDependency and a CheckMethod that accepts a WallClock.\n        final long start = System.currentTimeMillis();\n        try {\n            final T value = getValue();\n            final CheckStatus status;\n            final T threshold;\n            if (value.compareTo(maxOK) <= 0) {\n                threshold = null;\n                status = CheckStatus.OK;\n            } else if (maxMinor != null && value.compareTo(maxMinor) <= 0) {\n                threshold = maxOK;\n                status = CheckStatus.MINOR;\n            } else if (maxMajor != null && value.compareTo(maxMajor) <= 0) {\n                threshold = maxMinor;\n                status = CheckStatus.MAJOR;\n            } else {\n                threshold = maxMajor != null ? maxMajor : (maxMinor != null ? maxMinor : maxOK);\n                status = CheckStatus.OUTAGE;\n            }\n            final long duration = System.currentTimeMillis() - start;\n            final String errorMessage = formatErrorMessage(status, value, threshold, start, duration, null);\n            return CheckResult.newBuilder(this, status, errorMessage)\n                    .setTimestamp(start)\n                    .setDuration(duration)\n                    .build();\n\n        } catch (final Exception e) {\n            final long duration = System.currentTimeMillis() - start;\n            final String errorMessage = formatErrorMessage(CheckStatus.OUTAGE, null, null, start, duration, e);\n            return CheckResult.newBuilder(this, CheckStatus.OUTAGE, errorMessage)\n                    .setTimestamp(start)\n                    .setDuration(duration)\n                    .setThrowable(e)\n                    .build();\n        }\n    }\n\n    @Deprecated public  ComparableDependency(\n            @Nonnull final String id,\n            @Nonnull final String description,\n            final long timeout,\n            final long pingPeriod,\n            @Nonnull final Urgency urgency,\n            @Nonnull final T maxOK,\n            @Nullable final T maxMinor,\n            @Nullable final T maxMajor\n    );\n    public  ComparableDependency(\n            @Nonnull final String id,\n            @Nonnull final String description,\n            final long timeout,\n            final long pingPeriod,\n            @Nonnull final Urgency urgency,\n            @Nonnull final DependencyType type,\n            @Nonnull final String servicePool,\n            @Nonnull final T maxOK,\n            @Nullable final T maxMinor,\n            @Nullable final T maxMajor\n    );\n\n    protected abstract T getValue();\n    protected abstract String formatErrorMessage(CheckStatus status, @Nullable T value, @Nullable T brokenThreshold, long timestamp, long duration, @Nullable Exception e);\n\n}\n\nclass ComparableDependencyTest {\n\n    @Test\n    public void testSane() throws Exception {\n", "reference": "        final AtomicInteger val = new AtomicInteger(0);\n        final CompDep compDep = new CompDep(val, 5, 10, 15);\n\n        val.set(0);\n        assertEquals(\"OK,0,null,null\", compDep.call().getErrorMessage());\n\n        val.set(5);\n        assertEquals(\"OK,5,null,null\", compDep.call().getErrorMessage());\n\n        val.set(6);\n        assertEquals(\"MINOR,6,5,null\", compDep.call().getErrorMessage());\n\n        val.set(10);\n        assertEquals(\"MINOR,10,5,null\", compDep.call().getErrorMessage());\n\n        val.set(11);\n        assertEquals(\"MAJOR,11,10,null\", compDep.call().getErrorMessage());\n\n        val.set(15);\n        assertEquals(\"MAJOR,15,10,null\", compDep.call().getErrorMessage());\n\n        val.set(16);\n        assertEquals(\"OUTAGE,16,15,null\", compDep.call().getErrorMessage());\n    }\n\n}", "prediction": "        final ComparableDependency<Integer> dependency = new ComparableDependency<Integer>(\n                \"test\",\n                \"test\",\n                1000,\n                1000,\n                Urgency.HIGH,\n                DependencyType.SIMPLE,\n                \"test\",\n                1,\n                null,\n                null\n        ) {\n            @Override\n            protected Integer getValue() {\n                return 1;\n            }\n\n            @Override\n            protected String formatErrorMessage(CheckStatus status, @Nullable Integer value, @Nullable Integer brokenThreshold, long timestamp, long duration, @Nullable Exception e) {\n                return \"test\";\n            }\n        };\n        final CheckResult result = dependency.call();\n        assertEquals(CheckStatus.OK, result.getStatus());\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "15758326_0", "part": [1, 1], "seq": [1, 1], "prompt": "class IntegerCoder {\n\n    public static ByteBuffer encodeLong(long value, int minBytes)\n    {\n        assert minBytes >= 1 && minBytes <= 8;\n\n        byte[] buf = new byte[9];\n        BitOps.putLongAsLittleEndian(buf, 1, value);\n\n        int count = buf.length - 1; // int lastNonZeroByteIndex = count;\n        while (count > minBytes && buf[count] == 0) {\n            count--;\n        }\n\n        int firstByteValue = 0xFF & (1 << (7 - count + minBytes));\n        // 1 <= minBytes <= 8\n        // minBytes <= count <= 8\n        // max(-count + minBytes) when count equals minBytes\n        // min(-count + minBytes) == -8 + 1 = -7\n        // 1 << ( 7 - 8 + 1) == 1 << 0 == 1;\n        // 1 << ( 7 - 0 ) == 128\n        // firstByteValue is a power of 2 in range: 1 <= firstByteValue <= 128\n\n        if ((0xFF & buf[count]) >= firstByteValue) {\n            buf[0] = (byte) ~ (firstByteValue - 1);\n            count++;\n        } else if (count > minBytes) {\n            buf[0] = (byte) ((~ (firstByteValue * 2 - 1)) | buf[count]);\n        } else {\n            buf[0] = buf[count];\n        }\n\n        return ByteBuffer.wrap(buf, 0, count);\n    }\n\n    private  IntegerCoder();\n\n    public static long decodeLong(Readable src, int minBytes);\n\n    private static final int _minBytes;\n    private long _input;\n    private ByteBuffer _expected;\n\n}\n\nclass IntegerCoderTest {\n\n    private static final int _minBytes;\n    private long _input;\n    private ByteBuffer _expected;\n\n    @Test\n    public void testEncodingCorrectness()\n    {\n", "reference": "        ByteBuffer actual = IntegerCoder.encodeLong(_input, _minBytes);\n        assertEquals(String.format(\"encode %d -> %s, expected %s (minBytes=%d)\",\n                                   _input,\n                                   Text.byteBufferToString(actual),\n                                   Text.byteBufferToString(_expected),\n                                   _minBytes),\n                     _expected, actual);\n    }\n\n}", "prediction": "        for (int i = 0; i < 10000; i++) {\n            _input = ThreadLocalRandom.current().nextLong();\n            _expected = IntegerCoder.encodeLong(_input, _minBytes);\n            assertEquals(_expected, IntegerCoder.encodeLong(_input, _minBytes));\n        }\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "16144428_60", "part": [1, 1], "seq": [1, 1], "prompt": "class BitVectorIterator implements Iterator<Boolean> {\n\n\t@Override\n\tpublic Boolean next() {\n\t\tif (this.pointer >= this.bitVector.size()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\n\t\treturn this.bitVector.getBit(this.pointer++);\n\t}\n\n\tpublic  BitVectorIterator(BitVector bitVector);\n\n\t@Override public boolean equals(Object o);\n\t@Override public int hashCode();\n\t@Override public boolean hasNext();\n\t@Override public void remove();\n\n}\n\nclass BitVectorIteratorTest {\n\n\t@Test(expected = NoSuchElementException.class)\n\tpublic void testNoSuchElementException() {\n", "reference": "\t\tnew BitVectorImpl().iterator().next();\n\t}\n\n}", "prediction": "\t\tBitVector bitVector = new BitVector(10);\n\t\tbitVector.setBit(0, true);\n\t\tbitVector.setBit(1, true);\n\t\tbitVector.setBit(2, true);\n\t\tbitVector.setBit(3, true);\n\t\tbitVector.setBit(4, true);\n\t\tbitVector.setBit(5, true);\n\t\tbitVector.setBit(6, true);\n\t\tbitVector.setBit(7, true);\n\t\tbitVector.setBit(8, true);\n\t\tbitVector.setBit(9, true);\n\n\t\tBitVectorIterator iterator = new BitVectorIterator(bitVector);\n\t\titerator.next();\n\t\titerator.next();\n\t\titerator.next();\n\t\titerator.next();\n\t\titerator.next();\n\t\titerator.next();\n\t\titerator.next();\n\t\titerator.next();\n\t\titerator.next();\n\t\titerator.next();\n\t\titerator.next();\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "16201889_25", "part": [1, 1], "seq": [1, 1], "prompt": "class NameParserGbifV1 implements NameParser {\n\n  @Override\n  // parses the name without authorship and returns the ParsedName.canonicalName() string\n  public String parseToCanonical(String scientificName, @Nullable Rank rank) {\n    if (Strings.isNullOrEmpty(scientificName)) {\n      return null;\n    }\n    try {\n      ParsedName pn = parse(scientificName, rank);\n      if (pn != null) {\n        return pn.canonicalName();\n      }\n    } catch (UnparsableException e) {\n      logUnparsable(e);\n    }\n    return null;\n  }\n\n  public  NameParserGbifV1();\n  public  NameParserGbifV1(long timeout);\n  public  NameParserGbifV1(org.gbif.nameparser.api.NameParser parser);\n\n  @Override public ParsedName parse(String s, @Nullable Rank rank);\n  @Override public ParsedName parse(String scientificName);\n  @Override public ParsedName parseQuietly(String scientificName, @Nullable Rank rank);\n  @Override public ParsedName parseQuietly(String scientificName);\n  private static void logUnparsable(UnparsableException e);\n  @Override public String parseToCanonical(String scientificName);\n  public String parseToCanonicalOrScientificName(String scientificName);\n  public String parseToCanonicalOrScientificName(String scientificName, @Nullable Rank rank);\n  private ParsedName convert(String scientificName, Rank rank, org.gbif.nameparser.api.ParsedName pn);\n  @VisibleForTesting static NameType gbifNameType(org.gbif.nameparser.api.ParsedName pn);\n  @VisibleForTesting static org.gbif.api.vocabulary.NamePart toGbif(NamePart notho);\n  @VisibleForTesting static Rank toGbif(org.gbif.nameparser.api.Rank rank);\n  @VisibleForTesting static org.gbif.nameparser.api.Rank fromGbif(Rank rank);\n  private static G convertEnum(Class<G> targetClass, Enum<?> value);\n\n  private static final boolean DEBUG;\n   NameParserGbifV1 parser;\n\n}\n\nclass NameParserGbifV1Test {\n\n  private static final boolean DEBUG;\n   NameParserGbifV1 parser;\n\n  @Test\n  public void parseToCanonical() throws Exception {\n", "reference": "    assertEquals(\"Abies alba\", parser.parseToCanonical(\"Abies alba Mill.\"));\n    assertNull(parser.parseToCanonical(\"BOLD:AAX3687\", Rank.SPECIES));\n  }\n\n}", "prediction": "    assertEquals(\"Acanthoscelides\", parser.parseToCanonical(\"Acanthoscelides\"));\n    assertEquals(\"Acanthoscelides\", parser.parseToCanonical(\"Acanthoscelides (Acanthoscelides)\"));\n    assertEquals(\"Acanthoscelides\", parser.parseToCanonical(\"Acanthoscelides (Acanthoscelides)\"));\n    assertEquals(\"Acanthoscelides\", parser.parseToCanonical(\"Acanthoscelides (Acanthoscelides)\"));\n    assertEquals(\"Acanthoscelides\", parser.parseToCanonical(\"Acanthoscelides (Acanthoscelides)\"));\n    assertEquals(\"Acanthoscelides\", parser.parseToCanonical(\"Acanthoscelides (Acanthoscelides)\"));\n    assertEquals(\"Acanthoscelides\", parser.parseToCanonical(\"Acanthoscelides (Acanthoscelides)\"));\n    assertEquals(\"Acanthoscelides\", parser.parseToCanonical(\"Acanthoscelides (Acanthoscelides)\"));\n    assertEquals(\"Acanthoscelides\", parser.parseToCanonical(\"Acanthoscelides (Acanthoscelides)\"));\n    assertEquals(\"Acanthoscelides\", parser.parseToCanonical(\"Acanthoscelides (Acanthoscelides)\"));\n    assertEquals(\"Acanthoscelides\", parser.parseToCanonical(\"Acanthoscelides (Acanthoscelides)\"));\n    assertEquals(\"Acanthoscelides\", parser.parseToCanonical(\"Acanthoscelides (Acanthoscelides)\"));\n    assertEquals(\"Acanthoscelides\", parser.parseToCanonical(\"Acanthoscelides (Acanthoscelides)\"));\n    assertEquals(\"Acanthoscelides\", parser.parseToCanonical(\"Acanthoscelides (Acanthoscelides)\"));\n    assertEquals(\"Acanthoscelides\", parser.parseToCanonical(\"Acanthoscelides (Acanthoscelides)\"));\n    assertEquals(\"Acanthoscelides\", parser.parseToCanonical(\"Acanthoscelides (Acanthoscelides)\"));\n    assertEquals(\"Acanthoscelides\", parser.parseToCanonical(\"Acanthoscelides (Acanthoscelides)\"));\n    assertEquals(\"Acanthoscelides\", parser.parseToCanonical(\"Acanthoscelides (Acanthoscelides)\"));\n    assertEquals(\"Acanthoscelides\", parser.parseToCanonical(\"Acanthoscelides (Acanthoscelides)\"));\n    assertEquals(\"Acanthoscelides\", parser.parseToCanonical(\"Acanthoscelides (Acanthoscelides)\"));\n    assertEquals(\"Acanthoscelides\", parser.parseToCanonical(\"Acanthoscelides (Acanthoscelides)\"));\n    assertEquals(\"Acanthoscelides\", parser.parseToCanonical(\"Acanthoscelides (Acanthoscelides)\"));\n    assertEquals(\"Acanthoscelides\", parser.parseToCanonical(\"Acanthoscelides (Acanthoscelides)\"));\n    assertEquals(\"Acanthoscelides\", parser.parseToCanonical(\"Acanthoscelides (Acanthoscelides)\"));\n    assertEquals(\"Acanthoscelides\", parser.parseToCanonical(\"Acanthoscelides (Acanthoscelides)\"));\n    assertEquals(\"Acanthoscelides\", parser.parseToCanonical(\"Acanthoscelides (Acanthoscelides)\"));\n    assertEquals(\"Acanthoscelides\", parser.parseToCanonical(\"Acanthoscelides (Acanthoscelides)\"));\n    assertEquals(\"Acanthoscelides\", parser.parseToCanonical(\"Acanthoscelides (Acanthoscelides)\"));\n    assertEquals(\"Acanthoscelides\", parser.parseToCanonical(\"Acanthoscelides (Acanthoscelides)\"));\n    assertEquals(\"Acanthoscelides\", parser.parseToCanonical(\"Acanthoscelides (Acanthoscelides)\"));\n    assertEquals(\"Acanthoscelides\", parser.parseToCanonical(\"Acanthoscelides (Acanthoscelides)\"));\n    assertEquals(\"Acanthoscelides\", parser.parseToCanonical(\"Acanthoscelides (Acanthoscelides)\"));\n    assertEquals(\"Acanthoscelides\", parser.parseToCanonical(\"Acanthoscelides (Acanthoscelides)\"));\n    assertEquals(\"Acanthoscel", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "16261234_0", "part": [1, 1], "seq": [1, 1], "prompt": "class RecursiveLinearizingComposer extends RecursiveLinearizingComposerTree {\n\n    public SimplePolynomialFunction compose( SimplePolynomialFunction inner ) {\n        Preconditions.checkArgument(outerInputLength == inner.getOutputLength() , \"Outer input length must equal inner output length\" );\n        List<SimplePolynomialFunction> pieces = evaluate( null , Arrays.asList( inner.getMonomials() ), Lists.newArrayList( inner.getMonomials() ), rowContributions( inner ) , indices( inner.getMonomials() ) );\n        SimplePolynomialFunction result = null;\n        for( SimplePolynomialFunction piece : pieces ) {\n            if( result == null ) { \n                result = piece;\n            } else {\n                result = piece.xor( result );\n            }\n        }\n        if( constantContribution!=null ) {\n            result = result.xor( getConstantFunction( inner.getInputLength() ) );\n        }\n        return result;\n    }\n\n    public  RecursiveLinearizingComposer(SimplePolynomialFunction outer );\n\n    @Override public void bucket(Monomial m, BitVector contribution);\n    public SimplePolynomialFunction getConstantFunction( int innerInputLength);\n    private static ConcurrentMap<Monomial,Integer> indices( Monomial[] innerMonomials );\n    private static List<BitVector> rowContributions( SimplePolynomialFunction inner );\n    private static RecursiveLinearizingComposerTree[] initializeTreeFromOuter( SimplePolynomialFunction outer );\n\n    private static final Logger logger;\n\n}\n\nclass RecursiveLinearizingComposerTest {\n\n    private static final Logger logger;\n\n    @Test \n    public void testRecurisveLinearizingComposer() {\n", "reference": "        logger.debug(\"Starting recursive linearing composer tests.\");\n        BasePolynomialFunction f = (BasePolynomialFunction)SimplePolynomialFunctions.denseRandomMultivariateQuadratic( 128 , 128);\n        BasePolynomialFunction inner = (BasePolynomialFunction) EnhancedBitMatrix.randomMatrix( 128 , 256 ) .multiply(  SimplePolynomialFunctions.identity( 256 ) );\n        \n        \n        RecursiveLinearizingComposer composer = new RecursiveLinearizingComposer( f );\n        Stopwatch watch = Stopwatch.createStarted();\n        SimplePolynomialFunction composed = composer.compose( inner );\n        logger.info( \"Compose time: {} ms\" , watch.elapsed( TimeUnit.MILLISECONDS ) );\n        \n        BitVector input =  BitVectors.randomVector( inner.getInputLength() );\n        BitVector expected = f.apply( inner.apply( input ) );\n        BitVector actual = composed.apply( input );\n        \n        Assert.assertEquals( expected , actual );\n    }\n\n}", "prediction": "       \n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "16336212_163", "part": [1, 1], "seq": [1, 1], "prompt": "class CommonHandler {\n\n    CommonResponse newHttpResponseFromException(CommonRequest request,\n            Authentication authentication, Exception exception) throws Exception {\n        Exception e = exception;\n        if (e instanceof InvocationTargetException) {\n            Throwable cause = e.getCause();\n            if (cause instanceof Exception) {\n                e = (Exception) cause;\n            }\n        }\n        if (e instanceof JsonServiceException) {\n            // this is an \"expected\" exception, no need to log\n            JsonServiceException jsonServiceException = (JsonServiceException) e;\n            if (jsonServiceException.getStatus() == FORBIDDEN) {\n                return handleNotAuthorized(request, authentication);\n            } else {\n                return newHttpResponseWithMessage(jsonServiceException.getStatus(),\n                        jsonServiceException.getMessage());\n            }\n        }\n        logger.error(e.getMessage(), e);\n        if (e instanceof SQLException\n                && ((SQLException) e).getErrorCode() == H2_STATEMENT_WAS_CANCELED) {\n            return newHttpResponseWithMessage(REQUEST_TIMEOUT,\n                    \"Query timed out (timeout is configurable under Configuration > Advanced)\");\n        }\n        return newHttpResponseWithStackTrace(e, INTERNAL_SERVER_ERROR, null);\n    }\n\n      CommonHandler(boolean central, LayoutService layoutService,\n            Map<Pattern, HttpService> httpServices, HttpSessionManager httpSessionManager,\n            List<Object> jsonServices, Clock clock);\n\n    public CommonResponse handle(CommonRequest request);\n    private @Nullable CommonResponse handleIfLoginOrLogoutRequest(CommonRequest request);\n    private CommonResponse handleRequest(CommonRequest request, Authentication authentication);\n    private @Nullable HttpService getHttpService(String path);\n    private CommonResponse handleHttpService(CommonRequest request, HttpService httpService,\n            Authentication authentication);\n    private @Nullable JsonServiceMapping getJsonServiceMapping(CommonRequest request,\n            String path);\n    private CommonResponse handleJsonServiceMappings(CommonRequest request,\n            JsonServiceMapping jsonServiceMapping, Authentication authentication);\n    private CommonResponse handleNotAuthorized(CommonRequest request,\n            Authentication authentication);\n    private CommonResponse handleStaticResource(String path, CommonRequest request);\n    private @Nullable Date getExpiresForPath(String path);\n    private static @Nullable String getAgentRollupIdFromRequest(CommonRequest request);\n    private static CommonResponse buildJsonResponse(@Nullable Object responseObject);\n    private static JsonServiceMapping build(HttpMethod httpMethod, String path,\n            String permission, Object jsonService, Method method);\n    private static @Nullable URL getSecureUrlForPath(String path);\n    private static @Nullable URL getUrlForPath(String path);\n    private static CommonResponse newHttpResponseWithMessage(HttpResponseStatus status,\n            @Nullable String message);\n    static CommonResponse newHttpResponseWithStackTrace(Exception e,\n            HttpResponseStatus status, @Nullable String simplifiedMessage);\n    private static String getHttpResponseWithStackTrace(Exception e,\n            @Nullable String simplifiedMessage);\n    private static @Nullable Object callMethod(JsonServiceMapping jsonServiceMapping,\n            List<Class<?>> parameterTypes, List<Object> parameters,\n            Map<String, List<String>> queryParameters, Authentication authentication,\n            CommonRequest request);\n    private static boolean isAutoRefresh(@Nullable List<String> autoRefreshParams);\n\n    private static final int H2_STATEMENT_WAS_CANCELED;\n    private static final CommonHandler HTTP_SERVER_HANDLER;\n\n}\n\nclass CommonHandlerTest {\n\n    private static final int H2_STATEMENT_WAS_CANCELED;\n    private static final CommonHandler HTTP_SERVER_HANDLER;\n\n    @Test\n    public void shouldCreateNonTimeoutSqlExceptionResponse() throws Exception {\n", "reference": "        // given\n        Exception e = new SQLException(\"Another message\", \"\", H2_STATEMENT_WAS_CANCELED + 1);\n        // when\n        CommonResponse httpResponse = HTTP_SERVER_HANDLER.newHttpResponseFromException(\n                mock(CommonRequest.class), mock(Authentication.class), e);\n        // then\n        String content = (String) httpResponse.getContent();\n        ObjectNode node = (ObjectNode) new ObjectMapper().readTree(content);\n        assertThat(node.get(\"message\").asText())\n                .isEqualTo(\"java.sql.SQLException: Another message\");\n        assertThat(node.get(\"stackTrace\")).isNotNull();\n        assertThat(httpResponse.getStatus()).isEqualTo(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n    }\n\n}", "prediction": "        CommonResponse response = HTTP_SERVER_HANDLER.newHttpResponseFromException(\n                new CommonRequest(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null,", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "16597144_10", "part": [1, 1], "seq": [1, 1], "prompt": "class ChebyshevDistanceCalculator extends DistanceCalculator {\n\n    public double getDistance(double[] features1, double[] features2) {\n        double distance = positiveInfinityIfEitherOrBothAreNull(features1, features2);\n        if (distance < 0) {\n            if(features1.length != features2.length) {\n                throw new IllegalArgumentException(\"Both features should have the same length. Received lengths of [\" +\n                        + features1.length + \"] and [\" + features2.length + \"]\");\n            }\n            distance = 0.0;\n            for (int i = 0; i < features1.length; i++) {\n                double currentDistance = Math.abs(features1[i] - features2[i]);\n                distance = (currentDistance > distance) ? currentDistance : distance; \n            }\n        }\n        return distance;\n    }\n\n    private ChebyshevDistanceCalculator distanceCalculator;\n    private double[] identicalA;\n    private double[] identicalB;\n\n}\n\nclass ChebyshevDistanceCalculatorTest {\n\n    private ChebyshevDistanceCalculator distanceCalculator;\n    private double[] identicalA;\n    private double[] identicalB;\n\n    @Test\n    public void nullValueOfSecondParameterReturnsPositiveInfinity( ) {\n", "reference": "        double distance = distanceCalculator.getDistance(new double[0], null);\n        assertThat(distance, is(equalTo(Double.POSITIVE_INFINITY)));\n    }\n\n}", "prediction": "        assertEquals(Double.POSITIVE_INFINITY, distanceCalculator.getDistance(identicalA, null));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "16611556_178", "part": [1, 1], "seq": [1, 1], "prompt": "class MemcacheClientWrapper extends AbstractMemcacheClientWrapper {\n\n    @Override\n    public boolean set(final String key, final int exp, final Object value) throws TimeoutException, CacheException {\n        try {\n            return memcachedClient.set(key, exp, value);\n        } catch (MemcachedException | InterruptedException e) {\n            throw new CacheException(e);\n        }\n    }\n\n      MemcacheClientWrapper(final MemcachedClient memcachedClient);\n\n    @Override public boolean add(final String key, final int exp, final Object value);\n    @Override public boolean add(final String key, final int exp, final T value, final CacheTranscoder transcoder);\n    @Override public long decr(final String key, final int by);\n    @Override public long decr(final String key, final int by, final long def);\n    @Override public boolean delete(final String key);\n    @Override public void flush();\n    @Override public Object get(final String key);\n    @Override public T get(final String key, final CacheTranscoder transcoder);\n    @Override public T get(final String key, final CacheTranscoder transcoder, final long timeout);\n    @Override public Collection<SocketAddress> getAvailableServers();\n    @Override public Map<String, Object> getBulk(final Collection<String> keys);\n    @Override public Map<String, T> getBulk(final Collection<String> keys, final CacheTranscoder transcoder);\n    @Override public long incr(final String key, final int by);\n    @Override public long incr(final String key, final int by, final long def);\n    @Override public long incr(final String key, final int by, final long def, final int expiration);\n    @Override public boolean set(final String key, final int exp, final T value, final CacheTranscoder transcoder);\n    @Override public void shutdown();\n    @Override @SuppressWarnings(\"unchecked\") public CacheTranscoder getTranscoder();\n    @Override public Object getNativeClient();\n    @SuppressWarnings(\"unchecked\") private Transcoder<T> getTranscoder(final CacheTranscoder transcoder);\n\n    private MemcachedClient client;\n    private MemcacheClientWrapper clientWrapper;\n\n}\n\nclass MemcacheClientWrapperTest {\n\n    private MemcachedClient client;\n    private MemcacheClientWrapper clientWrapper;\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void setStringIntTMemcacheTranscoderOfT() throws TimeoutException, InterruptedException, MemcachedException, CacheException {\n", "reference": "        CacheTranscoder transcoder = EasyMock.createMock(CacheTranscoder.class);\n        EasyMock.expect(client.set(EasyMock.eq(\"key1\"), EasyMock.eq(1), EasyMock.eq(\"value\"), EasyMock.anyObject(Transcoder.class)))\n                .andReturn(true);\n        EasyMock.replay(client);\n        assertTrue(clientWrapper.set(\"key1\", 1, \"value\", transcoder));\n        EasyMock.verify(client);\n    }\n\n}", "prediction": "        clientWrapper.set(\"key\", 10, \"value\", new MemcacheTranscoder());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "16630721_2", "part": [1, 1], "seq": [1, 1], "prompt": "class SampleDao {\n\n  public Sample findSampleById(final Long sampleId, boolean lockRow) {\n    return dbp.get().toSelect(\"select sample_name, update_sequence, update_time from sample where sample_id=?\"\n        + (lockRow ? \" for update\" : \"\"))\n        .argLong(sampleId).queryOneOrNull(r -> {\n          Sample result = new Sample();\n          result.setSampleId(sampleId);\n          result.setName(r.getStringOrNull());\n          result.setUpdateSequence(r.getIntegerOrNull());\n          result.setUpdateTime(r.getDateOrNull());\n          return result;\n        });\n  }\n\n  public  SampleDao(Supplier<Database> dbp);\n\n  public void createSample(final Sample sample, Long userIdMakingChange);\n  public void updateSample(Sample sample, Long userIdMakingChange);\n  public void deleteSample(Sample sample, Long userIdMakingChange);\n\n  @Mock\n  private DatabaseMock db;\n  private Date now;\n  private SampleDao sampleDao;\n\n}\n\nclass SampleDaoTest {\n\n  @Mock\n  private DatabaseMock db;\n  private Date now;\n  private SampleDao sampleDao;\n\n  @Test\n  public void testFindAndLock() throws Exception {\n", "reference": "    // Configure the mock because our class under test expects values to be returned from the db\n    when(db.query(anyString(), anyString())).thenReturn(new RowStub()\n        .withColumnNames(\"sample_name\", \"update_sequence\", \"update_time\")\n        .addRow(\"Foo\", 3, now));\n\n    // The test scenario\n    Sample sample = sampleDao.findSampleById(15L, true);\n\n    // Verify object in memory is updated properly\n    assertEquals(new Long(15L), sample.getSampleId());\n    assertEquals(\"Foo\", sample.getName());\n    assertEquals(new Integer(3), sample.getUpdateSequence());\n    assertEquals(now, sample.getUpdateTime());\n\n    // Verify database queries against golden copies\n    verify(db).query(anyString(), eq(\"select sample_name, update_sequence, update_time from sample where sample_id=15 for update\"));\n    verifyNoMoreInteractions(db);\n  }\n\n}", "prediction": "    Sample sample = new Sample();\n    sample.setSampleId(1L);\n    sample.setName(\"sample1\");\n    sample.setUpdateSequence(1);\n    sample.setUpdateTime(now);\n    db.add(sample);\n\n    Sample result = sampleDao.findSampleById(sample.getSampleId(), true);\n    assertEquals(sample.getSampleId(), result.getSampleId());\n    assertEquals(sample.getName(), result.getName());\n    assertEquals(sample.getUpdateSequence(), result.getUpdateSequence());\n    assertEquals(sample.getUpdateTime(), result.getUpdateTime());\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "16885508_1", "part": [1, 1], "seq": [1, 1], "prompt": "class CSVWrapper extends AbstractWrapper {\n\n    public boolean initialize() {\n        AddressBean addressBean = getActiveAddressBean();\n        dataFile = addressBean.getPredicateValueWithException(\"file\");\n        String csvFields = addressBean.getPredicateValueWithException(\"fields\");\n        String csvFormats = addressBean.getPredicateValueWithException(\"formats\");\n        //String csvSeparator = addressBean.getPredicateValueWithDefault(\"separator\",\",\");\n        String value = addressBean.getPredicateValue(\"separator\");\n        String csvSeparator = (value == null || value.length() == 0) ? \",\" : value;\n        checkPointDir = addressBean.getPredicateValueWithDefault(\"check-point-directory\", \"./csv-check-points\");\n        String csvStringQuote = addressBean.getPredicateValueWithDefault(\"quote\", \"\\\"\");\n        int skipFirstXLine = addressBean.getPredicateValueAsInt(\"skip-first-lines\", 0);\n        String timezone = addressBean.getPredicateValueWithDefault(\"timezone\", handler.LOCAL_TIMEZONE_ID);\n        String nullValues = addressBean.getPredicateValueWithDefault(\"bad-values\", \"\");\n        String strUseCounterForCheckPoint = addressBean.getPredicateValueWithDefault(\"use-counter-for-check-point\", \"false\");\n        samplingPeriodInMsc = addressBean.getPredicateValueAsInt(\"sampling\", 10000);\n\n        /*\n        DEBUG_INFO(dataFile);\n        */\n\n        if (csvSeparator != null && csvSeparator.length() != 1) {\n            logger.warn(\"The provided CSV separator:>\" + csvSeparator + \"< should only have  1 character, thus ignored and instead \\\",\\\" is used.\");\n            csvSeparator = \",\";\n        }\n\n        if (csvStringQuote.length() != 1) {\n            logger.warn(\"The provided CSV quote:>\" + csvSeparator + \"< should only have 1 character, thus ignored and instead '\\\"' is used.\");\n            csvStringQuote = \"\\\"\";\n        }\n\n        try {\n            if (strUseCounterForCheckPoint.equalsIgnoreCase(\"true\")) {\n                useCounterForCheckPoint = true;\n                logger.warn(\"Using counter-based check points\");\n            }\n            //String checkPointFile = new File(checkPointDir).getAbsolutePath()+\"/\"+(new File(dataFile).getName())+\"-\"+addressBean.hashCode();\n            StringBuilder checkPointFile = new StringBuilder()\n                    .append(new File(checkPointDir).getAbsolutePath())\n                    .append(\"/\")\n                    .append(addressBean.getVirtualSensorName())\n                    .append(\"_\")\n                    .append(addressBean.getInputStreamName())\n                    .append(\"_\")\n                    .append(addressBean.getWrapper())\n                    .append(\"_\")\n                    .append(new File(dataFile).getName());\n            if (!handler.initialize(dataFile.trim(), csvFields, csvFormats, csvSeparator.toCharArray()[0], csvStringQuote.toCharArray()[0], skipFirstXLine, nullValues, timezone, checkPointFile.toString()))\n                return false;\n\n            String val = FileUtils.readFileToString(new File(checkPointFile.toString()), \"UTF-8\");\n            long lastItem = 0;\n            if (val != null && val.trim().length() > 0)\n                lastItem = Long.parseLong(val.trim());\n            logger.warn(\"Latest item: \"+lastItem);\n\n            if (useCounterForCheckPoint) {\n                processedLineCounter = lastItem;\n            }\n\n        } catch (Exception e) {\n            logger.error(\"Loading the csv-wrapper failed:\" + e.getMessage(), e);\n            return false;\n        }\n\n        dataField = handler.getDataFields();\n\n        logger.warn(\"Reading from: \" + dataFile);\n\n        return true;\n    }\n\n    public void run();\n    public DataField[] getOutputFormat();\n    public String getWrapperName();\n    public void dispose();\n    public void DEBUG_INFO(String s);\n     String list(String name, long value);\n\n\tprivate final String CSV_FILE_NAME;\n\tprivate final String CHECK_POINT_DIR;\n\n}\n\nclass CSVWrapperTest {\n\n\tprivate final String CSV_FILE_NAME;\n\tprivate final String CHECK_POINT_DIR;\n\n\t@Test\n\tpublic void testFieldConverting() throws IOException {\n", "reference": "\t\tString fields = \"TIMED, air_temp , TIMED , AiR_TeMp2\";\n\t\tString formats = \"Timestamp(d.M.y ) , Numeric , timestamp(k:m) , numeric    \";\n\t\tString badFormat = \"Timestamp(d.M.y k:m) , numeric , numeric, numeric,numeric,dollluble \";\n\t\tString badFormat2 =\"Timestamp(d.Mjo0o.y k:m) , numeric, numeric, numeric\";\n\t\t\n\t\tCSVHandler wrapper = new CSVHandler();\n\t\tassertEquals(false,wrapper.initialize(\"test.csv.csv\", fields,badFormat,',','\\\"',0,\"NaN,-1234,4321\"));\n\t\tassertEquals(false,wrapper.initialize(\"test.csv.csv\", fields,badFormat,',','\\\"',0,\"NaN,-1234,4321\"));\n\t\tassertEquals(false,wrapper.initialize(\"test.csv.csv\", fields,badFormat2,',','\\\"',0,\"NaN,-1234,4321\"));\n\t\t\n\t\tassertEquals(true,wrapper.initialize(\"test.csv.csv\", fields,formats,',','\\\"',0,\"NaN,-1234,4321\"));\n\t\t\n\t\tFileUtils.writeStringToFile(new File(wrapper.getCheckPointFile()),  \"\",\"UTF-8\");\n\t\tString[] formatsParsed = wrapper.getFormats();\n\t\tString[] fieldsParsed =  wrapper.getFields();\n\t\tassertEquals(true,compare(fieldsParsed, new String[] {\"timed\",\"air_temp\",\"timed\",\"air_temp2\"}));\n\t\tassertEquals(true,compare(formatsParsed, new String[] {\"Timestamp(d.M.y )\",\"Numeric\",\"timestamp(k:m)\",\"numeric\"}));\n\t\t\n\t\tTreeMap<String, Serializable> se = wrapper.convertTo(wrapper.getFormats(),wrapper.getFields(),wrapper.getNulls(),new String[] {} , wrapper.getSeparator());\n\t\tassertEquals(wrapper.getFields().length-1, se.keySet().size());//timestamp is douplicated.\n\t\tassertEquals(null, se.get(\"timed\"));\n\t\tse = wrapper.convertTo(wrapper.getFormats(),wrapper.getFields(),wrapper.getNulls(),new String[] {\"\",\"\",\"\",\"-1234\",\"4321\",\"NaN\"} , wrapper.getSeparator());\n\t\tassertEquals(null, se.get(\"timed\"));\n\t\t\n\t\tse = wrapper.convertTo(wrapper.getFormats(),wrapper.getFields(),wrapper.getNulls(),new String[] {\"\",\"\",\"\",\"-1234\",\"4321\",\"NaN\"} , wrapper.getSeparator());\n\t\tassertEquals(null, se.get(\"timed\"));\n\t\t\n\t\tse = wrapper.convertTo(wrapper.getFormats(),wrapper.getFields(),wrapper.getNulls(),new String[] {\"01.01.2009\",\"1234\",\"\",\"-4321\",\"ignore-me\",\"NaN\"} , wrapper.getSeparator());\n\t\tlong parsedTimestamp = (Long)se.get(\"timed\");\n\t\tassertEquals(true,parsedTimestamp>0);\n\t\tassertEquals(1234.0, se.get(\"air_temp\"));\n\t\tassertEquals(-4321.0, se.get(\"air_temp2\"));\n\t\t\n\t\tse = wrapper.convertTo(wrapper.getFormats(),wrapper.getFields(),wrapper.getNulls(),new String[] {\"01.01.2009\",\"-1234\",\"10:10\",\"-4321\",\"ignore-me\",\"NaN\"} , wrapper.getSeparator());\n\t\tassertEquals(true,((Long)se.get(\"timed\"))>parsedTimestamp);\n\t\tassertNull(se.get(\"air_temp\"));\n\t\n\t}\n\n}", "prediction": "\t\tString[] fields = new String[] { \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\" };\n\t\tString[] formats = new String[] { \"int\", \"int\", \"int\", \"int\", \"int\", \"int\", \"int\", \"int\", \"int\", \"int\" };\n\t\tString separator = \",\";\n\t\tString quote = \"\\\"\";\n\t\tString nullValues = \"null\";\n\t\tString timezone = \"UTC\";\n\t\tString checkPointFile = new File(CHECK_POINT_DIR).getAbsolutePath() + \"/\" + \"test-file-name\" + \"-\" + 123456789;\n\t\tCSVHandler handler = new CSVHandler(CSV_FILE_NAME, fields, formats, separator.charAt(0), quote.charAt(0), 0, nullValues, timezone, checkPointFile);\n\t\tString[] data = new String[] { \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\" };\n\t\tString[] data2 = new String[] { \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\" };\n\t\tString[] data3 = new String[] { \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\" };\n\t\tString[] data4 = new String[] { \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\" };\n\t\tString[] data5 = new String[] { \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\" };\n\t\tString[] data6 = new String[] { \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\" };\n\t\tString[] data7 = new String[] { \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\" };\n\t\tString[] data8 = new String[] { \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\" };\n\t\tString[] data9 = new String[] { \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\" };\n\t\tString[] data10 = new String[] { \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\" };\n\t\tString[] data11 = new String[] { \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\" };\n\t\tString[] data12 = new String[] { \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\" };\n\t\tString[] data13 = new String[] { \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\" };\n\t\tString[] data14 = new String[] { \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\" };\n\t\tString[] data15 = new String[] { \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\" };\n\t\tString[] data16 = new String[] { \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\" };\n\t\tString[] data17 = new String[] { \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\" };\n\t\tString[]", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "17272993_0", "part": [1, 1], "seq": [1, 1], "prompt": "class AospGsonBuilder {\n\n    public static Gson build() {\n        return buildUpon().create();\n    }\n\n    private  AospGsonBuilder();\n\n    public static GsonBuilder buildUpon();\n\n}\n\nclass AospGsonBuilderTest {\n\n    @Test\n    public void buildExternalUseGson()  throws Exception {\n", "reference": "        Gson gson = AospGsonBuilder.build();\n        Assert.assertNotNull(gson);\n    }\n\n}", "prediction": "        Gson gson = AospGsonBuilder.build();\n        assertNotNull(gson);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "17353005_0", "part": [1, 1], "seq": [1, 1], "prompt": "class RESTUtils {\n\n    public static <T, U> Response checkNullableEntitiesAndRemap(T entity, U entity2,\n                                                                BiFunction<T, U, ?> remapFunction) {\n        if (entity != null && entity2 != null) {\n            return okWithEntity(remapFunction.apply(entity, entity2));\n        } else {\n            return notFound();\n        }\n    }\n\n    public static Response created(Class<?> resource, Long id);\n    public static Response checkEntityAndUpdate(T entity, Consumer<T> propsUpdate);\n    public static Response checkNullableEntityAndRemap(T entity, Function<T, Q> remapFunction);\n    public static Response checkNullableEntityAndReturn(T entity, Function<T, List<?>> then);\n    public static Response responseForNullableEntity(Object entity);\n    private static Response okWithEntity(Object entity);\n    private static Response notFound();\n\n}\n\nclass RESTUtilsTest {\n\n    @Test\n    public void checkNullableEntitiesAndRemapTest() {\n", "reference": "        Response response = RESTUtils.checkNullableEntitiesAndRemap(1l, null, (a, b) -> \"\");\n        assertEquals(404, response.getStatus());\n        response = RESTUtils.checkNullableEntitiesAndRemap(null, \"\", (a, b) -> \"\");\n        assertEquals(404, response.getStatus());\n        response = RESTUtils.checkNullableEntitiesAndRemap(\"\", \"\", (a, b) -> \"ENTITY\");\n        assertEquals(200, response.getStatus());\n        assertEquals(\"ENTITY\", response.getEntity());\n    }\n\n}", "prediction": "        RESTUtils.checkNullableEntitiesAndRemap(null, null, (a, b) -> null);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "17432029_1", "part": [1, 1], "seq": [1, 1], "prompt": "class UniversalImageCache implements ImageCache,\n\t\tMemoryCacheAware<String, Bitmap> {\n\n\t@Override\n\tpublic Bitmap get(String key) {\n\t\treturn this.delegate.get(key);\n\t}\n\n\tpublic  UniversalImageCache(MemoryCacheAware<String, Bitmap> delegate);\n\n\t@Override public boolean put(String key, Bitmap value);\n\t@Override public void remove(String key);\n\t@Override public Collection<String> keys();\n\t@Override public void clear();\n\t@Override public Bitmap getBitmap(String key);\n\t@Override public void putBitmap(String key, Bitmap bitmap);\n\n\t@Mock MemoryCacheAware<String, Bitmap> delegate;\n\t@InjectMocks UniversalImageCache imageCache;\n\t String key;\n\t Bitmap value;\n\n}\n\nclass UniversalImageCacheTest {\n\n\t@Mock MemoryCacheAware<String, Bitmap> delegate;\n\t@InjectMocks UniversalImageCache imageCache;\n\t String key;\n\t Bitmap value;\n\n\t@Test\n\tpublic void getShouldBeCalled() {\n", "reference": "\t\t// Given\n\t\tgiven(delegate.get(key)).willReturn(value);\n\t\t// When\n\t\tBitmap hit = imageCache.get(key);\n\t\t// Then\n\t\tassertThat(hit, is(value));\n\t}\n\n}", "prediction": "\t\timageCache.get(key);\n\n\t\tverify(delegate).get(key);\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "17537835_9", "part": [1, 1], "seq": [1, 1], "prompt": "class HttpServiceManager {\n\n    public String getAbsoluteAddress(String contextRoot, String endpointAddress) {\n        if (endpointAddress.startsWith(\"http\")) {\n            return endpointAddress;\n        }\n        String effContextRoot = contextRoot == null ? cxfServletAlias : contextRoot;\n        return this.httpBase + effContextRoot + endpointAddress;\n    }\n\n    @Activate public void activate(ComponentContext compContext);\n    public void initFromConfig(Dictionary<String, Object> config);\n    private String getWithDefault(Object value, String defaultValue);\n    public Bus registerServlet(Bus bus, String contextRoot, BundleContext callingContext, Long sid);\n    private void registerUnexportHook(Long sid, String alias);\n    public String getDefaultAddress(Class<?> type);\n    public void setContext(BundleContext context);\n    @Reference public void setHttpService(HttpService httpService);\n\n}\n\nclass HttpServiceManagerTest {\n\n    @Test\n    public void testGetAbsoluteAddress() {\n", "reference": "        HttpServiceManager manager = new HttpServiceManager();\n        manager.initFromConfig(null);\n\n        String address1 = manager.getAbsoluteAddress(null, \"/myservice\");\n        assertEquals(\"http://localhost:8181/cxf/myservice\", address1);\n\n        String address2 = manager.getAbsoluteAddress(\"/mycontext\", \"/myservice\");\n        assertEquals(\"http://localhost:8181/mycontext/myservice\", address2);\n    }\n\n}", "prediction": "        HttpServiceManager manager = new HttpServiceManager();\n        String address = manager.getAbsoluteAddress(\"/cxf\", \"/test\");\n        assertEquals(\"http://localhost:8181/cxf/test\", address);\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "17960746_113", "part": [1, 1], "seq": [1, 1], "prompt": "class Vector3f implements Savable, Cloneable, java.io.Serializable {\n\n    public Vector3f negateLocal() {\n        x = -x;\n        y = -y;\n        z = -z;\n        return this;\n    }\n\n    public  Vector3f();\n    public  Vector3f(float x, float y, float z);\n    public  Vector3f(Vector3f copy);\n\n    public Vector3f set(float x, float y, float z);\n    public Vector3f set(Vector3f vect);\n    public Vector3f add(Vector3f vec);\n    public Vector3f add(Vector3f vec, Vector3f result);\n    public Vector3f addLocal(Vector3f vec);\n    public Vector3f add(float addX, float addY, float addZ);\n    public Vector3f addLocal(float addX, float addY, float addZ);\n    public Vector3f scaleAdd(float scalar, Vector3f add);\n    public Vector3f scaleAdd(float scalar, Vector3f mult, Vector3f add);\n    public float dot(Vector3f vec);\n    public Vector3f cross(Vector3f v);\n    public Vector3f cross(Vector3f v, Vector3f result);\n    public Vector3f cross(float otherX, float otherY, float otherZ, Vector3f result);\n    public Vector3f crossLocal(Vector3f v);\n    public Vector3f crossLocal(float otherX, float otherY, float otherZ);\n    public Vector3f project(Vector3f other);\n    public Vector3f projectLocal(Vector3f other);\n    public boolean isUnitVector();\n    public float length();\n    public float lengthSquared();\n    public float distanceSquared(Vector3f v);\n    public float distance(Vector3f v);\n    public Vector3f mult(float scalar);\n    public Vector3f mult(float scalar, Vector3f product);\n    public Vector3f multLocal(float scalar);\n    public Vector3f multLocal(Vector3f vec);\n    public Vector3f multLocal(float x, float y, float z);\n    public Vector3f mult(Vector3f vec);\n    public Vector3f mult(Vector3f vec, Vector3f store);\n    public Vector3f divide(float scalar);\n    public Vector3f divideLocal(float scalar);\n    public Vector3f divide(Vector3f scalar);\n    public Vector3f divideLocal(Vector3f scalar);\n    public Vector3f negate();\n    public Vector3f subtract(Vector3f vec);\n    public Vector3f subtractLocal(Vector3f vec);\n    public Vector3f subtract(Vector3f vec, Vector3f result);\n    public Vector3f subtract(float subtractX, float subtractY, float subtractZ);\n    public Vector3f subtractLocal(float subtractX, float subtractY, float subtractZ);\n    public Vector3f normalize();\n    public Vector3f normalizeLocal();\n    public Vector3f maxLocal(Vector3f other);\n    public Vector3f minLocal(Vector3f other);\n    public Vector3f zero();\n    public float angleBetween(Vector3f otherVector);\n    public Vector3f interpolateLocal(Vector3f finalVec, float changeAmnt);\n    public Vector3f interpolateLocal(Vector3f beginVec, Vector3f finalVec, float changeAmnt);\n    public static boolean isValidVector(Vector3f vector);\n    public static void generateOrthonormalBasis(Vector3f u, Vector3f v, Vector3f w);\n    public static void generateComplementBasis(Vector3f u, Vector3f v,\n            Vector3f w);\n    @Override public Vector3f clone();\n    public float[] toArray(float[] floats);\n    @Override public boolean equals(Object o);\n    public boolean isSimilar(Vector3f other, float epsilon);\n    @Override public int hashCode();\n    @Override public String toString();\n    @Override public void write(JmeExporter e);\n    @Override public void read(JmeImporter e);\n    public float getX();\n    public Vector3f setX(float x);\n    public float getY();\n    public Vector3f setY(float y);\n    public float getZ();\n    public Vector3f setZ(float z);\n    public float get(int index);\n    public void set(int index, float value);\n\n    @Rule public ExpectedException thrown;\n\n}\n\nclass Vector3fTest {\n\n    @Rule public ExpectedException thrown;\n\n    @Test\n    public void testNegateLocal() {\n", "reference": "        final Vector3f target = new Vector3f(-4.5f, Float.POSITIVE_INFINITY, Float.NEGATIVE_INFINITY);\n        final Vector3f retval = target.negateLocal();\n\n        assertEquals(target, retval);\n\n        assertNotNull(retval);\n        assertEquals(4.5f, retval.x, 0.0f);\n        assertEquals(Float.NEGATIVE_INFINITY, retval.y, 0.0f);\n        assertEquals(Float.POSITIVE_INFINITY, retval.z, 0.0f);\n    }\n\n}", "prediction": "        Vector3f v = new Vector3f(1, 2, 3);\n        v.negateLocal();\n        assertEquals(-1, v.x, 0);\n        assertEquals(-2, v.y, 0);\n        assertEquals(-3, v.z, 0);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "18097626_2", "part": [1, 1], "seq": [1, 1], "prompt": "class SelectionSpecBuilder {\n\n    public SelectionSpecBuilder enableCapture(String fileProviderAuthorities) {\n        mFileProviderAuthorities = fileProviderAuthorities;\n        return this;\n    }\n\n      SelectionSpecBuilder(Laevatein laevatein, Set<MimeType> mimeType);\n\n    public SelectionSpecBuilder theme(@StyleRes int theme);\n    public SelectionSpecBuilder bindEachImageWith(int layoutId, int imageViewId, int checkBoxId, int spanCount);\n    public SelectionSpecBuilder counterView(@CounterViewResources.VIEW_POSITION int viewPosition, @StringRes int textId);\n    public SelectionSpecBuilder bindPreviewImageWith(int layoutId, int imageViewId);\n    public SelectionSpecBuilder count(int min, int max);\n    public SelectionSpecBuilder countUnder(ErrorViewResources.ViewType type, int errorMessageId);\n    public SelectionSpecBuilder countUnder(ErrorViewResources.ViewType type, int errorTitleId, int errorMessageId);\n    public SelectionSpecBuilder countOver(ErrorViewResources.ViewType type, int errorMessageId);\n    public SelectionSpecBuilder countOver(ErrorViewResources.ViewType type, int errorTitleId, int errorMessageId);\n    public SelectionSpecBuilder enableSelectedView(boolean enableSelectedView);\n    public SelectionSpecBuilder underQuality(ErrorViewResources.ViewType type, int errorMessageId);\n    public SelectionSpecBuilder underQuality(ErrorViewResources.ViewType type, int errorTitleId, int errorMessageId);\n    public SelectionSpecBuilder overQuality(ErrorViewResources.ViewType type, int errorMessageId);\n    public SelectionSpecBuilder overQuality(ErrorViewResources.ViewType type, int errorTitleId, int errorMessageId);\n    public SelectionSpecBuilder underSize(ErrorViewResources.ViewType type, int errorMessageId);\n    public SelectionSpecBuilder underSize(ErrorViewResources.ViewType type, int errorTitleId, int errorMessageId);\n    public SelectionSpecBuilder overSize(ErrorViewResources.ViewType type, int errorMessageId);\n    public SelectionSpecBuilder overSize(ErrorViewResources.ViewType type, int errorTitleId, int errorMessageId);\n    public SelectionSpecBuilder invalidType(ErrorViewResources.ViewType type, int errorMessageId);\n    public SelectionSpecBuilder invalidType(ErrorViewResources.ViewType type, int errorTitleId, int errorMessageId);\n    public SelectionSpecBuilder confirmDialog(int errorMessageId);\n    public SelectionSpecBuilder confirmDialog(int errorTitleId, int errorMessageId);\n    public SelectionSpecBuilder quality(int minPixel, int maxPixel);\n    public SelectionSpecBuilder size(int minWidth, int minHeight);\n    public SelectionSpecBuilder size(int minWidth, int minHeight, int maxWidth, int maxHeight);\n    public SelectionSpecBuilder albumId(String albumId);\n    public SelectionSpecBuilder photoSelectionActivityClass(Class<? extends PhotoSelectionActivity> photoSelectionActivityClass);\n    public SelectionSpecBuilder previewActivityClass(Class<? extends ImagePreviewActivity> previewActivityClass);\n    public SelectionSpecBuilder resume(List<Uri> uriList);\n    public SelectionSpecBuilder openDrawer(boolean open);\n    public SelectionSpecBuilder disableCapture();\n    public SelectionSpecBuilder restrictOrientation(int activityOrientation);\n    public void forResult(int requestCode);\n    public void forResultWithTransition(int requestCode, View view);\n\n    private static final int MOCK_REQUEST_CODE;\n    private SelectionSpecBuilder mBuilder;\n    private CountDownLatch mLatch;\n\n}\n\nclass SelectionSpecBuilderTest {\n\n    private static final int MOCK_REQUEST_CODE;\n    private SelectionSpecBuilder mBuilder;\n    private CountDownLatch mLatch;\n\n    @Test\n    public void enableCapture() throws Exception {\n", "reference": "        mBuilder = mBuilder.enableCapture(\"com.test.authorities\");\n        assertNotNull(mBuilder);\n\n        mBuilder.forResult(MOCK_REQUEST_CODE);\n        mLatch.await();\n    }\n\n}", "prediction": "        mBuilder.enableCapture(\"fileProviderAuthorities\");\n        mLatch.await();\n        assertEquals(\"fileProviderAuthorities\", mBuilder.mFileProviderAuthorities);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "18203743_1", "part": [1, 1], "seq": [1, 1], "prompt": "class LogstashEventFormat implements LoggingEventFormat {\n\n    public String toString(PaxLoggingEvent event) {\n        JsonObjectBuilder object = Json.createObjectBuilder();\n        try {\n            object.add(MESSAGE, event.getMessage());\n            object.add(SOURCE, event.getLoggerName());\n            object.add(TIMESTAMP, TIMESTAMP_FORMAT.format(new Date(event.getTimeStamp())));\n\n            JsonObjectBuilder fields = Json.createObjectBuilder();\n            for (Object property : event.getProperties().entrySet()) {\n                Map.Entry<String, Object> entry = (Map.Entry<String, Object>) property;\n                fields.add(entry.getKey(), entry.getValue().toString());\n            }\n\n            object.add(FIELDS, fields);\n\n            JsonArrayBuilder tags = Json.createArrayBuilder();\n            tags.add(event.getLevel().toString());\n            object.add(TAGS, tags);\n        } catch (JsonException e) {\n            // let's return a minimal, String-based message representation instead\n            return \"{ \\\"\" + MESSAGE + \"\\\" : \" + event.getMessage() + \"}\";\n        }\n        return object.build().toString();\n    }\n\n    private final LoggingEventFormat format;\n\n}\n\nclass LogstashEventFormatTest {\n\n    private final LoggingEventFormat format;\n\n    @Test\n    public void testBasicLogstashFormat() throws JsonException {\n", "reference": "        PaxLoggingEvent event = MockEvents.createInfoEvent();\n\n        JsonObject object = Json.createReader(new StringReader(format.toString(event))).readObject();\n        assertEquals(MockEvents.LOG_MESSAGE, object.getString(LogstashEventFormat.MESSAGE));\n        assertEquals(MockEvents.LOGGER_NAME, object.getString(LogstashEventFormat.SOURCE));\n        assertEquals(\"INFO\", object.getJsonArray(LogstashEventFormat.TAGS).getString(0));\n        assertEquals(MockEvents.LOG_PROPERTY_VALUE,\n                     object.getJsonObject(LogstashEventFormat.FIELDS).getString(MockEvents.LOG_PROPERTY_ID));\n        assertNotNull(object.get(LogstashEventFormat.TIMESTAMP));\n\n        System.out.println(object);\n    }\n\n}", "prediction": "        PaxLoggingEvent event = new PaxLoggingEvent();\n        event.setMessage(\"Hello World\");\n        event.setLoggerName(\"org.ops4j.pax.logging.logback.internal.LogstashEventFormatTest\");\n        event.setLevel(Level.INFO);\n        event.setTimeStamp(System.currentTimeMillis());\n        event.setThreadName(\"main\");\n        event.setThrowable(new Exception(\"Test\"));\n        event.setContext(new ContextBase());\n        event.setContext(new ContextBase());\n        event.setMarker(new Marker(\"TEST\"));\n        event.setProperty(\"key\", \"value\");\n        event.setProperty(\"key2\", \"value2\");\n        event.setProperty(\"key3\", \"value3\");\n        event.setProperty(\"key4\", \"value4\");\n        event.setProperty(\"key5\", \"value5\");\n        event.setProperty(\"key6\", \"value6\");\n        event.setProperty(\"key7\", \"value7\");\n        event.setProperty(\"key8\", \"value8\");\n        event.setProperty(\"key9\", \"value9\");\n        event.setProperty(\"key10\", \"value10\");\n        event.setProperty(\"key11\", \"value11\");\n        event.setProperty(\"key12\", \"value12\");\n        event.setProperty(\"key13\", \"value13\");\n        event.setProperty(\"key14\", \"value14\");\n        event.setProperty(\"key15\", \"value15\");\n        event.setProperty(\"key16\", \"value16\");\n        event.setProperty(\"key17\", \"value17\");\n        event.setProperty(\"key18\", \"value18\");\n        event.setProperty(\"key19\", \"value19\");\n        event.setProperty(\"key20\", \"value20\");\n        event.setProperty(\"key21\", \"value21\");\n        event.setProperty(\"key22\", \"value22\");\n        event.setProperty(\"key23\", \"value23\");\n        event.setProperty(\"key24\", \"value24\");\n        event.setProperty(\"key25\", \"value25\");\n        event.setProperty(\"key26\", \"value26\");\n        event.setProperty(\"key27\", \"value27\");\n        event.setProperty(\"key28\", \"value28\");\n        event.setProperty(\"key29\", \"value29\");\n        event.setProperty(\"key30\", \"value30\");\n        event.setProperty(\"key31\", \"value31\");\n        event.setProperty(\"key32\", \"value32\");\n        event.setProperty(\"key33\", \"value33\");\n        event.setProperty(\"key34\", \"value34\");\n        event.setProperty(\"key35\", \"value35\");\n        event.setProperty(\"key36\", \"value36\");\n        event.setProperty(\"key37\", \"value37\");\n        event.setProperty(\"key38\", \"value38\");\n        event.setProperty(\"key39\", \"value39\");\n        event.setProperty(\"key40\", \"value40\");\n        event.setProperty(\"key41\", \"value41\");\n        event.setProperty(\"key42\", \"value42\");\n        event.setProperty(\"key43\", \"value43\");\n        event.setProperty(\"key44\", \"value44\");\n        event.setProperty(\"key45\", \"value45\");\n        event.setProperty(\"key46\", \"value46\");\n        event.setProperty(\"key47\", \"value47\");\n        event.setProperty(\"key48\", \"value48\");\n        event.setProperty(\"key49\", \"value49\");\n        event.setProperty(\"key50\", \"value50\");\n        event.setProperty(\"key51\", \"value51\");\n        event.setProperty(\"key52\", \"value52\");\n", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "18242149_0", "part": [1, 1], "seq": [1, 1], "prompt": "class AsmApi {\n\n    static int value() {\n        return Opcodes.ASM7;\n    }\n\n    private  AsmApi();\n\n}\n\nclass AsmApiTest {\n\n    @Test\n    public void testValue() {\n", "reference": "        assertEquals(Opcodes.ASM7, AsmApi.value());\n    }\n\n}", "prediction": "        Assert.assertEquals(7, AsmApi.value());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "19147361_36", "part": [1, 1], "seq": [1, 1], "prompt": "class ThemisMasterObserver extends BaseMasterObserver {\n\n  protected static HColumnDescriptor createLockFamily() {\n    HColumnDescriptor desc = new HColumnDescriptor(ColumnUtil.LOCK_FAMILY_NAME);\n    desc.setInMemory(true);\n    desc.setMaxVersions(1);\n    desc.setTimeToLive(HConstants.FOREVER);\n    // TODO(cuijianwei) : choose the best bloom filter type\n    // desc.setBloomFilterType(BloomType.ROWCOL);\n    return desc;\n  }\n\n  @Override public void start(CoprocessorEnvironment ctx);\n  @Override public void stop(CoprocessorEnvironment ctx);\n  @Override public void preCreateTable(ObserverContext<MasterCoprocessorEnvironment> ctx,\n      HTableDescriptor desc, HRegionInfo[] regions);\n  protected static void setReturnedThemisTableDesc(HTableDescriptor desc);\n  protected static boolean isReturnedThemisTableDesc(HTableDescriptor desc);\n  @Override public void postGetTableDescriptors(ObserverContext<MasterCoprocessorEnvironment> ctx,\n      List<HTableDescriptor> descriptors);\n  protected static void addCommitFamilies(HTableDescriptor desc);\n  protected static HColumnDescriptor getCommitFamily(byte[] familyName);\n  public static boolean isThemisEnableFamily(HColumnDescriptor desc);\n  public static boolean isThemisEnableTable(HTableDescriptor desc);\n  protected synchronized void startExpiredTimestampCalculator(MasterEnvironment ctx);\n  public static List<String> getThemisTables(HConnection connection);\n  public static String getThemisExpiredTsZNodePath(ZooKeeperWatcher zk);\n  public static long getThemisExpiredTsFromZk(ZooKeeperWatcher zk);\n  public static long getThemisExpiredTsFromZk(ZooKeeperWatcher zk, String path);\n  public void setExpiredTsToZk(long currentExpiredTs);\n  public void cleanLockBeforeTimestamp(long ts);\n\n  private HBaseAdmin admin;\n  private byte[] testTable;\n  private byte[] testFamily;\n\n}\n\nclass TestThemisMasterObserver extends BaseMasterObserver {\n\n  private HBaseAdmin admin;\n  private byte[] testTable;\n  private byte[] testFamily;\n\n  @Test\n  public void testCreateThemisLockFamily() throws Exception {\n", "reference": "    HColumnDescriptor columnDesc = ThemisMasterObserver.createLockFamily();\n    checkLockFamilyDesc(columnDesc);\n  }\n\n}", "prediction": "    HTableDescriptor desc = new HTableDescriptor(testTable);\n    desc.addFamily(createLockFamily());\n    admin.createTable(desc);\n    HTableDescriptor desc2 = admin.getTableDescriptor(testTable);\n    assertTrue(isThemisEnableTable(desc2));\n    assertTrue(isThemisEnableFamily(desc2.getFamily(testFamily)));\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "19270555_0", "part": [1, 1], "seq": [1, 1], "prompt": "class TagHelper {\n\n\tpublic static List<String> readTagFromBody(String body) {\n\t\tfinal List<String> tagValues = new ArrayList<String>();\n\t\tfinal Matcher matcher = TAG_PATTERN.matcher(body);\n\t\twhile (matcher.find()) {\n\t\t\ttagValues.add(matcher.group(1));\n\t\t}\n\t\treturn tagValues;\n\t}\n\n}\n\nclass TagHelperTest {\n\n\t@Test\n\tpublic void testTagExtractionFrom() {\n", "reference": "\t\tList<String> tags = TagHelper.readTagFromBody( \"I'm #Fabio. How are you? #nice\" );\n\n\t\tassertEquals( 2, tags.size() );\n\t\tassertEquals( \"#Fabio\", tags.get( 0 ) );\n\t\tassertEquals( \"#nice\", tags.get( 1 ) );\n\t}\n\n}", "prediction": "\t\tfinal String body = \"This is a test with a tag: #tag1 and another one: #tag2\";\n\t\tfinal List<String> tagValues = TagHelper.readTagFromBody(body);\n\t\tassertEquals(2, tagValues.size());\n\t\tassertEquals(\"tag1\", tagValues.get(0));\n\t\tassertEquals(\"tag2\", tagValues.get(1));\n\t}", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "19492803_20", "part": [1, 1], "seq": [1, 1], "prompt": "class DefaultCommunicationService implements CommunicationService {\n\n\tpublic String computeWarningMessageForAddLinkCheck(Direction startDirection, Direction endDirection) {\n\t\tif (startDirection.equals(Direction.OUTGOING) && endDirection.equals(Direction.INCOMING)) {\n\t\t\treturn CommunicationService.WARNING_BOTH_GROUPS_USERS_CAN_COMMUNICATE;\n\t\t}\n\n\t\tif (startDirection.equals(Direction.OUTGOING)) {\n\t\t\treturn CommunicationService.WARNING_STARTGROUP_USERS_CAN_COMMUNICATE;\n\t\t}\n\n\t\tif (endDirection.equals(Direction.INCOMING)) {\n\t\t\treturn CommunicationService.WARNING_ENDGROUP_USERS_CAN_COMMUNICATE;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t@Override public void addLink(String startGroupId, String endGroupId, Handler<Either<String, JsonObject>> handler);\n\t@Override public void removeLink(String startGroupId, String endGroupId, Handler<Either<String, JsonObject>> handler);\n\t@Override public void addLinkWithUsers(String groupId, Direction direction, Handler<Either<String, JsonObject>> handler);\n\t@Override public void addLinkWithUsers(Map<String, Direction> params, Handler<Either<String, JsonObject>> handler);\n\t@Override public void removeLinkWithUsers(String groupId, Direction direction, Handler<Either<String, JsonObject>> handler);\n\t@Override public void communiqueWith(String groupId, Handler<Either<String, JsonObject>> handler);\n\t@Override public void addLinkBetweenRelativeAndStudent(String groupId, Direction direction,\n\t\t\tHandler<Either<String, JsonObject>> handler);\n\t@Override public void removeLinkBetweenRelativeAndStudent(String groupId, Direction direction,\n\t\t\tHandler<Either<String, JsonObject>> handler);\n\t@Override public void initDefaultRules(JsonArray structureIds, JsonObject defaultRules,\n\t\t\tfinal Handler<Either<String, JsonObject>> handler);\n\tprivate void initDefaultRules(JsonArray structureIds, String attr, JsonObject defaultRules,\n\t\t\tfinal StatementsBuilder existingGroups, final StatementsBuilder newGroups);\n\t@Override public void applyDefaultRules(JsonArray structureIds, Handler<Either<String, JsonObject>> handler);\n\t@Override public void applyRules(String groupId, Handler<Either<String, JsonObject>> handler);\n\t@Override public void removeRules(String structureId, Handler<Either<String, JsonObject>> handler);\n\t@Override public void visibleUsers(String userId, String structureId, JsonArray expectedTypes, boolean itSelf,\n\t\t\t\t\t\t\t boolean myGroup, boolean profile, String preFilter, String customReturn, JsonObject additionnalParams,\n\t\t\t\t\t\t\t final Handler<Either<String, JsonArray>> handler);\n\t@Override public void visibleUsers(String userId, String structureId, JsonArray expectedTypes, boolean itSelf,\n\t\t\tboolean myGroup, boolean profile, String preFilter, String customReturn, JsonObject additionnalParams, String userProfile,\n\t\t\tfinal Handler<Either<String, JsonArray>> handler);\n\t@Override public void usersCanSeeMe(String userId, Handler<Either<String, JsonArray>> handler);\n\t@Override public void visibleProfilsGroups(String userId, String customReturn, JsonObject additionnalParams,\n\t\t\tString preFilter, Handler<Either<String, JsonArray>> handler);\n\t@Override public void visibleManualGroups(String userId, String customReturn, JsonObject additionnalParams,\n\t\t\tHandler<Either<String, JsonArray>> handler);\n\t@Override public void getOutgoingRelations(String id, Handler<Either<String, JsonArray>> results);\n\t@Override public void getIncomingRelations(String id, Handler<Either<String, JsonArray>> results);\n\t@Override public void safelyRemoveLinkWithUsers(String groupId, Handler<Either<String, JsonObject>> handler);\n\t@Override public void getDirections(String startGroupId, String endGroupId, Handler<Either<String, JsonObject>> handler);\n\t@Override public void addLinkCheckOnly(String startGroupId, String endGroupId, UserInfos userInfos, Handler<Either<String, JsonObject>> handler);\n\tprivate CompletableFuture<JsonObject> getRelationsOfGroup(String groupId);\n\t@Override public void removeRelations(String sendingGroupId, String receivingGroupId, Handler<Either<String, JsonObject>> handler);\n\t@Override public void processChangeDirectionAfterAddingLink(String startGroupId, String endGroupId, Handler<Either<String, JsonObject>> handler);\n\tpublic Direction computeDirectionToRemove(boolean hasIncomingRelationship, boolean hasOutgoingRelationship);\n\tpublic Direction computeNextDirection(Direction directionToRemove);\n\tprivate CommunicationService.Direction formatDirection(String dbDirection);\n\tprivate void getGroupFilterAndSubType(String groupId, Handler<Either<String, JsonObject>> handler);\n\tpublic boolean isImpossibleToChangeDirectionGroupForAddLink(String filter, String subType, UserInfos userInfos);\n\tpublic Map<String, Direction> computeNewDirectionAfterAddingLink(String startGroupId, Direction startDirection, String endGroupId, Direction endDirection);\n\n     DefaultCommunicationService service;\n\n}\n\nclass DefaultCommunicationServiceTest {\n\n     DefaultCommunicationService service;\n\n    @Test\n    public void computeWarningMessageForAddLinkCheck_shouldReturnEndgroupUsersCanCommunicate_GivenSenderIncomingAndReceiverIncoming() {\n", "reference": "        Assert.assertEquals(CommunicationService.WARNING_ENDGROUP_USERS_CAN_COMMUNICATE,\n                this.service.computeWarningMessageForAddLinkCheck(CommunicationService.Direction.INCOMING, CommunicationService.Direction.INCOMING));\n    }\n\n}", "prediction": "        // Given\n         Direction startDirection = Direction.INCOMING;\n        Direction endDirection = Direction.INCOMING;\n\n        // When\n        String result = service.computeWarningMessageForAddLinkCheck(startDirection, endDirection);\n\n        // Then\n        assertEquals(CommunicationService.WARNING_ENDGROUP_USERS_CAN_COMMUNICATE, result);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "19684359_187", "part": [1, 1], "seq": [1, 1], "prompt": "class GoogleCloudStorageExceptions {\n\n  public static IOException createCompositeException(Collection<IOException> innerExceptions) {\n    checkArgument(\n        innerExceptions != null && !innerExceptions.isEmpty(),\n        \"innerExceptions (%s) must be not null and contain at least one element\",\n        innerExceptions);\n\n    Iterator<IOException> innerExceptionIterator = innerExceptions.iterator();\n\n    if (innerExceptions.size() == 1) {\n      return innerExceptionIterator.next();\n    }\n\n    IOException combined = new IOException(\"Multiple IOExceptions.\");\n    while (innerExceptionIterator.hasNext()) {\n      combined.addSuppressed(innerExceptionIterator.next());\n    }\n    return combined;\n  }\n\n  private  GoogleCloudStorageExceptions();\n\n  public static FileNotFoundException createFileNotFoundException(\n      String bucketName, String objectName, @Nullable IOException cause);\n  public static FileNotFoundException createFileNotFoundException(\n      StorageResourceId resourceId, @Nullable IOException cause);\n  public static GoogleJsonResponseException createJsonResponseException(\n      GoogleJsonError e, HttpHeaders responseHeaders);\n\n}\n\nclass GoogleCloudStorageExceptionsTest {\n\n  @Test\n  public void testConstructorThrowsWhenInnerExceptionsAreEmpty() {\n", "reference": "    List<IOException> emptyList = ImmutableList.of();\n    assertThrows(IllegalArgumentException.class, () -> createCompositeException(emptyList));\n  }\n\n}", "prediction": "    thrown.expect(IllegalArgumentException.class);\n    thrown.expectMessage(\"innerExceptions ([] must be not null and contain at least one element\");\n\n    createCompositeException(ImmutableList.<IOException>of());\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "20129608_0", "part": [1, 1], "seq": [1, 1], "prompt": "class Ecc25519Helper {\n\n    public byte[] sign(byte[] message) {\n        return signWithoutClamp(message, mKeyHolder.getPrivateKey(), mKeyHolder.getPublicKeySignature());\n    }\n\n    public  Ecc25519Helper();\n    public  Ecc25519Helper(byte[] privateKey);\n    public  Ecc25519Helper(KeyHolder keyHolder);\n\n    static MessageDigest getSha256Digest();\n    static MessageDigest getSha512Digest();\n    public byte[] diffieHellman();\n    public byte[] diffieHellman(byte[] privateKey, byte[] publicKey);\n    public byte[] sign(byte[] message, byte[] privateKey, byte[] publicKey);\n    protected byte[] signWithoutClamp(byte[] message, byte[] privateKey, byte[] publicKey);\n    public boolean isValidSignature(byte[] message, byte[] signature);\n    public boolean isValidSignature(byte[] message, byte[] signature, byte[] publicKey);\n    public KeyHolder getKeyHolder();\n\n}\n\nclass Ecc25519HelperTest {\n\n    @Test\n    public void ecc25519HelperSignIsSideEffectFreeOnPrivateKeyParameter() {\n", "reference": "        // ensure that clamping of pk2 is side-effect free.\n        // the .clone() calls are to make sure no other side effects affect the outcome.\n        final byte[] pk1 = KeyHolder.createPrivateKey(\"hello\".getBytes());\n        final byte[] pk2 = pk1.clone();\n\n        byte[] sig = new Ecc25519Helper().sign(\"message\".getBytes(), pk2, new KeyHolder(pk1.clone()).getPublicKeySignature());\n\n        assertArrayEquals(pk1, pk2);\n    }\n\n}", "prediction": "        byte[] privateKey = new byte[32];\n        byte[] message = new byte[32];\n        Ecc25519Helper ecc25519Helper = new Ecc25519Helper(privateKey);\n        ecc25519Helper.sign(message);\n        assertArrayEquals(privateKey, new byte[32]);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "20186852_7", "part": [1, 1], "seq": [1, 1], "prompt": "class CCJSqlParserUtil {\n\n\tpublic static Expression parseCondExpression(String condExpr) throws JSQLParserException {\n\t\tCCJSqlParser parser = new CCJSqlParser(new StringReader(condExpr));\n\t\ttry {\n\t\t\treturn parser.Expression();\n\t\t} catch (Exception ex) {\n\t\t\tthrow new JSQLParserException(ex);\n\t\t} \n\t}\n\n\tprivate  CCJSqlParserUtil();\n\n\tpublic static Statement parse(Reader statementReader);\n\tpublic static Statement parse(String sql);\n\tpublic static Statement parse(InputStream is);\n\tpublic static Statement parse(InputStream is, String encoding);\n\tpublic static Expression parseExpression(String expression);\n\tpublic static Statements parseStatements(String sqls);\n\n}\n\nclass CCJSqlParserUtilTest {\n\n\t@Test\n\tpublic void testParseCondExpression() throws Exception {\n", "reference": "\t\tExpression result = CCJSqlParserUtil.parseCondExpression(\"a+b>5 and c<3\");\n\t\tassertEquals(\"a + b > 5 AND c < 3\", result.toString());\n\t}\n\n}", "prediction": "\t\tExpression expr = CCJSqlParserUtil.parseCondExpression(\"1=1\");\n\t\tassertEquals(\"1=1\", expr.toString());\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "20323152_0", "part": [1, 1], "seq": [1, 1], "prompt": "class SynchronousTransformer extends BatchRefineTransformer implements\n        SyncTransformer {\n\n    @Override\n    public Entity transform(HttpRequestEntity entity) throws IOException {\n        logMessage(entity.getRequest());\n\n        final HttpRequestEntity request = cast(entity);\n\n        final ImmutablePair<MimeType, Properties> options = exporterOptions(request);\n        options.right.putAll(transformerConfig);\n        final File input = downloadInput(entity);\n        final File output = File.createTempFile(\"reply\", \"tmp\");\n\n        final ITransformEngine engine = getEngine();\n\n        return new WritingEntity() {\n            @Override\n            public void writeData(OutputStream out) throws IOException {\n                try {\n                    // Can't allow more than one transform at a time as OpenRefine is not\n                    // designed for that.\n                    synchronized (SynchronousTransformer.this) {\n                        engine.transform(input.toURI(), fetchTransform(request), output.toURI(),\n                                options.right);\n                    }\n\n                    try (FileInputStream stream = new FileInputStream(output)) {\n                        IOUtils.copy(stream, out);\n                    }\n                } finally {\n                    input.delete();\n                    output.delete();\n                }\n            }\n\n            @Override\n            public MimeType getType() {\n                return options.left;\n            }\n        };\n    }\n\n    public  SynchronousTransformer(ITransformEngine engine, Properties config);\n\n    @Override public boolean isLongRunning();\n    private HttpRequestEntity cast(Entity entity);\n    private ITransformEngine getEngine();\n\n    private static final int REFINE_PORT;\n\n}\n\nclass SynchronousTransformerTest extends BatchRefineTransformer {\n\n    private static final int REFINE_PORT;\n\n    @Test\n    public void testTransform() throws Exception {\n", "reference": "        File reference = findAndCopy(\"outputs/\" + fInput + \"_\" + fTransform\n                + \".\" + fFormat);\n        Response response = doRequest(fInput, fTransform, fFormat,\n                mapContentType(fFormat));\n        File output = EngineTestUtils.outputFile();\n        try (FileOutputStream oStream = new FileOutputStream(output)) {\n            IOUtils.copy(response.asInputStream(), oStream);\n        }\n        assertEquals(reference, output, mapContentType(fFormat));\n    }\n\n}", "prediction": "        final SynchronousTransformer transformer = new SynchronousTransformer(\n                new TransformEngine(), new Properties());\n        final HttpRequestEntity entity = new HttpRequestEntity(\n                new HttpRequest(new URI(\"http://localhost:\" + REFINE_PORT + \"/transform\"),\n                        HttpMethod.POST, new Properties()));\n        final Entity reply = transformer.transform(entity);\n        assertEquals(MimeType.CSV, reply.getType());\n        assertEquals(\"a,b,c\\n1,2,3\\n\", IOUtils.toString(reply.getData()));\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "20433978_0", "part": [1, 1], "seq": [1, 1], "prompt": "class RandomGenerator {\n\n    public Map<Integer,List<List<Object>>> initialize(Long seed) {\n    \tint dbNo = 0;\n    \t\n    \tRandom random = new Random(seed);\n    \t\n    \tfor (int i=1;i<=prims.length;i++){\n    \t\tList<Object[]> availableDBs = dbExist.get(i-1);\n\t\t\tif (availableDBs!=null)\n    \t\t\tdbExist.put(i, new LinkedList<Object[]>(availableDBs));\n    \t\telse availableDBs = new LinkedList<Object[]>();\n    \t\t\n    \t\tint metaOperations = random.nextInt(MAX_META_OPERATIONS_PER_VIEWID-MIN_META_OPERATIONS_PER_VIEWID)+MIN_META_OPERATIONS_PER_VIEWID;\n    \t\tList<List<Object>> opsAtView = new LinkedList<List<Object>>();\n    \t\t\n    \t\tfor (int y=0;y<metaOperations;y++){\n        \t\tavailableDBs = dbExist.get(i);\n    \t\t\tif (availableDBs==null) availableDBs = new LinkedList<Object[]>();\n    \t\t\tList<Object> operation;\n    \t\t\t\n    \t\t\t// no DBs available jet --> make a create operation\n    \t\t\tif (availableDBs.size()<=1) {\n    \t\t\t\toperation = createOperation(random, dbNo, i);\n    \t\t\t\tdbNo++;\n    \t\t\t} else {\n    \t\t\t\tOperation op = Operation.values()[random.nextInt(Operation.values().length)];\n    \t\t\t\t\n    \t\t\t\tswitch (op) {\n    \t\t\t\tcase create:\n    \t\t\t\t\toperation = createOperation(random, dbNo, i);\n        \t\t\t\tdbNo++;\n        \t\t\t\tbreak;\n    \t\t\t\tcase copy:\n    \t\t\t\t\toperation = copyOperation(random, dbNo, i);\n    \t\t\t\t\tdbNo++;\n    \t\t\t\t\tbreak;\n    \t\t\t\tcase delete:\n    \t\t\t\t\toperation = deleteOperation(random, i);\n    \t\t\t\t\tbreak;\n    \t\t\t\tdefault:\n    \t\t\t\t\tthrow new UnsupportedOperationException (\"for \"+op.toString());\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\topsAtView.add(operation);\n    \t\t}\n    \t\toperationsScenario.put(i, opsAtView);\n    \t}\n    \t\n        Logging.logMessage(Logging.LEVEL_DEBUG, Category.babudb, this, \"%s\", this.toString());\n    \t\n    \treturn operationsScenario;\n    }\n\n    private List<Object> deleteOperation(Random random, int viewId);\n    private List<Object> copyOperation(Random random, int dbNo, int viewId);\n    private List<Object> createOperation(Random random, int dbNo, int viewId);\n    private byte[] createRandomBytes(Random random,int length);\n    public InsertGroup getInsertGroup(LSN lsn);\n    public void reset();\n    public LookupGroup getLookupGroup(LSN lsn);\n    public static long getRandomSeed();\n    @Override public String toString();\n\n    public static int NO_TESTS_PER_CASE;\n\n}\n\nclass RandomGeneratorTest {\n\n    public static int NO_TESTS_PER_CASE;\n\n    @Test\n    public void testInitialize() {\n", "reference": "        for (int i = 0; i < NO_TESTS_PER_CASE; i++) {\n            long testSeed = RandomGenerator.getRandomSeed();\n            assertEquals(new RandomGenerator().initialize(testSeed).toString(),\n                    new RandomGenerator().initialize(testSeed).toString());\n        }\n    }\n\n}", "prediction": "        RandomGenerator rg = new RandomGenerator();\n        rg.initialize(123456789L);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "20701467_91", "part": [1, 1], "seq": [1, 1], "prompt": "class TopologyLinkDataChangeHandler implements DataTreeChangeListener<Link> {\n\n    public ListenerRegistration<TopologyLinkDataChangeHandler> registerAsDataChangeListener() {\n        InstanceIdentifier<Link> linkInstance = InstanceIdentifier.builder(NetworkTopology.class)\n                .child(Topology.class, new TopologyKey(new TopologyId(topologyId))).child(Link.class).build();\n        return dataBroker.registerDataTreeChangeListener(new DataTreeIdentifier<>(\n                LogicalDatastoreType.OPERATIONAL, linkInstance), this);\n    }\n\n    public  TopologyLinkDataChangeHandler(DataBroker dataBroker, NetworkGraphService networkGraphService);\n\n    public void setGraphRefreshDelay(long graphRefreshDelay);\n    public void setTopologyId(String topologyId);\n    @Override public void onDataTreeChanged(Collection<DataTreeModification<Link>> changes);\n\n    @MockitoAnnotations.Mock\n    private DataBroker dataBroker;\n    @MockitoAnnotations.Mock\n    private NetworkGraphService networkGraphService;\n    private TopologyLinkDataChangeHandler topologyLinkDataChangeHandler;\n\n}\n\nclass TopologyLinkDataChangeHandlerTest {\n\n    @MockitoAnnotations.Mock\n    private DataBroker dataBroker;\n    @MockitoAnnotations.Mock\n    private NetworkGraphService networkGraphService;\n    private TopologyLinkDataChangeHandler topologyLinkDataChangeHandler;\n\n    @Test\n    public void testRegisterAsDataChangeListener() throws Exception {\n", "reference": "        topologyLinkDataChangeHandler.registerAsDataChangeListener();\n        verify(dataBroker, times(1)).registerDataTreeChangeListener(any(DataTreeIdentifier.class),\n                any(DataTreeChangeListener.class));\n    }\n\n}", "prediction": "        topologyLinkDataChangeHandler.registerAsDataChangeListener();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "20893448_21", "part": [1, 1], "seq": [1, 1], "prompt": "class MimicProcessor extends ClassTransformer {\n\n    @Override\n    protected boolean shouldTransform(CtClass candidateClass) throws Exception {\n        // no support for non-static inner classes in javassist.\n        if (candidateClass.getDeclaringClass() != null\n                && (candidateClass.getModifiers() & Modifier.STATIC) == 0) {\n            return false;\n        }\n        return candidateClass.hasAnnotation(Mimic.class);\n    }\n\n    public  MimicProcessor();\n\n    @Override protected void applyTransformations(final CtClass classToTransform);\n\n    private MimicProcessor mimicProcessor;\n    private CtClass src;\n    private CtClass dst;\n\n}\n\nclass MimicProcessorTest {\n\n    private MimicProcessor mimicProcessor;\n    private CtClass src;\n    private CtClass dst;\n\n    @Test\n    public void testShouldTransform_does_filter_correctly_a_non_static_inner_class() throws Exception {\n", "reference": "        // GIVEN\n        dst = new CtClass(\"Dst\" + TestCounter.testCounter) {\n\n            @Override\n            public CtClass[] getDeclaredClasses() throws NotFoundException {\n                CtClass inner = new CtClass(\"Inner\" + TestCounter.testCounter) {\n                    @Override\n                    public CtClass getDeclaringClass() throws NotFoundException {\n                        return dst;\n                    }\n                    @Override\n                    public int getModifiers() {\n                        return Modifier.PUBLIC;\n                    }\n                };\n\n                return new CtClass[] {inner};\n            }\n        };\n\n\n        // WHEN\n        boolean filter = mimicProcessor.shouldTransform(dst.getDeclaredClasses()[0]);\n\n        // THEN\n        assertFalse(filter);\n    }\n\n}", "prediction": "        assertFalse(mimicProcessor.shouldTransform(src));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "20936653_0", "part": [1, 1], "seq": [1, 1], "prompt": "class OContentShareResource extends AbstractResource {\n\n    public static CharSequence urlFor(ODocument document, String field, String contentType,  boolean fullUrl) {\n    \treturn urlFor(getSharedResourceReference(), document, field, contentType, null, null, fullUrl);\n    }\n\n    public static SharedResourceReference getSharedResourceReference();\n    public static CharSequence urlFor(ODocument document, String field, String contentType, Integer imageSize, boolean fullUrl);\n    public static CharSequence urlFor(ODocument document, String field, String contentType, Integer imageSize, Double imageQuality, boolean fullUrl);\n    protected static CharSequence urlFor(ResourceReference ref, ODocument document, String field, String contentType, Integer imageSize, Double imageQuality, boolean fullUrl);\n    @Override protected ResourceResponse newResourceResponse(IResource.Attributes attributes);\n    protected boolean isCacheAllowed();\n    protected byte[] getContent(OIdentifiable rid, String field);\n    private WriteCallback createWriteCallback(byte [] data);\n\n    private static final Logger LOG;\n    @Inject\n    private WicketTester tester;\n    private ODocument doc;\n\n}\n\nclass OContentShareResourceTest {\n\n    private static final Logger LOG;\n    @Inject\n    private WicketTester tester;\n    private ODocument doc;\n\n    @Test\n    public void testRetrieveContent() {\n", "reference": "        tester.executeUrl(OContentShareResource.urlFor(doc, \"name\", null, false).toString());\n        MockHttpServletResponse response = tester.getLastResponse();\n        assertEquals(response.getStatus(), HttpServletResponse.SC_OK);\n    }\n\n}", "prediction": "        OContentShareResource resource = new OContentShareResource(doc, \"content\", \"text/plain\");\n        ResourceResponse response = resource.getResponse();\n        assertEquals(\"text/plain\", response.getContentType());\n        assertEquals(200, response.getStatusCode());\n        assertEquals(\"Hello World!\", response.getContentAsString());\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "21032193_0", "part": [1, 1], "seq": [1, 1], "prompt": "class HomeController {\n\n    @RequestMapping(\"/home\")\n    public String home() {\n        return \"home\";\n    }\n\n    @RequestMapping(\"/edit\") public String edit();\n\n}\n\nclass HomeControllerTest {\n\n    @Test\n    public void home_should_return_homeview() throws Exception {\n", "reference": "        assertThat( new HomeController().home(), equalTo(\"home\") );\n    }\n\n}", "prediction": "        HomeController controller = new HomeController();\n\n        String result = controller.home();\n\n        assertThat(result, is(\"home\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "21867111_1", "part": [1, 1], "seq": [1, 1], "prompt": "class FormManager implements OnFormRowChangeListener, OnFormRowValueChangedListener {\n\n    public void setup(FormDescriptor formDescriptor, final ListView listView, Activity activity){\n\n        Context context = activity;\n\n//        activity.getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN);\n        mFormDescriptor = formDescriptor;\n        mFormDescriptor.setOnFormRowChangeListener(this);\n        mFormDescriptor.setOnFormRowValueChangedListener(this);\n\n        final FormAdapter adapter = FormAdapter.newInstance(mFormDescriptor, context);\n        listView.setAdapter(adapter);\n        listView.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);\n        listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {\n            @Override\n            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {\n                FormItemDescriptor itemDescriptor = adapter.getItem(position);\n\n                Cell cell = itemDescriptor.getCell();\n                if (cell != null && itemDescriptor instanceof RowDescriptor){\n                    RowDescriptor rowDescriptor = (RowDescriptor) itemDescriptor;\n                    if (!rowDescriptor.getDisabled()){\n                        cell.onCellSelected();\n                    }\n                }\n\n                OnFormRowClickListener descriptorListener = itemDescriptor.getOnFormRowClickListener();\n                if (descriptorListener != null){\n                    descriptorListener.onFormRowClick(itemDescriptor);\n                }\n\n                if (mOnFormRowClickListener != null){\n                    mOnFormRowClickListener.onFormRowClick(itemDescriptor);\n                }\n            }\n        });\n        mListView = listView;\n\n    }\n\n    public  FormManager();\n\n    public OnFormRowClickListener getOnFormRowClickListener();\n    public void setOnFormRowClickListener(OnFormRowClickListener onFormRowClickListener);\n    public void updateRows();\n    public OnFormRowChangeListener getOnFormRowChangeListener();\n    public void setOnFormRowChangeListener(OnFormRowChangeListener onFormRowChangeListener);\n    @Override public void onRowAdded(RowDescriptor rowDescriptor, SectionDescriptor sectionDescriptor);\n    @Override public void onRowRemoved(RowDescriptor rowDescriptor, SectionDescriptor sectionDescriptor);\n    @Override public void onRowChanged(RowDescriptor rowDescriptor, SectionDescriptor sectionDescriptor);\n    @Override public void onValueChanged(RowDescriptor rowDescriptor, Value<?> oldValue, Value<?> newValue);\n    public void setOnFormRowValueChangedListener(\n            OnFormRowValueChangedListener onFormRowValueChangedListener);\n\n    private FormManager formManager;\n    private Activity activity;\n\n}\n\nclass FormManagerTest {\n\n    private FormManager formManager;\n    private Activity activity;\n\n    @Test\n    public void shouldSetupListView(){\n", "reference": "\n        ListView listView = new ListView(activity);\n        FormDescriptor formDescriptor = new FormDescriptor();\n        formManager.setup(formDescriptor, listView, activity);\n\n        assertThat(listView.getAdapter(), is(notNullValue()));\n\n    }\n\n}", "prediction": "        //when\n        formManager.setup(mFormDescriptor, mListView, activity);\n\n        //then\n        assertThat(mListView.getAdapter(), is(notNullValue()));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "21894018_13", "part": [1, 1], "seq": [1, 1], "prompt": "class VisibilityFence {\n\n  public static TransactionAware create(byte[] fenceId) {\n    return new ReadFence(fenceId);\n  }\n\n  private  VisibilityFence();\n\n  public static FenceWait prepareWait(byte[] fenceId, TransactionSystemClient txClient);\n\n  private static Configuration conf;\n  private static TransactionManager txManager;\n\n}\n\nclass VisibilityFenceTest {\n\n  private static Configuration conf;\n  private static TransactionManager txManager;\n\n  @Test\n  public void testFence2() throws Exception {\n", "reference": "    byte[] fenceId = \"test_table\".getBytes(Charsets.UTF_8);\n\n    // Readers use fence to indicate that they are interested in changes to specific data\n    // Reader 1\n    TransactionAware readFence1 = VisibilityFence.create(fenceId);\n    TransactionContext readTxContext1 = new TransactionContext(new InMemoryTxSystemClient(txManager), readFence1);\n    readTxContext1.start();\n\n    // Reader 2\n    TransactionAware readFence2 = VisibilityFence.create(fenceId);\n    TransactionContext readTxContext2 = new TransactionContext(new InMemoryTxSystemClient(txManager), readFence2);\n    readTxContext2.start();\n\n    // Reader 3\n    TransactionAware readFence3 = VisibilityFence.create(fenceId);\n    TransactionContext readTxContext3 = new TransactionContext(new InMemoryTxSystemClient(txManager), readFence3);\n    readTxContext3.start();\n\n    // Writer updates data here in a separate transaction (code not shown)\n    // start tx\n    // update\n    // commit tx\n\n    // Now writer needs to wait for readers 1, 2, and 3 to see the change, it uses write fence to do so\n    TransactionAware writeFence = new WriteFence(fenceId);\n    TransactionContext writeTxContext = new TransactionContext(new InMemoryTxSystemClient(txManager), writeFence);\n    writeTxContext.start();\n\n    // Reader 1 commits before writeFence is committed\n    readTxContext1.finish();\n\n    try {\n      // writeFence will throw exception since Reader 1 committed without seeing changes\n      writeTxContext.finish();\n      Assert.fail(\"Expected transaction to fail\");\n    } catch (TransactionConflictException e) {\n      // Expected\n      writeTxContext.abort();\n    }\n\n    // Start over writeFence again\n    writeTxContext.start();\n\n    // Now, Reader 3 commits before writeFence\n    // Note that Reader 3 does not conflict with Reader 1\n    readTxContext3.finish();\n\n    try {\n      // writeFence will throw exception again since Reader 3 committed without seeing changes\n      writeTxContext.finish();\n      Assert.fail(\"Expected transaction to fail\");\n    } catch (TransactionConflictException e) {\n      // Expected\n      writeTxContext.abort();\n    }\n\n    // Start over writeFence again\n    writeTxContext.start();\n    // This time writeFence commits before the other readers\n    writeTxContext.finish();\n\n    // After this point all readers will see the change\n\n    try {\n      // Reader 2 commits after writeFence, hence this commit with throw exception\n      readTxContext2.finish();\n      Assert.fail(\"Expected transaction to fail\");\n    } catch (TransactionConflictException e) {\n      // Expected\n      readTxContext2.abort();\n    }\n\n    // Reader 2 has to abort and start over again. It will see the changes now.\n    readTxContext2 = new TransactionContext(new InMemoryTxSystemClient(txManager), readFence2);\n    readTxContext2.start();\n    readTxContext2.finish();\n  }\n\n}", "prediction": "    TransactionSystemClient txClient = new TransactionSystemClient(conf);\n    Transaction tx = txClient.startShort(User.getCurrent());\n    byte[] fenceId = new byte[16];\n    new Random().nextBytes(fenceId);\n    TransactionAware fence = VisibilityFence.create(fenceId);\n    fence.setTransactionAware(tx);\n    fence.start();\n    assertTrue(fence.isStarted());\n    assertFalse(fence.isDone());\n    assertFalse(fence.isFailed());\n    assertFalse(fence.isSuccessful());\n    assertFalse(fence.isAborted());\n    assertFalse(fence.isCommitted());\n    assertFalse(fence.isAborted());\n    assertFalse(fence.isCommitted());\n    assertFalse(fence.isAborted());\n    assertFalse(fence.isCommitted());\n    assertFalse(fence.isAborted());\n    assertFalse(fence.isCommitted());\n    assertFalse(fence.isAborted());\n    assertFalse(fence.isCommitted());\n    assertFalse(fence.isAborted());\n    assertFalse(fence.isCommitted());\n    assertFalse(fence.isAborted());\n    assertFalse(fence.isCommitted());\n    assertFalse(fence.isAborted());\n    assertFalse(fence.isCommitted());\n    assertFalse(fence.isAborted());\n    assertFalse(fence.isCommitted());\n    assertFalse(fence.isAborted());\n    assertFalse(fence.isCommitted());\n    assertFalse(fence.isAborted());\n    assertFalse(fence.isCommitted());\n    assertFalse(fence.isAborted());\n    assertFalse(fence.isCommitted());\n    assertFalse(fence.isAborted());\n    assertFalse(fence.isCommitted());\n    assertFalse(fence.isAborted());\n    assertFalse(fence.isCommitted());\n    assertFalse(fence.isAborted());\n    assertFalse(fence.isCommitted());\n    assertFalse(fence.isAborted());\n    assertFalse(fence.isCommitted());\n    assertFalse(fence.isAborted());\n    assertFalse(fence.isCommitted());\n    assertFalse(fence.isAborted());\n    assertFalse(fence.isCommitted());\n    assertFalse(fence.isAborted());\n    assertFalse(fence.isCommitted());\n    assertFalse(fence.isAborted());\n    assertFalse(fence.isCommitted());\n    assertFalse(fence.isAborted());\n    assertFalse(fence.isCommitted());\n    assertFalse(fence.isAborted());\n    assertFalse(fence.isCommitted());\n    assertFalse(fence.isAborted());\n    assertFalse(fence.isCommitted());\n    assertFalse(fence.isAborted());\n    assertFalse(fence.isCommitted());\n    assertFalse(fence.isAborted());\n    assertFalse(fence.isCommitted());\n    assertFalse(fence.isAborted());\n    assertFalse(fence.isCommitted());\n    assertFalse(fence.isAborted());\n    assertFalse(fence.isCommitted());\n    assertFalse(fence.isAborted());\n    assertFalse(fence.isCommitted());\n    assertFalse(fence.isAborted());\n    assertFalse(fence.isCommitted());\n    assertFalse(fence.isAborted());\n    assertFalse(fence.isCommitted());\n    assertFalse(fence.isAborted());\n    assertFalse(fence.isCommitted());\n    assertFalse(fence.isAborted());\n    assertFalse(fence.isCommitted());\n    assertFalse(fence.isAborted());\n    assertFalse(fence.isCommitted());\n    assertFalse(fence.isAborted());\n    assertFalse(", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "22165604_7", "part": [1, 1], "seq": [1, 1], "prompt": "class ApkProvider extends FDroidProvider {\n\n    @Override\n    public Cursor query(@NonNull Uri uri, String[] projection, String selection,\n                        String[] selectionArgs, String sortOrder) {\n\n        QuerySelection query = new QuerySelection(selection, selectionArgs);\n\n        switch (MATCHER.match(uri)) {\n            case CODE_REPO_APP:\n                List<String> uriSegments = uri.getPathSegments();\n                Long repoId = Long.parseLong(uriSegments.get(1));\n                String packageName = uriSegments.get(2);\n                query = query.add(queryRepo(repoId)).add(queryPackage(packageName));\n                break;\n\n            case CODE_LIST:\n                break;\n\n            case CODE_APK_FROM_ANY_REPO:\n                query = query.add(querySingleFromAnyRepo(uri));\n                break;\n\n            case CODE_APK_ROW_ID:\n                query = query.add(querySingle(Long.parseLong(uri.getLastPathSegment())));\n                break;\n\n            case CODE_PACKAGE:\n                query = query.add(queryPackage(uri.getLastPathSegment()));\n                break;\n\n            case CODE_APKS:\n                query = query.add(queryApks(uri.getLastPathSegment()));\n                break;\n\n            case CODE_REPO:\n                query = query.add(queryRepo(Long.parseLong(uri.getLastPathSegment())));\n                break;\n\n            default:\n                Log.e(TAG, \"Invalid URI for apk content provider: \" + uri);\n                throw new UnsupportedOperationException(\"Invalid URI for apk content provider: \" + uri);\n        }\n\n        Query queryBuilder = new Query();\n        for (final String field : projection) {\n            queryBuilder.addField(field);\n        }\n        queryBuilder.addSelection(query);\n        queryBuilder.addOrderBy(sortOrder);\n\n        Cursor cursor = LoggingQuery.rawQuery(db(), queryBuilder.toString(), queryBuilder.getArgs());\n        cursor.setNotificationUri(getContext().getContentResolver(), uri);\n        return cursor;\n    }\n\n    public static String getAuthority();\n    public static Uri getContentUri();\n    private Uri getApkUri(long apkRowId);\n    public static Uri getAppUri(String packageName);\n    public static Uri getRepoUri(long repoId);\n    public static Uri getRepoUri(long repoId, String packageName);\n    public static Uri getApkFromAnyRepoUri(Apk apk);\n    public static Uri getApkFromAnyRepoUri(String packageName, int versionCode, @Nullable String signature);\n    @Override protected String getTableName();\n    protected String getApkAntiFeatureJoinTableName();\n    protected String getAppTableName();\n    @Override protected String getProviderName();\n    @Override protected UriMatcher getMatcher();\n    private QuerySelection queryPackage(String packageName);\n    private QuerySelection querySingleFromAnyRepo(Uri uri);\n    private QuerySelection querySingleFromAnyRepo(Uri uri, boolean includeAlias);\n    private QuerySelection querySingle(long apkRowId);\n    private QuerySelection querySingle(long apkRowId, boolean includeAlias);\n    private QuerySelection querySingleWithAppId(Uri uri);\n    protected QuerySelection queryRepo(long repoId);\n    protected QuerySelection queryRepo(long repoId, boolean includeAlias);\n    protected QuerySelection queryApks(String apkKeys);\n    protected QuerySelection queryApks(String apkKeys, boolean includeAlias);\n    private String getMetadataIdFromPackageNameQuery();\n    private static void removeFieldsFromOtherTables(ContentValues values);\n    @Override public Uri insert(@NonNull Uri uri, ContentValues values);\n    protected void ensureAntiFeatures(String[] antiFeatures, long apkId);\n    protected long ensureAntiFeature(String antiFeatureName);\n    @Override public int delete(@NonNull Uri uri, String where, String[] whereArgs);\n    @Override public int update(@NonNull Uri uri, ContentValues values, String where, String[] whereArgs);\n\n    private static final String[] PROJ;\n    private static final long REPO_KEEP;\n    private static final long REPO_DELETE;\n\n}\n\nclass ApkProviderTest extends FDroidProvider {\n\n    private static final String[] PROJ;\n    private static final long REPO_KEEP;\n    private static final long REPO_DELETE;\n\n    @Test\n    public void testInsertWithValidExtraFields() {\n", "reference": "\n        assertResultCount(0, queryAllApks());\n\n        ContentValues values = new ContentValues();\n        values.put(Cols.REPO_ID, 10);\n        values.put(Cols.Repo.ADDRESS, \"http://example.com\");\n        values.put(Cols.Repo.VERSION, 3);\n        values.put(Cols.FEATURES, \"Some features\");\n        Uri uri = Assert.insertApk(context, \"com.example.com\", 1, values);\n\n        assertResultCount(1, queryAllApks());\n\n        String[] projections = Cols.ALL;\n        Cursor cursor = contentResolver.query(uri, projections, null, null, null);\n        cursor.moveToFirst();\n        Apk apk = new Apk(cursor);\n        cursor.close();\n\n        // These should have quietly been dropped when we tried to save them,\n        // because the provider only knows how to query them (not update them).\n        assertEquals(null, apk.repoAddress);\n        assertEquals(0, apk.repoVersion);\n\n        // But this should have saved correctly...\n        assertEquals(1, apk.features.length);\n        assertEquals(\"Some features\", apk.features[0]);\n        assertEquals(\"com.example.com\", apk.packageName);\n        assertEquals(1, apk.versionCode);\n        assertEquals(10, apk.repoId);\n    }\n\n}", "prediction": "        ContentValues values = new ContentValues();\n        values.put(ApkProvider.APK_PACKAGE_NAME, \"com.example.test\");\n        values.put(ApkProvider.APK_VERSION_CODE, 1);\n        values.put(ApkProvider.APK_SIGNATURE, \"signature\");\n        values.put(ApkProvider.APK_REPO_ID, REPO_KEEP);\n        values.put(ApkProvider.APK_REPO_NAME, \"repo\");\n        values.put(ApkProvider.APK_REPO_OWNER_NAME, \"owner\");\n        values.put(ApkProvider.APK_REPO_OWNER_ID, 1);\n        values.put(ApkProvider.APK_REPO_URL, \"http://example.com\");\n        values.put(ApkProvider.APK_REPO_DESCRIPTION, \"description\");\n        values.put(ApkProvider.APK_REPO_ICON_URL, \"http://example.com/icon\");\n        values.put(ApkProvider.APK_REPO_ICON_MIME_TYPE, \"image/png\");\n        values.put(ApkProvider.APK_REPO_ICON_DATA, \"icon data\".getBytes());\n        values.put(ApkProvider.APK_REPO_ICON_DATA_MIME_TYPE, \"image/png\");\n        values.put(ApkProvider.APK_REPO_ICON_DATA_FILENAME, \"icon.png\");\n        values.put(ApkProvider.APK_REPO_ICON_DATA_FILESIZE, 100);\n        values.put(ApkProvider.APK_REPO_ICON_DATA_FILE_EXTENSION, \"png\");\n        values.put(ApkProvider.APK_REPO_ICON_DATA_FILE_MIME_TYPE, \"image/png\");\n        values.put(ApkProvider.APK_REPO_ICON_DATA_FILE_LAST_MODIFIED, 1000);\n        values.put(ApkProvider.APK_REPO_ICON_DATA_FILE_LAST_ACCESSED, 2000);\n        values.put(ApkProvider.APK_REPO_ICON_DATA_FILE_CREATION, 3000);\n        values.put(ApkProvider.APK_REPO_ICON_DATA_FILE_CHANGED, 4000);\n        values.put(ApkProvider.APK_REPO_ICON_DATA_FILE_READ_ONLY, true);\n        values.put(ApkProvider.APK_REPO_ICON_DATA_FILE_HIDDEN, true);\n        values.put(ApkProvider.APK_REPO_ICON_DATA_FILE_ARCHIVE, true);\n        values.put(ApkProvider.APK_REPO_ICON_DATA_FILE_SYSTEM, true);\n        values.put(ApkProvider.APK_REPO_ICON_DATA_FILE_DIRECTORY, true);\n        values.put(ApkProvider.APK_REPO_ICON_DATA_FILE_PICTURE, true);\n        values.put(ApkProvider.APK_REPO_ICON_DATA_FILE_VIDEO, true);\n        values.put(ApkProvider.APK_REPO_ICON_DATA_FILE_AUDIO, true);\n        values.put(ApkProvider.APK_REPO_ICON_DATA_FILE_DOCUMENT, true);\n        values.put(ApkProvider.APK_REPO_ICON_DATA_FILE_APPLICATION, true);\n        values.put(ApkProvider.APK_REPO_ICON_DATA_FILE_PREFERENCE, true);\n        values.put(ApkProvider.APK_REPO_ICON_DATA_FILE_COMPRESSED, true);\n        values", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "22169673_0", "part": [1, 1], "seq": [1, 1], "prompt": "class ProxyHelper {\n\n   static boolean isHostMatchesNonProxyHostsPattern( String host, String nonProxyHostsPattern )\n   {\n       boolean matches = true;\n       if ( StringUtils.isNotBlank( nonProxyHostsPattern ) )\n       {\n           try\n           {\n               matches = host.matches( nonProxyHostsPattern );\n           }\n           catch ( PatternSyntaxException e )\n           {\n               String message = String.format( \"Invalid pattern for non-proxy hosts: '%s'\", nonProxyHostsPattern );\n               log.warn( message, e );\n               matches = false;\n           }\n       }\n       String format = \"isHostMatchesNonProxyHostsPattern( host = '{}', nonProxyHostsPattern = '{}' ): {}\";\n       log.debug( format, host, nonProxyHostsPattern, matches );\n       return matches;\n   }\n\n   private  ProxyHelper(  );\n\n   public static Proxy getProxy( String url );\n   private static boolean isUseProxy( String protocol, String host );\n   static boolean isUseProxyByPattern( String host, String nonProxyHostsPattern );\n   static String convertToJavaPattern( String pattern );\n   private static int getProxyPort( String protocol );\n   private static String getProxyHost( String protocol );\n   private static String getNonProxyHostsPattern( String protocol );\n   private static String getProxyPassword( String protocol );\n   private static String getProxyUser( String protocol );\n   static String getProtocol( String url );\n   static String getHost( String url );\n\n    public static final String PATTERN;\n    public static final String HOST;\n    public static final String SOURCE_URL;\n\n}\n\nclass ProxyHelperTest {\n\n    public static final String PATTERN;\n    public static final String HOST;\n    public static final String SOURCE_URL;\n\n    @Test\n    public void testIsHostMatchesNonProxyHostsPattern(   )\n    {\n", "reference": "        String javaPattern = ProxyHelper.convertToJavaPattern( PATTERN );\n        boolean matches = ProxyHelper.isHostMatchesNonProxyHostsPattern( HOST, javaPattern );\n        String message = String.format( \"host '%s' must match pattern '%s'\", HOST, PATTERN );\n        assertTrue( message, matches );\n    }\n\n}", "prediction": "        assertTrue( ProxyHelper.isHostMatchesNonProxyHostsPattern( \"localhost\", null ) );\n        assertTrue( ProxyHelper.isHostMatchesNonProxyHostsPattern( \"localhost\", \"\" ) );\n        assertTrue( ProxyHelper.isHostMatchesNonProxyHostsPattern( \"localhost\", \" \" ) );\n        assertTrue( ProxyHelper.isHostMatchesNonProxyHostsPattern( \"localhost\", \"localhost\" ) );\n        assertTrue( ProxyHelper.isHostMatchesNonProxyHostsPattern( \"localhost\", \"localhost|\" ) );\n        assertTrue( ProxyHelper.isHostMatchesNonProxyHostsPattern( \"localhost\", \"|localhost\" ) );\n        assertTrue( ProxyHelper.isHostMatchesNonProxyHostsPattern( \"localhost\", \"|localhost|\" ) );\n        assertTrue( ProxyHelper.isHostMatchesNonProxyHostsPattern( \"localhost\", \"|localhost|localhost\" ) );\n        assertTrue( ProxyHelper.isHostMatchesNonProxyHostsPattern( \"localhost\", \"|localhost|localhost|\" ) );\n        assertTrue( ProxyHelper.isHostMatchesNonProxyHostsPattern( \"localhost\", \"|localhost|localhost|localhost\" ) );\n        assertTrue( ProxyHelper.isHostMatchesNonProxyHostsPattern( \"localhost\", \"|localhost|localhost|localhost|\" ) );\n        assertTrue( ProxyHelper.isHostMatchesNonProxyHostsPattern( \"localhost\", \"|localhost|localhost|localhost|localhost\" ) );\n        assertTrue( ProxyHelper.isHostMatchesNonProxyHostsPattern( \"localhost\", \"|localhost|localhost|localhost|localhost|\" ) );\n        assertTrue( ProxyHelper.isHostMatchesNonProxyHostsPattern( \"localhost\", \"|localhost|localhost|localhost|localhost|localhost\" ) );\n        assertTrue( ProxyHelper.isHostMatchesNonProxyHostsPattern( \"localhost\", \"|localhost|localhost|localhost|localhost|localhost|\" ) );\n        assertTrue( ProxyHelper.isHostMatchesNonProxyHostsPattern( \"localhost\", \"|localhost|localhost|localhost|localhost|localhost|localhost\" ) );\n        assertTrue( ProxyHelper.isHostMatchesNonProxyHostsPattern( \"localhost\", \"|localhost|localhost|localhost|localhost|localhost|localhost|\" ) );\n        assertTrue( ProxyHelper.isHostMatchesNonProxyHostsPattern( \"localhost\", \"|localhost|localhost|localhost|localhost|localhost|localhost|localhost\" ) );\n        assertTrue( ProxyHelper.isHostMatchesNonProxyHostsPattern( \"localhost\", \"|localhost|localhost|localhost|localhost|localhost|localhost|localhost|\" ) );\n        assertTrue( ProxyHelper.isHostMatchesNonProxyHostsPattern( \"localhost\", \"|localhost|localhost|localhost|localhost|localhost|localhost|localhost|localhost\" ) );\n        assertTrue( ProxyHelper.isHostMatchesNonProxyHostsPattern( \"localhost\", \"|localhost|localhost|localhost|localhost|localhost|localhost|localhost|localhost|\" ) );\n        assertTrue( ProxyHelper.isHostMatchesNonProxyHostsPattern( \"localhost\", \"|localhost|localhost|localhost|localhost|localhost|localhost|localhost|localhost|localhost\" ) );\n        assertTrue( ProxyHelper.isHostMatchesNonProxyHostsPattern( \"localhost\", \"|localhost|localhost|localhost|localhost|localhost|localhost|localhost|localhost|localhost|\" ) );\n        assertTrue( ProxyHelper.isHostMatchesNonProxyHostsPattern( \"localhost\", \"|localhost|localhost|localhost|localhost|localhost|localhost|localhost|localhost|localhost|localhost\" ) );\n        assertTrue( ProxyHelper.isHostMatchesNonProxyHostsPattern( \"localhost\", \"|localhost|localhost|localhost|localhost|localhost|localhost|localhost|localhost|localhost|localhost|\" ) );\n        assertTrue( ProxyHelper.isHostMatchesNonProxyHostsPattern( \"localhost\", \"|localhost|localhost|localhost|localhost|localhost|localhost|localhost|localhost|localhost|localhost|localhost\" ) );\n        assertTrue( ProxyHelper.isHostMatchesNonProxyHostsPattern( \"localhost\", \"|localhost", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "22589840_305", "part": [1, 1], "seq": [1, 1], "prompt": "class SubscriptionDelegate {\n\n    synchronized Publisher getPublisher(NotificationSubscriptionContext subscriptionContext) {\n        Publisher publisher = publisherDao.findPublisher(subscriptionContext.getContextId(), subscriptionContext.getContextType(), subscriptionContext.getSourceId(),\n                subscriptionContext.getSourceType());\n        if (publisher == null) {\n            publisher = publisherDao.createAndSavePublisher(subscriptionContext.getContextId(), subscriptionContext.getContextType(), subscriptionContext.getSourceId(),\n                    subscriptionContext.getSourceType(), subscriptionContext.getSubcontextId());\n        }\n        return publisher;\n    }\n\n    @Deprecated void deleteSubscription(NotificationSubscriptionContext subscriptionContext);\n    public void invalidateSubscriptionForSubscriptionContext(NotificationSubscriptionContext subscriptionContext);\n    public void invalidateSubscription(Publisher publisher, Subscriber subscriber);\n    public void invalidateSubscription(Subscription subscription);\n     Subscriber getSubscriber(Identity subscriberIdentity);\n    public Subscription getSubscription(NotificationSubscriptionContext subscriptionContext);\n    public Subscription createAndSaveSubscription(NotificationSubscriptionContext subscriptionContext);\n    public List<Subscription> getSubscriptions(Identity identity);\n\n     SubscriptionDelegate subscriptionDelegateTestObject;\n    private Subscriber subscriber;\n    private Publisher publisher;\n    private Identity subscriberIdentity;\n    private Long contextId;\n    private ContextType contextType;\n    private Long sourceId;\n    private String sourceType;\n    private Long subcontextId;\n    private NotificationSubscriptionContext subscriptionContext;\n    private Subscription subscription;\n\n}\n\nclass SubscriptionDelegateTest {\n\n     SubscriptionDelegate subscriptionDelegateTestObject;\n    private Subscriber subscriber;\n    private Publisher publisher;\n    private Identity subscriberIdentity;\n    private Long contextId;\n    private ContextType contextType;\n    private Long sourceId;\n    private String sourceType;\n    private Long subcontextId;\n    private NotificationSubscriptionContext subscriptionContext;\n    private Subscription subscription;\n\n    @Test\n    public void getPublisher_PublisherExist() {\n", "reference": "        when(subscriptionDelegateTestObject.publisherDao.findPublisher(contextId, contextType, sourceId, sourceType)).thenReturn(publisher);\n\n        Publisher resultPublisher = subscriptionDelegateTestObject.getPublisher(subscriptionContext);\n\n        assertEquals(\"getPublisher returns wrong publisher\", publisher, resultPublisher);\n\n    }\n\n}", "prediction": "        Publisher publisher = subscriptionDelegateTestObject.getPublisher(subscriptionContext);\n        assertEquals(publisher, this.publisher);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "22648109_0", "part": [1, 1], "seq": [1, 1], "prompt": "class Geometry {\n\n    public static boolean isInsideTriangle(Vector2 p, Vector2 pA, Vector2 pB, Vector2 pC) {\n        // Move origin of coordinates to point A\n        Vector2 pointB = new Vector2(pB.x - pA.x, pB.y - pA.y);\n        Vector2 pointC = new Vector2(pC.x - pA.x, pC.y - pA.y);\n        Vector2 point = new Vector2(p.x - pA.x, p.y - pA.y);\n\n        // Calculate scalar\n        Double scalar = pointB.x * pointC.y - pointC.x * pointB.y;\n\n        //  Calculate the 3 Barycentric weights\n        Double weightA = ( point.x * ( pointB.y - pointC.y ) + point.y * ( pointC.x - pointB.x ) + pointB.x * pointC.y - pointC.x * pointB.y ) / scalar;\n\n        Double weightB = ( point.x * pointC.y - point.y * pointC.x ) / scalar;\n\n        Double weightC = ( point.y * pointB.x - point.x * pointB.y ) / scalar;\n\n        // Point is inside triangle if and only if the 3 weights are between 0 and 1\n        return isBetweenZeroAndOne(weightA) && isBetweenZeroAndOne(weightB) && isBetweenZeroAndOne(weightC);\n    }\n\n    public static boolean isInsideTriangle(Vector2 p, Triangle triangle);\n    private static boolean isBetweenZeroAndOne(Double d);\n    public static boolean areTrianglesColliding(Triangle triangle1, Triangle triangle2);\n    public static Vector2 coordinatesAfterRotation(Vector2 coordinates, Double rotation);\n\n}\n\nclass GeometryTest {\n\n    @Test\n    public void testIsInsideTriangle() throws Exception {\n", "reference": "        Vector2 p = new Vector2(2d, 3d);\n        Vector2 pA = new Vector2(1d, 1d);\n        Vector2 pB = new Vector2(4d, 2d);\n        Vector2 pC = new Vector2(2d, 7d);\n\n        assertThat(Geometry.isInsideTriangle(p, pA, pB, pC)).isTrue();\n    }\n\n}", "prediction": "        Vector2 p = new Vector2(0, 0);\n        Vector2 pA = new Vector2(0, 0);\n        Vector2 pB = new Vector2(1, 0);\n        Vector2 pC = new Vector2(0, 1);\n\n        assertTrue(Geometry.isInsideTriangle(p, pA, pB, pC));\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "22809141_0", "part": [1, 1], "seq": [1, 1], "prompt": "class Updater {\n\n    public static int isVersionNewerThan(String version, String check) {\n        // If version starts with RecipeManager, remove it\n        if (version.startsWith(\"RecipeManager\")) {\n            version = version.substring(\"RecipeManager\".length()).trim();\n        }\n\n        if (check.startsWith(\"RecipeManager\")) {\n            check = check.substring(\"RecipeManager\".length()).trim();\n        }\n\n        // Remove initial \"v\". Ex: v1.0.0 -> 1.0.0\n        if (version.startsWith(\"v\")) {\n            version = version.substring(1).trim();\n        }\n\n        if (check.startsWith(\"v\")) {\n            check = check.substring(1).trim();\n        }\n\n        if (version.equals(check)) {\n            return 0;\n        }\n\n        String[] versionSplit = version.split(\"[ -]\");\n        String[] checkSplit = check.split(\"[ -]\");\n\n        int compare = -2;\n        String[] currentArray = versionSplit[0].split(\"\\\\.\");\n        String[] latestArray = checkSplit[0].split(\"\\\\.\");\n\n        int shortest = currentArray.length;\n        int latestLength = latestArray.length;\n        if (latestLength < shortest) {\n            shortest = latestLength;\n        }\n\n        for (int i = 0; i < shortest; i++) {\n            int c = Integer.parseInt(currentArray[i]);\n            int l = Integer.parseInt(latestArray[i]);\n\n            if (c > l) {\n                compare = 1;\n                break;\n            } else if (l > c) {\n                compare = -1;\n                break;\n            }\n        }\n\n        if (compare == -2) {\n            boolean versionHasBeta = versionSplit.length > 1;\n            boolean checkHasBeta = checkSplit.length > 1;\n            if (versionHasBeta && checkHasBeta) {\n                String versionBeta = versionSplit[1];\n                versionBeta = versionBeta.replace(\"dev\", \"0.\");\n                versionBeta = versionBeta.replace(\"alpha\", \"1.\");\n                versionBeta = versionBeta.replace(\"beta\", \"2.\");\n\n                String checkBeta = checkSplit[1];\n                checkBeta = checkBeta.replace(\"dev\", \"0.\");\n                checkBeta = checkBeta.replace(\"alpha\", \"1.\");\n                checkBeta = checkBeta.replace(\"beta\", \"2.\");\n\n                try {\n                    double versionDouble = Double.parseDouble(versionBeta);\n                    double checkDouble = Double.parseDouble(checkBeta);\n                    if (versionDouble > checkDouble) {\n                        compare = 1;\n                    } else if (versionDouble < checkDouble) {\n                        compare = -1;\n                    }\n                } catch (NumberFormatException e) {\n                    // Versions aren't doubles, fail quietly\n                }\n            } else if (versionHasBeta) {\n                // Only beta status on version means it's newer\n                compare = 1;\n            } else if (checkHasBeta) {\n                // Only beta status on check means version is older\n                compare = -1;\n            }\n        }\n\n        return compare;\n    }\n\n    private  Updater();\n\n    public static void init(RecipeManager newPlugin, int newProjectID, String newApiKey);\n    public static void updateOnce(final CommandSender sender);\n    public static void stop();\n    public static String getCurrentVersion();\n    public static String getLatestVersion();\n    public static int isVersionOlderThan(String version, String check);\n    public static String getLatestLink();\n    public static void query(CommandSender sender);\n\n}\n\nclass UpdaterTest {\n\n    @Test\n    public void testVersionEquals() {\n", "reference": "        assertEquals(0, Updater.isVersionNewerThan(\"2.10.0\", \"RecipeManager v2.10.0\"));\n        assertEquals(0, Updater.isVersionNewerThan(\"2.10.0 alpha\", \"RecipeManager v2.10.0 alpha\"));\n        assertEquals(0, Updater.isVersionNewerThan(\"2.10.0 beta\", \"v2.10.0 beta\"));\n    }\n\n}", "prediction": "        assertEquals(0, Updater.isVersionNewerThan(\"1.0.0\", \"1.0.0\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "22876447_1", "part": [1, 1], "seq": [1, 1], "prompt": "class CsvExtractorFactory implements IExtractorFactory<StreamConnector> {\n\n    @Override\n    public Extractor createExtractor(StreamConnector connector, ExtractorModel model) {\n\n        String charsetName = model.getPropertyValue(CHARSET_PROPERTY);\n\n        Charset charset = charsetName != null ? Charset.forName(charsetName) : defaultCharset;\n\n        CSVFormat csvFormat = CSVFormat.RFC4180;\n        String delimiter = model.getPropertyValue(DELIMITER_PROPERTY);\n        if (delimiter != null) {\n            if (delimiter.length() != 1) {\n                throw new LmRuntimeException(\"Invalid delimiter (should be exactly one character): \" + delimiter);\n            }\n            csvFormat = csvFormat.withDelimiter(delimiter.charAt(0));\n        }\n\n        String readFromString = model.getPropertyValue(READ_FROM_PROPERTY);\n        Integer readFrom = readFromString != null ? Integer.valueOf(readFromString) : null;\n\n        return new CsvExtractor(connector, model.getAttributes(), charset, csvFormat, readFrom);\n    }\n\n    public  CsvExtractorFactory();\n\n    @Override public String getExtractorType();\n    @Override public Class<StreamConnector> getConnectorType();\n\n    protected static final String CONNECTOR_ID;\n    protected CsvExtractorFactory extractorFactory;\n    protected StreamConnector connectorMock;\n    private MutableExtractorModel model;\n\n}\n\nclass CsvExtractorFactoryTest {\n\n    protected static final String CONNECTOR_ID;\n    protected CsvExtractorFactory extractorFactory;\n    protected StreamConnector connectorMock;\n    private MutableExtractorModel model;\n\n    @Test\n    public void testCreateExtractor() {\n", "reference": "        extractorFactory.createExtractor(connectorMock, model);\n    }\n\n}", "prediction": "        Extractor extractor = extractorFactory.createExtractor(connectorMock, model);\n        assertNotNull(extractor);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "23743671_1", "part": [1, 1], "seq": [1, 1], "prompt": "class S3Path {\n\n\tpublic void appendPath( String path )\n\t{\n\t\tif( mKey == null )\n\t\t\tmKey = path ;\n\t\telse\n\t\t\tif( mKey.endsWith(mDelim))\n\t\t\t\tmKey = mKey + path ;\n\t\t\telse\n\t\t\t\tmKey = mKey + mDelim + path ;\n\n\t}\n\n\tpublic  S3Path(String\tpath);\n\tpublic  S3Path( String bucket , String key );\n\tpublic  S3Path( S3Path parent , String child );\n\n\tprivate void initFromPath( String path );\n\tpublic String getBucket();\n\tpublic String getPrefix();\n\tpublic boolean hasBucket();\n\tpublic boolean hasKey();\n\tpublic String getKey();\n\t@Override public String toString();\n\tpublic boolean isDirectory();\n\tpublic void setBucket(String bucket);\n\tpublic void setKey(String key);\n\tpublic static boolean isDirectory(String key, String delim );\n\tpublic static boolean isDirectory(String key);\n\n}\n\nclass S3PathTest {\n\n  @Test\n  public void testAppendPath() throws Exception {\n", "reference": "    S3Path p = new S3Path(\"bucket\",\"key\");\n    p.appendPath(\"subkey\");\n    assertThat(\"key/subkey\",equalTo(p.getKey()));\n\n  }\n\n}", "prediction": "    S3Path path = new S3Path(\"bucket\", \"key\");\n    path.appendPath(\"child\");\n    assertEquals(\"bucket/key/child\", path.getKey());\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "23749387_4", "part": [1, 1], "seq": [1, 1], "prompt": "class RCUtils {\n\n    @SuppressWarnings(\"unchecked\")\n    public static void validateSettingsParms(HashMap<String, Object> parameters) throws RCException\n    {\n        validatePushSettings(parameters);\n      /*\n      if (parameters.containsKey(RCDevice.ParameterKeys.MEDIA_TURN_ENABLED) &&\n            ((Boolean)parameters.get(RCDevice.ParameterKeys.MEDIA_TURN_ENABLED))) {\n       */\n\n        if (!parameters.containsKey(RCDevice.ParameterKeys.SIGNALING_USERNAME) ||\n                parameters.get(RCDevice.ParameterKeys.SIGNALING_USERNAME).equals(\"\")) {\n            throw new RCException(RCClient.ErrorCodes.ERROR_DEVICE_MISSING_USERNAME);\n            //return new ErrorStruct(RCClient.ErrorCodes.ERROR_DEVICE_MISSING_USERNAME);\n        }\n\n        if (!parameters.containsKey(RCDevice.ParameterKeys.MEDIA_ICE_SERVERS_DISCOVERY_TYPE)) {\n            // discovery type not provided\n            parameters.put(RCDevice.ParameterKeys.MEDIA_ICE_SERVERS_DISCOVERY_TYPE, RCDevice.MediaIceServersDiscoveryType.ICE_SERVERS_CONFIGURATION_URL_XIRSYS_V2);\n        }\n        else {\n            // discovery type provided\n            RCDevice.MediaIceServersDiscoveryType iceServersDiscoveryType;\n            if (parameters.get(RCDevice.ParameterKeys.MEDIA_ICE_SERVERS_DISCOVERY_TYPE) instanceof Enum){\n                iceServersDiscoveryType = (RCDevice.MediaIceServersDiscoveryType)parameters.get(RCDevice.ParameterKeys.MEDIA_ICE_SERVERS_DISCOVERY_TYPE);\n            } else {\n                int discoveryType = (int)parameters.get(RCDevice.ParameterKeys.MEDIA_ICE_SERVERS_DISCOVERY_TYPE);\n                if (discoveryType >= RCDevice.MediaIceServersDiscoveryType.values().length || discoveryType < 0){\n                    throw new RCException(RCClient.ErrorCodes.ERROR_DEVICE_INVALID_ICE_SERVER_DISCOVERY_TYPE);\n                }else {\n                    iceServersDiscoveryType = RCDevice.MediaIceServersDiscoveryType.values()[discoveryType];\n                }\n            }\n\n            if (iceServersDiscoveryType == RCDevice.MediaIceServersDiscoveryType.ICE_SERVERS_CUSTOM) {\n                // custom (i.e. no configuration url used)\n                if (!parameters.containsKey(RCDevice.ParameterKeys.MEDIA_ICE_SERVERS) || parameters.get(RCDevice.ParameterKeys.MEDIA_ICE_SERVERS) == null ||\n                        ((List<Map<String,String>>) parameters.get(RCDevice.ParameterKeys.MEDIA_ICE_SERVERS)).size() == 0) {\n                    throw new RCException(RCClient.ErrorCodes.ERROR_DEVICE_INVALID_CUSTOM_DISCOVERY_NO_ICE_SERVERS);\n                }\n\n                List<Map<String, String>> iceServers = (List<Map<String, String>>)parameters.get(RCDevice.ParameterKeys.MEDIA_ICE_SERVERS);\n                for (Map<String, String> iceServer : iceServers) {\n                    if (!iceServer.containsKey(RCConnection.IceServersKeys.ICE_SERVER_URL) ||\n                            iceServer.get(RCConnection.IceServersKeys.ICE_SERVER_URL).equals(\"\")) {\n                        throw new RCException(RCClient.ErrorCodes.ERROR_DEVICE_INVALID_CUSTOM_DISCOVERY);\n                    }\n                }\n\n                if (parameters.containsKey(RCDevice.ParameterKeys.MEDIA_ICE_URL) ||\n                        parameters.containsKey(RCDevice.ParameterKeys.MEDIA_ICE_USERNAME) ||\n                        parameters.containsKey(RCDevice.ParameterKeys.MEDIA_ICE_PASSWORD) ||\n                        parameters.containsKey(RCDevice.ParameterKeys.MEDIA_ICE_DOMAIN)) {\n                    throw new RCException(RCClient.ErrorCodes.ERROR_DEVICE_INVALID_CUSTOM_DISCOVERY);\n                }\n            }\n            else {\n                // not custom; media ice servers shouldn't be provided\n                if (parameters.containsKey(RCDevice.ParameterKeys.MEDIA_ICE_SERVERS)) {\n                    throw new RCException(RCClient.ErrorCodes.ERROR_DEVICE_INVALID_ICE_SERVERS_NOT_CUSTOM_DISCOVERY);\n                }\n\n                // all those fields are mandatory when configuration URL is used\n                if (!parameters.containsKey(RCDevice.ParameterKeys.MEDIA_ICE_URL) ||\n                        parameters.get(RCDevice.ParameterKeys.MEDIA_ICE_URL).equals(\"\")) {\n                    throw new RCException(RCClient.ErrorCodes.ERROR_DEVICE_MISSING_ICE_URL);\n                }\n                if (!parameters.containsKey(RCDevice.ParameterKeys.MEDIA_ICE_USERNAME) ||\n                        parameters.get(RCDevice.ParameterKeys.MEDIA_ICE_USERNAME).equals(\"\")) {\n                    throw new RCException(RCClient.ErrorCodes.ERROR_DEVICE_MISSING_ICE_USERNAME);\n                }\n                if (!parameters.containsKey(RCDevice.ParameterKeys.MEDIA_ICE_PASSWORD) ||\n                        parameters.get(RCDevice.ParameterKeys.MEDIA_ICE_PASSWORD).equals(\"\")) {\n                    throw new RCException(RCClient.ErrorCodes.ERROR_DEVICE_MISSING_ICE_PASSWORD);\n                }\n                if (!parameters.containsKey(RCDevice.ParameterKeys.MEDIA_ICE_DOMAIN) ||\n                        parameters.get(RCDevice.ParameterKeys.MEDIA_ICE_DOMAIN).equals(\"\")) {\n                    throw new RCException(RCClient.ErrorCodes.ERROR_DEVICE_MISSING_ICE_DOMAIN);\n                }\n            }\n        }\n    }\n\n    public static void validateDeviceParms(HashMap<String, Object> parameters);\n    public static void validateConnectionParms(HashMap<String, Object> parameters);\n    static void validatePushSettings(HashMap<String, Object> parameters);\n    public static boolean shouldRegisterForPush(HashMap<String, Object> parameters, StorageManagerInterface storageManagerInterface);\n\n    private Context context;\n\n}\n\nclass RCUtilsTest {\n\n    private Context context;\n\n    @Test\n    public void validateSignalingAndPushParams_Valid() {\n", "reference": "        HashMap<String, Object> settingParams = new HashMap<String, Object>();\n\n        try {\n            settingParams = getFilledHashMapWithValidPush(settingParams);\n            getFilledWithMediaParams(settingParams);\n\n            RCUtils.validateSettingsParms(settingParams);\n        } catch (RCException ex) {\n            fail(ex.toString());\n        }\n    }\n\n}", "prediction": "        HashMap<String, Object> parameters = new HashMap<>();\n        parameters.put(RCDevice.ParameterKeys.SIGNALING_USERNAME, \"username\");\n        parameters.put(RCDevice.ParameterKeys.SIGNALING_PASSWORD, \"password\");\n        parameters.put(RCDevice.ParameterKeys.SIGNALING_URL, \"url\");\n        parameters.put(RCDevice.ParameterKeys.SIGNALING_PROTOCOL, RCDevice.SignalingProtocol.SIGNALING_PROTOCOL_XIRSYS);\n        parameters.put(RCDevice.ParameterKeys.SIGNALING_PROTOCOL_VERSION, RCDevice.SignalingProtocolVersion.SIGNALING_PROTOCOL_VERSION_V2);\n        parameters.put(RCDevice.ParameterKeys.SIGNALING_PROTOCOL_TYPE, RCDevice.SignalingProtocolType.SIGNALING_PROTOCOL_TYPE_WEBSOCKET);\n        parameters.put(RCDevice.ParameterKeys.SIGNALING_PROTOCOL_WEBSOCKET_URL, \"ws://url\");\n        parameters.put(RCDevice.ParameterKeys.SIGNALING_PROTOCOL_WEBSOCKET_PATH, \"path\");\n        parameters.put(RCDevice.ParameterKeys.SIGNALING_PROTOCOL_WEBSOCKET_QUERY_STRING, \"query\");\n        parameters.put(RCDevice.ParameterKeys.SIGNALING_PROTOCOL_WEBSOCKET_HEADERS, new HashMap<>());\n        parameters.put(RCDevice.ParameterKeys.SIGNALING_PROTOCOL_XIRSYS_API_KEY, \"apiKey\");\n        parameters.put(RCDevice.ParameterKeys.SIGNALING_PROTOCOL_XIRSYS_API_SECRET, \"apiSecret\");\n        parameters.put(RCDevice.ParameterKeys.SIGNALING_", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "23783621_1", "part": [1, 1], "seq": [1, 1], "prompt": "class VanillaDataCache implements Closeable {\n\n    public int findNextDataCount(int cycle, int threadId) throws IOException {\n        final String cycleStr = dateCache.formatFor(cycle);\n        final String cyclePath = basePath + \"/\" + cycleStr;\n        final String dataPrefix = FILE_NAME_PREFIX + threadId + \"-\";\n\n        int maxCount = -1;\n        final File[] files = new File(cyclePath).listFiles();\n        if (files != null) {\n            for (File file : files) {\n                if (file.getName().startsWith(dataPrefix)) {\n                    final int count = Integer.parseInt(file.getName().substring(dataPrefix.length()));\n                    if (maxCount < count)\n                        maxCount = count;\n                }\n            }\n        }\n        // Move to the next data file\n        return maxCount + 1;\n    }\n\n    public  VanillaDataCache(@NotNull String basePath, int blockBits, @NotNull DateCache dateCache);\n    public  VanillaDataCache(@NotNull String basePath, int blockBits, @NotNull DateCache dateCache, @NotNull VanillaChronicleConfig config);\n    public  VanillaDataCache(@NotNull String basePath, int blockBits, @NotNull DateCache dateCache, int capacity);\n    public  VanillaDataCache(@NotNull String basePath, int blockBits, @NotNull DateCache dateCache, int capacity, boolean cleanupOnClose);\n\n    public File fileFor(int cycle, int threadId, int dataCount, boolean forWrite);\n    public File fileFor(int cycle, int threadId);\n    public synchronized VanillaMappedBytes dataFor(int cycle, int threadId, int dataCount, boolean forWrite);\n    private void findEndOfData(final VanillaMappedBytes buffer);\n     int nextWordAlignment(int len);\n    @Override public synchronized void close();\n    public void checkCounts(int min, int max);\n\n}\n\nclass VanillaDataCacheTest  {\n\n    @Test\n    public void testFindNextDataCount() throws Exception {\n", "reference": "        final String baseDir = getTestPath();\n        assertNotNull(baseDir);\n\n        try {\n            final DateCache dateCache = new DateCache(\"yyyyMMddHHmmss\", 1000);\n            final VanillaDataCache cache = new VanillaDataCache(baseDir, 10 + 6, dateCache);\n\n            int cycle = (int) (System.currentTimeMillis() / 1000);\n            final int threadId = AffinitySupport.getThreadId();\n\n            // Check that the data file count starts at 0 when the data directory is empty\n            assertEquals(0, cache.findNextDataCount(cycle, threadId));\n\n            // Add some more data files into the directory - use discontinuous numbers to test reading\n            VanillaMappedBytes vanillaBuffer1 = cache.dataFor(cycle, threadId, 1, true);\n            vanillaBuffer1.release();\n\n            VanillaMappedBytes vanillaBuffer2 = cache.dataFor(cycle, threadId, 2, true);\n            vanillaBuffer2.release();\n\n            VanillaMappedBytes vanillaBuffer4 = cache.dataFor(cycle, threadId, 4, true);\n            vanillaBuffer4.release();\n\n            cache.checkCounts(1, 1);\n            cache.close();\n\n            // Open a new cache and check that it reads the existing data files that were created above\n            final VanillaDataCache cache2 = new VanillaDataCache(baseDir, 10 + 6, dateCache);\n\n            assertEquals(5, cache2.findNextDataCount(cycle, threadId));\n\n            cache.checkCounts(1, 1);\n            cache2.close();\n        } finally {\n            IOTools.deleteDir(baseDir);\n            assertFalse(new File(baseDir).exists());\n        }\n    }\n\n}", "prediction": "        VanillaDataCache cache = new VanillaDataCache(basePath, 10, dateCache);\n        assertEquals(1, cache.findNextDataCount(1, 0));\n        assertEquals(2, cache.findNextDataCount(1, 1));\n        assertEquals(3, cache.findNextDataCount(1, 2));\n        assertEquals(4, cache.findNextDataCount(1, 3));\n        assertEquals(5, cache.findNextDataCount(1, 4));\n        assertEquals(6, cache.findNextDataCount(1, 5));\n        assertEquals(7, cache.findNextDataCount(1, 6));\n        assertEquals(8, cache.findNextDataCount(1, 7));\n        assertEquals(9, cache.findNextDataCount(1, 8));\n        assertEquals(10, cache.findNextDataCount(1, 9));\n        assertEquals(11, cache.findNextDataCount(1, 10));\n        assertEquals(12, cache.findNextDataCount(1, 11));\n        assertEquals(13, cache.findNextDataCount(1, 12));\n        assertEquals(14, cache.findNextDataCount(1, 13));\n        assertEquals(15, cache.findNextDataCount(1, 14));\n        assertEquals(16, cache.findNextDataCount(1, 15));\n        assertEquals(17, cache.findNextDataCount(1, 16));\n        assertEquals(18, cache.findNextDataCount(1, 17));\n        assertEquals(19, cache.findNextDataCount(1, 18));\n        assertEquals(20, cache.findNextDataCount(1, 19));\n        assertEquals(21, cache.findNextData", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "23961325_6", "part": [1, 1], "seq": [1, 1], "prompt": "class Updater extends Task<UpdateSummary> {\n\n    @Override\n    protected UpdateSummary call() throws Exception {\n        highestLocalVersion = UpdateFX.extractVerFromFilename(UpdateFX.findBestJar(pathToOrigJar, localUpdatesDir));\n        newHighestVersion = highestLocalVersion;\n        UFXProtocol.Updates updates = processSignedIndex(downloadSignedIndex());\n        return new UpdateSummary(newHighestVersion, updates);\n    }\n\n    public  Updater(URI indexURL, String userAgent, Path localUpdatesDir,\n                   Path pathToOrigJar, List<ECPoint> pubkeys, int requiredSigningThreshold);\n\n    public void setOverrideURLs(boolean overrideURLs);\n    private UFXProtocol.SignedUpdates downloadSignedIndex();\n    private URLConnection openURL(URI url);\n    private UFXProtocol.Updates processSignedIndex(UFXProtocol.SignedUpdates signedUpdates);\n    private List<Path> downloadUpdates(LinkedList<UFXProtocol.Update> updates, long bytesToFetch);\n    private void processDownloadedUpdates(List<UFXProtocol.Update> updates, List<Path> files);\n    private URI maybeOverrideBaseURL(URI url);\n    private HashingOutputStream hashingFileStream(Path outfile);\n    private UFXProtocol.Updates validateSignatures(UFXProtocol.SignedUpdates updates);\n\n    private static final int HTTP_LOCAL_TEST_PORT;\n    public static final String SERVER_PATH;\n    private HttpServer localServer;\n    private Map<String, byte[]> paths;\n    private Updater updater;\n    private Path dir;\n    private URI indexURL;\n    private long workDone;\n    private List<BigInteger> privKeys;\n    private List<ECPoint> pubKeys;\n\n}\n\nclass UpdaterTest {\n\n    private static final int HTTP_LOCAL_TEST_PORT;\n    public static final String SERVER_PATH;\n    private HttpServer localServer;\n    private Map<String, byte[]> paths;\n    private Updater updater;\n    private Path dir;\n    private URI indexURL;\n    private long workDone;\n    private List<BigInteger> privKeys;\n    private List<ECPoint> pubKeys;\n\n    @Test(expected = SignatureException.class)\n    public void badSig() throws Exception {\n", "reference": "        byte[] fakePatch = new byte[1024];\n        Arrays.fill(fakePatch, (byte) 0x42);\n        paths.put(\"/2.jar.bpatch\", fakePatch);\n        UFXProtocol.SignedUpdates.Builder builder = makeWrongIndex();\n        builder.setSignatures(0, \"bzzzz\");\n        paths.put(\"/index\", builder.build().toByteArray());\n        updater = new TestUpdater(indexURL, \"UnitTest\", dir, null);\n        updater.call();\n    }\n\n}", "prediction": "        updater.setOverrideURLs(true);\n        updater.call();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "24729346_0", "part": [1, 1], "seq": [1, 1], "prompt": "class TelemetryData implements java.io.Serializable {\n\n\tpublic long getTotalDuration() {\n\t\treturn totalDuration;\n\t}\n\n\tpublic ObjectId getId();\n\tpublic void setId(ObjectId id);\n\tpublic List<String> getAppName();\n\tpublic void setAppName(List<String> appName);\n\tpublic List<String> getOldPlatformVersion();\n\tpublic void setOldPlatformVersion(List<String> oldPlatformVersion);\n\tpublic String getNewPlatformVersion();\n\tpublic void setNewPlatformVersion(String newPlatformVersion);\n\tpublic List<String> getDetectedAppType();\n\tpublic void setDetectedAppType(List<String> detectedAppType);\n\tpublic String getMigrationToolVersion();\n\tpublic void setMigrationToolVersion(String migrationToolVersion);\n\tpublic String getUserName();\n\tpublic void setUserName(String userName);\n\tpublic String getAdditionalEmails();\n\tpublic void setAdditionalEmails(String additionalEmails);\n\tpublic String getSourceGitURL();\n\tpublic void setSourceGitURL(String sourceGitURL);\n\tpublic String getDestinationGitURL();\n\tpublic void setDestinationGitURL(String destinationGitURL);\n\tpublic Date getStartTime();\n\tpublic void setStartTime(Date startTime);\n\tpublic String getOverrideAppType();\n\tpublic void setOverrideAppType(String overrideAppType);\n\tpublic String getTaskId();\n\tpublic void setTaskId(String taskId);\n\tpublic String getSourceGitBranch();\n\tpublic void setSourceGitBranch(String sourceGitBranch);\n\tpublic String getSourceGitRelativePath();\n\tpublic void setSourceGitRelativePath(String sourceGitRelativePath);\n\tpublic String getDestinationGitBranch();\n\tpublic void setDestinationGitBranch(String destinationGitBranch);\n\tpublic Boolean isGitForkSuccessful();\n\tpublic void setGitForkSuccessful(Boolean isGitForkSuccessful);\n\tpublic Boolean isGitCloneSuccessful();\n\tpublic void setGitCloneSuccessful(Boolean isGitCloneSuccessful);\n\tpublic Boolean isMigrationSuccessful();\n\tpublic void setMigrationSuccessful(Boolean isMigrationSuccessful);\n\tpublic Boolean isGitPushSuccesful();\n\tpublic void setGitPushSuccesful(Boolean isGitPushSuccesful);\n\tpublic static long getSerialversionuid();\n\tpublic long getGitForkDuration();\n\tpublic void setGitForkDuration(long gitForkDuration);\n\tpublic long getGitCloneDuration();\n\tpublic void setGitCloneDuration(long gitCloneDuration);\n\tpublic long getMigrationDuration();\n\tpublic void setMigrationDuration(long migrationDuration);\n\tpublic long getGitPushDuration();\n\tpublic void setGitPushDuration(long gitPushDuration);\n\tpublic void setTotalDuration(long totalDuration);\n\tpublic String getStartDate();\n\tpublic void setStartDate(String startDate);\n\tpublic Boolean isGitBranchSuccessful();\n\tpublic void setGitBranchSuccessful(Boolean isGitBranchSuccessful);\n\tpublic Boolean isGitPullSuccessful();\n\tpublic void setGitPullSuccessful(Boolean isGitPullSuccessful);\n\tpublic long getGitBranchDuration();\n\tpublic void setGitBranchDuration(long gitBranchDuration);\n\tpublic long getGitPullDuration();\n\tpublic void setGitPullDuration(long gitPullDuration);\n\tpublic Boolean isSuccess();\n\tpublic void setSuccess(Boolean success);\n\tpublic String getDebugLogURL();\n\tpublic void setDebugLogURL(String debugLogURL);\n\tpublic String getWarnLogURL();\n\tpublic void setWarnLogURL(String warnLogURL);\n\tpublic String getFinalReportURL();\n\tpublic void setFinalReportURL(String finalReportURL);\n\tpublic String getProgressReportURL();\n\tpublic void setProgressReportURL(String progressReportURL);\n\tpublic String getGitPullRequestURL();\n\tpublic void setGitPullRequestURL(String gitPullRequestURL);\n\t@Override public String toString();\n\n}\n\nclass TelemetryDataTest  {\n\n  @Test\n  public void testGetTotalDuration() {\n", "reference": "    // Do nothing\n  }\n\n}", "prediction": "    TelemetryData telemetryData = new TelemetryData();\n    telemetryData.setTotalDuration(100);\n    assertEquals(100, telemetryData.getTotalDuration());\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "24750302_75", "part": [1, 1], "seq": [1, 1], "prompt": "class PatchUtil {\n\n    public static <A, B> Map<A, B> setMap(Map<A, B> instance, Map<A, B> newValues, boolean patch) {\n        if (patch) {\n            if (newValues == null || newValues.size() == 0) {\n                return instance;\n            }\n        }\n\n        if (instance == null) {\n            instance = new HashMap<>();\n        }\n\n        if (patch) {\n            for (Map.Entry<A, B> entry : newValues.entrySet()) {\n                if (entry.getValue() == null || realValue(entry.getValue()) == null) {\n                    // remove\n                    instance.remove(entry.getKey());\n                } else {\n                    // add or update\n                    instance.put(entry.getKey(), entry.getValue());\n                }\n            }\n        } else {\n            instance.clear();\n            instance.putAll(safe(newValues));\n        }\n\n        return instance;\n    }\n\n    public static boolean set(Object instance, String fieldName, Object value, boolean patch);\n    public static T realValue(T value);\n\n    private TestObject testObject;\n\n}\n\nclass PatchUtilTest {\n\n    private TestObject testObject;\n\n    @Test\n    public void check_an_update_override_everything() throws Exception {\n", "reference": "        Map<String, String> patch = new HashMap<String, String>() {{\n            put(\"d\", \"4\");\n        }};\n\n        PatchUtil.setMap(testObject.getMap(), patch, false);\n\n        assertThat(testObject.getMap()).hasSize(1);\n        assertThat(testObject.getMap()).containsEntry(\"d\", \"4\");\n    }\n\n}", "prediction": "        Map<String, Object> newValues = new HashMap<>();\n        newValues.put(\"name\", \"new name\");\n        newValues.put(\"age\", 100);\n        newValues.put(\"address\", \"new address\");\n        newValues.put(\"phone\", \"new phone\");\n        newValues.put(\"email\", \"new email\");\n        newValues.put(\"birthday\", \"2017-01-01\");\n        newValues.put(\"gender\", \"F\");\n        newValues.put(\"married\", true);\n        newValues.put(\"children\", 10);\n        newValues.put(\"hobbies\", Arrays.asList(\"hobby1\", \"hobby2\"));\n        newValues.put(\"favoriteNumbers\", Arrays.asList(1, 2, 3));\n        newValues.put(\"favoriteColors\", Arrays.asList(\"red\", \"blue\"));\n        newValues.put(\"favoriteFoods\", Arrays.asList(\"food1\", \"food2\"));\n        newValues.put(\"favoriteMovies\", Arrays.asList(\"movie1\", \"movie2\"));\n        newValues.put(\"favoriteBooks\", Arrays.asList(\"book1\", \"book2\"));\n        newValues.put(\"favoriteSongs\", Arrays.asList(\"song1\", \"song2\"));\n        newValues.put(\"favoriteGames\", Arrays.asList(\"game1\", \"game2\"));\n        newValues.put(\"favoritePlaces\", Arrays.asList(\"place1\", \"place2\"));\n        newValues.put(\"favoriteActivities\", Arrays.asList(\"activity1\", \"activity2\"));\n        newValues.put(\"favoriteThings\", Arrays.asList(\"thing1\", \"thing2\"));\n        newValues.put(\"favoritePeople\", Arrays.asList(\"person1\", \"person2\"));\n        newValues.put(\"favoriteQuotes\", Arrays.asList(\"quote1\", \"quote2\"));\n        newValues.put(\"favoriteAuthors\", Arrays.asList(\"author1\", \"author2\"));\n        newValues.put(\"favoriteArtists\", Arrays.asList(\"artist1\", \"artist2\"));\n        newValues.put(\"favoriteActors\", Arrays.asList(\"actor1\", \"actor2\"));\n        newValues.put(\"favoriteActresses\", Arrays.asList(\"actress1\", \"actress2\"));\n        newValues.put(\"favoriteMusicians\", Arrays.asList(\"musician1\", \"musician2\"));\n        newValues.put(\"favoriteSports\", Arrays.asList(\"sport1\", \"sport2\"));\n        newValues.put(\"favoriteBooks\", Arrays.asList(\"book1\", \"book2\"));\n        newValues.put(\"favoriteMovies\", Arrays.asList(\"movie1\", \"movie2\"));\n        newValues.put(\"favoriteGames\", Arrays.asList(\"game1\", \"game2\"));\n        newValues.put(\"favoritePlaces\", Arrays.asList(\"place1\", \"place2\"));\n        newValues.put(\"favoriteActivities\", Arrays.asList(\"activity1\", \"activity2\"));\n        newValues.put(\"favoriteThings\", Arrays.asList(\"thing1\", \"thing2\"));\n        newValues.put(\"favoritePeople\", Arrays.asList(\"person1\", \"person2\"));\n        newValues.put(\"favoriteQuotes\", Arrays.asList(\"quote1\", \"quote2\"));\n        newValues.put(\"favoriteAuthors\", Arrays.asList(\"author1\", \"author2\"));\n        newValues.put(\"favoriteArtists\", Arrays.asList(\"artist1\", \"artist2\"));\n        newValues.put(\"favoriteActors\", Arrays.asList(\"actor1\", \"actor2\"));\n        newValues.put(\"favoriteActresses\", Arrays.asList(\"actress1\", \"actress2\"));\n        newValues.put(\"favoriteMusicians\", Arrays.asList(\"musician1\", \"musician2\"));\n        newValues.put(\"favoriteSports\", Arrays.asList(\"sport1\", \"sport2\"));\n        newValues.put(\"favoriteBooks\", Arrays.asList(\"book1\", \"book2\"));\n        newValues.put(\"favoriteMovies\", Arrays.asList(\"movie1\", \"movie2\"));\n        newValues", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "24917019_37", "part": [1, 1], "seq": [1, 1], "prompt": "class DynamoDBMissionWorker implements Callable<Map<Integer, String>> {\n\n    public static Map<Integer, String> getSolJSON(final URL url, final int connectTimeout) throws IOException {\n        final Map<Integer, String> map = new HashMap<Integer, String>();\n        // Retrieve the JSON data\n        final JsonNode manifest = JSONParser.getJSONFromURL(url, connectTimeout);\n        // Validate the JSON data version\n        if (!manifest.has(RESOURCE_TYPE_KEY) || !SUPPORTED_TYPES.contains(manifest.get(RESOURCE_TYPE_KEY).asText())) {\n            throw new IllegalArgumentException(\"Manifest version verification failed\");\n        }\n        // Validate that the JSON data contains a sol list\n        if (!manifest.has(SOLS_LIST_KEY)) {\n            throw new IllegalArgumentException(\"Manifest does not contain a sol list\");\n        }\n        final ArrayNode sols = (ArrayNode) manifest.get(SOLS_LIST_KEY);\n        // Process each sol in the sol list\n        for (int i = 0; i < sols.size(); i++) {\n            final JsonNode sol = sols.path(i);\n            if (sol.has(SOL_ID_KEY) && sol.has(SOL_URL_KEY)) {\n                final Integer solID = sol.get(SOL_ID_KEY).asInt();\n                final String solURL = sol.get(SOL_URL_KEY).asText();\n                if (solID != null && solURL != null) {\n                    // Add valid sol to the map\n                    map.put(solID, solURL);\n                } else {\n                    LOGGER.warning(\"Sol contains unexpected values: \" + sol);\n                }\n            } else {\n                LOGGER.warning(\"Sol missing required keys: \");\n            }\n        }\n        return map;\n    }\n\n    public  DynamoDBMissionWorker(final String manifestURL, final int connectTimeout);\n\n    @Override public Map<Integer, String> call();\n\n    private static final String IMAGE_RESOURCE_FILE;\n    private static final String INVALID_VERSION_FILE;\n    private static final String MISSING_SOL_LIST_FILE;\n    private static final String MISSING_SOL_ID_FILE;\n    private static final String MISSING_SOL_URL_FILE;\n    private static final Map<Integer, String> EXPECTED_MAP;\n    @Rule\n    public ExpectedException expectedEx;\n\n}\n\nclass DynamoDBMissionWorkerTest {\n\n    private static final String IMAGE_RESOURCE_FILE;\n    private static final String INVALID_VERSION_FILE;\n    private static final String MISSING_SOL_LIST_FILE;\n    private static final String MISSING_SOL_ID_FILE;\n    private static final String MISSING_SOL_URL_FILE;\n    private static final Map<Integer, String> EXPECTED_MAP;\n    @Rule\n    public ExpectedException expectedEx;\n\n    @Test\n    public void testInvalidVersion() {\n", "reference": "        expectedEx.expect(IllegalArgumentException.class);\n        expectedEx.expectMessage(\"version verification failed\");\n        final URL url = PowerMock.createMock(URL.class);\n        PowerMock.mockStatic(JSONUtils.class);\n        PowerMock.mockStatic(NetworkUtils.class);\n        String manifest = null;\n        try {\n            manifest = WorkerTestUtils.readFile(INVALID_VERSION_FILE);\n        } catch (final IOException e) {\n            fail(\"Could not read file: \" + INVALID_VERSION_FILE);\n        }\n        try {\n            NetworkUtils.getDataFromURL(url, null, ImageIngester.DEFAULT_CONNECT_TIMEOUT);\n            PowerMock.expectLastCall().andReturn(manifest.getBytes());\n            PowerMock.replayAll();\n            DynamoDBMissionWorker.getSolJSON(url, ImageIngester.DEFAULT_CONNECT_TIMEOUT);\n        } catch (final IOException e) {\n            fail(e.getMessage());\n        }\n        fail(\"Version is incorrect\");\n    }\n\n}", "prediction": "        expectedEx.expect(IllegalArgumentException.class);\n        expectedEx.expectMessage(INVALID_VERSION_FILE);\n        DynamoDBMissionWorker.getSolJSON(new URL(IMAGE_RESOURCE_FILE), 1000);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "25040346_0", "part": [1, 1], "seq": [1, 1], "prompt": "class Encoder extends MediaCodecPlugin implements ITransform, ISurfaceCreator {\n\n    @Override\n    public void pull(Frame frame) {\n        throw new UnsupportedOperationException(\"Unexpected call of pull() in Encoder.\");\n    }\n\n    public  Encoder(IMediaCodec mediaCodec);\n\n    @Override public ISurface getSurface();\n    @Override public ISurface getSimpleSurface(IEglContext eglContext);\n    @Override public void checkIfOutputQueueHasData();\n    @Override public void push(Frame frame);\n    @Override public void configure();\n    @Override public void onSurfaceAvailable(IOnSurfaceReady listener);\n    @Override public void releaseOutputBuffer(int outputBufferIndex);\n    @Override public void setTrackId(int trackId);\n    @Override public void close();\n\n}\n\nclass EncoderTest extends MediaCodecPlugin {\n\n    @Test(expected = UnsupportedOperationException.class)\n    public void pull_shouldThrowUnsupportedOperationException() {\n", "reference": "        VideoEncoder videoEncoder = create.videoEncoder().construct();\n        videoEncoder.pull(create.frame().construct());\n    }\n\n}", "prediction": "        Encoder encoder = new Encoder(null);\n        encoder.pull(null);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "25881432_0", "part": [1, 1], "seq": [1, 1], "prompt": "class CloudShellCredential extends GoogleCredential {\n\n  @Override\n  protected TokenResponse executeRefreshToken()\n      throws IOException {\n    Socket socket = new Socket(\"localhost\", this.getAuthPort());\n    socket.setSoTimeout(READ_TIMEOUT_MS);\n    TokenResponse token = new TokenResponse();\n    try {\n      PrintWriter out =\n        new PrintWriter(socket.getOutputStream(), true);\n      out.println(GET_AUTH_TOKEN_REQUEST);\n\n      BufferedReader input =\n          new BufferedReader(new InputStreamReader(socket.getInputStream()));\n      // Ignore the size line\n      input.readLine();\n\n      Collection<Object> messageArray = jsonFactory.createJsonParser(input)\n        .parseArray(LinkedList.class, Object.class);\n      String accessToken = ((List<Object>) messageArray).get(ACCESS_TOKEN_INDEX).toString();\n      token.setAccessToken(accessToken);\n    } finally {\n      socket.close();\n    }\n    return token;\n  }\n\n  public  CloudShellCredential(int authPort, JsonFactory jsonFactory);\n\n  protected int getAuthPort();\n\n}\n\nclass CloudShellCredentialTest {\n\n  @Test\n  public void refreshAccessToken() throws IOException{\n", "reference": "    final ServerSocket authSocket = new ServerSocket(0);\n    Runnable serverTask =\n        new Runnable() {\n          @Override\n          public void run() {\n            try {\n              Socket clientSocket = authSocket.accept();\n              BufferedReader input =\n                  new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n              String lines = input.readLine();\n              lines += '\\n' + input.readLine();\n              assertEquals(CloudShellCredential.GET_AUTH_TOKEN_REQUEST, lines);\n\n              PrintWriter out =\n                  new PrintWriter(clientSocket.getOutputStream(), true);\n              out.println(\"32\\n[\\\"email\\\", \\\"project-id\\\", \\\"token\\\", 1234]\");\n            } catch (Exception reThrown) {\n              throw new RuntimeException(reThrown);\n            }\n          }\n        };\n    Thread serverThread = new Thread(serverTask);\n    serverThread.start();\n\n    GoogleCredential creds = new CloudShellCredential(\n        authSocket.getLocalPort(), GsonFactory.getDefaultInstance());\n    assertEquals(\"token\", creds.executeRefreshToken().getAccessToken());\n  }\n\n}", "prediction": "    CloudShellCredential credential = new CloudShellCredential(1234, null);\n    TokenResponse token = credential.executeRefreshToken();\n    assertEquals(\"accessToken\", token.getAccessToken());\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "25884252_5", "part": [1, 1], "seq": [1, 1], "prompt": "class FreebaseHelper {\n\n\tpublic Entity getNameForID(String id) throws IOException {\n\t\tString trimmedID = id.replaceAll(\"\\\\.\", \"/\");\n\t\tif (!trimmedID.startsWith(\"/\")) {\n\t\t\ttrimmedID = \"/\" + trimmedID;\n\t\t}\n\t\tString metaURL = FREEBASE_SEARCH_API.replace(\"{id}\", trimmedID);\n\n\t\tJsonNode jsonNode = getURL(metaURL);\n\n\t\tLOG.trace(metaURL);\n\n\t\tif (jsonNode.get(\"result\").size() < 1) {\n\t\t\tLOG.error(\"No results for mid {}\", id);\n\t\t\treturn null;\n\t\t}\n\n\t\tJsonNode result = jsonNode.get(\"result\").get(0);\n\n\t\tString name = result.has(\"name\") ? result.get(\"name\").asText() : \"\";\n\n\t\tEntity person = new Entity(id, name);\n\n\t\tfinal JsonNode output = result.get(\"output\");\n\n\t\tif (output.has(\"type\")) {\n\t\t\tfinal JsonNode types = output.get(\"type\").get(\"/type/object/type\");\n\t\t\tperson.types = Lists.newArrayList(Iterables.transform(types, new Function<JsonNode, String>() {\n\t\t\t\t@Nullable\n\t\t\t\t@Override\n\t\t\t\tpublic String apply(@Nullable JsonNode type) {\n\t\t\t\t\treturn type.get(\"id\").asText();\n\t\t\t\t}\n\t\t\t}));\n\t\t}\n\n\t\tif (output.has(\"/common/topic/alias\")) {\n\t\t\tfinal JsonNode alias = output.get(\"/common/topic/alias\").get(\"/common/topic/alias\");\n\t\t\tif (alias != null) {\n\t\t\t\tperson.alias = Lists.newArrayList(Iterables.transform(alias, new Function<JsonNode, String>() {\n\t\t\t\t\t@Nullable\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String apply(@Nullable JsonNode alias) {\n\t\t\t\t\t\treturn alias.asText();\n\t\t\t\t\t}\n\t\t\t\t}));\n\t\t\t}\n\t\t}\n\n\n\t\treturn person;\n\t}\n\n\tprivate JsonNode getURL(String metaURL);\n\tpublic static String transformOldToNewId(String old);\n\tpublic static String transformNewToOldId(String newId);\n\tpublic Entity getNameForIDs(String id);\n\tpublic boolean checkIfCompoundRelationHolds(String id1, String id2, String[] relation);\n\tprivate String getInverseRelation(String relation);\n\tprivate JsonNode getFreebaseTopicForID(String freebaseID);\n\tpublic FreebaseRelation getTypesForRelationFromFreebase(String r);\n\tpublic void readAllInverseRelations();\n\tpublic static void main(String[] args);\n\n}\n\nclass FreebaseHelperTest {\n\n\t@Test\n\tpublic void testReplacedTopic() throws Exception {\n", "reference": "\t\tFreebaseHelper  freebaseHelper = new FreebaseHelper();\n\n\t\tfinal FreebaseHelper.Entity nameForID = freebaseHelper.getNameForID(\"/m/07mt8q3\");\n\n\t\tSystem.out.println(nameForID);\n\n\t}\n\n}", "prediction": "\t\tString id = \"/en/john_f_kennedy\";\n\t\tEntity entity = FreebaseHelper.getInstance().getNameForID(id);\n\t\tassertEquals(\"John F. Kennedy\", entity.name);\n\t}", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "25927306_42", "part": [1, 1], "seq": [1, 1], "prompt": "class IntegerType extends AbstractDERType implements DEREncoder {\n\n  public static int decodeUnsignedPrimitive(final DERBuffer encoded)\n  {\n    // CheckStyle:MagicNumber OFF\n    final byte[] bytes = encoded.getRemainingBytes();\n    if (bytes.length > 4) {\n      throw new IllegalArgumentException(\"Buffer length must be <= 4 bytes\");\n    }\n    int i = 0;\n    for (byte b : bytes) {\n      i <<= 8;\n      i |= b & 0xFF;\n    }\n    return i;\n    // CheckStyle:MagicNumber ON\n  }\n\n  public  IntegerType(final BigInteger item);\n  public  IntegerType(final int item);\n  public  IntegerType(final DERTag tag, final BigInteger item);\n  public  IntegerType(final DERTag tag, final int item);\n\n  @Override public byte[] encode();\n  public static BigInteger decode(final DERBuffer encoded);\n  public static BigInteger decodeUnsigned(final DERBuffer encoded);\n  public static byte[] toBytes(final BigInteger i);\n\n}\n\nclass IntegerTypeTest {\n\n  @Test(groups = \"asn1\", dataProvider = \"ints\")\n  public void decodeUnsignedPrimitive(\n    final byte[] bytes, final BigInteger expected, final BigInteger unsigned, final int unsignedPrim)\n    throws Exception\n  {\n", "reference": "    Assert.assertEquals(IntegerType.decodeUnsignedPrimitive(new DefaultDERBuffer(bytes)), unsignedPrim);\n  }\n\n}", "prediction": "    Assert.assertEquals(IntegerType.decodeUnsignedPrimitive(new DERBuffer(bytes)), unsignedPrim);\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "26170170_3", "part": [1, 1], "seq": [1, 1], "prompt": "class GuestService {\n\n    public List<Guest> getAllGuests() {\n        CriteriaQuery<Guest> cq = this.em.getCriteriaBuilder().createQuery(Guest.class);\n        cq.select(cq.from(Guest.class));\n        return this.em.createQuery(cq).getResultList();\n    }\n\n    public  GuestService();\n    @Inject public  GuestService(@Background Event<Guest> guestEvents);\n\n    public void setEntityManager(EntityManager em);\n    public void saveGuest(Guest guest);\n    public Guest findSingleGuestById(@PathParam(\"guestId\") Long guestId);\n    public Optional<Guest> findById(@PathParam(\"guestId\") Long guestId);\n    public Optional<Guest> updateGuestDetails(Guest guest);\n    public Optional<Guest> findByPublicId(String publicId);\n    public boolean deleteGuest(@NotNull String publicId);\n\n    private GuestService guestService;\n    private static final Long WELL_KNOWN_ID;\n\n}\n\nclass GuestServiceTest  {\n\n    private GuestService guestService;\n    private static final Long WELL_KNOWN_ID;\n\n    @Test\n    public void finding_all_guests_does_not_return_null() {\n", "reference": "        assertThat(guestService.getAllGuests()).isNotNull();\n    }\n\n}", "prediction": "        List<Guest> guests = guestService.getAllGuests();\n        assertThat(guests).isNotNull();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "27030629_4", "part": [1, 1], "seq": [1, 1], "prompt": "class UserModelDataMapper {\n\n  public UserModel transform(User user) {\n    if (user == null) {\n      throw new IllegalArgumentException(\"Cannot transform a null value\");\n    }\n    UserModel userModel = new UserModel(user.getUserId());\n    userModel.setFullName(user.getFullName());\n\n    return userModel;\n  }\n\n  public Collection<UserModel> transform(Collection<User> usersCollection);\n\n    private static final int FAKE_USER_ID;\n    private static final String FAKE_FULLNAME;\n    private UserModelDataMapper userModelDataMapper;\n\n}\n\nclass UserModelDataMapperTest  {\n\n    private static final int FAKE_USER_ID;\n    private static final String FAKE_FULLNAME;\n    private UserModelDataMapper userModelDataMapper;\n\n    @Test\n    public void testTransformUserCollection() {\n", "reference": "        User mockUserOne = mock(User.class);\n        User mockUserTwo = mock(User.class);\n\n        List<User> userList = new ArrayList<>(5);\n        userList.add(mockUserOne);\n        userList.add(mockUserTwo);\n\n        Collection<UserModel> userModelList = userModelDataMapper.transform(userList);\n\n        assertThat(userModelList.toArray()[0], is(instanceOf(UserModel.class)));\n        assertThat(userModelList.toArray()[1], is(instanceOf(UserModel.class)));\n        assertThat(userModelList.size(), is(2));\n    }\n\n}", "prediction": "        // Given\n        User user = new User(FAKE_USER_ID, FAKE_FULLNAME);\n        Collection<User> usersCollection = new ArrayList<>();\n        usersCollection.add(user);\n\n        // When\n        Collection<UserModel> userModelCollection = userModelDataMapper.transform(usersCollection);\n\n        // Then\n        assertEquals(userModelCollection.size(), 1);\n        assertEquals(userModelCollection.iterator().next().getUserId(), FAKE_USER_ID);\n        assertEquals(userModelCollection.iterator().next().getFullName(), FAKE_FULLNAME);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "27062690_0", "part": [1, 1], "seq": [1, 1], "prompt": "class XModifier {\n\n    private void create(Node parent, XModifyNode node) throws XPathExpressionException {\n        Node newNode;\n        if (node.isAttributeModifier()) {\n            //attribute\n            createAttributeByXPath(parent, node.getCurNode().substring(1), node.getValue());\n        } else {\n            //element\n            if (node.isRootNode()) {\n                //root node\n                newNode = parent;\n                boolean canMoveToNext = node.moveNext();\n                if (!canMoveToNext) {\n                    //last node\n                    newNode.setTextContent(node.getValue());\n                } else {\n                    //next node\n                    create(newNode, node);\n                }\n            } else if (node.getCurNode().equals(\"text()\")) {\n                parent.setTextContent(node.getValue());\n            } else {\n                //element\n                findOrCreateElement(parent, node);\n            }\n        }\n\n    }\n\n    public  XModifier(Document document);\n\n    public void setNamespace(String prefix, String url);\n    public void addModify(String xPath, String value);\n    public void addModify(String xPath);\n    public void modify();\n    private void initXPath();\n    private void createAttributeByXPath(Node node, String current, String value);\n    private void findOrCreateElement(Node parent, XModifyNode node);\n    private Element createNewElement(String namespaceURI, String local, String[] conditions);\n\n}\n\nclass XModifierTest {\n\n    @Test\n    public void create() throws ParserConfigurationException, IOException, SAXException {\n", "reference": "        Document document = createDocument();\n        Document documentExpected = readDocument(\"createExpected.xml\");\n        XModifier modifier = new XModifier(document);\n        modifier.setNamespace(\"ns\", \"http://localhost\");\n        // create an empty element\n        modifier.addModify(\"/ns:root/ns:element1\");\n        // create an element with attribute\n        modifier.addModify(\"/ns:root/ns:element2[@attr=1]\");\n        // append an new element to existing element1\n        modifier.addModify(\"/ns:root/ns:element1/ns:element11\");\n        // create an element with text\n        modifier.addModify(\"/ns:root/ns:element3\", \"TEXT\");\n        modifier.modify();\n        assertXmlEquals(documentExpected, document);\n    }\n\n}", "prediction": "        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        DocumentBuilder builder = factory.newDocumentBuilder();\n        Document document = builder.newDocument();\n        XModifier xModifier = new XModifier(document);\n        xModifier.addModify(\"//*[@id='root']/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/div/", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "27064201_0", "part": [1, 1], "seq": [1, 1], "prompt": "class RemoteFileDescriptor extends RemoteFileDescriptorBase<Void> {\n\n  @Override\n  public synchronized void close() throws IOException {\n    FileDescriptor fd = getFileDescriptor();\n    if (fd != null && fd.valid()) {\n      new FileInputStream(fd).close();\n    }\n  }\n\n  public  RemoteFileDescriptor();\n  public  RemoteFileDescriptor(AFUNIXRMISocketFactory socketFactory, FileDescriptor fd);\n\n  private static final String TEST_SERVICE_NAME;\n  private static final byte[] HELLO_WORLD;\n  private static final byte[] SMILEY;\n  private static AFUNIXNaming namingInstance;\n  private static RemoteFileDescriptorTestServiceImpl testService;\n\n}\n\nclass RemoteFileDescriptorTest {\n\n  private static final String TEST_SERVICE_NAME;\n  private static final byte[] HELLO_WORLD;\n  private static final byte[] SMILEY;\n  private static AFUNIXNaming namingInstance;\n  private static RemoteFileDescriptorTestServiceImpl testService;\n\n  @Test\n  public void testWriteAndReadHello() throws Exception {\n", "reference": "    RemoteFileDescriptorTestService svc = (RemoteFileDescriptorTestService) namingInstance\n        .getRegistry().lookup(TEST_SERVICE_NAME);\n\n    try (FileOutputStream fos = svc.output().asFileOutputStream()) {\n      fos.write(HELLO_WORLD);\n    }\n    svc.verifyContents(HELLO_WORLD);\n\n    try (FileInputStream fin = svc.input(12).asFileInputStream()) {\n      byte[] data = TestUtils.readAllBytes(fin);\n      assertArrayEquals(SMILEY, data);\n    }\n\n    try (NaiveFileInputStreamRemote rfis = svc.naiveInputStreamRemote();\n        FileInputStream fin = rfis.getRemoteFileDescriptor().asFileInputStream()) {\n      assertEquals('H', rfis.read());\n      assertEquals('e', fin.read());\n      assertEquals('l', fin.read());\n      assertEquals('l', fin.read());\n      fin.close(); // it's OK to close the remote file descriptor we received via RMI\n      assertEquals('o', rfis.read());\n    }\n  }\n\n}", "prediction": "    RemoteFileDescriptor fd = new RemoteFileDescriptor();\n    fd.write(HELLO_WORLD);\n    byte[] buf = new byte[HELLO_WORLD.length];\n    fd.read(buf);\n    assertArrayEquals(HELLO_WORLD, buf);\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "27147147_24", "part": [1, 1], "seq": [1, 1], "prompt": "class Settings implements Serializable {\n\n    Object put(String key, @Nullable Object value) {\n        Preconditions.checkNotNull(key);\n        return put(\"<direct call>\", key, value);\n    }\n\n      Settings();\n\n    public synchronized void loadFromClassPath(String location);\n    public synchronized void loadFromProperties(Properties p);\n    public synchronized void loadFromFile(String location);\n    synchronized void loadOverrides();\n     void substituteVariables(Properties p);\n    private void putAll(String source, Properties p);\n     Object remove(String source, String key);\n     Object remove(String key);\n    private Object put(String source, String key, @Nullable Object value);\n    private void broadcastSettingChanged(\n            String key, Object oldValue, Object newValue);\n    public Object set(String source, String setting, @Nullable String value);\n    public Object set(String setting, @Nullable String value);\n    public static KeyIteratorFilter startsWith(String prefix);\n    public static KeyIteratorFilter endsWith(String prefix);\n    public static KeyIteratorFilter contains(String string);\n    public static KeyIteratorFilter notContains(String string);\n    public static KeyIteratorFilter matches(String regex);\n    public static KeyIteratorFilter[] join(KeyIteratorFilter filter,\n                                           KeyIteratorFilter... filters);\n    public Keys keys();\n    public Keys keys(@Nullable KeyIteratorFilter... filter);\n    public MappedSettings<T> map(@Nullable String prefix, Class<T> type);\n    public MappedSettings<T> map(@Nullable String prefix,\n                                     Class<T> type,\n                                     KeyIteratorFilter... filters);\n    public boolean isDefined(String key);\n    @Nullable public String getString(String key);\n    @Nullable public Integer getInteger(String key);\n    @Nullable public Long getLong(String key);\n    @Nullable public Double getDouble(String key);\n    public Boolean getBoolean(String key);\n    @Nullable public BigDecimal getBigDecimal(String key);\n    public String getString(String key, String defaultValue);\n    public Long getLong(String key, @Nullable Long defaultValue);\n    public Integer getInteger(String key, @Nullable Integer defaultValue);\n    public Double getDouble(String key, @Nullable Double defaultValue);\n    @Nullable public BigDecimal getBigDecimal(String key, @Nullable BigDecimal defaultValue);\n    public Boolean getBoolean(String key, @Nullable Boolean defaultValue);\n    public Properties asProperties();\n    public Properties asProperties(@Nullable String prefixForCutoff);\n    public Map<String, String> asMap();\n    public Map<String, String> asMap(@Nullable String prefixForCutoff);\n    public synchronized List<String> getLocationsLoaded();\n    public void addListener(SettingsListener l);\n    public void removeListener(SettingsListener l);\n    @Override public String toString();\n    public static SettingsBuilder builder();\n\n}\n\nclass SettingsTest {\n\n    @Test\n    public void testSettingsModule() {\n", "reference": "        Settings settings = new Settings();\n        settings.put(\"foo\", \"bar\");\n        Bootstrap bootstrap = new Bootstrap(settings);\n        WhatsYourFoo instance = bootstrap.getInjector().getInstance(WhatsYourFoo.class);\n        Assert.assertEquals(\"bar\", instance.foo);\n    }\n\n}", "prediction": "        Settings settings = Settings.builder().build();\n        assertNotNull(settings);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "28214426_7", "part": [1, 1], "seq": [1, 1], "prompt": "class StructuredLoggerImpl implements StructuredLogger {\n\n  public void error(final Supplier<SchemaAndValue> msgSupplier) {\n    if (!inner.isErrorEnabled()) {\n      return;\n    }\n    error(msgSupplier.get());\n  }\n\n    StructuredLoggerImpl(final Logger inner);\n\n  public String getName();\n  public void error(final SchemaAndValue msg);\n  public void info(final Supplier<SchemaAndValue> msgSupplier);\n  public void info(final SchemaAndValue msg);\n  public void debug(final Supplier<SchemaAndValue> msgSupplier);\n  public void debug(final SchemaAndValue msg);\n\n  private final static String LOG_MSG;\n  @Mock\n  private Logger innerLogger;\n  @Mock\n  private SchemaAndValue msg;\n  @Mock\n  private Supplier<SchemaAndValue> msgSupplier;\n  @Captor\n  private ArgumentCaptor<SerializableSchemaAndValue> captor;\n  private StructuredLoggerImpl logger;\n  @Rule\n  public MockitoRule rule;\n\n}\n\nclass StructuredLoggerImplTest {\n\n  private final static String LOG_MSG;\n  @Mock\n  private Logger innerLogger;\n  @Mock\n  private SchemaAndValue msg;\n  @Mock\n  private Supplier<SchemaAndValue> msgSupplier;\n  @Captor\n  private ArgumentCaptor<SerializableSchemaAndValue> captor;\n  private StructuredLoggerImpl logger;\n  @Rule\n  public MockitoRule rule;\n\n  @Test\n  public void shouldNotGetMessageIfLoggerDisabledForError() {\n", "reference": "    // Given:\n    when(innerLogger.isErrorEnabled()).thenReturn(false);\n\n    // When:\n    logger.error(msgSupplier);\n\n    // Then:\n    verify(innerLogger).isErrorEnabled();\n    verifyNoMoreInteractions(innerLogger, msgSupplier);\n  }\n\n}", "prediction": "    when(innerLogger.isErrorEnabled()).thenReturn(false);\n    logger.error(msgSupplier);\n    verify(innerLogger, never()).error(any(SerializableSchemaAndValue.class));\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "28394156_18", "part": [1, 1], "seq": [1, 1], "prompt": "class JavaExecutor implements Executor {\n\n    Object execute(String className, String methodName, JavaExecutionParametersProvider parametersProvider) {\n        ClassLoader origCL = Thread.currentThread().getContextClassLoader();\n        try {\n            Thread.currentThread().setContextClassLoader(classLoader);\n            Class actionClass = getActionClass(className);\n            Method executionMethod = getMethodByName(actionClass, methodName);\n\n            Object[] executionParameters = parametersProvider.getExecutionParameters(executionMethod);\n            Object[] transformedExecutionParameters = transformExecutionParameters(executionParameters,\n                    executionMethod);\n\n            return executionMethod.invoke(actionClass.newInstance(), transformedExecutionParameters);\n        } catch (Exception e) {\n            throw new RuntimeException(\n                    \"Method [\" + methodName + \"] invocation of class [\" + className + \"] failed: \" + e.getMessage(), e);\n        } finally {\n            Thread.currentThread().setContextClassLoader(origCL);\n        }\n    }\n\n      JavaExecutor(Set<String> filePaths);\n\n    public static ClassLoader getParentClassLoader();\n    private Object[] transformExecutionParameters(Object[] oldExecutionParameters, Method executionMethod);\n    private Object getFieldValue(String fieldName, Class<?> currentParameterClass, Object currentParameter);\n    private Object getFieldValueFromSuperClass(String fieldName, Class<?> currentParameterClass,\n                                               Object currentParameter);\n    private void setValue(Object value, Class<?> currentParameterClass, Object currentParameter);\n    private void setName(Object name, Class<?> currentParameterClass, Object currentParameter);\n    private void setField(String fieldId, Object fieldValue, Class<?> fieldType, Class<?> currentParameterClass,\n                          Object currentParameter);\n    private boolean isSerializableSessionObjectMismatch(Class<?> expectedClass, Class<?> currentParameterClass);\n    private Class getActionClass(String className);\n    private Method getMethodByName(Class actionClass, String methodName);\n    @Override public void allocate();\n    @Override public void release();\n    @Override public void close();\n\n    private static final String CLASS_NAME;\n    private static final String METHOD_NAME;\n    private static final JavaExecutionParametersProvider PARAM_PROVIDER;\n    @Rule\n    public ExpectedException expectedEx;\n\n}\n\nclass JavaExecutorTest {\n\n    private static final String CLASS_NAME;\n    private static final String METHOD_NAME;\n    private static final JavaExecutionParametersProvider PARAM_PROVIDER;\n    @Rule\n    public ExpectedException expectedEx;\n\n    @Test\n    public void testJavaExecutorDifferentClassloaders() {\n", "reference": "\n        File one1 = new File(getClass().getClassLoader().getResource(\"one1.zip\").getFile());\n        File one2 = new File(getClass().getClassLoader().getResource(\"one2.zip\").getFile());\n        File one3 = new File(getClass().getClassLoader().getResource(\"one3.zip\").getFile());\n\n        File another1 = new File(getClass().getClassLoader().getResource(\"another1.zip\").getFile());\n        File another2 = new File(getClass().getClassLoader().getResource(\"another2.zip\").getFile());\n        File another3 = new File(getClass().getClassLoader().getResource(\"another3.zip\").getFile());\n\n        JavaExecutor javaExecutor1 = new JavaExecutor(new HashSet<>(Arrays.asList(one1.getAbsolutePath(), another2.getAbsolutePath())));\n        JavaExecutor javaExecutor2 = new JavaExecutor(new HashSet<>(Arrays.asList(one2.getAbsolutePath(), another3.getAbsolutePath())));\n        JavaExecutor javaExecutor3 = new JavaExecutor(new HashSet<>(Arrays.asList(one3.getAbsolutePath(), another1.getAbsolutePath())));\n\n        assertEquals(\"The version is One 1 and [The version is Another 2]\", javaExecutor1.execute(CLASS_NAME, METHOD_NAME, PARAM_PROVIDER).toString());\n        assertEquals(\"The version is One 2 and [The version is Another 3]\", javaExecutor2.execute(CLASS_NAME, METHOD_NAME, PARAM_PROVIDER).toString());\n        assertEquals(\"The version is One 3 and [The version is Another 1]\", javaExecutor3.execute(CLASS_NAME, METHOD_NAME, PARAM_PROVIDER).toString());\n\n        assertEquals(\"The version is One 1 and [The version is Another 2]\", javaExecutor1.execute(CLASS_NAME, METHOD_NAME, PARAM_PROVIDER).toString());\n        assertEquals(\"The version is One 2 and [The version is Another 3]\", javaExecutor2.execute(CLASS_NAME, METHOD_NAME, PARAM_PROVIDER).toString());\n        assertEquals(\"The version is One 3 and [The version is Another 1]\", javaExecutor3.execute(CLASS_NAME, METHOD_NAME, PARAM_PROVIDER).toString());\n    }\n\n}", "prediction": "        JavaExecutor executor = new JavaExecutor(new HashSet<String>());\n        executor.execute(CLASS_NAME, METHOD_NAME, PARAM_PROVIDER);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "28505345_59", "part": [1, 1], "seq": [1, 1], "prompt": "class HttpHeaderParser {\n\n    public static Cache.Entry parseCacheHeaders(NetworkResponse response) {\n        long now = System.currentTimeMillis();\n\n        Headers headers = response.headers;\n\n        long serverDate = 0;\n        long lastModified = 0;\n        long serverExpires = 0;\n        long softExpire = 0;\n        long finalExpire = 0;\n        long maxAge = 0;\n        long staleWhileRevalidate = 0;\n        boolean hasCacheControl = false;\n        boolean mustRevalidate = false;\n\n        String serverEtag = null;\n        String headerValue;\n        List<String> headerValues;\n\n        headerValue = headers.get(\"Date\");\n        if (headerValue != null) {\n            serverDate = parseDateAsEpoch(headerValue);\n        }\n\n        //TODO check multiple cache and make stale if more than 1 value for given directive\n        headerValues = headers.values(\"Cache-Control\");\n        if (headerValues != null && headerValues.size() > 0) {\n            hasCacheControl = true;\n            for (int i = 0; i < headerValues.size(); i++) {\n                String[] tokens = headerValues.get(i).trim().split(\",\");\n                for (int j = 0; j < tokens.length; j++) {\n                    String token = tokens[j].trim();\n                    if (token.equals(\"no-cache\") || token.equals(\"no-store\")) {\n                        return null;\n                    } else if (token.startsWith(\"max-age=\")) {\n                        try {\n                            maxAge = Long.parseLong(token.substring(8));\n                        } catch (Exception e) {\n                        }\n                    } else if (token.startsWith(\"stale-while-revalidate=\")) {\n                        try {\n                            staleWhileRevalidate = Long.parseLong(token.substring(23));\n                        } catch (Exception e) {\n                        }\n                    } else if (token.equals(\"must-revalidate\") || token.equals(\"proxy-revalidate\")) {\n\n                        mustRevalidate = true;\n                    }\n                }\n            }\n        }\n\n        headerValue = headers.get(\"Expires\");\n        if (headerValue != null) {\n            serverExpires = parseDateAsEpoch(headerValue);\n        }\n\n        headerValue = headers.get(\"Last-Modified\");\n        if (headerValue != null) {\n            lastModified = parseDateAsEpoch(headerValue);\n        }\n\n        serverEtag = headers.get(\"ETag\");\n\n        // Cache-Control takes precedence over an Expires header, even if both exist and Expires\n        // is more restrictive.\n        if (hasCacheControl) {\n            softExpire = now + maxAge * 1000;\n            finalExpire = mustRevalidate\n                    ? softExpire\n                    : softExpire + staleWhileRevalidate * 1000;\n        } else if (serverDate > 0 && serverExpires >= serverDate) {\n            // Default semantic for Expire header in HTTP specification is softExpire.\n            softExpire = now + (serverExpires - serverDate);\n            finalExpire = softExpire;\n        }\n\n        Cache.Entry entry = new Cache.Entry();\n        entry.data = response.data;\n        entry.etag = serverEtag;\n        entry.softTtl = softExpire;\n        entry.ttl = finalExpire;\n        entry.serverDate = serverDate;\n        entry.lastModified = lastModified;\n        entry.responseHeaders = headers;\n\n        return entry;\n    }\n\n    public static long parseDateAsEpoch(String dateStr);\n    public static String parseCharset(Map<String, String> headers, String defaultCharset);\n    public static String parseCharset(Map<String, String> headers);\n\n    private static long ONE_MINUTE_MILLIS;\n    private static long ONE_HOUR_MILLIS;\n    private static long ONE_DAY_MILLIS;\n    private static long ONE_WEEK_MILLIS;\n    private Map<String, String> headers;\n\n}\n\nclass HttpHeaderParserTest {\n\n    private static long ONE_MINUTE_MILLIS;\n    private static long ONE_HOUR_MILLIS;\n    private static long ONE_DAY_MILLIS;\n    private static long ONE_WEEK_MILLIS;\n    private Map<String, String> headers;\n\n    @Test public void parseCacheHeaders_headersSet() {\n", "reference": "        headers.put(\"MyCustomHeader\", \"42\");\n        NetworkResponse response = new NetworkResponse(0, new byte[0], Headers.of(headers), 0);\n        Cache.Entry entry = HttpHeaderParser.parseCacheHeaders(response);\n        assertNotNull(entry);\n        assertNotNull(entry.responseHeaders);\n        assertEquals(1, entry.responseHeaders.size());\n        assertEquals(\"42\", entry.responseHeaders.get(\"MyCustomHeader\"));\n    }\n\n}", "prediction": "        long now = System.currentTimeMillis();\n\n        headers.put(\"Date\", \"Tue, 04 Dec 2012 08:49:19 GMT\");\n        headers.put(\"Cache-Control\", \"max-age=600\");\n        Cache.Entry entry = HttpHeaderParser.parseCacheHeaders(new NetworkResponse(200, headers, \"body\".getBytes()));\n        assertEquals(now + 600 * 1000, entry.softTtl);\n        assertEquals(now + 600 * 1000, entry.ttl);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "28649714_28", "part": [1, 1], "seq": [1, 1], "prompt": "class CompetitionGroupSetMapper {\n\npublic abstract CompetitionGroupSetAddPayload toDomainAddPayload(AddCompetitionGroupSetRequest apiAddRequest)public abstract CompetitionGroupSetAddPayload toDomainAddPayload(AddCompetitionGroupSetRequest apiAddRequest);\n\npublic abstract CompetitionGroupSetAddPayload toDomainAddPayload(AddCompetitionGroupSetRequest apiAddRequest)public abstract CompetitionGroupSetApiEntity toApiEntity(CompetitionGroupSet domainEntity);\npublic abstract CompetitionGroupSetAddPayload toDomainAddPayload(AddCompetitionGroupSetRequest apiAddRequest)public Set<CompetitionGroupApiEntity> toInnerApiEntitySet(Set<CompetitionGroup> innerDomainEntitySet);\npublic abstract CompetitionGroupSetAddPayload toDomainAddPayload(AddCompetitionGroupSetRequest apiAddRequest)public abstract List<CompetitionGroupSetApiEntity> toApiEntityList(List<CompetitionGroupSet> domainEntityList);\npublic abstract CompetitionGroupSetAddPayload toDomainAddPayload(AddCompetitionGroupSetRequest apiAddRequest)public abstract CompetitionGroupSetHibernateEntity toHibernateEntity(\n            CompetitionGroupSetAddPayload domainAddPayload\n    );\npublic abstract CompetitionGroupSetAddPayload toDomainAddPayload(AddCompetitionGroupSetRequest apiAddRequest)public CompetitionGroupSetHibernateEntity toHibernateEntity(CompetitionGroupSet domainEntity);\npublic abstract CompetitionGroupSetAddPayload toDomainAddPayload(AddCompetitionGroupSetRequest apiAddRequest)public Set<CompetitionGroupHibernateEntity> toInnerHibernateEntitySet(Set<CompetitionGroup> innerDomainEntitySet);\npublic abstract CompetitionGroupSetAddPayload toDomainAddPayload(AddCompetitionGroupSetRequest apiAddRequest)public abstract void updateHibernateEntity(\n            CompetitionGroupSet domainEntity,\n            @MappingTarget CompetitionGroupSetHibernateEntity hibernateEntity\n    );\npublic abstract CompetitionGroupSetAddPayload toDomainAddPayload(AddCompetitionGroupSetRequest apiAddRequest)public abstract CompetitionGroupSet toDomainEntity(CompetitionGroupSetHibernateEntity hibernateEntity);\npublic abstract CompetitionGroupSetAddPayload toDomainAddPayload(AddCompetitionGroupSetRequest apiAddRequest)public Set<CompetitionGroup> toInnerDomainEntitySet(Set<CompetitionGroupHibernateEntity> innerHibernateEntitySet);\npublic abstract CompetitionGroupSetAddPayload toDomainAddPayload(AddCompetitionGroupSetRequest apiAddRequest)public abstract List<CompetitionGroupSet> toDomainEntityList(\n            List<CompetitionGroupSetHibernateEntity> hibernateEntityList\n    );\npublic abstract CompetitionGroupSetAddPayload toDomainAddPayload(AddCompetitionGroupSetRequest apiAddRequest)public void setDao(CompetitionGroupSetDao dao);\npublic abstract CompetitionGroupSetAddPayload toDomainAddPayload(AddCompetitionGroupSetRequest apiAddRequest)public void setCompetitionGroupMapper(CompetitionGroupMapper competitionGroupMapper);\n\n    private CompetitionGroupSetMapper mapper;\n    @Mock CompetitionGroupSetDao dao;\n    @Mock CompetitionGroupDao competitionGroupDao;\n\n}\n\nclass CompetitionGroupSetMapperTest {\n\n    private CompetitionGroupSetMapper mapper;\n    @Mock CompetitionGroupSetDao dao;\n    @Mock CompetitionGroupDao competitionGroupDao;\n\n    @Test\n    public void whenToDomainAddPayloadFromApiAddRequest() {\n", "reference": "        AddCompetitionGroupSetRequest apiAddRequest = ApiRequestTestUtils.fullAddCompetitionGroupSet();\n        CompetitionGroupSetAddPayload expected = DomainPayloadTestUtils.fullCompetitionGroupSetAdd();\n        expected.setCompetitionGroups(null);\n\n        CompetitionGroupSetAddPayload actual = mapper.toDomainAddPayload(apiAddRequest);\n\n        assertThat(actual).isEqualTo(expected);\n    }\n\n}", "prediction": "        // given\n        AddCompetitionGroupSetRequest apiAddRequest = new AddCompetitionGroupSetRequest();\n        apiAddRequest.setCompetitionGroupSetName(\"competitionGroupSetName\");\n        apiAddRequest.setCompetitionGroupSetDescription(\"competitionGroupSetDescription\");\n        apiAddRequest.setCompetitionGroupSetId(1L);\n        apiAddRequest.setCompetitionGroupSetCompetitionId(1L);\n        apiAddRequest.setCompetitionGroupSetCompetitionName(\"competitionName\");\n        apiAddRequest.setCompetitionGroupSetCompetitionDescription(\"competitionDescription\");\n        apiAddRequest.setCompetitionGroupSetCompetitionStartDate(LocalDate.now());\n        apiAddRequest.setCompetitionGroupSetCompetitionEndDate(LocalDate.now());\n        apiAddRequest.setCompetitionGroupSetCompetitionStatus(CompetitionStatus.OPEN);\n        apiAddRequest.setCompetitionGroupSetCompetitionType(CompetitionType.LEAGUE);\n        apiAddRequest.setCompetitionGroupSetCompetitionGroupId(1L);\n        apiAddRequest.setCompetitionGroupSetCompetitionGroupName(\"competitionGroupName\");\n        apiAddRequest.setCompetitionGroupSetCompetitionGroupDescription(\"competitionGroupDescription\");\n        apiAddRequest.setCompetitionGroupSetCompetitionGroupStartDate(LocalDate.now());\n        apiAddRequest.setCompetitionGroupSetCompetitionGroupEndDate(LocalDate.now());\n        apiAddRequest.setCompetitionGroupSetCompetitionGroupStatus(CompetitionStatus.OPEN);\n        apiAddRequest.setCompetitionGroupSetCompetitionGroupType(CompetitionType.LEAGUE);\n        apiAddRequest.setCompetitionGroupSetCompetitionGroupCompetitionId(1L);\n        apiAddRequest.setCompetitionGroupSetCompetitionGroupCompetitionName(\"competitionGroupCompetitionName\");\n        apiAddRequest.setCompetitionGroupSetCompetitionGroupCompetitionDescription(\"competitionGroupCompetitionDescription\");\n        apiAddRequest.setCompetitionGroupSetCompetitionGroupCompetitionStartDate(LocalDate.now());\n        apiAddRequest.setCompetitionGroupSetCompetitionGroupCompetitionEndDate(LocalDate.now());\n        apiAddRequest.setCompetitionGroupSetCompetitionGroupCompetitionStatus(CompetitionStatus.OPEN);\n        apiAddRequest.setCompetitionGroupSetCompetitionGroupCompetitionType(CompetitionType.LEAGUE);\n        apiAddRequest.setCompetitionGroupSetCompetitionGroupCompetitionGroupId(1L);\n        apiAddRequest.setCompetitionGroupSetCompetitionGroupCompetitionGroupName(\"competitionGroupCompetitionGroupName\");\n        apiAddRequest.setCompetitionGroupSetCompetitionGroupCompetitionGroupDescription(\"competitionGroupCompetitionGroupDescription\");\n        apiAddRequest.setCompetitionGroupSetCompetitionGroupCompetitionGroupStartDate(LocalDate.now());\n        apiAddRequest.setCompetitionGroupSetCompetitionGroupCompetitionGroupEndDate(LocalDate.now());\n        apiAddRequest.setCompetitionGroupSetCompetitionGroupCompetitionGroupStatus(CompetitionStatus.OPEN);\n        apiAddRequest.setCompetitionGroupSetCompetitionGroupCompetitionGroupType(CompetitionType.LEAGUE);\n        apiAddRequest.setCompetitionGroupSetCompetitionGroupCompetitionGroupCompetitionId(1L);\n        apiAddRequest.setCompetitionGroupSetCompetitionGroupCompetitionGroupCompetitionName(\"competitionGroupCompetitionGroupCompetitionName\");\n        apiAddRequest.setCompetitionGroupSetCompetitionGroupCompetitionGroupCompetitionDescription(\"competitionGroupCompetitionGroupCompetitionDescription\");\n        apiAddRequest.setCompetitionGroupSetCompet", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "29383909_23", "part": [1, 1], "seq": [1, 1], "prompt": "class NovaLauncher extends Launcher {\n\n  @Override\n  public void cleanup(JsonCluster definition, ClusterRuntime runtime) throws KaramelException {\n    runtime.resolveFailures();\n    List<GroupRuntime> groups = runtime.getGroups();\n    Set<String> allNovaVms = new HashSet<>();\n    Set<String> allNovaVmsIds = new HashSet<>();\n    Map<String, String> groupRegion = new HashMap<>();\n    for (GroupRuntime group : groups) {\n      group.getCluster().resolveFailures();\n      Provider provider = UserClusterDataExtractor.getGroupProvider(definition, group.getName());\n      if (provider instanceof Nova) {\n        for (MachineRuntime machine : group.getMachines()) {\n          if (machine.getVmId() != null) {\n            allNovaVmsIds.add(machine.getVmId());\n          }\n        }\n        JsonGroup jg = UserClusterDataExtractor.findGroup(definition, group.getName());\n        List<String> vmNames = NovaSetting.NOVA_UNIQUE_VM_NAMES(group.getCluster().getName(), group.getName(),\n                jg.getSize());\n        allNovaVms.addAll(vmNames);\n        groupRegion.put(group.getName(), novaContext.getNovaCredentials().getRegion());\n      }\n    }\n    cleanup(definition.getName(), allNovaVmsIds, allNovaVms, groupRegion);\n  }\n\n  public  NovaLauncher(NovaContext novaContext, SshKeyPair sshKeyPair);\n\n  public static NovaContext validateCredentials(NovaCredentials novaCredentials, ContextBuilder builder);\n  public static NovaCredentials readCredentials(Confs confs);\n  public String createSecurityGroup(String clusterName, String groupName, Nova nova, Set<String> ports);\n  public boolean uploadSshPublicKey(String keyPairName, Nova nova, boolean removeOld);\n  public boolean cleanupFailedNodes(Map<NodeMetadata, Throwable> failedNodes);\n  public void cleanup(String clusterName, Set<String> vmIds, Set<String> vmNames, Map<String, String> groupRegion);\n  @Override public String forkGroup(JsonCluster definition, ClusterRuntime runtime, String name);\n  @Override public List<MachineRuntime> forkMachines(JsonCluster definition, ClusterRuntime runtime, String name);\n  private List<MachineRuntime> requestNodes(String keypairName, GroupRuntime groupRuntime, Set<String> groupIds,\n                                            Integer totalSize, Nova nova);\n  private void addSuccessAndLostNodes(RunNodesException rnex, Set<NodeMetadata> successfulNodes, Map<NodeMetadata,\n          Throwable> lostNodes);\n  private List<String> findLeftVmNames(Set<? extends NodeMetadata> successfulNodes, List<String> vmNames);\n  public static Predicate<NodeMetadata> withPredicate(final Set<String> ids, final Set<String> names,\n                                                      final Set<String> groupNames);\n\n  private static final Set<String> ports;\n  private NovaContext novaContext;\n  private SshKeyPair sshKeyPair;\n  private NovaCredentials novaCredentials;\n  private ContextBuilder builder;\n  private ComputeServiceContext serviceContext;\n  private ComputeService novaComputeService;\n  private NovaApi novaApi;\n  private SecurityGroupApi securityGroupApi;\n  private KeyPairApi keyPairApi;\n  private Optional securityGroupApiOptional;\n  private Optional keyPairApiOptional;\n  private SecurityGroup securityGroupCreated;\n  private String clusterName;\n  private String groupName;\n  private Nova nova;\n\n}\n\nclass NovaLauncherTest {\n\n  private static final Set<String> ports;\n  private NovaContext novaContext;\n  private SshKeyPair sshKeyPair;\n  private NovaCredentials novaCredentials;\n  private ContextBuilder builder;\n  private ComputeServiceContext serviceContext;\n  private ComputeService novaComputeService;\n  private NovaApi novaApi;\n  private SecurityGroupApi securityGroupApi;\n  private KeyPairApi keyPairApi;\n  private Optional securityGroupApiOptional;\n  private Optional keyPairApiOptional;\n  private SecurityGroup securityGroupCreated;\n  private String clusterName;\n  private String groupName;\n  private Nova nova;\n\n  @Test\n  public void cleanup() throws KaramelException{\n", "reference": "    String uniqueGroup = NovaSetting.NOVA_UNIQUE_GROUP_NAME(clusterName, groupName);\n\n    //mocking\n    JsonCluster cluster = mock(JsonCluster.class);\n    ClusterRuntime clusterRuntime = mock(ClusterRuntime.class);\n    when(clusterRuntime.getName()).thenReturn(clusterName);\n\n    List<JsonGroup> groups = new ArrayList<>();\n    JsonGroup group = mock(JsonGroup.class);\n    groups.add(group);\n    when(cluster.getGroups()).thenReturn(groups);\n    when(cluster.getProvider()).thenReturn(nova);\n    when(cluster.getName()).thenReturn(clusterName);\n\n    //mocking json group\n    when(group.getName()).thenReturn(groupName);\n    when(group.getProvider()).thenReturn(nova);\n    when(group.getSize()).thenReturn(1);\n\n    //mocking group runtime\n    List<GroupRuntime> groupRuntimes = new ArrayList<>();\n    GroupRuntime groupRuntime = mock(GroupRuntime.class);\n    when(groupRuntime.getName()).thenReturn(groupName);\n    when(groupRuntime.getId()).thenReturn(\"10\");\n    when(groupRuntime.getCluster()).thenReturn(clusterRuntime);\n    groupRuntimes.add(groupRuntime);\n\n    //mocking clusterRuntime\n    when(clusterRuntime.getGroups()).thenReturn(groupRuntimes);\n\n    //mocking securityGroups\n    SecurityGroup securityGroup = mock(SecurityGroup.class);\n    List<SecurityGroup> securityGroupList = new ArrayList<>();\n    securityGroupList.add(securityGroup);\n    FluentIterable<SecurityGroup> securityGroupFluentIterable = FluentIterable.from(securityGroupList);\n\n    when(novaContext.getSecurityGroupApi()).thenReturn(securityGroupApi);\n    when(securityGroupApi.list()).thenReturn(securityGroupFluentIterable);\n    when(securityGroup.getName()).thenReturn(uniqueGroup);\n\n    NovaLauncher novaLauncher = new NovaLauncher(novaContext, sshKeyPair);\n    novaLauncher.cleanup(cluster, clusterRuntime);\n  }\n\n}", "prediction": "    novaLauncher.cleanup(definition, runtime);\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "29397553_10", "part": [1, 1], "seq": [1, 1], "prompt": "class AveragePrecision extends AbstractRecommendationMetric<U, I> {\n\n    @Override\n    public double evaluate(Recommendation<U, I> recommendation) {\n        UserIdealRelevanceModel<U, I> userRelModel = relModel.getModel(recommendation.getUser());\n\n        int nRelItems = min(cutoff, userRelModel.getRelevantItems().size());\n        if (nRelItems == 0) {\n            return 0.0;\n        }\n\n        double ap = 0;\n        int relCount = 0;\n        int rank = 0;\n\n        for (Tuple2od<I> pair : recommendation.getItems()) {\n            rank++;\n            if (userRelModel.isRelevant(pair.v1)) {\n                relCount++;\n                ap += relCount / (double) rank;\n            }\n            if (rank == cutoff) {\n                break;\n            }\n        }\n\n        return ap / nRelItems;\n    }\n\n    public  AveragePrecision(int cutoff, IdealRelevanceModel<U, I> relevanceModel);\n\n    private final PreferenceData<String, String> prefs;\n    private final RecommendationMetric<String, String> ap;\n\n}\n\nclass AveragePrecisionTest {\n\n    private final PreferenceData<String, String> prefs;\n    private final RecommendationMetric<String, String> ap;\n\n    @Test\n    public void testA() {\n", "reference": "        Recommendation<String, String> recA = new Recommendation<>(\"a\", Arrays.asList(\n                Tuples.tuple(\"A\", 9.0),\n                Tuples.tuple(\"L\", 8.0),\n                Tuples.tuple(\"B\", 7.0),\n                Tuples.tuple(\"N\", 6.0),\n                Tuples.tuple(\"O\", 5.0),\n                Tuples.tuple(\"P\", 4.0),\n                Tuples.tuple(\"Q\", 3.0),\n                Tuples.tuple(\"L\", 2.0),\n                Tuples.tuple(\"C\", 1.0),\n                Tuples.tuple(\"R\", 0.0)\n        ));\n\n        Assert.assertEquals(5.0 / 12.0, ap.evaluate(recA), 1e-12);\n    }\n\n}", "prediction": "        assertEquals(0.0, ap.evaluate(new Recommendation<String, String>(\"a\", new ArrayList<Tuple2od<String>>())));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "29406271_0", "part": [1, 1], "seq": [1, 1], "prompt": "class SampleResource {\n\n\t@GET\n\t@Path(\"/{id}\")\n\t@Produces(\"application/json\")\n\tpublic Response get(@PathParam(\"id\") String id) {\n\t\tResource resource;\n\t\ttry {\n\t\t\tresource = store.get(id);\n\t\t} catch (IOException e) {\n\t\t\treturn Response.status(Response.Status.NOT_FOUND).build();\n\t\t}\n\n\t\treturn Response.ok(resource).build();\n\t}\n\n\t@POST @Consumes(\"application/json\") public Response post(JsonNode node);\n\t@PUT @Path(\"/{id}\") @Produces(\"application/json\") @Consumes(\"application/json\") public Response put(@PathParam(\"id\") String id, JsonNode node);\n\t@DELETE @Path(\"/{id}\") public Response delete(@PathParam(\"id\") String id);\n\n\tprivate HttpServer server;\n\tprivate Client client;\n\n}\n\nclass SampleResourceTest {\n\n\tprivate HttpServer server;\n\tprivate Client client;\n\n\t@Test\n\tpublic void testGet() throws Exception {\n", "reference": "\t\tWebTarget target = client.target(Main.uri + \"u1\");\n\n\t\tResource resource = target.request(MediaType.APPLICATION_JSON).get(Resource.class);\n\t\tassertEquals(1, resource.getContents().size());\n\n\t\tEObject u1 = resource.getContents().get(0);\n\t\tassertEquals(\"User\", u1.eClass().getName());\n\t\tassertEquals(\"u1\", u1.eGet(u1.eClass().getEStructuralFeature(\"name\")));\n\t}\n\n}", "prediction": "\t\tResponse response = client.target(\"http://localhost:8080/sample/123\").request().get();\n\t\tassertEquals(Response.Status.OK.getStatusCode(), response.getStatus());\n\t\tassertEquals(\"application/json\", response.getHeaderString(\"Content-Type\"));\n\t\tassertEquals(\"{\\\"id\\\":\\\"123\\\",\\\"name\\\":\\\"sample\\\"}\", response.readEntity(String.class));\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "29479059_81", "part": [1, 1], "seq": [1, 1], "prompt": "class DefaultJobService implements JobService {\n\n    @Override\n    public JobParameters getLastJobParameters(final String jobName) {\n        final List<JobExecution> executions = this.lightminJobExecutionDao.getJobExecutions(jobName, 0, 1);\n        JobExecution lastExecution = null;\n        if (!CollectionUtils.isEmpty(executions)) {\n            lastExecution = executions.iterator().next();\n        }\n        JobParameters oldParameters = new JobParameters();\n        if (lastExecution != null) {\n            oldParameters = lastExecution.getJobParameters();\n        }\n        return oldParameters;\n    }\n\n    public  DefaultJobService(final JobOperator jobOperator,\n                             final JobRegistry jobRegistry,\n                             final JobExplorer jobExplorer,\n                             final LightminJobExecutionDao lightminJobExecutionDao);\n\n    @Override public int getJobInstanceCount(final String jobName);\n    @Override public int getJobExecutionCount(final JobInstance jobInstance);\n    @Override public Set<String> getJobNames();\n    @Override public Job getJobByName(final String jobName);\n    @Override public Collection<JobInstance> getJobInstances(final String jobName, final int startIndex, final int pageSize);\n    @Override public Collection<JobExecution> getJobExecutions(final JobInstance jobInstance);\n    @Override public Collection<JobExecution> getJobExecutions(final JobInstance jobInstance, final int start, final int count);\n    @Override public JobExecution getJobExecution(final Long jobExecutionId);\n    @Override public JobInstance getJobInstance(final Long jobInstanceId);\n    @Override public void attachJobInstance(final JobExecution jobExecution);\n    @Override public void restartJobExecution(final Long jobExecutionId);\n    @Override public void stopJobExecution(final Long jobExecutionId);\n    @Override public void afterPropertiesSet();\n\n    private static final String JOB_NAME;\n    private static final String JOB_NAME_2;\n    private static final String JOB_NAME_3;\n    private static final String[] JOB_NAMES;\n    @InjectMocks\n    private DefaultJobService jobService;\n    @Mock\n    private JobOperator jobOperator;\n    @Mock\n    private JobRegistry jobRegistry;\n    @Mock\n    private JobExplorer jobExplorer;\n    @Mock\n    private LightminJobExecutionDao lightminJobExecutionDao;\n\n}\n\nclass DefaultJobServiceTest {\n\n    private static final String JOB_NAME;\n    private static final String JOB_NAME_2;\n    private static final String JOB_NAME_3;\n    private static final String[] JOB_NAMES;\n    @InjectMocks\n    private DefaultJobService jobService;\n    @Mock\n    private JobOperator jobOperator;\n    @Mock\n    private JobRegistry jobRegistry;\n    @Mock\n    private JobExplorer jobExplorer;\n    @Mock\n    private LightminJobExecutionDao lightminJobExecutionDao;\n\n    @Test\n    public void getLastJobParametersTest() {\n", "reference": "        final List<JobExecution> jobExecutions = new LinkedList<>();\n        final JobParameters jobParameters = new JobParametersBuilder().addLong(\"long\", 1L).addString(\"String\",\n                \"someString\").toJobParameters();\n        final JobExecution jobExecution = new JobExecution(1L, jobParameters, \"test\");\n        jobExecutions.add(jobExecution);\n        when(this.lightminJobExecutionDao.getJobExecutions(anyString(), anyInt(), anyInt())).thenReturn(jobExecutions);\n        final JobParameters result = this.jobService.getLastJobParameters(\"test\");\n        assertThat(result).isEqualTo(jobParameters);\n    }\n\n}", "prediction": "        final JobParameters jobParameters = new JobParametersBuilder().addString(\"test\", \"test\").toJobParameters();\n        final JobExecution jobExecution = new JobExecution(1L, jobParameters);\n        when(this.lightminJobExecutionDao.getJobExecutions(JOB_NAME, 0, 1)).thenReturn(Collections.singletonList(jobExecution));\n        final JobParameters lastJobParameters = this.jobService.getLastJobParameters(JOB_NAME);\n        assertEquals(jobParameters, lastJobParameters);\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "30466015_4", "part": [1, 1], "seq": [1, 1], "prompt": "class BPIViewHolder extends RecyclerView.ViewHolder {\n\n    public void bind(BPI item) {\n        if (date != null) {\n            date.setText(simpleDateFormat.format(item.getDate()));\n        }\n        SpannableStringBuilder closeText = new SpannableStringBuilder(String.format(\"$%.2f\", item.getClose()));\n        if (largeCloseTextSize) {\n            // if large text, the price looks better with a small $\n            closeText.setSpan(new RelativeSizeSpan(0.4f), 0, 1, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n        }\n        close.setText(closeText);\n\n        int changeTextColorRes = R.color.textColorSecondary;\n        String changeText = \"\";\n        String changeArrow = \"\";\n        if (item.getChange() != null) {\n            changeText = String.format(\"%.2f%%\", item.getChange() * 100);\n            if (item.getChange() > 0) {\n                changeArrow = \" \u25b2\";\n                changeTextColorRes = R.color.bpiChangeIncrease;\n            } else if (item.getChange() < 0) {\n                changeArrow = \" \u25bc\";\n                changeTextColorRes = R.color.bpiChangeDecrease;\n            }\n        }\n        change.setText(changeText + changeArrow);\n        change.setTextColor(change.getResources().getColor(changeTextColorRes));\n    }\n\n    public  BPIViewHolder(View itemView, SimpleDateFormat simpleDateFormat);\n\n    private int layoutId;\n    private SimpleDateFormat simpleDateFormat;\n    private BPIViewHolder viewHolder;\n\n}\n\nclass BPIViewHolderTest {\n\n    private int layoutId;\n    private SimpleDateFormat simpleDateFormat;\n    private BPIViewHolder viewHolder;\n\n    @Test\n    public void bind_noChange() {\n", "reference": "        BPI bpi = new BPI(new Date(System.currentTimeMillis()), 225.25f);\n\n        viewHolder.bind(bpi);\n\n        if (viewHolder.date != null) {\n            ANDROID.assertThat(viewHolder.date).hasTextString(simpleDateFormat.format(bpi.getDate()));\n        }\n        ANDROID.assertThat(viewHolder.close).hasTextString(\"$\" + bpi.getClose());\n        ANDROID.assertThat(viewHolder.change).hasTextString(\"\");\n    }\n\n}", "prediction": "        BPI item = new BPI();\n        item.setDate(new Date());\n        item.setClose(100.0);\n        viewHolder.bind(item);\n        assertThat(viewHolder.date.getText().toString(), is(simpleDateFormat.format(item.getDate())));\n        assertThat(viewHolder.close.getText().toString(), is(\"$100.00\"));\n        assertThat(viewHolder.change.getText().toString(), is(\"\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "30562287_2", "part": [1, 1], "seq": [1, 1], "prompt": "class CalendarWeekDayFormatter implements WeekDayFormatter {\n\n  @Override public CharSequence format(final DayOfWeek dayOfWeek) {\n    return dayOfWeek.getDisplayName(TextStyle.SHORT, Locale.getDefault());\n  }\n\n  public CalendarWeekDayFormatter formatter;\n  public Locale defaultLocaleOriginal;\n\n}\n\nclass CalendarWeekDayFormatterTest {\n\n  public CalendarWeekDayFormatter formatter;\n  public Locale defaultLocaleOriginal;\n\n  @Test public void testFormattedDayOfWeek_Tuesday() {\n", "reference": "    assertThat(formatter.format(DayOfWeek.TUESDAY).toString(), is(\"Tue\"));\n  }\n\n}", "prediction": "    assertEquals(\"Tue\", formatter.format(DayOfWeek.TUESDAY));\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "30593072_11", "part": [1, 1], "seq": [1, 1], "prompt": "class ByteUtil {\n\n    public static boolean isInteger(final byte[] asciiBuffer, final int offset, final int length)\n    {\n        for (int i = 0; i < length; i++)\n        {\n            if (!isAsciiDigit(asciiBuffer[offset + i]))\n            {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    public static void writeLongAsAscii(final byte[] outputBuffer, final int offset, final long valueParam);\n    public static boolean isAsciiDigit(final byte asciiCharacter);\n    public static String formatIntAsIpAddress(final int address);\n    public static void formatIntAsIpAddress(final StringBuilder buffer, final int address);\n    public static long packLongWithUnsignedShortInts(final int int1, final int int2, final int int3, final int int4);\n    public static boolean isEqual(final byte[] lhs, final int lhsOffset, final byte[] rhs, final int rhsOffset, final int length);\n    public static int readIntFromAscii(final byte[] asciiBuffer, final int offset, final int length);\n    public static long readLongFromAscii(final byte[] asciiBuffer, final int offset, final int length);\n    public static void replace(final byte[] buffer, final int offset, final int length,\n                               final byte target, final byte replacement);\n    public static void asciiEncode(final CharSequence chars, final int charOffset,\n                                   final byte[] buffer, final int bufferOffset, final int length);\n    private static void checkUnsignedShort(final int value);\n\n}\n\nclass ByteUtilTest {\n\n        @Test\n        public void shouldConfirmIsNotIntegerValue() throws UnsupportedEncodingException\n        {\n", "reference": "            final byte[] bytes = \"1;3\".getBytes(StandardCharsets.US_ASCII);\n            assertFalse(ByteUtil.isInteger(bytes, 0, bytes.length));\n        }\n\n}", "prediction": "           final byte[] asciiBuffer = \"123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "30616178_2", "part": [1, 1], "seq": [1, 1], "prompt": "class RadixTrie {\n\n  static <T> Builder<T> builder() {\n    return new Builder<T>();\n  }\n\n    RadixTrie(final Node<T> root);\n\n   T lookup(final CharSequence path);\n   T lookup(final CharSequence path, final Captor captor);\n   int captures();\n   Captor captor();\n  static Captor captor(final int captures);\n  @SuppressWarnings(\"UnusedParameters\") static Builder<T> builder(Class<T> clazz);\n  private static String prefixes(Node<T> node);\n  @Override public String toString();\n\n  @Rule public ExpectedException exception;\n\n}\n\nclass RadixTrieTest {\n\n  @Rule public ExpectedException exception;\n\n  @Test(expected = IllegalArgumentException.class)\n  public void verifyNonAsciiInsertThrows() {\n", "reference": "    RadixTrie.builder(String.class).insert(\"\" + (char) 128, \"foo\");\n  }\n\n}", "prediction": "    RadixTrie.builder().insert(\"foo\", \"bar\");\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "31075855_16", "part": [1, 1], "seq": [1, 1], "prompt": "class Prefser {\n\n  public <T> void put(@NonNull String key, @NonNull T value) {\n    Preconditions.checkNotNull(value, VALUE_IS_NULL);\n    put(key, value, TypeToken.fromValue(value));\n  }\n\n  public  Prefser(@NonNull Context context);\n  public  Prefser(@NonNull Context context, @NonNull JsonConverter jsonConverter);\n  public  Prefser(@NonNull SharedPreferences sharedPreferences);\n  @SuppressLint(\"CommitPrefEdits\") public  Prefser(@NonNull SharedPreferences sharedPreferences,\n      @NonNull JsonConverter jsonConverter);\n\n  public SharedPreferences getPreferences();\n  public boolean contains(String key);\n  public Observable<T> getAndObserve(String key, Class<T> classOfT, T defaultValue);\n  public Observable<T> getAndObserve(final String key, final TypeToken<T> typeTokenOfT,\n      final T defaultValue);\n  public Observable<T> observe(@NonNull String key, @NonNull Class<T> classOfT,\n      T defaultValue);\n  public Observable<T> observe(@NonNull final String key,\n      @NonNull final TypeToken<T> typeTokenOfT, final T defaultValue);\n  public T get(@NonNull String key, @NonNull Class<T> classOfT, T defaultValue);\n  public T get(@NonNull String key, @NonNull TypeToken<T> typeTokenOfT, T defaultValue);\n  public Observable<String> observePreferences();\n  public void put(@NonNull String key, @NonNull T value, @NonNull TypeToken<T> typeTokenOfT);\n  public void remove(@NonNull String key);\n  public void clear();\n  public int size();\n\n  private static final String GIVEN_KEY;\n  private static final String GIVEN_STRING_VALUE;\n  private static final String KEY_WHICH_DOES_NOT_EXIST;\n  private Prefser prefser;\n\n}\n\nclass PrefserTest {\n\n  private static final String GIVEN_KEY;\n  private static final String GIVEN_STRING_VALUE;\n  private static final String KEY_WHICH_DOES_NOT_EXIST;\n  private Prefser prefser;\n\n  @Test(expected = NullPointerException.class)\n  public void testPutShouldThrowAnExceptionWhenKeyAndValueAreNullForPut() {\n", "reference": "    // given\n    String key = null;\n    String value = null;\n\n    // when\n    prefser.put(key, value);\n\n    // then\n    // throw an exception\n  }\n\n}", "prediction": "    prefser.put(null, null);\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "31208159_0", "part": [1, 1], "seq": [1, 1], "prompt": "class CommentsPresenter implements ReplyView.Listener, CommentsAdapter.Listener, LoaderManager.LoaderCallbacks<Cursor> {\n\n    public boolean onOptionsItemSelected(MenuItem item) {\n\n        switch (item.getItemId()) {\n            case R.id.action_bookmark:\n                if (item.isChecked()) {\n                    onBookmarkUnselected(item);\n                } else {\n                    onBookmarkSelected(item);\n                }\n                return true;\n            case android.R.id.home:\n                activity.finish();\n                return true;\n            default:\n                return false;\n        }\n\n    }\n\n    public  CommentsPresenter(HNewsActivity activity, SwipeRefreshLayout.OnRefreshListener refreshListener);\n\n    private Story getStory();\n    public void onCreate();\n    public void onPostCreate(boolean online);\n    public void onCreateOptionsMenu(Menu menu);\n    public void onBookmarkUnselected(MenuItem item);\n    public void onBookmarkSelected(MenuItem item);\n    private void setupHeaderView();\n    private void setupSnackbar();\n    private void setupCommentsView();\n    private void setupReplyListener();\n    private void loadComments();\n    private void showReplyViewForStory();\n    public void showReplyViewForComment(Long commentId);\n    private void showReplyView();\n    private void hideReplyView();\n    private void checkBookmarkMenuItem(MenuItem bookmarks);\n    private void uncheckBookmarkMenuItem(MenuItem bookmarks);\n    private void showAddedBookmarkSnackbar(final CommentsOperator commentsOperator, final Story story);\n    private void showRemovedBookmarkSnackbar(final CommentsOperator commentsOperator, final Story story);\n    public void showNotImplemented();\n    public void showLoginExpired();\n    public void showContentUpdating();\n    @Override public void onReplyCancelled();\n    @Override public void onReplySuccessful();\n    @Override public void onLoginExpired();\n    @Override public void onCommentReplyAction(Long id);\n    @Override public void onCommentVoteAction(Long id);\n    @Override public Loader<Cursor> onCreateLoader(int id, Bundle args);\n    @Override public void onLoadFinished(Loader<Cursor> loader, Cursor data);\n    @Override public void onLoaderReset(Loader<Cursor> loader);\n    public void hideRefreshAnimation();\n    public void onRefresh(boolean isOnline);\n    public void onBackPressed();\n    public boolean inReplyMode();\n\n    @Mock CommentsActivity activity;\n    @Mock SwipeRefreshLayout.OnRefreshListener refreshListener;\n    @Mock MenuItem menuItem;\n    @Mock CommentsView commentsView;\n     CommentsPresenter commentsPresenter;\n\n}\n\nclass CommentsPresenterTest {\n\n    @Mock CommentsActivity activity;\n    @Mock SwipeRefreshLayout.OnRefreshListener refreshListener;\n    @Mock MenuItem menuItem;\n    @Mock CommentsView commentsView;\n     CommentsPresenter commentsPresenter;\n\n    @Test\n    public void removesBookmarkWhenBookmarkItemWasSelected() {\n", "reference": "        when(menuItem.getItemId()).thenReturn(R.id.action_bookmark);\n        when(menuItem.isChecked()).thenReturn(true);\n\n        commentsPresenter.onOptionsItemSelected(menuItem);\n\n        verify(menuItem).setIcon(R.drawable.ic_bookmark_outline_white);\n        verify(menuItem).setChecked(false);\n    }\n\n}", "prediction": "        // given\n        when(menuItem.isChecked()).thenReturn(true);\n\n        // when\n        commentsPresenter.onBookmarkSelected(menuItem);\n\n        // then\n        verify(menuItem).setChecked(false);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "31234709_18", "part": [1, 1], "seq": [1, 1], "prompt": "class BaseServerListResponse extends ArrayList<BaseServerResponse> {\n\n    public List<Exception> listExceptions() {\n        return\n            this\n                .stream()\n                .filter(this::isJobNotQueued)\n                .map(this::errorMessage)\n                .map(ClcClientException::new)\n                .collect(toList());\n    }\n\n    public  BaseServerListResponse(int initialCapacity);\n    public  BaseServerListResponse();\n    public  BaseServerListResponse(Collection<? extends BaseServerResponse> collection);\n\n    private boolean isJobNotQueued(BaseServerResponse r);\n    private String errorMessage(BaseServerResponse response);\n    public ClcException summaryException();\n    public boolean hasErrors();\n\n     BaseServerListResponse response;\n\n}\n\nclass BaseServerListResponseTest {\n\n     BaseServerListResponse response;\n\n    @Test\n    public void testListExceptions_onlyNotQueued() throws Exception {\n", "reference": "        response = prepareResponseList(basicServerResponse(\"VA1ALTDSRV101\").queued(false));\n\n        List<Exception> errors = response.listExceptions();\n\n        assertEquals(errors.size(), 1);\n        assertContains(firstErrorMessage(errors), \"VA1ALTDSRV101\", \"not queued\");\n    }\n\n}", "prediction": "        response.add(new BaseServerResponse(\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\", \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\", \"30\", \"31\", \"32\", \"33\", \"34\", \"35\", \"36\", \"37\", \"38\", \"39\", \"40\", \"41\", \"42\", \"43\", \"44\", \"45\", \"46\", \"47\", \"48\", \"49\", \"50\", \"51\", \"52\", \"53\", \"54\", \"55\", \"56\", \"57\", \"58\", \"59\", \"60\", \"61\", \"62\", \"63\", \"64\", \"65\", \"66\", \"67\", \"68\", \"69\", \"70\", \"71\", \"72\", \"73\", \"74\", \"75\", \"76\", \"77\", \"78\", \"79\", \"80\", \"81\", \"82\", \"83\", \"84\", \"85\", \"86\", \"87\", \"88\", \"89\", \"90\", \"91\", \"92\", \"93\", \"94\", \"95\", \"96\", \"97\", \"98\", \"99\", \"100\", \"101\", \"102\", \"103\", \"104\", \"105\", \"106\", \"107\", \"108\", \"109\", \"110\", \"111\", \"112\", \"113\", \"114\", \"115\", \"116\", \"117\", \"118\", \"119\", \"120\", \"121\", \"122\", \"123\", \"124\", \"125\", \"126\", \"127\", \"128\", \"129\", \"130\", \"131\", \"132\", \"133\", \"134\", \"135\", \"136\", \"137\", \"138\", \"139\", \"140\", \"141\", \"142\", \"143\", \"144\", \"145\", \"146\", \"147\", \"148\", \"149\", \"150\", \"151\", \"152\", \"153\", \"154\", \"155\", \"156\", \"157\", \"158\", \"159\", \"160\", \"161\", \"162\", \"163\", \"164\", \"165\", \"166\", \"167\", \"168\", \"169\", \"170\", \"171\", \"172\", \"173\", \"174\", \"175\", \"176\", \"177\", \"178\", \"179\", \"180\", \"181\", \"182\", \"183\", \"184\", \"185\", \"186\", \"187\", \"188\", \"189\", \"190\", \"191\", \"192\", \"193\", \"194\", \"195\", \"196\", \"197\", \"198\", \"199\", \"200\", \"201\", \"202\", \"203\", \"204\", \"205\", \"206\", \"207\", \"208\", \"209\", \"210\", \"211\", \"212\", \"213\", \"214\", \"215\", \"216\", \"217\", \"218\", \"219\", \"220\", \"221\", \"222\", \"223\", \"224\", \"225\", \"226\", \"227\", \"228\", \"229\", \"230\", \"231\", \"232\", \"233\", \"234\", \"235\", \"236\", \"237\", \"238\", \"239\", \"240\", \"241\", \"242\", \"243\", \"244\", \"245\", \"246\", \"247\", \"248\", \"249\", \"250\", \"251\", \"252\", \"253\", \"254\", \"255\", \"256\", \"257\", \"258\", \"259\", \"260\", \"261\", \"262\", \"263\", \"264\", \"265\", \"266\", \"267\", \"268\", \"269\", \"270\", \"271\", \"272\", \"273\", \"274\", \"275\", \"276\", \"277\", \"278\", \"279\", \"280\", \"281\", \"282\", \"283\", \"", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "31634402_0", "part": [1, 1], "seq": [1, 1], "prompt": "class FluxBuilder {\n\n    public static boolean isPrimitiveNumber(Class clazz){\n        return clazz.isPrimitive() && !clazz.equals(boolean.class);\n    }\n\n    public static Config buildConfig(TopologyDef topologyDef);\n    static StormTopology buildTopology(ExecutionContext context);\n    private static Method findGetTopologyMethod(Object topologySource, String methodName);\n    private static void buildStreamDefinitions(ExecutionContext context, TopologyBuilder builder);\n    private static void applyProperties(ObjectDef bean, Object instance, ExecutionContext context);\n    private static Field findPublicField(Class clazz, String property, Object arg);\n    private static Method findSetter(Class clazz, String property, Object arg);\n    private static String toSetterName(String name);\n    private static List<Object> resolveReferences(List<Object> args, ExecutionContext context);\n    private static Object buildObject(ObjectDef def, ExecutionContext context);\n    private static StormTopology buildExternalTopology(ObjectDef def, ExecutionContext context);\n    private static CustomStreamGrouping buildCustomStreamGrouping(ObjectDef def, ExecutionContext context);\n    private static void buildComponents(ExecutionContext context);\n    private static void buildSpouts(ExecutionContext context, TopologyBuilder builder);\n    private static IRichSpout buildSpout(SpoutDef def, ExecutionContext context);\n    private static void buildBolts(ExecutionContext context);\n    private static Constructor findCompatibleConstructor(List<Object> args, Class target);\n    public static void invokeConfigMethods(ObjectDef bean, Object instance, ExecutionContext context);\n    private static Method findCompatibleMethod(List<Object> args, Class target, String methodName);\n    private static Object[] getArgsWithListCoercian(List<Object> args, Class[] parameterTypes);\n    private static boolean canInvokeWithArgs(List<Object> args, Class[] parameterTypes);\n\n}\n\nclass FluxBuilderTest {\n\n    @Test\n    public void testIsPrimitiveNumber() throws Exception {\n", "reference": "        assertTrue(FluxBuilder.isPrimitiveNumber(int.class));\n        assertFalse(FluxBuilder.isPrimitiveNumber(boolean.class));\n        assertFalse(FluxBuilder.isPrimitiveNumber(String.class));\n    }\n\n}", "prediction": "        assertTrue(FluxBuilder.isPrimitiveNumber(int.class));\n        assertTrue(FluxBuilder.isPrimitiveNumber(Integer.class));\n        assertTrue(FluxBuilder.isPrimitiveNumber(long.class));\n        assertTrue(FluxBuilder.isPrimitiveNumber(Long.class));\n        assertTrue(FluxBuilder.isPrimitiveNumber(float.class));\n        assertTrue(FluxBuilder.isPrimitiveNumber(Float.class));\n        assertTrue(FluxBuilder.isPrimitiveNumber(double.class));\n        assertTrue(FluxBuilder.isPrimitiveNumber(Double.class));\n        assertFalse(FluxBuilder.isPrimitiveNumber(String.class));\n        assertFalse(FluxBuilder.isPrimitiveNumber(Boolean.class));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "32001142_0", "part": [1, 1], "seq": [1, 1], "prompt": "class MethodToLog {\n\n    public boolean matchMethodOrConstructor(Member member) {\n        if (member instanceof Method) {\n            return matchMethod((Method) member);\n        } else if (member instanceof Constructor) {\n            return matchMethod((Constructor) member);\n        }\n        return false;\n    }\n\n    public  MethodToLog(int type, String className, String methodName, List<String> parameterClasses,\n            List<String> parameterNames);\n\n    public int getType();\n    public String getClassName();\n    public String getName();\n    public List<String> getParameterClasses();\n    public List<String> getParameterNames();\n    public boolean isMethod();\n    public boolean isConstructor();\n    private boolean matchMethod(Method method);\n    private boolean matchMethod(Constructor constructor);\n    @Override public String toString();\n\n    public static  final String METHODS_TO_LOG;\n\n}\n\nclass MethodToLogTest {\n\n    public static  final String METHODS_TO_LOG;\n\n    @Test\n    public void testMatchMethodOrConstructor() {\n", "reference": "        List<MethodToLog> methodToLogs = new Gson()\n                .fromJson(METHODS_TO_LOG, new TypeToken<List<MethodToLog>>() {\n                }.getType());\n\n        Set<Member> methods = new HashSet<>();\n        methods.addAll(Arrays.asList(TestMatchMethod.class.getDeclaredMethods()));\n        methods.addAll(Arrays.asList(TestMatchMethod.class.getDeclaredConstructors()));\n        methods.addAll(Arrays.asList(TestMatchMethod.InnerClass.class.getDeclaredMethods()));\n        methods.addAll(Arrays.asList(TestMatchMethod.InnerClass.class.getDeclaredConstructors()));\n        methods.addAll(Arrays.asList(TestMatchMethod.StaticNestedClass.class.getDeclaredMethods()));\n        methods.addAll(\n                Arrays.asList(TestMatchMethod.StaticNestedClass.class.getDeclaredConstructors()));\n\n        for (Member member : methods) {\n            int matchCount = 0;\n\n            for (MethodToLog methodToLog : methodToLogs) {\n                if (methodToLog.matchMethodOrConstructor(member)) {\n                    matchCount++;\n                }\n            }\n\n            // ensure every method match 1 time\n            assertThat(matchCount, is(1));\n        }\n\n        // ensure every method is tested\n        assertThat(methodToLogs.size(), is(methods.size()));\n    }\n\n}", "prediction": "        MethodToLog mtl = new MethodToLog(MethodToLog.METHOD, \"foo\", \"bar\", null, null);\n        assertTrue(mtl.matchMethodOrConstructor(new Method(\"foo\", \"bar\", null, null)));\n        assertTrue(mtl.matchMethodOrConstructor(new Constructor(\"foo\", \"bar\", null, null)));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "32135981_10", "part": [1, 1], "seq": [1, 1], "prompt": "class MavenEchoOutput implements EchoOutput {\n\n    @Override\n    public void error(String content) {\n        wrappedLog.error(content);\n    }\n\n    public  MavenEchoOutput(Log wrappedLog);\n\n    @Override public void fail(String content);\n    @Override public void warning(String content);\n    @Override public void info(String content);\n    @Override public void debug(String content);\n    @SuppressWarnings(\"unchecked\") private void throwAsUnchecked(Exception e);\n\n    private final Log logMock;\n    private MavenEchoOutput mavenEchoOutput;\n    @Rule\n    public final ExpectedException expectedException;\n\n}\n\nclass MavenEchoOutputTest {\n\n    private final Log logMock;\n    private MavenEchoOutput mavenEchoOutput;\n    @Rule\n    public final ExpectedException expectedException;\n\n    @Test\n    public void errorShouldOutputErrorLevel() {\n", "reference": "        mavenEchoOutput.error(\"Gurka\");\n\n        verify(logMock).error(\"Gurka\");\n        verifyNoMoreInteractions(logMock);\n    }\n\n}", "prediction": "        mavenEchoOutput.error(\"error\");\n        verify(logMock).error(\"error\");\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "32139352_2", "part": [1, 1], "seq": [1, 1], "prompt": "class OpenTipBotService {\n\n    public void processNewOpenTipBotCommands() throws OpenTipBotServiceException {\n        logger.debug(\"Start command processing\");\n\n        processTips(opentipbotCommandRepository.findByOpenTipBotCommandStatusAndOpenTipBotCommandEnumOrderByCreationTimeAsc(OpenTipBotCommandStatus.NEW, OpenTipBotCommandEnum.TIP));\n\n        processTips(opentipbotCommandRepository.findByOpenTipBotCommandStatusAndOpenTipBotCommandEnumOrderByCreationTimeAsc(OpenTipBotCommandStatus.NEW, OpenTipBotCommandEnum.TIP_RAIN));\n\n        processTips(opentipbotCommandRepository.findByOpenTipBotCommandStatusAndOpenTipBotCommandEnumOrderByCreationTimeAsc(OpenTipBotCommandStatus.NEW, OpenTipBotCommandEnum.TIP_RANDOM));\n\n        processWithdrawals(opentipbotCommandRepository.findByOpenTipBotCommandStatusAndOpenTipBotCommandEnumOrderByCreationTimeAsc(OpenTipBotCommandStatus.NEW, OpenTipBotCommandEnum.WITHDRAW));\n\n        processReceiverNotifications(opentipbotCommandRepository.findByOpenTipBotCommandStatusAndOpenTipBotCommandEnumOrderByCreationTimeAsc(OpenTipBotCommandStatus.NEW, OpenTipBotCommandEnum.NOTIFY_RECEIVER));\n\n        processErrorNotifications(opentipbotCommandRepository.findByOpenTipBotCommandStatusAndOpenTipBotCommandEnumOrderByCreationTimeAsc(OpenTipBotCommandStatus.NEW, OpenTipBotCommandEnum.NOTIFY_ERROR));\n\n        processFavs(opentipbotCommandRepository.findByOpenTipBotCommandStatusAndOpenTipBotCommandEnumOrderByCreationTimeAsc(OpenTipBotCommandStatus.NEW, OpenTipBotCommandEnum.FAV));\n\n        logger.debug(\"Operation Complete\");\n\n    }\n\n    public TwitterTemplate getTwitterTemplate();\n    @PostConstruct public void init();\n    public void handleNewTweets();\n    public void handleNewTweet(Tweet tweet);\n    private void processFavs(List<OpenTipBotCommand> commands);\n    private void processErrorNotifications(List<OpenTipBotCommand> commands);\n    private void processReceiverNotifications(List<OpenTipBotCommand> commands);\n    private void processWithdrawals(List<OpenTipBotCommand> commands);\n    private void processTips(List<OpenTipBotCommand> commands);\n    private void notifyReceiver(OpenTipBotCommand opentipbotCommand);\n    private void favOriginalMessage(OpenTipBotCommand opentipbotCommand);\n     boolean validateWithdrawalCommand(OpenTipBotCommand opentipbotCommand);\n    private void notifyValidationError(OpenTipBotCommand opentipbotCommand, String errorMessage);\n     String getRandomTipNotificationMessage(String fromUserName, String toUserName, double amount);\n     boolean validateTipCommand(OpenTipBotCommand opentipbotCommand);\n    private String validateUserExists(String toUserName);\n     boolean validateMinimumAmount(double amount);\n     boolean validateUserRegistration(String userName);\n     boolean validateSufficientBalance(double amount, String userName);\n     boolean validateSufficientBalanceToWIthdraw(String userName);\n     void persistOpenTipBotCommands(List<Tweet> incomingTweets);\n     String findRandomFollower(long fromUser);\n     List<String> getRainUsernames(String userNames);\n     List<Tweet> filterTweets(List<Tweet> incomingTweets);\n     List<Tweet> filterNotProcessedTweets(List<Tweet> incomingTweets);\n     Double getCoinAmout(String amount);\n     List<Tweet> filterValidTweets(List<Tweet> incomingTweets);\n    private String removeLineSeparators(String str);\n    public List<OpenTipBotCommand> getLastTips();\n    private static String formatDouble(double d);\n\n    @Autowired\n    protected OpenTipBotService opentipbotService;\n\n}\n\nclass OpenTipBotServiceTest  {\n\n    @Autowired\n    protected OpenTipBotService opentipbotService;\n\n    @Test\n    public void processNewOpenTipBotCommandsTest()\n    {\n", "reference": "        try {\n            opentipbotService.processNewOpenTipBotCommands();\n        } catch (OpenTipBotServiceException e) {\n            e.printStackTrace();\n        }\n    }\n\n}", "prediction": "        opentipbotService.processNewOpenTipBotCommands();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "32143635_14", "part": [1, 1], "seq": [1, 1], "prompt": "class NSSpeechSynthesizer extends NSObject {\n\n    public NSSpeechStatus getStatus() {\n        return new NSSpeechStatus(Rococoa.cast(getProperty(SpeechProperty.StatusProperty), NSMutableDictionary.class));\n    }\n\n    public static NSSpeechSynthesizer synthesizerWithVoiceIdentifier(String voiceIdentifer);\n    public static NSSpeechSynthesizer synthesizerWithVoice(NSVoice voice);\n    public static NSVoice defaultVoice();\n    public static List<NSVoice> availableVoices();\n    public static boolean isAnyApplicationSpeaking();\n    public synchronized void setDelegate(final NSSpeechSynthesizerDelegate delegate);\n    public synchronized NSSpeechSynthesizerDelegate getDelegate();\n    public String opcodeToPhoneme(short opcode);\n    public static String createSyncPoint(int marker);\n    public NSObject getProperty(SpeechProperty property);\n    public void setProperty(SpeechProperty property, NSObject value);\n    public void addSpeechDictionary(NSSpeechDictionary dictionary);\n    public NSSpeechError getError();\n    public NSSpeechMode getInputMode();\n    public void setInputMode(NSSpeechMode mode);\n    public NSSpeechMode getCharacterMode();\n    public void setCharacterMode(NSSpeechMode mode);\n    public NSSpeechMode getNumberMode();\n    public void setNumberMode(NSSpeechMode mode);\n    public NSSpeechSynthesizerInfo getSynthesizerInfo();\n    public float getPitchBase();\n    public void setPitchBase(float baselinePitch);\n    public float getPitchMod();\n    public void setPitchMod(float modulation);\n    public List<NSSpeechPhonemeInfo> getPhonemeInfo();\n    public int getRecentSync();\n    public boolean setVoice(NSVoice voice);\n    public NSVoice getVoice();\n    public void setCommandDelimiter(NSSpeechCommand delimiters);\n    public void reset();\n    public void setOutputToFileURL(URI uri);\n    public boolean startSpeakingStringToURL(String text, URI uri);\n    abstract void addSpeechDictionary(NSDictionary speechDictionary);\n    public abstract void continueSpeaking();\n    abstract ID delegate();\n    abstract NSSpeechSynthesizer initWithVoice(String voiceIdentifier);\n    public abstract boolean isSpeaking();\n    abstract NSObject objectForProperty_error(NSString speechProperty, ObjCObjectByReference out_error);\n    abstract boolean setObject_forProperty_error(NSObject object, NSString speechProperty, ObjCObjectByReference out_error);\n    public abstract void pauseSpeakingAtBoundary(NSSpeechBoundary boundary);\n    public abstract String phonemesFromText(String text);\n    public abstract float rate();\n    abstract void setDelegate(ID delegate);\n    public abstract void setRate(float rate);\n    public abstract void setUsesFeedbackWindow(boolean useFeedbackWindow);\n    public abstract boolean setVoice(String voiceIdentifier);\n    public abstract void setVolume(float volume);\n    public abstract boolean startSpeakingString(String text);\n    abstract boolean startSpeakingString_toURL(NSString text, NSURL url);\n    public abstract void stopSpeaking();\n    public abstract void stopSpeakingAtBoundary(NSSpeechBoundary boundary);\n    public abstract boolean usesFeedbackWindow();\n    abstract String voice();\n    public String getVoiceIdentifier();\n    abstract float volume();\n    public float getVolume();\n\n    private static final int TIME_TO_WAIT;\n    private NSAutoreleasePool pool;\n\n}\n\nclass NSSpeechSynthesizerTest {\n\n    private static final int TIME_TO_WAIT;\n    private NSAutoreleasePool pool;\n\n    @Test\n    public void testGetStatus() {\n", "reference": "        NSSpeechSynthesizer ss = NSSpeechSynthesizer.synthesizerWithVoice(null);\n        SynthesizerDelegate sd = new SynthesizerDelegate(ss);        \n        NSSpeechStatus status = ss.getStatus();\n        assertEquals(status.isOutputBusy(), ss.isSpeaking());\n        assertFalse(status.isOutputPaused());\n        assertEquals(\"Should have no characters left\", 0, status.getNumberOfCharactersLeft());\n        assertEquals(0, status.getPhonemeCode());\n        \n        ss.startSpeakingString(\"Status check\");\n        status = ss.getStatus();\n        assertEquals(status.isOutputBusy(), ss.isSpeaking());\n        assertFalse(status.isOutputPaused());\n        assertTrue(\"Should have characters left\", status.getNumberOfCharactersLeft() > 0);\n        //assertTrue(\"Opcode should not be zero\", status.getPhonemeCode() != 0); always zero... seems to have word granularity\n        sd.waitForSpeechDone(TIME_TO_WAIT, true);\n    }\n\n}", "prediction": "        NSSpeechSynthesizer synthesizer = NSSpeechSynthesizer.synthesizerWithVoiceIdentifier(\"com.apple.speech.synthesis.voice.fiona\");\n        NSSpeechStatus status = synthesizer.getStatus();\n        assertNotNull(status);\n        assertEquals(NSSpeechStatus.Speaking, status.getPhoneme());\n        assertEquals(0, status.getPhonemeLength());\n        assertEquals(0, status.getPhonemePosition());\n        assertEquals(0, status.getPhonemeStartTime());\n        assertEquals(0, status.getPhonemeEndTime());\n        assertEquals(0, status.getPhonemeDuration());\n        assertEquals(0, status.getPhonemePitch());\n        assertEquals(0, status.getPhonemeVolume());\n        assertEquals(0, status.getPhonemeRate());\n        assertEquals(0, status.getPhonemePitchBase());\n        assertEquals(0, status.getPhonemePitchMod());\n        assertEquals(0, status.getPhonemePitchBase());\n        assertEquals(0, status.getPhonemePitchMod());\n        assertEquals(0, status.getPhonemePitchBase());\n        assertEquals(0, status.getPhonemePitchMod());\n        assertEquals(0, status.getPhonemePitchBase());\n        assertEquals(0, status.getPhonemePitchMod());\n        assertEquals(0, status.getPhonemePitchBase());\n        assertEquals(0, status.getPhonemePitchMod());\n        assertEquals(0, status.getPhonemePitchBase());\n        assertEquals(0, status.getPhonemePitchMod());\n        assertEquals(0, status.getPhonemePitchBase());\n        assertEquals(0, status.getPhonemePitchMod());\n        assertEquals(0, status.getPhonemePitchBase());\n        assertEquals(0, status.getPhonemePitchMod());\n        assertEquals(0, status.getPhonemePitchBase());\n        assertEquals(0, status.getPhonemePitchMod());\n        assertEquals(0, status.getPhonemePitchBase());\n        assertEquals(0, status.getPhonemePitchMod());\n        assertEquals(0, status.getPhonemePitchBase());\n        assertEquals(0, status.getPhonemePitchMod());\n        assertEquals(0, status.getPhonemePitchBase());\n        assertEquals(0, status.getPhonemePitchMod());\n        assertEquals(0, status.getPhonemePitchBase());\n        assertEquals(0, status.getPhonemePitchMod());\n        assertEquals(0, status.getPhonemePitchBase());\n        assertEquals(0, status.getPhonemePitchMod());\n        assertEquals(0, status.getPhonemePitchBase());\n        assertEquals(0, status.getPhonemePitchMod());\n        assertEquals(0, status.getPhonemePitchBase());\n        assertEquals(0, status.getPhonemePitchMod());\n        assertEquals(0, status.getPhonemePitchBase());\n        assertEquals(0, status.getPhonemePitchMod());\n        assertEquals(0, status.getPhonemePitchBase());\n        assertEquals(0, status.getPhonemePitchMod());\n        assertEquals(0, status.getPhonemePitchBase());\n        assertEquals(0, status.getPhonemePitchMod());\n        assertEquals(0, status.getPhonemePitchBase());\n        assertEquals(0, status.getPhonemePitchMod());\n        assertEquals(0, status.getPhonemePitchBase());\n        assertEquals(0, status.getPhonemePitchMod());\n        assertEquals(0, status.getPhonemePitchBase());\n        assertEquals(0, status.getPhoneme", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "32651977_1", "part": [1, 1], "seq": [1, 1], "prompt": "class CompositeFileReader implements FileReader {\n\n    @Nullable\n    @Override\n    public CharStream read(String name) {\n        for (FileReader delegate : delegateList) {\n            CharStream result = delegate.read(name);\n            if (result != null) {\n                return result;\n            }\n        }\n        return null;\n    }\n\n    public  CompositeFileReader(List<FileReader> delegateList);\n    public  CompositeFileReader(FileReader... delegates);\n\n}\n\nclass CompositeFileReaderTest {\n\n    @Test\n    public void testRead() throws Exception {\n", "reference": "        TestReader r1 = new TestReader(\"1.proto\", \"1\");\n        TestReader r2 = new TestReader(\"2.proto\", \"2\");\n        CompositeFileReader reader = new CompositeFileReader(r1, r2);\n        CharStream s1 = reader.read(\"1.proto\");\n        CharStream s2 = reader.read(\"2.proto\");\n        CharStream s3 = reader.read(\"3.proto\");\n        assertNotNull(s1);\n        assertNotNull(s2);\n        assertNull(s3);\n        assertEquals(\"1\", s1.getText(Interval.of(0, 1)));\n        assertEquals(\"2\", s2.getText(Interval.of(0, 1)));\n    }\n\n}", "prediction": "        CompositeFileReader compositeFileReader = new CompositeFileReader(new FileReader() {\n            @Nullable\n            @Override\n            public CharStream read(String name) {\n                return null;\n            }\n        });\n        assertNull(compositeFileReader.read(\"foo\"));\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "32796510_13", "part": [1, 1], "seq": [1, 1], "prompt": "class Token {\n\n    public int getCapturingGroupCount() {\n        return capturingGroupCount;\n    }\n\n    public  Token(String regex);\n    public  Token(String name, String regex);\n    public  Token(String name, String regex, String replacement);\n    public  Token(String name, String regex, MatchProcessor matchProcessor);\n\n    public String getName();\n    public String getRegex();\n    public MatchProcessor getMatchProcessor();\n    @Override public String toString();\n\n}\n\nclass TokenTest {\n\n    @Test\n    public void testGetCapturingGroupCount() throws Exception {\n", "reference": "        assertEquals(0, new Token(\"\").getCapturingGroupCount());\n        assertEquals(1, new Token(\"a(b)c\").getCapturingGroupCount());\n        assertEquals(0, new Token(\"a(?:b)c\").getCapturingGroupCount());\n    }\n\n}", "prediction": "        Token token = new Token(\"(a)\");\n        assertEquals(1, token.getCapturingGroupCount());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "32866430_13", "part": [1, 1], "seq": [1, 1], "prompt": "class ModifyClientRequestV2 {\n\n  @JsonCreator public static ModifyClientRequestV2 forName(@JsonProperty(\"name\") String name) {\n    return new AutoValue_ModifyClientRequestV2(name);\n  }\n\n  @JsonProperty(\"name\") public abstract String name();\n\n}\n\nclass ModifyClientRequestV2Test {\n\n  @Test public void deserializesCorrectly() throws Exception {\n", "reference": "    ModifyClientRequestV2 modifyClientRequest = ModifyClientRequestV2.forName(\"client-name\");\n\n    assertThat(\n        fromJson(jsonFixture(\"fixtures/v2/modifyClientRequest.json\"), ModifyClientRequestV2.class))\n        .isEqualTo(modifyClientRequest);\n  }\n\n}", "prediction": "    ModifyClientRequestV2 request = ModifyClientRequestV2.forName(\"foo\");\n    assertThat(request.name()).isEqualTo(\"foo\");\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "32913234_8", "part": [1, 1], "seq": [1, 1], "prompt": "class UsersTemplate extends AbstractGithubTemplate implements UsersOperations {\n\n\t@Override\n\tpublic List<Email> listEmails() {\n\t\treturn Arrays\n\t\t\t\t.asList(getRestOperations().getForEntity(buildUriString(USER_EMAILS_PATH), Email[].class).getBody());\n\t}\n\n\tpublic  UsersTemplate(RestOperations restOperations);\n\n\t@Override public List<Email> addEmails(String... emails);\n\t@Override public List<Email> addEmails(List<String> emails);\n\t@Override public void deleteEmails(String... emails);\n\t@Override public void deleteEmails(List<String> emails);\n\t@Override public List<PubKey> listPublicKeys(String username);\n\t@Override public List<ExtPubKey> listPublicKeys();\n\t@Override public ExtPubKey getPublicKey(long id);\n\t@Override public ExtPubKey createPublicKey(PubKeyInput pubKey);\n\t@Override public void deletePublicKey(long id);\n\n\tprotected UsersTemplate usersTemplate;\n\n}\n\nclass UsersTemplateTest extends AbstractGithubTemplate {\n\n\tprotected UsersTemplate usersTemplate;\n\n\t@Test\n\tpublic void getEmails() throws Exception {\n", "reference": "\t\tmockServer.expect(requestTo(\"https://api.github.com/user/emails\")).andExpect(method(HttpMethod.GET))\n\t\t\t\t// .andExpect(header(\"Authorization\", \"Bearer ACCESS_TOKEN\"))\n\t\t\t\t.andRespond(\n\t\t\t\t\t\twithSuccess(new ClassPathResource(\"listEmails.json\", getClass()), MediaType.APPLICATION_JSON));\n\n\t\tList<Email> emailList = usersTemplate.listEmails();\n\n\t\tAssertions.assertThat(emailList).isNotNull();\n\t\tAssertions.assertThat(emailList.size()).isEqualTo(1);\n\t}\n\n}", "prediction": "\t\tassertThat(usersTemplate.listEmails(), notNullValue());\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "33499067_5", "part": [1, 1], "seq": [1, 1], "prompt": "class FirmwareImage implements Chunk.Chunkable {\n\n    public int blockCount() {\n        return (int) Math.ceil((double) data().length / FW_BLOCK_SIZE);\n    }\n\n    public  FirmwareImage(byte[] rawData, String filename);\n\n    private int uint16FromData(int offset);\n    private byte[] uint8_4FromData(int offset);\n    public byte[] data();\n    public String name();\n    public int sizeBytes();\n    public long version();\n    @Override public byte[] getChunkableData();\n    public int crc();\n    public int crcShadow();\n    public int intVersion();\n    public int length();\n    public byte[] uniqueID();\n    public byte[] reserved();\n    public byte[] metadata();\n    public byte[] block(int index);\n\n     byte[] rawImageData_valid;\n     byte[] rawImageData_tooShort;\n     byte[] rawImageData_invalid;\n\n}\n\nclass FirmwareImageTest {\n\n     byte[] rawImageData_valid;\n     byte[] rawImageData_tooShort;\n     byte[] rawImageData_invalid;\n\n    @Test\n    public void testBlockCount() throws ImageParsingException {\n", "reference": "        FirmwareImage image1 = new FirmwareImage(rawImageData_valid, \"\");\n        FirmwareImage image2 = new FirmwareImage(rawImageData_invalid, \"\");\n        assertThat(image1.blockCount()).isEqualTo(1);\n        assertThat(image2.blockCount()).isEqualTo(3);\n    }\n\n}", "prediction": "        FirmwareImage image = new FirmwareImage(rawImageData_valid, \"test.bin\");\n        assertEquals(1, image.blockCount());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "33645537_540", "part": [1, 1], "seq": [1, 1], "prompt": "class Artists {\n\n    public String getArtistName(int index) {\n        try {\n            Artist artist = getArtist(index);\n            return artist.getName();\n        } catch (IllegalArgumentException e) {\n            return \"unknown\";\n        }\n    }\n\n    public  Artists(List<Artist> artists);\n\n    public Artist getArtist(int index);\n    private void indexException(int index);\n\n    private final Artists optionalExamples;\n\n}\n\nclass ArtistsTest {\n\n    private final Artists optionalExamples;\n\n    @Test\n    public void nameIndexOutsideRange() {\n", "reference": "        String artist = optionalExamples.getArtistName(4);\n        assertEquals(\"unknown\", artist);\n    }\n\n}", "prediction": "        assertEquals(\"unknown\", optionalExamples.getArtistName(100));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "33683869_3", "part": [1, 1], "seq": [1, 1], "prompt": "class DateUtil {\n\n    static public boolean isPublicHoliday(Date date) {\n        final Calendar calendar = GregorianCalendar.getInstance();\n        calendar.setTime(date);\n        final int day = calendar.get(Calendar.DAY_OF_MONTH);\n        final int month = calendar.get(Calendar.MONTH) + 1;\n        final int year = calendar.get(Calendar.YEAR);\n\n        String dateStr = String.valueOf(day) + \".\" + String.valueOf(month);\n        String dateStrWithYear = dateStr + \".\" + String.valueOf(year);\n        return FIXED_HOLIDAYS.contains(dateStr) || DYNAMIC_HOLIDAYS.contains(dateStrWithYear);\n    }\n\n    static public int getDayOfWeek(Date date);\n    public static int inMinutes(int hours, int minutes);\n    public static Date addMinutesToDate(Date date, int minutes);\n    static public String formatTimeFromMinutes(int minutes);\n\n}\n\nclass DateUtilTest {\n\n    @Test\n    public void testIsPublicHoliday() throws Exception {\n", "reference": "        final Calendar calendar = GregorianCalendar.getInstance();\n        calendar.set(2015, 0, 1);\n        assertTrue(DateUtil.isPublicHoliday(calendar.getTime()));\n\n        calendar.set(2016, 2, 28); //28 March is \"Ostermontag\"\n        assertTrue(DateUtil.isPublicHoliday(calendar.getTime()));\n\n        calendar.set(2015, 5, 5); // 5 June\n        assertFalse(DateUtil.isPublicHoliday(calendar.getTime()));\n\n    }\n\n}", "prediction": "        Date date = new Date();\n        assertTrue(DateUtil.isPublicHoliday(date));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "33718145_7", "part": [1, 1], "seq": [1, 1], "prompt": "class LotComparator implements Comparator<Map<String, Object>> {\n\n\tpublic int compare(Map<String, Object> o1, Map<String, Object> o2) {\n\t\t\n\t\tint compareValue = 0;\n\t\t\n\t\t// Get dnulot information\n\t\tString dnulot1 = (String)o1.get(CadastrappConstants.PB_LOT_ID);\n\t\tString dnulot2 = (String)o2.get(CadastrappConstants.PB_LOT_ID);\n\t\t\n\t\t// If contains only number\t\t\n\t\tif(dnulot1.matches(numberRegex) && dnulot2.matches(numberRegex)){\n\t\t\tcompareValue = Integer.valueOf(dnulot1).compareTo(Integer.valueOf(dnulot2));\n\t\t}\n\t\t// If both start by number, but finish with char\n\t\telse if(dnulot1.matches(numberStartRegex) && dnulot2.matches(numberStartRegex)){\t\n\t\t\tcompareValue = Integer.valueOf(dnulot1.replaceAll(\"[^\\\\d]\", \"\")).compareTo(Integer.valueOf(dnulot2.replaceAll(\"[^\\\\d]\", \"\")));\n\t\t\t// If same number compare end string value\n\t\t\tif(compareValue == 0){\n\t\t\t\tcompareValue = dnulot1.replaceAll(\"[0-9]\", \"\").compareTo(dnulot2.replaceAll(\"[0-9]\", \"\"));\n\t\t\t}\n\t\t}\n\t\t// If one start with number and the other is char\n\t\telse if(dnulot1.matches(numberStartRegex)){\t\n\t\t\tcompareValue = -1;\n\t\t}\n\t\t// If one is char and the other start by number\n\t\telse if(dnulot2.matches(numberStartRegex)){\t\n\t\t\tcompareValue = 1;\n\t\t}\n\t\t// All other case\n\t\telse{\n\t\t\tcompareValue = dnulot1.compareTo(dnulot2);\n\t\t}\n\t\t\n\t\treturn compareValue;\n\t}\n\n\tstatic final Logger logger;\n\tpublic LotComparator lotComparator;\n\n}\n\nclass LotComparatorTest {\n\n\tstatic final Logger logger;\n\tpublic LotComparator lotComparator;\n\n\t@Test\n\tpublic void testBiggerNumberStringCompare() {\n", "reference": "\t\t\n\t\tMap<String, Object> lotsInformation1 = new HashMap<String, Object>();\n\t\tlotsInformation1.put(CadastrappConstants.PB_LOT_ID, \"01\");\n\t\t\n\t\tMap<String, Object> lotsInformation2 = new HashMap<String, Object>();\n\t\tlotsInformation2.put(CadastrappConstants.PB_LOT_ID, \"A\");\n\t\t\n\t\tint result = lotComparator.compare(lotsInformation1, lotsInformation2);\n\t\tassertTrue(result < 0);\t\n\t}\n\n}", "prediction": "\t\tMap<String, Object> lot1 = new HashMap<String, Object>();\n\t\tlot1.put(CadastrappConstants.PB_LOT_ID, \"1234567890\");\n\t\tMap<String, Object> lot2 = new HashMap<String, Object>();\n\t\tlot2.put(CadastrappConstants.PB_LOT_ID, \"12345678901\");\n\t\tassertTrue(lotComparator.compare(lot1, lot2) < 0);\n\t}", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "34599551_7", "part": [1, 1], "seq": [1, 1], "prompt": "class HelloWorldEndpointImpl implements HelloWorldPortType {\n\n    @Override\n    public Greeting sayHello(Person person) {\n\n        String firstName = person.getFirstName();\n        LOGGER.debug(\"firstName={}\", firstName);\n        String lasttName = person.getLastName();\n        LOGGER.debug(\"lastName={}\", lasttName);\n\n        ObjectFactory factory = new ObjectFactory();\n        Greeting response = factory.createGreeting();\n\n        String greeting = \"Hello \" + firstName + \" \" + lasttName + \"!\";\n        LOGGER.info(\"greeting={}\", greeting);\n\n        response.setText(greeting);\n        return response;\n    }\n\n    private static String ENDPOINT_ADDRESS;\n\n}\n\nclass HelloWorldEndpointImplTest {\n\n    private static String ENDPOINT_ADDRESS;\n\n    @Test\n    public void testSayHelloProxy() {\n", "reference": "        Person person = new Person();\n        person.setFirstName(\"John\");\n        person.setLastName(\"Watson\");\n\n        assertEquals(\"Hello John Watson!\", new HelloWorldClientImplMock(\n                ENDPOINT_ADDRESS).sayHello(person));\n    }\n\n}", "prediction": "        HelloWorldPortType proxy = getProxy();\n        Greeting greeting = proxy.sayHello(createPerson());\n        assertNotNull(greeting);\n        assertEquals(\"Hello John Doe!\", greeting.getText());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "34706545_4", "part": [1, 1], "seq": [1, 1], "prompt": "class Convert {\n\n    public static boolean getNthBit(byte[] arr, int offset){\n        int arrayOffset = offset / 8;\n        int bitOfByte = offset % 8;\n        int maskedBit = arr[arrayOffset] & (1 << (7 - bitOfByte));\n        return (maskedBit != 0);\n    }\n\n    public static String bytesToHex(byte[] bytes);\n    public static byte[] strToBytes(String str);\n    public static byte[] longToBytes(long val);\n    public static byte[] getPrefixBytes(byte[] arr);\n\n}\n\nclass ConvertTest {\n\n    @Test\n    public void testBitsBytesConvert() {\n", "reference": "\n        Random r = new Random();\n\n        boolean[] bits = new boolean[32];\n        for (int i = 0; i < bits.length; i++) {\n            bits[i] = r.nextBoolean();\n        }\n\n        // convert bits to byte array\n        byte[] bytes = new byte[4];\n        for (int i = 0;i < bits.length; i++) {\n            if (bits[i]) {\n                bytes[i/8] |= (1 << 7) >> (i%8);\n            }\n        }\n\n        for (int i = 0; i < bits.length; i++) {\n            if (Convert.getNthBit(bytes, i) != bits[i]) {\n                fail(\"Conversion of bytes to bits failed at bit \"+i);\n            }\n        }\n\n    }\n\n}", "prediction": "        byte[] arr = new byte[1];\n        arr[0] = 0b00000001;\n        assertTrue(Convert.getNthBit(arr, 0));\n        assertFalse(Convert.getNthBit(arr, 1));\n        assertFalse(Convert.getNthBit(arr, 2));\n        assertFalse(Convert.getNthBit(arr, 3));\n        assertFalse(Convert.getNthBit(arr, 4));\n        assertFalse(Convert.getNthBit(arr, 5));\n        assertFalse(Convert.getNthBit(arr, 6));\n        assertTrue(Convert.getNthBit(arr, 7));\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "34861263_54", "part": [1, 1], "seq": [1, 1], "prompt": "class JXPanel extends JPanel implements AlphaPaintable, BackgroundPaintable, Scrollable {\n\n    @Override\n    public void setAlpha(float alpha) {\n        if (isPatch()) {\n            setAlphaPatch(alpha);\n            return;\n        }\n        if (alpha < 0f || alpha > 1f) {\n            throw new IllegalArgumentException(\"invalid alpha value \" + alpha);\n        }\n        \n        float oldValue = getAlpha();\n        this.alpha = alpha;\n        \n        if (getAlpha() < 1f) {\n            if (oldValue == 1) {\n                //it used to be 1, but now is not. Save the oldOpaque\n                oldOpaque = isOpaque();\n                super.setOpaque(false);\n            }\n            \n            installRepaintManager();\n        } else {\n            uninstallRepaintManager();\n            \n            //restore the oldOpaque if it was true (since opaque is false now)\n            if (oldOpaque) {\n                super.setOpaque(true);\n            }\n        }\n        \n        firePropertyChange(\"alpha\", oldValue, getAlpha());\n        repaint();\n    }\n\n    public  JXPanel();\n    public  JXPanel(boolean isDoubleBuffered);\n    public  JXPanel(LayoutManager layout);\n    public  JXPanel(LayoutManager layout, boolean isDoubleBuffered);\n\n    @Override public void setOpaque(boolean opaque);\n    @Override public boolean isOpaque();\n    @Override public float getAlpha();\n    private void setAlphaPatch(float alpha);\n     void installRepaintManager();\n     void uninstallRepaintManager();\n    @Override public float getEffectiveAlpha();\n    @Override public boolean isInheritAlpha();\n    @Override public void setInheritAlpha(boolean val);\n    public final void setScrollableWidthHint(ScrollableSizeHint hint);\n    public final void setScrollableHeightHint(ScrollableSizeHint hint);\n    protected ScrollableSizeHint getScrollableWidthHint();\n    protected ScrollableSizeHint getScrollableHeightHint();\n    @Override public boolean getScrollableTracksViewportHeight();\n    @Override public boolean getScrollableTracksViewportWidth();\n    @Override public Dimension getPreferredScrollableViewportSize();\n    @Override public int getScrollableBlockIncrement(Rectangle visibleRect, int orientation, int direction);\n    @Override public int getScrollableUnitIncrement(Rectangle visibleRect, int orientation, int direction);\n    public void setScrollableTracksViewportHeight(boolean scrollableTracksViewportHeight);\n    public void setScrollableTracksViewportWidth(boolean scrollableTracksViewportWidth);\n    @Override public void setBackgroundPainter(Painter p);\n    protected PropertyChangeListener getPainterChangeListener();\n    @Override public Painter getBackgroundPainter();\n    @Override public boolean isPaintBorderInsets();\n    @Override public void setPaintBorderInsets(boolean paintBorderInsets);\n    protected boolean isPaintingOrigin();\n    @Override public void paint(Graphics g);\n    @Override @SuppressWarnings(\"unchecked\") protected void paintComponent(Graphics g);\n    protected boolean isPatch();\n    protected void paintComponentPatch(Graphics g);\n    protected boolean isOpaquePatch();\n    protected void setOpaquePatch(boolean opaque);\n    protected boolean isAlpha();\n    protected boolean isTransparentBackground();\n    protected boolean isPaintingBackground();\n\n    @SuppressWarnings(\"unused\")\n    private static final Logger LOG;\n\n}\n\nclass JXPanelTest extends JPanel {\n\n    @SuppressWarnings(\"unused\")\n    private static final Logger LOG;\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testSetAlphaWithLessThanZero() {\n", "reference": "        new JXPanel().setAlpha(Math.nextAfter(0f, Float.NEGATIVE_INFINITY));\n    }\n\n}", "prediction": "        JXPanel panel = new JXPanel();\n        panel.setAlpha(-0.1f);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "35126599_96", "part": [1, 1], "seq": [1, 1], "prompt": "class IntoImpl extends BaseSqlPart implements Into {\n\n  @Override\n  public void prependTo(@NotNull final RawSqlBuilder builder) {\n    builder.prepend(mTableName);\n\n    if (mDatabaseName != null) {\n      builder.prepend('.').prepend(mDatabaseName);\n    }\n\n    builder.prepend(\"INTO \");\n  }\n\n    IntoImpl(@Nullable final String databaseName, @NotNull final String tableName, @NotNull final SqlPart previous);\n\n  @NotNull @Override public InsertColumns columns(@NotNull final String... columnNames);\n  @NotNull @Override public Values values(@NotNull final Object... expressions);\n  @Nullable @Override public SqlPart previous();\n\n}\n\nclass IntoImplTest {\n\n  @Test\n  public void prependTo_table_prependsProperSql() {\n", "reference": "    /* Given */\n    IntoImpl into = new IntoImpl(null, \"table\", mock(SqlPart.class));\n    RawSqlBuilder builder = new RawSqlBuilderImpl();\n\n    /* When */\n    into.prependTo(builder);\n\n    /* Then */\n    assertThat(builder.toString(), is(\"INTO table\"));\n  }\n\n}", "prediction": "    final RawSqlBuilder builder = new RawSqlBuilder();\n    final Into into = new IntoImpl(\"db\", \"table\", null);\n    into.prependTo(builder);\n    assertEquals(\"db.table INTO \", builder.build());\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "35689778_3", "part": [1, 1], "seq": [1, 1], "prompt": "class HtpasswdRealm extends MemoryRealm {\n\n    @Override\n    public Account authenticate(AuthenticationToken authenticationToken) {\n        readCredentialsFile();\n        return super.authenticate(authenticationToken);\n    }\n\n    public  HtpasswdRealm();\n\n    @Override public boolean canAuthenticate(AuthenticationToken authenticationToken);\n    @Override public void setup(Config config);\n    @Override public void start();\n    @Override public void stop();\n    public boolean isAllowClearTextPasswords();\n    public void setAllowClearTextPasswords(boolean value);\n    public synchronized void setFile(File realmFile);\n    @Override public boolean hasAccount(String username);\n    @Override public Account getAccount(String username);\n    @Override protected boolean validatePassword(StandardCredentials requestCredentials, StandardCredentials storedCredentials);\n    protected synchronized void readCredentialsFile();\n    protected Map<String, String> readCredentialsURL(URL url);\n\n     HtpasswdRealm htpasswd;\n\n}\n\nclass HtpasswdRealmTest extends MemoryRealm {\n\n     HtpasswdRealm htpasswd;\n\n    @Test\n    public void testAuthenticate() {\n", "reference": "\n        htpasswd.setAllowClearTextPasswords(true);\n\n        Account account = htpasswd.authenticate(\"user1\", \"pass1\");\n        assertNotNull(account);\n        assertEquals(\"user1\", account.getUsername());\n\n        account = htpasswd.authenticate(\"user2\", \"pass2\");\n        assertNotNull(account);\n        assertEquals(\"user2\", account.getUsername());\n\n        // Test different encryptions\n        account = htpasswd.authenticate(\"plain\", \"passWord\");\n        assertNotNull(account);\n        assertEquals(\"plain\", account.getUsername());\n\n        htpasswd.setAllowClearTextPasswords(false);\n        account = htpasswd.authenticate(\"crypt\", \"password\");\n        assertNotNull(account);\n        assertEquals(\"crypt\", account.getUsername());\n\n        account = htpasswd.authenticate(\"md5\", \"password\");\n        assertNotNull(account);\n        assertEquals(\"md5\", account.getUsername());\n\n        account = htpasswd.authenticate(\"sha\", \"password\");\n        assertNotNull(account);\n        assertEquals(\"sha\", account.getUsername());\n\n\n        // Test leading and trailing whitespace\n        account = htpasswd.authenticate(\"trailing\", \"whitespace\");\n        assertNotNull(account);\n        assertEquals(\"trailing\", account.getUsername());\n\n        account = htpasswd.authenticate(\"tabbed\", \"frontAndBack\");\n        assertNotNull(account);\n        assertEquals(\"tabbed\", account.getUsername());\n\n        account = htpasswd.authenticate(\"leading\", \"whitespace\");\n        assertNotNull(account);\n        assertEquals(\"leading\", account.getUsername());\n    }\n\n}", "prediction": "        htpasswd.setFile(new File(\"src/test/resources/htpasswd\"));\n        assertTrue(htpasswd.authenticate(new UsernamePasswordToken(\"admin\", \"admin\")) != null);\n        assertTrue(htpasswd.authenticate(new UsernamePasswordToken(\"user\", \"user\")) != null);\n        assertTrue(htpasswd.authenticate(new UsernamePasswordToken(\"user\", \"user1\")) == null);\n        assertTrue(htpasswd.authenticate(new UsernamePasswordToken(\"user\", \"user2\")) == null);\n        assertTrue(htpasswd.authenticate(new UsernamePasswordToken(\"user\", \"user3\")) == null);\n        assertTrue(htpasswd.authenticate(new UsernamePasswordToken(\"user\", \"user4\")) == null);\n        assertTrue(htpasswd.authenticate(new UsernamePasswordToken(\"user\", \"user5\")) == null);\n        assertTrue(htpasswd.authenticate(new UsernamePasswordToken(\"user\", \"user6\")) == null);\n        assertTrue(htpasswd.authenticate(new UsernamePasswordToken(\"user\", \"user7\")) == null);\n        assertTrue(htpasswd.authenticate(new UsernamePasswordToken(\"user\", \"user8\")) == null);", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "35844242_14", "part": [1, 1], "seq": [1, 1], "prompt": "class DynamodbAttributeValueTransformer {\n\n    public static AttributeValue toAttributeValueV2(final com.amazonaws.services.lambda.runtime.events.models.dynamodb.AttributeValue value) {\n        if (Objects.nonNull(value.getS())) {\n            return AttributeValue.builder()\n                    .s(value.getS())\n                    .build();\n\n        } else if (Objects.nonNull(value.getSS())) {\n            return AttributeValue.builder()\n                    .ss(value.getSS())\n                    .build();\n\n        } else if (Objects.nonNull(value.getN())) {\n            return AttributeValue.builder()\n                    .n(value.getN())\n                    .build();\n\n        } else if (Objects.nonNull(value.getNS())) {\n            return AttributeValue.builder()\n                    .ns(value.getNS())\n                    .build();\n\n        } else if (Objects.nonNull(value.getB())) {\n            return AttributeValue.builder()\n                    .b(SdkBytes.fromByteBuffer(value.getB()))\n                    .build();\n\n        } else if (Objects.nonNull(value.getBS())) {\n            return AttributeValue.builder()\n                    .bs(value.getBS().stream()\n                            .map(SdkBytes::fromByteBuffer)\n                            .collect(Collectors.toList()))\n                    .build();\n\n        } else if (Objects.nonNull(value.getBOOL())) {\n            return AttributeValue.builder()\n                    .bool(value.getBOOL())\n                    .build();\n\n        } else if (Objects.nonNull(value.getL())) {\n            return AttributeValue.builder()\n                    .l(value.getL().stream()\n                            .map(DynamodbAttributeValueTransformer::toAttributeValueV2)\n                            .collect(Collectors.toList()))\n                    .build();\n\n        } else if (Objects.nonNull(value.getM())) {\n            return AttributeValue.builder()\n                    .m(toAttributeValueMapV2(value.getM()))\n                    .build();\n\n        } else if (Objects.nonNull(value.getNULL())) {\n            return AttributeValue.builder()\n                    .nul(value.getNULL())\n                    .build();\n\n        } else {\n            throw new IllegalArgumentException(\n                    String.format(\"Unsupported attributeValue type: %s\", value));\n        }\n    }\n\n    static Map<String, AttributeValue> toAttributeValueMapV2(\n            final Map<String, com.amazonaws.services.lambda.runtime.events.models.dynamodb.AttributeValue> attributeValueMap\n    );\n\n    private static final String valueN;\n    private static final List<String> valueNS;\n    private static final String valueS;\n    private static final List<String> valueSS;\n    private static final ByteBuffer valueB;\n    private static final List<ByteBuffer> valueBS;\n    private static final boolean valueBOOL;\n    private static final boolean valueNUL;\n    private static final String keyM1;\n    private static final String keyM2;\n    public static final AttributeValue attributeValueN_event;\n    public static final AttributeValue attributeValueNS_event;\n    public static final AttributeValue attributeValueS_event;\n    public static final AttributeValue attributeValueSS_event;\n    public static final AttributeValue attributeValueB_event;\n    public static final AttributeValue attributeValueBS_event;\n    public static final AttributeValue attributeValueBOOL_event;\n    public static final AttributeValue attributeValueNUL_event;\n    public static final AttributeValue attributeValueM_event;\n    public static final AttributeValue attributeValueL_event;\n    public static final software.amazon.awssdk.services.dynamodb.model.AttributeValue attributeValueN_v2;\n    public static final software.amazon.awssdk.services.dynamodb.model.AttributeValue attributeValueNS_v2;\n    public static final software.amazon.awssdk.services.dynamodb.model.AttributeValue attributeValueS_v2;\n    public static final software.amazon.awssdk.services.dynamodb.model.AttributeValue attributeValueSS_v2;\n    public static final software.amazon.awssdk.services.dynamodb.model.AttributeValue attributeValueB_v2;\n    public static final software.amazon.awssdk.services.dynamodb.model.AttributeValue attributeValueBS_v2;\n    public static final software.amazon.awssdk.services.dynamodb.model.AttributeValue attributeValueBOOL_v2;\n    public static final software.amazon.awssdk.services.dynamodb.model.AttributeValue attributeValueNUL_v2;\n    public static final software.amazon.awssdk.services.dynamodb.model.AttributeValue attributeValueM_v2;\n    public static final software.amazon.awssdk.services.dynamodb.model.AttributeValue attributeValueL_v2;\n\n}\n\nclass DynamodbAttributeValueTransformerTest {\n\n    private static final String valueN;\n    private static final List<String> valueNS;\n    private static final String valueS;\n    private static final List<String> valueSS;\n    private static final ByteBuffer valueB;\n    private static final List<ByteBuffer> valueBS;\n    private static final boolean valueBOOL;\n    private static final boolean valueNUL;\n    private static final String keyM1;\n    private static final String keyM2;\n    public static final AttributeValue attributeValueN_event;\n    public static final AttributeValue attributeValueNS_event;\n    public static final AttributeValue attributeValueS_event;\n    public static final AttributeValue attributeValueSS_event;\n    public static final AttributeValue attributeValueB_event;\n    public static final AttributeValue attributeValueBS_event;\n    public static final AttributeValue attributeValueBOOL_event;\n    public static final AttributeValue attributeValueNUL_event;\n    public static final AttributeValue attributeValueM_event;\n    public static final AttributeValue attributeValueL_event;\n    public static final software.amazon.awssdk.services.dynamodb.model.AttributeValue attributeValueN_v2;\n    public static final software.amazon.awssdk.services.dynamodb.model.AttributeValue attributeValueNS_v2;\n    public static final software.amazon.awssdk.services.dynamodb.model.AttributeValue attributeValueS_v2;\n    public static final software.amazon.awssdk.services.dynamodb.model.AttributeValue attributeValueSS_v2;\n    public static final software.amazon.awssdk.services.dynamodb.model.AttributeValue attributeValueB_v2;\n    public static final software.amazon.awssdk.services.dynamodb.model.AttributeValue attributeValueBS_v2;\n    public static final software.amazon.awssdk.services.dynamodb.model.AttributeValue attributeValueBOOL_v2;\n    public static final software.amazon.awssdk.services.dynamodb.model.AttributeValue attributeValueNUL_v2;\n    public static final software.amazon.awssdk.services.dynamodb.model.AttributeValue attributeValueM_v2;\n    public static final software.amazon.awssdk.services.dynamodb.model.AttributeValue attributeValueL_v2;\n\n    @Test\n    public void testToAttributeValueV2_IllegalArgumentWhenNull_BOOL() {\n", "reference": "        Assertions.assertThrows(IllegalArgumentException.class, () ->\n                DynamodbAttributeValueTransformer.toAttributeValueV2(new AttributeValue().withBOOL(null))\n        );\n    }\n\n}", "prediction": "        assertThrows(IllegalArgumentException.class, () -> DynamodbAttributeValueTransformer.toAttributeValueV2(\n                AttributeValue.builder()\n                        .bool(null)\n                        .build()\n        ));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "35957836_1", "part": [1, 1], "seq": [1, 1], "prompt": "class LanguageStats {\n\n    public static List<LanguageStats> buildStats(List<Project> projectList) {\n        List<Project> projects = filterUniqueSnapshots(projectList);\n\n        // For each date, we have a map of all the counts. Later we piece the\n        // results together from these pieces of information.\n        Map<Date, Map<String,Integer>> counts = new HashMap<>();\n        TreeSet<Date> dates = new TreeSet<>();\n        Set<String> languages = new HashSet<>();\n\n        for (Project p: projects) {\n            String language = p.getPrimaryLanguage();\n            Date date = p.getSnapshotDate();\n\n            if (language == null)\n                language = \"unknown\";\n\n            dates.add(date);\n            languages.add(language);\n\n            Map<String,Integer> hist = counts.get(date);\n            if (hist == null) {\n                hist = new HashMap<>();\n                counts.put(date, hist);\n            }\n\n            if (hist.containsKey(language)) {\n                hist.put(language, hist.get(language) + 1);\n            } else {\n                hist.put(language, 1);\n            }\n        }\n\n        List<LanguageStats> result = new ArrayList<>();\n        for (String l: languages) {\n            List<Integer> projectCounts = new ArrayList<>();\n            List<Date> snapshotDates = new ArrayList<>(dates);\n\n            for(Date d: snapshotDates) {\n                Integer i = counts.get(d).get(l);\n                if (i == null) {\n                    projectCounts.add(0);\n                } else {\n                    projectCounts.add(i);\n                }\n            }\n            result.add(new LanguageStats(l, projectCounts, snapshotDates));\n        }\n        return result;\n    }\n\n    public  LanguageStats(String languageName, List<Integer> projectCounts, List<Date> snapshotDates);\n\n    public static List<Project> filterUniqueSnapshots(List<Project> projects);\n    @JsonProperty(value=\"name\") public String getLanguageName();\n    @JsonProperty(value=\"project_counts\") public List<Integer> getProjectCounts();\n    @JsonProperty(value=\"snapshot_dates\") @JsonSerialize(using = JsonDateListSerializer.class) public List<Date> getSnapshotDates();\n\n    private static final String JAVA;\n    private static final String PYTHON;\n\n}\n\nclass LanguageStatsTest {\n\n    private static final String JAVA;\n    private static final String PYTHON;\n\n    @Test\n    public void thatStatsAreBuiltForEmptyProjects() {\n", "reference": "        assertThat(LanguageStats.buildStats(Lists.newArrayList()), empty());\n    }\n\n}", "prediction": "        List<Project> projects = new ArrayList<>();\n        List<LanguageStats> stats = LanguageStats.buildStats(projects);\n        assertEquals(0, stats.size());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "36185854_15", "part": [1, 1], "seq": [1, 1], "prompt": "class BasenameBuilder {\n\n    static String build(Resource resource) throws IOException{\n        Validate.notNull(resource, \"resource can't be null!\");\n\n        //---------------------------------------------------------------\n\n        URL url = resource.getURL();\n        String fileName = url.getFile();\n\n        String afterParseUrl = parseUrl(url, fileName);\n\n        String baseName = parseBasename(afterParseUrl);\n        LOGGER.debug(\"file:[{}],baseName is:[{}]\", fileName, baseName);\n        return baseName;\n    }\n\n    private  BasenameBuilder();\n\n    private static String parseUrl(URL url,String fileName);\n    private static String parseBasename(String replaceFirst);\n\n}\n\nclass BasenameBuilderTest  {\n\n    @Test\n    public void test() throws IOException{\n", "reference": "        String urlOrPath = \"classpath:i18n/help_message_zh_HK.properties\";\n        Resource resource = ResourceUtil.getResource(urlOrPath);\n        String build = BasenameBuilder.build(resource);\n\n        LOGGER.debug(build);\n    }\n\n}", "prediction": "        Resource resource = new ClassPathResource(\"test.txt\");\n        String basename = BasenameBuilder.build(resource);\n        Assert.assertEquals(\"test\", basename);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "37813245_0", "part": [1, 1], "seq": [1, 1], "prompt": "class ReservationClient {\n\n    public Flux<Reservation> getAllReservations() {\n        return this.webClient\n                .get()\n                .uri(\"http://localhost:8081/reservations\")\n                .retrieve()\n                .bodyToFlux(Reservation.class);\n    }\n\n    @Autowired\n    private ReservationClient client;\n\n}\n\nclass ReservationClientTest {\n\n    @Autowired\n    private ReservationClient client;\n\n    @Test\n    public void getAll() {\n", "reference": "\n      /*  WireMock\n                .stubFor(WireMock\n                        .get(\"/reservations\")\n                        .willReturn(\n                                WireMock\n                                        .aResponse()\n                                        .withHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)\n                                        .withBody(\"[ { \\\"id\\\":\\\"1\\\", \\\"reservationName\\\":\\\"Jane\\\" } ]\")\n                        ));\n*/\n\n        Flux<Reservation> allReservations = this.client.getAllReservations();\n        StepVerifier\n                .create(allReservations)\n                .expectNextMatches(r -> r.getName().equalsIgnoreCase(\"Jane\") && r.getId() != null)\n                .verifyComplete();\n\n    }\n\n}", "prediction": "        StepVerifier.create(client.getAllReservations())\n                .expectNextCount(1)\n                .expectComplete()\n                .verify();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "37814227_6", "part": [1, 1], "seq": [1, 1], "prompt": "class TravisRestService {\n\n  public void finish(long buildId) throws Exception {\n    jandyWorker.put(buildId, JandyTask.FINISH, Long.valueOf(buildId));\n  }\n\n  @Transactional public void begin(BuildInfo bi);\n  @Transactional public Map<String, ?> createProf(ProfilingInfo profParams);\n  public void saveProf(ProfilingContext profilingContext);\n  public void updateTreeNodes(List<TreeNode> treeNodes);\n\n  @Autowired\n  private TravisRestService travisRestService;\n  @MockBean\n  private ProfContextDumpRepository profContextDumpRepository;\n  @MockBean\n  private ProjectRepository projectRepository;\n  @MockBean\n  private BranchRepository branchRepository;\n  @MockBean\n  private BuildRepository buildRepository;\n  @MockBean\n  private JandyWorker jandyWorker;\n  @MockBean\n  private SampleRepository sampleRepository;\n  private BuildInfo bi;\n  private Project project;\n  private Branch branch;\n\n}\n\nclass TravisRestServiceTest {\n\n  @Autowired\n  private TravisRestService travisRestService;\n  @MockBean\n  private ProfContextDumpRepository profContextDumpRepository;\n  @MockBean\n  private ProjectRepository projectRepository;\n  @MockBean\n  private BranchRepository branchRepository;\n  @MockBean\n  private BuildRepository buildRepository;\n  @MockBean\n  private JandyWorker jandyWorker;\n  @MockBean\n  private SampleRepository sampleRepository;\n  private BuildInfo bi;\n  private Project project;\n  private Branch branch;\n\n  @Test\n  public void testFinish() throws Exception {\n", "reference": "    travisRestService.finish(1L);\n\n    verify(jandyWorker, times(1)).put(eq(1L), eq(JandyTask.FINISH), eq(Long.valueOf(1L)));\n  }\n\n}", "prediction": "    travisRestService.finish(1);\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "37817790_8", "part": [1, 1], "seq": [1, 1], "prompt": "class SetterAdapter implements Setter {\n\n    @Override\n    public void setTransientColour(@ColorInt int colour) {\n        colorSetter.setTransientColor(colour);\n    }\n\n    public  SetterAdapter(ColorSetter colorSetter);\n\n    @Override public void setColour(@ColorInt int colour);\n\n    @Mock\n    private ColorSetter colorSetter;\n    private Setter setter;\n\n}\n\nclass SetterAdapterTest {\n\n    @Mock\n    private ColorSetter colorSetter;\n    private Setter setter;\n\n    @Test\n    public void givenAColourSetterWrappedInASetterAdapterThenTransientSetColorIsCalled() {\n", "reference": "        setter.setTransientColour(1);\n        verify(colorSetter, atLeastOnce()).setTransientColor(anyInt());\n    }\n\n}", "prediction": "        setter.setTransientColour(1);\n        verify(colorSetter).setTransientColor(1);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "38092182_93", "part": [1, 1], "seq": [1, 1], "prompt": "class VastVideoViewController extends BaseVideoViewController implements DownloadTask.DownloadTaskListener {\n\n    @Deprecated\n    int getShowCloseButtonDelay() {\n        return mShowCloseButtonDelay;\n    }\n\n      VastVideoViewController(final Context context,\n            final Bundle bundle,\n            final long broadcastIdentifier,\n            final BaseVideoViewControllerListener baseVideoViewControllerListener);\n\n    @Override protected VideoView getVideoView();\n    @Override protected void onCreate();\n    @Override protected void onResume();\n    @Override protected void onPause();\n    @Override protected void onDestroy();\n    @Override public boolean backButtonEnabled();\n    @Override void onActivityResult(final int requestCode, final int resultCode, final Intent data);\n    @Override public void onComplete(String url, DownloadResponse downloadResponse);\n    private void downloadCompanionAd();\n    private Runnable createVideoProgressCheckerRunnable();\n    private void createVideoBackground(final Context context);\n    private VastVideoToolbar createVastVideoToolBar(final Context context);\n    private VideoView createVideoView(final Context context);\n     boolean retryMediaPlayer(final MediaPlayer mediaPlayer, final int what, final int extra);\n    private ImageView createCompanionAdImageView(final Context context);\n    private void handleClick(final List<String> clickThroughTrackers, final String clickThroughUrl);\n    private boolean isLongVideo(final int duration);\n    private void makeVideoInteractable();\n    private boolean shouldBeInteractable();\n    private boolean shouldAllowClickThrough();\n    private void startProgressChecker();\n    private void stopProgressChecker();\n    @Deprecated boolean getIsVideoProgressShouldBeChecked();\n    @Deprecated int getVideoRetries();\n    @Deprecated boolean isShowCloseButtonEventFired();\n    @Deprecated void setCloseButtonVisible(boolean visible);\n    @Deprecated boolean isVideoFinishedPlaying();\n    @Deprecated ImageView getCompanionAdImageView();\n\n    public static final int NETWORK_DELAY;\n    private MediaPlayer mediaPlayer;\n    private Context context;\n    private Bundle bundle;\n    private long testBroadcastIdentifier;\n    private VastVideoViewController subject;\n    private BaseVideoViewControllerListener baseVideoViewControllerListener;\n    private EventForwardingBroadcastReceiver broadcastReceiver;\n    private int expectedBrowserRequestCode;\n    private String expectedUserAgent;\n\n}\n\nclass VastVideoViewControllerTest {\n\n    public static final int NETWORK_DELAY;\n    private MediaPlayer mediaPlayer;\n    private Context context;\n    private Bundle bundle;\n    private long testBroadcastIdentifier;\n    private VastVideoViewController subject;\n    private BaseVideoViewControllerListener baseVideoViewControllerListener;\n    private EventForwardingBroadcastReceiver broadcastReceiver;\n    private int expectedBrowserRequestCode;\n    private String expectedUserAgent;\n\n    @Test\n    public void constructor_shouldNotChangeCloseButtonDelay() throws Exception {\n", "reference": "        initializeSubject();\n\n        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON);\n    }\n\n}", "prediction": "        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(VastVideoViewController.SHOW_CLOSE_BUTTON_DELAY);\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "38943889_27", "part": [1, 1], "seq": [1, 1], "prompt": "class ByteArray implements Serializable, Cloneable {\n\n    public ByteArray clearBit(int displacement, byte mask) {\n        byte b = value.get(displacement);\n        b &= (255 - (mask & 0xff));\n        value.put(displacement, b);\n        return this;\n    }\n\n    public  ByteArray(int size);\n    public  ByteArray(int size, String encoding);\n    public  ByteArray(int size, ByteOrder order);\n    public  ByteArray(int size, String encoding, ByteOrder order);\n    public  ByteArray(byte[] array);\n    public  ByteArray(byte[] array, ByteOrder order);\n    public  ByteArray(byte[] array, String encoding);\n    public  ByteArray(byte[] array, String encoding, ByteOrder order);\n    public  ByteArray(ByteArray byteArray);\n    public  ByteArray(ByteBuffer buffer);\n    public  ByteArray(ByteBuffer buffer, String encoding);\n\n    public Object clone();\n    public ByteArray slice(int displacement, int length);\n    public ByteArray duplicate();\n    public boolean testBit(int displacement, byte mask);\n    public ByteArray setBit(int displacement, byte mask);\n    public ByteArray setBit(int displacement, byte mask, boolean b);\n    public byte[] read(int displacement, int length);\n    public int read(int displacement, byte[] bytes);\n    public int read(int displacement, byte[] bytes, int offset, int length);\n    public byte readAsByte(int displacement);\n    public ByteArray readAsByteArray(int displacement, int length);\n    public char readAsChar(int displacement);\n    public char[] readAsCharArray(int displacement, int length);\n    public int read(int displacement, char[] chars);\n    public int read(int displacement, char[] chars, int offset, int length);\n    public String readAsString();\n    public String readAsString(int displacement);\n    public String readAsString(int displacement, int length);\n    public String readAsString(int displacement, int length, boolean nts);\n    public float readAsFloat(int displacement);\n    public double readAsDouble(int displacement);\n    public short readAsShort(int displacement);\n    public int readAsInt(int displacement);\n    public long readAsLong(int displacement);\n    public String readPns(int displacement, int length);\n    public String readPns(int displacement, int length, boolean convertAtoF);\n    private char convertAtoF(byte nybble);\n    public ByteArray fill();\n    public ByteArray fill(byte filler);\n    public ByteArray fill(byte filler, int displacement, int length);\n    public ByteArray write(char[] chars, int displacement);\n    public ByteArray write(char[] chars, int offset, int length, int displacement);\n    public ByteArray write(ByteArray byteArray, int displacement, int length);\n    public ByteArray write(ByteArray byteArray, int displacement);\n    public ByteArray write(byte[] bytes, int displacement);\n    public ByteArray write(byte[] bytes, int offset, int length, int displacement);\n    public ByteArray write(String s, int displacement);\n    public ByteArray write(String s, int displacement, int length);\n    public ByteArray write(String s, int displacement, int length, boolean nts);\n    public ByteArray write(short s, int displacement);\n    public ByteArray write(char c, int displacement);\n    public ByteArray write(byte b, int displacement);\n    public ByteArray write(int i, int displacement);\n    public ByteArray write(long i, int displacement);\n    public ByteArray write(float f, int displacement);\n    public ByteArray write(double d, int displacement);\n    public ByteArray writeAsPs(String s, int displacement, int length);\n    public ByteArray writeAsPns(String s, int displacement, int length);\n    public ByteArray writeAsPns(String s, int displacement, int length,\n                                char filler);\n    private static byte convertCharToNybble(char fromChar);\n    public static byte getSpaceFiller(String encoding);\n    public static ByteArray valueOf(String string);\n    @Override public boolean equals(Object anObject);\n    public static boolean equalTo(ByteArray a, ByteArray b);\n    public boolean equalSame(byte b);\n    public boolean equalSame(byte b, int displacement, int length);\n    public int getLength();\n    public boolean hasArray();\n    public UnderlyingArray getArray();\n    public byte[] getBytes();\n    @Deprecated public byte[] getByteArray();\n    public ByteArray setEncoding(String encoding);\n    public String getEncoding();\n    public ByteArray setOrder(ByteOrder order);\n    public ByteOrder getOrder();\n    public ByteBuffer getBuffer();\n\n     ByteArray byteArray;\n\n}\n\nclass ByteArrayTest {\n\n     ByteArray byteArray;\n\n    @Test\n    public void testClearBit() {\n", "reference": "        byte[] ba = new byte[2];\n        byteArray = new ByteArray(ba);\n        byteArray.setBit(0, (byte) 0x41);\n        byteArray.setBit(1, (byte) 0x01);\n        assertTrue(byteArray.testBit(0, (byte) 0x01));\n        assertTrue(byteArray.testBit(0, (byte) 0x40));\n        assertTrue(byteArray.testBit(0, (byte) 0x41));\n        assertFalse(byteArray.testBit(0, (byte) 0x02));\n        byteArray.clearBit(0, (byte) 0x40);\n        assertTrue(byteArray.testBit(0, (byte) 0x01));\n        assertFalse(byteArray.testBit(0, (byte) 0x40));\n        System.out.println(\"CLR : \" + byteArray.readPns(0, 2));\n        byteArray.clearBit(0, (byte) 0x80);\n        System.out.println(\"CLR : \" + byteArray.readPns(0, 2));\n        byteArray.clearBit(0, (byte) 0x01);\n        byteArray.setBit(0, (byte) 0x42);\n        System.out.println(\"CLR : \" + byteArray.readPns(0, 2));\n    }\n\n}", "prediction": "        byteArray.clearBit(0, (byte) 0x01);\n        assertEquals(0, byteArray.readAsByte(0));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "39038703_232", "part": [1, 1], "seq": [1, 1], "prompt": "class WorkspaceItem implements InProgressSubmission, Serializable, ReloadableEntity<Integer> {\n\n    @Override\n    public boolean hasMultipleFiles()\n    {\n        return multipleFiles;\n    }\n\n    protected  WorkspaceItem();\n\n    @Override public Integer getID();\n    public int getStageReached();\n    public void setStageReached(int v);\n    public int getPageReached();\n    public void setPageReached(int v);\n    @Override public boolean equals(Object o);\n    @Override public int hashCode();\n    @Override public Item getItem();\n     void setItem(Item item);\n    @Override public Collection getCollection();\n     void setCollection(Collection collection);\n    @Override public EPerson getSubmitter();\n    @Override public void setMultipleFiles(boolean b);\n    @Override public boolean hasMultipleTitles();\n    @Override public void setMultipleTitles(boolean b);\n    @Override public boolean isPublishedBefore();\n    @Override public void setPublishedBefore(boolean b);\n    public List<Group> getSupervisorGroups();\n     void removeSupervisorGroup(Group group);\n     void addSupervisorGroup(Group group);\n\n    private static final Logger log;\n    private WorkspaceItem wi;\n    private Community owningCommunity;\n    private Collection collection;\n    protected CommunityService communityService;\n    protected CollectionService collectionService;\n    protected EPersonService ePersonService;\n    protected ItemService itemService;\n    protected WorkspaceItemService workspaceItemService;\n\n}\n\nclass WorkspaceItemTest  {\n\n    private static final Logger log;\n    private WorkspaceItem wi;\n    private Community owningCommunity;\n    private Collection collection;\n    protected CommunityService communityService;\n    protected CollectionService collectionService;\n    protected EPersonService ePersonService;\n    protected ItemService itemService;\n    protected WorkspaceItemService workspaceItemService;\n\n    @Test\n    public void testHasMultipleFiles()\n    {\n", "reference": "        assertFalse(\"testHasMultipleFiles 0\", wi.hasMultipleFiles());\n    }\n\n}", "prediction": "        assertFalse(wi.hasMultipleFiles());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "39215543_3", "part": [1, 1], "seq": [1, 1], "prompt": "class InstrumentedOkHttpClients {\n\n  public static OkHttpClient create(MetricRegistry registry) {\n    return new InstrumentedOkHttpClient(registry, new OkHttpClient(), null);\n  }\n\n  private  InstrumentedOkHttpClients();\n\n  public static OkHttpClient create(MetricRegistry registry, OkHttpClient client);\n  public static OkHttpClient create(MetricRegistry registry, String name);\n  public static OkHttpClient create(MetricRegistry registry, OkHttpClient client, String name);\n\n  private MetricRegistry registry;\n\n}\n\nclass InstrumentedOkHttpClientsTest {\n\n  private MetricRegistry registry;\n\n  @Test public void instrumentProvidedClient() {\n", "reference": "    OkHttpClient rawClient = new OkHttpClient();\n    OkHttpClient client = InstrumentedOkHttpClients.create(registry, rawClient);\n    assertThatClientsAreEqual(client, rawClient);\n  }\n\n}", "prediction": "    OkHttpClient client = new OkHttpClient();\n    InstrumentedOkHttpClient instrumented = InstrumentedOkHttpClients.create(registry, client);\n    assertThat(instrumented).isNotSameAs(client);\n  }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "39542036_0", "part": [1, 1], "seq": [1, 1], "prompt": "class UserRepository {\n\n    @Transactional(SUPPORTS)\n    public User find(final long id) {\n        return em.find(User.class, id);\n    }\n\n    @Resource\n    private DataSource dataSource;\n    @Rule\n    public final TestRule rules;\n    @Inject\n    private UserRepository repository;\n\n}\n\nclass UserRepositoryTest {\n\n    @Resource\n    private DataSource dataSource;\n    @Rule\n    public final TestRule rules;\n    @Inject\n    private UserRepository repository;\n\n    @Test\n    @DataSet(\"datasets/users.yml\")\n    public void find1() {\n", "reference": "        assertEquals(\"John Smith\", repository.find(1L).getName());\n        assertEquals(\"Clark Kent\", repository.find(2L).getName());\n    }\n\n}", "prediction": "        User user = repository.find(1);\n        assertThat(user.getId(), is(1L));\n        assertThat(user.getName(), is(\"user1\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "40141672_1", "part": [1, 1], "seq": [1, 1], "prompt": "class StateListColourDrawableBuilder {\n\n    public StateListColourDrawableBuilder addStateColour(int[] states, int colour) {\n\n        for(int state: states) {\n            if(!ResourceUtils.isValidState(state)) {\n                throw new IllegalArgumentException(\"Invalid state passed to StateListColourDrawableBuilder: \" + state);\n            }\n        }\n\n        stateColoursList.add(new StateColour(states, colour));\n        return this;\n    }\n\n    public  StateListColourDrawableBuilder(int defaultColour);\n\n    public Drawable getDrawable();\n\n}\n\nclass StateListColourDrawableBuilderTest {\n\n    @Test\n    public void adding_invalid_state_should_fail() {\n", "reference": "        try {\n            StateListColourDrawableBuilder builder = new StateListColourDrawableBuilder(Color.BLACK);\n            builder.addStateColour(new int[]{1}, Color.RED);\n            fail(\"Adding invalid state should fail in StateListColourDrawableBuilder\");\n        } catch (IllegalArgumentException e) {}\n    }\n\n}", "prediction": "        StateListColourDrawableBuilder builder = new StateListColourDrawableBuilder(Color.BLACK);\n\n        try {\n            builder.addStateColour(new int[] { -1 }, Color.BLACK);\n            fail();\n        } catch (IllegalArgumentException e) {\n            assertThat(e.getMessage(), is(\"Invalid state passed to StateListColourDrawableBuilder: -1\"));\n        }\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "40162365_29", "part": [1, 1], "seq": [1, 1], "prompt": "class PauseResumeAudioRecorder {\n\n    public void setSampleRate(final int sampleRateInHertz){\n        if (sampleRateInHertz!=DEFAULT_AUDIO_SAMPLE_RATE_HERTZ && sampleRateInHertz !=22050\n                && sampleRateInHertz != 16000 && sampleRateInHertz !=11025){\n            throw new IllegalArgumentException(\"Invalid sample rate given\");\n        }\n        else if (currentAudioState.get()!=PREPARED_STATE && currentAudioState.get()!=INITIALIZED_STATE ){\n            throw new IllegalStateException(\"Recorder cannot have its sample rate changed when it is not in an initialized or prepared state\");\n        }\n        this.sampleRateInHertz=sampleRateInHertz;\n    }\n\n    public  PauseResumeAudioRecorder();\n\n    public void setOnFileSizeReachedListener(final OnFileSizeReachedListener onFileSizeReachedListener);\n    public void setMaxFileSizeInBytes(final long maxFileSizeInBytes);\n    public void setOnTimeCompletionListener(final OnTimeCompletionListener onTimeCompletionListener);\n    public void setMaxTimeInMillis(final long maxTimeInMillis);\n    public void setAudioEncoding(final int audioEncoding);\n    public void setAudioFile(final String audioFilePath);\n    public void setChannel(final int channelConfig);\n    public int getCurrentState();\n    public void startRecording();\n    public void pauseRecording();\n    public void resumeRecording();\n    public void stopRecording();\n\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private PauseResumeAudioRecorder pauseResumeAudioRecorder;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private boolean failTest;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field sampleRateInHertzField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field channelConfigField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field audioEncodingField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field audioFileField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field currentAudioStateField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field currentAudioRecordingThreadField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field recordingStartTimeMillisField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field remainingMaxTimeInMillisField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field onTimeCompletedTimerField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field onTimeCompletionTimerTaskField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field onTimeCompletionListenerField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field maxTimeInMillisField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field onFileSizeReachedListenerField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field maxFileSizeInBytesField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field audioRecordThreadField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);@Mock\n    private Timer mockTimer;\n\n}\n\nclass PauseResumeAudioRecorderTest {\n\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private PauseResumeAudioRecorder pauseResumeAudioRecorder;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private boolean failTest;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field sampleRateInHertzField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field channelConfigField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field audioEncodingField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field audioFileField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field currentAudioStateField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field currentAudioRecordingThreadField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field recordingStartTimeMillisField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field remainingMaxTimeInMillisField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field onTimeCompletedTimerField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field onTimeCompletionTimerTaskField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field onTimeCompletionListenerField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field maxTimeInMillisField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field onFileSizeReachedListenerField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field maxFileSizeInBytesField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field audioRecordThreadField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);@Mock\n    private Timer mockTimer;\n\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);@Test(expected = IllegalArgumentException.class)\n", "reference": "    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);}\n\n}", "prediction": "   public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private PauseResumeAudioRecorder pauseResumeAudioRecorder;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private boolean failTest;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field sampleRateInHertzField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field channelConfigField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field audioEncodingField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field audioFileField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field currentAudioStateField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field currentAudioRecordingThreadField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field recordingStartTimeMillisField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field remainingMaxTimeInMillisField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field onTimeCompletedTimerField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field onTimeCompletionTimerTaskField;\n    public void testSetSampleRateBadInput(){p", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "40492118_30", "part": [1, 1], "seq": [1, 1], "prompt": "class PreLollipopNetworkObservingStrategy implements NetworkObservingStrategy {\n\n  @Override public void onError(final String message, final Exception exception) {\n    Log.e(LOG_TAG, message, exception);\n  }\n\n  @Override public Observable<Connectivity> observeNetworkConnectivity(final Context context);\n  protected void tryToUnregisterReceiver(final Context context, final BroadcastReceiver receiver);\n  private Disposable disposeInUiThread(final Action action);\n\n  @Rule public MockitoRule rule;\n  @Spy private PreLollipopNetworkObservingStrategy strategy;\n  @Mock private BroadcastReceiver broadcastReceiver;\n\n}\n\nclass PreLollipopNetworkObservingStrategyTest {\n\n  @Rule public MockitoRule rule;\n  @Spy private PreLollipopNetworkObservingStrategy strategy;\n  @Mock private BroadcastReceiver broadcastReceiver;\n\n  @Test public void shouldCallOnError() {\n", "reference": "    // given\n    final String message = \"error message\";\n    final Exception exception = new Exception();\n\n    // when\n    strategy.onError(message, exception);\n\n    // then\n    verify(strategy, times(1)).onError(message, exception);\n  }\n\n}", "prediction": "    final String message = \"message\";\n    final Exception exception = new Exception();\n    strategy.onError(message, exception);\n    verify(strategy).onError(message, exception);\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "40672250_1", "part": [1, 1], "seq": [1, 1], "prompt": "class MarkLogicDatasetGraph extends DatasetGraphTriplesQuads implements\n        DatasetGraph, Transactional {\n\n    public Dataset toDataset() {\n        checkIsOpen();\n        return DatasetFactory.wrap(this);\n    }\n\n    public  MarkLogicDatasetGraph(JenaDatabaseClient jenaClient);\n\n    @Override public Iterator<Node> listGraphNodes();\n    @Override public Lock getLock();\n    @Override public void clear();\n    public static SPARQLQueryDefinition bindObject(SPARQLQueryDefinition qdef,\n            String variableName, Node objectNode);\n    @Override protected void addToDftGraph(Node s, Node p, Node o);\n    private Node skolemize(Node s);\n    @Override protected void addToNamedGraph(Node g, Node s, Node p, Node o);\n    @Override protected void deleteFromDftGraph(Node s, Node p, Node o);\n    @Override protected void deleteFromNamedGraph(Node g, Node s, Node p, Node o);\n    private InputStream selectTriplesInGraph(String graphName, Node s, Node p,\n            Node o);\n    @Override protected Iterator<Quad> findInDftGraph(Node s, Node p, Node o);\n    @Override protected Iterator<Quad> findInSpecificNamedGraph(Node g, Node s, Node p,\n            Node o);\n    @Override protected Iterator<Quad> findInAnyNamedGraphs(Node s, Node p, Node o);\n    @Override /** * @see org.apache.jena.sparql.core.DatasetGraph */ public void setDefaultGraph(Graph g);\n    @Override /** * Start a transaction. */ public void begin(ReadWrite readWrite);\n    @Override /** * Commit the current transaction. */ public void commit();\n    @Override /** * Abort the current transaction with a rollback operation. */ public void abort();\n    @Override /** * @return true if there is a multi-statement transaction in play. */ public boolean isInTransaction();\n    @Override /** * Synonymous with abort(); */ public void end();\n    @Override public Graph getDefaultGraph();\n    @Override public Graph getGraph(Node graphNode);\n    @Override public void addGraph(Node graphName, Graph graph);\n    public void mergeGraph(Node graphName, Graph graph);\n    @Override public void removeGraph(Node graphName);\n    @Override /** * Not supported by MarkLogicDatasetGraph. */ public long size();\n    public GraphPermissions getPermissions(Node graphName);\n    public void addPermissions(Node graphName, GraphPermissions permissions);\n    public void clearPermissions(Node graphName);\n    public void writePermissions(Node graphName, GraphPermissions permissions);\n    public void sync();\n    public void syncAdds();\n    public void setRulesets(SPARQLRuleset... rulesets);\n    public SPARQLRuleset[] getRulesets();\n    public MarkLogicDatasetGraph withRulesets(SPARQLRuleset... rulesets);\n    public void setConstrainingQueryDefinition(\n            QueryDefinition constrainingQueryDefinition);\n    public QueryDefinition getConstrainingQueryDefinition();\n    public JenaDatabaseClient getDatabaseClient();\n    public void setSPARQLUpdatePermissions(GraphPermissions permissions);\n    public GraphPermissions getSPARQLUpdatePermissions();\n    @Override public void close();\n    @Override public boolean supportsTransactions();\n    private void checkIsOpen();\n\n    private static Logger log;\n\n}\n\nclass MarkLogicDatasetGraphTest extends DatasetGraphTriplesQuads {\n\n    private static Logger log;\n\n    @Test\n    public void testRIOTWrite() {\n", "reference": "        Dataset dataSet = getMarkLogicDatasetGraph(\"testdata/smallfile.nt\")\n                .toDataset();\n        RDFDataMgr.write(System.out, dataSet, RDFFormat.TRIG_PRETTY);\n    }\n\n}", "prediction": "       DatasetGraph dsg = DatasetFactory.create();\n        dsg.add(Quad.defaultGraphNodeGenerated, NodeFactory.createURI(\"http://example.org/s\"),\n                NodeFactory.createURI(\"http://example.org/p\"),\n                NodeFactory.createLiteral(\"o\"));\n        dsg.add(Quad.defaultGraphNodeGenerated, NodeFactory.createURI(\"http://example.org/s\"),\n                NodeFactory.createURI(\"http://example.org/p\"),\n                NodeFactory.createLiteral(\"o\"));\n        dsg.add(Quad.defaultGraphNodeGenerated, NodeFactory.createURI(\"http://example.org/s\"),\n                NodeFactory.createURI(\"http://example.org/p\"),\n                NodeFactory.createLiteral(\"o\"));\n        dsg.add(Quad.defaultGraphNodeGenerated, NodeFactory.createURI(\"http://example.org/s\"),\n                NodeFactory.createURI(\"http://example.org/p\"),\n                NodeFactory.createLiteral(\"o\"));\n        dsg.add(Quad.defaultGraphNodeGenerated, NodeFactory.createURI(\"http://example.org/s\"),\n                NodeFactory.createURI(\"http://example.org/p\"),\n                NodeFactory.createLiteral(\"o\"));\n        dsg.add(Quad.defaultGraphNodeGenerated, NodeFactory.createURI(\"http://example.org/s\"),\n                NodeFactory.createURI(\"http://example.org/p\"),\n                NodeFactory.createLiteral(\"o\"));\n        dsg.add(Quad.defaultGraphNodeGenerated, NodeFactory.createURI(\"http://example.org/s\"),\n                NodeFactory.createURI(\"http://example.org/p\"),\n                NodeFactory.createLiteral(\"o\"));\n        dsg.add", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "41633567_2", "part": [1, 1], "seq": [1, 1], "prompt": "class SpreadsheetMetadata implements ConnectorMetadata {\n\n  @Override\n  public ConnectorTableHandle getTableHandle(ConnectorSession session, SchemaTableName tableName) {\n    Path spreadsheetPath = getSpreadsheetBasePath(session.getUser());\n    Path filePath = getSpreadsheetFilePath(session, spreadsheetPath, tableName.getSchemaName());\n    return new SpreadsheetTableHandle(session.getUser(), tableName, filePath.toString());\n  }\n\n  public  SpreadsheetMetadata(UserGroupInformation ugi, Configuration configuration, Path basePath,\n      String spreadsheetSubDir, boolean useFileCache, boolean proxyUser);\n\n  @Override public List<ConnectorTableLayoutResult> getTableLayouts(ConnectorSession session, ConnectorTableHandle table,\n      Constraint<ColumnHandle> constraint, Optional<Set<ColumnHandle>> desiredColumns);\n  @Override public ConnectorTableLayout getTableLayout(ConnectorSession session, ConnectorTableLayoutHandle handle);\n  @Override public ColumnMetadata getColumnMetadata(ConnectorSession session, ConnectorTableHandle tableHandle,\n      ColumnHandle columnHandle);\n  @Override public ConnectorTableMetadata getTableMetadata(ConnectorSession session, ConnectorTableHandle table);\n  @Override public Map<SchemaTableName, List<ColumnMetadata>> listTableColumns(ConnectorSession session,\n      SchemaTablePrefix prefix);\n  private SpreadsheetTableLayoutHandle createTableLayoutHandle(SpreadsheetTableHandle tableHandle);\n  @Override public List<String> listSchemaNames(ConnectorSession session);\n  @Override public List<SchemaTableName> listTables(ConnectorSession session, String schemaNameOrNull);\n  @Override public Map<String, ColumnHandle> getColumnHandles(ConnectorSession session, ConnectorTableHandle tableHandle);\n  private Path getSpreadsheetFilePath(ConnectorSession session, Path spreadsheetPath, String schema);\n  private Path getSpreadsheetBasePath(String user);\n  private Type getType(TableType columnType);\n  public static SpreadsheetReader getSpreadSheetHelper(UserGroupInformation ugi, ConnectorSession session,\n      SpreadsheetTableHandle spreadsheetTableHandle, Configuration configuration, boolean useFileCache);\n  private UserGroupInformation getUgi(ConnectorSession session);\n  public static UserGroupInformation getUgi(ConnectorSession session, boolean proxyUser, UserGroupInformation ugi);\n  public static UserGroupInformation getProxyUserGroupInformation(ConnectorSession session, UserGroupInformation ugi);\n\n  private static UserGroupInformation ugi;\n  private static final String SCHEMA_NAME;\n  public static final ConnectorSession SESSION;\n  private boolean useFileCache;\n  private Configuration conf;\n\n}\n\nclass SpreadsheetMetadataTest {\n\n  private static UserGroupInformation ugi;\n  private static final String SCHEMA_NAME;\n  public static final ConnectorSession SESSION;\n  private boolean useFileCache;\n  private Configuration conf;\n\n  @Test\n  public void testGetTableHandle() throws IOException {\n", "reference": "    Path basePath = setupTest(conf, SESSION.getUser(), SpreadsheetMetadataTest.class);\n    SpreadsheetMetadata spreadsheetMetadata = new SpreadsheetMetadata(ugi, conf, basePath, SPREADSHEETS, useFileCache,\n        true);\n    List<SchemaTableName> listTables = spreadsheetMetadata.listTables(SESSION, SCHEMA_NAME);\n    for (SchemaTableName name : listTables) {\n      ConnectorTableHandle tableHandle = spreadsheetMetadata.getTableHandle(SESSION, name);\n      assertTrue(tableHandle instanceof SpreadsheetTableHandle);\n      SpreadsheetTableHandle spreadsheetTableHandle = (SpreadsheetTableHandle) tableHandle;\n      String filePath = new Path(new Path(new Path(basePath, SESSION.getUser()), SPREADSHEETS),\n          PRESTO_EXAMPLE_XLSX).toString();\n      assertEquals(filePath, spreadsheetTableHandle.getSpreadsheetPath());\n      SchemaTableName tableName = spreadsheetTableHandle.getTableName();\n      assertEquals(name, tableName);\n      assertEquals(SESSION.getUser(), spreadsheetTableHandle.getUser());\n    }\n  }\n\n}", "prediction": "    SpreadsheetMetadata metadata = new SpreadsheetMetadata(ugi, conf, new Path(\"/\"), \"test\", useFileCache, false);\n    ConnectorTableHandle tableHandle = metadata.getTableHandle(SESSION, new SchemaTableName(SCHEMA_NAME, \"test\"));\n    assertNotNull(tableHandle);\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "42032884_56", "part": [1, 1], "seq": [1, 1], "prompt": "class MwMobileViewPageLead extends MwResponse implements PageLead {\n\n    @VisibleForTesting\n    public Mobileview getMobileview() {\n        return mobileview;\n    }\n\n    @Override public Page toPage(@NonNull PageTitle title);\n    private PageTitle adjustPageTitle(@NonNull PageTitle title, @NonNull String originalPrefixedText);\n    @Override @NonNull public String getLeadSectionContent();\n    @Nullable @Override public String getTitlePronunciationUrl();\n    @Nullable @Override public String getLeadImageUrl(int leadImageWidth);\n    @Nullable @Override public String getThumbUrl();\n    @Nullable @Override public String getDescription();\n    @Nullable @Override public Location getGeo();\n\n    private PageClient subject;\n\n}\n\nclass MwMobileViewPageLeadTest extends MwResponse {\n\n    private PageClient subject;\n\n    @Test public void testUnprotectedDisambiguationPage() {\n", "reference": "        MwMobileViewPageLead pageLead = unmarshal(MwMobileViewPageLead.class,\n                wrapInMobileview(getUnprotectedDisambiguationPageJson()));\n        MwMobileViewPageLead.Mobileview props = pageLead.getMobileview();\n        verifyUnprotectedDisambiguationPage(props);\n    }\n\n}", "prediction": "        // Given\n        MwMobileViewPageLead pageLead = new MwMobileViewPageLead(new MwMobileView(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "42112681_1", "part": [1, 1], "seq": [1, 1], "prompt": "class Symbol {\n\n  public static String java2Elisp(String javaName) {\n\n    StringBuffer lispName        = new StringBuffer();\n    boolean      lastCharWasDash = false;\n    char         prev            = ' ';\n\n    for (int i = 0; i < javaName.length(); i++) {\n\n      char c = javaName.charAt(i);\n\n      if (!Character.isLetterOrDigit(c)) {\n        lispName.append('-');\n        lastCharWasDash = true;\n      } else {\n        // add in a dash only if the last character was not a dash and we\n        // didn't undergo a case change from lower to upper case\n        if (i > 0 && !lastCharWasDash\n            && Character.isLetter(prev)\n            && Character.isLetter(c)\n            && Character.isLowerCase(prev)\n            && Character.isUpperCase(c)) {\n          lispName.append('-');\n        }\n\n        lispName.append(Character.toLowerCase(c));\n        lastCharWasDash = false;\n      }\n      prev = c;\n    }\n\n    return lispName.toString();\n  }\n\n  public  Symbol(String name);\n\n  public String getName();\n  public String toString();\n\n}\n\nclass SymbolTest {\n\n    @Test\n    public void testJava2Elisp2() {\n", "reference": "        assertEquals(\"jdee-foo-call-left-right\", Symbol.java2Elisp(\"jdee.foo.Call.leftRight\"));\n    }\n\n}", "prediction": "        assertEquals(\"foo-bar\", Symbol.java2Elisp(\"fooBar\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "42557838_92", "part": [1, 1], "seq": [1, 1], "prompt": "class Cookie {\n\n    public String getValue() {\n        return value;\n    }\n\n    public  Cookie(final String name, final String value);\n    public  Cookie(final String name, final int value);\n    public  Cookie(final String name, final long value);\n    public  Cookie(final String name, final double value);\n    public  Cookie(final String name, final boolean value);\n\n    private void checkNameForIllegalCharacters(final String cookieName);\n    public String getComment();\n    public void setComment(final String comment);\n    public String getDomain();\n    public void setDomain(final String domain);\n    public String getPath();\n    public void setPath(final String path);\n    public int getMaxAge();\n    public void setMaxAge(final int maxAge);\n    public String getName();\n    public void setValue(final String value);\n    public boolean isSecure();\n    public void setSecure(final boolean secure);\n    public boolean isHttpOnly();\n    public void setHttpOnly(final boolean httpOnly);\n\n}\n\nclass CookieTest {\n\n    @Test\n    public void shouldAllowDoubleValues() {\n", "reference": "        Cookie cookie = new Cookie(\"someName\", 22.33);\n        assertThat(cookie.getValue(), is(\"22.33\"));\n    }\n\n}", "prediction": "        final Cookie cookie = new Cookie(\"name\", 1.0);\n        assertEquals(\"1.0\", cookie.getValue());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "43258821_3", "part": [1, 1], "seq": [1, 1], "prompt": "class Streams {\n\n    @NotNull\n    public static <S, T> Stream<ResultWrapper<T>> parallelize(\n            @NotNull Collection<S> source,\n            @NotNull Function<S, Supplier<T>> mapper\n    ) {\n        // operations will be executed in parallel\n        List<CompletableFuture<ResultWrapper<T>>> results = source.stream()\n                .map(s -> CompletableFuture.supplyAsync(new ResultSupplier<>(mapper.apply(s)), parallelExecutor))\n                .collect(ImmutableList.toImmutableList());\n\n        return collect(results);\n    }\n\n    private  Streams();\n\n    @NotNull public static Stream<ResultWrapper<T>> parallelize(int n, @NotNull Supplier<T> supplier);\n    private static Stream<ResultWrapper<T>> collect(List<CompletableFuture<ResultWrapper<T>>> results);\n\n}\n\nclass StreamsTest {\n\n    @Test\n    public void parallelizeSupplier() {\n", "reference": "        assertEquals((long) Streams.parallelize(3, () -> 42L)\n                .filter(r -> !r.hasError())\n                .map(ResultWrapper::getResult)\n                .reduce(0L, (a, b) -> a + b), 126L);\n    }\n\n}", "prediction": "        Stream<ResultWrapper<String>> stream = Streams.parallelize(10, () -> \"test\");\n        assertThat(stream.collect(Collectors.toList())).hasSize(10);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "43306906_7", "part": [1, 1], "seq": [1, 1], "prompt": "class SparseIntArrayBuilder {\n\n  @NonNull @CheckResult public SparseIntArray build() {\n    return sparseIntArray;\n  }\n\n  public  SparseIntArrayBuilder();\n  public  SparseIntArrayBuilder(final int capacity);\n  public  SparseIntArrayBuilder(@NonNull final SparseIntArray sparseIntArray);\n\n  @CheckResult public SparseIntArrayBuilder put(final int key, final int value);\n  @CheckResult public SparseIntArrayBuilder add(final int key, final int value);\n  @CheckResult public SparseIntArrayBuilder add(@Nullable final SparseIntArray array);\n  @CheckResult public SparseIntArrayBuilder clear();\n\n}\n\nclass SparseIntArrayBuilderTest {\n\n  @Test public void constructor0CapacityBuildShouldReturnEmpty() {\n", "reference": "    final SparseIntArray actual = new SparseIntArrayBuilder(0).build();\n    final SparseIntArray expected = new SparseIntArray();\n\n    assertSparseIntArrayEquals(expected, actual);\n  }\n\n}", "prediction": "    SparseIntArray sparseIntArray = new SparseIntArrayBuilder().build();\n    assertThat(sparseIntArray).isEmpty();\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "43326581_119", "part": [1, 1], "seq": [1, 1], "prompt": "class SearchLevels {\n\n    protected boolean isCpe(String potentialCpe){\n        return (! (null == potentialCpe))\n                && ( potentialCpe.startsWith(CPE_PREFIX) || potentialCpe.startsWith(OLD_CPE_PREFIX) )\n                && potentialCpe.length() > 10;\n    }\n\n    public  SearchLevels(CveSearchApi cveSearchApi);\n\n    private static int getIntFromProperties(Properties properties, String key, int defaultValue);\n    private void setup(CveSearchApi cveSearchApi, int vendorThreshold, int productThreshold, int cutoff);\n    public Stream<List<NeedleWithMeta>> apply(Release release);\n    protected String cleanupCPE(String cpe);\n    private void addCPESearchLevel();\n    private void addGuessingSearchLevels(CveSearchApi cveSearchApi, int vendorThreshold, int productThreshold, int cutoff);\n    private List<NeedleWithMeta> guessForRelease(CveSearchGuesser cveSearchGuesser, Release release, boolean useVersionInformation);\n\n     SearchLevels searchLevels;\n\n}\n\nclass SearchLevelsTest {\n\n     SearchLevels searchLevels;\n\n    @Test\n    public void isCpeTestEmpty() {\n", "reference": "        assert(!searchLevels.isCpe(\"\"));\n    }\n\n}", "prediction": "        assertFalse(searchLevels.isCpe(\"\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "43748389_7", "part": [1, 1], "seq": [1, 1], "prompt": "class InfluxDbHttpSender extends InfluxDbBaseSender {\n\n    @Override\n    protected int writeData(byte[] line) throws Exception {\n        final HttpURLConnection con = (HttpURLConnection) url.openConnection();\n        con.setRequestMethod(\"POST\");\n        if (authStringEncoded != null && !authStringEncoded.isEmpty()) {\n            con.setRequestProperty(\"Authorization\", \"Basic \" + authStringEncoded);\n        }\n        con.setDoOutput(true);\n        con.setConnectTimeout(connectTimeout);\n        con.setReadTimeout(readTimeout);\n\n        OutputStream out = con.getOutputStream();\n        try {\n            out.write(line);\n            out.flush();\n        } finally {\n            out.close();\n        }\n\n        int responseCode = con.getResponseCode();\n\n        // Check if non 2XX response code.\n        if (responseCode / 100 != 2) {\n            throw new IOException(\n                \"Server returned HTTP response code: \" + responseCode + \" for URL: \" + url + \" with content :'\"\n                    + con.getResponseMessage() + \"'\");\n        }\n        return responseCode;\n    }\n\n    public  InfluxDbHttpSender(\n        final String protocol, final String hostname, final int port, final String database, final String authString,\n        final TimeUnit timePrecision, final int connectTimeout, final int readTimeout, final String measurementPrefix);\n    @Deprecated public  InfluxDbHttpSender(\n        final String protocol, final String hostname, final int port, final String database, final String authString,\n        final TimeUnit timePrecision);\n\n}\n\nclass InfluxDbHttpSenderTest {\n\n    @Test\n    public void shouldNotThrowException() throws Exception {\n", "reference": "        HttpServer server = HttpServer.create(new InetSocketAddress(10081), 0);\n        try {\n            server.createContext(\"/write\", new MyHandler());\n            server.setExecutor(null); // creates a default executor\n            server.start();\n            InfluxDbHttpSender influxDbHttpSender = new InfluxDbHttpSender(\n                \"http\",\n                \"localhost\",\n                10081,\n                \"testdb\",\n                \"asdf\",\n                TimeUnit.MINUTES,\n                1000,\n                1000,\n                \"\"\n            );\n            assertThat(influxDbHttpSender.writeData(new byte[0]) == 0);\n        } catch (IOException e) {\n            throw new IOException(e);\n        } finally {\n            server.stop(0);\n        }\n    }\n\n}", "prediction": "        InfluxDbHttpSender sender = new InfluxDbHttpSender(\"http\", \"localhost\", 8086, \"test\", \"test\", TimeUnit.MILLISECONDS, 1000, 1000, \"\");\n        sender.send(\"test\", \"test\", new HashMap<>());\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "44512524_217", "part": [1, 1], "seq": [1, 1], "prompt": "class FilterAction extends Action<Query> {\n\n    @Override\n    public QueryResponse execute(Query parameter) throws QueryStoreException {\n        parameter.setTable(ElasticsearchUtils.getValidTableName(parameter.getTable()));\n        if (null == parameter.getFilters() || parameter.getFilters().isEmpty()) {\n            parameter.setFilters(Lists.<Filter>newArrayList(new AnyFilter(parameter.getTable())));\n        }\n        if (null == parameter.getSort()) {\n            ResultSort resultSort = new ResultSort();\n            resultSort.setField(\"_timestamp\");\n            resultSort.setOrder(ResultSort.Order.desc);\n            parameter.setSort(resultSort);\n        }\n        SearchRequestBuilder search = null;\n        SearchResponse response;\n        try {\n            /*if(!tableManager.exists(query.getTable())) {\n                throw new QueryStoreException(QueryStoreException.ErrorCode.NO_SUCH_TABLE,\n                        \"There is no table called: \" + query.getTable());\n            }*/\n            search = getConnection().getClient().prepareSearch(ElasticsearchUtils.getIndices(parameter.getTable(), parameter))\n                    .setTypes(ElasticsearchUtils.TYPE_NAME)\n                    .setQuery(new ElasticSearchQueryGenerator(FilterCombinerType.and).genFilter(parameter.getFilters()))\n                    .setSearchType(SearchType.QUERY_THEN_FETCH)\n                    .setFrom(parameter.getFrom())\n                    .setSize(parameter.getLimit());\n            search.addSort(parameter.getSort().getField(),\n                    ResultSort.Order.desc == parameter.getSort().getOrder() ? SortOrder.DESC : SortOrder.ASC);\n            response = search.execute().actionGet();\n            Vector<String> ids = new Vector<String>();\n            for (SearchHit searchHit : response.getHits()) {\n                ids.add(searchHit.getId());\n            }\n            if (ids.isEmpty()) {\n                return new QueryResponse(Collections.<Document>emptyList());\n            }\n            return new QueryResponse(getQueryStore().get(parameter.getTable(), ids));\n        } catch (Exception e) {\n            if (null != search) {\n                logger.error(\"Error running generated query: \" + search, e);\n            } else {\n                logger.error(\"Query generation error: \", e);\n            }\n            throw new QueryStoreException(QueryStoreException.ErrorCode.QUERY_EXECUTION_ERROR,\n                    \"Error running query: \" + parameter.toString());\n        }\n    }\n\n    public  FilterAction(Query parameter,\n                        TableMetadataManager tableMetadataManager,\n                        DataStore dataStore,\n                        QueryStore queryStore,\n                        ElasticsearchConnection connection,\n                        String cacheToken);\n\n    @Override protected String getRequestCacheKey();\n\n    private QueryExecutor queryExecutor;\n    private ObjectMapper mapper;\n    private MockElasticsearchServer elasticsearchServer;\n    private HazelcastInstance hazelcastInstance;\n\n}\n\nclass FilterActionTest {\n\n    private QueryExecutor queryExecutor;\n    private ObjectMapper mapper;\n    private MockElasticsearchServer elasticsearchServer;\n    private HazelcastInstance hazelcastInstance;\n\n    @Test\n    public void testQueryEmptyResult() throws QueryStoreException, JsonProcessingException {\n", "reference": "        Query query = new Query();\n        query.setTable(TestUtils.TEST_TABLE_NAME);\n\n        EqualsFilter equalsFilter = new EqualsFilter();\n        equalsFilter.setField(\"os\");\n        equalsFilter.setValue(\"wp8\");\n        query.setFilters(Lists.<Filter>newArrayList(equalsFilter));\n\n        List<Document> documents = new ArrayList<Document>();\n        QueryResponse actualResponse = QueryResponse.class.cast(queryExecutor.execute(query));\n        compare(documents, actualResponse.getDocuments());\n    }\n\n}", "prediction": "        Query query = new Query();\n        query.setTable(\"test\");\n        query.setFilters(Lists.<Filter>newArrayList(new EqualsFilter(\"field1\", \"value1\")));\n        QueryResponse response = queryExecutor.execute(query);\n        assertEquals(0, response.getDocuments().size());\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "44579325_0", "part": [1, 1], "seq": [1, 1], "prompt": "class MoshasEngine {\n\n    public Template describe(String templateName, ViewLogicDescriber describer) {\n        if (describer == null) {\n            throw new IllegalArgumentException(\"describer is required\");\n        }\n\n        Template template = manager.loadTemplate(templateName);\n\n        describeSnippet(template, describer);\n        // Mark selected elements\n        Element root = template.getRootElement();\n        root.children().forEach(Element::selected);\n\n        manager.cacheTemplate(templateName, template);\n        describerCache.put(templateName, describer);\n        return template;\n    }\n\n    public  MoshasEngine(TemplateManager manager);\n    public  MoshasEngine();\n\n    public TemplateManager getTemplateManager();\n    private Snippet describeSnippet(Snippet snippet, ViewLogicDescriber describer);\n    public Snippet describe(String templateName, String selector, ViewLogicDescriber describer);\n    public String process(String templateName, IContext context);\n    public void process(String templateName, IContext context, Writer writer);\n\n    @Parameterized.Parameter(0)\n    public MoshasEngine engine;\n\n}\n\nclass MoshasEngineTest {\n\n    @Parameterized.Parameter(0)\n    public MoshasEngine engine;\n\n    @Test(expected = TemplateNotFoundException.class)\n    public void test() {\n", "reference": "        engine.describe(\"notfound\", t -> {});\n    }\n\n}", "prediction": "        engine.process(\"not_found\", new Context());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "44637917_4", "part": [1, 1], "seq": [1, 1], "prompt": "class CassandraDependenciesJob {\n\n  static String parsePort(String contactPoints) {\n    Set<Integer> ports = Sets.newLinkedHashSet();\n    for (String contactPoint : contactPoints.split(\",\", -1)) {\n      HostAndPort parsed = HostAndPort.fromString(contactPoint);\n      ports.add(parsed.getPortOrDefault(9042));\n    }\n    return ports.size() == 1 ? String.valueOf(ports.iterator().next()) : \"9042\";\n  }\n\n    CassandraDependenciesJob(Builder builder);\n\n  public static Builder builder();\n  public void run();\n   JavaPairRDD<String, DependencyLink> flatMapToLinksByTraceId(\n      CassandraTableScanJavaRDD<CassandraRow> spans,\n      long microsUpper, long microsLower, boolean inTest\n  );\n  static String getEnv(String key, String defaultValue);\n  static String parseHosts(String contactPoints);\n  static String traceId(CassandraRow r);\n\n}\n\nclass CassandraDependenciesJobTest {\n\n  @Test\n  public void parsePort_defaultsTo9042() {\n", "reference": "    assertThat(parsePort(\"1.1.1.1\"))\n        .isEqualTo(\"9042\");\n  }\n\n}", "prediction": "   assertThat(CassandraDependenciesJob.parsePort(\"localhost\")).isEqualTo(\"9042\");\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "44835755_19", "part": [1, 1], "seq": [1, 1], "prompt": "class MesosClient {\n\n    static int getPort(@NotNull final URI uri) {\n        final int uriPort = uri.getPort();\n        if (uriPort > 0) {\n            return uriPort;\n        } else {\n            switch (uri.getScheme()) {\n                case \"http\":\n                    return 80;\n                case \"https\":\n                    return 443;\n                default:\n                    throw new IllegalArgumentException(\"URI Scheme must be http or https\");\n            }\n        }\n    }\n\n      MesosClient(\n        @NotNull final URI mesosUri,\n        @NotNull final Function<Class<?>, UserAgentEntry> applicationUserAgentEntry,\n        @NotNull final MessageCodec<Send> sendCodec,\n        @NotNull final MessageCodec<Receive> receiveCodec,\n        @NotNull final Send subscribe,\n        @NotNull final Function<Observable<Receive>, Observable<Optional<SinkOperation<Send>>>> streamProcessor,\n        @NotNull final  Observable.Transformer<byte[], byte[]> backpressureTransformer\n    );\n\n    @NotNull public AwaitableSubscription openStream();\n    @NotNull private static URI resolveMesosUri(final @NotNull URI mesosUri);\n    @NotNull // @VisibleForTesting static URI getUriFromRedirectResponse(final @NotNull URI mesosUri, @NotNull final HttpClientResponse<ByteBuf> redirectResponse);\n    @NotNull // @VisibleForTesting static URI resolveRelativeUri(final @NotNull URI mesosUri, final String location);\n    @NotNull // @VisibleForTesting static String createRedirectUri(@NotNull final URI uri);\n    @NotNull // @VisibleForTesting static Func1<HttpClientResponse<ByteBuf>, Observable<ByteBuf>> verifyResponseOk(\n        @NotNull final Send subscription,\n        @NotNull final AtomicReference<String> mesosStreamId,\n        @NotNull final String receiveMediaType\n    );\n    @NotNull // @VisibleForTesting static Func1<Send, Observable<HttpClientRequest<ByteBuf>>> curryCreatePost(\n        @NotNull final URI mesosUri,\n        @NotNull final MessageCodec<Send> sendCodec,\n        @NotNull final MessageCodec<Receive> receiveCodec,\n        @NotNull final UserAgent userAgent,\n        @NotNull final AtomicReference<String> mesosStreamId\n    );\n\n}\n\nclass MesosClientTest {\n\n    @Test\n    public void testGetPort_returnsSpecifiedPort() throws Exception {\n", "reference": "        assertThat(MesosClient.getPort(URI.create(\"http://glavin:500/path\"))).isEqualTo(500);\n    }\n\n}", "prediction": "        final URI uri = new URI(\"http://localhost:1234\");\n        assertEquals(1234, MesosClient.getPort(uri));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "46134098_14", "part": [1, 1], "seq": [1, 1], "prompt": "class JavaPropertiesResource extends ResourceFilter {\n\n    @Override\n    public void write(OutputStream outStream, LanguageBundle languageBundle,\n            FilterOptions options) throws IOException, ResourceFilterException {\n\n        List<ResourceString> resStrings = languageBundle.getSortedResourceStrings();\n        BreakIterator brkItr = Utils.getWordBreakIterator(options);\n\n        PrintWriter pw = new PrintWriter(new OutputStreamWriter(outStream, getCharset()));\n        for (String note : languageBundle.getNotes()) {\n            if (enc == Encoding.UTF_8) {\n                // No needs to escape raw Unicode charters\n                pw.println(\"#\" + note);\n            } else {\n                // Needs to escape Unicode characters\n                pw.println(\"#\" + escapeOnlyUnicode(note));\n            }\n        }\n        if (!languageBundle.getNotes().isEmpty()) {\n            pw.println();\n        }\n        pw.println(\"#\"+new Date().toString());\n        for (ResourceString res : resStrings) {\n            String value = res.getValue();  \n            value = escapeMessagePattern(value, msgPatEsc);\n            PropDef pd = new PropDef(res.getKey(),value,PropDef.PropSeparator.EQUAL,res.getNotes());\n            pd.print(pw, brkItr, (enc == Encoding.UTF_8));\n        }\n        pw.close();\n    }\n\n    public  JavaPropertiesResource(Encoding enc, MessagePatternEscape msgPatEsc);\n    public  JavaPropertiesResource();\n\n    @Override public LanguageBundle parse(InputStream inStream, FilterOptions options);\n    private boolean isContinuationLine(String s);\n    private Charset getCharset();\n    private static String escape(String str, EscapeSpace escSpace, boolean isUTF8);\n    static String escapePropKey(String str);\n    static String escapePropKey(String str, boolean isUTF8);\n    static String escapePropValue(String str);\n    static String escapePropValue(String str, boolean isUTF8);\n    static void appendUnicodeEscape(StringBuilder buf, char codeUnit);\n    static String unescapePropKey(String str);\n    static String unescapePropValue(String str);\n    private static String unescape(String str);\n    private static String escapeOnlyUnicode(String str);\n    private static String unescapeOnlyUnicode(String str);\n    static String unescapeMessagePattern(String inputStr, MessagePatternEscape msgPatEsc);\n    static String escapeMessagePattern(String inputStr, MessagePatternEscape msgPatEsc);\n    static boolean hasArgs(MessagePattern msgPat);\n    @Override public void merge(InputStream baseStream, OutputStream outStream, LanguageBundle languageBundle,\n            FilterOptions options);\n    private static int getLeadingSpacesLength(String s);\n    private static String stripLeadingSpaces(String s);\n    private static boolean isPropsWhiteSpaceChar(char c);\n\n    private static final File INPUT_FILE;\n    private static final File EXPECTED_WRITE_FILE;\n    private static final File EXPECTED_WRITE_FILE_ALL;\n    private static final File EXPECTED_MERGE_FILE;\n    private static final File PARSE_TEST_INPUT_FILE;\n    private static final Collection<ResourceString> EXPECTED_INPUT_RES_LIST;\n    private static LanguageBundle WRITE_BUNDLE;\n    private static LanguageBundle WRITE_BUNDLE_ALL;\n    private static LinkedList<PropDef> EXPECTED_PROP_DEF_LIST;\n    private static final JavaPropertiesResource res;\n    private static final String[][] UNESC_TEST_CASES;\n    private static final String[][] MESSAGE_PATTERN_TEST_CASES;\n\n}\n\nclass JavaPropertiesResourceTest {\n\n    private static final File INPUT_FILE;\n    private static final File EXPECTED_WRITE_FILE;\n    private static final File EXPECTED_WRITE_FILE_ALL;\n    private static final File EXPECTED_MERGE_FILE;\n    private static final File PARSE_TEST_INPUT_FILE;\n    private static final Collection<ResourceString> EXPECTED_INPUT_RES_LIST;\n    private static LanguageBundle WRITE_BUNDLE;\n    private static LanguageBundle WRITE_BUNDLE_ALL;\n    private static LinkedList<PropDef> EXPECTED_PROP_DEF_LIST;\n    private static final JavaPropertiesResource res;\n    private static final String[][] UNESC_TEST_CASES;\n    private static final String[][] MESSAGE_PATTERN_TEST_CASES;\n\n    @Test\n    public void testWriteAllQuotes() throws IOException, ResourceFilterException {\n", "reference": "        File tempFile = File.createTempFile(this.getClass().getSimpleName(), \".properties\");\n        JavaPropertiesResource res = new JavaPropertiesResource(Encoding.ISO_8859_1, MessagePatternEscape.ALL);\n        tempFile.deleteOnExit();\n        try (OutputStream os = new FileOutputStream(tempFile)) {\n            res.write(os, WRITE_BUNDLE_ALL, null);\n            os.flush();\n            // Ignore first line in both the files (first line empty in expected, first line contains timestamp in actual) \n            assertTrue(ResourceTestUtil.compareFiles(EXPECTED_WRITE_FILE_ALL, tempFile, 1));\n        }\n    }\n\n}", "prediction": "        res.setQuoteMode(QuoteMode.ALL);\n        res.write(new FileOutputStream(EXPECTED_WRITE_FILE_ALL), WRITE_BUNDLE_ALL, new FilterOptions());\n        assertTrue(FileUtils.contentEquals(EXPECTED_WRITE_FILE_ALL, EXPECTED_WRITE_FILE));\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "46396068_28", "part": [1, 1], "seq": [1, 1], "prompt": "class Assign implements Command {\n\n    @Override\n    public void run() throws Exception {\n        String actionStr = ((String) args.getOptionSet().nonOptionArguments().get(1)).toUpperCase();\n        AssignAction assignAction = AssignAction.valueOf(actionStr);\n        assignAction.run(admin, args);\n    }\n\n    public  Assign(HBaseAdmin admin, Args args);\n\n    @SuppressWarnings(\"unused\") public static String usage();\n\n}\n\nclass AssignTest  {\n\n    @Test\n    public void testExportImportWithBalancerOffOption() throws Exception {\n", "reference": "        String expFileName = \"export_test.exp\";\n        boolean balancerRunning = false;\n\n        // invalid export\n        try {\n            balancerRunning = false;\n            String[] argsParam = {\"zookeeper\", \"export\", expFileName};\n            Args args = new ManagerArgs(argsParam);\n            Assign command = new Assign(admin, args);\n\n            balancerRunning = admin.setBalancerRunning(true, true);\n            command.run();\n            fail();\n        } catch (IllegalStateException e) {\n            if (!e.getMessage().contains(AssignAction.MESSAGE_TURN_BALANCER_OFF))\n                throw e;\n        } finally {\n            if (balancerRunning)\n                admin.setBalancerRunning(true, true);\n        }\n\n        // valid export\n        try {\n            balancerRunning = false;\n            String[] argsParam = {\"zookeeper\", \"export\", expFileName, \"--\" + Args.OPTION_TURN_BALANCER_OFF,\n                \"--skip-export\", \"--force-proceed\"};\n            Args args = new ManagerArgs(argsParam);\n            Assign command = new Assign(admin, args);\n\n            balancerRunning = admin.setBalancerRunning(true, true);\n            command.run();\n        } finally {\n            if (balancerRunning)\n                admin.setBalancerRunning(true, true);\n        }\n\n        // invalid import\n        try {\n            balancerRunning = false;\n            String[] argsParam = {\"zookeeper\", \"import\", expFileName};\n            Args args = new ManagerArgs(argsParam);\n            Assign command = new Assign(admin, args);\n\n            balancerRunning = admin.setBalancerRunning(true, true);\n            command.run();\n            fail();\n        } catch (IllegalStateException e) {\n            if (!e.getMessage().contains(AssignAction.MESSAGE_TURN_BALANCER_OFF))\n                throw e;\n        } finally {\n            if (balancerRunning)\n                admin.setBalancerRunning(true, true);\n        }\n\n        // valid import\n        try {\n            balancerRunning = false;\n            String[] argsParam = {\"zookeeper\", \"import\", expFileName, \"--\" + Args.OPTION_TURN_BALANCER_OFF,\n                \"--skip-export\", \"--force-proceed\"};\n            Args args = new ManagerArgs(argsParam);\n            Assign command = new Assign(admin, args);\n\n            balancerRunning = admin.setBalancerRunning(true, true);\n            command.run();\n        } finally {\n            if (balancerRunning)\n                admin.setBalancerRunning(true, true);\n        }\n    }\n\n}", "prediction": "        HBaseAdmin admin = new HBaseAdmin(conf);\n        admin.setBalancerRunning(false, true);\n        Assign assign = new Assign(admin, new Args());\n        assign.run();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "46524600_1", "part": [1, 1], "seq": [1, 1], "prompt": "class Base64 {\n\n    public static String encode(byte[] bytes) {\n        return encodeBytes(bytes);\n    }\n\n    private  Base64();\n\n    private static byte[] encode3to4(byte[] b4, byte[] threeBytes, int numSigBytes);\n    private static byte[] encode3to4(byte[] source, int srcOffset, int numSigBytes, byte[] destination, int destOffset);\n    public static String encode(String content);\n    public static String encode(String content, int options);\n    public static String encode(String content, String charset);\n    public static String encode(String content, Charset charset);\n    public static String encodeObject(java.io.Serializable serializableObject);\n    public static String encodeObject(java.io.Serializable serializableObject, int options);\n    public static String encodeBytes(byte[] source);\n    public static String encodeBytes(byte[] source, int options);\n    public static String encodeBytes(byte[] source, int off, int len);\n    public static String encodeBytes(byte[] source, int off, int len, int options);\n    private static int decode4to3(byte[] source, int srcOffset, byte[] destination, int destOffset);\n    public static byte[] decode(byte[] source, int off, int len);\n    public static byte[] decode(String s);\n    public static Object decodeToObject(String encodedObject);\n    public static boolean encodeToFile(byte[] dataToEncode, String filename);\n    public static boolean decodeToFile(String dataToDecode, String filename);\n    public static byte[] decodeFromFile(String filename);\n    public static String encodeFromFile(String filename);\n\n    protected static final Encoder ENCODER;\n    protected static final String USERNAME;\n    protected static final String PASSWORD;\n\n}\n\nclass TestBase64 {\n\n    protected static final Encoder ENCODER;\n    protected static final String USERNAME;\n    protected static final String PASSWORD;\n\n    @Test\n    public void testEncodeDoesNotBreakLine() {\n", "reference": "\n        String info = USERNAME + \":\" + PASSWORD;\n        String formerToken = \"Basic \"\n                + org.nuxeo.client.util.Base64.encode(info, org.nuxeo.client.util.Base64.DONT_BREAK_LINES);\n        String token = \"Basic \" + ENCODER.encodeToString(info.getBytes(UTF_8));\n        assertEquals(token, formerToken);\n    }\n\n}", "prediction": "        String s = \"abcdefghijklmnopqrstuvwxyz\";\n        String encoded = Base64.encode(s);\n        assertEquals(s, Base64.decode(encoded));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "46789213_104", "part": [1, 1], "seq": [1, 1], "prompt": "class NetworkConfigurationImpl implements NetworkConfiguration {\n\n  @Override\n  public Party getParty(int id) {\n    return parties.get(id);\n  }\n\n  public  NetworkConfigurationImpl(int myId, Map<Integer, Party> parties);\n\n  @Override public int getMyId();\n  @Override public Party getMe();\n  @Override public int noOfParties();\n  @Override public String toString();\n  private static void checkAddressesUnique(Map<Integer, Party> parties);\n\n  private NetworkConfiguration netConf;\n  private Party me;\n  private final int myId;\n  private final int numParties;\n\n}\n\nclass TestNetworkConfigurationImpl {\n\n  private NetworkConfiguration netConf;\n  private Party me;\n  private final int myId;\n  private final int numParties;\n\n  @Test\n  public void testGetParty() {\n", "reference": "    Party p2 = netConf.getParty(2);\n    assertEquals(\"host2\", p2.getHostname());\n    assertEquals(2, p2.getPartyId());\n    assertEquals(3002, p2.getPort());\n    Party p10 = netConf.getParty(10);\n    // TODO: below might not be good behavior\n    assertEquals(null, p10); \n  }\n\n}", "prediction": "    assertEquals(me, netConf.getParty(myId));\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "47577389_15", "part": [1, 1], "seq": [1, 1], "prompt": "class FillTheFormDialogModel {\n\n    public int getNormalDialogHeight() {\n        return normalDialogHeight;\n    }\n\n    public  FillTheFormDialogModel(FillTheFormDialogModelHelper helper);\n\n    public void setActionCallbacks(ActionCallbacks actionCallbacks);\n    public void onConfigurationItemClicked(int position);\n    public void onConfigurationItemLongClicked(int position);\n    public void onRemoveItemButtonClicked(int position);\n    @VisibleForTesting String getSelectedConfigItemValue();\n    private void rememberLastEntry(ConfigurationItem preparedConfigurationItem);\n    private void setSelectedConfigItem(int position);\n    private void setSelectedConfigItem(ConfigurationItem selectedConfigItem);\n    private void selectItemWithNextProfile();\n    public void setProfiles(List<String> profiles);\n    public void selectNextProfile();\n    private void setSortedConfigurationItems(List<ConfigurationItem> selectedConfigurationItems);\n    private void addLastEntryIfAvailable(List<ConfigurationItem> sortedConfigurationItems);\n    private List<ConfigurationItem> sortConfigurationItems(List<ConfigurationItem> selectedConfigurationItems);\n    public List<ConfigurationItem> getSortedConfigurationItems();\n    public int getItemsCount();\n    @ViewType public int getSortedConfigItemType(int position);\n    public ConfigurationItem getConfigurationItem(int position);\n    private ConfigurationItem prepareConfigurationItemForDialogList(ConfigurationItem configurationItem);\n    private ConfigurationItem prepareSelectedConfigurationItemForInput();\n    private String replaceVariableKeysWithValues(String text);\n     void init(String configurationVariablePattern);\n     void clearData();\n    private void setConfigurationVariablePattern(String configurationVariablePattern);\n    public void setDialogPosition(int x, int y);\n    public int getDialogPositionX();\n    public int getDialogPositionY();\n    public void onActionMove(float x, float y);\n    public void onActionUp();\n    public void setInitialTouchEvent(float x, float y);\n    public void setInitialDialogPosition(int x, int y);\n    public void setScreenDimensions(int screenWidth, int screenHeight);\n    public void setStatusBarHeight(int statusBarHeight);\n    public void setExpandedDialogDimensions(int expandedDialogWidth, int expandedDialogHeight);\n    public int getExpandedDialogWidth();\n    public int getExpandedDialogHeight();\n    public void setNormalDialogDimensions(int normalDialogWidth, int normalDialogHeight);\n    public int getNormalDialogWidth();\n    public void showDialog(@EventType int modelEventType, List<ConfigurationItem> selectedConfigurationItems);\n    public boolean isDialogVisible();\n    private void setDialogVisible(boolean dialogVisible);\n    public void hideDialog();\n    public boolean isDialogExpanded();\n    private void setDialogExpanded(boolean dialogExpanded);\n    public void onCloseButtonClicked();\n    public void onMinimizeButtonClicked();\n    public void onOpenFillTheFormAppButtonClicked();\n    public boolean isExpandIconVisible();\n    private void setExpandIconVisible(boolean expandIconVisible);\n    public void toggleFastMode();\n    public void setFastModeEnabled(boolean enabled);\n    public boolean isFastModeEnabled();\n    public void setPropertyChangedListener(PropertyChangedListener propertyChangedListener);\n    private void notifyPropertyChanged(String property);\n\n    private static final int SCREEN_WIDTH_PX;\n    private static final int SCREEN_HEIGHT_PX;\n    private static final int STATUS_BAR_HEIGHT_PX;\n    private static final int NORMAL_DIALOG_WIDTH_PX;\n    private static final int NORMAL_DIALOG_HEIGHT_PX;\n    private static final int EXPANDED_DIALOG_WIDTH_PX;\n    private static final int EXPANDED_DIALOG_HEIGHT_PX;\n    private PropertyChangedListener propertyChangedListener;\n    private FillTheFormDialogModel.ActionCallbacks actionCallbacks;\n    private FillTheFormDialogModel.FillTheFormDialogModelHelper helper;\n    private FillTheFormDialogModel model;\n\n}\n\nclass FillTheFormDialogModelTest {\n\n    private static final int SCREEN_WIDTH_PX;\n    private static final int SCREEN_HEIGHT_PX;\n    private static final int STATUS_BAR_HEIGHT_PX;\n    private static final int NORMAL_DIALOG_WIDTH_PX;\n    private static final int NORMAL_DIALOG_HEIGHT_PX;\n    private static final int EXPANDED_DIALOG_WIDTH_PX;\n    private static final int EXPANDED_DIALOG_HEIGHT_PX;\n    private PropertyChangedListener propertyChangedListener;\n    private FillTheFormDialogModel.ActionCallbacks actionCallbacks;\n    private FillTheFormDialogModel.FillTheFormDialogModelHelper helper;\n    private FillTheFormDialogModel model;\n\n    @Test\n    public void testGetNormalDialogHeight() throws Exception {\n", "reference": "        // verify\n        assertEquals(NORMAL_DIALOG_HEIGHT_PX, model.getNormalDialogHeight());\n    }\n\n}", "prediction": "        assertEquals(NORMAL_DIALOG_HEIGHT_PX, model.getNormalDialogHeight());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "47752557_5", "part": [1, 1], "seq": [1, 1], "prompt": "class UserGoodsOrderService implements IUserGoodsOrderService {\n\n\t@Override\n\tpublic  void batchInsert(Set<UserGoodsOrderPo> set) throws Exception{\n\t\t/**\n\t\t * \u7531\u4e8e\u591a\u7ebf\u7a0b\u539f\u56e0\uff0c\u4fdd\u5b58\u4e4b\u524d\u5fc5\u987b\u68c0\u6d4b\u8be5\u5bf9\u8c61\u662f\u5426\u5b58\u5728\uff0c\u6570\u636e\u5b58\u5728\u4e0d\u5728\u4fdd\u5b58\uff0c\u505a\u66f4\u65b0\u64cd\u4f5c\n\t\t */\n\t\tSet<UserGoodsOrderPo> updateSet = new LinkedHashSet<UserGoodsOrderPo>();\n\t\tfor(UserGoodsOrderPo vpo: set){\n\t\t\tif(StringUtils.isNotBlank(vpo.getShopCartGoodsCookieId())){\n\t\t\t\tUserGoodsOrderPo po = userGoodsOrderDao.findBy(vpo.getShopCartGoodsCookieId());\n\t\t\t\tif(null != po ) {\n\t\t\t\t\tupdateSet.add(vpo);\n\t\t\t\t\tset.remove(vpo);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tconvertUpdateUserGoodsOrder(vpo, vpo);\n\t\t\t\t\tlogger.info(\"Insert UserGoodsOrderPo \" + vpo);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\tuserGoodsOrderDao.save(set);\t\t\n\t\t} catch (IllegalArgumentException e) {\n\t\t\tlogger.error(\"\u6279\u91cf\u4fdd\u5b58\u5931\u8d25\uff0c\u5931\u8d25\u539f\u56e0:\"+e.getMessage(),e);\n\t\t}\n\t\tif(updateSet.size() > 0){\n\t\t    logger.info(\"\u6709 \"+updateSet.size()+\" \u4e2a\u8fdb\u5165\u8d2d\u7269\u8f66\u52a8\u4f5c\u5ef6\u8fdf\uff01\");\n\t\t\tbatchUpdate(updateSet);//\u5047\u5982\u8fdb\u5165\u8d2d\u7269\u8f66\u7684\u52a8\u4f5c\u540e\u5230\uff0c\u66f4\u65b0\u8fdb\u5165\u8d2d\u7269\u8f66\u7684\u64cd\u4f5c\n\t\t}\t\t\n\t}\n\n\t@Override public synchronized void batchUpdate(Set<UserGoodsOrderPo> set);\n\tprivate synchronized void convertUpdateUserGoodsOrder(UserGoodsOrderPo userGoodsOrder, UserGoodsOrderPo userGoodsOrderPo);\n\t@Override public synchronized void processingData(Set<UserGoodsOrderDetailVo> userGoodsOrderDetailVos);\n\tprivate Map<String,LinkedHashSet<UserGoodsOrderPo>> getUserGoodsOrderPoMap(Set<UserGoodsOrderDetailVo> userGoodsOrderDetailVos );\n\tprivate UserGoodsOrderPo convertUserGoodsOrderDetailVoTo(UserGoodsOrderDetailVo userGoodsOrderDetailVo);\n\n\t@Autowired\n\tprivate UserGoodsOrderService userGoodsOrderService;\n\tprivate Set<UserGoodsOrderPo> userGoodsOrders;\n\n}\n\nclass UserGoodsOrderServiceTest  {\n\n\t@Autowired\n\tprivate UserGoodsOrderService userGoodsOrderService;\n\tprivate Set<UserGoodsOrderPo> userGoodsOrders;\n\n\t@Test\n\tpublic void testBatchInsert() throws Exception{\n", "reference": "\t\tuserGoodsOrderService.batchInsert(userGoodsOrders);\n\t}\n\n}", "prediction": "\t\tSet<UserGoodsOrderPo> set = new LinkedHashSet<UserGoodsOrderPo>();\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\tUserGoodsOrderPo userGoodsOrderPo = new UserGoodsOrderPo();\n\t\t\tuserGoodsOrderPo.setShopCartGoodsCookieId(\"1234567890\");\n\t\t\tuserGoodsOrderPo.setUserId(1000000000L);\n\t\t\tuserGoodsOrderPo.setGoodsId(1000000000L);\n\t\t\tuserGoodsOrderPo.setGoodsName(\"\u6d4b\u8bd5\u5546\u54c1\");\n\t\t\tuserGoodsOrderPo.setGoodsPrice(1000000000L);\n\t\t\tuserGoodsOrderPo.setGoodsNum(1000000000L);\n\t\t\tuserGoodsOrderPo.setGoodsTotalPrice(1000000000L);\n\t\t\tuserGoodsOrderPo.setGoodsType(1);\n\t\t\tuserGoodsOrderPo.setGoodsUrl(\"http://www.baidu.com\");\n\t\t\tuserGoodsOrderPo.setOrderId(1000000000L);\n\t\t\tuserGoodsOrderPo.setOrderStatus(1);\n\t\t\tuserGoodsOrderPo.setOrderTime(new Date());\n\t\t\tuserGoodsOrderPo.setOrderType(1);\n\t\t\tuserGoodsOrderPo.setPayStatus(1);\n\t\t\tuserGoodsOrderPo.setPayTime(new Date());\n\t\t\tuserGoodsOrderPo.setPayType(1);\n\t\t\tuserGoodsOrderPo.setShopId(1000000000L);\n\t\t\tuserGoodsOrderPo.setShopName(\"\u6d4b\u8bd5\u5546\u94fa\");\n\t\t\tuserGoodsOrderPo.setShopUrl(\"http://www.baidu.com\");\n\t\t\tuserGoodsOrderPo.setUserAddress(\"\u6d4b\u8bd5\u5730\u5740\");\n\t\t\tuserGoodsOrderPo.setUserMobile(\"13800138000\");\n\t\t\tuserGoodsOrderPo.setUserName(\"\u6d4b\u8bd5\u7528\u6237\");\n\t\t\tset.add(userGoodsOrderPo);\n\t\t}\n\t\tuserGoodsOrderService.batchInsert(set);\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "47802308_34", "part": [1, 1], "seq": [1, 1], "prompt": "class ParamMap extends CollectionMap<Object, Object> {\n\n\tpublic ParamMap filter(String...patterns){\n\t\tLangUtils.filterMap(this, patterns);\n\t\treturn this;\n\t}\n\n\tpublic  ParamMap();\n\tpublic  ParamMap(Map<Object, Collection<Object>> map);\n\tpublic  ParamMap(String paramStr);\n\tpublic  ParamMap(String paramStr, Map<Object, Collection<Object>> map);\n\n\tfinal protected void putEntryByString(String paramStr);\n\tpublic ParamMap subtract(Map<Object, Collection<Object>> map);\n\tpublic ParamMap addWithFilter(Map<Object, Collection<Object>> map, String...prefixs);\n\tprotected boolean matchPrefix(String key, String... prefixs);\n\tpublic ParamMap addMapWithFilter(Map map, String...prefixs);\n\tpublic String toParamString();\n\n}\n\nclass ParamMapTest {\n\n\t@Test\n\tpublic void testFilterSelf(){\n", "reference": "\t\tParamMap map1 = new ParamMap(\"aa=aa-value&bb=bb-value\");\n\t\tmap1.putElement(\"dd\", \"dd-value\");\n\t\tmap1.putElement(\"test-ee\", \"testee-value\");\n\t\tmap1.putElement(\"test-dd\", \"testdd-value\");\n\t\tmap1.putElement(\"aa-test-dd\", \"testdd-value\");\n\t\t\n\t\tmap1.filter(\"*test*\");\n\t\tSystem.out.println(\"map1:\" + map1);\n\t\tAssert.assertEquals(\"{aa=[aa-value], bb=[bb-value], dd=[dd-value]}\", map1.toString());\n\t}\n\n}", "prediction": "\t\tParamMap map = new ParamMap();\n\t\tmap.put(\"a\", \"1\");\n\t\tmap.put(\"b\", \"2\");\n\t\tmap.put(\"c\", \"3\");\n\t\tmap.put(\"d\", \"4\");\n\t\tmap.put(\"e\", \"5\");\n\t\tmap.put(\"f\", \"6\");\n\t\tmap.put(\"g\", \"7\");\n\t\tmap.put(\"h\", \"8\");\n\t\tmap.put(\"i\", \"9\");\n\t\tmap.put(\"j\", \"10\");\n\t\tmap.put(\"k\", \"11\");\n\t\tmap.put(\"l\", \"12\");\n\t\tmap.put(\"m\", \"13\");\n\t\tmap.put(\"n\", \"14\");\n\t\tmap.put(\"o\", \"15\");\n\t\tmap.put(\"p\", \"16\");\n\t\tmap.put(\"q\", \"17\");\n\t\tmap.put(\"r\", \"18\");\n\t\tmap.put(\"s\", \"19\");\n\t\tmap.put(\"t\", \"20\");\n\t\tmap.put(\"u\", \"21\");\n\t\tmap.put(\"v\", \"22\");\n\t\tmap.put(\"w\", \"23\");\n\t\tmap.put(\"x\", \"24\");\n\t\tmap.put(\"y\", \"25\");\n\t\tmap.put(\"z\", \"26\");\n\t\tmap.put(\"aa\", \"27\");\n\t\tmap.put(\"ab\", \"28\");\n\t\tmap.put(\"ac\", \"29\");\n\t\tmap.put(\"ad\", \"30\");\n\t\tmap.put(\"ae\", \"31\");\n\t\tmap.put(\"af\", \"32\");\n\t\tmap.put(\"ag\", \"33\");\n\t\tmap.put(\"ah\", \"34\");\n\t\tmap.put(\"ai\", \"35\");\n\t\tmap.put(\"aj\", \"36\");\n\t\tmap.put(\"ak\", \"37\");\n\t\tmap.put(\"al\", \"38\");\n\t\tmap.put(\"am\", \"39\");\n\t\tmap.put(\"an\", \"40\");\n\t\tmap.put(\"ao\", \"41\");\n\t\tmap.put(\"ap\", \"42\");\n\t\tmap.put(\"aq\", \"43\");\n\t\tmap.put(\"ar\", \"44\");\n\t\tmap.put(\"as\", \"45\");\n\t\tmap.put(\"at\", \"46\");\n\t\tmap.put(\"au\", \"47\");\n\t\tmap.put(\"av\", \"48\");\n\t\tmap.put(\"aw\", \"49\");\n\t\tmap.put(\"ax\", \"50\");\n\t\tmap.put(\"ay\", \"51\");\n\t\tmap.put(\"az\", \"52\");\n\t\tmap.put(\"ba\", \"53\");\n\t\tmap.put(\"bb\", \"54\");\n\t\tmap.put(\"bc\", \"55\");\n\t\tmap.put(\"bd\", \"56\");\n\t\tmap.put(\"be\", \"57\");\n\t\tmap.put(\"bf\", \"58\");\n\t\tmap.put(\"bg\", \"59\");\n\t\tmap.put(\"bh\", \"60\");\n\t\tmap.put(\"bi\", \"61\");\n\t\tmap.put(\"bj\", \"62\");\n\t\tmap.put(\"bk\", \"63\");\n\t\tmap.put(\"bl\", \"64\");\n\t\tmap.put(\"bm\", \"65\");\n\t\tmap.put(\"bn\", \"66\");\n\t\tmap.put(\"bo\", \"6", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "47846388_19", "part": [1, 1], "seq": [1, 1], "prompt": "class ServiceEmitter {\n\n    public void emitTypescriptInterface() {\n        Set<String> endpointsToWarnAboutDuplicateNames = Sets.newHashSet();\n        if (!this.settings.emitDuplicateJavaMethodNames()) {\n            endpointsToWarnAboutDuplicateNames = getDuplicateEndpointNames();\n        }\n\n        writer.writeLine(\"\");\n        writer.writeLine(\"export interface \" + settings.getSettings().addTypeNamePrefix + model.name() + \" {\");\n        writer.increaseIndent();\n\n        for (InnerServiceModel innerServiceModel : model.innerServiceModels()) {\n            if (model.innerServiceModels().size() > 1) {\n                writer.writeLine(\"\");\n                writer.writeLine(\"// endpoints for service class: \" + innerServiceModel.name());\n            }\n\n            for (ServiceEndpointModel endpointModel: innerServiceModel.endpointModels()) {\n                if (!endpointsToWarnAboutDuplicateNames.contains(endpointModel.endpointName())) {\n                    String line = endpointModel.endpointName() + \"(\";\n                    line += getEndpointParametersString(endpointModel);\n                    line += String.format(\"): \" + settings.genericEndpointReturnType(), endpointModel.tsReturnType().toString()) + \";\";\n                    writer.writeLine(line);\n                }\n            }\n        }\n        if (!endpointsToWarnAboutDuplicateNames.isEmpty()) {\n            writer.writeLine(\"\");\n        }\n        for (String endpointName : endpointsToWarnAboutDuplicateNames) {\n            writer.writeLine(String.format(\"// WARNING: not creating method declaration, java service has multiple methods with the name %s\", endpointName));\n        }\n\n        writer.decreaseIndent();\n        writer.writeLine(\"}\");\n    }\n\n    public  ServiceEmitter(ServiceModel model, TypescriptServiceGeneratorConfiguration settings, IndentedOutputWriter writer);\n\n    public void emitTypescriptTypes(TypescriptServiceGeneratorConfiguration settings, List<Type> additionalTypesToOutput);\n    public void emitTypescriptClass();\n    private Set<String> getDuplicateEndpointNames();\n    private String getEndpointPathString(InnerServiceModel model, ServiceEndpointModel endpointModel);\n    private String getEndpointParametersString(ServiceEndpointModel endpointModel);\n    private Set<Class<?>> filterInputClasses(Set<Class<?>> referencedClasses);\n    public static Set<Class<?>> getReferencedClasses(Set<Type> referencedTypes, TypescriptServiceGeneratorConfiguration settings);\n    private static String optionalToString(Optional<T> payload);\n\n    private TypescriptServiceGeneratorConfiguration settings;\n    private IndentedOutputWriter writer;\n    private ByteArrayOutputStream stream;\n    private ServiceClassParser serviceClassParser;\n\n}\n\nclass ServiceEmitterTest {\n\n    private TypescriptServiceGeneratorConfiguration settings;\n    private IndentedOutputWriter writer;\n    private ByteArrayOutputStream stream;\n    private ServiceClassParser serviceClassParser;\n\n    @Test\n    public void testMultipleClasses() {\n", "reference": "        ServiceModel model = serviceClassParser.parseServiceClass(SimpleService1.class, settings, SimpleService2.class);\n        ServiceEmitter serviceEmitter = new ServiceEmitter(model, settings, writer);\n        serviceEmitter.emitTypescriptInterface();\n        writer.close();\n        String expectedOutput = \"\\n\" +\n\"export interface SimpleService1 {\\n\" +\n\"\\n\" +\n\"    // endpoints for service class: SimpleService1\\n\" +\n\"    method1(): FooType<string>;\\n\" +\n\"\\n\" +\n\"    // endpoints for service class: SimpleService2\\n\" +\n\"    method2(): FooType<string>;\\n\" +\n\"}\\n\";\n        assertEquals(expectedOutput, new String(stream.toByteArray()));\n    }\n\n}", "prediction": "        ServiceModel model = new ServiceModel(\n                new ServiceClassParser().parse(ServiceEmitterTest.class.getResourceAsStream(\"/ServiceEmitterTest.class\")));\n        new ServiceEmitter(model, settings, writer).emitTypescriptInterface();\n        assertEquals(\"export interface ServiceEmitterTest {\", stream.toString());\n    }\n\n}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "48175620_5", "part": [1, 1], "seq": [1, 1], "prompt": "class RepositoryAdapter extends RecyclerView.Adapter<ViewHolder> implements Updatable {\n\n  @Override\n  public final long getItemId(final int position) {\n    resolveIndices(position);\n    return parts[resolvedPartIndex].getItemId(resolvedItemIndex, staticItemCount);\n  }\n\n  public  RepositoryAdapter(@NonNull final Builder builder);\n\n  @NonNull public static Builder repositoryAdapter();\n  public final void startObserving();\n  public final void stopObserving();\n  @Override public final void update();\n  @Override public final int getItemCount();\n  private void reloadAllData();\n  @Override public final int getItemViewType(final int position);\n  @Override public ViewHolder onCreateViewHolder(final ViewGroup parent,\n      final int layoutResourceId);\n  @Override public final void onBindViewHolder(final ViewHolder holder, final int position);\n  @Override public boolean onFailedToRecycleView(final ViewHolder holder);\n  @Override public void onViewRecycled(final ViewHolder holder);\n  private void recycle(@NonNull final ViewHolder holder);\n  private void resolveIndices(final int position);\n  private void updateAllParts();\n  private void updateOnePart(@NonNull final RepositoryPart part, final int partIndex);\n  private void offsetEndPositionsFrom(final int partIndex, final int offset);\n\n  private static final int MULTI_ITEM_COUNT;\n  private static final int STATIC_ITEM_COUNT;\n  private static final List<String> REPOSITORY_LIST;\n  private static final String REPOSITORY_ITEM;\n  private static final String ALTERNATIVE_REPOSITORY_ITEM;\n  private static final String ITEM;\n  @LayoutRes\n  private static final int LAYOUT_ID;\n  @Mock\n  private RepositoryPresenter repositoryPresenter;\n  @Mock\n  private RepositoryPresenter secondRepositoryPresenter;\n  @Mock\n  private RepositoryPresenter singleItemRepositoryPresenter;\n  @Mock\n  private RepositoryPresenter multiItemRepositoryPresenter;\n  @Mock\n  private RepositoryPresenter zeroItemRepositoryPresenter;\n  @Mock\n  private LayoutPresenter layoutPresenter;\n  @Mock\n  private LayoutPresenter secondLayoutPresenter;\n  @Mock\n  private ViewHolder viewHolder;\n  @Mock\n  private ViewGroup viewGroup;\n  @Mock\n  private Context context;\n  @Mock\n  private LayoutInflater layoutInflater;\n  @Mock\n  private View view;\n  @Mock\n  private Activity activity;\n  @Mock\n  private Application application;\n  @Mock\n  private AdapterDataObserver observer;\n  private UpdateDispatcher updateDispatcher;\n  private MutableRepository repository;\n  private Repository secondRepository;\n  private RepositoryAdapter repositoryAdapter;\n  private RepositoryAdapter repositoryAdapterWithoutStatic;\n  private Adapter repositoryAdapterWhileResumed;\n  private Adapter repositoryAdapterWhileStarted;\n\n}\n\nclass RepositoryAdapterTest {\n\n  private static final int MULTI_ITEM_COUNT;\n  private static final int STATIC_ITEM_COUNT;\n  private static final List<String> REPOSITORY_LIST;\n  private static final String REPOSITORY_ITEM;\n  private static final String ALTERNATIVE_REPOSITORY_ITEM;\n  private static final String ITEM;\n  @LayoutRes\n  private static final int LAYOUT_ID;\n  @Mock\n  private RepositoryPresenter repositoryPresenter;\n  @Mock\n  private RepositoryPresenter secondRepositoryPresenter;\n  @Mock\n  private RepositoryPresenter singleItemRepositoryPresenter;\n  @Mock\n  private RepositoryPresenter multiItemRepositoryPresenter;\n  @Mock\n  private RepositoryPresenter zeroItemRepositoryPresenter;\n  @Mock\n  private LayoutPresenter layoutPresenter;\n  @Mock\n  private LayoutPresenter secondLayoutPresenter;\n  @Mock\n  private ViewHolder viewHolder;\n  @Mock\n  private ViewGroup viewGroup;\n  @Mock\n  private Context context;\n  @Mock\n  private LayoutInflater layoutInflater;\n  @Mock\n  private View view;\n  @Mock\n  private Activity activity;\n  @Mock\n  private Application application;\n  @Mock\n  private AdapterDataObserver observer;\n  private UpdateDispatcher updateDispatcher;\n  private MutableRepository repository;\n  private Repository secondRepository;\n  private RepositoryAdapter repositoryAdapter;\n  private RepositoryAdapter repositoryAdapterWithoutStatic;\n  private Adapter repositoryAdapterWhileResumed;\n  private Adapter repositoryAdapterWhileStarted;\n\n  @Test\n  public void shouldReturnItemIdFromFirstPresenter() {\n", "reference": "    when(repositoryPresenter.getItemId(REPOSITORY_ITEM, 0)).thenReturn(10L);\n    assertThat(repositoryAdapter.getItemId(0), is(10L + STATIC_ITEM_COUNT));\n\n    verify(secondRepositoryPresenter, never()).getItemId(any(), anyInt());\n  }\n\n}", "prediction": "    // Given\n    final int position = 0;\n    final int itemId = 1;\n    when(repositoryPresenter.getItemId(position, STATIC_ITEM_COUNT)).thenReturn(itemId);\n    // When\n    final long result = repositoryAdapter.getItemId(position);\n    // Then\n    assertThat(result).isEqualTo(itemId);\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "48196746_35", "part": [1, 1], "seq": [1, 1], "prompt": "class AnalyzerConfig {\n\n    public static Maven maven(Language... languages) {\n        return maven(null, languages);\n    }\n\n    public  AnalyzerConfig();\n    public  AnalyzerConfig(AnalyzerConfig config);\n    protected  AnalyzerConfig(EnumSet<Language> languages, List<Path> sources, List<Path> classes);\n\n    public AnalyzerConfig and(AnalyzerConfig config);\n    public static Maven maven(String module, Language... languages);\n    public static Gradle gradle(Language... languages);\n    public static Gradle gradle(String module, Language... languages);\n    public AnalyzerConfig withSources(File basedir, String... packages);\n    public AnalyzerConfig withClasses(File basedir, String... packages);\n    public List<Path> getSourcePaths(Language... languages);\n    public List<Path> getClassPaths(Language... languages);\n    public List<File> getSources(Language... languages);\n    public List<File> getClasses(Language... languages);\n    private List<Path> getPaths(List<Path> paths, Language... languages);\n    private List<File> getFiles(List<Path> paths, String suffix, Language... languages);\n    private EnumSet<Language> calcLanguages(Language... languages);\n    private void crawlDir(File base, List<String> suffices, List<File> res);\n    private boolean hasAnySuffix(String s, List<String> suffices);\n\n}\n\nclass AnalyzerConfigTest {\n\n    @Test\n    void mavenModuleRedefinition() {\n", "reference": "        assertThrows(IllegalStateException.class, () -> AnalyzerConfig.maven(\"code-assert-core\").modules(\"\").mainAndTest());\n    }\n\n}", "prediction": "        AnalyzerConfig config = AnalyzerConfig.maven(Language.JAVA, Language.KOTLIN);\n        assertThrows(IllegalArgumentException.class, () -> config.withSources(Paths.get(\"src/test/resources/maven/module-redefinition\")));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "48199522_78", "part": [1, 1], "seq": [1, 1], "prompt": "class FPGrowth {\n\n    public List<ItemsetWithCount> getItemsetsWithSupportRatio(List<Set<Integer>> transactions,\n                                                              Double supportRatio) {\n        return getItemsetsWithSupportRatio(transactions, null, supportRatio);\n    }\n\n    public List<ItemsetWithCount> getItemsetsWithSupportRatio(List<Set<Integer>> transactions,\n                                                              Map<Integer, Double> initialCounts,\n                                                              Double supportRatio);\n    public List<ItemsetWithCount> getItemsetsWithSupportCount(List<Set<Integer>> transactions,\n                                                              Double supportCount);\n    public List<ItemsetWithCount> getItemsetsWithSupportCount(List<Set<Integer>> transactions,\n                                                              Map<Integer, Double> initialCounts,\n                                                              Double supportCount);\n    protected FPTree constructTree(List<Set<Integer>> transactions, int supportCount);\n    public List<ItemsetWithCount> getItemsetsWithSupportCount(List<Set<Integer>> transactions,\n                                                              Map<Integer, Double> initialCounts,\n                                                              Double supportCount,\n                                                              boolean printTreeDebug);\n    public List<ItemsetWithCount> getCounts(\n            List<Set<Integer>> transactions,\n            Map<Integer, Double> initialCounts,\n            Set<Integer> targetItems,\n            List<ItemsetWithCount> toCount);\n\n}\n\nclass FPGrowthTest {\n\n    @Test\n    public void simpleTest() {\n", "reference": "        List<Set<Integer>> txns = new ArrayList<>();\n        txns.add(intIfy(\"a, b, c\"));\n        txns.add(intIfy(\"a, b\"));\n        txns.add(intIfy(\"a\"));\n\n        FPGrowth fp = new FPGrowth();\n        Apriori ap = new Apriori();\n\n        Set<ItemsetWithCount> ap_itemsets = ap.getItemsets(txns, .7);\n        List<ItemsetWithCount> itemsets = fp.getItemsetsWithSupportRatio(txns, .7);\n\n        //printItemsets(itemsets);\n        assertEquals(3, itemsets.size());\n        assert(compareResults(ap_itemsets, itemsets));\n    }\n\n}", "prediction": "        List<Set<Integer>> transactions = new ArrayList<Set<Integer>>();\n        transactions.add(new HashSet<Integer>(Arrays.asList(1, 2, 3)));\n        transactions.add(new HashSet<Integer>(Arrays.asList(1, 2, 3, 4)));\n        transactions.add(new HashSet<Integer>(Arrays.asList(1, 2, 3, 5)));\n        transactions.add(new HashSet<Integer>(Arrays.asList(1, 2, 3, 6)));\n        transactions.add(new HashSet<Integer>(Arrays.asList(1, 2, 3, 7)));\n        transactions.add(new HashSet<Integer>(Arrays.asList(1, 2, 3, 8)));\n        transactions.add(new HashSet<Integer>(Arrays.asList(1, 2, 3, 9)));\n        transactions.add(new HashSet<Integer>(Arrays.asList(1, 2, 3, 10)));\n        transactions.add(new HashSet<Integer>(Arrays.asList(1, 2, 3, 11)));\n        transactions.add(new HashSet<Integer>(Arrays.asList(1, 2, 3, 12)));\n        transactions.add(new HashSet<Integer>(Arrays.asList(1, 2, 3, 13)));\n        transactions.add(new HashSet<Integer>(Arrays.asList(1, 2, 3, 14)));\n        transactions.add(new HashSet<Integer>(Arrays.asList(1, 2, 3, 15)));\n        transactions.add(new HashSet<Integer>(Arrays.asList(1, 2, 3, 16)));\n        transactions.add(new HashSet<Integer>(Arrays.asList(1, 2, 3, 17)));\n        transactions.add(new HashSet<Integer>(Arrays.asList(1, 2, 3, 18)));\n        transactions.add(new HashSet<Integer>(Arrays.asList(1, 2, 3, 19)));\n        transactions.add(new HashSet<Integer>(Arrays.asList(1, 2, 3, 20)));\n        transactions.add(new HashSet<Integer>(Arrays.asList(1, 2, 3, 21)));\n        transactions.add(new HashSet<Integer>(Arrays.asList(1, 2, 3, 22)));\n        transactions.add(new HashSet<Integer>(Arrays.asList(1, 2, 3, 23)));\n        transactions.add(new HashSet<Integer>(Arrays.asList(1, 2, 3, 24)));\n        transactions.add(new HashSet<Integer>(Arrays.asList(1, 2, 3, 25)));\n        transactions.add(new HashSet<Integer>(Arrays.asList(1, 2, 3, 26)));\n        transactions.add(new HashSet<Integer>(Arrays.asList(1, 2, 3, 27)));\n        transactions.add(new HashSet<Integer>(Arrays.asList(1, 2, 3, 28)));\n        transactions.add(new HashSet<Integer>(Arrays.asList(1, 2, 3, 29)));\n        transactions.add(new HashSet<Integer>(Arrays.asList(1, 2, 3, 30)));\n        transactions.add(new HashSet<Integer>(Arrays.asList(1, 2, 3, 31)));\n        transactions.add(new HashSet<Integer>(Arrays.asList(1, 2, 3, 32)));\n        transactions.add(new HashSet<Integer>(Arrays.asList(1, 2, 3, 33)));\n        transactions.add(new HashSet", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "48321891_0", "part": [1, 1], "seq": [1, 1], "prompt": "class FeatureTransformerHtml implements FeatureTransformer2 {\n\n    protected void writeField(FeatureProperty featureProperty, String value) {\n\n        if (featureProperty.isId()) {\n          currentFeature.id = new PropertyDTO();\n          currentFeature.id.addValue(value);\n          currentFeature.id.itemProp = \"url\";\n        }\n\n        PropertyDTO property = new PropertyDTO();\n        property.name = featureProperty.getName();\n        property.addValue(value);\n\n        if (currentFeature.name != null) {\n            int pos = currentFeature.name.indexOf(\"{{\" + property.name + \"}}\");\n            if (pos > -1) {\n                currentFeature.name = currentFeature.name.substring(0, pos) + value + currentFeature.name.substring(pos);\n            }\n        }\n\n        String tkey = featureProperty.getName()\n                                     .replaceAll(\"\\\\[[^\\\\]]+?\\\\]\", \"[]\");\n        if (transformations.containsKey(tkey)) {\n\n            Optional<ValueDTO> transformedProperty = property.values.size()>0 ?\n                    transformations.get(tkey)\n                                   .transform(property.values.get(0), featureProperty) :\n                    Optional.empty();\n\n            if (transformedProperty.isPresent()) {\n                if (transformedProperty.get().property.name.equals(featureProperty.getName()) && featureSchema.isPresent()) {\n                    String propertyName = featureProperty.getName().replace(\"[]\", \"\");\n                    FeatureSchema schema = featureSchema.get()\n                                                        .getProperties()\n                                                        .stream()\n                                                        .filter(prop -> prop.getName().equals(propertyName))\n                                                        .findAny()\n                                                        .orElse(null);\n                    if (schema!=null) {\n                        transformedProperty.get().property.name = schema.getLabel().orElse(schema.getName());\n                    }\n                }\n\n                property.values.set(0,transformedProperty.get());\n                currentFeature.addChild(property);\n            }\n        } else {\n            if (featureSchema.isPresent()) {\n                String propertyName = featureProperty.getName().replace(\"[]\", \"\");\n                FeatureSchema schema = featureSchema.get()\n                                                    .getProperties()\n                                                    .stream()\n                                                    .filter(prop -> prop.getName().equals(propertyName))\n                                                    .findAny()\n                                                    .orElse(null);\n                if (schema!=null) {\n                    property.name = schema.getLabel().orElse(schema.getName());\n                }\n            }\n\n            currentFeature.addChild(property);\n        }\n    }\n\n    public  FeatureTransformerHtml(FeatureTransformationContextHtml transformationContext, HttpClient httpClient);\n\n    @Override public String getTargetFormat();\n    @Override public void onStart(OptionalLong numberReturned, OptionalLong numberMatched);\n    @Override public void onEnd();\n    @Override public void onFeatureStart(FeatureType featureType);\n    @Override public void onFeatureEnd();\n    @Override public void onPropertyStart(FeatureProperty featureProperty, List<Integer> multiplicities);\n    @Override public void onPropertyText(String text);\n    @Override public void onPropertyEnd();\n    @Override public void onGeometryStart(FeatureProperty featureProperty, SimpleFeatureGeometry type,\n                                Integer dimension);\n    @Override public void onGeometryNestedStart();\n    @Override public void onGeometryCoordinates(String text);\n    @Override public void onGeometryNestedEnd();\n    @Override public void onGeometryEnd();\n\n    private static final Logger LOGGER;\n\n}\n\nclass FeatureTransformerHtmlTest {\n\n    private static final Logger LOGGER;\n\n    @Test\n    public void testWriteField() {\n", "reference": "    String input = \"Abc|\\n---|\\n1|\";\n    String actual = StringTemplateFilters.applyFilterMarkdown(input);\n\n    LOGGER.info(actual);\n    }\n\n}", "prediction": "        FeatureTransformerHtml transformer = new FeatureTransformerHtml(null, null);\n        FeatureProperty featureProperty = new FeatureProperty(\"name\", \"name\", \"string\", false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "48562236_28", "part": [1, 1], "seq": [1, 1], "prompt": "class YAML {\n\n    public static YamlValue parse(String string) throws YamlException {\n        return YamlValue.of(decode(string));\n    }\n\n    protected  YAML();\n\n    public static YamlValue parse(Reader reader);\n    public static T decode(String string);\n    public static T decode(Reader reader);\n    public static T decodeYamlOrJson(Resource resource);\n\n}\n\nclass YamlTest  {\n\n\t@Test\n\tpublic void testParseSimpleMap() {\n", "reference": "\t\tString yaml = \"p: value\";\n\t\tYamlObject o = YAML.parse(yaml).asYamlObject();\n\t\tassertEquals(\"value\",o.get(\"p\"));\n\t}\n\n}", "prediction": "\t\tYamlValue value = YAML.parse(\"{a: 1, b: 2}\");\n\t\tassertTrue(value.isMap());\n\t\tassertEquals(2, value.asMap().size());\n\t\tassertEquals(1, value.asMap().get(\"a\").asInt());\n\t\tassertEquals(2, value.asMap().get(\"b\").asInt());\n\t}", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "48609929_0", "part": [1, 1], "seq": [1, 1], "prompt": "class Sequencer {\n\n    public static int next() {\n        int tick = counter.getAndIncrement();\n        return tick & 0xff;\n    }\n\n    private  Sequencer();\n\n}\n\nclass sequencerTest {\n\n    @Test\n    public void sequencerShouldReturnIntegerIncrementallyFrom0To255(){\n", "reference": "        int pre = Sequencer.next();\n        int cur;\n        for (int i = 0; i < 10000; ++i){\n            cur = Sequencer.next();\n            Assert.assertTrue(cur >= 0);\n            Assert.assertTrue(cur <= 255);\n            if(pre == 255){\n                pre = 0;\n                Assert.assertEquals(0, cur);\n            }else {\n                Assert.assertEquals(1, cur - pre);\n                pre = cur;\n            }\n        }\n    }\n\n}", "prediction": "        for (int i = 0; i < 256; i++) {\n            assertEquals(i, Sequencer.next());\n        }\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "48638354_1", "part": [1, 1], "seq": [1, 1], "prompt": "class AnalyticsTrackerHelper {\n\n    public void trackEvent(String category, String action) {\n        analyticsTracker.send(\n                new HitBuilders.EventBuilder()\n                        .setCategory(category)\n                        .setAction(action)\n                        .build()\n        );\n    }\n\n    @Inject public  AnalyticsTrackerHelper(Tracker analyticsTracker);\n\n    public void trackScreenView(String screenName);\n\n    @Inject Tracker mockAnalyticsTracker;\n    private AnalyticsTrackerHelper analyticsTrackerHelper;\n\n}\n\nclass AnalyticsTrackerHelperTest  {\n\n    @Inject Tracker mockAnalyticsTracker;\n    private AnalyticsTrackerHelper analyticsTrackerHelper;\n\n    @Test\n    public void shouldTrackEventProperly() {\n", "reference": "        analyticsTrackerHelper.trackEvent(AnalyticsTags.CATEGORY_ACTION, AnalyticsTags.ACTION_SHARE);\n\n        verify(mockAnalyticsTracker).send(anyMap());\n    }\n\n}", "prediction": "        analyticsTrackerHelper.trackEvent(\"category\", \"action\");\n        verify(mockAnalyticsTracker).send(any(HitBuilders.EventBuilder.class));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "48880766_426", "part": [1, 1], "seq": [1, 1], "prompt": "class IntIndex implements Index {\n\n  public Selection greaterThan(int value) {\n    Selection selection = new BitmapBackedSelection();\n    Int2ObjectSortedMap<IntArrayList> tail = index.tailMap(value + 1);\n    for (IntArrayList keys : tail.values()) {\n      addAllToSelection(keys, selection);\n    }\n    return selection;\n  }\n\n  public  IntIndex(DateColumn column);\n  public  IntIndex(IntColumn column);\n  public  IntIndex(TimeColumn column);\n\n  private static void addAllToSelection(IntArrayList tableKeys, Selection selection);\n  public Selection get(int value);\n  public Selection get(LocalTime value);\n  public Selection get(LocalDate value);\n  public Selection atLeast(int value);\n  public Selection atLeast(LocalTime value);\n  public Selection atLeast(LocalDate value);\n  public Selection greaterThan(LocalTime value);\n  public Selection greaterThan(LocalDate value);\n  public Selection atMost(int value);\n  public Selection atMost(LocalTime value);\n  public Selection atMost(LocalDate value);\n  public Selection lessThan(int value);\n  public Selection lessThan(LocalTime value);\n  public Selection lessThan(LocalDate value);\n\n  private ColumnType[] types;\n  private DoubleIndex index;\n  private IntIndex dateIndex;\n  private Table table;\n\n}\n\nclass IntIndexTest {\n\n  private ColumnType[] types;\n  private DoubleIndex index;\n  private IntIndex dateIndex;\n  private Table table;\n\n  @Test\n  public void testGT1() {\n", "reference": "    LocalDate date = LocalDate.of(2002, 4, 1);\n    int value = PackedLocalDate.pack(date);\n    Selection fromCol = table.dateColumn(\"date\").eval(DateAndTimePredicates.isGreaterThan, value);\n    Selection fromIdx = dateIndex.greaterThan(value);\n    Selection fromIdx1 = dateIndex.greaterThan(date);\n    assertEquals(fromCol, fromIdx);\n    assertEquals(fromCol, fromIdx1);\n  }\n\n}", "prediction": "    Selection selection = index.greaterThan(1);\n    assertEquals(2, selection.size());\n    assertTrue(selection.contains(2));\n    assertTrue(selection.contains(3));\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "49679586_4", "part": [1, 1], "seq": [1, 1], "prompt": "class SLongByteUtils {\n\n\tstatic byte[] fromLong(final long value, final int numBytes) {\n\t\tlong shiftedValue = value;\n\t\tbyte[] res = new byte[numBytes];\n\t\tfor(int i = 0; i < numBytes; i++) {\n\t\t\tres[i] = (byte) (shiftedValue & BYTE_MASK);\n\t\t\tshiftedValue = shiftedValue >> 8;\n\t\t}\n\t\treturn res;\n\t}\n\n\tprivate  SLongByteUtils();\n\n\tstatic long getLong(final byte[] list);\n\n}\n\nclass SLongByteUtilsTest {\n\n\t@Test\n\t/**\n\t * Test\n\t */\n\tpublic void getSLongSize2WorksFor0() {\n", "reference": "\t\tassertArrayEquals(\"SLong(2) : 0 => 0\",\n\t\t\t\tnew byte[]{0, 0},\n\t\t\t\tSLongByteUtils.fromLong(0, 2));\n\t}\n\n}", "prediction": "\t\tassertEquals(0, SLongByteUtils.getLong(new byte[] {0, 0}));\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "49688312_0", "part": [1, 1], "seq": [1, 1], "prompt": "class QueryMatcher implements Serializable {\n\n    public boolean matches(String... queryTerms) {\n        for (String queryTerm : queryTerms) {\n            for (String entityTerm : entityTerms) {\n                if (entityTerm.contains(queryTerm.toUpperCase())) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    public  QueryMatcher(final String... theEntityTerms);\n\n    private List<String> processEntityTerms(String[] terms);\n    private String getNonAccentTerm(String term);\n\n}\n\nclass QueryMatcherTest {\n\n    @Test\n    public void test() {\n", "reference": "        QueryMatcher matcher = new QueryMatcher(\"Jair Bolsonaro\", \"PP\");\n        boolean result = matcher.matches(\"bolsonaro\");\n\n        Assert.assertTrue(result);\n    }\n\n}", "prediction": "        QueryMatcher matcher = new QueryMatcher(\"a\", \"b\", \"c\");\n        assertTrue(matcher.matches(\"a\"));\n        assertTrue(matcher.matches(\"b\"));\n        assertTrue(matcher.matches(\"c\"));\n        assertFalse(matcher.matches(\"d\"));\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "49717672_54", "part": [1, 1], "seq": [1, 1], "prompt": "class UserNotification extends Model {\n\n    public static UserNotification lastCalibrationAlert() {\n        return new Select()\n                .from(UserNotification.class)\n                .where(\"calibration_alert = ?\", true)\n                .orderBy(\"_ID desc\")\n                .executeSingle();\n    }\n\n    public static UserNotification lastBgAlert();\n    public static UserNotification lastDoubleCalibrationAlert();\n    public static UserNotification lastExtraCalibrationAlert();\n    public static UserNotification GetNotificationByType(String type);\n    public static void DeleteNotificationByType(String type);\n    public static void snoozeAlert(String type, long snoozeMinutes);\n    public static UserNotification create(String message, String type, long timestamp);\n\n}\n\nclass UserNotificationTest extends Model {\n\n    @Test\n    public void lastCalibrationAlert() {\n", "reference": "        // :: Setup\n        UserNotification.create(\"test1\", \"calibration_alert\", System.currentTimeMillis());\n        UserNotification.create(\"test2\", \"calibration_alert\", System.currentTimeMillis());\n\n        // :: Act\n        UserNotification userNotification = UserNotification.lastCalibrationAlert();\n\n        // :: Verify\n        assertThat(userNotification.calibration_alert).isTrue();\n        assertThat(userNotification.message).isEqualTo(\"test2\");\n    }\n\n}", "prediction": "        UserNotification.lastCalibrationAlert();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "49875177_0", "part": [1, 1], "seq": [1, 1], "prompt": "class Primes {\n\n    public final int compute() {\n        long start = System.currentTimeMillis();\n        int cnt = 0;\n        int prntCnt = 97;\n        int res;\n        for (;;) {\n            res = next();\n            cnt += 1;\n            if (cnt % prntCnt == 0) {\n                log(\"Computed \" + cnt + \" primes in \" + (System.currentTimeMillis() - start) + \" ms. Last one is \" + res);\n                prntCnt *= 2;\n            }\n            if (cnt >= 100000) {\n                break;\n            }\n        }\n        return res;\n    }\n\n    protected  Primes();\n\n     int next();\n    protected abstract void log(String msg);\n    public static void main(String... args);\n\n}\n\nclass PrimesTest {\n\n    @Test\n    public void fifthThousandThPrime() {\n", "reference": "        Primes p = new Primes() {\n            @Override\n            protected void log(String msg) {\n            }\n        };\n        int last = p.compute();\n        assertEquals(\"100000th prime is\", 1_299_709, last);\n    }\n\n}", "prediction": "        assertEquals(104743, new Primes().compute());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "50430650_26", "part": [1, 1], "seq": [1, 1], "prompt": "class JunitFeatureRunner extends org.junit.runner.Runner {\n\n    public final void init(final Class<?> reportedClass, final List<Class<?>> stepImplementationClasses,\n                           final String featureFile, final String tags, final String subStepsFile,\n                           final Class<?>[] beforeAndAfterImplementations) {\n        init(reportedClass, stepImplementationClasses, featureFile, tags, subStepsFile, true, null,\n                EclipseDescriptionProvider.class, beforeAndAfterImplementations);\n    }\n\n    public  JunitFeatureRunner();\n    public  JunitFeatureRunner(final Class<?> classContainingTheTests);\n\n    public final void init(final Class<?> reportedClass, final List<Class<?>> stepImplementationClasses,\n                           final String featureFile, final String tags, final String subStepsFileName, final boolean strict,\n                           final String[] nonStrictKeywordPrecedence,\n                           final Class<? extends DescriptionProvider> descriptionProviderClass,\n                           final Class<?>[] beforeAndAfterImplementations);\n    private Config buildConfig(final List<Class<?>> stepImplementationClasses,\n                               final String featureFile, final String tags, final String subStepsFileName, final boolean strict,\n                               final String[] nonStrictKeywordPrecedence,\n                               final Class<?>[] beforeAndAfterImplementations,\n                               String description);\n    @Override public Description getDescription();\n    @Override public void run(final RunNotifier junitNotifier);\n    private static String printDescription(final Description desc, final int depth);\n    public IExecutionNode getRootExecutionNode();\n\n    private File baseResourcesDir;\n\n}\n\nclass JunitFeatureRunnerTest extends org.junit.runner.Runner {\n\n    private File baseResourcesDir;\n\n    @Test(expected = SubstepsConfigurationException.class)\n    public void testMissingSubStepCausesFailure() {\n", "reference": "        final String feature = getResourcePath( \"features/error.feature\");\n        final String tag = \"@bug_missing_sub_step_impl\";\n        final String substeps = getResourcePath( \"substeps/error.substeps\");\n\n        final JunitFeatureRunner runner = new JunitFeatureRunner();\n\n        final List<Class<?>> stepImplsList = new ArrayList<>();\n        stepImplsList.add(TestStepImplementations.class);\n\n        runner.init(this.getClass(), stepImplsList, feature, tag, substeps, null);\n    }\n\n}", "prediction": "        final List<Class<?>> stepImplementations = new ArrayList<Class<?>>();\n        stepImplementations.add(SubStepImplementation.class);\n        final String featureFile = \"src/test/resources/junit/substeps/substeps.feature\";\n        final String subStepsFile = \"src/test/resources/junit/substeps/substeps.substeps\";\n        final String tags = \"substeps\";\n        final String description = \"Substeps\";\n        init(SubStepImplementation.class, stepImplementations, featureFile, tags, subStepsFile, true, null,\n                EclipseDescriptionProvider.class, new Class<?>[0]);\n        run(new RunNotifier());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "50765065_32", "part": [1, 1], "seq": [1, 1], "prompt": "class TodoListController {\n\n    public void observeItemHeight(View itemView) {\n        itemView.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {\n            @Override\n            public void onGlobalLayout() {\n                emitItemHeightIfNot(itemView);\n                itemView.getViewTreeObserver().removeOnGlobalLayoutListener(this);\n            }\n        });\n    }\n\n    public  TodoListController(@NonNull Context context, @NonNull List<TodoItemViewModel> items,\n                              @NonNull EventBus eventBus);\n\n    public void setItems(List<TodoItemViewModel> items);\n    public void bindFooterAction(TodoFooterViewHolder holder);\n    private Observable<Integer> footerHeight();\n    private int calculateFooterHeight(int listSize, int itemHeight);\n    public void bindItemAction(TodoItemViewHolder viewHolder, TodoItemViewModel viewModel);\n    private void emitItemHeightIfNot(View itemView);\n    public void resetState();\n    private void handleChooseItem(View itemView, TodoItemViewModel decorator);\n    private void updateFooterWhenClickItem(boolean actionShowing);\n    private void updateListWhenClickItem(TodoItemViewModel decorator);\n    private void waitForLayoutCompleteFireEvent(View itemView, TodoItemViewModel decorator);\n    private int indexOf(TodoItemViewModel decorator);\n\n    private static final int CONTENT_HEIGHT;\n    private static final int ITEM_HEIGHT;\n    private TodoListController mTodoListController;\n    private List<TodoItemViewModel> mItemViewModelList;\n    private Context mContext;\n    private TodoItemViewHolder mTodoItemViewHolder;\n    private TodoFooterViewHolder mTodoFooterViewHolder;\n    private View mFooterView;\n    @Rule\n    public PowerMockRule rule;\n    @Mock\n    private EventBus mEventBus;\n\n}\n\nclass TodoListControllerTest {\n\n    private static final int CONTENT_HEIGHT;\n    private static final int ITEM_HEIGHT;\n    private TodoListController mTodoListController;\n    private List<TodoItemViewModel> mItemViewModelList;\n    private Context mContext;\n    private TodoItemViewHolder mTodoItemViewHolder;\n    private TodoFooterViewHolder mTodoFooterViewHolder;\n    private View mFooterView;\n    @Rule\n    public PowerMockRule rule;\n    @Mock\n    private EventBus mEventBus;\n\n    @Test\n    public void testObserveItemHeight() throws Exception {\n", "reference": "        mTodoListController.observeItemHeight(mockFooterView());\n    }\n\n}", "prediction": "        mTodoListController.observeItemHeight(mTodoItemViewHolder.itemView);\n        verify(mTodoItemViewHolder.itemView.getViewTreeObserver()).addOnGlobalLayoutListener(any(ViewTreeObserver.OnGlobalLayoutListener.class));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "50866545_2", "part": [1, 1], "seq": [1, 1], "prompt": "class MediaType {\n\n    public static MediaType parse(String string) {\n        Matcher typeSubtype = TYPE_SUBTYPE.matcher(string);\n        if (!typeSubtype.lookingAt()) return null;\n        String type = typeSubtype.group(1).toLowerCase(Locale.US);\n        String subtype = typeSubtype.group(2).toLowerCase(Locale.US);\n\n        String charset = null;\n        Matcher parameter = PARAMETER.matcher(string);\n        for (int s = typeSubtype.end(); s < string.length(); s = parameter.end()) {\n            parameter.region(s, string.length());\n            if (!parameter.lookingAt()) return null; // This is not a well-formed media type.\n\n            String name = parameter.group(1);\n            if (name == null || !name.equalsIgnoreCase(\"charset\")) continue;\n            String charsetParameter = parameter.group(2) != null\n                    ? parameter.group(2)  // Value is a token.\n                    : parameter.group(3); // Value is a quoted string.\n            if (charset != null && !charsetParameter.equalsIgnoreCase(charset)) {\n                throw new IllegalArgumentException(\"Multiple different charsets: \" + string);\n            }\n            charset = charsetParameter;\n        }\n\n        return new MediaType(string, type, subtype, charset);\n    }\n\n    private  MediaType(String mediaType, String type, String subtype, String charset);\n\n    public String type();\n    public String subtype();\n    public Charset charset();\n    public Charset charset(Charset defaultValue);\n    @Override public String toString();\n    @Override public boolean equals(Object o);\n    @Override public int hashCode();\n\n}\n\nclass MediaTypeTest {\n\n    @Test public void testMultipleCharsets() {\n", "reference": "        try {\n            MediaType.parse(\"text/plain; charset=utf-8; charset=utf-16\");\n            fail();\n        } catch (IllegalArgumentException expected) {\n        }\n    }\n\n}", "prediction": "        MediaType mediaType = MediaType.parse(\"text/plain; charset=utf-8; charset=utf-16\");\n        assertEquals(\"text/plain; charset=utf-16\", mediaType.toString());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "51269282_0", "part": [1, 1], "seq": [1, 1], "prompt": "class HttpZipkinFactory extends ReportingZipkinFactory {\n\n  @JsonProperty\n  public String getBaseUrl() {\n    return baseUrl;\n  }\n\n  @JsonProperty public void setBaseUrl(String baseUrl);\n  @JsonProperty public void setConnectTimeout(Duration connectTimeout);\n  @JsonProperty public void setReadTimeout(Duration readTimeout);\n  @Override public Optional<HttpTracing> build(final Environment environment);\n\n}\n\nclass HttpZipkinFactoryTest {\n\n  @Test\n  public void shouldBeConfigurable() throws IOException {\n", "reference": "    ObjectMapper mapper =\n        new ObjectMapper(new YAMLFactory()).setSubtypeResolver(new DiscoverableSubtypeResolver());\n\n    final ZipkinFactory factory =\n        mapper.readValue(\n            \"enabled: true\\n\"\n                + \"collector: http\\n\"\n                + \"baseUrl: http://example.com:1234/zipkin\\n\"\n                + \"connectTimeout: 1d\\n\"\n                + \"readTimeout: 2d\\n\"\n                + \"reportTimeout: 3d\\n\",\n            ZipkinFactory.class);\n    assertThat(factory).isInstanceOf(HttpZipkinFactory.class);\n    HttpZipkinFactory httpFactory = (HttpZipkinFactory) factory;\n    assertThat(httpFactory.getBaseUrl()).isEqualTo(\"http://example.com:1234/zipkin\");\n    assertThat(httpFactory.getReportTimeout()).isEqualTo(Duration.days(3));\n  }\n\n}", "prediction": "    HttpZipkinFactory factory = new HttpZipkinFactory();\n    factory.setBaseUrl(\"http://localhost:9411/api/v2/spans\");\n    factory.setConnectTimeout(Duration.ofSeconds(1));\n    factory.setReadTimeout(Duration.ofSeconds(1));\n    HttpTracing httpTracing = factory.build(null).get();\n    assertThat(httpTracing.httpSender().baseUrl()).isEqualTo(\"http://localhost:9411/api/v2/spans\");\n    assertThat(httpTracing.httpSender().connectTimeout()).isEqualTo(Duration.ofSeconds(1));\n    assertThat(httpTracing.httpSender().readTimeout()).isEqualTo(Duration.ofSeconds(1));\n  }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "51843899_1", "part": [1, 1], "seq": [1, 1], "prompt": "class WARCRecord {\n\n    public static String extractHTTPHeaderContentType(String httpHeaderText)\n            throws IOException\n    {\n        if (httpHeaderText == null) {\n            throw new IOException(\"httpHeaderText parameter is null\");\n        }\n\n        Matcher matcher = CONTENT_TYPE_PATTERN.matcher(httpHeaderText);\n\n        if (matcher.find()) {\n            return matcher.group(1).toLowerCase();\n        }\n\n        return null;\n    }\n\n    public  WARCRecord(DataInput in);\n    public  WARCRecord(WARCRecord other);\n\n    private static Header readHeader(DataInput in);\n    private static String readLine(DataInput in);\n    private static void readSeparator(DataInput in);\n    public boolean isContentApplicationHttpResponse();\n    public String getHTTPHeaders();\n    public Header getHeader();\n    public byte[] getContent();\n    public void write(DataOutput out);\n    @Override public String toString();\n    public void setContent(String newContent);\n    public static String extractHTTPHeaderCharset(String httpHeaderText);\n\n}\n\nclass WARCRecordTest {\n\n    @Test\n    public void testExtractHTTPHeaderContentType()\n            throws Exception\n    {\n", "reference": "        String httpHeaders = \"HTTP/1.1 200 OK\\n\" + \"Date: Sun, 05 Jul 2015 17:30:02 GMT\\n\"\n                + \"Server: Apache/2.2.29 (Unix) FrontPage/5.0.2.2635\\n\"\n                + \"X-Powered-By: PHP/5.3.29-pl0-gentoo\\n\"\n                + \"X-Pingback: http://0351de3.netsolhost.com/WordPress/xmlrpc.php\\n\"\n                + \"Link: <http://0351de3.netsolhost.com/WordPress/?p=8261>; rel=shortlink\\n\"\n                + \"Connection: close\\n\" + \"Content-Type: text/html; charset=UTF-8\\n\";\n\n        assertEquals(\"text/html\", WARCRecord.extractHTTPHeaderContentType(httpHeaders));\n\n        httpHeaders = \"HTTP/1.1 200 OK\\n\" + \"Date: Sun, 05 Jul 2015 17:30:02 GMT\\n\"\n                + \"Content-Type: application/xhtml+xml\\n\"\n                + \"Server: Apache/2.2.29 (Unix) FrontPage/5.0.2.2635\\n\";\n\n        assertEquals(\"application/xhtml+xml\", WARCRecord.extractHTTPHeaderContentType(httpHeaders));\n\n        httpHeaders = \"HTTP/1.1 200 OK\\n\" + \"Date: Sun, 05 Jul 2015 17:30:02 GMT\\n\"\n                + \"Content-Type: application/wordperfect5.1;\\n\"\n                + \"Server: Apache/2.2.29 (Unix) FrontPage/5.0.2.2635\\n\";\n\n        assertEquals(\"application/wordperfect5.1\",\n                WARCRecord.extractHTTPHeaderContentType(httpHeaders));\n\n    }\n\n}", "prediction": "        assertEquals(\"text/html\", WARCRecord.extractHTTPHeaderContentType(\n                \"Content-Type: text/html\\r\\n\" +\n                \"Content-Length: 1234\\r\\n\" +\n                \"\\r\\n\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "52316952_26", "part": [1, 1], "seq": [1, 1], "prompt": "class NimbleFrameLayout extends FrameLayout implements NimbleView {\n\n  @Override\n  protected void onDetachedFromWindow() {\n    super.onDetachedFromWindow();\n    presenter().dropView(getMvpView());\n    if (getActivity().isFinishing()) {\n      presenter().onDestroy();\n    }\n  }\n\n  public  NimbleFrameLayout(Context context);\n  public  NimbleFrameLayout(Context context, AttributeSet attrs);\n  public  NimbleFrameLayout(Context context, AttributeSet attrs, int defStyleAttr);\n\n  abstract protected NimblePresenter<V> presenter();\n  public Activity getActivity();\n  @Override protected void onAttachedToWindow();\n  @Override protected Parcelable onSaveInstanceState();\n  @Override protected void onRestoreInstanceState(Parcelable state);\n  private V getMvpView();\n\n  @Mock NimblePresenter<NimbleView> presenter;\n  @Mock Bundle bundle;\n   NimbleFrameLayout<NimbleView> layout;\n  @Mock Context context;\n\n}\n\nclass TestNimbleFrameLayout {\n\n  @Mock NimblePresenter<NimbleView> presenter;\n  @Mock Bundle bundle;\n   NimbleFrameLayout<NimbleView> layout;\n  @Mock Context context;\n\n  @Test\n  public void testOnDetachedFromWindow() throws Exception {\n", "reference": "    prepareForOnDetachedFromWindows(false);\n    layout.onDetachedFromWindow();\n    verify(presenter).dropView(layout);\n  }\n\n}", "prediction": "    layout.onDetachedFromWindow();\n    verify(presenter).dropView(layout);\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "52409237_1", "part": [1, 1], "seq": [1, 1], "prompt": "class Segment extends AbstractTextMatch<TokenType> {\n\n    Segment(String name, SegmentFilter segmentFilter, AbstractTextMatch<TokenType> asciiAnalyzer,\n            CjkAnalyzer cjkAnalyzer, NumQuantifierMerge numQuantifierMerge) {\n        this.name = name;\n        this.segmentFilter = segmentFilter;\n        this.asciiAnalyzer = asciiAnalyzer;\n        this.cjkAnalyzer = cjkAnalyzer;\n        this.numQuantifierMerge = numQuantifierMerge;\n    }\n\n      Segment(String name, SegmentFilter segmentFilter, AbstractTextMatch<TokenType> asciiAnalyzer,\n            CjkAnalyzer cjkAnalyzer, NumQuantifierMerge numQuantifierMerge);\n\n    @Override public List<Hit<TokenType>> match(final char[] text, final int off, final int len);\n    public String getName();\n    @Override public boolean equals(Object o);\n    @Override public int hashCode();\n    public static Builder build(String name);\n\n    private static Segment fullSegment;\n    private static Segment maxSegment;\n    private static Segment minSegment;\n\n}\n\nclass SegmentTest {\n\n    private static Segment fullSegment;\n    private static Segment maxSegment;\n    private static Segment minSegment;\n\n    @Test\n    public void segmentTest() {\n", "reference": "        List<String> texts = new ArrayList<>();\n        texts.add(\"Xing-Wang0.5\u5143, \u5927\u9023\u7406\u5de5\u5927\u5b66\u516d\u5341\u5e74\u6821\u5e86, 500\u4eba\u4e0d\u662f\u53c2\u52a0\u534e\u4e2d\u79d1\u6280\u5927\u5b66\");\n        texts.add(\"\u5317\u4eac\u5927\u5b66\");\n        texts.add(\"\u5317\u4eac\u7684\u5927\u5b66\");\n        texts.add(\"\u5546\u54c1\u670d\u52a1\");\n        texts.add(\"\u5546\u54c1\u548c\u670d\u52a1\");\n        texts.add(\"\u5546\u54c1\u548c\u6c0f\u74a7\");\n        texts.add(\"B-tree\u4e2d\u7684\u6bcf\u4e2a\u7ed3\u70b9\u6839\u636e\u5b9e\u9645\u60c5\u51b5\u53ef\u4ee5\u5305\u542b\u5927\u91cf\u7684\u5173\u952e\u5b57\u4fe1\u606f\");\n        texts.add(\"\u4e1c\u65b9\u4e0d\u8d25\u7b11\u50b2\u6c5f\u6e56\u90fd\u662f\u597d\u770b\u7684\u7535\u89c6\u5267\");\n        texts.add(\"\u5546\u54c1\u5171\u548c\u670d\");\n        texts.add(\"\u4e25\u5b88\u4e00\u628a\u624b\u673a\u5173\u4e86\");\n        texts.add(\"\u5409\u6797\u7701\u957f\u6625\u836f\u5e97\");\n        texts.add(\"\u4ee3\u8868\u5317\u5927\u7684\u4eba\u5927\u4ee3\u8868\uff0c\u4ee3\u8868\u4eba\u5927\u7684\u5317\u5927\u535a\u58eb\");\n        texts.add(\"\u6c5f\u9634\u6bdb\u7eba\u7ec7\u5382\");\n        texts.add(\"\u8584\u7199\u6765\u5230\u91cd\u5e86\");\n        texts.add(\"\u5468\u6770\u8f6e\u5468\u6770\u4f26\uff0c\u8303\u4f1f\u9a91\u8303\u73ae\u742a\");\n        texts.add(\"\u7ed3\u5a5a\u7684\u548c\u5c1a\u672a\u7ed3\u5a5a\u7684\");\n        texts.add(\"\u5317\u4eac\u5927\u5b66\u751f\u524d\u6765\u5e94\u8058\");\n        texts.add(\"\u9ad8\u6570\u5b66\u8d77\u6765\u5f88\u96be\");\n        texts.add(\"\u535a\u89c2\u662f\u4ec0\u4e48\u65f6\u5019\u52a0\u5165\u963f\u91cc\u7684\uff1f\");\n        texts.add(\"\u8682\u8681\u91d1\u670d\u7684\u5458\u5de5\u90fd\u5206\u5e03\u5728\u54ea\u4e9b\u5de5\u4f5c\u5730\u70b9\uff1f\");\n        texts.add(\"\u5317\u4eac\u5927\u5b66\u751f\u524d\u6765\u5e94\u8058\");\n        for (String text : texts) {\n            System.out.println(\"text: \" + text);\n            char[] array = text.toCharArray();\n            System.out.println(\"fullSegment: \" + Hits.valueOf(array, fullSegment.match(array, 0, array.length)));\n            System.out.println(\"maxSegment: \" + Hits.valueOf(array, maxSegment.match(array, 0, array.length)));\n            System.out.println(\"minSegment: \" + Hits.valueOf(array, minSegment.match(array, 0, array.length)));\n            break;\n        }\n    }\n\n}", "prediction": "        assertEquals(fullSegment.match(\"abc\", 0, 3), Collections.singletonList(new Hit<>(TokenType.FULL, 0, 3)));\n        assertEquals(fullSegment.match(\"abc\", 0, 2), Collections.singletonList(new Hit<>(TokenType.FULL, 0, 2)));\n        assertEquals(fullSegment.match(\"abc\", 0, 1), Collections.singletonList(new Hit<>(TokenType.FULL, 0, 1)));\n        assertEquals(fullSegment.match(\"abc\", 0, 0), Collections.singletonList(new Hit<>(TokenType.FULL, 0, 0)));\n        assertEquals(fullSegment.match(\"abc\", 1, 2), Collections.singletonList(new Hit<>(TokenType.FULL, 1, 2)));\n        assertEquals(fullSegment.match(\"abc\", 1, 1), Collections.singletonList(new Hit<>(TokenType.FULL, 1, 1)));\n        assertEquals(fullSegment.match(\"abc\", 1, 0), Collections.singletonList(new Hit<>(TokenType.FULL, 1, 0)));\n        assertEquals(fullSegment.match(\"abc\", 2, 1), Collections.singletonList(new Hit<>(TokenType.FULL, 2, 1)));\n        assertEquals(fullSegment.match(\"abc\", 2, 0), Collections.singletonList(new Hit<>(TokenType.FULL, 2, 0)));\n        assertEquals(fullSegment.match(\"abc\", 3, 0), Collections.emptyList());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "52435170_121", "part": [1, 1], "seq": [1, 1], "prompt": "class DataSetComparator {\n\n    public void compare(final IDataSet currentDataSet, final IDataSet expectedDataSet, final AssertionErrorCollector errorCollector)\n            throws DatabaseUnitException {\n        if (expectedDataSet.getTableNames().length == 0) {\n            shouldBeEmpty(currentDataSet, errorCollector);\n        } else {\n            compareContent(currentDataSet, expectedDataSet, errorCollector);\n        }\n    }\n\n    public  DataSetComparator(final String[] orderBy, final String[] toExclude, final boolean isStrict,\n            final Set<Class<? extends IColumnFilter>> columnFilters);\n\n    private void shouldBeEmpty(final IDataSet dataSet, final AssertionErrorCollector errorCollector);\n    @SuppressWarnings(\"unchecked\") private void compareContent(final IDataSet currentDataSet, final IDataSet expectedDataSet, final AssertionErrorCollector errorCollector);\n    private List<String> defineColumnsForSorting(final IDataSet currentDataSet, final IDataSet expectedDataSet, final String tableName);\n    private ITable sort(final ITable table, final List<String> columnsForSorting);\n    private List<String> extractColumnsToBeIgnored(final ITable expectedTableState, final ITable currentTableState);\n    private ITable filter(final ITable table, final String[] columnsToFilter);\n    private void collectErrors(final AssertionErrorCollector errorCollector, final List<Difference> diffs);\n    private List<String> additionalColumnsForSorting(final ITable expectedTableState, final ITable currentTableState);\n    private ITable applyCustomFilters(final ITable table);\n    private Collection<String> extractColumnNames(final Column[] columns);\n    private List<String> extractNotExpectedColumnNames(final ITable expectedTable, final ITable currentTable);\n\n    private static final String TABLE_1_NAME;\n    private static final int TABLE_1_ENTRIES;\n    private static final Column TABLE_1_COLUMN_1;\n    private static final Column TABLE_1_COLUMN_2;\n    private static final String TABLE_2_NAME;\n    private static final int TABLE_2_ENTRIES;\n    private static final Column TABLE_2_COLUMN_1;\n    private static final Column TABLE_2_COLUMN_2;\n    private static final Column TABLE_2_COLUMN_3;\n    private static final String TABLE_3_NAME;\n    private static final int TABLE_3_ENTRIES;\n    private static final Column TABLE_3_COLUMN_1;\n    private static final Column TABLE_3_COLUMN_2;\n    private static final Column TABLE_3_COLUMN_3;\n    private static final Column TABLE_3_COLUMN_4;\n    private static final Column TABLE_4_COLUMN_1;\n    private static final Column TABLE_4_COLUMN_2;\n    @Mock\n    private IDataSet currentDataSet;\n    @Mock\n    private IDataSet expectedDataSet;\n    @Mock\n    private ITable table1;\n    @Mock\n    private ITable table2;\n    @Mock\n    private ITable table3;\n    @Mock\n    private ITable table4;\n    @Mock\n    private ITableMetaData table1MetaData;\n    @Mock\n    private ITableMetaData table2MetaData;\n    @Mock\n    private ITableMetaData table3MetaData;\n    @Mock\n    private ITableMetaData table4MetaData;\n    private AssertionErrorCollector errorCollector;\n\n}\n\nclass DataSetComparatorTest {\n\n    private static final String TABLE_1_NAME;\n    private static final int TABLE_1_ENTRIES;\n    private static final Column TABLE_1_COLUMN_1;\n    private static final Column TABLE_1_COLUMN_2;\n    private static final String TABLE_2_NAME;\n    private static final int TABLE_2_ENTRIES;\n    private static final Column TABLE_2_COLUMN_1;\n    private static final Column TABLE_2_COLUMN_2;\n    private static final Column TABLE_2_COLUMN_3;\n    private static final String TABLE_3_NAME;\n    private static final int TABLE_3_ENTRIES;\n    private static final Column TABLE_3_COLUMN_1;\n    private static final Column TABLE_3_COLUMN_2;\n    private static final Column TABLE_3_COLUMN_3;\n    private static final Column TABLE_3_COLUMN_4;\n    private static final Column TABLE_4_COLUMN_1;\n    private static final Column TABLE_4_COLUMN_2;\n    @Mock\n    private IDataSet currentDataSet;\n    @Mock\n    private IDataSet expectedDataSet;\n    @Mock\n    private ITable table1;\n    @Mock\n    private ITable table2;\n    @Mock\n    private ITable table3;\n    @Mock\n    private ITable table4;\n    @Mock\n    private ITableMetaData table1MetaData;\n    @Mock\n    private ITableMetaData table2MetaData;\n    @Mock\n    private ITableMetaData table3MetaData;\n    @Mock\n    private ITableMetaData table4MetaData;\n    private AssertionErrorCollector errorCollector;\n\n    @Test\n    public void testExpectedDataSetIsASubsetOfCurrentDataSetUsingNotStringMode() throws Exception {\n", "reference": "        // GIVEN\n        final String[] orderBy = new String[] {};\n        final String[] toExclude = new String[] {};\n        final Set<Class<? extends IColumnFilter>> columnFilters = Collections.emptySet();\n        final DataSetComparator comparator = new DataSetComparator(orderBy, toExclude, false, columnFilters);\n\n        when(expectedDataSet.getTableNames()).thenReturn(new String[] {\n                TABLE_2_NAME\n        });\n        when(expectedDataSet.getTable(any(String.class))).thenAnswer((final InvocationOnMock invocation) -> {\n            final String tableName = (String) invocation.getArguments()[0];\n            if (tableName == TABLE_2_NAME) {\n                return table2;\n            } else {\n                throw new NoSuchTableException(tableName);\n            }\n        });\n\n        when(currentDataSet.getTableNames()).thenReturn(new String[] {\n                TABLE_1_NAME, TABLE_2_NAME\n        });\n        when(currentDataSet.getTable(any(String.class))).thenAnswer((final InvocationOnMock invocation) -> {\n            final String tableName = (String) invocation.getArguments()[0];\n            if (tableName == TABLE_1_NAME) {\n                return table1;\n            } else if (tableName == TABLE_2_NAME) {\n                return table2;\n            } else {\n                throw new NoSuchTableException(tableName);\n            }\n        });\n\n        // WHEN\n        comparator.compare(currentDataSet, expectedDataSet, errorCollector);\n\n        // THEN\n        assertThat(errorCollector.amountOfErrors(), equalTo(0));\n\n        errorCollector.report();\n    }\n\n}", "prediction": "        when(currentDataSet.getTable(TABLE_1_NAME)).thenReturn(table1);\n        when(currentDataSet.getTable(TABLE_2_NAME)).thenReturn(table2);\n        when(currentDataSet.getTable(TABLE_3_NAME)).thenReturn(table3);\n        when(currentDataSet.getTable(TABLE_4_NAME)).thenReturn(table4);\n        when(table1.getTableMetaData()).thenReturn(table1MetaData);\n        when(table2.getTableMetaData()).thenReturn(table2MetaData);\n        when(table3.getTableMetaData()).thenReturn(table3MetaData);\n        when(table4.getTableMetaData()).thenReturn(table4MetaData);\n        when(table1MetaData.getColumns()).thenReturn(new Column[] { TABLE_1_COLUMN_1, TABLE_1_COLUMN_2 });\n        when(table2MetaData.getColumns()).thenReturn(new Column[] { TABLE_2_COLUMN_1, TABLE_2_COLUMN_2, TABLE_2_COLUMN_3 });\n        when(table3MetaData.getColumns()).thenReturn(new Column[] { TABLE_3_COLUMN_1, TABLE_3_COLUMN_2, TABLE_3_COLUMN_3, TABLE_3_COLUMN_4 });\n        when(table4MetaData.getColumns()).thenReturn(new Column[] { TABLE_4_COLUMN_1, TABLE_4_COLUMN_2 });\n        when(table1.getRowCount()).thenReturn(TABLE_1_ENTRIES);\n        when(table2.getRowCount()).thenReturn(TABLE_2_ENTRIES);\n        when(table3.getRowCount()).thenReturn(TABLE_3_ENTRIES);\n        when(table4.getRowCount()).thenReturn(0);\n        when(table1.getTableName()).thenReturn(TABLE_1_NAME);\n        when(table2.getTableName()).thenReturn(TABLE_2_NAME);\n        when(table3.getTableName()).thenReturn(TABLE_3_NAME);\n        when(table4.getTableName()).thenReturn(TABLE_4_NAME);\n        when(table1.getTableMetaData()).thenReturn(table1MetaData);\n        when(table2.getTableMetaData()).thenReturn(table2MetaData);\n        when(table3.getTableMetaData()).thenReturn(table3MetaData);\n        when(table4.getTableMetaData()).thenReturn(table4MetaData);\n        when(table1MetaData.getColumns()).thenReturn(new Column[] { TABLE_1_COLUMN_1, TABLE_1_COLUMN_2 });\n        when(table2MetaData.getColumns()).thenReturn(new Column[] { TABLE_2_COLUMN_1, TABLE_2_COLUMN_2, TABLE_2_COLUMN_3 });\n        when(table3MetaData.getColumns()).thenReturn(new Column[] { TABLE_3_COLUMN_1, TABLE_3_COLUMN_2, TABLE_3_COLUMN_3, TABLE_3_COLUMN_4 });\n        when(table4MetaData.getColumns()).thenReturn(new Column[] { TABLE_4_COLUMN_1, TABLE_4_COLUMN_2 });\n        when(table1.getRowCount()).thenReturn(TABLE_1_ENTRIES);\n        when(table2.getRowCount()).thenReturn(TABLE_2_ENTRIES);\n        when", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "53501969_1", "part": [1, 1], "seq": [1, 1], "prompt": "class SentenceWriter extends Processor {\n\n\tprotected void writeSentences(CrawlURI curi, String cleaned_plaintext) {\n\t\tString perplexity_value_as_string = \"null\";\n\t\tif(curi != null && curi.getData() != null){\n\t\t\tObject obj = curi.getData().get(SharedConstants.EXTRA_INFO_PERPLEXITY);\n\t\t\tif(obj != null)\n\t\t\t\tperplexity_value_as_string = (String)obj;\n\t\t}\n\t\tString time = TimeUtils.get_ISO_8601_UTC();\n\t\tint c = 0;\n\t\tsynchronized (_lck) {\n\t\t\tfor(String sentence :  _sentence_maker.getSentences(cleaned_plaintext, _languagecode)){\n\t\t\t\tString s = String.format(\"%s\\t%s\\t%s\\t%d\\t%s%n\", time, sentence, curi, ++c, perplexity_value_as_string);\n\t\t\t\t_current_stream.print(s);\n\t\t\t\t_num_bytes_written.getAndAdd(s.getBytes().length);\n\t\t\t\t_num_bytes_sentences_written.getAndAdd(sentence.getBytes().length);\n\t\t\t}\n\t\t\t_current_stream.flush();\n\t\t}\n\t\t_num_sentences.getAndAdd(c);\n\t\t_num_uris_written.getAndIncrement();\n\t}\n\n\tpublic  SentenceWriter();\n\n\tpublic TextExtractor getTextExtractor();\n\tpublic void setTextExtractor(TextExtractor text_extractor);\n\tpublic SentenceMaker getSentenceMaker();\n\tpublic void setSentenceMaker(SentenceMaker sentence_maker);\n\tpublic ConfigPath getPath();\n\tpublic void setPath(ConfigPath newpath);\n\tpublic String getLanguageCode();\n\tpublic void setLanguageCode(String languagecode);\n\tpublic long getMaxFileSizeBytes();\n\tpublic void setMaxFileSizeBytes(long maxFileSizeBytes);\n\tpublic String getPrefix();\n\tpublic void setPrefix(String prefix);\n\tpublic String getFilenameFormat();\n\tpublic void setFilenameFormat(String filename_format);\n\t@Override public void start();\n\t@Override public void stop();\n\t@Override protected boolean shouldProcess(CrawlURI curi);\n\t@Override protected void innerProcess(CrawlURI curi);\n\tprotected File updateOuputFile();\n\tprotected String getFilename();\n\tprotected PrintStream openPrintToFileStream(File outputfile);\n\t@Override public String report();\n\n}\n\nclass SentenceWriterTest {\n\n\t@Test\n\tpublic void test() {\n", "reference": "\t\tSentenceWriter w = new SentenceWriter(){{_sentence_maker = new SentenceMaker();}};\n\t\tw._current_stream = System.out;\n\t\tw.writeSentences(null, \"This is a test. This is also a test.\");\n\t}\n\n}", "prediction": "\t\tfail(\"Not yet implemented\");\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "53528552_2", "part": [1, 1], "seq": [1, 1], "prompt": "class RegexEvaluator {\n\n    public void update(String regex, int flags, String replacement, String input) {\n        try {\n            //TODO: catch empty/null exceptions\n            if (!this.regex.equals(regex) || this.flags != flags) {\n                pattern = Pattern.compile(regex, flags);\n                this.regex = regex;\n                this.flags = flags;\n                this.validRegex = true;\n                this.validReplex = true;\n            }\n            if (pattern != null) {\n                matcher = pattern.matcher(input);\n                matches = matcher.matches();\n                matcher.reset();\n                if (isNotEmpty(replacement)) {\n                    try {\n                        replaceFirst = matcher.replaceFirst(replacement);\n                        replaceAll = matcher.replaceAll(replacement);\n                        validReplex = true;\n                    } catch (IllegalArgumentException iae) {\n                        validReplex = false;\n                        replexReason = iae.getMessage();\n                        replaceAll = \"\";\n                        replaceFirst = \"\";\n                    } catch (IndexOutOfBoundsException ioe) {\n                        validReplex = false;\n                        replexReason = ioe.getMessage();\n                        replaceAll = \"\";\n                        replaceFirst = \"\";\n                    }\n                }\n                lookingAt = matcher.lookingAt();\n                matcher.reset();\n                find = matcher.find();\n                if (find) {\n                    groups = new MatcherGroup[matcher.groupCount() + 1];\n                    for (int i = 0; i < matcher.groupCount() + 1; i++) {\n                        groups[i] = new MatcherGroup(matcher.start(i), matcher.end(i), matcher.group(i));\n                    }\n                } else {\n                    groups = new MatcherGroup[0];\n                }\n            }\n        } catch (PatternSyntaxException pse) {\n            this.validRegex = false;\n            this.regexReason = pse.getMessage();\n        }\n    }\n\n    private boolean isNotEmpty(String toTest);\n\n   RegexEvaluator eval;\n\n}\n\nclass RegexEvaluatorTest {\n\n   RegexEvaluator eval;\n\n  @Test\n  public void testMultipleGroups() {\n", "reference": "    String testInput = \"Foobar Ipsum Lorem\";\n    eval.update(\"Foo(.*) (.*)\", 0, \"\", testInput);\n    assertTrue(eval.matches);\n    assertTrue(eval.lookingAt);\n    assertTrue(eval.find);\n    assertEquals(3, eval.groups.length);\n    assertEquals(testInput, eval.groups[0].group);\n    assertEquals(0, eval.groups[0].start);\n    assertEquals(testInput.length(), eval.groups[0].end);\n    assertEquals(\"bar Ipsum\", eval.groups[1].group);\n    assertEquals(3, eval.groups[1].start);\n    assertEquals(12, eval.groups[1].end);\n    assertEquals(\"Lorem\", eval.groups[2].group);\n    assertEquals(13, eval.groups[2].start);\n    assertEquals(testInput.length(), eval.groups[2].end);\n  }\n\n}", "prediction": "    eval.update(\"(a)(b)(c)\", 0, \"\\\\1\\\\2\\\\3\", \"abc\");\n    assertTrue(eval.validRegex);\n    assertTrue(eval.validReplex);\n    assertEquals(\"abc\", eval.replaceFirst);\n    assertEquals(\"abc\", eval.replaceAll);\n    assertTrue(eval.lookingAt);\n    assertTrue(eval.find);\n    assertEquals(3, eval.groups.length);\n    assertEquals(0, eval.groups[0].start);\n    assertEquals(1, eval.groups[0].end);\n    assertEquals(\"a\", eval.groups[0].value);\n    assertEquals(1, eval.groups[1].start);\n    assertEquals(2, eval.groups[1].end);\n    assertEquals(\"b\", eval.groups[1].value);\n    assertEquals(2, eval.groups[2].start);\n    assertEquals(3, eval.groups[2].end);\n    assertEquals(\"c\", eval.groups[2].value);\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "54110401_3", "part": [1, 1], "seq": [1, 1], "prompt": "class CoordinateUtils {\n\n    public static int findMinDepthIndex(double[] depths, double from) {\n        int first = Arrays.binarySearch(depths, from);\n        if (first < 0) {\n            // Extract insertion point\n            first = -1 - first;\n            // Check at 1 cm for rounding tolerance\n            if (first != 0 && (Math.floor(from * 100) - Math.floor(100 * depths[first - 1])) <= 1) {\n                first--;\n            }\n        }\n        if (first == depths.length) {\n            first = -1;\n        }\n        return first;\n    }\n\n    public static double getLongitudeM180P180(double longitude);\n    public static List<Range> createRange(int minj, int maxj, int mini, int maxi);\n    public static int findCoordElementBounded(CoordinateAxis1D axis, double pos, int lastIndex);\n    public static List<Range> getRangesFromLatLonRect(GridCoordSys gcs, LatLonRect rect);\n    public static double getMinOrMaxLon(double lon1, double lon2, boolean wantMin);\n    public static MinMax computeMinMax(MinMax ref, MinMax work);\n    public static MAMath.MinMax computeLatMinMax(MAMath.MinMax minMaxYValue2D, CoordinateAxis2D latAxis, int minj, int mini, int maxj, int maxi);\n    public static MAMath.MinMax computeLonMinMax(MAMath.MinMax minMaxXValue2D,\n                                                 CoordinateAxis2D lonAxis,\n                                                 int minj,\n                                                 int mini,\n                                                 int maxj,\n                                                 int maxi,\n                                                 double minx,\n                                                 double maxx);\n    public static MinMax computeMinMaxX(Projection dataProjection, LatLonRect rect);\n    public static MinMax computeMinMaxY(Projection dataProjection, LatLonRect rect);\n    public static MinMax[] computeMinMaxXY(Projection dataProjection, LatLonRect rect);\n    public static void checkXYAxis(CoordinateAxis xaxis, CoordinateAxis yaxis, GridCoordSys gcs);\n    public static double checkLon(double lon, double refXMin);\n    public static boolean isInside(double lat, double lon, MinMax minMaxX, MinMax minMaxY);\n    public static void removeEmptyYXRanges(List<List<Range>> listRanges);\n    public static boolean hasEmptyYXRanges(List<List<Range>> listRanges);\n    public static List<Range> createEmptyYXRanges();\n    public static boolean hasRange(List<Range> ranges);\n    public static boolean hasRange(Range range);\n    public static void getRangeValues(GridCoordSys gcs, Range rangeLat, Range rangeLon, double[] rangeValueLat, double[] rangeValueLon);\n    public static MAMath.MinMax getMinMaxValueForAxis(CoordinateAxis axis);\n    public static double getMinValueForAxis(CoordinateAxis axis);\n    public static double getMaxValueForAxis(CoordinateAxis axis);\n    public static String getMinValForAxisAsString(CoordinateAxis axis);\n    public static String getMaxValForAxisAsString(CoordinateAxis axis);\n    public static int findMaxDepthIndex(double[] depths, double to);\n\n}\n\nclass CoordinateUtilsTest {\n\n    @Test\n    public void testFindMinDepthIndex() {\n", "reference": "\n        double[] depths = { 0.18234, 0.235, 0.24, 0.245, 1.1 };\n\n        assertTrue(CoordinateUtils.findMinDepthIndex(depths, 0.15) == 0);\n        assertTrue(CoordinateUtils.findMinDepthIndex(depths, 0.18234) == 0);\n        assertTrue(CoordinateUtils.findMinDepthIndex(depths, 0.24) == 2);\n        assertTrue(CoordinateUtils.findMinDepthIndex(depths, 0.2401) == 2);\n        assertTrue(CoordinateUtils.findMinDepthIndex(depths, 0.239) == 1);\n        assertTrue(CoordinateUtils.findMinDepthIndex(depths, 2) == -1);\n        assertTrue(CoordinateUtils.findMinDepthIndex(depths, 0.24275) == 2);\n\n    }\n\n}", "prediction": "        double[] depths = new double[] { 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0 };\n        assertEquals(0, CoordinateUtils.findMinDepthIndex(depths, 0.0));\n        assertEquals(0, CoordinateUtils.findMinDepthIndex(depths, 0.1));\n        assertEquals(1, CoordinateUtils.findMinDepthIndex(depths, 1.0));\n        assertEquals(1, CoordinateUtils.findMinDepthIndex(depths, 1.1));\n        assertEquals(2, CoordinateUtils.findMinDepthIndex(depths, 2.0));\n        assertEquals(2, CoordinateUtils.findMinDepthIndex(depths, 2.1));\n        assertEquals(3, CoordinateUtils.findMinDepthIndex(depths, 3.0));\n        assertEquals(3, CoordinateUtils.findMinDepthIndex(depths, 3.1));\n        assertEquals(4, CoordinateUtils.findMinDepthIndex(depths, 4.0));\n        assertEquals(4, CoordinateUtils.findMinDepthIndex(depths, 4.1));\n        assertEquals(5, CoordinateUtils.findMinDepthIndex(depths, 5.0));\n        assertEquals(5, CoordinateUtils.findMinDepthIndex(depths, 5.1));\n        assertEquals(6, CoordinateUtils.findMinDepthIndex(depths, 6.0));\n        assertEquals(6, CoordinateUtils.findMinDepthIndex(depths, 6.1));\n        assertEquals(7, CoordinateUtils.findMinDepthIndex(depths, 7.0));\n        assertEquals(7, CoordinateUtils.findMinDepthIndex(depths, 7.1));\n        assertEquals(8, CoordinateUtils.findMinDepthIndex(depths, 8.0));\n        assertEquals(8, CoordinateUtils.findMinDepthIndex(depths, 8.1));\n        assertEquals(9, CoordinateUtils.findMinDepthIndex(depths, 9.0));\n        assertEquals(9, CoordinateUtils.findMinDepthIndex(depths, 9.1));\n        assertEquals(10, CoordinateUtils.findMinDepthIndex(depths, 10.0));\n        assertEquals(10, CoordinateUtils.findMinDepthIndex(depths, 10.1));\n        assertEquals(10, CoordinateUtils.findMinDepthIndex(depths, 11.0));\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "54138284_1", "part": [1, 1], "seq": [1, 1], "prompt": "class DefaultTemplateResolver implements TemplateResolver {\n\n    protected URL resourceUrl(String templateName, Class<?> viewType) {\n        String path = relativeResourcePath(templateName, viewType);\n        return templateBase.getUrl(path);\n    }\n\n    public  DefaultTemplateResolver(FolderResourceFactory templateBase, Charset templateEncoding);\n\n    @Override public Template resolve(String templateName, Class<?> viewType);\n    protected String relativeResourcePath(String templateName, Class<?> viewType);\n\n    private static final Charset DEFAULT_CHARSET;\n\n}\n\nclass DefaultTemplateResolverTest {\n\n    private static final Charset DEFAULT_CHARSET;\n\n    @Test\n    public void testResourcePath_FilePathBase() throws IOException {\n", "reference": "\n        DefaultTemplateResolver resolver = resolver(\"/tmp\");\n\n        File canonical = new File(\"/tmp/io/bootique/mvc/resolver/tName.txt\").getCanonicalFile();\n\n        assertEquals(canonical.toURI().toURL(),\n                resolver.resourceUrl(\"tName.txt\", DefaultTemplateResolverTest.class));\n        assertEquals(canonical.toURI().toURL(),\n                resolver.resourceUrl(\"/tName.txt\", DefaultTemplateResolverTest.class));\n    }\n\n}", "prediction": "        DefaultTemplateResolver resolver = new DefaultTemplateResolver(new FileResourceFactory(new File(\"src/test/resources\")), DEFAULT_CHARSET);\n        URL url = resolver.resourceUrl(\"test.txt\", DefaultTemplateResolverTest.class);\n        assertNotNull(url);\n        assertEquals(\"file:/src/test/resources/test.txt\", url.toString());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "55954702_4", "part": [1, 1], "seq": [1, 1], "prompt": "class SaveBmiService extends IntentService {\n\n    @Override\n    protected void onHandleIntent(Intent intent) {\n        if (intent == null) {\n            return;\n        }\n\n        Serializable extra = intent.getSerializableExtra(PARAM_KEY_BMI_VALUE);\n        if (extra == null || !(extra instanceof BmiValue)) {\n            return;\n        }\n\n        BmiValue bmiValue = (BmiValue)extra;\n        boolean result = saveToRemoteServer(bmiValue);\n        sendLocalBroadcast(result);\n    }\n\n    public  SaveBmiService();\n\n    @Override public void onCreate();\n    @VisibleForTesting boolean saveToRemoteServer(BmiValue bmiValue);\n    @VisibleForTesting void sendLocalBroadcast(boolean result);\n    @VisibleForTesting void setLocalBroadcastManager(LocalBroadcastManager manager);\n    public static void start(Context context, BmiValue bmiValue);\n\n}\n\nclass SaveBmiServiceTest {\n\n    @Test\n    public void onHandleIntent\u306bBmiValue\u578b\u4ee5\u5916\u306e\u30c7\u30fc\u30bf\u304c\u5165\u3063\u305fIntent\u3092\u6e21\u3057\u305f\u3089\u4f55\u3082\u3057\u306a\u3044() {\n", "reference": "        Intent intent = mock(Intent.class);\n        when(intent.getSerializableExtra(SaveBmiService.PARAM_KEY_BMI_VALUE)).thenReturn(\"hoge\");\n\n        SaveBmiService service = spy(new SaveBmiService());\n        service.onHandleIntent(intent);\n        verify(service, never()).sendLocalBroadcast(anyBoolean());\n        verify(service, never()).saveToRemoteServer((BmiValue)any());\n    }\n\n}", "prediction": "        Intent intent = new Intent();\n        intent.putExtra(SaveBmiService.PARAM_KEY_BMI_VALUE, \"\");\n\n        SaveBmiService service = new SaveBmiService();\n        service.onHandleIntent(intent);\n\n        verify(service, never()).saveToRemoteServer(any(BmiValue.class));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "55955301_2", "part": [1, 1], "seq": [1, 1], "prompt": "class PortfolioServiceImpl implements PortfolioService {\n\n  @Override\n  public void buy(int amount, JsonObject quote, Handler<AsyncResult<Portfolio>> resultHandler) {\n    if (amount <= 0) {\n      resultHandler.handle(Future.failedFuture(\"Cannot buy \" + quote.getString(\"name\") + \" - the amount must be \" +\n          \"greater than 0\"));\n    }\n\n    if (quote.getInteger(\"shares\") < amount) {\n      resultHandler.handle(Future.failedFuture(\"Cannot buy \" + amount + \" - not enough \" +\n          \"stocks on the market (\" + quote.getInteger(\"shares\") + \")\"));\n    }\n\n    double price = amount * quote.getDouble(\"ask\");\n    String name = quote.getString(\"name\");\n    // 1) do we have enough money\n    if (portfolio.getCash() >= price) {\n      // Yes, buy it\n      portfolio.setCash(portfolio.getCash() - price);\n      int current = portfolio.getAmount(name);\n      int newAmount = current + amount;\n      portfolio.getShares().put(name, newAmount);\n      sendActionOnTheEventBus(\"BUY\", amount, quote, newAmount);\n      resultHandler.handle(Future.succeededFuture(portfolio));\n    } else {\n      resultHandler.handle(Future.failedFuture(\"Cannot buy \" + amount + \" of \" + name + \" - \" + \"not enough money, \" +\n          \"need \" + price + \", has \" + portfolio.getCash()));\n    }\n  }\n\n  public  PortfolioServiceImpl(Vertx vertx, ServiceDiscovery discovery, double initialCash);\n\n  @Override public void getPortfolio(Handler<AsyncResult<Portfolio>> resultHandler);\n  private void sendActionOnTheEventBus(String action, int amount, JsonObject quote, int newAmount);\n  @Override public void evaluate(Handler<AsyncResult<Double>> resultHandler);\n  private void computeEvaluation(WebClient webClient, Handler<AsyncResult<Double>> resultHandler);\n  private Future<Double> getValueForCompany(WebClient client, String company, int numberOfShares);\n  @Override public void sell(int amount, JsonObject quote, Handler<AsyncResult<Portfolio>> resultHandler);\n  private static String encode(String value);\n\n  private Vertx vertx;\n  private PortfolioService service;\n  private Portfolio original;\n\n}\n\nclass PortfolioServiceImplTest {\n\n  private Vertx vertx;\n  private PortfolioService service;\n  private Portfolio original;\n\n  @Test\n  public void testThatYouCannotBuyIfThereIsNotEnoughShare(TestContext tc) {\n", "reference": "    Async async = tc.async();\n    service.buy(100, quote(\"A\", 10, 20, 10), ar -> {\n      tc.assertTrue(ar.failed());\n      tc.assertTrue(ar.cause().getMessage().contains(\"not enough stocks\"));\n      async.complete();\n    });\n  }\n\n}", "prediction": "   Async async = tc.async();\n    service.buy(100, new JsonObject().put(\"name\", \"IBM\").put(\"shares\", 10).put(\"ask\", 100),\n        result -> {\n          tc.assertTrue(result.failed());\n          async.complete();\n        });\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "56089333_1", "part": [1, 1], "seq": [1, 1], "prompt": "class LegofyPicassoTransformation implements Transformation {\n\n    @Override\n    public String key() {\n        return LEGOFY;\n    }\n\n    public  LegofyPicassoTransformation(Context context);\n\n    @Override public Bitmap transform(Bitmap source);\n\n    @Mock\n    private Context mockContext;\n    private LegofyPicassoTransformation legofyPicassoTransformation;\n\n}\n\nclass LegofyPicassoTransformationTest {\n\n    @Mock\n    private Context mockContext;\n    private LegofyPicassoTransformation legofyPicassoTransformation;\n\n    @Test\n    public void shouldReturnKey() throws Exception {\n", "reference": "        String key = legofyPicassoTransformation.key();\n\n        assertThat(key).isEqualTo(LegofyPicassoTransformation.LEGOFY);\n    }\n\n}", "prediction": "        assertThat(legofyPicassoTransformation.key(), is(LEGOFY));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "56342300_1", "part": [1, 1], "seq": [1, 1], "prompt": "class DroolsDescriptionService implements DescriptionService {\n\n\t@Override\n\tpublic Set<String> getFSNs(Set<String> conceptIds, String... languageRefsetIds) {\n\t\tSet<String> fsns = new HashSet<>();\n\t\tfor (String conceptId : conceptIds) {\n\t\t\tDroolsConcept concept = repository.getConcept(conceptId);\n\t\t\tif(concept != null) {\n\t\t\t\tCollection<DroolsDescription> descriptions = concept.getDescriptions();\n\t\t\t\tfor (DroolsDescription description : descriptions) {\n\t\t\t\t\tif (description.isActive() && description.getTypeId().equals(FULLY_SPECIFIED_NAME)) {\n\t\t\t\t\t\tif(languageRefsetIds != null && languageRefsetIds.length > 0) {\n\t\t\t\t\t\t\tfor (String languageRefsetId : languageRefsetIds) {\n\t\t\t\t\t\t\t\tif (PREFERRED_ACCEPTABILITY.equals(description.getAcceptabilityMap().get(languageRefsetId))) {\n\t\t\t\t\t\t\t\t\tfsns.add(description.getTerm());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfsns.add(description.getTerm());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn fsns;\n\t}\n\n\tpublic  DroolsDescriptionService(SnomedDroolsComponentRepository repository, TestResourceProvider testResourceProvider);\n\n\t@Override public Set<Description> findActiveDescriptionByExactTerm(String exactTerm);\n\t@Override public Set<Description> findInactiveDescriptionByExactTerm(String exactTerm);\n\t@Override // FIXME: Currently only finds matching description in ancestors. // Should search all descendants of the second highest ancestor (the ancestor which is a direct child of root). public Set<Description> findMatchingDescriptionInHierarchy(Concept concept, Description description);\n\t@Override public String getCaseSensitiveWordsErrorMessage(Description description);\n\t@Override public String getLanguageSpecificErrorMessage(Description description);\n\t@Override public Set<String> findParentsNotContainingSemanticTag(Concept concept, String termSematicTag, String... languageRefsetIds);\n\t@Override public boolean isRecognisedSemanticTag(String termSemanticTag);\n\tpublic DroolsDescriptionIndex getDroolsDescriptionIndex();\n\n    private DroolsDescriptionService droolsDescriptionService;\n\n}\n\nclass DroolsDescriptionServiceTest  {\n\n    private DroolsDescriptionService droolsDescriptionService;\n\n    @Test\n    public void testFindFSNs() {\n", "reference": "        repository.getConcept(\"1263005\").getDescriptions().stream()\n                .filter(d -> ConceptConstants.FSN.equals(d.getTypeId()))\n                .forEach(d -> d.getAcceptabilityMap().put(ConceptConstants.US_EN_LANGUAGE_REFERENCE_SET, Constants.ACCEPTABILITY_PREFERRED));\n\n        Set<String> conceptsIds = new HashSet<>();\n        conceptsIds.add(\"1263005\");\n        Set<String> results = droolsDescriptionService.getFSNs(conceptsIds, ConceptConstants.US_EN_LANGUAGE_REFERENCE_SET);\n        Assert.assertEquals(1, results.size());\n        for (String result : results) {\n            Assert.assertEquals(\"Distinctive arrangement of microtubules (cell structure)\", result);\n        }\n\n    }\n\n}", "prediction": "        Set<String> fsns = droolsDescriptionService.getFSNs(new HashSet<>(Arrays.asList(\"10000100\", \"10000200\", \"10000300\")), \"900000000000509007\");\n        assertEquals(3, fsns.size());\n        assertTrue(fsns.contains(\"Fully specified name (finding)\"));\n        assertTrue(fsns.contains(\"Fully specified name (finding) [900000000000509007]\"));\n        assertTrue(fsns.contains(\"Fully specified name (finding) [900000000000509007] [900000000000509007]\"));\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "56587374_22", "part": [1, 1], "seq": [1, 1], "prompt": "class Output implements Verifiable {\n\n    public void setOutputProperty(final String key, final String value) throws InvalidSyntaxException {\n        outputProperties.defineProperty(key, value);\n    }\n\n    public  Output();\n\n    public void setRelativeTo(String relativeTo);\n    public void setRelativePath(String relativePath);\n    public void setAbsolute(String absolute);\n    public void setPrefix(String prefix);\n    public void setSuffix(String suffix);\n    public void setName(String name);\n    private boolean isAbsolute();\n    public void setNull(final boolean nullOutput);\n    public void setOutputProperties(final Properties props);\n    public void unsetOutputProperty(final String key);\n    public boolean isNullOutput();\n    public Properties getOutputProperties();\n    public String getOutputProperty(final String key);\n    public File getDestinationFile(File sourceFile, HashMap<QName,ParameterValue> parameters);\n    private String getFileName(File sourceFile, HashMap<QName,ParameterValue> parameters);\n    @Override public void verify();\n    @Override public String toString();\n    public String toString(final String prefix);\n    public String getConsole();\n    public void setConsole(String console);\n    public boolean isConsoleOutput();\n    public String getId();\n    public void setId(String id);\n\n    private Output output;\n    private static HashMap<QName,ParameterValue> emptyInputParams;\n    private static SaxonConfigurationFactory configFactory;\n\n}\n\nclass OutputTest {\n\n    private Output output;\n    private static HashMap<QName,ParameterValue> emptyInputParams;\n    private static SaxonConfigurationFactory configFactory;\n\n    @Test\n    public void addValidProperties() throws InvalidSyntaxException {\n", "reference": "        output.setOutputProperty(\"byte-order-mark\", \"yes\");\n        output.setOutputProperty(\"byte-order-mark\", \"no\");\n        output.setOutputProperty(\"cdata-section-elements\", \"{fr:efl:inneo}pNonNum\");\n        output.setOutputProperty(\"doctype-public\", \"about:legacy-compat\");\n        output.setOutputProperty(\"doctype-system\", \"\");\n        output.setOutputProperty(\"encoding\", \"UTF-32\");\n        output.setOutputProperty(\"escape-uri-attributes\", \"yes\");\n        output.setOutputProperty(\"escape-uri-attributes\", \"no\");\n        output.setOutputProperty(\"include-content-type\", \"yes\");\n        output.setOutputProperty(\"include-content-type\", \"no\");\n        output.setOutputProperty(\"indent\", \"yes\");\n        output.setOutputProperty(\"indent\", \"no\");\n        output.setOutputProperty(\"media-type\",\"application/xml\");\n        output.setOutputProperty(\"method\", \"xml\");\n        output.setOutputProperty(\"method\", \"xhtml\");\n        output.setOutputProperty(\"method\", \"html\");\n        output.setOutputProperty(\"method\", \"text\");\n        output.setOutputProperty(\"normalization-form\", \"NFC\");\n        output.setOutputProperty(\"normalization-form\", \"NFD\");\n        output.setOutputProperty(\"normalization-form\", \"NFKC\");\n        output.setOutputProperty(\"normalization-form\", \"NFKD\");\n        output.setOutputProperty(\"normalization-form\", \"none\");\n        output.setOutputProperty(\"omit-xml-declaration\", \"yes\");\n        output.setOutputProperty(\"omit-xml-declaration\", \"no\");\n        output.setOutputProperty(\"saxon-attribute-order\", \"{}id\");\n        output.setOutputProperty(\"saxon-character-representation\", \"decimal\");\n        output.setOutputProperty(\"saxon-double-space\", \"{}docNiv\");\n        output.setOutputProperty(\"saxon-implicit-result-document\", \"ben, Je sais pas quoi mettre\");\n        output.setOutputProperty(\"saxon-indent-spaces\", \"4\");\n        output.setOutputProperty(\"saxon-line-length\", \"140\");\n        output.setOutputProperty(\"saxon-recognize-binary\", \"yes\");\n        output.setOutputProperty(\"saxon-recognize-binary\", \"no\");\n        output.setOutputProperty(\"saxon-suppress-inndentation\", \"{}pNonNum\");\n        output.setOutputProperty(\"standalone\", \"yes\");\n        output.setOutputProperty(\"standalone\", \"no\");\n        output.setOutputProperty(\"undeclare-prefixes\", \"#all\");\n        output.setOutputProperty(\"use-character-maps\", \"myCm,yourCm\");\n        output.setOutputProperty(\"version\",\"1.0\");\n        output.setOutputProperty(\"version\",\"1.1\");\n        // on veut juste pas d'exception\n        assertTrue(true);\n    }\n\n}", "prediction": "        output.setOutputProperty(\"key\", \"value\");\n        assertEquals(\"value\", output.getOutputProperty(\"key\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "56736842_2", "part": [1, 1], "seq": [1, 1], "prompt": "class GetUserList extends UseCase {\n\n\t@Override protected Observable buildUseCaseObservable() {\n\t\t// \u5f53\u8c03\u7528\u7236\u7c7bUseCase.execute()\u65b9\u6cd5\u65f6\uff0c\u89e6\u53d1\u672c\u65b9\u6cd5\uff0c\u5e76\u6307\u5411\u5b50\u7c7b\u7684\u5b9e\u73b0\uff1b\n\t\treturn userRepository.user(); // UserRepository\u662f\u6570\u636e\u5c42\u5b9e\u73b0\u7684\uff0c\u5f53\u8c03\u7528users()\n\t\t// \u65b9\u6cd5\u65f6\uff0c\u4f1a\u8c03\u7528data\u5c42\u7684\u5b9e\u73b0\uff0c\u5e76\u8fd4\u56de\u7ed9\u8c03\u7528\u8be5\u65b9\u6cd5\u7684\u4eba\uff0c\u4e3b\u8981\u7528\u4e8e\u83b7\u53d6data\u5c42\u6570\u636e\u5e76\u8f6c\u6362\u6210User\u7c7b\u578b\n\t}\n\n\t@Inject public  GetUserList(UserRepository userRepository,ThreadExecutor threadExecutor,\n\t\t\t\t\tPostExecutionThread postExecutionThread);\n\n\tprivate GetUserList getUserList;\n\t@Mock private UserRepository mockUserRepository;\n\t@Mock private ThreadExecutor mockThreadExecutor;\n\t@Mock private PostExecutionThread mockExecutionThread;\n\n}\n\nclass GetUserListTest {\n\n\tprivate GetUserList getUserList;\n\t@Mock private UserRepository mockUserRepository;\n\t@Mock private ThreadExecutor mockThreadExecutor;\n\t@Mock private PostExecutionThread mockExecutionThread;\n\n\t@Test public void testGetUserListUseCaseObservableHappyCase() {\n", "reference": "\t\tgetUserList.buildUseCaseObservable();\n\n\t\t// 1. \u9a8c\u8bc1\u7684\u57fa\u672c\u65b9\u6cd5: verify(mock).someMethod(\u2026)\u6765\u9a8c\u8bc1\u65b9\u6cd5\u7684\u8c03\u7528\n\t\tverify(mockUserRepository).user();\n\t\t//        verify(mockUserRepository).user(1); // worry way\n\t\t// 2. \u9a8c\u8bc1\u672a\u66fe\u6267\u884c\u7684\u65b9\u6cd5: \u786e\u5b9auser(1)\u8fd9\u4e2a\u6784\u9020\u65b9\u6cd5\u6ca1\u6709\u88ab\u6267\u884c\n\t\tverify(mockUserRepository,never()).user(1);\n\t\t// 3. \u67e5\u8be2\u591a\u4f59\u7684\u65b9\u6cd5\u8c03\u7528 verifyNoMoreInteractions()\u65b9\u6cd5\u53ef\u4ee5\u4f20\u5165\u591a\u4e2amock\u5bf9\u8c61\u4f5c\u4e3a\u53c2\u6570\n\t\tverifyNoMoreInteractions(mockUserRepository);\n\t\t// 4. \u67e5\u8be2\u6ca1\u6709\u4ea4\u4e92\u7684mock\u5bf9\u8c61: verifyZeroInteractions()\u4e5f\u662f\u4e00\u4e2a\u6d4b\u8bd5\u5de5\u5177\uff0c\u6e90\u7801\u548cverifyNoMoreInteractions()\n\t\t// \u7684\u5b9e\u73b0\u662f\u4e00\u6837\u7684\uff0c\u4e3a\u4e86\u63d0\u9ad8\u903b\u8f91\u7684\u53ef\u8bfb\u6027\uff0c\u6240\u4ee5\u53ea\u4e0d\u8fc7\u540d\u5b57\u4e0d\u540c\u3002\n\t\t// \u672c\u4f8b\u4e2d\u7528\u6765\u786e\u8ba4\u4f20\u5165\u7684\u5bf9\u8c61\u6ca1\u6709\u4efb\u4f55\u4ea4\u4e92\n\t\tverifyZeroInteractions(mockThreadExecutor);\n\t\tverifyZeroInteractions(mockExecutionThread);\n\n\t}\n\n}", "prediction": "\t\t// Given\n\t\twhen(mockUserRepository.user()).thenReturn(Observable.just(new User()));\n\t\t// When\n\t\tTestSubscriber<User> testSubscriber = new TestSubscriber<>();\n\t\tgetUserList.execute().subscribe(testSubscriber);\n\t\t// Then\n\t\ttestSubscriber.assertNoErrors();\n\t\ttestSubscriber.assertCompleted();\n\t\ttestSubscriber.assertValueCount(1);\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "57061988_103", "part": [1, 1], "seq": [1, 1], "prompt": "class RetryingEncryptionService {\n\n  public String decrypt(final EncryptedValue encryptedValue)\n    throws Exception {\n    LOGGER.info(\"Attempting decrypt\");\n    return retryOnErrorWithRemappedKey(() -> {\n      final EncryptionKey key = keySet.get(encryptedValue.getEncryptionKeyUuid());\n\n      if (key == null) {\n        throw new KeyNotFoundException(ErrorMessages.MISSING_ENCRYPTION_KEY);\n      }\n      return key.decrypt(encryptedValue.getEncryptedValue(), encryptedValue.getNonce());\n    });\n  }\n\n  @Autowired public  RetryingEncryptionService(final EncryptionKeySet keySet);\n\n  public EncryptedValue encrypt(final String value);\n  protected void setNeedsReconnectFlag();\n  private T retryOnErrorWithRemappedKey(final ThrowingFunction<T> operation);\n  private T withPreventReconnectLock(final ThrowingSupplier<T> operation);\n  private void withPreventCryptoLock(final ThrowingRunnable runnable);\n  private void clearNeedsReconnectFlag();\n\n  private RetryingEncryptionService subject;\n  private ReentrantReadWriteLock.ReadLock readLock;\n  private ReentrantReadWriteLock.WriteLock writeLock;\n  private LunaEncryptionService encryptionService;\n  private UUID activeKeyUuid;\n  private ReentrantReadWriteLock readWriteLock;\n  private EncryptionKeySet keySet;\n  private EncryptionKey firstActiveKey;\n  private EncryptionKey secondActiveKey;\n\n}\n\nclass RetryingEncryptionServiceTest {\n\n  private RetryingEncryptionService subject;\n  private ReentrantReadWriteLock.ReadLock readLock;\n  private ReentrantReadWriteLock.WriteLock writeLock;\n  private LunaEncryptionService encryptionService;\n  private UUID activeKeyUuid;\n  private ReentrantReadWriteLock readWriteLock;\n  private EncryptionKeySet keySet;\n  private EncryptionKey firstActiveKey;\n  private EncryptionKey secondActiveKey;\n\n  @Test\n  public void decrypt_locksAndUnlocksTheReconnectLockWhenLoginError() throws Exception {\n", "reference": "    when(keySet.get(activeKeyUuid))\n      .thenReturn(firstActiveKey);\n\n    when(firstActiveKey.decrypt(any(byte[].class), any(byte[].class)))\n      .thenThrow(new ProviderException(\"function 'C_GenerateRandom' returns 0x30\"));\n    reset(writeLock);\n    doThrow(new RuntimeException()).when(encryptionService)\n      .reconnect(any(Exception.class));\n\n    try {\n      subject.decrypt(new EncryptedValue(activeKeyUuid, \"an encrypted value\".getBytes(UTF_8), \"a nonce\".getBytes(UTF_8)));\n    } catch (final IllegalBlockSizeException | RuntimeException e) {\n      // expected\n    }\n\n    verify(readLock, times(2)).lock();\n    verify(readLock, times(2)).unlock();\n\n    verify(writeLock, times(1)).lock();\n    verify(writeLock, times(1)).unlock();\n  }\n\n}", "prediction": "    final EncryptedValue encryptedValue = new EncryptedValue(\"encryptedValue\", \"nonce\", \"keyUuid\");\n    final EncryptionKey key = new EncryptionKey(\"key\", \"keyUuid\");\n    keySet.addKey(key);\n\n    final RuntimeException exception = new RuntimeException(\"login error\");\n    when(encryptionService.decrypt(encryptedValue)).thenThrow(exception);\n\n    assertThatThrownBy(() -> subject.decrypt(encryptedValue))\n      .isEqualTo(exception);\n\n    verify(readLock).lock();\n    verify(readLock).unlock();\n  }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "57110085_0", "part": [1, 1], "seq": [1, 1], "prompt": "class PatientEntityToDetailsTransformer implements Transformer<PatientEntity, PatientDetails> {\n\n    @Override\n    public PatientDetails transform(final PatientEntity patientEntity) {\n        final PatientDetails patient = new PatientDetails();\n\n\n        String[] address = new String[]{StringUtils.trimToNull(patientEntity.getAddress1()),\n            StringUtils.trimToNull(patientEntity.getAddress2()),\n            StringUtils.trimToNull(patientEntity.getAddress3()),\n            StringUtils.trimToNull(patientEntity.getAddress4()),\n            StringUtils.trimToNull(patientEntity.getAddress5())};\n\n        final String name = patientEntity.getFirstName() + \" \" + patientEntity.getLastName();\n        final String patientId = patientEntity.getNhsNumber();\n\n        patient.setId(String.valueOf(patientEntity.getId()));\n        patient.setName(name);\n        patient.setTitle(patientEntity.getTitle());\n        patient.setForename(patientEntity.getFirstName());\n        patient.setSurname(patientEntity.getLastName());\n        patient.setGender(patientEntity.getGender());\n        patient.setDateOfBirth(patientEntity.getDateOfBirth());\n        patient.setNhsNumber(patientId);\n        patient.setPasNumber(patientEntity.getPasNumber());\n        patient.setAddress(address);\n        patient.setPostcode(patientEntity.getPostcode());\n        patient.setTelephone(patientEntity.getPhone());\n        patient.setPasNumber(patientEntity.getPasNumber());\n        patient.setLastUpdated(patientEntity.getLastUpdated());\n        patient.setRegistrationStartDateTime(patientEntity.getRegistrationStartDateTime());\n        patient.setRegistrationEndDateTime(patientEntity.getRegistrationEndDateTime());\n        patient.setRegistrationStatus(patientEntity.getRegistrationStatus());\n        patient.setRegistrationType(patientEntity.getRegistrationType());\n        patient.setMaritalStatus(patientEntity.getMaritalStatus());\n        patient.setManagingOrganization(patientEntity.getManagingOrganization());\n\n        PractitionerEntity gp = patientEntity.getPractitioner();\n\n        if (gp != null) {\n            patient.setGpDetails(gp.getNamePrefix() + \" \" + gp.getNameGiven() + \" \" + gp.getNameFamily());\n            patient.setGpId(gp.getId());\n        }\n\n        Date deceased = patientEntity.getDeceasedDateTime();\n        if (deceased != null) {\n            patient.setDeceased(deceased);\n        }\n\n        patient.setSensitive(patientEntity.isSensitive());\n        \n        populateTelecoms(patient, patientEntity);\n\n        return patient;\n    }\n\n    private void populateTelecoms(PatientDetails patientDetails, PatientEntity patientEntity);\n\n    private static final String PATIENT_ID;\n    private PatientEntityToDetailsTransformer transformer;\n\n}\n\nclass PatientEntityToDetailsTransformerTest {\n\n    private static final String PATIENT_ID;\n    private PatientEntityToDetailsTransformer transformer;\n\n    @Test\n    public void shouldRemoveEmptyLinesFromAddressString() {\n", "reference": "        final PatientEntity patientEntity = dummyPatientEntity();\n\n        patientEntity.setAddress1(\"line 1\");\n        patientEntity.setAddress2(null);\n        patientEntity.setAddress3(\"line 3\");\n        patientEntity.setAddress5(\"\");\n        patientEntity.setAddress5(\"line 5\");\n        patientEntity.setPostcode(\"postcode\");\n\n        final PatientDetails patientDetails = transformer.transform(patientEntity);\n\n        assertNotNull(patientDetails);\n        // TODO Commented out for 1.2.2 build. Need to check this, get Address now returns an array of 5 strings one per line\n        // Changes at 1.2.2 remove the use of teh text field and stupulate a more strcutured address so this test no longer applies\n        //assertEquals(\"line 1, line 3, postcode\", patientDetails.getAddress());\n    }\n\n}", "prediction": "        final PatientEntity patientEntity = new PatientEntity();\n        patientEntity.setAddress1(\"\");\n        patientEntity.setAddress2(\"\");\n        patientEntity.setAddress3(\"\");\n        patientEntity.setAddress4(\"\");\n        patientEntity.setAddress5(\"\");\n\n        final PatientDetails patient = transformer.transform(patientEntity);\n\n        assertThat(patient.getAddress(), is(new String[]{}));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "59118773_26", "part": [1, 1], "seq": [1, 1], "prompt": "class ClassFieldsExcelExport implements ClassFields {\n\n    @Override\n    public Iterator<Field> getFields() {\n        final Iterable<Field> originalFields = () -> this.original.getFields();\n\n        // return only classes that are annotated with @ExcelExport\n        final Iterator<Field> fields = StreamSupport.stream(originalFields.spliterator(), false)\n                .filter(field -> field.getAnnotation(ExcelExport.class) != null)\n                .filter(this::filterByClass)\n                .iterator();\n\n        return fields;\n    }\n\n    public  ClassFieldsExcelExport(final ClassFields classFields);\n\n    private boolean filterByClass(final Field field);\n    @Override public Class getClazz();\n\n}\n\nclass ClassFieldsExcelExportTest {\n\n    @Test\n    public void getFields() throws Exception {\n", "reference": "        final String[] expectedFields = {\"id\", \"label\"};\n\n        final ClassFields classFields = new ClassFieldsExcelExport(\n                new ClassFieldsDefault(TestClass.class)\n        );\n        final Iterator<Field> fields = classFields.getFields();\n\n        final List<String> actualFields = new ArrayList<>();\n        while (fields.hasNext()) {\n            final Field f = fields.next();\n            actualFields.add(f.getName());\n        }\n\n        Assert.assertArrayEquals(\"Check declared @ExcelExport fields\", expectedFields, actualFields.toArray());\n    }\n\n}", "prediction": "        final ClassFields classFields = new ClassFieldsExcelExport(new ClassFieldsImpl(ClassWithExcelExport.class));\n\n        final Iterator<Field> fields = classFields.getFields();\n\n        assertTrue(fields.hasNext());\n        assertEquals(\"field1\", fields.next().getName());\n        assertTrue(fields.hasNext());\n        assertEquals(\"field2\", fields.next().getName());\n        assertFalse(fields.hasNext());\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "59216067_0", "part": [1, 1], "seq": [1, 1], "prompt": "class Mocker {\n\n    public T mock() {\n        return mock(0);\n    }\n\n    public  Mocker(Class<T> clazz);\n    public  Mocker(Mocker<T> mocker);\n\n    public Mocker<T> when(Func1<T, R> when);\n    public Mocker<T> when(Func2<T, Integer, R> when);\n    public Mocker<T> thenReturn(Func1<T, R> thenReturn);\n    public Mocker<T> thenReturn(Func2<T, Integer, R> thenReturn);\n    public static Mocker<V> of(Class<V> clazz);\n    public T mock(int i);\n    @SuppressWarnings(\"unchecked\") public static V mock(Class<V> clazz);\n    public static Mocker<V> mocker(Class<V> clazz);\n    public Mocker<T> then(Action1<T> then);\n    public Mocker<T> then(Action2<T, Integer> then);\n    public Mocker<T> lift();\n    public Mocker<T> safeLift();\n    public Mocker<T> lift(Mocker<T> mocker);\n    public List<T> asList();\n    public List<T> asList(int many);\n    public Mocker<T> times(int times);\n    public Mocker<T> atLeast(int atLeast);\n    public Mocker<T> atMost(int atMost);\n    public Mocker<T> never();\n    public Mocker<T> atLeastOnce();\n    public Mocker<T> verify(Action1<T> verify);\n    public Mocker<T> verify(Action2<T, Integer> verify);\n    public T never(Action1<T> verify);\n    public T times(Action1<T> verify, int i);\n\n}\n\nclass MockerTest {\n\n    @Test\n    public void testMock() {\n", "reference": "        List mock = mock(List.class);\n        when(mock.size()).thenReturn(3);\n\n        assertThat(mock.size()).isEqualTo(3);\n    }\n\n}", "prediction": "        Mocker<String> mocker = Mocker.of(String.class);\n        mocker.when(String::length).thenReturn(String::length);\n        assertEquals(0, mocker.mock().length());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "59288941_4", "part": [1, 1], "seq": [1, 1], "prompt": "class ELFunction implements PartitionFunction {\n\n    public Integer execute(String columnValue, Map<String, Object> extension) {\n        Map<String, Object> vrs = new HashMap<String, Object>();\n        //, Map<String, ElFunction<?,?>> functionMap\n        //vrs.putAll(functionMap);// \u62d3\u5c55\u51fd\u6570\n        Map<String, Object> params = new HashMap<String, Object>();\n        params.put(\"value\", columnValue);\n        vrs.put(\"$ROOT\", params);\n        VariableResolverFactory vrfactory = new MapVariableResolverFactory(vrs);\n        return MVEL.eval(expression, params, vrfactory, Integer.class);\n    }\n\n    public void setExpression(String expression);\n    @Override public String toString();\n\n}\n\nclass ELFunctionTest {\n\n    @Test\n    public void testExecute() throws Exception {\n", "reference": "        ELFunction rule = new ELFunction();\n        rule.setExpression(\"user_id % 4\");\n\n        Object result = rule.execute(\"1\", null);\n\n        System.out.println(result);\n    }\n\n}", "prediction": "        ELFunction function = new ELFunction();\n        function.setExpression(\"$ROOT.value.length()\");\n        assertEquals(Integer.valueOf(10), function.execute(\"1234567890\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "59507570_144", "part": [1, 1], "seq": [1, 1], "prompt": "class IncidentPresenter extends RecordPresenter {\n\n    public boolean isFormReady() {\n        return incidentFormService.isReady();\n    }\n\n    @Inject public  IncidentPresenter(IncidentFormService incidentFormService);\n\n    @Mock IncidentFormService incidentFormService;\n    @InjectMocks IncidentPresenter incidentPresenter;\n\n}\n\nclass IncidentPresenterTest {\n\n    @Mock IncidentFormService incidentFormService;\n    @InjectMocks IncidentPresenter incidentPresenter;\n\n    @Test\n    public void should_return_false_when_incident_form_not_ready() throws Exception {\n", "reference": "        when(incidentFormService.isReady()).thenReturn(false);\n\n        assertThat(\"Should return false\", incidentPresenter.isFormReady(), is(false));\n        verify(incidentFormService, times(1)).isReady();\n    }\n\n}", "prediction": "       when(incidentFormService.isReady()).thenReturn(false);\n        assertThat(incidentPresenter.isFormReady(), is(false));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "60201162_10", "part": [1, 1], "seq": [1, 1], "prompt": "class KafkaClusterObserver implements Closeable {\n\n  public KafkaClusterObserver(String bootstrapServer) {\n    Properties properties = new Properties();\n    properties.setProperty(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServer);\n    properties.setProperty(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, String.valueOf(false));\n    properties.setProperty(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG,\n        DESERIALIZER_CLASS);\n    properties.setProperty(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG,\n        DESERIALIZER_CLASS);\n    this.kafkaConsumer = new KafkaConsumer(properties);\n  }\n\n  public  KafkaClusterObserver(String bootstrapServer);\n  @VisibleForTesting protected  KafkaClusterObserver(KafkaConsumer kafkaConsumer);\n\n  public Map<TopicPartition, Integer> findLeaderForPartitions(\n      List<TopicPartition> topicPartitions);\n  private Integer findLeaderId(TopicPartition topicPartition,\n      List<PartitionInfo> partitionInfoList);\n  @Override public void close();\n\n  private final KafkaConsumer kafkaConsumer;\n  private final KafkaClusterObserver observer;\n  private String testTopic1;\n  private final List<PartitionInfo> partitionInfo1;\n  private String testTopic2;\n  private final List<PartitionInfo> partitionInfo2;\n  private Map<TopicPartition, Integer> mockPartitionLeaderMap;\n\n}\n\nclass KafkaClusterObserverTest {\n\n  private final KafkaConsumer kafkaConsumer;\n  private final KafkaClusterObserver observer;\n  private String testTopic1;\n  private final List<PartitionInfo> partitionInfo1;\n  private String testTopic2;\n  private final List<PartitionInfo> partitionInfo2;\n  private Map<TopicPartition, Integer> mockPartitionLeaderMap;\n\n  @Test\n  public void testKafkaClusterObserver() {\n", "reference": "    EasyMock.reset(kafkaConsumer);\n\n    TopicPartition tp1 = new TopicPartition(testTopic1, 1);\n    TopicPartition tp2 = new TopicPartition(testTopic2, 1);\n    Map<String, List<PartitionInfo>> partitionInfoMap = new HashMap<>();\n    partitionInfoMap.put(testTopic1, partitionInfo1);\n    partitionInfoMap.put(testTopic2, partitionInfo2);\n\n    EasyMock.expect(kafkaConsumer.listTopics()).andReturn(partitionInfoMap);\n    EasyMock.replay(kafkaConsumer);\n\n    Map<TopicPartition, Integer> result =\n        observer.findLeaderForPartitions(ImmutableList.of(tp1, tp2));\n    Assert.assertEquals(result.get(tp1), Integer.valueOf(1));\n    Assert.assertEquals(result.get(tp2), Integer.valueOf(2));\n\n    EasyMock.verify(kafkaConsumer);\n  }\n\n}", "prediction": "    Map<TopicPartition, Integer> leaderMap = observer.findLeaderForPartitions(\n        Arrays.asList(new TopicPartition(testTopic1, 0),\n            new TopicPartition(testTopic2, 0)));\n    assertEquals(leaderMap.get(new TopicPartition(testTopic1, 0)),\n        partitionInfo1.get(0).leader().id());\n    assertEquals(leaderMap.get(new TopicPartition(testTopic2, 0)),\n        partitionInfo2.get(0).leader().id());\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "60344998_18", "part": [1, 1], "seq": [1, 1], "prompt": "class NakadiReader implements IORunnable {\n\n    @Override\n    public void run() throws IOException {\n        try {\n            runInternal();\n        } catch (BackoffException e) {\n            throw e.getCause();\n        }\n    }\n\n      NakadiReader(URI uri, RequestFactory requestFactory, BackoffStrategy backoffStrategy, CursorManager cursorManager, ObjectMapper objectMapper, Set<String> eventNames, Optional<Subscription> subscription, Optional<Lock> lock, Class<T> eventClass, Listener<T> listener);\n      NakadiReader(URI uri, RequestFactory requestFactory, BackoffStrategy backoffStrategy, CursorManager cursorManager, Set<String> eventNames, Optional<Subscription> subscription, Optional<Lock> lock, EventReader<T> eventReader, Listener<T> listener, BatchHandler batchHandler, final MetricsCollector metricsCollector);\n\n    private static Optional<String> getStreamId(Response response);\n    private JsonInput openJsonInput();\n    @Nullable private String getCursorsHeader();\n    private Collection<Cursor> getLockedCursors();\n    private String getCurrentEventName(final Cursor cursor);\n    private void processBatch(final Batch<T> batch);\n    private Cursor readCursor(JsonParser jsonParser);\n     void runInternal();\n     void readSingleBatch();\n    private void readBatch(final JsonParser jsonParser);\n\n    private static final String EVENT_NAME;\n    private final URI uri;\n    private final ObjectMapper objectMapper;\n    private final CursorManager cursorManager;\n    private final RequestFactory RequestFactory;\n    @SuppressWarnings(\"unchecked\")\n    private final Listener<SomeEvent> listener;\n    @Rule\n    public final ExpectedException expectedException;\n\n}\n\nclass NakadiReaderTest {\n\n    private static final String EVENT_NAME;\n    private final URI uri;\n    private final ObjectMapper objectMapper;\n    private final CursorManager cursorManager;\n    private final RequestFactory RequestFactory;\n    @SuppressWarnings(\"unchecked\")\n    private final Listener<SomeEvent> listener;\n    @Rule\n    public final ExpectedException expectedException;\n\n    @Test(timeout = 2000)\n    public void shouldBeInterruptibleWhenReadingFromSocket() throws IOException, InterruptedException, BackoffException, ExecutionException, TimeoutException {\n", "reference": "        final Response response = mock(Response.class);\n        final InetAddress loopbackAddress = InetAddress.getLoopbackAddress();\n        final ServerSocket serverSocket = new ServerSocket(0, 0, loopbackAddress);\n        final ExecutorService executorService = Executors.newSingleThreadExecutor();\n        executorService.submit(() -> {\n            try {\n                try (final Socket socket = serverSocket.accept()) {\n                    try (OutputStream out = socket.getOutputStream()) {\n                        while (true) {\n                            out.write(\"{\\\"cursor\\\":{\\\"partition\\\":\\\"0\\\",\\\"offset\\\":\\\"0\\\"}}\\n\".getBytes(\"utf-8\"));\n                            try {\n                                Thread.sleep(100);\n                            } catch (InterruptedException e) {\n                                break;\n                            }\n                        }\n                    }\n                }\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        });\n        final int localPort = serverSocket.getLocalPort();\n        final Socket socket = new Socket(loopbackAddress, localPort);\n        socket.setSoTimeout(1000);\n        final InputStream inputStream = socket.getInputStream();\n        when(response.getBody()).thenReturn(inputStream);\n\n        final Request request = mock(Request.class);\n        when(request.execute()).thenReturn(response);\n\n        when(RequestFactory.createRequest(uri, \"GET\")).thenReturn(request);\n\n        final BackoffStrategy backoffStrategy = new NoBackoffStrategy();\n        final NakadiReader<SomeEvent> nakadiReader = new NakadiReader<>(uri, RequestFactory, backoffStrategy, cursorManager, objectMapper, Collections.singleton(EVENT_NAME), Optional.empty(), Optional.empty(), SomeEvent.class, listener);\n\n        final ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(2);\n        final Future<?> future = scheduledExecutorService.submit(() -> {\n            final Thread currentThread = Thread.currentThread();\n            scheduledExecutorService.schedule(currentThread::interrupt, 100, TimeUnit.MILLISECONDS);\n            nakadiReader.unchecked().run();\n        });\n\n        Assert.assertNull(\"Thread should have completed normally\", future.get(500, TimeUnit.MILLISECONDS));\n    }\n\n}", "prediction": "        final CountDownLatch latch = new CountDownLatch(1);\n        final NakadiReader reader = new NakadiReader(uri, RequestFactory, new FixedBackoffStrategy(100), cursorManager, objectMapper, Collections.singleton(EVENT_NAME), Optional.empty(), Optional.empty(), SomeEvent.class, new Listener<SomeEvent>() {\n            @Override\n            public void onEvent(SomeEvent event) {\n                latch.countDown();\n            }\n\n            @Override\n            public void onError(Throwable t) {\n            }\n        });\n        final Thread thread = new Thread(reader);\n        thread.start();\n        thread.interrupt();\n        latch.await(1, TimeUnit.SECONDS);\n        assertThat(thread.isInterrupted(), is(true));\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "60701247_130", "part": [1, 1], "seq": [1, 1], "prompt": "class MultiVersionTreeNode extends UpdaterTreeNode {\n\n  @Override\n  @NotNull\n  public PackageNodeModel.SelectedState getCurrentState() {\n    return getState(UpdaterTreeNode::getCurrentState);\n  }\n\n  public  MultiVersionTreeNode(@NotNull Collection<DetailsTreeNode> versionNodes);\n\n  @NotNull private PackageNodeModel.SelectedState getState(@NotNull Function<UpdaterTreeNode, PackageNodeModel.SelectedState> childStateGetter);\n  @Override @NotNull public PackageNodeModel.SelectedState getInitialState();\n  @Override protected boolean canHaveMixedState();\n  @Override public void customizeRenderer(Renderer renderer,\n                                JTree tree,\n                                boolean selected,\n                                boolean expanded,\n                                boolean leaf,\n                                int row,\n                                boolean hasFocus);\n  @NotNull public String getDisplayName();\n  @Override @NotNull public String getStatusString();\n  @Override protected void setState(PackageNodeModel.SelectedState state);\n\n}\n\nclass MultiVersionTreeNodeTest {\n\n  @Test\n  public void maxVersion() {\n", "reference": "    SdkUpdaterConfigurable configurable = Mockito.mock(SdkUpdaterConfigurable.class);\n    List<DetailsTreeNode> nodes = ImmutableList.of(\n      new DetailsTreeNode(new PackageNodeModel(new UpdatablePackage(new FakePackage.FakeRemotePackage(\"foo;1.0.0-alpha1\"))), null, configurable),\n      new DetailsTreeNode(new PackageNodeModel(new UpdatablePackage(new FakePackage.FakeRemotePackage(\"foo;1.0.0-beta2\"))), null, configurable),\n      new DetailsTreeNode(new PackageNodeModel(new UpdatablePackage(new FakePackage.FakeRemotePackage(\"foo;1.0.0\"))), null, configurable),\n      new DetailsTreeNode(new PackageNodeModel(new UpdatablePackage(new FakePackage.FakeRemotePackage(\"foo;0.9.9\"))), null, configurable)\n    );\n    MultiVersionTreeNode node = new MultiVersionTreeNode(nodes);\n    node.cycleState();\n    assertEquals(PackageNodeModel.SelectedState.NOT_INSTALLED, nodes.get(0).getCurrentState());\n    assertEquals(PackageNodeModel.SelectedState.NOT_INSTALLED, nodes.get(1).getCurrentState());\n    assertEquals(PackageNodeModel.SelectedState.INSTALLED, nodes.get(2).getCurrentState());\n    assertEquals(PackageNodeModel.SelectedState.NOT_INSTALLED, nodes.get(3).getCurrentState());\n  }\n\n}", "prediction": "    MultiVersionTreeNode node = new MultiVersionTreeNode(Collections.singletonList(new DetailsTreeNode(new PackageNodeModel.SelectedState(PackageNodeModel.State.UPDATED))));\n    assertEquals(PackageNodeModel.State.UPDATED, node.getCurrentState().getState());\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "60776569_8", "part": [1, 1], "seq": [1, 1], "prompt": "class WelcomePresenter extends BasePresenter<WelcomeMvpView> {\n\n    public void getAccessToken(String code) {\n        checkViewAttached();\n        getMvpView().showLoadingState(true);\n        mSubscription = mDataManager.getAccessToken(code)\n                .subscribeOn(Schedulers.io())\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribe(new SingleSubscriber<AccessToken>() {\n                    @Override\n                    public void onSuccess(AccessToken accessToken) {\n                        getMvpView().showLoadingState(false);\n                        getMvpView().launchMainActivity();\n                    }\n\n                    @Override\n                    public void onError(Throwable error) {\n                        getMvpView().showLoadingState(false);\n                        Timber.e(error, \"There was a problem retrieving the access token\");\n                        getMvpView().showAccessTokenError();\n                    }\n                });\n    }\n\n    @Inject public  WelcomePresenter(DataManager dataManager);\n\n    @Override public void detachView();\n\n    private WelcomePresenter mWelcomePresenter;\n    @Mock WelcomeMvpView mMockWelcomeMvpView;\n    @Mock DataManager mMockDataManager;\n    @Rule\n    public final RxSchedulersOverrideRule mOverrideSchedulersRule;\n\n}\n\nclass WelcomePresenterTest {\n\n    private WelcomePresenter mWelcomePresenter;\n    @Mock WelcomeMvpView mMockWelcomeMvpView;\n    @Mock DataManager mMockDataManager;\n    @Rule\n    public final RxSchedulersOverrideRule mOverrideSchedulersRule;\n\n    @Test\n    public void getAccessTokenSucceedsAndLaunchesMainActivity() {\n", "reference": "        AccessToken accessToken = TestDataFactory.makeAccessToken();\n        stubDataManagerGetAccessToken(Single.just(accessToken));\n        mWelcomePresenter.getAccessToken(\"code\");\n\n        verify(mMockWelcomeMvpView).showLoadingState(true);\n        verify(mMockWelcomeMvpView).launchMainActivity();\n        verify(mMockWelcomeMvpView).showLoadingState(false);\n    }\n\n}", "prediction": "        mWelcomePresenter.getAccessToken(\"code\");\n        verify(mMockWelcomeMvpView).showLoadingState(true);\n        verify(mMockWelcomeMvpView).showLoadingState(false);\n        verify(mMockWelcomeMvpView).launchMainActivity();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "61247013_20", "part": [1, 1], "seq": [1, 1], "prompt": "class DoubleCondition extends BasicCondition<Double, DoubleCondition> implements FloatingPointChecks<Double, DoubleCondition> {\n\n\t@Override\n\tpublic DoubleCondition isGreaterThanOrEqual(Double number)\n\t{\n\t\trequire(this.subject).isNotNull();\n\t\trequire(number).isNotNull();\n\n\t\tif (!(Double.compare(this.subject, number) >= 0))\n\t\t{\n\t\t\tDbcAssertionError.throwNew(new IllegalArgumentException(\"Expected double <\" + this.subject + \"> to be greater than or equal to <\" + number + \">\"), this.message);\n\t\t}\n\n\t\treturn result();\n\t}\n\n\tpublic  DoubleCondition(Double subject);\n\n\t@Override public DoubleCondition isGreaterThan(Double number);\n\t@Override public DoubleCondition isLessThan(Double number);\n\t@Override public DoubleCondition isLessThanOrEqual(Double number);\n\t@Override public DoubleCondition isNear(Double floatingPointNumber);\n\t@Override public DoubleCondition isNearWithTolerance(Double floatingPointNumber, Double tolerance);\n\t@Override public DoubleCondition isNearZero();\n\t@Override public DoubleCondition isNearZeroWithTolerance(Double tolerance);\n\t@Deprecated @Override public DoubleCondition isEqualTo(Double toCompare);\n\n}\n\nclass DoubleConditionTest {\n\n\t@Test\n\tpublic void isGreaterThanOrEqual() throws Exception\n\t{\n", "reference": "\t\tDoubleCondition condition = new DoubleCondition(2.0D);\n\t\tcondition.isGreaterThanOrEqual(2D);\n\n\t\tassertThatThrownBy(() -> condition.isGreaterThanOrEqual(3D))\n\t\t\t\t.isInstanceOf(DbcAssertionError.class)\n\t\t\t\t.hasCauseInstanceOf(IllegalArgumentException.class);\n\t}\n\n}", "prediction": "\t\tDoubleCondition condition = new DoubleCondition(1.0);\n\t\tcondition.isGreaterThanOrEqual(0.0);\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "61250412_9", "part": [1, 1], "seq": [1, 1], "prompt": "class FileParser implements Closeable {\n\n    public void registerRecordCallback(String recordName, RecordCallback callback) {\n        List<RecordCallback> callbacks = recordCallbacks.get(recordName);\n        if (!callbacks.contains(callback)) {\n            recordCallbacks.put(recordName, callback);\n        }\n    }\n\n    protected  FileParser();\n    public  FileParser(String configContent, String dataInputContent);\n    public  FileParser(File configFile, File dataInputFile);\n    public  FileParser(File configFile, String dataInputContent);\n    public  FileParser(String configContent, File dataInputFile);\n\n    public boolean removeRecordCallback(String recordName, RecordCallback callback);\n    public void registerExceptionCallback(ExceptionCallback callback);\n    public boolean removeExceptionCallback(ExceptionCallback callback);\n    public void open();\n    protected void loadConfiguration();\n    @Override public void close();\n    public void read();\n    private void doCallback(String recordName, MatchedRecord record);\n    private void doExceptionCallback(Exception ex, String message, String lastLine);\n\n}\n\nclass FileParserTest {\n\n    @Test\n    public void executeRecordCallback() {\n", "reference": "        RecordCallback callback = mock(RecordCallback.class);\n        MatchedRecord matchedRecord = mock(MatchedRecord.class);\n\n        FileParser parser = new FileParser(\"\", \"\");\n        parser.registerRecordCallback(\"test\", callback);\n\n        // TODO when there is more time - need to have content and config embedded into the test.\n//        verify(callback, atMost(1)).processRecord(matchedRecord);\n    }\n\n}", "prediction": "        FileParser parser = new FileParser(\"\", \"\");\n        parser.registerRecordCallback(\"test\", new RecordCallback() {\n            @Override\n            public void execute(MatchedRecord record) {\n                assertEquals(\"test\", record.getRecordName());\n            }\n        });\n        parser.read();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "61566208_137", "part": [1, 1], "seq": [1, 1], "prompt": "class UpgradeRestService {\n\n    @POST\n    public Response upgrade( OobUpgradeSpec upgradeSpec )\n        throws HMSRestException\n    {\n\n        String message = null;\n\n        // validate upgrade request.\n        Response validationResponse = UpgradeUtil.validateUpgradeRequest( upgradeSpec );\n        if ( validationResponse != null )\n        {\n            // delete upgrade scripts and upgrade bundle files\n            if ( upgradeSpec != null )\n            {\n                UpgradeUtil.deleteUpgradeFiles( upgradeSpec.getId() );\n            }\n            return validationResponse;\n        }\n\n        final String upgradeId = upgradeSpec.getId();\n        final String upgradeDir = UpgradeUtil.getUpgradeDir( upgradeId );\n\n        UpgradeStatus status = new UpgradeStatus();\n        status.setId( upgradeId );\n\n        boolean scriptsExecutable = FileUtil.setFilesExecutable( upgradeDir, \"sh\" );\n        if ( !scriptsExecutable )\n        {\n\n            // delete upgrade scripts and upgrade bundle files\n            UpgradeUtil.deleteUpgradeFiles( upgradeId );\n\n            message = String.format( \"Failed to grant execute rights to upgrade scripts at '%s'.\", upgradeDir );\n            logger.error( message );\n\n            status.setStatusCode( UpgradeStatusCode.HMS_OOB_UPGRADE_INTERNAL_ERROR );\n            status.setStatusMessage( UpgradeStatusCode.HMS_OOB_UPGRADE_INTERNAL_ERROR.getStatusMessage() );\n            status.setMoreInfo( message );\n            return Response.status( Status.INTERNAL_SERVER_ERROR ).entity( status ).build();\n        }\n\n        /*\n         * 1. Put Service under maintenance 2. Drain/Post all events in queue 3. Shut off monitoring threads\n         */\n        boolean serviceInMaintenance = ServiceManager.putServiceInMaintenance();\n        if ( serviceInMaintenance )\n        {\n\n            // Invoke upgrade-hms-oob script\n            boolean upgradeInitiated = UpgradeUtil.initiateUpgrade( upgradeId, upgradeSpec.getFileName() );\n\n            if ( upgradeInitiated )\n            {\n\n                if ( ( ServiceManager.getServiceState().equals( ServiceState.NORMAL_MAINTENANCE ) )\n                    && ( ServiceManager.getActiveRequests() == 1 ) )\n                {\n\n                    message =\n                        \"Upgrade initiated after Out-of-band agent in \" + ServiceState.NORMAL_MAINTENANCE.toString();\n\n                }\n                else if ( ( ServiceManager.getServiceState().equals( ServiceState.FORCE_MAINTENANCE ) )\n                    && ( ServiceManager.getActiveRequests() > 1 ) )\n                {\n\n                    message =\n                        String.format( \"Upgrade initiated after Out-of-band agent \" + \"in %s with %s active requests.\",\n                                       ServiceState.FORCE_MAINTENANCE.toString(), ServiceManager.getActiveRequests() );\n                }\n\n                logger.info( message );\n\n                // save upgradeStatus to json file.\n                status.setStatusCode( UpgradeStatusCode.HMS_OOB_UPGRADE_INITIATED );\n\n                final String hmsUpgradeDir = UpgradeUtil.getHmsUpgradeDir();\n                String upgradeStatusFileAbsPath = String.format( \"%1$s/%2$s.json\", hmsUpgradeDir, upgradeId );\n                boolean saved = HmsUpgradeUtil.saveUpgradeStatus( upgradeStatusFileAbsPath, status );\n                if ( saved )\n                {\n                    logger.info( \"Saved upgrade status to '{}'\", upgradeStatusFileAbsPath );\n                }\n                else\n                {\n                    logger.warn( \"Unable to save upgrade status to '{}'.\", upgradeStatusFileAbsPath );\n                }\n\n                status.setStatusMessage( UpgradeStatusCode.HMS_OOB_UPGRADE_INITIATED.getStatusMessage() );\n                status.setMoreInfo( message );\n                return Response.status( Status.ACCEPTED ).entity( status ).build();\n\n            }\n            else\n            {\n\n                // delete upgrade scripts and upgrade bundle files\n                UpgradeUtil.deleteUpgradeFiles( upgradeId );\n\n                message = \"Executing Out-of-band Agent upgrade script failed.\";\n                logger.error( message );\n\n                /*\n                 * put back service in running state and reset activeRequests and restart monitoring.\n                 */\n                ServiceManager.putServiceInRunning();\n\n                status.setStatusCode( UpgradeStatusCode.HMS_OOB_UPGRADE_INTERNAL_ERROR );\n                status.setStatusMessage( UpgradeStatusCode.HMS_OOB_UPGRADE_INTERNAL_ERROR.getStatusMessage() );\n                status.setMoreInfo( message );\n                return Response.status( Status.INTERNAL_SERVER_ERROR ).entity( status ).build();\n            }\n        }\n        else\n        {\n\n            // delete upgrade scripts and upgrade bundle files\n            UpgradeUtil.deleteUpgradeFiles( upgradeId );\n\n            message = \"Setting Out-of-band Agent Service in MAINTENANCE failed.\";\n            logger.error( message );\n            status.setStatusCode( UpgradeStatusCode.HMS_OOB_UPGRADE_INTERNAL_ERROR );\n            status.setStatusMessage( UpgradeStatusCode.HMS_OOB_UPGRADE_INTERNAL_ERROR.getStatusMessage() );\n            status.setMoreInfo( message );\n            return Response.status( Status.INTERNAL_SERVER_ERROR ).entity( status ).build();\n        }\n    }\n\n    @POST @Path( \"/rollback\" ) public Response rollback( RollbackSpec rollbackSpec );\n    @POST @Path( \"/upload\" ) @Consumes( MediaType.MULTIPART_FORM_DATA ) public Response uploadFile( MultipartFormDataInput multipartFormDataInput );\n    @GET @Path( \"/monitor/{upgradeId}\" ) public Response getUpgradeStatus( @PathParam( \"upgradeId\" ) String upgradeId );\n    @DELETE @Path( \"/backup/{upgradeId}\" ) public Response deleteBackup( @PathParam( \"upgradeId\" ) String upgradeId );\n    @POST @Path( \"/proxy/restart/{upgradeId}\" ) public Response restartProxy( @PathParam( \"upgradeId\" ) String upgradeId );\n    @GET @Path( \"/download/inventory/{upgradeId}\" ) public File downloadInventoryFile( @PathParam( \"upgradeId\" ) String upgradeId );\n\n    private UpgradeRestService service;\n    private String message;\n    private OobUpgradeSpec upgradeSpec;\n    private RollbackSpec rollbackSpec;\n\n}\n\nclass UpgradeRestServiceTest {\n\n    private UpgradeRestService service;\n    private String message;\n    private OobUpgradeSpec upgradeSpec;\n    private RollbackSpec rollbackSpec;\n\n    @Test\n    public void testUpgradeWithBlankChecksum()\n    {\n", "reference": "\n        upgradeSpec.setChecksum( \" \" );\n        Response response = upgrade( upgradeSpec );\n        assertNotNull( response );\n\n        assertTrue( response.getStatus() == Status.BAD_REQUEST.getStatusCode() );\n\n        UpgradeStatus status = (UpgradeStatus) response.getEntity();\n        assertNotNull( status );\n\n        message = \"'checksum' is a mandatory parameter for HMS Upgrade.\";\n        assertEquals( message, status.getMoreInfo() );\n    }\n\n}", "prediction": "        /*\n         * Create a blank checksum file.\n         */\n        String checksumFile = \"checksum.txt\";\n        File checksumFileObj = new File( checksumFile );\n        try\n        {\n            checksumFileObj.createNewFile();\n        }\n        catch ( IOException e )\n        {\n            e.printStackTrace();\n        }\n\n        /*\n         * Create a blank upgradeSpec.\n         */\n        upgradeSpec = new OobUpgradeSpec();\n        upgradeSpec.setId( \"1234567890\" );\n        upgradeSpec.setFileName( \"upgrade.zip\" );\n        upgradeSpec.setChecksum( checksumFile );\n\n        Response response = service.upgrade( upgradeSpec );\n        assertEquals( Status.INTERNAL_SERVER_ERROR.getStatusCode(), response.getStatus() );\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "61879415_4", "part": [1, 1], "seq": [1, 1], "prompt": "class IdentityRoleByIdentityDeduplicationExecutor extends AbstractReportExecutor {\n\n\t@Override\n\tpublic String getName() {\n\t\treturn REPORT_NAME;\n\t}\n\n\t@Override protected IdmAttachmentDto generateData(RptReportDto report);\n\t@Override public List<IdmFormAttributeDto> getFormAttributes();\n\tprivate UUID getTreeNode(RptReportDto report);\n\tprivate RptIdentityRoleByRoleDeduplicationDto createRecordForContracts(IdmIdentityContractDto contract);\n\n\t@Autowired \n\tprivate IdentityRoleByIdentityDeduplicationExecutor reportExecutor;\n\t@Autowired\n\tprivate ObjectMapper mapper;\n\t@Autowired\n\tprivate AttachmentManager attachmentManager;\n\t@Autowired\n\tprivate IdentityRoleByIdentityDeduplicationXlsxRenderer xlsxRenderer;\n\n}\n\nclass IdentityRoleByIdentityDeduplicationExecutorTest extends AbstractReportExecutor {\n\n\t@Autowired \n\tprivate IdentityRoleByIdentityDeduplicationExecutor reportExecutor;\n\t@Autowired\n\tprivate ObjectMapper mapper;\n\t@Autowired\n\tprivate AttachmentManager attachmentManager;\n\t@Autowired\n\tprivate IdentityRoleByIdentityDeduplicationXlsxRenderer xlsxRenderer;\n\n\t@Test\n\tpublic void testExecuteReportTwoContract() throws JsonParseException, JsonMappingException, IOException {\n", "reference": "\t\tString roleCode = \"test-\" + System.currentTimeMillis(); \n\t\tIdmTreeNodeDto treeNode = getHelper().createTreeNode();\n\t\tIdmIdentityDto identity = getHelper().createIdentity(new GuardedString());\n\t\tIdmIdentityContractDto contactOne = getHelper().createContract(identity, treeNode);\n\t\tIdmIdentityContractDto contactTwo = getHelper().createContract(identity, treeNode);\n\t\t\n\t\tIdmRoleDto role = getHelper().createRole(roleCode);\n\n\t\tgetHelper().createIdentityRole(contactOne, role);\n\t\tgetHelper().createIdentityRole(contactOne, role);\n\t\tgetHelper().createIdentityRole(contactTwo, role);\n\t\tgetHelper().createIdentityRole(contactTwo, role);\n\n\t\tRptReportDto report = new RptReportDto(UUID.randomUUID());\n\t\treport.setExecutorName(reportExecutor.getName());\n\t\tIdmFormDto filter = new IdmFormDto();\n\t\tIdmFormDefinitionDto definition = reportExecutor.getFormDefinition();\n\t\tIdmFormValueDto treeNodeParameter = new IdmFormValueDto(definition.getMappedAttributeByCode(IdentityRoleByIdentityDeduplicationExecutor.PARAMETER_TREE_NODE));\n\t\ttreeNodeParameter.setValue(treeNode.getId());\n\t\tfilter.getValues().add(treeNodeParameter);\n\t\tfilter.setFormDefinition(definition.getId());\n\t\treport.setFilter(filter);\n\n\t\treport = reportExecutor.generate(report);\n\t\tAssert.assertNotNull(report.getData());\n\t\tList<RptIdentityRoleByRoleDeduplicationDto> reportItems = mapper.readValue(\n\t\t\t\tattachmentManager.getAttachmentData(report.getData()), \n\t\t\t\tnew TypeReference<List<RptIdentityRoleByRoleDeduplicationDto>>(){});\n\n\t\tassertEquals(2, reportItems.size());\n\t\tfor (RptIdentityRoleByRoleDeduplicationDto item : reportItems) {\n\t\t\tassertNotNull(item.getIdentity());\n\t\t\tassertEquals(identity.getId(), item.getIdentity().getId());\n\t\t\tassertNotNull(item.getWorkPosition());\n\t\t\tassertEquals(treeNode.getId(), item.getWorkPosition().getId());\n\t\t\tassertNotNull(item.getIdentityContract());\n\t\t\tif (item.getIdentityContract().getId().equals(contactOne.getId())) {\n\t\t\t\t// Success\n\t\t\t} else if (item.getIdentityContract().getId().equals(contactTwo.getId())) {\n\t\t\t\t// Success\n\t\t\t} else {\n\t\t\t\tfail();\n\t\t\t}\n\t\t\tList<RptIdentityRoleByRoleDeduplicationDuplicityDto> duplicities = item.getDuplicity();\n\t\t\tassertEquals(1, duplicities.size());\n\t\t}\n\n\t\tattachmentManager.deleteAttachments(report);\n\t}\n\n}", "prediction": "\t\tIdmIdentityDto identity = getHelper().createIdentity();\n\t\tIdmIdentityContractDto contract = getHelper().createContract(identity);\n\t\tIdmIdentityContractDto contract2 = getHelper().createContract(identity);\n\t\t\n\t\tRptIdentityRoleByRoleDeduplicationDto record = createRecordForContracts(contract);\n\t\trecord.setIdentityContract(contract2.getId());\n\t\trecord.setRole(contract2.getRole());\n\t\trecord.setRoleCode(contract2.getRole().getCode());\n\t\trecord.setRoleName(contract2.getRole().getName());\n\t\trecord.setRoleDescription(contract2.getRole().getDescription());\n\t\trecord.setRoleTreeNode(contract2.getRole().getTreeNode());\n\t\trecord.setRoleTreeNodeName(contract2.getRole().getTreeNode().getName());\n\t\trecord.setRoleTreeNodeCode(contract2.getRole().getTreeNode().getCode());\n\t\trecord.setRoleTreeNodeDescription(contract2.getRole().getTreeNode().getDescription());\n\t\trecord.setRoleTreeNodeParentCode(contract2.getRole().getTreeNode().getParent().getCode());\n\t\trecord.setRoleTreeNodeParentName(contract2.getRole().getTreeNode().getParent().getName());\n\t\trecord.setRoleTreeNodeParentDescription(contract2.getRole().getTreeNode().getParent().getDescription());\n\t\trecord.setRoleTreeNodeParentParentCode(contract2.getRole().getTreeNode().", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "63543726_1", "part": [1, 1], "seq": [1, 1], "prompt": "class HtmlGenerator {\n\n    public void generate() throws IOException {\n        ApiModel apiModel = new ApiModelBuilder().buildApiModel(config.getSourceFile());\n        TemplateEngine engine = new TemplateEngine();\n        engine.setTemplateDir(config.getTemplateDir());\n        String result = engine.renderTemplate(\"api\", apiModel);\n\n        File targetDir = new File(config.getTargetDir());\n        createDirectoryIfNeeded(targetDir);\n        Files.write(targetDir.toPath()\n            .resolve(\"index.html\"), result.getBytes(StandardCharsets.UTF_8));\n\n        writeWebResources(targetDir);\n    }\n\n    public  HtmlGenerator(HtmlConfiguration config);\n\n     HtmlContext getContext();\n    private void writeWebResources(File targetDir);\n    private void writeDefaultWebResources(File targetDir);\n    private void copyCustomWebResources(File sourceDir, File targetDir);\n    private void copyTo(Path sourcePath, Path sourceRoot, Path targetRoot);\n    private void copyTo(String file, File targetDir);\n\n}\n\nclass HtmlGeneratorTest {\n\n    @Test\n    public void shouldRenderApi() throws IOException {\n", "reference": "        HtmlConfiguration config = new HtmlConfiguration();\n        config.setSourceFile(\"src/test/resources/raml/simpleobject.raml\");\n        config.setTargetDir(\"target/html/simpleobject\");\n        HtmlGenerator generator = new HtmlGenerator(config);\n        generator.generate();\n\n        verifyTargetDir(config);\n    }\n\n}", "prediction": "        HtmlConfiguration config = new HtmlConfiguration();\n        config.setSourceFile(getClass().getResource(\"/api.json\").getFile());\n        config.setTemplateDir(getClass().getResource(\"/templates\").getFile());\n        config.setTargetDir(getClass().getResource(\"/target\").getFile());\n\n        HtmlGenerator generator = new HtmlGenerator(config);\n        generator.generate();\n\n        String expected = new String(Files.readAllBytes(Paths.get(getClass().getResource(\"/expected.html\").toURI())));\n        String actual = new String(Files.readAllBytes(Paths.get(config.getTargetDir(), \"index.html\")));\n\n        assertEquals(expected, actual);\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "63545071_4", "part": [1, 1], "seq": [1, 1], "prompt": "class RCLJava {\n\n    public static void rclJavaInit(final String... args) {\n        synchronized (RCLJava.class) {\n            if (!RCLJava.initialized) {\n                if (args != null) {\n                    RCLJava.arguments = args;\n\n                    for (final String arg : RCLJava.arguments) {\n                        if (arg.contains(\"=\")) {\n                            final String[] keyVal = arg.split(\"=\");\n                            RCLJava.logger.debug(\"Args : \" + keyVal[0] + \"\\t : \" + keyVal[1]);\n                        } else {\n                            RCLJava.logger.debug(\"Args : \" + arg);\n                        }\n                    }\n                }\n\n                // Auto-detect RMW implementation.\n                if (RCLJava.rmwImplementation == null) {\n                    RCLJava.displayContext();\n                    RCLJava.autoLoadRmw();\n                }\n\n                // No RMW implementation founded !\n                if (RCLJava.rmwImplementation == null) {\n                    RCLJava.logger.error(\"No RMW implementation found...\");\n                    System.exit(1);\n                } else\n\n                // RMW implementation founded.\n                {\n                    RCLJava.logger.debug(\"Initialize rclJava with \" + RCLJava.rmwImplementation);\n                    RCLJava.nativeRCLJavaInit(RCLJava.arguments);\n                    RCLJava.initialized = true;\n                }\n            } else {\n                final NotInitializedException ex = new NotInitializedException(\"Cannot intialized twice !\");\n                logger.error(ex.getMessage());\n                throw ex;\n            }\n        }\n    }\n\n    private  RCLJava();\n\n    private static native void nativeRCLJavaInit(String... args);\n    private static native void nativeShutdown();\n    private static native boolean nativeOk();\n    private static native String nativeGetRMWIdentifier();\n    private static native long nativeConvertQoSProfileToHandle(\n            int history, int depth, int reliability, int durability, boolean avoidRos);\n    private static native void nativeDisposeQoSProfile(\n            long qosProfileHandle);\n    private static String getRmwImplementationSuffix(final String rmwImplementation);\n    private static void displayContext();\n    private static void displayReport();\n    public static boolean isInitialized();\n    public static Node createNode(final String defaultName);\n    public static Node createNode(final String namespace, final String defaultName);\n    public static void spinOnce(final Node node);\n    public static void spin(final Node node);\n    public static boolean ok();\n    public static void shutdown();\n    private static void shutdown(final boolean force);\n    public static String getRMWIdentifier();\n    public static String getTypesupportIdentifier();\n    @SuppressWarnings(\"PMD.AvoidUsingNativeCode\") public static void setRMWImplementation(final String rmwImplementation);\n    @SuppressWarnings(\"PMD.AvoidUsingNativeCode\") public static void loadLibrary(final String name);\n    private static void autoLoadRmw();\n    protected static void shutdownHook();\n    private static void lockAndCheckInitialized();\n    public static long convertQoSProfileToHandle(final QoSProfile qosProfile);\n    public static void disposeQoSProfile(final long qosProfileHandle);\n\n    private static final Logger logger;\n    public static final String TEST_TOPIC;\n    public static final String ERROR_RUNTIME;\n\n}\n\nclass RCLJavaTest  {\n\n    private static final Logger logger;\n    public static final String TEST_TOPIC;\n    public static final String ERROR_RUNTIME;\n\n    @Test\n    public final void testInitShutdownSequence() {\n", "reference": "        logger.debug(new Object(){}.getClass().getEnclosingMethod().getName());\n\n        boolean test = true;\n\n        this.initRCLjava();\n        this.releaseRCLjava();\n\n        try {\n            RCLJava.rclJavaInit();\n            this.releaseRCLjava();\n        } catch (Exception e) {\n            test = false;\n        }\n\n        Assert.assertTrue(\"failed to initialize rclJava after shutdown\", test);\n    }\n\n}", "prediction": "        RCLJava.rclJavaInit();\n        RCLJava.shutdown();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "63689153_9", "part": [1, 1], "seq": [1, 1], "prompt": "class MixAll {\n\n    public static List<String> getLocalInetAddress() {\n        List<String> inetAddressList = new ArrayList<String>();\n        try {\n            Enumeration<NetworkInterface> enumeration = NetworkInterface.getNetworkInterfaces();\n            while (enumeration.hasMoreElements()) {\n                NetworkInterface networkInterface = enumeration.nextElement();\n                Enumeration<InetAddress> addrs = networkInterface.getInetAddresses();\n                while (addrs.hasMoreElements()) {\n                    inetAddressList.add(addrs.nextElement().getHostAddress());\n                }\n            }\n        } catch (SocketException e) {\n            throw new RuntimeException(\"get local inet address fail\", e);\n        }\n\n        return inetAddressList;\n    }\n\n    public static String getRetryTopic(final String consumerGroup);\n    public static boolean isSysConsumerGroup(final String consumerGroup);\n    public static String getDLQTopic(final String consumerGroup);\n    public static String brokerVIPChannel(final String brokerAddr);\n    public static long getPID();\n    public static long createBrokerId(final String ip, final int port);\n    public static final void string2File(final String str, final String fileName);\n    public static final void string2FileNotSafe(final String str, final String fileName);\n    public static final String file2String(final String fileName);\n    public static final String file2String(final URL url);\n    public static final String file2String(final File file);\n    public static String findClassPath(Class<?> c);\n    public static void printObjectProperties(final Logger log, final Object object);\n    public static void printObjectProperties(final Logger log, final Object object, final boolean onlyImportantField);\n    public static String properties2String(final Properties properties);\n    public static Properties string2Properties(final String str);\n    public static Properties object2Properties(final Object object);\n    public static void properties2Object(final Properties p, final Object object);\n    public static boolean isPropertiesEqual(final Properties p1, final Properties p2);\n    public static boolean isLocalAddr(String address);\n    private static String localhost();\n    public static boolean compareAndIncreaseOnly(final AtomicLong target, final long value);\n    public Set<String> list2Set(List<String> values);\n    public List<String> set2List(Set<String> values);\n    public static String localhostName();\n\n}\n\nclass MixAllTest {\n\n    @Test\n    public void test() throws Exception {\n", "reference": "        List<String> localInetAddress = MixAll.getLocalInetAddress();\n        String local = InetAddress.getLocalHost().getHostAddress();\n        Assert.assertTrue(localInetAddress.contains(\"127.0.0.1\"));\n        Assert.assertTrue(localInetAddress.contains(local));\n    }\n\n}", "prediction": "        MixAll.getLocalInetAddress();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "64004196_13", "part": [1, 1], "seq": [1, 1], "prompt": "class SVGParser {\n\n    protected static NumberParse parseNumbers(String s) {\n        //Util.debug(\"Parsing numbers from: '\" + s + \"'\");\n        int n = s.length();\n        int p = 0;\n        ArrayList<Float> numbers = new ArrayList<Float>();\n        boolean skipChar = false;\n        for (int i = 1; i < n; i++) {\n            if (skipChar) {\n                skipChar = false;\n                continue;\n            }\n            char c = s.charAt(i);\n            switch (c) {\n                // This ends the parsing, as we are on the next element\n                case 'M':\n                case 'm':\n                case 'Z':\n                case 'z':\n                case 'L':\n                case 'l':\n                case 'H':\n                case 'h':\n                case 'V':\n                case 'v':\n                case 'C':\n                case 'c':\n                case 'S':\n                case 's':\n                case 'Q':\n                case 'q':\n                case 'T':\n                case 't':\n                case 'a':\n                case 'A':\n                case ')': {\n                    String str = s.substring(p, i);\n                    if (str.trim().length() > 0) {\n                        //Util.debug(\"  Last: \" + str);\n                        Float f = Float.parseFloat(str);\n                        numbers.add(f);\n                    }\n                    p = i;\n                    return new NumberParse(numbers, p);\n                }\n                case '\\n':\n                case '\\t':\n                case ' ':\n                case ',':\n                case '-': {\n                    String str = s.substring(p, i);\n                    // Just keep moving if multiple whitespace\n                    if (str.trim().length() > 0) {\n                        //Util.debug(\"  Next: \" + str);\n                        Float f = Float.parseFloat(str);\n                        numbers.add(f);\n                        if (c == '-') {\n                            p = i;\n                        } else {\n                            p = i + 1;\n                            skipChar = true;\n                        }\n                    } else {\n                        p++;\n                    }\n                    break;\n                }\n            }\n        }\n        String last = s.substring(p);\n        if (last.length() > 0) {\n            //Util.debug(\"  Last: \" + last);\n            try {\n                numbers.add(Float.parseFloat(last));\n            } catch (NumberFormatException nfe) {\n                // Just white-space, forget it\n            }\n            p = s.length();\n        }\n        return new NumberParse(numbers, p);\n    }\n\n    public static SVG getSVGFromInputStream(InputStream svgData);\n    public static SVG getSVGFromInputStream(InputStream svgData, int targetWidth, int targetHeight);\n    public static SVG getSVGFromResource(Resources resources, int resId);\n    public static SVG getSVGFromAsset(AssetManager assetMngr, String svgPath);\n    public static SVG getSVGFromInputStream(InputStream svgData, int searchColor, int replaceColor,\n                                            int targetWidth, int targetHeight);\n    public static SVG getSVGFromString(String svgData, int searchColor, int replaceColor);\n    public static SVG getSVGFromResource(Resources resources, int resId, int searchColor, int replaceColor);\n    public static SVG getSVGFromAsset(AssetManager assetMngr, String svgPath, int searchColor, int replaceColor);\n    public static Path parsePath(String pathString);\n    private static SVG parse(InputStream in, Integer searchColor, Integer replaceColor, boolean whiteMode,\n                             int targetWidth, int targetHeight);\n    private static SVG parse(InputStream in, Integer searchColor, Integer replaceColor, boolean whiteMode);\n    private static Matrix parseTransform(String s);\n    private static Path doPath(String s);\n    private static NumberParse getNumberParseAttr(String name, Attributes attributes);\n    private static String getStringAttr(String name, Attributes attributes);\n    private static Float getFloatAttr(String name, Attributes attributes);\n    private static Float getFloatAttr(String name, Attributes attributes, Float defaultValue);\n    protected static Integer getHexAttr(String name, Attributes attributes);\n\n}\n\nclass SVGParserTest  {\n\n    @Test\n    public void parseNumbers() {\n", "reference": "        String numbers = \"10.0  -10.0-1f\";\n        SVGParser.NumberParse numberParse = SVGParser.parseNumbers(numbers);\n        assertThat(numberParse.getNumber(0), is(10.0f));\n        assertThat(numberParse.getNumber(1), is(-10.0f));\n        assertThat(numberParse.getNumber(2), is(-1.0f));\n        assertThat(numberParse.getNextCmd(), is(numbers.length()));\n    }\n\n}", "prediction": "        NumberParse parseNumbers = SVGParser.parseNumbers(\"1234567890\");\n        assertEquals(10, parseNumbers.numbers.size());\n        assertEquals(1234567890f, parseNumbers.numbers.get(0), 0.00001);\n        assertEquals(1234567890f, parseNumbers.numbers.get(9), 0.00001);\n        assertEquals(10, parseNumbers.p);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "65088801_0", "part": [1, 1], "seq": [1, 1], "prompt": "class VertxDispatcher extends DispatcherBase implements Dispatcher<String> {\n\n    @Override\n    public Dispatcher<String> noAuth() {\n        this.requireAuth = false;\n        return this;\n    }\n\n    public void init();\n    @Override public synchronized void close();\n    @Override public boolean isOpen();\n    @Override public Dispatcher<String> preHandle(Predicate<RequestContext> handler);\n    @Override public Dispatcher<String> postHandle(Consumer<RequestContext> handler);\n    @Override public Dispatcher<String> get(String s, Consumer<RequestContext> handler);\n    @Override public Dispatcher<String> head(String s, Consumer<RequestContext> handler);\n    @Override public Dispatcher<String> delete(String s, Consumer<RequestContext> handler);\n    @Override public Dispatcher<String> post(String s, Class<? extends Payload> payloadType, BiConsumer<Payload, RequestContext> handler);\n    @Override public Dispatcher<String> postJson(String s, BiConsumer<JsonObject, RequestContext> handler);\n    @Override public Dispatcher<String> post(String s, Consumer<RequestContext> handler);\n    @Override public Dispatcher<String> post(String s, BiConsumer<byte[], RequestContext> handler);\n    @Override public Dispatcher<String> postUpload(String s, Consumer<RequestContext> handler);\n    @Override public Dispatcher<String> put(String s, Consumer<RequestContext> handler);\n    @Override public Dispatcher<String> put(String s, Class<? extends Payload> payloadType, BiConsumer<Payload, RequestContext> handler);\n    @Override public Dispatcher<String> putJson(String s, BiConsumer<JsonObject, RequestContext> handler);\n    @Override public Dispatcher<String> put(String s, BiConsumer<byte[], RequestContext> handler);\n    @Override public Dispatcher<String> blocking();\n    @Override public Dispatcher<String> requireAuth();\n    @Override public Dispatcher<String> allowNotConfirmed();\n    @Override public Dispatcher<String> filter(Predicate<RequestContext> filter, String message);\n    @Override public Dispatcher<String> filter(Predicate<RequestContext> filter, String message, Object... params);\n    @Override public Dispatcher<String> mimeTypes(String... mimeTypes);\n    @Override public Dispatcher<String> exceptionHandler(BiConsumer<Throwable, RequestContext> handler);\n    protected Dispatcher<String> handler(String s, HttpMethod method,\n                                         BiConsumer<RoutingContext, RequestContext> handler);\n    public Vertx getVertx();\n    public void setVertx(Vertx vertx);\n    public BodyHandler getBodyHandler();\n    public void setBodyHandler(BodyHandler bodyHandler);\n\n    protected static final int TIMEOUT;\n    protected Utils.Port port;\n    protected AccountRepository accountRepository;\n    protected ConfigurationManager configRepository;\n    protected VertxDispatcher dispatcher;\n    protected Vertx vertx;\n    protected static final String HOST;\n\n}\n\nclass VertxDispatcherTest {\n\n    protected static final int TIMEOUT;\n    protected Utils.Port port;\n    protected AccountRepository accountRepository;\n    protected ConfigurationManager configRepository;\n    protected VertxDispatcher dispatcher;\n    protected Vertx vertx;\n    protected static final String HOST;\n\n    @Test\n    public void testNoAuth() throws Exception {\n", "reference": "        final int[] count = { 0 };\n        dispatcher.requireAuth().get(\"/get/me\", c -> {\n            count[0] += 1;\n        });\n\n        HttpClient client = vertx.createHttpClient();\n        httpGet(client, \"/get/me\", jo -> jo.getLong(\"error\") == ErrorMessages.NOT_AUTHORISED);\n        Assert.assertEquals(count[0], 0);\n    }\n\n}", "prediction": "        dispatcher.noAuth();\n        assertFalse(dispatcher.requireAuth);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "65541750_0", "part": [1, 1], "seq": [1, 1], "prompt": "class DynamicRecyclerViewAdapter extends RecyclerView.Adapter {\n\n    @Override\n    public final int getItemCount() {\n        return sectionedItemList.size();\n    }\n\n    public abstract ViewHolder onCreateViewHolder(@NonNull ViewGroup parent);\n    public abstract TitleViewHolder onCreateTitleViewHolder(@NonNull ViewGroup parent);\n    public abstract void onBindViewHolder(@NonNull ViewHolder holder, @NonNull DataObject item, int position);\n    public abstract void onBindTitleViewHolder(@NonNull TitleViewHolder holder,\n                                               @NonNull String sectionName,\n                                               @NonNull Collection<DataObject> dataItems,\n                                               int position);\n    @Override public final RecyclerView.ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType);\n    @Override public final void onBindViewHolder(@NonNull RecyclerView.ViewHolder holder, int position);\n    @Override public final int getItemViewType(int position);\n    public final void setData(@Nullable Collection<DataObject> items,\n                              @NonNull SectionEvaluator<DataObject> sectionEvaluator);\n    public final void setData(@Nullable Collection<DataObject> items,\n                              @NonNull SectionEvaluator<DataObject> sectionEvaluator,\n                              @NonNull Comparator<Section> comparator);\n    private void insertNewItems(SectionedItems<DataObject> sectionedItems);\n    private void removeUnnecessaryItems(List<? extends ListItem> newItems);\n    private void addMissingItems(List<? extends ListItem> newItems);\n    private void updateTitles();\n\n     DynamicRecyclerViewAdapter dynamicRecyclerViewAdapter;\n    private static final String FIRST_ITEM;\n    private static final String FIRST_ITEM_SECTION_TITLE;\n    private final static String SECOND_ITEM;\n    private static final String SECOND_ITEM_SECTION_TITLE;\n    private List<String> testItems;\n    @Captor ArgumentCaptor<String> titleCaptor;\n    @Captor ArgumentCaptor<Collection<DataCellItem>> dataItemsCaptor;\n    @Captor ArgumentCaptor<String> dataItemCaptor;\n    @Captor ArgumentCaptor<Integer> positionCaptor;\n\n}\n\nclass DynamicRecyclerViewAdapterTest {\n\n     DynamicRecyclerViewAdapter dynamicRecyclerViewAdapter;\n    private static final String FIRST_ITEM;\n    private static final String FIRST_ITEM_SECTION_TITLE;\n    private final static String SECOND_ITEM;\n    private static final String SECOND_ITEM_SECTION_TITLE;\n    private List<String> testItems;\n    @Captor ArgumentCaptor<String> titleCaptor;\n    @Captor ArgumentCaptor<Collection<DataCellItem>> dataItemsCaptor;\n    @Captor ArgumentCaptor<String> dataItemCaptor;\n    @Captor ArgumentCaptor<Integer> positionCaptor;\n\n    @Test\n    public void shouldGetCorrectItemCount() {\n", "reference": "        assertThat(dynamicRecyclerViewAdapter.getItemCount()).isEqualTo(4);\n    }\n\n}", "prediction": "        assertThat(dynamicRecyclerViewAdapter.getItemCount()).isEqualTo(testItems.size());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "65776167_4", "part": [1, 1], "seq": [1, 1], "prompt": "class CheramiClientImpl implements CheramiClient {\n\n    @Override\n    public void deleteConsumerGroup(DeleteConsumerGroupRequest request)\n            throws EntityNotExistsError, BadRequestError, IOException {\n\n        this.throwOnNullRequest(request);\n\n        if (!request.isSetConsumerGroupName()) {\n            throw new BadRequestError(\"request missing consumerGroupName parameter\");\n        }\n        if (!request.isSetDestinationPath()) {\n            throw new BadRequestError(\"request missing destinationPath parameter\");\n        }\n\n        ThriftRequest<deleteConsumerGroup_args> thriftRequest = null;\n        ThriftResponse<deleteConsumerGroup_result> thriftResponse = null;\n        try {\n            thriftRequest = buildThriftRequest(\"deleteConsumerGroup\", new deleteConsumerGroup_args(request));\n            thriftResponse = doRemoteCall(thriftRequest);\n            deleteConsumerGroup_result result = thriftResponse.getBody(deleteConsumerGroup_result.class);\n            if (thriftResponse.getResponseCode() == ResponseCode.OK) {\n                return;\n            }\n            if (result != null && result.isSetEntityError()) {\n                throw result.getEntityError();\n            }\n            if (result != null && result.isSetRequestError()) {\n                throw result.getRequestError();\n            }\n\n            throw new IOException(\"deleteConsumerGroup failed with unknown error:\" + result);\n        } finally {\n            if (thriftResponse != null) {\n                thriftResponse.release();\n            }\n        }\n    }\n\n    private  CheramiClientImpl(ClientOptions options);\n    protected  CheramiClientImpl(String host, int port, ClientOptions options);\n    protected  CheramiClientImpl(String routerFile, ClientOptions options);\n\n    protected MetricsReporter getMetricsReporter();\n    @Override public ClientOptions getOptions();\n    private boolean isProd(String deploymentStr);\n    private String getFrontendServiceName();\n    protected static WebSocketClient getWebsocketClient();\n    private static String getEndpoint(String service, String method);\n    private void throwOnRpcError(ThriftResponse<?> response);\n    private void throwOnNullRequest(Object request);\n    private ThriftRequest<T> buildThriftRequest(String apiName, T body);\n    private ThriftResponse<T> doRemoteCall(ThriftRequest<?> request);\n    @Override public void close();\n    @Override public ConsumerGroupDescription createConsumerGroup(CreateConsumerGroupRequest request);\n    @Override public DestinationDescription createDestination(CreateDestinationRequest request);\n    @Override public CheramiPublisher createPublisher(CreatePublisherRequest request);\n    @Override public CheramiConsumer createConsumer(CreateConsumerRequest request);\n    @Override public void deleteDestination(DeleteDestinationRequest request);\n    @Override public ConsumerGroupDescription readConsumerGroup(ReadConsumerGroupRequest request);\n    @Override public DestinationDescription readDestination(ReadDestinationRequest request);\n    @Override public ConsumerGroupDescription updateConsumerGroup(UpdateConsumerGroupRequest request);\n    @Override public DestinationDescription updateDestination(UpdateDestinationRequest request);\n    @Override public ListConsumerGroupResult listConsumerGroups(ListConsumerGroupRequest request);\n    @Override public ListDestinationsResult listDestinations(ListDestinationsRequest request);\n    @Override public List<HostAddress> readDestinationHosts(String path);\n    @Override public ReadPublisherOptionsResult readPublisherOptions(String path);\n    @Override public ReadConsumerGroupHostsResult readConsumerGroupHosts(String path, String consumerGroupName);\n\n    private static CheramiClientImpl client;\n    private static MockFrontendService frontendService;\n    private static final Logger logger;\n    @Rule\n    public ExpectedException thrown;\n\n}\n\nclass CheramiClientImplTest {\n\n    private static CheramiClientImpl client;\n    private static MockFrontendService frontendService;\n    private static final Logger logger;\n    @Rule\n    public ExpectedException thrown;\n\n    @Test\n    public void testDeleteConsumerGroup() throws Exception {\n", "reference": "        //Create a ConsumerGroup to delete\n        CreateConsumerGroupRequest request = new CreateConsumerGroupRequest();\n        final String destination = \"/foo/bar\";\n        final String consumerGroup = \"TestConsumerGroup\";\n        final int lockTimeout = new Random().nextInt();\n        final int maxDelivery = new Random().nextInt();\n        final String email = \"foo@bar.com\";\n        final int skipOlder = new Random().nextInt();\n        final long timestamp = new Date().getTime();\n        request.setDestinationPath(destination);\n        request.setConsumerGroupName(consumerGroup);\n        request.setLockTimeoutInSeconds(lockTimeout);\n        request.setMaxDeliveryCount(maxDelivery);\n        request.setOwnerEmail(email);\n        request.setSkipOlderMessagesInSeconds(skipOlder);\n        request.setStartFrom(timestamp);\n\n        ConsumerGroupDescription response = client.createConsumerGroup(request);\n\n        assert (response.getDestinationPath().equals(destination));\n        assert (response.getConsumerGroupName().equals(consumerGroup));\n\n        DeleteConsumerGroupRequest deleteRequest = new DeleteConsumerGroupRequest();\n\n        deleteRequest.setDestinationPath(destination);\n        deleteRequest.setConsumerGroupName(consumerGroup);\n        // Simple test case where we delete an existing ConsumerGroup\n        try {\n            client.deleteConsumerGroup(deleteRequest);\n        } catch (RuntimeException e) {\n            assert (false);\n        }\n\n        // Client should not be able to delete a nonexistent ConsumerGroup\n        thrown.expect(EntityNotExistsError.class);\n        client.deleteConsumerGroup(deleteRequest);\n    }\n\n}", "prediction": "        DeleteConsumerGroupRequest request = new DeleteConsumerGroupRequest();\n        request.setConsumerGroupName(\"test\");\n        request.setDestinationPath(\"test\");\n        client.deleteConsumerGroup(request);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "65987043_9", "part": [1, 1], "seq": [1, 1], "prompt": "class TableInfo {\n\n    public String getFileName(String entityName, String value, Supplier<String> defaultValue) {\n        return StringUtils.isNotBlank(value) ? String.format(value, entityName) : defaultValue.get();\n    }\n\n    @Deprecated public TableInfo setConvert(boolean convert);\n    protected TableInfo setConvert(StrategyConfig strategyConfig);\n    public String getEntityPath();\n    @Deprecated public TableInfo setEntityName(String entityName);\n    public TableInfo setEntityName(StrategyConfig strategyConfig, String entityName);\n    @Deprecated public TableInfo setFields(List<TableField> fields);\n    public TableInfo addFields(List<TableField> fields);\n    public TableInfo addFields(TableField... fields);\n    @Deprecated public TableInfo setImportPackages(String pkg);\n    public TableInfo addImportPackages(String... pkgs);\n    public boolean isLogicDelete(String logicDeletePropertyName);\n    @Deprecated public TableInfo setFieldNames(String fieldNames);\n    public String getFieldNames();\n    @Deprecated public TableInfo setCommonFields(List<TableField> commonFields);\n    public TableInfo addCommonFields(TableField... commonFields);\n    public TableInfo addCommonFields(List<TableField> commonFields);\n    public void importPackage(StrategyConfig strategyConfig, GlobalConfig globalConfig);\n    public void processTable(StrategyConfig strategyConfig, GlobalConfig globalConfig);\n\n}\n\nclass TableInfoTest {\n\n    @Test\n    void getFileNameTest() {\n", "reference": "        TableInfo tableInfo = new TableInfo();\n        Assertions.assertEquals(\"UserEntity\", tableInfo.getFileName(\"User\", \"\", () -> \"UserEntity\"));\n        Assertions.assertEquals(\"UserEntity\", tableInfo.getFileName(\"User\", null, () -> \"UserEntity\"));\n        Assertions.assertEquals(\"UserTable\", tableInfo.getFileName(\"User\", \"%sTable\", () -> \"UserEntity\"));\n        Assertions.assertEquals(\"UserTable\", tableInfo.getFileName(\"User\", \"UserTable\", () -> \"UserEntity\"));\n    }\n\n}", "prediction": "        TableInfo tableInfo = new TableInfo();\n        assertEquals(\"test\", tableInfo.getFileName(\"test\", \"test\", () -> \"test\"));\n        assertEquals(\"test\", tableInfo.getFileName(\"test\", \"test\", () -> \"test\"));\n        assertEquals(\"test\", tableInfo.getFileName(\"test\", \"test\", () -> \"test\"));\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "66622989_36", "part": [1, 1], "seq": [1, 1], "prompt": "class SentenceDetailPresenter extends AbstractMvpPresenter<SentenceDetail.View, SentenceDetailViewModel> implements SentenceDetail.Presenter<SentenceDetail.View, SentenceDetailViewModel> {\n\n    @Override\n    public void setPlayStyle(int style) {\n        getViewModel().setPlayStyle(style);\n        mSetPlayStyleUC.requestParams(style).execute(mSetPlayStyleUseCaseHandler);\n        mAudioPlayer.setLooping(style == Constants.PLAY_REPEAT);\n    }\n\n    public  SentenceDetailPresenter(SentenceDataRepository sentenceDataRepository, AudioPlayer audioPlayer);\n\n    public void setLoadSentencesUCAndHandler(LoadSentencesUC loadSentencesUC, UseCaseHandler useCaseHandler);\n    public void setUpdateFavoriteSentenceUCAndHandler(UpdateFavoriteSentenceUC updateFavoriteSentenceUC, UseCaseHandler useCaseHandler);\n    public void setSetPlayStyleUCAndHandler(SetPlayStyleUC setPlayStyleUC, UseCaseHandler useCaseHandler);\n    public void setGetPlayStyleUCAndHandler(GetPlayStyleUC getPlayStyleUCForPrepareMenu,\n                                            GetPlayStyleUC getPlayStyleUCForPlayAudio,\n                                            UseCaseHandler useCaseHandler);\n    public void setFetchSentenceAudioUCAndHandler(FetchSentenceAudioUC fetchSentenceAudioUC, UseCaseHandler useCaseHandler);\n    @Override public void loadSentences(boolean firstLoad);\n    public void loadCurrentSentense(LoadSentenceUC.LoadSentenceCallback callback);\n    private void showSentenceList(List<? extends Sentence> sentences);\n    private int findInitialPosition(List<? extends Sentence> sentences);\n    @Override public void fetchSentenceAudio();\n    @Override public void setFavorite(@NonNull Sentence sentence, boolean favorite);\n    @Override public void onAudioFabButtonClicked();\n    @Subscribe(threadMode = ThreadMode.MAIN) @Override public void onFetchingAudioEvent(FetchingAudioEvent fetchingAudioEvent);\n    @Override public void onDisplaySentence(Sentence sentence);\n    @Override public void onCreate();\n    @Override public void onViewCreated();\n    @Override public void onPrepareOptionsMenu();\n    private void updateOptionsMenu();\n    private void updateAudioFabStatusIfNeed();\n    private void updateAudioFabStatusAndPlayIfNeed();\n    private void refreshMediaPlayer();\n    private void releaseMediaPlayer();\n    private void startMediaPlayer();\n    @Override public void onActivityCreated();\n    @Override public void onResume();\n    @Override public void onStop();\n    @Override public void onDestroy();\n    @Nullable @Override protected SentenceDetailViewModel createViewModel();\n    @VisibleForTesting public EventBus getEventBus();\n\n    @Mock\n    private SentenceDetail.View mView;\n    private SentenceDetailViewModel mModel;\n    @Mock\n    private UseCaseHandler mLoadSentencesUseCaseHandler;\n    @Mock\n    private LoadSentencesUC mLoadSentencesUC;\n    @Captor\n    private ArgumentCaptor<LoadSentencesUC.LoadSentencesCallback> mLoadSentencesCallbackCaptor;\n    @Captor\n    private ArgumentCaptor<LoadSentenceUC.LoadSentenceCallback> mLoadSentenceCallbackCaptor;\n    @Captor\n    private ArgumentCaptor<LoadSentencesUC.LoadSentencesRequestParms> mLoadSentencesRequestParmsCaptor;\n    @Captor\n    private ArgumentCaptor<List<? extends Sentence>> mSentenceListCaptor;\n    @Mock\n    private UseCaseHandler mUpdateFavoriteSentenceUseCaseHandler;\n    @Mock\n    private UpdateFavoriteSentenceUC mUpdateFavoriteSentenceUC;\n    @Mock\n    private UseCaseHandler mSetPlayStyleUseCaseHandler;\n    @Mock\n    private SetPlayStyleUC mSetPlayStyleUC;\n    @Captor\n    private ArgumentCaptor<Integer> mSetPlayStyleParmsCaptor;\n    @Mock\n    private UseCaseHandler mGetPlayStyleUseCaseHandler;\n    @Mock\n    private GetPlayStyleUC mGetPlayStyleUCForPrepareMenu;\n    @Mock\n    private GetPlayStyleUC mGetPlayStyleUCForPlayAudio;\n    @Captor\n    private ArgumentCaptor<GetPlayStyleUC.GetPlayStyleCallback> mGetPlayStyleCallbackCaptor;\n    @Mock\n    private UseCaseHandler mFetchSentenceAudioUseCaseHander;\n    @Mock\n    private FetchSentenceAudioUC mFetchSentenceAudioUC;\n    @Captor\n    private ArgumentCaptor<FetchSentenceAudioUC.FetchSentenceAudioRequestParms> mFetchSentenceAudioRequestParmsCaptor;\n    @Mock\n    private AudioPlayer mAudioPlayer;\n    @Mock\n    private SentenceDataRepository mSentenceDataRepository;\n    @Mock\n    private EventBus mEventBus;\n    @Captor\n    private ArgumentCaptor<FocusedSentenceEvent> mFocusedSentenceEventCaptor;\n    private SentenceDetailPresenter mSentenceDetailPresenter;\n    @Mock\n    private List<? extends Sentence> mSentences;\n    @Mock\n    private Sentence mCurrentSentence;\n\n}\n\nclass SentenceDetailPresenterTest {\n\n    @Mock\n    private SentenceDetail.View mView;\n    private SentenceDetailViewModel mModel;\n    @Mock\n    private UseCaseHandler mLoadSentencesUseCaseHandler;\n    @Mock\n    private LoadSentencesUC mLoadSentencesUC;\n    @Captor\n    private ArgumentCaptor<LoadSentencesUC.LoadSentencesCallback> mLoadSentencesCallbackCaptor;\n    @Captor\n    private ArgumentCaptor<LoadSentenceUC.LoadSentenceCallback> mLoadSentenceCallbackCaptor;\n    @Captor\n    private ArgumentCaptor<LoadSentencesUC.LoadSentencesRequestParms> mLoadSentencesRequestParmsCaptor;\n    @Captor\n    private ArgumentCaptor<List<? extends Sentence>> mSentenceListCaptor;\n    @Mock\n    private UseCaseHandler mUpdateFavoriteSentenceUseCaseHandler;\n    @Mock\n    private UpdateFavoriteSentenceUC mUpdateFavoriteSentenceUC;\n    @Mock\n    private UseCaseHandler mSetPlayStyleUseCaseHandler;\n    @Mock\n    private SetPlayStyleUC mSetPlayStyleUC;\n    @Captor\n    private ArgumentCaptor<Integer> mSetPlayStyleParmsCaptor;\n    @Mock\n    private UseCaseHandler mGetPlayStyleUseCaseHandler;\n    @Mock\n    private GetPlayStyleUC mGetPlayStyleUCForPrepareMenu;\n    @Mock\n    private GetPlayStyleUC mGetPlayStyleUCForPlayAudio;\n    @Captor\n    private ArgumentCaptor<GetPlayStyleUC.GetPlayStyleCallback> mGetPlayStyleCallbackCaptor;\n    @Mock\n    private UseCaseHandler mFetchSentenceAudioUseCaseHander;\n    @Mock\n    private FetchSentenceAudioUC mFetchSentenceAudioUC;\n    @Captor\n    private ArgumentCaptor<FetchSentenceAudioUC.FetchSentenceAudioRequestParms> mFetchSentenceAudioRequestParmsCaptor;\n    @Mock\n    private AudioPlayer mAudioPlayer;\n    @Mock\n    private SentenceDataRepository mSentenceDataRepository;\n    @Mock\n    private EventBus mEventBus;\n    @Captor\n    private ArgumentCaptor<FocusedSentenceEvent> mFocusedSentenceEventCaptor;\n    private SentenceDetailPresenter mSentenceDetailPresenter;\n    @Mock\n    private List<? extends Sentence> mSentences;\n    @Mock\n    private Sentence mCurrentSentence;\n\n    @Test\n    public void testSetPlayStyle_Repeat() {\n", "reference": "        mSentenceDetailPresenter.setPlayStyle(Constants.PLAY_REPEAT);\n        verify(mSetPlayStyleUC).requestParams(mSetPlayStyleParmsCaptor.capture());\n        assertEquals(mSetPlayStyleParmsCaptor.getValue().intValue(), mModel.getPlayStyle());\n        verify(mSetPlayStyleUC).execute(mSetPlayStyleUseCaseHandler);\n        // not loop\n        verify(mAudioPlayer).setLooping(true);\n    }\n\n}", "prediction": "        // Given\n        int style = Constants.PLAY_REPEAT;\n\n        // When\n        mSentenceDetailPresenter.setPlayStyle(style);\n\n        // Then\n        verify(mSetPlayStyleUC).requestParams(style);\n        verify(mSetPlayStyleUseCaseHandler).execute(mSetPlayStyleUC, mSetPlayStyleParmsCaptor.capture());\n        assertEquals(style, mSetPlayStyleParmsCaptor.getValue().getStyle());\n        verify(mAudioPlayer).setLooping(true);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "66940520_432", "part": [1, 1], "seq": [1, 1], "prompt": "class AnalyticsUtils {\n\n    public static Double getBaseMonth( PeriodType periodType )\n    {\n        if ( periodType instanceof FinancialPeriodType)\n        {\n            return (double) ((FinancialPeriodType) periodType).getBaseMonth();\n        }\n\n        return 0D;\n    }\n\n    public static String getDebugDataSql( DataQueryParams params );\n    public static List<DimensionalItemObject> getByDataDimensionItemType( DataDimensionItemType itemType, List<DimensionalItemObject> dataDimensionOptions );\n    public static Number getRoundedValue( DataQueryParams params, Integer decimals, Double value );\n    public static Object getRoundedValueObject( DataQueryParams params, Object value );\n    public static ColumnDataType getColumnType( ValueType valueType, boolean spatialSupport );\n    public static Map<String, T> convertDxToOperand( Map<String, T> valueMap, TotalType totalType );\n    public static Map<String, Double> getDoubleMap( Map<String, Object> map );\n    public static Map<String, Object> getAggregatedDataValueMapping( Grid grid );\n    public static DataValueSet getDataValueSetFromGrid( DataQueryParams params, Grid grid );\n    public static void handleGridForDataValueSet( DataQueryParams params, Grid grid );\n    public static Object getIntegerOrValue( Object value, DimensionalItemObject item );\n    public static Map<String, DimensionalItemObject> getDimensionalItemObjectMap( DataQueryParams params );\n    public static Map<String, String> getDimensionItemNameMap( DataQueryParams params );\n    public static Map<String, MetadataItem> getDimensionMetadataItemMap( DataQueryParams params );\n    public static Map<String, String> getCocNameMap( DataQueryParams params );\n    public static Map<String, String> getUidDisplayPropertyMap( List<QueryItem> queryItems, DisplayProperty displayProperty );\n    public static Map<String, String> getUidDisplayPropertyMap( List<DimensionalObject> dimensions, boolean hierarchyMeta, DisplayProperty displayProperty );\n    public static boolean periodIsOutsideApprovalMaxYears( Integer year, Integer maxYears );\n    public static int getLevelFromOrgUnitDimensionName( String dimensionName );\n    public static boolean isTableLayout( List<String> columns, List<String> rows );\n    public static Double calculateYearlyWeightedAverage( Double year1Value, Double year2Value, Double factor );\n    public static void throwIllegalQueryEx( ErrorCode errorCode, Object... args );\n    public static boolean isPeriodInPeriods( String period, List<DimensionalItemObject> periods );\n    public static List<DimensionalItemObject> findDimensionalItems( String dimensionIdentifier,\n        List<DimensionalItemObject> items );\n    public static boolean hasPeriod( List<Object> row, int periodIndex );\n\n}\n\nclass AnalyticsUtilsTest  {\n\n    @Test\n    public void testGetBaseMonth()\n    {\n", "reference": "        assertEquals( 3, AnalyticsUtils.getBaseMonth( new FinancialAprilPeriodType() ), 0 );\n        assertEquals( 6, AnalyticsUtils.getBaseMonth( new FinancialJulyPeriodType() ), 0 );\n        assertEquals( 9, AnalyticsUtils.getBaseMonth( new FinancialOctoberPeriodType() ), 0 );\n        assertEquals( 10, AnalyticsUtils.getBaseMonth( new FinancialNovemberPeriodType() ), 0 ) ;\n        assertEquals( 0, AnalyticsUtils.getBaseMonth( new DailyPeriodType() ), 0 );\n    }\n\n}", "prediction": "        assertEquals( 1, AnalyticsUtils.getBaseMonth( new FinancialOctoberPeriodType() ) );\n        assertEquals( 1, AnalyticsUtils.getBaseMonth( new FinancialJulyPeriodType() ) );\n        assertEquals( 1, AnalyticsUtils.getBaseMonth( new FinancialAprilPeriodType() ) );\n        assertEquals( 1, AnalyticsUtils.getBaseMonth( new FinancialMarchPeriodType() ) );\n        assertEquals( 1, AnalyticsUtils.getBaseMonth( new FinancialJanuaryPeriodType() ) );\n        assertEquals( 1, AnalyticsUtils.getBaseMonth( new FinancialSeptemberPeriodType() ) );\n", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "67030086_34", "part": [1, 1], "seq": [1, 1], "prompt": "class ArgumentPatternMatcher {\n\n    public static List<String> arguments(Pattern pattern, String state) {\n        final List<String> argumentsValues = new ArrayList<>();\n        Matcher matcher = pattern.matcher(state);\n        if (matcher.lookingAt()) {\n            for (int i = 1; i <= matcher.groupCount(); i++) {\n                int startIndex = matcher.start(i);\n\n                if (startIndex == -1) {\n                    argumentsValues.add(\"\");\n                } else {\n                    argumentsValues.add(matcher.group(i));\n                }\n            }\n        }\n\n        return argumentsValues;\n    }\n\n    public  ArgumentPatternMatcher();\n\n}\n\nclass ArgumentPatternMatcherTest {\n\n    @Test\n    public void should_not_extract_anything_if_no_matches() {\n", "reference": "        List<String> arguments = ArgumentPatternMatcher.arguments(Pattern.compile(\"The following animals: (.*)\"),\n            \"I have 36 cukes in my belly\");\n        assertThat(arguments).isEmpty();\n    }\n\n}", "prediction": "        Pattern pattern = Pattern.compile(\".*\");\n        String state = \"foo\";\n\n        List<String> argumentsValues = ArgumentPatternMatcher.arguments(pattern, state);\n\n        assertThat(argumentsValues).isEmpty();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "67588628_118", "part": [1, 1], "seq": [1, 1], "prompt": "class DefaultVertexTraversal extends AbstractVertexTraversal implements VertexTraversal {\n\n    @Override\n    public <T> VertexTraversal filter(Predicate<T> predicate) {\n        requireNonNull(predicate, \"predicate is required\");\n\n        Predicate<Traverser<Vertex>> p = v -> predicate.test(converter.toEntity(v.get()));\n        return new DefaultVertexTraversal(supplier, flow.andThen(g -> g.filter(p)), converter);\n    }\n\n      DefaultVertexTraversal(Supplier<GraphTraversal<?, ?>> supplier,\n                           Function<GraphTraversal<?, ?>, GraphTraversal<Vertex, Vertex>> flow,\n                           GraphConverter converter);\n\n    @Override public VertexTraversal has(String propertyKey, Object value);\n    @Override public VertexTraversal has(String propertyKey);\n    @Override public VertexTraversal has(String propertyKey, P<?> predicate);\n    @Override public VertexTraversal has(T accessor, Object value);\n    @Override public VertexTraversal has(T accessor, P<?> predicate);\n    @Override public VertexTraversal out(String... labels);\n    @Override public EdgeTraversal outE(String... edgeLabels);\n    @Override public VertexTraversal in(String... labels);\n    @Override public EdgeTraversal inE(String... edgeLabels);\n    @Override public VertexTraversal both(String... labels);\n    @Override public EdgeTraversal bothE(String... edgeLabels);\n    @Override public VertexRepeatTraversal repeat();\n    @Override public VertexTraversal limit(long limit);\n    @Override public VertexTraversal range(long start, long end);\n    @Override public VertexTraversal hasLabel(String label);\n    @Override public VertexTraversal hasLabel(Class<T> entityClass);\n    @Override public VertexTraversal hasLabel(P<String> predicate);\n    @Override public VertexTraversal hasNot(String propertyKey);\n    @Override public Optional<T> next();\n    @Override public Stream<T> stream();\n    @Override public Optional<T> getSingleResult();\n    @Override public List<T> getResultList();\n    @Override public Stream<T> next(int limit);\n    @Override public ValueMapTraversal valueMap(String... propertyKeys);\n    @Override public long count();\n    @Override public VertexTraversalOrder orderBy(String property);\n\n}\n\nclass DefaultVertexTraversalTest extends AbstractVertexTraversal {\n\n    @Test\n    public void shouldReturnErrorWhenPredicateIsNull() {\n", "reference": "        assertThrows(NullPointerException.class, () -> graphTemplate.getTraversalVertex().filter(null));\n    }\n\n}", "prediction": "        assertThatThrownBy(() -> traversal.filter(null))\n                .isInstanceOf(IllegalArgumentException.class)\n                .hasMessage(\"predicate is required\");\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "68935766_90", "part": [1, 1], "seq": [1, 1], "prompt": "class OptionalContext extends CommandContext<T> {\n\n    public <V> @Nullable V getOptionalArgument(String name, Class<V> type) {\n        return getOptionalArgument(name, type, null);\n    }\n\n    public  OptionalContext(CommandContext<T> context);\n\n    public V getOptionalArgument(String name, Class<V> type, V value);\n    @Override public OptionalContext<T> copyFor(T source);\n    @Override public CommandContext<T> getChild();\n    @Override public CommandContext<T> getLastChild();\n    @Override public Command<T> getCommand();\n    @Override public T getSource();\n    @Override public V getArgument(String name, Class<V> type);\n    @Override public RedirectModifier<T> getRedirectModifier();\n    @Override public StringRange getRange();\n    @Override public String getInput();\n    @Override public List<ParsedCommandNode<T>> getNodes();\n    @Override public boolean isForked();\n    @Override public boolean equals(Object other);\n    @Override public int hashCode();\n\n    static final Object SOURCE;\n    static final Command<Object> COMMAND;\n    static final CommandNode<Object> NODE;\n    static final StringRange RANGE;\n    static final RedirectModifier<Object> MODIFIER;\n    static final CommandContext<Object> DELEGATE;\n    static final OptionalContext<Object> CONTEXT;\n\n}\n\nclass OptionalContextTest {\n\n    static final Object SOURCE;\n    static final Command<Object> COMMAND;\n    static final CommandNode<Object> NODE;\n    static final StringRange RANGE;\n    static final RedirectModifier<Object> MODIFIER;\n    static final CommandContext<Object> DELEGATE;\n    static final OptionalContext<Object> CONTEXT;\n\n    @Test\n    void getOptionalArgument_default() {\n", "reference": "        assertEquals(\"value\", CONTEXT.getOptionalArgument(\"argument\", String.class, \"value\"));\n    }\n\n}", "prediction": "        assertEquals(Optional.empty(), CONTEXT.getOptionalArgument(\"foo\", String.class));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "69031608_6", "part": [1, 1], "seq": [1, 1], "prompt": "class CodeBlocks {\n\n    @Nonnull\n    public static CodeBlock createUnmodifiableStatement(@Nonnull TypeMirror type, @Nonnull String variable) {\n        if (type.getKind() == TypeKind.ARRAY) {\n            return CodeBlock.of(\"$T.copyOf($N, $N.length)\", Arrays.class, variable, variable);\n        }\n\n        if (MoreTypes.isTypeOf(List.class, type)) {\n            return CodeBlock.of(\"new $T<>($N)\", ArrayList.class, variable);\n        }\n\n        if (MoreTypes.isTypeOf(Set.class, type)) {\n            return CodeBlock.of(\"new $T<>($N)\", HashSet.class, variable);\n        }\n\n        if (MoreTypes.isTypeOf(Map.class, type)) {\n            return CodeBlock.of(\"new $T<>($N)\", HashMap.class, variable);\n        }\n        return CodeBlock.of(\"$N\", variable);\n    }\n\n    private  CodeBlocks();\n\n    @Rule\n    public CompilationRule compilationRule;\n    private Elements elements;\n\n}\n\nclass CodeBlocksTest {\n\n    @Rule\n    public CompilationRule compilationRule;\n    private Elements elements;\n\n    @Test\n    public void createUnmodifiableStatementShouldCopyListDefensively() throws Exception {\n", "reference": "        // setup\n        final TypeElement element = elements.getTypeElement(List.class.getCanonicalName());\n        final TypeMirror mirror = element.asType();\n\n        // exercise\n        final CodeBlock actual = CodeBlocks.createUnmodifiableStatement(mirror, \"value\");\n\n        // verify\n        assertThat(actual.toString())\n                .isEqualTo(\"new java.util.ArrayList<>(value)\");\n    }\n\n}", "prediction": "        TypeElement typeElement = compilationRule.getElements().getTypeElement(\"test.Test\");\n        TypeMirror type = typeElement.asType();\n        String variable = \"list\";\n        CodeBlock codeBlock = CodeBlocks.createUnmodifiableStatement(type, variable);\n        assertThat(codeBlock.toString()).isEqualTo(\"new $T<>($N)\", ArrayList.class, variable);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "69356520_2", "part": [1, 1], "seq": [1, 1], "prompt": "class UPS extends Patcher {\n\n    public static UpsCrc readUpsCrc(Context context, File f) throws PatchException, IOException {\n        BufferedInputStream stream = null;\n        try {\n            stream = new BufferedInputStream(new FileInputStream(f));\n            CRC32 crc = new CRC32();\n            int x;\n            for (long i = f.length() - 12; i != 0; i--) {\n                x = stream.read();\n                if (x == -1)\n                    throw new PatchException(context.getString(R.string.notify_error_patch_corrupted));\n                crc.update(x);\n            }\n\n            long inputCrc = 0;\n            for (int i = 0; i < 4; i++) {\n                x = stream.read();\n                if (x == -1)\n                    throw new PatchException(context.getString(R.string.notify_error_patch_corrupted));\n                crc.update(x);\n                inputCrc += ((long) x) << (i * 8);\n            }\n\n            long outputCrc = 0;\n            for (int i = 0; i < 4; i++) {\n                x = stream.read();\n                if (x == -1)\n                    throw new PatchException(context.getString(R.string.notify_error_patch_corrupted));\n                crc.update(x);\n                outputCrc += ((long) x) << (i * 8);\n            }\n\n            long realPatchCrc = crc.getValue();\n            long patchCrc = readLong(stream);\n            if (patchCrc == -1)\n                throw new PatchException(context.getString(R.string.notify_error_patch_corrupted));\n            return new UpsCrc(inputCrc, outputCrc, patchCrc, realPatchCrc);\n        } finally {\n            IOUtils.closeQuietly(stream);\n        }\n    }\n\n    public  UPS(Context context, File patch, File rom, File output);\n\n    @Override public void apply(boolean ignoreChecksum);\n    private Pair decode(BufferedInputStream stream);\n    public static boolean checkMagic(File f);\n    private static long readLong(BufferedInputStream stream);\n\n    private static final String PATCH_CORRUPTED;\n    @Rule\n    public TemporaryFolder folder;\n    @Mock Context mockContext;\n\n}\n\nclass UPSTest {\n\n    private static final String PATCH_CORRUPTED;\n    @Rule\n    public TemporaryFolder folder;\n    @Mock Context mockContext;\n\n    @Test\n    public void testReadUpsCrc() throws Exception {\n", "reference": "        File patch = new File(this.getClass().getResource(\"/ups/readUpsCrc.ups\").getPath());\n        UPS.UpsCrc pCrc = null;\n        try {\n            pCrc = UPS.readUpsCrc(mockContext, patch);\n        } catch (PatchException e) {\n            fail(\"Patch exception\");\n        }\n        assertEquals(pCrc.getPatchFileCRC(), pCrc.getRealPatchCRC());\n    }\n\n}", "prediction": "        File f = folder.newFile(\"ups.ups\");\n        FileOutputStream stream = new FileOutputStream(f);\n        stream.write(UPS.UPS_MAGIC);\n        stream.write(UPS.UPS_VERSION);\n        stream.write(UPS.UPS_CRC_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.UPS_PATCH_SIZE);\n        stream.write(UPS.", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "69645155_2", "part": [1, 1], "seq": [1, 1], "prompt": "class DrawMargin {\n\n    public static double GetDrawMarginFromDrawProbability(double drawProbability, double beta) {\n\n        /*\n         * Derived from TrueSkill technical report (MSR-TR-2006-80), page 6\n         *\n         * draw probability = 2 * CDF(margin/(sqrt(n1+n2)*beta)) -1\n         * implies\n         * margin = inversecdf((draw probability + 1)/2) * sqrt(n1+n2) * beta\n         * where n1 and n2 are the number of players on each team\n         */\n        return inverseCumulativeTo(.5 * (drawProbability + 1), 0, 1) * Math.sqrt(1 + 1) * beta;\n    }\n\n    private static final double ErrorTolerance;\n\n}\n\nclass DrawMarginTest {\n\n    private static final double ErrorTolerance;\n\n    @Test\n    public void GetDrawMarginFromDrawProbabilityTest() {\n", "reference": "        double beta = 25.0 / 6.0;\n        // The expected values were compared against Ralf Herbrich's implementation in F#\n        AssertDrawMargin(0.10, beta, 0.74046637542690541);\n        AssertDrawMargin(0.25, beta, 1.87760059883033);\n        AssertDrawMargin(0.33, beta, 2.5111010132487492);\n    }\n\n}", "prediction": "        Assert.assertEquals(DrawMargin.GetDrawMarginFromDrawProbability(0.0, 1.0), 0.0, ErrorTolerance);\n        Assert.assertEquals(DrawMargin.GetDrawMarginFromDrawProbability(0.0, 2.0), 0.0, ErrorTolerance);\n        Assert.assertEquals(DrawMargin.GetDrawMarginFromDrawProbability(0.0, 3.0), 0.0, ErrorTolerance);\n        Assert.assertEquals(DrawMargin.GetDrawMarginFromDrawProbability(0.0, 4.0), 0.0, ErrorTolerance);\n        Assert.assertEquals(DrawMargin.GetDrawMarginFromDrawProbability(0.0, 5.0), 0.0, ErrorTolerance);\n        Assert.assertEquals(DrawMargin.GetDrawMarginFromDrawProbability(0.0, 6.0), 0.0, ErrorTolerance);\n        Assert.assertEquals(DrawMargin.GetDrawMarginFromDrawProbability(0.0, 7.0), 0.0, ErrorTolerance);\n        Assert.assertEquals(DrawMargin.GetDrawMarginFromDrawProbability(0.0, 8.0), 0.0, ErrorTolerance);\n        Assert.assertEquals(DrawMargin.GetDrawMarginFromDrawProbability(0.0, 9.0), 0.0, ErrorTolerance);\n        Assert.assertEquals(DrawMargin.GetDrawMarginFromDrawProbability(0.0, 10.0), 0.0, ErrorTolerance);\n\n        Assert.assertEquals(DrawMargin.GetDrawMarginFromDrawProbability(0.1, 1.0), 0.0, ErrorTolerance);\n        Assert.assertEquals(DrawMargin.GetDrawMarginFromDrawProbability(0.1, 2.0), 0.0, ErrorTolerance);\n        Assert.assertEquals(DrawMargin.GetDrawMarginFromDrawProbability(0.1, 3.0), 0.0, ErrorTolerance);\n        Assert.assertEquals(DrawMargin.GetDrawMarginFromDrawProbability(0.1, 4.0), 0.0, ErrorTolerance);\n        Assert.assertEquals(DrawMargin.GetDrawMarginFromDrawProbability(0.1, 5.0), 0.0, ErrorTolerance);\n        Assert.assertEquals(DrawMargin.GetDrawMarginFromDrawProbability(0.1, 6.0), 0.0, ErrorTolerance);\n        Assert.assertEquals(DrawMargin.GetDrawMarginFromDrawProbability(0.1, 7.0), 0.0, ErrorTolerance);\n        Assert.assertEquals(DrawMargin.GetDrawMarginFromDrawProbability(0.1, 8.0), 0.0, ErrorTolerance);\n        Assert.assertEquals(DrawMargin.GetDrawMarginFromDrawProbability(0.1, 9.0), 0.0, ErrorTolerance);\n        Assert.assertEquals(DrawMargin.GetDrawMarginFromDrawProbability(0.1, 10.0), 0.0, ErrorTolerance);\n\n        Assert.assertEquals(DrawMargin.GetDrawMarginFromDrawProbability(0.2, 1.0), 0.0, ErrorTolerance);\n        Assert.assertEquals(DrawMargin.GetDrawMarginFromDrawProbability(0.2, 2.0), 0.0, ErrorTolerance);\n        Assert.assertEquals(DrawMargin.GetDrawMarginFromDrawProbability(0.2, 3.0), 0.0, ErrorTolerance);\n        Assert.assertEquals(DrawMargin.GetDrawMarginFromDrawProbability(0.2, 4.0), 0.0, ErrorTolerance);\n        Assert.assertEquals(DrawMargin.GetDrawMarginFromDrawProbability(0.2, 5.0), 0.0, ErrorTolerance);\n        Assert.assertEquals(DrawMargin.GetDrawMarginFromDrawProbability(0.2, 6.0), 0.0, ErrorTolerance);\n        Assert.assertEquals(DrawMargin.GetDrawMarginFromDrawProbability(0.2, 7.0), 0.0, ErrorTolerance);\n        Assert.assertEquals(DrawMargin.GetDrawMarginFromDrawProbability(0.2, 8.0), 0.0, ErrorTolerance);\n        Assert.assertEquals(DrawMargin.GetDrawMarginFromDrawProbability(0.2, 9.0), 0.0, ErrorTolerance);\n        Assert.assertEquals(DrawMargin.GetDrawMarginFromDrawProbability(0.2, 10.0), 0.0, ErrorTolerance);\n\n        Assert.assertEquals(DrawMargin.GetDrawMarginFromDrawProbability(0.3, 1.0), 0.0, ErrorTolerance);\n        Assert.assertEquals(DrawMargin.GetDrawMarginFromDrawProbability(0.3, 2.0), 0.0, ErrorTolerance);\n        Assert.assertEquals(DrawMargin.GetDrawMarginFromDrawProbability(0.3, 3.0), 0.0, ErrorTolerance);\n        Assert.assertEquals(DrawMargin.GetDrawMarginFromDrawProbability(0.3, 4.0), 0", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "70374047_3", "part": [1, 1], "seq": [1, 1], "prompt": "class Exif {\n\n    public void save() throws IOException {\n        if (!mRemoveTimestamp) {\n            attachLastModifiedTimestamp();\n        }\n        mExifInterface.saveAttributes();\n    }\n\n    public  Exif(File file);\n    public  Exif(String filePath);\n    public  Exif(InputStream is);\n    private  Exif(ExifInterface exifInterface);\n\n    @Override public String toString();\n    private int getOrientation();\n    public int getWidth();\n    public int getHeight();\n    @Nullable public String getDescription();\n    public void setDescription(@Nullable String description);\n    public int getRotation();\n    public boolean isFlippedVertically();\n    public boolean isFlippedHorizontally();\n    private void attachLastModifiedTimestamp();\n    public long getLastModifiedTimestamp();\n    public long getTimestamp();\n    @Nullable public Location getLocation();\n    public void rotate(int degrees);\n    public void flipVertically();\n    public void flipHorizontally();\n    public void attachTimestamp();\n    public void removeTimestamp();\n    public void attachLocation(Location location);\n    public void removeLocation();\n    private long parseTimestamp(@Nullable String date, @Nullable String time);\n    private long parseTimestamp(@Nullable String datetime);\n    private static String convertToExifDateTime(long timestamp);\n    private static Date convertFromExifDateTime(String dateTime);\n    private static String convertToExifDate(long timestamp);\n    private static Date convertFromExifDate(String date);\n    private static String convertToExifTime(long timestamp);\n    private static Date convertFromExifTime(String time);\n\n     Exif exif;\n\n}\n\nclass ExifTest {\n\n     Exif exif;\n\n    @Test\n    public void save() {\n", "reference": "        assertEquals(-1, exif.getLastModifiedTimestamp());\n\n        try {\n            exif.save();\n        } catch (IOException e) {\n            // expected\n        }\n\n        assertWithin(System.currentTimeMillis(), exif.getLastModifiedTimestamp(), 3);\n\n        // removeTimestamp should also be clearing the last modified timestamp\n        exif.removeTimestamp();\n        assertEquals(-1, exif.getLastModifiedTimestamp());\n\n        // Even when saving again\n        try {\n            exif.save();\n        } catch (IOException e) {\n            // expected\n        }\n\n        assertEquals(-1, exif.getLastModifiedTimestamp());\n    }\n\n}", "prediction": "        exif.save();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "70515197_5", "part": [1, 1], "seq": [1, 1], "prompt": "class CerberusMetadataLookup {\n\n    public ArrayList<String> searchCerberusMetadata(ArrayList<Map<String, String>> sdbMetadata, String sdbName, String principalName) {\n\n        if (sdbMetadata == null) {\n            throw new NullPointerException(\"SDB Metadata is empty\");\n        }\n\n        ArrayList<String> owner = new ArrayList<>();\n\n        for (Map<String, String> entry : sdbMetadata) {\n\n            if (entry.get(\"path\").contains(sdbName) && !sdbName.isEmpty()) {\n                owner.add(entry.get(\"owner\"));\n                if (entry.get(\"created_by\").contains(EMAIL_SYMBOL)) owner.add(entry.get(\"created_by\"));\n                if (entry.get(\"last_updated_by\").contains(EMAIL_SYMBOL)\n                        && !entry.get(\"last_updated_by\").equals(entry.get(\"created_by\"))) {\n                    owner.add(entry.get(\"last_updated_by\"));\n                }\n                return owner;\n            } else {\n                if (entry.containsValue(principalName)) {\n                    owner.add(entry.get(\"owner\"));\n                    if (entry.get(\"created_by\").contains(EMAIL_SYMBOL)) owner.add(entry.get(\"created_by\"));\n                    if (entry.get(\"last_updated_by\").contains(EMAIL_SYMBOL)\n                            && !entry.get(\"last_updated_by\").equals(entry.get(\"created_by\"))) {\n                        owner.add(entry.get(\"last_updated_by\"));\n                    }\n                    return owner;\n                }\n            }\n        }\n\n        owner.add(\"No owner found\");\n        return owner;\n    }\n\n    private OkHttpClient createHttpClient();\n    public ArrayList<Map<String, String>> getCerberusMetadata(String environment);\n    private HashMap executeRequest(OkHttpClient httpClient, DefaultCerberusCredentialsProviderChain chain,\n                                   String cerberusUrl, String offset);\n\n    private static final String ERROR_RESPONSE;\n    private static final String mockResponseBodyString;\n    private static final String emptyMetadataResponseBodyString;\n    private CerberusMetadataLookup cerberusMetadataLookup;\n\n}\n\nclass CerberusMetadataLookupTest {\n\n    private static final String ERROR_RESPONSE;\n    private static final String mockResponseBodyString;\n    private static final String emptyMetadataResponseBodyString;\n    private CerberusMetadataLookup cerberusMetadataLookup;\n\n    @Test\n    public void test_search_cerberus_metadata_parameters_empty() throws IOException {\n", "reference": "        HashMap result = new ObjectMapper().readValue(mockResponseBodyString, HashMap.class);\n        ArrayList<Map<String, String>> sdbMetadata = (ArrayList<Map<String, String>>) result.get(\"safe_deposit_box_metadata\");\n\n        ArrayList<String> results = cerberusMetadataLookup.searchCerberusMetadata(sdbMetadata, \"\", \"\");\n        assertTrue(results.contains(\"No owner found\"));\n    }\n\n}", "prediction": "        ArrayList<String> owner = cerberusMetadataLookup.searchCerberusMetadata(null, \"\", \"\");\n        assertEquals(owner.get(0), \"No owner found\");\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "70767609_3", "part": [1, 1], "seq": [1, 1], "prompt": "class TicketAgentClient {\n\n  @SuppressWarnings(\"unchecked\")\n  public List<BigInteger> listFlights() {\n    ObjectFactory factory = new ObjectFactory();\n    TListFlights tListFlights = factory.createTListFlights();\n\n    JAXBElement<TListFlights> request = factory.createListFlightsRequest(tListFlights);\n\n    // use SoapActionCallback to add the SOAPAction\n    JAXBElement<TFlightsResponse> response =\n        (JAXBElement<TFlightsResponse>) webServiceTemplate.marshalSendAndReceive(request,\n            new SoapActionCallback(\"http://example.com/TicketAgent/listFlights\"));\n\n    return response.getValue().getFlightNumber();\n  }\n\n  @Autowired\n  private TicketAgentClient ticketAgentClient;\n  @Autowired\n  private WebServiceTemplate webServiceTemplate;\n  private MockWebServiceServer mockWebServiceServer;\n\n}\n\nclass TicketAgentClientTest {\n\n  @Autowired\n  private TicketAgentClient ticketAgentClient;\n  @Autowired\n  private WebServiceTemplate webServiceTemplate;\n  private MockWebServiceServer mockWebServiceServer;\n\n  @Test\n  public void testListFlights() {\n", "reference": "    Source requestPayload =\n        new StringSource(\"<ns3:listFlightsRequest xmlns:ns3=\\\"http://example.org/TicketAgent.xsd\\\">\"\n            + \"</ns3:listFlightsRequest>\");\n\n    Source responsePayload =\n        new StringSource(\"<v1:listFlightsResponse xmlns:v1=\\\"http://example.org/TicketAgent.xsd\\\">\"\n            + \"<flightNumber>101</flightNumber>\" + \"</v1:listFlightsResponse>\");\n\n    // check if the SOAPAction is present using the custom matcher\n    mockWebServiceServer.expect(new SoapActionMatcher(\"http://example.com/TicketAgent/listFlights\"))\n        .andExpect(payload(requestPayload)).andRespond(withPayload(responsePayload));\n\n    List<BigInteger> flights = ticketAgentClient.listFlights();\n    assertThat(flights.get(0)).isEqualTo(BigInteger.valueOf(101));\n\n    mockWebServiceServer.verify();\n  }\n\n}", "prediction": "    mockWebServiceServer.expectSoapAction(\"http://example.com/TicketAgent/listFlights\")\n        .andRespond(withPayload(\"<ticketAgentResponse xmlns=\\\"http://example.com/TicketAgent\\\"><flightNumber>123</flightNumber></ticketAgentResponse>\"));\n\n    List<BigInteger> flightNumbers = ticketAgentClient.listFlights();\n\n    assertThat(flightNumbers).containsExactly(BigInteger.valueOf(123));\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "70856121_41", "part": [1, 1], "seq": [1, 1], "prompt": "class ClusterFacade {\n\n  public static CompactionStats parseCompactionStats(String json) throws IOException {\n    try {\n      return parseJson(json, new TypeReference<CompactionStats>(){});\n    } catch (IOException e) {\n      // it can be that the storage had old format of compaction info, so we try to parse that\n      List<Compaction> compactions = parseJson(json, new TypeReference<List<Compaction>>() {});\n      return CompactionStats.builder()\n          .withPendingCompactions(-1)\n          .withActiveCompactions(compactions)\n          .build();\n    }\n  }\n\n  private  ClusterFacade(AppContext context);\n\n  public static ClusterFacade create(AppContext context);\n  public JmxProxy preHeatJmxConnections(Cluster cluster, Collection<String> endpoints);\n  public String getClusterName(Cluster cluster, Collection<String> endpoints);\n  public String getClusterName(Node node);\n  public String getPartitioner(Cluster cluster, Collection<String> endpoints);\n  public List<String> getLiveNodes(Cluster cluster);\n  public List<String> getLiveNodes(Cluster cluster, Collection<String> endpoints);\n  public NodesStatus getNodesStatus(Cluster cluster, Collection<String> endpoints);\n  public String getCassandraVersion(Cluster cluster);\n  public String getCassandraVersion(Cluster cluster, Collection<String> endpoints);\n  public List<BigInteger> getTokens(Cluster cluster);\n  public Map<List<String>, List<String>> getRangeToEndpointMap(\n      Cluster cluster,\n      String keyspace);\n  public Set<Table> getTablesForKeyspace(Cluster cluster, String keyspaceName);\n  public Map<String, List<String>> listTablesByKeyspace(Cluster cluster);\n  public List<String> getKeyspaces(Cluster cluster);\n  public Map<String, String> getEndpointToHostId(Cluster cluster);\n  public List<String> tokenRangeToEndpoint(Cluster cluster, String keyspace, Segment segment);\n  public List<RingRange> getRangesForLocalEndpoint(Cluster cluster, String keyspace);\n  public String getDatacenter(Cluster cluster, String endpoint);\n  public String getDatacenter(Node node);\n  public String getLocalEndpoint(Node node);\n  public Map<String, List<String>> getTokensByNode(Cluster cluster);\n  public CompactionStats listActiveCompactions(Node node);\n  public CompactionStats listCompactionStatsDirect(Node node);\n  public boolean nodeIsAccessibleThroughJmx(String nodeDc, String node);\n  public Map<String, List<JmxStat>> collectMetrics(Node node, String[] collectedMetrics);\n  public List<MetricsHistogram> getClientRequestLatencies(Node node);\n  public List<DroppedMessages> getDroppedMessages(Node node);\n  @VisibleForTesting public List<DroppedMessages> convertToDroppedMessages(List<GenericMetric> metrics);\n  public List<ThreadPoolStat> getTpStats(Node node);\n  @VisibleForTesting public List<ThreadPoolStat> convertToThreadPoolStats(List<GenericMetric> metrics);\n  @VisibleForTesting public List<MetricsHistogram> convertToMetricsHistogram(List<GenericMetric> metrics);\n  public Pair<Node, String> takeSnapshot(String snapshotName, Node host, String... keyspaces);\n  public List<Snapshot> listSnapshots(Node host);\n  public void clearSnapshot(String snapshotName, Node host);\n  public List<StreamSession> listActiveStreams(Node node);\n  public List<StreamSession> listStreamsDirect(Node node);\n  private Set<Table> getTablesForKeyspaceImpl(Cluster cluster, String keyspaceName);\n  private Map<List<String>, List<String>> getRangeToEndpointMapImpl(\n      Cluster cluster,\n      String keyspace);\n  public static List<StreamSession> parseStreamSessionJson(String json);\n  private static T parseJson(String json, TypeReference<T> ref);\n  public JmxProxy connect(Cluster cluster);\n  public JmxProxy connect(Cluster cluster, Collection<String> endpoints);\n  public JmxProxy connect(Node node);\n  public JmxProxy connect(Node node, Collection<String> endpoints);\n  private JmxProxy connectImpl(Cluster cluster, Collection<String> endpoints);\n  private JmxProxy connectImpl(Node node, Collection<String> endpoints);\n  private Collection<String> enforceLocalNodeForSidecar(Collection<String> endpoints);\n\n}\n\nclass ClusterFacadeTest {\n\n  @Test\n  public void parseCompactionStatsTest() throws IOException {\n", "reference": "    final ObjectMapper objectMapper = new ObjectMapper();\n    Compaction compaction = Compaction.builder()\n        .withId(\"foo\")\n        .withKeyspace(\"ks\")\n        .withTable(\"t\")\n        .withProgress(64L)\n        .withTotal(128L)\n        .withType(\"Validation\")\n        .withUnit(\"unit\")\n        .build();\n    CompactionStats originalCompactionStats = CompactionStats.builder()\n        .withActiveCompactions(ImmutableList.of(compaction))\n        .withPendingCompactions(42)\n        .build();\n    String compactionJson = objectMapper.writeValueAsString(originalCompactionStats);\n    CompactionStats compactionStats = ClusterFacade.parseCompactionStats(compactionJson);\n    assertEquals(42L, compactionStats.getPendingCompactions().longValue());\n  }\n\n}", "prediction": "    String json = \"{\\\"pending_compactions\\\": 0, \\\"compactions_in_progress\\\": [{\\\"keyspace_name\\\": \\\"system_auth\\\", \\\"columnfamily_name\\\": \\\"roles\\\", \\\"id\\\": 1, \\\"bytes_compacted\\\": 0, \\\"bytes_in_progress\\\": 0, \\\"total_bytes\\\": 0, \\\"unit\\\": \\\"bytes\\\"}]}\";\n    CompactionStats stats = ClusterFacade.parseCompactionStats(json);\n    assertEquals(0, stats.getPendingCompactions());\n    assertEquals(1, stats.getActiveCompactions().size());\n  }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "71268678_2", "part": [1, 1], "seq": [1, 1], "prompt": "class TodoActivity extends Activity {\n\n\tTodoProvider getProvider()\n\t{\n\t\treturn TodoActivity.this.dataProvider;\n\t}\n\n\t EditText getEditableTextbox();\n\t Button getSaveTaskButton();\n\t ListView getTaskListView();\n\t@Override public void onCreate(final Bundle bundle);\n\tprivate void render();\n\n}\n\nclass TodoActivityTest {\n\n\t@Test\n\tpublic void should_remove_task() throws Exception\n\t{\n", "reference": "\t\tfinal TodoActivity activity = Robolectric.buildActivity(TodoActivity.class).create().get();\n\n\t\tactivity.getProvider().addTask(\"Some task\");\n\t\tactivity.getProvider().deleteTask(\"Some task\");\n\t\tfinal List<String> tasks = activity.getProvider().findAll();\n\t\tAssert.assertEquals(tasks.size(), 0);\n\t}\n\n}", "prediction": "\t\t// given\n\t\tfinal TodoActivity activity = new TodoActivity();\n\t\tfinal TodoProvider provider = activity.getProvider();\n\t\tfinal Todo todo = new Todo(\"test\");\n\t\tprovider.add(todo);\n\t\tfinal ListView listView = activity.getTaskListView();\n\t\tfinal int position = listView.getAdapter().getCount() - 1;\n\t\tfinal View view = listView.getChildAt(position);\n\t\tfinal Button deleteButton = (Button) view.findViewById(R.id.delete_button);\n\n\t\t// when\n\t\tdeleteButton.performClick();\n\n\t\t// then\n\t\tassertThat(listView.getAdapter().getCount(), is(0));\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "71328643_1", "part": [1, 1], "seq": [1, 1], "prompt": "class SecurityService {\n\n    public Boolean hasUserPermissionToObject(final User user, final PermissionName permissionName, final SecurableModel securableModel) {\n        if (user == null) {\n            throw new IllegalArgumentException(\"User can not be null.\");\n        }\n        if (permissionName == null) {\n            throw new IllegalArgumentException(\"Permission Name can not be null.\");\n        }\n        if (securableModel == null) {\n            throw new IllegalArgumentException(\"SecurableModel can not be null.\");\n        }\n\n        if (hasUserPermissionToClass(user, permissionName, securableModel.getClass().getCanonicalName())) {\n            return true;\n        }\n\n        final List<Long> userRoleIds = new ArrayList<>();\n        for (Role role : user.getRoles()) {\n            userRoleIds.add(role.getId());\n        }\n        final List<AclEntry> rolesAclEntries = aclEntryService.findAll(permissionName, AclSidType.ROLE, userRoleIds, AclClassName.getByName(securableModel.getClass().getCanonicalName()), securableModel.getId());\n\n        if (rolesAclEntries.size() > 0) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"User \" + user.getUsername() + \" has permission \" + permissionName + \" to object \" + securableModel.getClass().getCanonicalName() + \"[id=\" + securableModel.getId() + \"] based on the ACL security settings.\");\n            }\n            return true;\n        }\n\n        if (securableModel.getCreatedBy() != null && securableModel.getCreatedBy().getId().equals(user.getId())) {\n            List<AclEntry> ownerAclEntries = aclEntryService.findAll(permissionName, AclSidType.OWNER, 0L, AclClassName.getByName(securableModel.getClass().getCanonicalName()), securableModel.getId());\n            if (ownerAclEntries.size() > 0) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"User \" + user.getUsername() + \" has permission \" + permissionName + \" to object \" + securableModel.getClass().getCanonicalName() + \"[id=\" + securableModel.getId() + \"] based on that he is the owner.\");\n                }\n                return true;\n            }\n        }\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"User \" + user.getUsername() + \" has not permission \" + permissionName + \" to object \" + securableModel.getClass().getCanonicalName() + \"[id=\" + securableModel.getId() + \"].\");\n        }\n        return false;\n    }\n\n    @Autowired public  SecurityService(UserService userService,\n                           AclEntryService aclEntryService);\n\n    public Boolean hasUserPermissionToClass(User user, PermissionName permissionName, String domainCanonicalClassName);\n    public PlatformUser getAuthorizedUser();\n    public boolean hasPermission(String username, SecurableModel securibleObject, String permissionName);\n\n    @Resource\n    private UserRepository userRepository;\n    @Resource\n    private PageRepository pageRepository;\n    @Resource\n    private ModuleRepository moduleRepository;\n    @Autowired\n    private SecurityService securityService;\n\n}\n\nclass SecurityServiceTest {\n\n    @Resource\n    private UserRepository userRepository;\n    @Resource\n    private PageRepository pageRepository;\n    @Resource\n    private ModuleRepository moduleRepository;\n    @Autowired\n    private SecurityService securityService;\n\n    @Ignore\n    @Test\n    public void userAdminHasPermissionToAddModule() {\n", "reference": "        log.debug(\"userAdminHasPermissionToAddModule()\");\n        User admin = userRepository.findOne(1L);\n        Module module = moduleRepository.findOne(2L);\n        Boolean hasPermission = securityService.hasUserPermissionToObject(admin, PermissionName.MODULE_ADD, module);\n        assertTrue(hasPermission);\n    }\n\n}", "prediction": "        final User admin = userRepository.findByUsername(\"admin\");\n        final Module module = new Module();\n        module.setName(\"Test Module\");\n        module.setDescription(\"Test Module Description\");\n        module.setCreatedBy(admin);\n        module.setLastModifiedBy(admin);\n        moduleRepository.save(module);\n\n        assertTrue(securityService.hasUserPermissionToObject(admin, PermissionName.ADD, module));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "71779309_25", "part": [1, 1], "seq": [1, 1], "prompt": "class ALU {\n\n\tpublic String ariRightShift (String operand, int n) {\n\t\t\n\t\tStringBuilder builder = new StringBuilder();\n\t\t\n\t\tchar leadingLetter = operand.charAt(0);\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tbuilder.append(leadingLetter);\n\t\t}\n\t\t\n\t\tfor(int i=0;i<operand.length()-n;i++){\n\t\t\tbuilder.append(operand.charAt(i));\n\t\t}\n\t\tbuilder.setLength(operand.length());\n\t\treturn builder.toString();\n\t}\n\n\tpublic static void main(String[] args);\n\tpublic static final boolean floatIsInfinity(String input, int eLength, int sLength);\n\tpublic static final String complementLength(String binary, int length);\n\tpublic static final String repeatedString(String str, int times);\n\tpublic static final String bitOp(String oneBitOperand1, String oneBitOperand2, BinaryOperator<Boolean> op);\n\tpublic static final boolean isSignTheSame(String binary1, String binary2);\n\tpublic static String movePoint(String operand, int offset);\n\tpublic static final char charOp(BinaryOperator<Boolean> op, Character... bits);\n\tpublic static final String stringOp(String operand1, String operand2, BinaryOperator<Boolean> op);\n\tpublic static final boolean xor(boolean operand1, boolean operand2);\n\tpublic static int minBinaryLong(int number);\n\tpublic static String integerBinRepresentationInMinLength(String decimalNumber);\n\tpublic static String get2sComplement(String binaryNumber, boolean isNegative);\n\tpublic String integerRepresentation(String number, int length);\n\tpublic String floatRepresentation(String number, int eLength, int sLength);\n\tpublic String ieee754(String number, int length);\n\tpublic String integerTrueValue(String operand);\n\tpublic String floatTrueValue(String operand, int eLength, int sLength);\n\tpublic String negation(String operand);\n\tpublic String leftShift(String operand, int n);\n\tpublic String logRightShift(String operand, int n);\n\tpublic String fullAdder(char x, char y, char c);\n\tpublic String claAdder(String operand1, String operand2, char c);\n\tpublic String oneAdder(String operand);\n\tpublic String adder(String operand1, String operand2, char c, int length);\n\tpublic String integerAddition(String operand1, String operand2, int length);\n\tpublic String integerSubtraction(String operand1, String operand2, int length);\n\tpublic String integerMultiplication(String operand1, String operand2, int length);\n\tpublic String integerDivision(String operand1, String operand2, int length);\n\tpublic String signedAddition(String operand1, String operand2, int length);\n\tpublic String floatAddition(String operand1, String operand2, int eLength, int sLength, int gLength);\n\tpublic String floatSubtraction(String operand1, String operand2, int eLength, int sLength, int gLength);\n\tpublic String floatMultiplication(String operand1, String operand2, int eLength, int sLength);\n\tpublic String floatDivision(String operand1, String operand2, int eLength, int sLength);\n\tpublic String trueFormDivision(String operand1, String operand2, int length);\n\n\t ALU ALU;\n\n}\n\nclass TestALU {\n\n\t ALU ALU;\n\n\t@Test\n\tpublic void testAriRightShift(){\n", "reference": "\t\tassertEquals(\"11110011\",ALU.ariRightShift(\"10011011\", 3));\n\t}\n\n}", "prediction": "\t\tassertEquals(\"0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "71792401_3", "part": [1, 1], "seq": [1, 1], "prompt": "class ForbiddenCallRule extends CobolCheck {\n\n  @Override\n  public void visitNode(AstNode callStatementNode) {\n    AstNode calledProgramNode = callStatementNode.getFirstChild(getCobolGrammar().literal);\n    if (calledProgramNode != null && calledProgramNode.getTokenValue().indexOf(\"FORBIDDEN\") > -1) {\n      reportIssue(\"CALL to this program are forbidden.\").on(calledProgramNode);\n    }\n  }\n\n  @Override public void init();\n\n}\n\nclass ForbiddenCallRuleTest {\n\n  @Test\n  public void testVisitNode() {\n", "reference": "    ForbiddenCallRule check = new ForbiddenCallRule();\n    CobolCheckVerifier.verify(\n      new File(\"src/test/resources/checks/SRC/ForbiddenCall.cbl\"),\n      check);\n  }\n\n}", "prediction": "    ForbiddenCallRule rule = new ForbiddenCallRule();\n    rule.init();\n    rule.visitNode(new AstNode(new CobolParser.CallStatementContext(null, 0)));\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "72580689_14", "part": [1, 1], "seq": [1, 1], "prompt": "class TextLayoutBuilder {\n\n  public TextLayoutBuilder setAlignment(Alignment alignment) {\n    if (mParams.alignment != alignment) {\n      mParams.alignment = alignment;\n      mSavedLayout = null;\n    }\n    return this;\n  }\n\n  public TextLayoutBuilder setWidth(@Px int width);\n  public TextLayoutBuilder setWidth(@Px int width, @MeasureMode int measureMode);\n  public CharSequence getText();\n  public TextLayoutBuilder setText(CharSequence text);\n  public float getTextSize();\n  public TextLayoutBuilder setTextSize(int size);\n  @ColorInt public int getTextColor();\n  public TextLayoutBuilder setTextColor(@ColorInt int color);\n  public TextLayoutBuilder setTextColor(ColorStateList colorStateList);\n  @ColorInt public int getLinkColor();\n  public TextLayoutBuilder setLinkColor(@ColorInt int linkColor);\n  public float getTextSpacingExtra();\n  public TextLayoutBuilder setTextSpacingExtra(float spacingExtra);\n  public float getTextSpacingMultiplier();\n  public TextLayoutBuilder setTextSpacingMultiplier(float spacingMultiplier);\n  public float getLineHeight();\n  public TextLayoutBuilder setLineHeight(float lineHeight);\n  @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP) public float getLetterSpacing();\n  @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP) public TextLayoutBuilder setLetterSpacing(float letterSpacing);\n  public boolean getIncludeFontPadding();\n  public TextLayoutBuilder setIncludeFontPadding(boolean shouldInclude);\n  public Alignment getAlignment();\n  public TextDirectionHeuristicCompat getTextDirection();\n  public TextLayoutBuilder setTextDirection(TextDirectionHeuristicCompat textDirection);\n  public TextLayoutBuilder setShadowLayer(float radius, float dx, float dy, @ColorInt int color);\n  public TextLayoutBuilder setTextStyle(int style);\n  public Typeface getTypeface();\n  public TextLayoutBuilder setTypeface(Typeface typeface);\n  public int[] getDrawableState();\n  public TextLayoutBuilder setDrawableState(int[] drawableState);\n  public TextUtils.TruncateAt getEllipsize();\n  public TextLayoutBuilder setEllipsize(TextUtils.TruncateAt ellipsize);\n  @RequiresApi(api = 28) public TextLayoutBuilder setUseLineSpacingFromFallbacks(boolean status);\n  public boolean getUseLineSpacingFromFallbacks();\n  public boolean getSingleLine();\n  public TextLayoutBuilder setSingleLine(boolean singleLine);\n  public int getMaxLines();\n  public TextLayoutBuilder setMaxLines(int maxLines);\n  public int getBreakStrategy();\n  public TextLayoutBuilder setBreakStrategy(int breakStrategy);\n  public int getHyphenationFrequency();\n  public TextLayoutBuilder setHyphenationFrequency(int hyphenationFrequency);\n  public int[] getLeftIndents();\n  public int[] getRightIndents();\n  public TextLayoutBuilder setIndents(int[] leftIndents, int[] rightIndents);\n  public boolean getShouldCacheLayout();\n  public TextLayoutBuilder setShouldCacheLayout(boolean shouldCacheLayout);\n  public boolean getShouldWarmText();\n  public TextLayoutBuilder setShouldWarmText(boolean shouldWarmText);\n  public GlyphWarmer getGlyphWarmer();\n  public TextLayoutBuilder setGlyphWarmer(GlyphWarmer glyphWarmer);\n  public int getMinEms();\n  public TextLayoutBuilder setMinEms(int minEms);\n  @Px public int getMinWidth();\n  public TextLayoutBuilder setMinWidth(@Px int minWidth);\n  public int getMaxEms();\n  public TextLayoutBuilder setMaxEms(int maxEms);\n  @Px public int getMaxWidth();\n  public TextLayoutBuilder setMaxWidth(@Px int maxWidth);\n  public float getDensity();\n  public TextLayoutBuilder setDensity(float density);\n  @RequiresApi(api = Build.VERSION_CODES.O) public int getJustificationMode();\n  @RequiresApi(api = Build.VERSION_CODES.O) public TextLayoutBuilder setJustificationMode(int justificationMode);\n  public TextLayoutBuilder setShouldLayoutZeroLengthText(boolean shouldLayoutZeroLengthText);\n  @Nullable public Layout build();\n\n  private static final String TEST;\n  private static final String LONG_TEXT;\n  private TextLayoutBuilder mBuilder;\n  private Layout mLayout;\n\n}\n\nclass TextLayoutBuilderTest {\n\n  private static final String TEST;\n  private static final String LONG_TEXT;\n  private TextLayoutBuilder mBuilder;\n  private Layout mLayout;\n\n  @Test\n  public void testSetAlignment() {\n", "reference": "    mLayout = mBuilder.setAlignment(Layout.Alignment.ALIGN_CENTER).build();\n    assertEquals(mBuilder.getAlignment(), Layout.Alignment.ALIGN_CENTER);\n    assertEquals(mLayout.getAlignment(), Layout.Alignment.ALIGN_CENTER);\n  }\n\n}", "prediction": "    mBuilder.setAlignment(Alignment.ALIGN_CENTER);\n    assertEquals(Alignment.ALIGN_CENTER, mBuilder.getAlignment());\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "73354878_32", "part": [1, 1], "seq": [1, 1], "prompt": "class VufsServiceImpl implements IVufsService {\n\n    @Override\n    public AllocationStrategy getAllocationStrategyByMetafileUuid(String metafileUuid)\n            throws MetafileDoesNotExistException {\n        for (Metafile metafile : currentMetatable.getMetafileSet()) {\n            if (metafile.getFileUuid().equalsIgnoreCase(metafileUuid)) {\n                return metafile.getAllocationStrategy();\n            }\n        }\n        throw new MetafileDoesNotExistException(getExceptionInfo(currentMetatable, metafileUuid,\n                \"getAllocationStrategyByMetafileUuid\"));\n    }\n\n    @Autowired public  VufsServiceImpl(IProfile profile,\n            MetatableTransformer metatableTransformer,\n            IMetatableService persistingService);\n\n    @Override public Metafile createEmptyMetafile();\n    @Override public Metafile getMetafileByUuid(String fileUuid);\n    @Override public Metafile addBlockByUuidToMetafile(String blockUuid, Metafile metafile);\n    @Override public Metafile removeBlockByUuidFromMetafile(String blockUuid, Metafile metafile);\n    @Override public boolean addMetafileToMetatable(Metafile metafile);\n    @Override public boolean removeMetafileFromMetatable(Metafile metafile);\n    @Override public Set<String> getAllocationByBlockUuid(String blockUuid);\n    @Override public void setAllocationForBlockByUuid(String blockUuid, Set<String> allocationSet);\n    @Override public boolean addMetafileAsChildToParent(Metafile childMetafile,\n            String parentMetafileUuid);\n    @Override public boolean removeMetafileFromParent(String childMetafileUuid,\n            String parentMetafileUuid);\n    @Override public void setAllocationStrategyByMetafileUuid(String metafileUuid,\n            AllocationStrategy allocationStrategy);\n    private String getExceptionInfo(Metatable currentMetatable, String metafileUuid,\n            String methodName);\n    @PreDestroy public void persistChanges();\n\n    private IVufsService vufsService;\n\n}\n\nclass VufsServiceImplTest {\n\n    private IVufsService vufsService;\n\n    @Test(expected = MetafileDoesNotExistException.class)\n    public void getAllocationStrategyByMetafileUuidWithException()\n            throws MetafileDoesNotExistException {\n", "reference": "        //here throw exception\n        AllocationStrategy result = vufsService\n                .getAllocationStrategyByMetafileUuid(UUID.randomUUID().toString());\n    }\n\n}", "prediction": "        vufsService.getAllocationStrategyByMetafileUuid(\"metafileUuid\");\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "73767658_1", "part": [1, 1], "seq": [1, 1], "prompt": "class RegisterExceptionHandler {\n\n    public static void handleException(final Exception cause) {\n        if (isIgnoredException(cause) || isIgnoredException(cause.getCause())) {\n            log.debug(\"Elastic config: ignored exception for: {}\", cause.getMessage());\n        }\n        else if (cause instanceof InterruptedException) {\n            Thread.currentThread().interrupt();\n        }\n        else {\n            throw new RegisterException(cause);\n        }\n    }\n\n    private static boolean isIgnoredException(final Throwable cause);\n\n}\n\nclass RegisterExceptionHandlerTest {\n\n    @Test(expected = RegisterException.class)\n    public void assertHandleExceptionWithOtherException() {\n", "reference": "        RegisterExceptionHandler.handleException(new RuntimeException());\n    }\n\n}", "prediction": "        RegisterExceptionHandler.handleException(new RuntimeException());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "73785779_0", "part": [1, 1], "seq": [1, 1], "prompt": "class ProxyBuilder {\n\n    public void build(Filer filer) throws IOException {\n        JavaFile javaFile = JavaFile.builder(mPackagePath, createTargetClass())\n                .addFileComment(\"Generated code from RxBus. Do not modify!\")\n                .build();\n        javaFile.writeTo(filer);\n    }\n\n    public  ProxyBuilder(ClassName targetClassName);\n\n    public void addMethod(MethodBinder methodBinder);\n     void build(File file);\n    private TypeSpec createTargetClass();\n    private ArrayList<MethodSpec> createMethods();\n    private MethodSpec createConstructor();\n    private CodeBlock createMethodCode(MethodBinder binder);\n    private TypeSpec createFunc1(List<TypeMirror> paramTypes);\n    private TypeSpec createProxyAction(MethodBinder binder);\n    @Override public String toString();\n    private ClassName getRxThread(ThreadType threadType);\n\n}\n\nclass ProxyBuilderTest {\n\n    @Test\n    public void testCreateClass() {\n", "reference": "        File file = new File(\"/home/trs/AndroidStudioProjects/RxBus/exampleTest\");\n        File DemoTestClass = new File(file.getAbsolutePath() + \"/vite/demo/MainActivity$$Proxy.java\");\n        ProxyBuilder builder = new ProxyBuilder(ClassName.get(\"vite.demo\", \"MainActivity\"));\n        builder.build(file);\n\n        assertTrue(file.exists());\n        assertTrue(DemoTestClass.exists());\n    }\n\n}", "prediction": "        ProxyBuilder builder = new ProxyBuilder(ClassName.get(\"com.example.test\", \"Test\"));\n        builder.addMethod(new MethodBinder(\"test\", \"test\", \"void\", new String[]{\"java.lang.String\"}));\n        builder.build(new Filer() {\n            @Override\n            public JavaFileObject createSourceFile(CharSequence charSequence, Element element) throws IOException {\n                return null;\n            }\n\n            @Override\n            public JavaFileObject createClassFile(CharSequence charSequence, Element element) throws IOException {\n                return null;\n            }\n\n            @Override\n            public FileObject createResource(FileObject fileObject, CharSequence charSequence, Element element) throws IOException {\n                return null;\n            }\n\n            @Override\n            public FileObject createResource(FileObject fileObject, CharSequence charSequence, Element element, Filer.Kind kind) throws IOException {\n                return null;\n            }\n\n            @Override\n            public void printMessage(Diagnostic.Kind kind, CharSequence charSequence) {\n\n            }\n\n            @Override\n            public void printMessage(Diagnostic.Kind kind, CharSequence charSequence, Element element) {\n\n            }\n\n            @Override\n            public void printMessage(Diagnostic.Kind kind, CharSequence charSequence, Element element, AnnotationMirror annotationMirror) {\n\n            }\n\n            @Override\n            public void printMessage(Diagnostic.Kind kind, CharSequence charSequence, Element element, AnnotationMirror annotationMirror, AnnotationValue annotationValue) {\n\n            }\n\n            @Override\n            public void printMessage(Diagnostic.Kind kind, CharSequence charSequence, Element element, AnnotationMirror annotationMirror, AnnotationValue annotationValue, AnnotationValue annotationValue1) {\n\n            }\n        });\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "74649126_17", "part": [1, 1], "seq": [1, 1], "prompt": "class HermesApiListener extends HermesAbstractApiListener {\n\n    protected Map<String, Object> createStatusObject() {\n        HashMap<String, Object> dict = new HashMap<String, Object>();\n        dict.put(\"status\", Constants.HEALTHY);\n        fillDate(dict);\n        return dict;\n    }\n\n    protected Map<String, Object> processGetRequest(RestRequest request);\n\n}\n\nclass HermesApiListenerTest {\n\n    @Test\n    public void testCreateStatusObject() {\n", "reference": "        HermesApiListener listener = new HermesApiListener();\n        Map<String, Object> statusObj = listener.createStatusObject();\n        Assert.assertEquals(true, statusObj.containsKey(\"status\"));\n        Assert.assertEquals(true, statusObj.containsKey(\"server_time\"));\n    }\n\n}", "prediction": "        HermesApiListener listener = new HermesApiListener();\n        Map<String, Object> status = listener.createStatusObject();\n        assertEquals(Constants.HEALTHY, status.get(\"status\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "74730037_1", "part": [1, 1], "seq": [1, 1], "prompt": "class SignProtocol {\n\n    public DoSignInfo signIn() throws BiliLiveException {\n        DoSignInfo doSignInfo = httpHelper.getBiliLiveJSON(DO_SIGN_IN_G, DoSignInfo.class, EXCEPTION_SIGN);\n        if (doSignInfo.getCode() == -101) throw new NotLoggedInException();\n        return doSignInfo;\n    }\n\n    public  SignProtocol(@NotNull Session session);\n\n    public SignInfo getCurrentSignInfo();\n\n}\n\nclass SignProtocolTest {\n\n    @Test\n    public void signIn() throws Exception {\n", "reference": "        SignProtocol signProtocol = new SignProtocol(TestSessionHelper.initSession());\n        SignProtocol.SignInfo signInfo = signProtocol.getCurrentSignInfo();\n        if (signInfo.isSignedIn()) fail();\n\n        System.out.println(signProtocol.signIn());\n    }\n\n}", "prediction": "        SignProtocol signProtocol = new SignProtocol(session);\n        SignInfo signInfo = signProtocol.getCurrentSignInfo();\n        System.out.println(signInfo);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "74903768_6", "part": [1, 1], "seq": [1, 1], "prompt": "class LdapFilter {\n\n    String filterString() {\n        if (isSerialNumberSearch()) {\n            return String.format(Locale.US, \"(serialNumber=%s)\", query);\n        } else {\n            return String.format(Locale.US, \"(cn=*%s*)\", query);\n        }\n    }\n\n      LdapFilter(String query);\n\n     boolean isSerialNumberSearch();\n     String getQuery();\n\n    private static final String SERIAL_NUMBER_QUERY;\n    private static final String CN_QUERY;\n\n}\n\nclass LdapFilterTest {\n\n    private static final String SERIAL_NUMBER_QUERY;\n    private static final String CN_QUERY;\n\n    @Test\n    public void shouldReturnCnFilterStringWhenNotSerialNumberQuery() {\n", "reference": "        String filterString = new LdapFilter(CN_QUERY).filterString();\n        assertThat(filterString, is(\"(cn=*\" + CN_QUERY + \"*)\"));\n    }\n\n}", "prediction": "        LdapFilter filter = new LdapFilter(CN_QUERY);\n\n        assertThat(filter.filterString(), is(String.format(Locale.US, \"(cn=*%s*)\", CN_QUERY)));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "75375279_0", "part": [1, 1], "seq": [1, 1], "prompt": "class WordChunkUtils {\n\n    public static List<WordChunk> getWordChunks(String string) {\n        string = string.replaceAll(\"\\\\s+\", \" \");\n\n        for (char c : SENTENCE_ENDING_INTERPUNCTIONS.toCharArray()) {\n            string = string.replace(\" \" + c, \"\" + c);\n        }\n\n        ArrayList<WordChunk> res = new ArrayList<>();\n        String[] parts = string.split(\"\\\\s+\");\n\n        for (int i = 0; i < parts.length; i++) {\n            String part = parts[i];\n            String word = getWord(part);\n            if (res.size() > 0 && StringUtils.isEmpty(word)) {\n                res.get(res.size() - 1).chunk += \" \" + part;\n            } else {\n                res.add(new WordChunk(part, word));\n            }\n        }\n\n        WordChunk firstChunk = res.get(0);\n        if (res.size() > 1 && StringUtils.isEmpty(firstChunk.word)) {\n            res.remove(0);\n            res.get(0).chunk = firstChunk.chunk + \" \" + res.get(0).chunk;\n        }\n\n        return res;\n    }\n\n    private  WordChunkUtils();\n\n    public static String getWord(String str);\n    public static void main(String[] args);\n\n}\n\nclass WordChunkUtilsTest {\n\n    @Test\n    public void testRomanianWithDash() {\n", "reference": "        String sentence = \"L-a trezit.\";\n        List<WordChunk> chunks = WordChunkUtils.getWordChunks(sentence);\n        Assert.assertEquals(2, chunks.size());\n        Assert.assertEquals(\"L-a\", chunks.get(0).word);\n        Assert.assertEquals(\"trezit\", chunks.get(1).word);\n    }\n\n}", "prediction": "        List<WordChunk> wordChunks = WordChunkUtils.getWordChunks(\"\u00cenceputul anului 1989, \u00eentr-o zi de luni, la ora 12:00, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-o zon\u0103 de 100 de metri p\u0103tra\u021bi, \u00eentr-", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "75960287_39", "part": [1, 1], "seq": [1, 1], "prompt": "class ConfigNode {\n\n    protected int getNodeDepth() {\n        return parent != null ? parent.getNodeDepth() + 1 : -1; // Root node is -1\n    }\n\n    public  ConfigNode(String key, ConfigNode parent, String value);\n\n    protected void updateParent(ConfigNode newParent);\n    public Optional<ConfigNode> getNode(String path);\n    private String[] splitPathInTwo(String path);\n    public boolean contains(String path);\n    public ConfigNode addNode(String path);\n    public boolean removeNode(String path);\n    public void remove();\n    protected ConfigNode addChild(ConfigNode child);\n    protected void removeChild(ConfigNode child);\n    public boolean moveChild(String oldPath, String newPath);\n    public String getKey(boolean deep);\n    public void sort();\n    public void reorder(List<String> newOrder);\n    public void save();\n    public void set(String path, T value);\n    public void set(T value);\n    public List<String> getComment();\n    public void setComment(List<String> comment);\n    public List<String> getStringList();\n    public Integer getInteger();\n    public Long getLong();\n    public String getString();\n    public boolean getBoolean();\n    public List<String> getStringList(String path);\n    public Map<String, String> getStringMap(boolean fullKeys);\n    public Integer getInteger(String path);\n    public Long getLong(String path);\n    public String getString(String path);\n    public boolean getBoolean(String path);\n    public void copyMissing(ConfigNode from);\n    public void copyAll(ConfigNode from);\n    public ConfigNode getParent();\n    public boolean isLeafNode();\n    protected List<String> getNodeOrder();\n    public Collection<ConfigNode> getChildren();\n    @Override public boolean equals(Object o);\n    @Override public int hashCode();\n    @Override public String toString();\n\n    private static final String SIMPLE_STRING_NODE;\n    private static final String STRING_NODE_WITH_QUOTES;\n    private static final String STRING_NODE_WITH_DOUBLE_QUOTES;\n    private static final String FIRST_LEVEL;\n    private static final String SECOND_LEVEL;\n    private static final String THIRD_LEVEL;\n    private ConfigNode testTree;\n\n}\n\nclass ConfigNodeTest {\n\n    private static final String SIMPLE_STRING_NODE;\n    private static final String STRING_NODE_WITH_QUOTES;\n    private static final String STRING_NODE_WITH_DOUBLE_QUOTES;\n    private static final String FIRST_LEVEL;\n    private static final String SECOND_LEVEL;\n    private static final String THIRD_LEVEL;\n    private ConfigNode testTree;\n\n    @Test\n    void rootNodeReturnsDepthZero() {\n", "reference": "        assertEquals(-1, testTree.getNodeDepth());\n    }\n\n}", "prediction": "        assertEquals(0, testTree.getNodeDepth());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "76279677_2", "part": [1, 1], "seq": [1, 1], "prompt": "class VarDependencies {\n\n    public List<Relationship> getRelationships(ClauseId clauseId) {\n        return Collections.unmodifiableList(this.relationships.get(clauseId));\n    }\n\n    public  VarDependencies(final Statement statement);\n\n    public List<Var> getUsedVars(ClauseId clauseId);\n    public Set<Var> getAllVariables();\n    public List<Var> getUsedAndIndirectUsedVars(ClauseId clauseId);\n    public AvailableVariables getReachableVars(ClauseId clauseId);\n    public List<Expr> getReturnExprs();\n\n}\n\nclass VarDependenciesTest  {\n\n    @Test\n    public void testRelationships() {\n", "reference": "        String cypher = \"\" +\n                \"MATCH (a)--(b)\\n\" +\n                \"RETURN 42\";\n        Statement st = PassAvailables.parseCypher(cypher);\n        SingleQuery sq = (SingleQuery) st.query.part;\n        VarDependencies dependencies = new VarDependencies(st);\n        Match match = ((Match) sq.clauses.iterator().next());\n        Iterator<PatternPart> iter = this.getPatternPart(match);\n        List<Relationship> match0 = dependencies.getRelationships(this.genClauseForASTNode(iter.next()));\n        Assert.assertEquals(match0.size(), 1);\n        Assert.assertEquals(match0.get(0).leftNode.name, \"a\");\n        Assert.assertEquals(match0.get(0).rightNode.name, \"b\");\n    }\n\n}", "prediction": "        VarDependencies vd = new VarDependencies(\n                \"SELECT * FROM a WHERE a.x = b.x AND b.y = c.y AND c.z = d.z AND d.w = a.w\");\n        assertEquals(2, vd.getRelationships(ClauseId.WHERE).size());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "76505423_7", "part": [1, 1], "seq": [1, 1], "prompt": "class IndexedQueryPlanner {\n\n    public QueryStrategy plan(OperatorNode<ExpressionOperator> filter) {\n        return planInternal(ImmutableSet.<String>of(), filter, false);\n    }\n\n    public  IndexedQueryPlanner(Set<IndexKey> indexes);\n    public  IndexedQueryPlanner(Iterable<IndexDescriptor> indexes);\n\n    private static Iterable<IndexDescriptor> convertSet(Set<IndexKey> indexes);\n    public QueryStrategy planExact(OperatorNode<ExpressionOperator> filter);\n    public QueryStrategy planJoin(OperatorNode<PhysicalExprOperator> leftSide, OperatorNode<ExpressionOperator> joinExpression, OperatorNode<ExpressionOperator> filter);\n    private QueryStrategy planInternal(Set<String> availableJoinColumns, OperatorNode<ExpressionOperator> filter, boolean exact);\n    private void prepareQuery(Set<String> availableJoinColumns, QueryStrategy iq, OperatorNode<ExpressionOperator> filter, boolean exact);\n    private IndexKey matchIndex(Set<String> columns, boolean exact);\n    private void processFilterClause(Map<String, OperatorNode<ExpressionOperator>> columns,\n                                     List<OperatorNode<ExpressionOperator>> others,\n                                     OperatorNode<ExpressionOperator> filter);\n    private String extractFieldMatch(OperatorNode<ExpressionOperator> expr);\n\n}\n\nclass IndexedQueryPlannerTest {\n\n    @Test\n    public void testIndexIdExtra() throws Exception {\n", "reference": "        IndexKey ID_INDEX = IndexKey.of(\"id\");\n        Set<IndexKey> indexKeySet = Sets.newHashSet(\n                ID_INDEX\n        );\n        IndexedQueryPlanner planner = new IndexedQueryPlanner(indexKeySet);\n        QueryStrategy strategy = planner.plan(parseFilter(\"id = '1' AND pants = '2'\"));\n        Assert.assertFalse(strategy.scan);\n        Assert.assertEquals(strategy.indexes.size(), 1);\n        Collection<IndexStrategy> q = strategy.indexes.get(ID_INDEX);\n        Assert.assertEquals(q.size(), 1);\n        Iterator<IndexStrategy> strategyIterator = q.iterator();\n        IndexStrategy strategyKey = strategyIterator.next();\n        Assert.assertEquals(strategyKey.filter.toString(), \"(EQ (READ_FIELD L13:1 row, pants), (LITERAL L21:1 2))\");\n        Assert.assertEquals(strategyKey.indexFilter.get(\"id\").toString(), \"(EQ (READ_FIELD L0:1 row, id), (LITERAL L5:1 1))\");\n    }\n\n}", "prediction": "        IndexedQueryPlanner planner = new IndexedQueryPlanner(ImmutableSet.of(\n                new IndexKey(\"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"id\", \"", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "76773649_0", "part": [1, 1], "seq": [1, 1], "prompt": "class AuthCodeGrantController {\n\n    @RequestMapping(path = RequestPath.PATH_OAUTH_AUTHORIZE_CODE, method = {GET, POST})\n    public ModelAndView authorize(HttpServletRequest request, HttpServletResponse response, HttpSession session,\n                                  @RequestParam(\"response_type\") String responseType,\n                                  @RequestParam(\"client_id\") long clientId,\n                                  @RequestParam(\"redirect_uri\") String redirectUri,\n                                  @RequestParam(name = \"scope\", required = false) String scope,\n                                  @RequestParam(name = \"state\", required = false) String state,\n                                  @RequestParam(name = \"skip_confirm\", required = false, defaultValue = \"false\") boolean skipConfirm,\n                                  @RequestParam(name = \"force_login\", required = false, defaultValue = \"false\") boolean forceLogin)\n            throws VerificationException {\n\n        log.info(\"Request authorize code, appId[{}]\", clientId);\n        ModelAndView mav = new ModelAndView();\n\n        // \u8bf7\u6c42\u53c2\u6570\u5c01\u88c5\u4e0e\u6821\u9a8c\n        AuthorizeRequestParams requestParams = new AuthorizeRequestParams(responseType, clientId, redirectUri, scope, state);\n        ErrorCode validateResult = requestParams.validate();\n        if (!ErrorCode.NO_ERROR.equals(validateResult)) {\n            // \u8bf7\u6c42\u53c2\u6570\u6709\u8bef\n            log.error(\"Request authorize params error, appId[{}], errorCode[{}], params[{}]\", clientId, validateResult, requestParams);\n            if (ErrorCode.INVALID_CLIENT.equals(validateResult) || ErrorCode.INVALID_REDIRECT_URI.equals(validateResult)) {\n                /*\n                 * If the request fails due to a missing, invalid, or mismatching redirection URI,\n                 * or if the client identifier is missing or invalid, the authorization server SHOULD inform the resource owner of the\n                 * error and MUST NOT automatically redirect the user-agent to the invalid redirection URI.\n                 */\n                return JsonView.render(new ResultInfo(validateResult, state), response, false);\n            }\n            return ResponseUtils.buildErrorResponse(redirectUri, validateResult, state);\n        }\n\n        AppInfo appInfo = requestParams.getAppInfo();\n        UserInfo user = SessionUtils.getUser(session, CookieUtils.get(request, COOKIE_KEY_USER_LOGIN_SIGN));\n        if (null == user || forceLogin) {\n            // \u7528\u6237\u672a\u767b\u5f55\u6216\u9700\u8981\u5f3a\u5236\u767b\u5f55\uff0c\u8df3\u8f6c\u5230\u767b\u5f55\u9875\u9762\n            return ResponseUtils.buildLoginResponse(request, appInfo);\n        }\n        requestParams.setUserInfo(user);\n\n        // \u83b7\u53d6\u7528\u6237\u4e0eAPP\u4e4b\u95f4\u7684\u6388\u6743\u5173\u7cfb\u8bb0\u5f55\n        Optional<AuthorizeRelation> relation =\n                authorizeRelationService.getAuthorizeRelation(user.getId(), requestParams.getClientId(), requestParams.getScope());\n\n        if (relation.isPresent() && skipConfirm) {\n            // \u7528\u6237\u5df2\u6388\u6743\u8be5APP\uff0c\u4e0b\u53d1\u6388\u6743\u7801\n            log.info(\"User had authorized and issue auth code, appId[{}], userId[{}], scope[{}]\", clientId, user.getId(), requestParams.getScope());\n            AuthorizationCode code = new AuthorizationCode(\n                    requestParams.getAppInfo(), user.getId(), relation.get().getScope(), requestParams.getRedirectUri());\n            String key = code.getValue();\n            if (StringUtils.isBlank(key)) {\n                log.error(\"Generate auth code error, appId[{}], userId[{}], scope[{}]\", clientId, user.getId(), requestParams.getScope());\n                return ResponseUtils.buildErrorResponse(redirectUri, ErrorCode.AUTHORIZATION_CODE_GENERATE_ERROR, state);\n            }\n            UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(requestParams.getRedirectUri());\n            builder.queryParam(\"code\", key);\n            if (StringUtils.isNotEmpty(state)) {\n                builder.queryParam(\"state\", state);\n            }\n            // cache auth code\n            AuthCodeCacheHandler.getInstance().put(key, code);\n            mav.setViewName(\"redirect:\" + builder.toUriString());\n            return mav;\n        }\n\n        // \u7528\u6237\u672a\u6388\u6743\u8be5APP\uff0c\u8df3\u8f6c\u5230\u6388\u6743\u9875\u9762\n        log.info(\"User not authorized and goto authorize page, appId[{}], userId[{}], relationExist[{}], skipConfirm[{}]\",\n                clientId, user.getId(), relation.isPresent(), skipConfirm);\n        List<Scope> scopes = scopeService.getScopes(requestParams.getScope());\n        return ResponseUtils.buildAuthorizeResponse(request, scopes, user, appInfo, state);\n    }\n\n    @RequestMapping(path = RequestPath.PATH_OAUTH_AUTHORIZE_TOKEN, method = {GET, POST}) public ModelAndView issueToken(HttpServletResponse response,\n                                   @RequestParam(\"grant_type\") String grantType,\n                                   @RequestParam(\"code\") String code,\n                                   @RequestParam(\"redirect_uri\") String redirectUri,\n                                   @RequestParam(\"client_id\") long clientId,\n                                   @RequestParam(name = \"client_secret\", required = false) String clientSecret,\n                                   @RequestParam(name = \"token_type\", required = false) String tokenType,\n                                   @RequestParam(name = \"issue_refresh_token\", required = false, defaultValue = \"true\") boolean refresh);\n\n    private static final long CLIENT_ID;\n    private static final String REDIRECT_URI;\n    private static final String SCOPE;\n    private static final String ALL_SCOPE;\n    private Response resp4Login;\n\n}\n\nclass AuthCodeGrantControllerTest  {\n\n    private static final long CLIENT_ID;\n    private static final String REDIRECT_URI;\n    private static final String SCOPE;\n    private static final String ALL_SCOPE;\n    private Response resp4Login;\n\n    @Test\n    public void authorizeTest() throws Exception {\n", "reference": "        Map<String, Object> params = new HashMap<>();\n        params.put(\"response_type\", ResponseType.AUTHORIZATION_CODE.getType());\n        params.put(\"client_id\", CLIENT_ID);\n        params.put(\"redirect_uri\", REDIRECT_URI);\n        Response response = RestAssured.with().params(params).cookies(resp4Login.cookies()).get(PATH_OAUTH_AUTHORIZE_CODE);\n        Assert.assertEquals(200, response.getStatusCode());\n        // System.out.println(response.asString());\n        response = MockUserOperationUtils.authorizationCodeUserAuthorize(response, resp4Login.cookies(), ALL_SCOPE, StringUtils.EMPTY);\n        System.out.println(response.asString());\n        Assert.assertEquals(302, response.getStatusCode());\n        String redirectUrl = response.getHeader(\"Location\");\n        System.out.println(redirectUrl);\n        response = RestAssured.with().redirects().follow(false).cookies(resp4Login.getCookies()).cookies(response.cookies()).get(redirectUrl);\n        System.out.println(response.getHeader(\"Location\"));\n        Map<String, String> results = ResultUtils.getLocationUrlParamsValue(response);\n        Assert.assertNotNull(results.get(\"code\"));\n    }\n\n}", "prediction": "        ModelAndView mav = authCodeGrantController.authorize(null, null, null, \"code\", CLIENT_ID, REDIRECT_URI, SCOPE, null, false, false);\n        assertEquals(\"login\", mav.getViewName());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "78868092_36", "part": [1, 1], "seq": [1, 1], "prompt": "class SubscriptionService {\n\n    public void addSubscription(Subscription subscription, String alarmId) {\n        validateSubscription(subscription);\n\n        if (this.searchSubscription(subscription, alarmId) != null) {\n            LOGGER.debug(\"Identical subscription found (alarm id: {}).\", alarmId);\n            throw new DuplicateSubscriptionException(\"Attempting to add a subscription that already exists on alarm \" + alarmId);\n        }\n\n        seyrenRepository.addSubscription(subscription, alarmId);\n    }\n\n    public Subscription getSubscription(String alarmId, String subscriptionId);\n    public Subscription searchSubscription(Subscription subscription, String alarmId);\n    public void updateSubscription(Subscription subscription, String alarmId);\n    private void validateSubscription(Subscription subscription);\n    private void validateUpdateSubscription(Subscription current, Subscription updated);\n    private boolean isLastSubscriptionActiveToDisable(Subscription current, Subscription updated, Alarm alarm);\n    public SubscriptionService.DeletedSubscriptionStatus deleteSubscription(String alarmId, String subscriptionId);\n\n    @InjectMocks\n    private final SubscriptionService subscriptionService;\n    @Mock\n    private SeyrenRepository seyrenRepository;\n\n}\n\nclass SubscriptionServiceTest {\n\n    @InjectMocks\n    private final SubscriptionService subscriptionService;\n    @Mock\n    private SeyrenRepository seyrenRepository;\n\n    @Test\n    public void addSubscriptionFailWithNoDayToSendAlert() throws Exception {\n", "reference": "        Subscription subscription = TestUtils.getDefaultSubscription();\n        String subId = \"subTestId\";\n        subscription.setId(subId);\n        subscription.setTarget(\"test@anotherteam.org\");\n        subscription.setSu(true);\n\n        subscription.setMo(false);\n        subscription.setTu(false);\n        subscription.setWe(false);\n        subscription.setTh(false);\n        subscription.setFr(false);\n        subscription.setSa(false);\n        subscription.setSu(false);\n\n        try {\n            subscriptionService.addSubscription(subscription, TestUtils.DEFAULT_ALARM_ID);\n            fail(\"Create a subscription with no alerting day should throw an exception\");\n        } catch (CerebroException ce) {\n            assertEquals(ErrorCode.SUBSCRIPTION_INVALID, ce.getErrorCode());\n        }\n    }\n\n}", "prediction": "        Subscription subscription = new Subscription();\n        subscription.setDayToSendAlert(null);\n        subscription.setEmailAddress(\"test@seyren.io\");\n        subscription.setType(SubscriptionType.EMAIL);\n\n        try {\n            subscriptionService.addSubscription(subscription, \"1\");\n            fail(\"Expected exception\");\n        } catch (IllegalArgumentException e) {\n            assertThat(e.getMessage(), is(\"Subscription must have a day to send alert\"));\n        }\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "79296222_0", "part": [1, 1], "seq": [1, 1], "prompt": "class PostListPresenter implements BasePresenter<PostListPresenter.View> {\n\n  @Override\n  public void attachView(View view) {\n    mMVPView = view;\n\n    mSubscriptions.add(\n        mDataController.getCombinedPosts()\n            .subscribeOn(Schedulers.io())\n            .observeOn(AndroidSchedulers.mainThread())\n            .subscribe(onNext -> mMVPView.onSubscribe(onNext), onError -> {}));\n\n  }\n\n  public  PostListPresenter(DataControllerInterface dataController);\n\n  @Override public void detachView();\n\n    private PostListPresenter mPresenter;\n    private List<PostItem> mValidDummyData;\n    @Mock private PostListPresenter.View mView;\n    @Mock private DataController mDataController;\n    private Observable<List<PostItem>> mPostListObservable;\n\n}\n\nclass PostListPresenterTest  {\n\n    private PostListPresenter mPresenter;\n    private List<PostItem> mValidDummyData;\n    @Mock private PostListPresenter.View mView;\n    @Mock private DataController mDataController;\n    private Observable<List<PostItem>> mPostListObservable;\n\n    @Test\n    public void givenCombinedPostsReturnsNoList_whenViewIsAttached_shouldNotPassToAdapter() throws Exception {\n", "reference": "        //Test when view is attached and data controller emits valid data, onSubscribe should be called from view, which is attached to the adapter\n        when(mDataController.getCombinedPosts()).thenReturn(Observable.empty());\n\n        mPresenter = new PostListPresenter(mDataController);\n        mPresenter.attachView(mView);\n\n        verify(mView, never()).onSubscribe(anyList());\n    }\n\n}", "prediction": "       mPostListObservable = Observable.just(new ArrayList<PostItem>());\n        when(mDataController.getCombinedPosts()).thenReturn(mPostListObservable);\n\n        mPresenter.attachView(mView);\n\n        verify(mView, never()).onSubscribe(anyListOf(PostItem.class));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "79497496_12", "part": [1, 1], "seq": [1, 1], "prompt": "class Dodecahedron {\n\n   public String toString() {\n      DecimalFormat fmt = new DecimalFormat(\"#,##0.0##\");\n      return \"Dodecahedron \\\"\" + label + \"\\\" is \\\"\" + color\n         + \"\\\" with 30 edges of length \" + edge + \" units.\\n\\t\"\n         + \"surface area = \" + fmt.format(surfaceArea()) + \" square units\\n\\t\"\n         + \"volume = \" + fmt.format(volume()) + \" cubic units\\n\\t\"\n         + \"surface/volume ratio = \" + fmt.format(surfaceToVolumeRatio());\n   }\n\n   public  Dodecahedron(String labelIn, String colorIn, double edgeIn);\n\n   public String getLabel();\n   public boolean setLabel(String labelIn);\n   public String getColor();\n   public boolean setColor(String colorIn);\n   public double getEdge();\n   public boolean setEdge(double edgeIn);\n   public double surfaceArea();\n   public double volume();\n   public double surfaceToVolumeRatio();\n   public static void resetCount();\n   public boolean equals(Object obj);\n   public int hashCode();\n\n   private Dodecahedron d;\n   private Dodecahedron dTrue;\n   private Dodecahedron dFalse;\n   private double edge;\n\n}\n\nclass DodecahedronTest {\n\n   private Dodecahedron d;\n   private Dodecahedron dTrue;\n   private Dodecahedron dFalse;\n   private double edge;\n\n   @Test\n   public void toStringTest() {\n", "reference": "      Dodecahedron[] dodObjList = new Dodecahedron[10];\n      for (int i = 0; i < 5; i++) {\n         Dodecahedron dodObj = new Dodecahedron(\"test\" + i, \"color\" + i, \n                                                               i + .25);\n         dodObjList[i] = dodObj;\n      }\n      Assert.assertEquals(\"\", true, dodObjList[4].toString().contains(\"4.25\"));\n   }\n\n}", "prediction": "     assertEquals(\"Dodecahedron \\\"\\\" is \\\"\\\" with 30 edges of length 1.0 units.\\n\\t\"\n         + \"surface area = 12.566370614359172 square units\\n\\t\"\n         + \"volume = 0.0 cubic units\\n\\t\"\n         + \"surface/volume ratio = 0.0\", d.toString());\n   }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "79784019_49", "part": [1, 1], "seq": [1, 1], "prompt": "class ModelValidator {\n\n    public List<ValidationError> getCreateValidationErrors(Object create, FieldData fieldData) {\n        if (create == null) {\n            return ImmutableList.of(ValidationError.of(\"\", \"create is null\"));\n        }\n\n        ImmutableList.Builder<ValidationError> errors = ImmutableList.builder();\n        Map<String,Object> createMap = mapper.convertValue(create, new TypeReference<Map<String,Object>>() { });\n        Set<String> createFields = createMap.keySet();\n        for (String fieldName : createFields) {\n            Field field = fieldData.getMap().get(fieldName);\n            if (field == null) {\n                errors.add(ValidationError.of(fieldName, \"does not exist\"));\n            } else if (!field.isCreatable() && !field.isUpdatable()) {\n                errors.add(ValidationError.of(fieldName, \"is not creatable\"));\n            }\n        }\n        for (Field field : fieldData.getMap().values()) {\n            Object value = createMap.get(field.getName());\n            if (!field.isOptional() && (field.isCreatable() || field.isUpdatable()) && (value == null || \"\".equals(value))) {\n                errors.add(ValidationError.of(field.getName(), \"is required\"));\n            }\n        }\n        Set<ConstraintViolation<Object>> violations = validator.validate(create, Default.class);\n        Set<String> errorFields = new HashSet<>();\n        for (ConstraintViolation<?> cv : violations) {\n            String field = cv.getPropertyPath().toString();\n            if (createFields.contains(field) && !errorFields.contains(field)) {\n                errors.add(ValidationError.of(field, cv.getMessage()));\n                errorFields.add(field);\n            }\n        }\n        return errors.build();\n    }\n\n    public  ModelValidator(Validator validator, ObjectMapper mapper);\n\n    public List<ValidationError> getModelValidationErrors(Object object, Class validationGroup);\n    public List<ValidationError> getUpdateValidationErrors(Update<?> update, FieldData fieldData);\n    public boolean validateModel(Object model);\n    public boolean validateCreate(Object create, FieldData fieldData);\n    public boolean validateUpdate(Update<?> update, FieldData fieldData);\n\n    private ModelValidator validator;\n    private FieldData fieldData;\n\n}\n\nclass ModelValidatorTest {\n\n    private ModelValidator validator;\n    private FieldData fieldData;\n\n    @Test\n    public void testGetCreateValidationErrors() throws Exception {\n", "reference": "        List<ValidationError> errors = validator.getCreateValidationErrors(null, fieldData);\n        assertEquals(1, errors.size());\n\n        TestValidateModel model = TestValidateModel.builder().build();\n        errors = validator.getCreateValidationErrors(model, fieldData);\n        assertEquals(2, errors.size());\n        assertEquals(\"is required\", errors.get(0).getMessage());\n        assertEquals(\"is required\", errors.get(1).getMessage());\n\n        model = TestValidateModel.builder().email(\"invalid\").build();\n        errors = validator.getCreateValidationErrors(model, fieldData);\n        assertEquals(2, errors.size());\n        assertEquals(\"is required\", errors.get(0).getMessage());\n        assertEquals(\"must be a well-formed email address\", errors.get(1).getMessage());\n\n        model = TestValidateModel.builder().email(\"example@example.com\").type(\"type\").loginAt(Instant.now()).build();\n        errors = validator.getCreateValidationErrors(model, fieldData);\n        assertEquals(1, errors.size());\n        assertEquals(\"loginAt\", errors.get(0).getField());\n        assertEquals(\"is not creatable\", errors.get(0).getMessage());\n    }\n\n}", "prediction": "        Create create = new Create();\n        create.setName(\"name\");\n        create.setDescription(\"description\");\n        create.setType(\"type\");\n        create.setValue(\"value\");\n        create.setValue2(\"value2\");\n        create.setValue3(\"value3\");\n        create.setValue4(\"value4\");\n        create.setValue5(\"value5\");\n        create.setValue6(\"value6\");\n        create.setValue7(\"value7\");\n        create.setValue8(\"value8\");\n        create.setValue9(\"value9\");\n        create.setValue10(\"value10\");\n        create.setValue11(\"value11\");\n        create.setValue12(\"value12\");\n        create.setValue13(\"value13\");\n        create.setValue14(\"value14\");\n        create.setValue15(\"value15\");\n        create.setValue16(\"value16\");\n        create.setValue17(\"value17\");\n        create.setValue18(\"value18\");\n        create.setValue19(\"value19\");\n        create.setValue20(\"value20\");\n        create.setValue21(\"value21\");\n        create.setValue22(\"value22\");\n        create.setValue23(\"value23\");\n        create.setValue24(\"value24\");\n        create.setValue25(\"value25\");\n        create.setValue26(\"value26\");\n        create.setValue27(\"value27\");\n        create.setValue28(\"value28\");\n        create.setValue29(\"value29\");\n        create.setValue30(\"value30\");\n        create.setValue31(\"value31\");\n        create.setValue32(\"value32\");\n        create.setValue33(\"value33\");\n        create.setValue34(\"value34\");\n        create.setValue35(\"value35\");\n        create.setValue36(\"value36\");\n        create.setValue37(\"value37\");\n        create.setValue38(\"value38\");\n        create.setValue39(\"value39\");\n        create.setValue40(\"value40\");\n        create.setValue41(\"value41\");\n        create.setValue42(\"value42\");\n        create.setValue43(\"value43\");\n        create.setValue44(\"value44\");\n        create.setValue45(\"value45\");\n        create.setValue46(\"value46\");\n        create.setValue47(\"value47\");\n        create.setValue48(\"value48\");\n        create.setValue49(\"value49\");\n        create.setValue50(\"value50\");\n        create.setValue51(\"value51\");\n        create.setValue52(\"value52\");\n        create.setValue53(\"value53\");\n        create.setValue54(\"value54\");\n        create.setValue55(\"value55\");\n        create.setValue56(\"value56\");\n        create.setValue57(\"value57\");\n        create.setValue58(\"value58\");\n        create.setValue59(\"value59\");\n        create.setValue60(\"value60\");\n        create.setValue61(\"value61\");\n        create.setValue62(\"value62\");\n        create.setValue63(\"value63\");\n        create.setValue64(\"value64\");\n        create.setValue65(\"value65\");\n        create.setValue66(\"value66\");\n        create.setValue67(\"value67\");\n        create.setValue68(\"value68\");\n        create.setValue69(\"value69\");\n        create.setValue70(\"value70\");\n        create.setValue71(\"value71\");\n        create.setValue72(\"value72\");\n        create.setValue73(\"value73\");\n        create.setValue74(\"value74\");\n        create.setValue75(\"value75\");\n        create.setValue76(\"value76\");\n        create.setValue77(\"value77\");\n        create.setValue78(\"value78\");\n        create.setValue79(\"value79\");\n        create.setValue80(\"value80\");\n        create.setValue81(\"value81\");\n        create.setValue82(\"value82\");\n        create.setValue83(\"value83\");\n        create.setValue84(\"value84\");\n        create.setValue85(\"value85\");\n        create.setValue86(\"value86\");\n        create.setValue87(\"value87\");\n        create.setValue88(\"value88\");\n        create.setValue89(\"value89\");\n        create.setValue90(\"value90\");\n        create.setValue91(\"value91\");\n        create.setValue92(\"value92\");\n        create.setValue93(\"value93\");\n        create.setValue94(\"value94\");\n        create.setValue95(\"value95\");\n        create.setValue96(\"value96\");\n        create.setValue97(\"value97\");\n        create.setValue98(\"value98\");\n        create.setValue99(\"value99\");\n        create.setValue100(\"value100\");\n        create.setValue101(\"value101\");\n        create.setValue102(\"value102\");\n        create.setValue103(\"value103\");\n        create.setValue104(\"value104\");\n        create.setValue105(\"value105\");\n        create.setValue106(\"value106\");\n        create.setValue107(\"value107\");\n        create.setValue1", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "81173322_1", "part": [1, 1], "seq": [1, 1], "prompt": "class HomeListPresenter implements HomeListContract.Presenter {\n\n    @Override\n    public void loadAllLists() {\n        allLists = todoRepository.getAllLists();\n        allLists.addChangeListener(new RealmChangeListener<RealmResults<TodoList>>() {\n            @Override\n            public void onChange(RealmResults<TodoList> element) {\n                LogUtils.d(\"onChange: \" + element.size());\n                if (view != null) {\n                    view.notifyDataChanged();\n                }\n            }\n        });\n\n        view.bindListData(allLists);\n    }\n\n      HomeListPresenter(TodoRepository todoRepository);\n\n    @Override public void init();\n    @Override public void attachView(HomeListContract.View view);\n    @Override public void detachView();\n    @Override public void onDestroy();\n    @Override public void onCreateListItemClicked();\n    @Override public void onFloatingActionButtonClicked();\n    @Override public void onListItemClicked(TodoList list);\n    @Override public void onListItemLongClicked(TodoList list);\n    @Override public void onDestroyActionMode();\n    @Override public void deleteSelectedItems(List<Long> itemIds);\n\n    @Mock HomeListContract.View view;\n    @Mock TodoRepository repository;\n    private HomeListPresenter presenter;\n\n}\n\nclass HomeListPresenterTest {\n\n    @Mock HomeListContract.View view;\n    @Mock TodoRepository repository;\n    private HomeListPresenter presenter;\n\n    @Ignore\n    @Test\n    public void shouldLoadDataFromRepoWhenLoadAllLists() throws Exception {\n", "reference": "//        RealmResults mockResults = mock(RealmResults.class);\n//        RealmResults<TodoList> todoLists = new RealmResults<TodoList>();\n//        when(repository.getAllLists()).thenReturn(mockResults);\n        // because the RealmResults can not be mocked or new, this test can't be run\n\n        presenter.loadAllLists();\n\n        verify(repository).getAllLists();\n    }\n\n}", "prediction": "        presenter.loadAllLists();\n        verify(view).bindListData(any(RealmResults.class));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "81226206_87", "part": [1, 1], "seq": [1, 1], "prompt": "class FileUtils {\n\n    public static String toPackageQualifiedName(String path) {\n        path = removePrefix(path);\n        path = path.replace('/', '.');\n        if (path.contains(\":\\\\\")) { // to remove windows drive letter and colon\n            path = removePrefix(path);\n        }\n        if (path.indexOf('\\\\') != -1) { // for windows paths\n            path = path.replace('\\\\', '.');\n        }\n        String packagePath = path.replace(\"..\", \"\");\n        if (packagePath.startsWith(\".\")) {\n            packagePath = packagePath.substring(1);\n        }\n        if (packagePath.endsWith(DOT_FEATURE)) {\n            packagePath = packagePath.substring(0, packagePath.length() - 8);\n        }\n        return packagePath;\n    }\n\n    private  FileUtils();\n\n    public static final boolean isClassPath(String text);\n    public static final boolean isFilePath(String text);\n    public static final boolean isThisPath(String text);\n    public static final boolean isJsonFile(String text);\n    public static final boolean isJavaScriptFile(String text);\n    public static final boolean isYamlFile(String text);\n    public static final boolean isXmlFile(String text);\n    public static final boolean isTextFile(String text);\n    public static final boolean isCsvFile(String text);\n    public static final boolean isGraphQlFile(String text);\n    public static final boolean isFeatureFile(String text);\n    public static ScriptValue readFile(String text, ScenarioContext context);\n    public static String removePrefix(String text);\n    private static StringUtils.Pair parsePathAndTags(String text);\n    public static Feature parseFeatureAndCallTag(String path);\n    public static Resource toResource(String path, ScenarioContext context);\n    public static String readFileAsString(String path, ScenarioContext context);\n    public static InputStream readFileAsStream(String path, ScenarioContext context);\n    public static String toString(File file);\n    public static String toString(InputStream is);\n    public static String toPrettyString(String raw);\n    public static byte[] toBytes(InputStream is);\n    private static ByteArrayOutputStream toByteStream(InputStream is);\n    public static String toString(byte[] bytes);\n    public static byte[] toBytes(String string);\n    public static void copy(File src, File dest);\n    public static void writeToFile(File file, byte[] data);\n    public static void writeToFile(File file, String data);\n    public static InputStream toInputStream(String text);\n    public static String removeFileExtension(String path);\n    public static String replaceFileExtension(String path, String extension);\n    public static String getKarateVersion();\n    public static void renameFileIfZeroBytes(String fileName);\n    public static String toStandardPath(String path);\n    public static String toRelativeClassPath(Path path, ClassLoader cl);\n    public static File getDirContaining(Class clazz);\n    public static Path getPathContaining(Class clazz);\n    private static String packageAsPath(Class clazz);\n    public static File getFileRelativeTo(Class clazz, String path);\n    public static String toRelativeClassPath(Class clazz);\n    public static Path fromRelativeClassPath(String relativePath, ClassLoader cl);\n    public static Path fromRelativeClassPath(String relativePath, Path parentPath);\n    public static List<Resource> scanForFeatureFilesOnClassPath(ClassLoader cl);\n    public static List<Resource> scanForFeatureFiles(List<String> paths, ClassLoader cl);\n    public static List<Resource> scanForFeatureFiles(List<String> paths, Class clazz);\n    public static boolean isJarPath(URI uri);\n    public static Path urlToPath(URL url, String relativePath);\n    public static List<URL> getAllClassPathUrls(ClassLoader classLoader);\n    private static FileSystem getFileSystem(URI uri);\n    public static List<Resource> scanForFeatureFiles(boolean classpath, String searchPath, ClassLoader cl);\n    private static void collectFeatureFiles(URL url, String searchPath, List<Resource> files);\n    public static String getBuildDir();\n    public static boolean isOsWindows();\n    public static boolean isOsMacOsX();\n    public static String getOsName();\n    public static OsType getOsType();\n    public static OsType getOsType(String name);\n\n    private static final Logger logger;\n\n}\n\nclass FileUtilsTest {\n\n    private static final Logger logger;\n\n    @Test\n    public void testWindowsFileNames() {\n", "reference": "        String path = \"com/intuit/karate/cucumber/scenario.feature\";\n        String fixed = FileUtils.toPackageQualifiedName(path);\n        assertEquals(\"com.intuit.karate.cucumber.scenario\", fixed);\n        path = \"file:C:\\\\Users\\\\Karate\\\\scenario.feature\";\n        fixed = FileUtils.toPackageQualifiedName(path);\n        assertEquals(\"Users.Karate.scenario\", fixed);\n        path = \"file:../Karate/scenario.feature\";\n        fixed = FileUtils.toPackageQualifiedName(path);\n        assertEquals(\"Karate.scenario\", fixed);\n    }\n\n}", "prediction": "        assertEquals(\"c:\\\\foo\\\\bar\", FileUtils.toPackageQualifiedName(\"c:\\\\foo\\\\bar\"));\n        assertEquals(\"c:\\\\foo\\\\bar\", FileUtils.toPackageQualifiedName(\"c:\\\\foo\\\\bar.feature\"));\n        assertEquals(\"c:\\\\foo\\\\bar\", FileUtils.toPackageQualifiedName(\"c:\\\\foo\\\\bar.feature:1\"));\n        assertEquals(\"c:\\\\foo\\\\bar\", FileUtils.toPackageQualifiedName(\"c:\\\\foo\\\\bar.feature:1:2\"));\n        assertEquals(\"c:\\\\foo\\\\bar\", FileUtils.toPackageQualifiedName(\"c:\\\\foo\\\\bar.feature:1:2:3\"));\n        assertEquals(\"c:\\\\foo\\\\bar\", FileUtils.toPackageQualifiedName(\"c:\\\\foo\\\\bar.feature:1:2:3:4\"));\n        assertEquals(\"c:\\\\foo\\\\bar\", FileUtils.toPackageQualifiedName(\"c:\\\\foo\\\\bar.feature:1:2:3:4:5\"));\n        assertEquals(\"c:\\\\foo\\\\bar\", FileUtils.toPackageQualifiedName(\"c:\\\\foo\\\\bar.feature:1:2:3:4:5:6\"));\n        assertEquals(\"c:\\\\foo\\\\bar\", FileUtils.toPackageQualifiedName(\"c:\\\\foo\\\\bar.feature:1:2:3:4:5:6:7\"));\n        assertEquals(\"c:\\\\foo\\\\bar\", FileUtils.toPackageQualifiedName(\"c:\\\\foo\\\\bar.feature:1:2:3:4:5:6:7:8\"));\n        assertEquals(\"c:\\\\foo\\\\bar\", FileUtils.toPackageQualifiedName(\"c:\\\\foo\\\\bar.feature:1:2:3:4:5:6:7:8:9\"));\n        assertEquals(\"c:\\\\foo\\\\bar\", FileUtils.toPackageQualifiedName(\"c:\\\\foo\\\\bar.feature:1:2:3:4:5:6:7:8:9:10\"));\n        assertEquals(\"c:\\\\foo\\\\bar\", FileUtils.toPackageQualifiedName(\"c:\\\\foo\\\\bar.feature:1:2:3:4:5:6:7:8:9:10:11\"));\n        assertEquals(\"c:\\\\foo\\\\bar\", FileUtils.toPackageQualifiedName(\"c:\\\\foo\\\\bar.feature:1:2:3:4:5:6:7:8:9:10:11:12\"));\n        assertEquals(\"c:\\\\foo\\\\bar\", FileUtils.toPackageQualifiedName(\"c:\\\\foo\\\\bar.feature:1:2:3:4:5:6:7:8:9:10:11:12:13\"));\n        assertEquals(\"c:\\\\foo\\\\bar\", FileUtils.toPackageQualifiedName(\"c:\\\\foo\\\\bar.feature:1:2:3:4:5:6:7:8:9:10:11:12:13:14\"));\n        assertEquals(\"c:\\\\foo\\\\bar\", FileUtils.toPackageQualifiedName(\"c:\\\\foo\\\\bar.feature:1:2:3:4:5:6:7:8:9:10:11:12:13:14:15\"));\n        assertEquals(\"c:\\\\foo\\\\bar\", FileUtils.toPackageQualifiedName(\"c:\\\\foo\\\\bar.feature:1:2:3:4:5:6:7:8:9:10:11:12:13:14:15:16\"));\n        assertEquals(\"c:\\\\foo\\\\bar\", FileUtils.toPackageQualifiedName(\"c:\\\\foo\\\\bar.feature:1:2:3:4:5:6:7:8:9:10:11:12:13:14:15:16:17\"));\n        assertEquals(\"c:\\\\foo\\\\bar\", FileUtils.toPackageQualifiedName(\"c:\\\\foo\\\\bar.feature:1:2:3:4:5:6:7:8:9:10:11:12:13:14:15:16:17:18\"));\n        assertEquals(\"c:\\\\foo\\\\bar\", FileUtils.toPackageQualifiedName(\"c:\\\\foo\\\\bar.feature:1:", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "81368488_180", "part": [1, 1], "seq": [1, 1], "prompt": "class Divisor implements GameLifeCycle {\n\n    @Override\n    public void launch() {\n        gameContext.setLimiterAvailable();\n        final Target target;\n        final ImageLibrary imageLibrary;\n\n\n        if (isRabbit) {\n            imageLibrary = ImageUtils.createCustomizedImageLibrary(null, \"divisor/rabbit/images\");\n            initBackground();\n            gameContext.resetBordersToFront();\n        } else {\n            imageLibrary = ImageUtils.createImageLibrary(Utils.getImagesSubdirectory(\"portraits\"));\n        }\n\n        this.stats.notifyNewRoundReady();\n        gameContext.getGazeDeviceManager().addStats(stats);\n        stats.incrementNumberOfGoalsToReach(15);\n\n         target = new Target(gameContext, stats, imageLibrary, 0,System.currentTimeMillis(), this,\n            this.gameContext.getRandomPositionGenerator().newRandomPosition(100), isRabbit);\n\n        gameContext.getChildren().add(target);\n        gameContext.firstStart();\n    }\n\n    public  Divisor(final IGameContext gameContext, final Stats stats, final boolean isRabbit);\n\n    private void initBackground();\n    public void restart();\n    @Override public void dispose();\n\n    @Mock\n    private IGameContext mockGameContext;\n    @Mock\n    private Configuration mockConfiguration;\n    @Mock\n    private GamePanelDimensionProvider mockProvider;\n    @Mock\n    private BackgroundStyle mockBackgroundStyle;\n    @Mock\n    private Stats mockStats;\n    private ObservableList<Node> children;\n    private final String sep;\n    private final String localDataFolder;\n\n}\n\nclass DivisorTest {\n\n    @Mock\n    private IGameContext mockGameContext;\n    @Mock\n    private Configuration mockConfiguration;\n    @Mock\n    private GamePanelDimensionProvider mockProvider;\n    @Mock\n    private BackgroundStyle mockBackgroundStyle;\n    @Mock\n    private Stats mockStats;\n    private ObservableList<Node> children;\n    private final String sep;\n    private final String localDataFolder;\n\n    @Test\n    void shouldLaunchRabbits() {\n", "reference": "        Divisor divisor = new Divisor(mockGameContext, mockStats, true);\n\n        divisor.launch();\n\n        verify(mockProvider, atLeastOnce()).getDimension2D();\n        assertEquals(2, children.size());\n\n        Target target = (Target) children.get(1);\n        assertTrue(target.getImgLib().pickRandomImage().getUrl().contains(\"rabbit\"));\n    }\n\n}", "prediction": "        new Divisor(mockGameContext, mockStats, true);\n        verify(mockGameContext).setLimiterAvailable();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "81745315_2", "part": [1, 1], "seq": [1, 1], "prompt": "class ZKTools {\n\n    public static void deleteTree(ZooKeeper zk, String path) throws Exception {\n        String[] list = getTree(zk, path);\n        for (int i = list.length - 1; i >= 0; i--) {\n            zk.delete(list[i], -1);\n        }\n    }\n\n    public static void createPath(ZooKeeper zk, String path, CreateMode createMode, List<ACL> acl);\n    public static void printTree(ZooKeeper zk, String path, Writer writer, String lineSplitChar);\n    public static String[] getTree(ZooKeeper zk, String path);\n\n    private static ZooKeeper zooKeeper;\n\n}\n\nclass ZKToolsTest {\n\n    private static ZooKeeper zooKeeper;\n\n    @Test\n    public void deleteTree() {\n", "reference": "    }\n    }\n\n    public static void createPath(ZooKeeper zk, String path, CreateMode createMode, List<ACL> acl);\n    public static void printTree(ZooKeeper zk, String path, Writer writer, String lineSplitChar);\n    public static String[] getTree(ZooKeeper zk, String path);\n\n    private static ZooKeeper zooKeeper;\n\n}\n\nclass ZKToolsTest {\n\n    private static ZooKeeper zooKeeper;\n\n    @Test\n    public void deleteTree() {\n    }\n\n}", "prediction": "        try {\n            ZKTools.deleteTree(zooKeeper, \"/test\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "83811108_1", "part": [1, 1], "seq": [1, 1], "prompt": "class CachingHttpClient {\n\n    public synchronized T get(URL url) throws IOException {\n        if (url == null) {\n            throw new IllegalArgumentException(\"URL must not be null\");\n        }\n\n        Optional<byte[]> content = Optional.empty();\n        try {\n            content = cache.get(url, () -> Optional.of(getContent(url)));\n        } catch (ExecutionException e) {\n            cache.put(url, Optional.empty());\n            throw new IOException(\"Unable to get \" + url.toString(), e.getCause());\n        }\n        return content.isPresent() ? callback.transform(content.get()) : null;\n    }\n\n    public  CachingHttpClient(ContentReceviedCallback<T> callback);\n\n    private byte[] getContent(URL url);\n\n    private static final String PATH_TO_RESOURCE;\n    private static final String PATH_TO_MISSING_RESOURCE;\n    private static final int TEST_PORT;\n    private static final String TEST_HOST;\n    private static final int TEST_TIMEOUT;\n    private static final String SERVER_RESPONSE;\n    private static Server server;\n    private ContentReceviedCallback<String> testCallback;\n    private CachingHttpClient<String> testClient;\n\n}\n\nclass CachingHttpClientTest {\n\n    private static final String PATH_TO_RESOURCE;\n    private static final String PATH_TO_MISSING_RESOURCE;\n    private static final int TEST_PORT;\n    private static final String TEST_HOST;\n    private static final int TEST_TIMEOUT;\n    private static final String SERVER_RESPONSE;\n    private static Server server;\n    private ContentReceviedCallback<String> testCallback;\n    private CachingHttpClient<String> testClient;\n\n    @Test\n    public void testMultipleSuccessfulRequests() throws Exception {\n", "reference": "        URL reachableURL = getUniqueURL(PATH_TO_RESOURCE);\n\n        assertNotNull(testClient.get(reachableURL));\n        assertNotNull(testClient.get(reachableURL));\n        assertNotNull(testClient.get(reachableURL));\n\n        verify(server.getHandler(), times(1)).handle(any(), any(), any(), any());\n    }\n\n}", "prediction": "        assertEquals(SERVER_RESPONSE, testClient.get(new URL(TEST_HOST + \":\" + TEST_PORT + PATH_TO_RESOURCE)));\n        assertEquals(SERVER_RESPONSE, testClient.get(new URL(TEST_HOST + \":\" + TEST_PORT + PATH_TO_RESOURCE)));\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "83838306_39", "part": [1, 1], "seq": [1, 1], "prompt": "class FeatureRecord {\n\n  @Override public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    FeatureRecord record = (FeatureRecord) o;\n    return Objects.equals(optionSelectorWeighted, record.optionSelectorWeighted) &&\n        Objects.equals(feature, record.feature) &&\n        Objects.equals(namespaceFeatureMap, record.namespaceFeatureMap) &&\n        Objects.equals(namespaceControlFeatureOptionMap,\n            record.namespaceControlFeatureOptionMap) &&\n        Objects.equals(namespaceOptionSelectorWeightedMap,\n            record.namespaceOptionSelectorWeightedMap) &&\n        Objects.equals(controlFeatureOption, record.controlFeatureOption);\n  }\n\n  private  FeatureRecord(Feature feature);\n\n  static FeatureRecord build(Feature feature);\n  public Feature feature();\n   NamespaceFeature namespace(String namespace);\n   FeatureOption controlFeatureOption();\n   FeatureOption controlFeatureOption(String namespace);\n   OptionSelectorWeighted optionSelectorWeighted();\n   OptionSelectorWeighted optionSelectorWeighted(String namespace);\n   boolean enabled();\n   boolean enabled(String namespace);\n   String select();\n   String select(String namespace);\n   boolean selectBoolean();\n   boolean selectBoolean(String namespace);\n  private String selectControlOption(String namespace);\n  private boolean isDefaultNamespace(String namespace);\n  private void prepare();\n  private void prepareDefault();\n  private void prepareNamespaces();\n  private boolean matchesControlOption(String control, FeatureOption featureOption);\n  private boolean isOptionalType();\n  private boolean isOptionalType(OptionCollection options);\n  @Override public int hashCode();\n  @Override public String toString();\n\n}\n\nclass FeatureRecordTest {\n\n  @Test\n  public void testEquals() {\n", "reference": "    final Feature feature = TestSupport.loadFeature(\n        \"json/feature-select-string-off-default-on-namespace-off-namespace.json\");\n    final Feature feature1 = TestSupport.loadFeature(\n        \"json/feature-select-string-off-default-on-namespace-off-namespace.json\");\n    final Feature feature2 = TestSupport.loadFeature(\"json/feature-1.json\");\n\n    assertEquals(feature, feature1);\n    assertNotEquals(feature, feature2);\n    assertSame(2, Sets.newHashSet(feature, feature1, feature2).size());\n    assertEquals(feature.toString(), feature1.toString());\n  }\n\n}", "prediction": "    FeatureRecord record1 = FeatureRecord.build(Feature.builder(\"test\").build());\n    FeatureRecord record2 = FeatureRecord.build(Feature.builder(\"test\").build());\n    assertEquals(record1, record2);\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "83988988_4", "part": [1, 1], "seq": [1, 1], "prompt": "class TweetService {\n\n\tpublic void save(Tweet tweet) {\n\t\ttweetsDatabase.put(tweet.getId(), tweet);\n\t\tSystem.out.println(\"Created tweet: '\" + tweet.getText() + \"' - ID Nr.: \" + tweet.getId());\n\t}\n\n\tpublic void delete(String id);\n\tpublic Tweet findById(String id);\n\tpublic int size();\n\tpublic List<Tweet> findAll();\n\tpublic List<Tweet> search(String someString);\n\n\t TweetService tweetService;\n\t Tweet tweet1;\n\t Tweet tweet2;\n\t Tweet tweet3;\n\t Tweet tweet4;\n\t Tweet tweet5;\n\n}\n\nclass TweetServiceTest {\n\n\t TweetService tweetService;\n\t Tweet tweet1;\n\t Tweet tweet2;\n\t Tweet tweet3;\n\t Tweet tweet4;\n\t Tweet tweet5;\n\n\t@Test\n\tpublic void saveTest() {\n", "reference": "\t\ttweetService.save(tweet1);\n\t\tassertEquals(\"hola gente!!!\", tweetService.findById(tweet1.getId()).getText());\n\t\t//tweetService.save(tweet1);\n\t\t//assertNumTweets(2);\n\t}\n\n}", "prediction": "\t\ttweetService.save(tweet1);\n\t\tassertEquals(1, tweetService.size());\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "84065080_6", "part": [1, 1], "seq": [1, 1], "prompt": "class AnnotationProcessor {\n\n    public Collection<Node<?>> getDependencies(Class<?> pluginClass) {\n        final Constructor<?>[] constructors = pluginClass.getConstructors();\n        if (constructors.length == 0) {\n            throw new IllegalArgumentException(String.format(\"Class %s doesn't have a public constructor. Class: %s\", pluginClass.getSimpleName(), pluginClass.getName()));\n        }\n\n        for (Constructor<?> constructor : constructors) {\n            final Inject annotation = constructor.getAnnotation(Inject.class);\n            if (annotation == null) {\n                continue;\n            }\n            final Collection<Node<?>> dependencies = new ArrayList<>();\n            final Class<?>[] parameterTypes = constructor.getParameterTypes();\n            for (final Class<?> param : parameterTypes) {\n                dependencies.add(new Node<>(param));\n\n            }\n            return dependencies;\n\n        }\n        return new ArrayList<>();\n    }\n\n    public static String getPluginName(T plugin);\n    public static String getPluginName(Class<T> plugin);\n    public boolean hasDependencies(Class<?> pluginClass);\n    private static Plugin getPluginAnnotation(Class<?> pluginClass);\n\n    private AnnotationProcessor sut;\n\n}\n\nclass AnnotationProcessorTest {\n\n    private AnnotationProcessor sut;\n\n    @Test\n    public void shouldRetrieveDependencies() {\n", "reference": "        final Collection<Node<?>> dependencies = sut.getDependencies(DependencyPlugin.class);\n        assertFalse(dependencies.isEmpty());\n    }\n\n}", "prediction": "        final Collection<Node<?>> dependencies = sut.getDependencies(PluginWithDependencies.class);\n        assertThat(dependencies).hasSize(2);\n        assertThat(dependencies).contains(new Node<>(String.class));\n        assertThat(dependencies).contains(new Node<>(Integer.class));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "85760629_1", "part": [1, 1], "seq": [1, 1], "prompt": "class TokenProvider {\n\n    public boolean validateToken(String authToken) {\n        try {\n            Jwts.parser().setSigningKey(secretKey).parseClaimsJws(authToken);\n            return true;\n        } catch (SignatureException e) {\n            log.info(\"Invalid JWT signature.\");\n            log.trace(\"Invalid JWT signature trace: {}\", e);\n        } catch (MalformedJwtException e) {\n            log.info(\"Invalid JWT token.\");\n            log.trace(\"Invalid JWT token trace: {}\", e);\n        } catch (ExpiredJwtException e) {\n            log.info(\"Expired JWT token.\");\n            log.trace(\"Expired JWT token trace: {}\", e);\n        } catch (UnsupportedJwtException e) {\n            log.info(\"Unsupported JWT token.\");\n            log.trace(\"Unsupported JWT token trace: {}\", e);\n        } catch (IllegalArgumentException e) {\n            log.info(\"JWT token compact of handler are invalid.\");\n            log.trace(\"JWT token compact of handler are invalid trace: {}\", e);\n        }\n        return false;\n    }\n\n    public  TokenProvider(JHipsterProperties jHipsterProperties);\n\n    @PostConstruct public void init();\n    public String createToken(Authentication authentication, Boolean rememberMe);\n    public Authentication getAuthentication(String token);\n\n    private final String secretKey;\n    private final long ONE_MINUTE;\n    private JHipsterProperties jHipsterProperties;\n    private TokenProvider tokenProvider;\n\n}\n\nclass TokenProviderTest {\n\n    private final String secretKey;\n    private final long ONE_MINUTE;\n    private JHipsterProperties jHipsterProperties;\n    private TokenProvider tokenProvider;\n\n    @Test\n    public void testReturnFalseWhenJWTisUnsupported() {\n", "reference": "        Date expirationDate = new Date(new Date().getTime() + ONE_MINUTE);\n\n        Authentication authentication = createAuthentication();\n\n        String unsupportedToken = createUnsupportedToken();\n\n        boolean isTokenValid = tokenProvider.validateToken(unsupportedToken);\n\n        assertThat(isTokenValid).isEqualTo(false);\n    }\n\n}", "prediction": "        assertFalse(tokenProvider.validateToken(\"unsupported\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "86467203_3", "part": [1, 1], "seq": [1, 1], "prompt": "class TopologicalSorter {\n\n\tpublic List<Node> sort(Node root, boolean failOnCycles) {\n\t\treturn new Sort(root, failOnCycles).compute();\n\t}\n\n}\n\nclass TopologicalSorterTest {\n\n\t@Test\n\tpublic void cycle_lenient() {\n", "reference": "\t\tNode a = createNode(\"a\", \"1\");\n\t\tNode b = createNode(\"b\", \"1\");\n\t\tNode c = createNode(\"c\", \"1\");\n\t\tNode d = createNode(\"d\", \"1\");\n\t\tNode oc = createOmittedNode(\"c\", \"1\");\n\t\tNode ob = createOmittedNode(\"b\", \"1\");\n\n\t\ta.addChildNode(b);\n\t\ta.addChildNode(c);\n\t\tb.addChildNode(d);\n\t\tc.addChildNode(ob);\n\t\tb.addChildNode(oc);\n\n\t\tList<Node> resultNodes = new TopologicalSorter().sort(a, false);\n\t\tList<String> r = resultNodes.stream().map(Node::getArtifactId).collect(Collectors.toList());\n\t\tAssert.assertTrue(r.indexOf(\"a\") > r.indexOf(\"b\"));\n\t\tAssert.assertTrue(r.indexOf(\"a\") > r.indexOf(\"c\"));\n\t\tAssert.assertTrue(r.indexOf(\"b\") > r.indexOf(\"d\"));\n\n\t}\n\n}", "prediction": "\t\tNode a = new Node(\"a\");\n\t\tNode b = new Node(\"b\");\n\t\tNode c = new Node(\"c\");\n\t\tNode d = new Node(\"d\");\n\t\tNode e = new Node(\"e\");\n\t\tNode f = new Node(\"f\");\n\t\tNode g = new Node(\"g\");\n\t\tNode h = new Node(\"h\");\n\t\tNode i = new Node(\"i\");\n\t\tNode j = new Node(\"j\");\n\t\tNode k = new Node(\"k\");\n\t\tNode l = new Node(\"l\");\n\t\tNode m = new Node(\"m\");\n\t\tNode n = new Node(\"n\");\n\t\tNode o = new Node(\"o\");\n\t\tNode p = new Node(\"p\");\n\t\tNode q = new Node(\"q\");\n\t\tNode r = new Node(\"r\");\n\t\tNode s = new Node(\"s\");\n\t\tNode t = new Node(\"t\");\n\t\tNode u = new Node(\"u\");\n\t\tNode v = new Node(\"v\");\n\t\tNode w = new Node(\"w\");\n\t\tNode x = new Node(\"x\");\n\t\tNode y = new Node(\"y\");\n\t\tNode z = new Node(\"z\");\n\t\ta.addDependency(b);\n\t\tb.addDependency(c);\n\t\tc.addDependency(d);\n\t\td.addDependency(e);\n\t\te.addDependency(f);\n\t\tf.addDependency(g);\n\t\tg.addDependency(h);\n\t\th.addDependency(i);\n\t\ti.addDependency(j);\n\t\tj.addDependency(k);\n\t\tk.addDependency(l);\n\t\tl.addDependency(m);\n\t\tm.addDependency(n);\n\t\tn.addDependency(o);\n\t\to.addDependency(p);\n\t\tp.addDependency(q);\n\t\tq.addDependency(r);\n\t\tr.addDependency(s);\n\t\ts.addDependency(t);\n\t\tt.addDependency(u);\n\t\tu.addDependency(v);\n\t\tv.addDependency(w);\n\t\tw.addDependency(x);\n\t\tx.addDependency(y);\n\t\ty.addDependency(z);\n\t\tz.addDependency(a);\n\t\tList<Node> sorted = new TopologicalSorter().sort(a, false);\n\t\tassertThat(sorted).containsExactly(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z);\n\t}", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "86734489_1", "part": [1, 1], "seq": [1, 1], "prompt": "class AdditionalPropertiesParser {\n\n    public static Properties merge(Properties base, Properties addtional){\n        Properties properties = new Properties();\n        properties.putAll(base);\n        if(addtional != null){\n            for(String key : addtional.stringPropertyNames()){\n                properties.putIfAbsent(key, addtional.getProperty(key));\n            }\n        }\n        return properties;\n    }\n\n    public  AdditionalPropertiesParser(String propertiesString);\n\n    private static String[] split(String propertiesString, String separator);\n    private static String correctSingleQuotes(String val);\n    public Properties parse();\n\n}\n\nclass AdditionalPropertiesParserTest {\n\n    @Test(dataProvider = \"MergingResultProvider\")\n    public void testMerge(Properties base, Properties additional, Properties expectedMergeResult) throws Exception {\n", "reference": "        assertEquals(expectedMergeResult, AdditionalPropertiesParser.merge(base, additional), \"Wrong result properties from merging found.\");\n    }\n\n}", "prediction": "        Properties mergeResult = AdditionalPropertiesParser.merge(base, additional);\n        assertEquals(mergeResult, expectedMergeResult);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "86897067_7", "part": [1, 1], "seq": [1, 1], "prompt": "class CameraUpdateHandler {\n\n\tpublic void moveCamera(CameraUpdate cameraUpdate) {\n\t\tfinal OsmCameraUpdate osmCameraUpdate = (OsmCameraUpdate) cameraUpdate;\n\n\t\tfinal IMapController controller = map.getController();\n\n\t\tif (osmCameraUpdate.bounds != null) {\n\t\t\tfinal LatLng center = osmCameraUpdate.bounds.getCenter();\n\n\t\t\tcontroller.setZoom(map.getMaxZoomLevel());\n\n\t\t\tcontroller.zoomToSpan(\n\t\t\t\t\t(int) ((osmCameraUpdate.bounds.northeast.latitude - osmCameraUpdate.bounds.southwest.latitude) * 1e6),\n\t\t\t\t\t(int) ((osmCameraUpdate.bounds.northeast.longitude - osmCameraUpdate.bounds.southwest.longitude) * 1e6)\n\t\t\t);\n\n\t\t\tcontroller.setCenter(\n\t\t\t\t\ttoGeoPoint(center)\n\t\t\t);\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (osmCameraUpdate.zoom != null) {\n\t\t\tcontroller.setZoom(osmCameraUpdate.zoom.intValue());\n\t\t}\n\n\t\tif (osmCameraUpdate.center != null) {\n\t\t\tcontroller.setCenter(\n\t\t\t\t\ttoGeoPoint(osmCameraUpdate.center)\n\t\t\t);\n\t\t}\n\t}\n\n\tpublic  CameraUpdateHandler(MapView map);\n\n\tpublic void animateCamera(CameraUpdate cameraUpdate);\n\tpublic void animateCamera(CameraUpdate cameraUpdate, AnyMap.CancelableCallback callback);\n\tpublic void animateCamera(CameraUpdate cameraUpdate, int duration, AnyMap.CancelableCallback callback);\n\n\t@Mock org.osmdroid.views.MapView map;\n\t@Mock IMapController mapController;\n\n}\n\nclass CameraUpdateHandlerTest {\n\n\t@Mock org.osmdroid.views.MapView map;\n\t@Mock IMapController mapController;\n\n\t@Test\n\tpublic void testMoveCameraToPositionWithZoom() throws Exception {\n", "reference": "\t\t// Given\n\t\tCameraUpdateHandler handler = new CameraUpdateHandler(map);\n\n\t\tfinal LatLng center = new LatLng(10, 10);\n\t\tfinal int zoomLevel = 10;\n\n\t\tOsmCameraUpdate cameraUpdate = new OsmCameraUpdate.Builder()\n\t\t\t\t.center(center)\n\t\t\t\t.zoom((float) zoomLevel)\n\t\t\t\t.build();\n\n\t\t// When\n\t\thandler.moveCamera(cameraUpdate);\n\n\t\t// Then\n\t\tverify(mapController).setCenter(eq(toGeoPoint(center)));\n\t\tverify(mapController).setZoom(zoomLevel);\n\t\tverifyNoMoreInteractions(mapController);\n\t}\n\n}", "prediction": "\t\tCameraUpdate cameraUpdate = CameraUpdateFactory.newLatLngZoom(new LatLng(1, 2), 3);\n\t\tCameraUpdateHandler cameraUpdateHandler = new CameraUpdateHandler(map);\n\t\tcameraUpdateHandler.moveCamera(cameraUpdate);\n\n\t\tverify(mapController).setZoom(3);\n\t\tverify(mapController).setCenter(any(GeoPoint.class));\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "87972852_0", "part": [1, 1], "seq": [1, 1], "prompt": "class Encoding {\n\n    @NonNull\n    public String toBase64(@NonNull String value) {\n        return toBase64(value.getBytes(SSCharset.CHARSET));\n    }\n\n    @NonNull public String fromBase64ToString(@NonNull String value);\n    @NonNull public String toBase64(@NonNull byte[] value);\n    @NonNull public byte[] fromBase64ToBytes(@NonNull String value);\n\n    private static final String TEST_VALUE;\n    private static final String TEST_VALUE_BASE64;\n    private Encoding encoding;\n\n}\n\nclass EncodingTest {\n\n    private static final String TEST_VALUE;\n    private static final String TEST_VALUE_BASE64;\n    private Encoding encoding;\n\n    @Test\n    public void toBase64FromString_ShouldEncodeToBase64String() {\n", "reference": "        PowerMockito.when(Base64.encodeToString(TEST_VALUE.getBytes(SSCharset.CHARSET), Base64.NO_WRAP))\n                .thenReturn(TEST_VALUE_BASE64);\n\n        Assert.assertEquals(TEST_VALUE_BASE64, encoding.toBase64(TEST_VALUE));\n    }\n\n}", "prediction": "        String base64 = encoding.toBase64(TEST_VALUE);\n        assertEquals(TEST_VALUE_BASE64, base64);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "88115454_2", "part": [1, 1], "seq": [1, 1], "prompt": "class TopicConfigManager extends ConfigManager {\n\n    public TopicConfig createTopicInSendMessageMethod(final String topic, final String defaultTopic,\n            final String remoteAddress, final int clientDefaultTopicQueueNums, final int topicSysFlag) {\n        TopicConfig topicConfig = null;\n        boolean createNew = false;\n\n        try {\n            if (this.lockTopicConfigTable.tryLock(LockTimeoutMillis, TimeUnit.MILLISECONDS)) {\n                try {\n                    topicConfig = this.topicConfigTable.get(topic); //\u8be5topic\u5b58\u5728\u5219\u76f4\u63a5\u8fd4\u56de\n                    if (topicConfig != null)\n                        return topicConfig;\n\n                    TopicConfig defaultTopicConfig = this.topicConfigTable.get(defaultTopic);\n                    if (defaultTopicConfig != null) {\n                        if (PermName.isInherited(defaultTopicConfig.getPerm())) {\n                            topicConfig = new TopicConfig(topic);\n\n                            int queueNums =\n                                    clientDefaultTopicQueueNums > defaultTopicConfig.getWriteQueueNums() ? defaultTopicConfig\n                                        .getWriteQueueNums() : clientDefaultTopicQueueNums;\n\n                            if (queueNums < 0) {\n                                queueNums = 0;\n                            }\n\n                            topicConfig.setReadQueueNums(queueNums);\n                            topicConfig.setWriteQueueNums(queueNums);\n                            int perm = defaultTopicConfig.getPerm();\n                            perm &= ~PermName.PERM_INHERIT;\n                            topicConfig.setPerm(perm);\n                            topicConfig.setTopicSysFlag(topicSysFlag);\n                            topicConfig.setTopicFilterType(defaultTopicConfig.getTopicFilterType());\n                        }\n                        else {\n                            log.warn(\"create new topic failed, because the default topic[\" + defaultTopic\n                                    + \"] no perm, \" + defaultTopicConfig.getPerm() + \" producer: \"\n                                    + remoteAddress);\n                        }\n                    }\n                    else {\n                        log.warn(\"create new topic failed, because the default topic[\" + defaultTopic\n                                + \"] not exist.\" + \" producer: \" + remoteAddress);\n                    }\n\n                    if (topicConfig != null) {\n                        log.info(\"create new topic by default topic[\" + defaultTopic + \"], \" + topicConfig\n                                + \" producer: \" + remoteAddress);\n\n                        this.topicConfigTable.put(topic, topicConfig);\n\n                        this.dataVersion.nextVersion();\n\n                        createNew = true;\n\n                        this.persist();\n                    }\n                }\n                finally {\n                    this.lockTopicConfigTable.unlock();\n                }\n            }\n        }\n        catch (InterruptedException e) {\n            log.error(\"createTopicInSendMessageMethod exception\", e);\n        }\n\n        if (createNew) {\n            this.brokerController.registerBrokerAll(false, true);\n        }\n\n        return topicConfig;\n    }\n\n    public  TopicConfigManager();\n    public  TopicConfigManager(BrokerController brokerController);\n\n    public boolean isSystemTopic(final String topic);\n    public Set<String> getSystemTopic();\n    public boolean isTopicCanSendMessage(final String topic);\n    public TopicConfig selectTopicConfig(final String topic);\n    public TopicConfig createTopicInSendMessageBackMethod(//\n            final String topic, //\n            final int clientDefaultTopicQueueNums,//\n            final int perm,//\n            final int topicSysFlag);\n    public void updateTopicUnitFlag(final String topic, final boolean unit);\n    public void updateTopicUnitSubFlag(final String topic, final boolean hasUnitSub);\n    public void updateTopicConfig(final TopicConfig topicConfig);\n    public void updateOrderTopicConfig(final KVTable orderKVTableFromNs);\n    public boolean isOrderTopic(final String topic);\n    public void deleteTopicConfig(final String topic);\n    public TopicConfigSerializeWrapper buildTopicConfigSerializeWrapper();\n    @Override public String encode();\n    public String encode(final boolean prettyFormat);\n    @Override //\u628a/root/store/config/topics.json \u4e2d\u7684\u5b57\u7b26\u4e32\u5e8f\u5217\u5316\u5b58\u5165topicConfigTable\uff0c public void decode(String jsonString);\n    private void printLoadDataWhenFirstBoot(final TopicConfigSerializeWrapper tcs);\n    @Override public String configFilePath();\n    public DataVersion getDataVersion();\n    public ConcurrentHashMap<String, TopicConfig> getTopicConfigTable();\n\n}\n\nclass TopicConfigManagerTest {\n\n    @Test\n    public void test_flushTopicConfig() throws Exception {\n", "reference": "        BrokerController brokerController = new BrokerController(//\n            new BrokerConfig(), //\n            new NettyServerConfig(), //\n            new NettyClientConfig(), //\n            new MessageStoreConfig());\n        boolean initResult = brokerController.initialize();\n        System.out.println(\"initialize \" + initResult);\n        brokerController.start();\n\n        TopicConfigManager topicConfigManager = new TopicConfigManager(brokerController);\n\n        TopicConfig topicConfig =\n                topicConfigManager.createTopicInSendMessageMethod(\"TestTopic_SEND\", MixAll.DEFAULT_TOPIC,\n                    null, 4, 0);\n        assertTrue(topicConfig != null);\n\n        System.out.println(topicConfig);\n\n        for (int i = 0; i < 10; i++) {\n            String topic = \"UNITTEST-\" + i;\n            topicConfig =\n                    topicConfigManager\n                        .createTopicInSendMessageMethod(topic, MixAll.DEFAULT_TOPIC, null, 4, 0);\n            assertTrue(topicConfig != null);\n        }\n\n        topicConfigManager.persist();\n\n        brokerController.shutdown();\n    }\n\n}", "prediction": "        TopicConfigManager topicConfigManager = new TopicConfigManager(createDefaultBrokerController());\n        topicConfigManager.start();\n\n        TopicConfig topicConfig = new TopicConfig(\"topic-test\");\n        topicConfig.setReadQueueNums(8);\n        topicConfig.setWriteQueueNums(8);\n        topicConfig.setTopicSysFlag(0);\n        topicConfig.setPerm(PermName.PERM_INHERIT);\n        topicConfig.setTopicFilterType(TopicFilterType.SINGLE_TAG);\n\n        topicConfigManager.createAndUpdateTopicConfig(topicConfig);\n\n        topicConfigManager.shutdown();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "88319793_0", "part": [1, 1], "seq": [1, 1], "prompt": "class ImageClassificationWorkItemHandler extends AbstractLogOrThrowWorkItemHandler implements Cacheable {\n\n\tpublic void executeWorkItem(WorkItem workItem, WorkItemManager manager) {\n\t\ttry {\n\t\t\tInputStream imageIS = null;\n\t\t\tObject inputImage = workItem.getParameter(PARAM_IMAGE);\n\t\t\tif (inputImage instanceof InputStream) {\n\t\t\t\timageIS = (InputStream) inputImage;\n\t\t\t} else if (inputImage instanceof File) {\n\t\t\t\timageIS = new FileInputStream((File) inputImage);\n\t\t\t} else if (inputImage instanceof URL) {\n\t\t\t\timageIS = ((URL) inputImage).openStream();\n\t\t\t} else {\n\t\t\t\tthrow new IllegalArgumentException(\"Input Parameter \" + PARAM_IMAGE + \" has an invalid type.\");\n\t\t\t}\n\t\t\tMap<String, Object> results = new HashMap<String, Object>();\n\t\t\tMap<String, Double> predictions = classifier.classifyImage(imageIS);\n\t\t\tresults.put(RESULT_PREDICTIONS, predictions);\n\t\t\tresults.put(RESULT_PREDICTION, getPrediction(predictions));\n\t\t\tmanager.completeWorkItem(workItem.getId(), results);\n\t\t} catch (Throwable cause) {\n\t\t\tSystem.out.println(\"Error running WIH: \" + cause.getMessage());\n\t\t\thandleException(cause);\n\t\t}\n\t}\n\n\tpublic  ImageClassificationWorkItemHandler(ClassLoader cl, String model, String labels, int width, int height, int channels);\n\tpublic  ImageClassificationWorkItemHandler(File model, String labels, int width, int height, int channels);\n\tpublic  ImageClassificationWorkItemHandler(URL model, String labels, int width, int height, int channels);\n\tpublic  ImageClassificationWorkItemHandler(InputStream model, String labels, int width, int height, int channels);\n\tpublic  ImageClassificationWorkItemHandler(InputStream model, String labels, int width, int height, int channels, DataNormalization normalization);\n\tpublic  ImageClassificationWorkItemHandler();\n\tprivate  ImageClassificationWorkItemHandler(InputStream model, List<String> labels, int width, int height,\n\t\t\tint channels, DataNormalization normalization);\n\n\tprivate static List<String> getLabels(InputStream labelsIS);\n\tprivate static List<String> getLabels(String labels);\n\t@Override public void abortWorkItem(WorkItem workItem, WorkItemManager manager);\n\t@Override public void close();\n\tprivate String getPrediction(Map<String, Double> predictions);\n\n}\n\nclass ImageClassificationWorkItemHandlerTest {\n\n\t@Test\n\tpublic void testHandler() throws Exception {\n", "reference": "\t\tWorkItemImpl workItem = new WorkItemImpl();\n\t\tTestWorkItemManager manager = new TestWorkItemManager();\n\t\tImageClassificationWorkItemHandler handler = new ImageClassificationWorkItemHandler();\n\t\tInputStream testImageIS = ImageClassificationWorkItemHandlerTest.class.getResourceAsStream(\"/my_bike.jpg\");\n\t\tworkItem.setParameter(ImageClassificationWorkItemHandler.PARAM_IMAGE, testImageIS);\n\t\thandler.executeWorkItem(workItem, manager);\n\t\tassertNotNull(manager.getResults());\n\t\tassertEquals(1, manager.getResults().size());\n\t\tassertEquals(\"mountain_bike\", manager.getResults().get(workItem.getId()).get(\"prediction\"));\n\t\tassertTrue(manager.getResults().containsKey(workItem.getId()));\n\t}\n\n}", "prediction": "\t\tImageClassificationWorkItemHandler handler = new ImageClassificationWorkItemHandler(\n\t\t\t\tgetClass().getResourceAsStream(\"/cat.jpg\"),\n\t\t\t\tgetClass().getResourceAsStream(\"/labels.txt\"),\n\t\t\t\t224, 224, 3);\n\t\tWorkItem workItem = new WorkItemImpl();\n\t\tworkItem.setParameter(ImageClassificationWorkItemHandler.PARAM_IMAGE, getClass().getResourceAsStream(\"/cat.jpg\"));\n\t\tWorkItemManager manager = new TestWorkItemManager();\n\t\thandler.executeWorkItem(workItem, manager);\n\t\tassertEquals(\"cat\", manager.getResults(workItem.getId()).get(ImageClassificationWorkItemHandler.RESULT_PREDICTION));\n\t}", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "88676590_1", "part": [1, 1], "seq": [1, 1], "prompt": "class ContextJdbcEventListenerFactory implements JdbcEventListenerFactory {\n\n    @Override\n    public JdbcEventListener createJdbcEventListener() {\n        return compoundJdbcEventListener;\n    }\n\n      ContextJdbcEventListenerFactory(JdbcEventListenerFactory delegate, List<JdbcEventListener> listeners);\n\n    private JdbcEventListenerFactory delegate;\n\n}\n\nclass ContextJdbcEventListenerFactoryTest {\n\n    private JdbcEventListenerFactory delegate;\n\n    @Test\n    void shouldReuseCompoundListenerFromFactory() {\n", "reference": "        SimpleJdbcEventListener listener1 = new SimpleJdbcEventListener() {};\n        Mockito.when(delegate.createJdbcEventListener()).thenReturn(new CompoundJdbcEventListener());\n        ContextJdbcEventListenerFactory contextJdbcEventListenerFactory = new ContextJdbcEventListenerFactory(delegate, Collections.singletonList(listener1));\n\n        CompoundJdbcEventListener jdbcEventListener = (CompoundJdbcEventListener) contextJdbcEventListenerFactory.createJdbcEventListener();\n        assertThat(jdbcEventListener.getEventListeners()).hasSize(1);\n        assertThat(jdbcEventListener.getEventListeners()).contains(listener1);\n    }\n\n}", "prediction": "        ContextJdbcEventListenerFactory factory = new ContextJdbcEventListenerFactory(delegate, Collections.emptyList());\n        JdbcEventListener listener = factory.createJdbcEventListener();\n        assertThat(listener).isSameAs(compoundJdbcEventListener);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "90501128_0", "part": [1, 1], "seq": [1, 1], "prompt": "class Pessoa {\n\n\tpublic void setNome(String nome) {\n\t\tthis.nome = nome;\n\t}\n\n\tpublic int getIdade();\n\tpublic void setIdade(int idade);\n\tpublic float getPeso();\n\tpublic void setPeso(float peso);\n\tpublic float getAltura();\n\tpublic void setAltura(float altura);\n\tpublic String getNome();\n\n}\n\nclass PessoaTest {\n\n\t@Test\n\tvoid pessoaComNomeRaro() {\n", "reference": "\n\t\tPessoa pessoa = new Pessoa();\n\t\tpessoa.setNome(\"Davi\");\n\n\t\tassertTrue(new NomeRaro().test(pessoa));\n\t}\n\n}", "prediction": "\t\tPessoa p = new Pessoa();\n\t\tp.setNome(\"Jo\u00e3o da Silva\");\n\t\tassertEquals(\"Jo\u00e3o da Silva\", p.getNome());\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "91121306_29", "part": [1, 1], "seq": [1, 1], "prompt": "class MarshmallowNetworkObservingStrategy extends Api21BaseNetworkObservingStrategy {\n\n  @Override\n  public Observable<RxNetworkInfo> observe() {\n    Observable.create(new MarshmallowOnSubscribe()).subscribeWith(networkChange);\n    return networkChange.distinctUntilChanged().doOnDispose(new OnDisposeAction());\n  }\n\n  public  MarshmallowNetworkObservingStrategy(@NonNull Context context);\n  public  MarshmallowNetworkObservingStrategy(@NonNull Context context,\n      @NonNull NetworkRequest networkRequest);\n\n  @Override void dispose();\n  @Override Logger logger();\n  private void unregisterIdleModeReceiver();\n  private void unregisterNetworkCallback();\n  @Override ConnectivityManager connectivityManager();\n\n  private final TestObserver<RxNetworkInfo> testObserver;\n  private final RxNetworkInfo defaultRxNetworkInfo;\n  @Rule public MockitoRule rule;\n  @Mock private PowerManager powerManager;\n  private Context context;\n  private BaseNetworkObservingStrategy sut;\n\n}\n\nclass MarshmallowNetworkObservingStrategyTest {\n\n  private final TestObserver<RxNetworkInfo> testObserver;\n  private final RxNetworkInfo defaultRxNetworkInfo;\n  @Rule public MockitoRule rule;\n  @Mock private PowerManager powerManager;\n  private Context context;\n  private BaseNetworkObservingStrategy sut;\n\n  @Test\n  public void shouldGetValue_whenIdleModeChanged_andDeviceIdled() {\n", "reference": "    setUpDeviceIdleMode(true);\n    doReturn(false).when(powerManager).isIgnoringBatteryOptimizations(anyString());\n\n    sut.observe().subscribeWith(testObserver);\n    testObserver.assertSubscribed().assertEmpty();\n\n    RuntimeEnvironment.application.sendBroadcast(new Intent(ACTION_DEVICE_IDLE_MODE_CHANGED));\n\n    testObserver.assertSubscribed().assertValue(defaultRxNetworkInfo);\n  }\n\n}", "prediction": "    // given\n    given(powerManager.isDeviceIdleMode()).willReturn(true);\n    given(powerManager.isDeviceIdleMode()).willReturn(false);\n\n    // when\n    sut.observe().subscribe(testObserver);\n\n    // then\n    testObserver.assertValueCount(2);\n    testObserver.assertValues(defaultRxNetworkInfo, defaultRxNetworkInfo);\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "91375712_0", "part": [1, 1], "seq": [1, 1], "prompt": "class RxOptional extends Maybe<T> {\n\n    public static <T> RxOptional<T> maybe(T value) {\n        return new RxOptional<>(value);\n    }\n\n    private  RxOptional();\n    private  RxOptional(T value);\n\n    @SuppressWarnings(\"unchecked\") public static RxOptional<T> empty();\n    public RxOptional<T> or(T anotherValue);\n    public Observable<U> flatten(Function<T, Iterable<? extends U>> mapper);\n    public T get();\n    @Nonnull public RxOptional<T> ifPresent(@Nonnull Consumer<T> consumer);\n    @Nonnull public RxOptional<T> ifNotPresent(@Nonnull Action action);\n    @Nonnull public RxOptional<T> mapIfNotPresent(@Nonnull Supplier<T> supplier);\n    @Nonnull public RxOptional<R> mapIfPresent(@Nonnull Function<T, R> function);\n    @Nonnull public RxOptional<T> flatMapIfNotPresent(@Nonnull Supplier<RxOptional<T>> supplier);\n    @Nonnull public RxOptional<R> flatMapIfPresent(@Nonnull Function<T, RxOptional<R>> function);\n    @Override protected void subscribeActual(MaybeObserver<? super T> observer);\n\n    public static final String SHOULD_NOT_EXECUTE;\n\n}\n\nclass RxOptionalTest {\n\n    public static final String SHOULD_NOT_EXECUTE;\n\n    @Test\n    public void maybe() {\n", "reference": "        assertEquals(\"1\", RxOptional.maybe(\"1\").get());\n    }\n\n}", "prediction": "        RxOptional.maybe(1).subscribe(new MaybeObserver<Integer>() {\n            @Override\n            public void onSubscribe(Disposable d) {\n\n            }\n\n            @Override\n            public void onSuccess(Integer integer) {\n                System.out.println(integer);\n            }\n\n            @Override\n            public void onError(Throwable e) {\n\n            }\n\n            @Override\n            public void onComplete() {\n\n            }\n        });\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "91730068_9", "part": [1, 1], "seq": [1, 1], "prompt": "class TokenUtils {\n\n    public static String signClaims(final String jsonResName) throws Exception {\n        return signClaims(jsonResName, SignatureAlgorithm.RS256);\n    }\n\n    private  TokenUtils();\n\n    @Deprecated public static String generateTokenString(final String jsonResName);\n    public static String signClaims(final String jsonResName, SignatureAlgorithm algorithm);\n    @Deprecated public static String generateTokenString(final String jsonResName, final Set<InvalidClaims> invalidClaims);\n    public static String signClaims(final String jsonResName, SignatureAlgorithm algorithm, final Set<InvalidClaims> invalidClaims);\n    @Deprecated public static String generateTokenString(String jsonResName, Set<InvalidClaims> invalidClaims, Map<String, Long> timeClaims);\n    public static String signClaims(String jsonResName, SignatureAlgorithm algorithm,\n        Set<InvalidClaims> invalidClaims, Map<String, Long> timeClaims);\n    @Deprecated public static String generateTokenString(PrivateKey pk, String kid, String jsonResName, Set<InvalidClaims> invalidClaims,\n            Map<String, Long> timeClaims);\n    public static String signClaims(PrivateKey pk, String kid, String jsonResName);\n    public static String signClaims(PrivateKey pk, String kid, String jsonResName,\n        Set<InvalidClaims> invalidClaims, Map<String, Long> timeClaims);\n    public static String encryptClaims(final String jsonResName);\n    public static String encryptClaims(final String jsonResName, final Set<InvalidClaims> invalidClaims);\n    public static String encryptClaims(String jsonResName, Set<InvalidClaims> invalidClaims, Map<String, Long> timeClaims);\n    public static String encryptClaims(PublicKey pk, String jsonResName);\n    public static String encryptClaims(PublicKey pk, String kid, String jsonResName);\n    public static String encryptClaims(PublicKey pk, String kid, String jsonResName, Set<InvalidClaims> invalidClaims,\n            Map<String, Long> timeClaims);\n    public static String signEncryptClaims(String jsonResName);\n    public static String signEncryptClaims(String jsonResName, SignatureAlgorithm signatureAlgorithm);\n    public static String signEncryptClaims(PrivateKey signingKey,\n                                             PublicKey encryptionKey,\n                                             String jsonResName);\n    public static String signEncryptClaims(PrivateKey signingKey,\n                                       String signingKid,\n                                       PublicKey encryptionKey,\n                                       String encryptionKid,\n                                       String jsonResName);\n    public static String signEncryptClaims(PrivateKey signingKey,\n                                       String signingKid,\n                                       PublicKey encryptionKey,\n                                       String encryptionKid,\n                                       String jsonResName,\n                                       boolean setContentType);\n    private static String encryptString(Key key, String kid, String plainText, boolean setContentType);\n    private static JwtClaims createJwtClaims(String jsonResName, Set<InvalidClaims> invalidClaims,\n            Map<String, Long> timeClaims);\n    private static String readJsonContent(String jsonResName);\n    public static String readResource(String resName);\n    public static RSAPrivateKey readPrivateKey(final String pemResName);\n    public static ECPrivateKey readECPrivateKey(final String pemResName);\n    public static RSAPublicKey readPublicKey(final String pemResName);\n    public static ECPublicKey readECPublicKey(final String pemResName);\n    public static PublicKey readJwkPublicKey(final String jwkResName);\n    public static PrivateKey readJwkPrivateKey(final String jwkResName);\n    public static KeyPair generateKeyPair(final int keySize);\n    public static RSAPrivateKey decodePrivateKey(final String pemEncoded);\n    public static ECPrivateKey decodeECPrivateKey(final String pemEncoded);\n    public static RSAPublicKey decodePublicKey(String pemEncoded);\n    public static ECPublicKey decodeECPublicKey(String pemEncoded);\n    private static byte[] toEncodedBytes(final String pemEncoded);\n    private static String removeBeginEnd(String pem);\n    public static int currentTimeInSecs();\n\n}\n\nclass TokenUtilsTest {\n\n    @Test(groups = TCKConstants.TEST_GROUP_UTILS, expectedExceptions = {InvalidJwtException.class},\n", "reference": "        description = \"Illustrate validation of signer\")\n    public void testFailSignature() throws Exception {\n        Set<TokenUtils.InvalidClaims> invalidFields = new HashSet<>();\n        invalidFields.add(TokenUtils.InvalidClaims.SIGNER);\n        String token = TokenUtils.signClaims(\"/Token1.json\", SignatureAlgorithm.RS256, invalidFields);\n        validateToken(token);\n    }\n\n}", "prediction": "           expectedExceptionsMessageRegExp = \"The JWT Claims Set must contain a JWT ID claim.\")\n    public void testGenerateTokenStringWithoutJti() throws Exception {\n        TokenUtils.generateTokenString(\"RS256\", \"src/test/resources/jwt-without-jti.json\");\n    }\n\n}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "93611636_1", "part": [1, 1], "seq": [1, 1], "prompt": "class PathExtractor {\n\n  String path(RequestContext context) {\n    HttpServletRequest request = context.getRequest();\n    StringBuilder builder = new StringBuilder();\n\n    builder.append(request.getContextPath()).append(request.getServletPath());\n    if (request.getPathInfo() != null) {\n      builder.append(request.getPathInfo());\n    }\n\n    if (context.getRequestQueryParams() != null) {\n      appendQueryParams(context, builder);\n    }\n\n    return builder.toString();\n  }\n\n  private void appendQueryParams(RequestContext context, StringBuilder builder);\n\n  private final RequestContext requestContext;\n  private final HttpServletRequest servletRequest;\n  private final Map<String, List<String>> queryParams;\n  private final PathExtractor extractor;\n\n}\n\nclass PathExtractorTest {\n\n  private final RequestContext requestContext;\n  private final HttpServletRequest servletRequest;\n  private final Map<String, List<String>> queryParams;\n  private final PathExtractor extractor;\n\n  @Test\n  public void extractsPathWithQueryStringAndPathInfo() {\n", "reference": "    when(servletRequest.getPathInfo()).thenReturn(\"/id\");\n    when(requestContext.getRequestQueryParams()).thenReturn(queryParams);\n\n    String path = extractor.path(requestContext);\n\n    assertThat(path).isEqualTo(\"/root/path/to/resource/id?n=3&n=5\");\n  }\n\n}", "prediction": "    assertThat(extractor.path(requestContext)).isEqualTo(\"/context/servlet/path/info?param=value\");\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "93714543_57", "part": [1, 1], "seq": [1, 1], "prompt": "class RocketChatVerifier {\n\n    public static void checkServerVersion(OkHttpClient client, String baseUrl,\n                                          final VersionVerifier versionVerifier,\n                                          final SimpleCallback callback) {\n        checkNotNull(client, \"client == null\");\n        checkNotNull(baseUrl, \"baseUrl == null\");\n        checkNotNull(versionVerifier, \"versionVerifier == null\");\n        checkNotNull(callback, \"callback == null\");\n\n        final Moshi moshi = new Moshi.Builder().add(CommonJsonAdapterFactory.create()).build();\n\n        HttpUrl url = HttpUrl.parse(baseUrl).newBuilder()\n                .addPathSegment(\"api\")\n                .addPathSegment(\"info\")\n                .build();\n\n        Request request = new Request.Builder()\n                .url(url)\n                .get()\n                .build();\n\n        client.newCall(request).enqueue(new Callback() {\n            @Override\n            public void onFailure(Call call, IOException e) {\n                callback.onError(new RocketChatNetworkErrorException(\"network error\", e));\n            }\n\n            @Override\n            public void onResponse(Call call, Response response) throws IOException {\n                try {\n                    if (!response.isSuccessful()) {\n                        JSONObject json = new JSONObject(response.body().string());\n                        String message = json.optString(\"error\");\n                        String errorType = json.optString(\"errorType\");\n                        callback.onError(new RocketChatApiException(response.code(), message,\n                                errorType));\n                    }\n\n                    JsonAdapter<ServerInfo> adapter = moshi.adapter(ServerInfo.class);\n                    ServerInfo info = adapter.fromJson(response.body().string());\n\n                    if (versionVerifier.isValidVersion(info.version())) {\n                        callback.onSuccess();\n                    } else {\n                        callback.onError(new RocketChatException(\"Unsupported version: \"\n                                + info.version()));\n                    }\n                } catch (IOException | JSONException e) {\n                    callback.onError(new RocketChatException(e.getMessage(), e));\n                }\n            }\n        });\n    }\n\n    @Mock\n    private RocketChatVerifier.VersionVerifier verifier;\n    @Mock\n    private SimpleCallback callback;\n    @Captor ArgumentCaptor<String> versionCaptor;\n    @Captor\n    private ArgumentCaptor<RocketChatException> exceptionCaptor;\n    private DefaultMockServer mockServer;\n    private OkHttpClient client;\n    private HttpUrl baseUrl;\n\n}\n\nclass RocketChatVerifierTest {\n\n    @Mock\n    private RocketChatVerifier.VersionVerifier verifier;\n    @Mock\n    private SimpleCallback callback;\n    @Captor ArgumentCaptor<String> versionCaptor;\n    @Captor\n    private ArgumentCaptor<RocketChatException> exceptionCaptor;\n    private DefaultMockServer mockServer;\n    private OkHttpClient client;\n    private HttpUrl baseUrl;\n\n    @Test\n    public void shouldNotCallVersionVerifierWithInvalidResponse() {\n", "reference": "        mockServer.expect().withPath(\"/api/info\").andReturn(200, \"INVALID_RESPONSE\").once();\n        RocketChatVerifier.checkServerVersion(client, baseUrl.toString(), verifier, callback);\n\n        verify(verifier, timeout(1000).times(0))\n                .isValidVersion(versionCaptor.capture());\n    }\n\n}", "prediction": "        mockServer.enqueue(new MockResponse().setResponseCode(400));\n\n        RocketChatVerifier.checkServerVersion(client, baseUrl, verifier, callback);\n\n        verify(callback).onError(exceptionCaptor.capture());\n        assertThat(exceptionCaptor.getValue().getMessage(), is(\"network error\"));\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "93777628_22", "part": [1, 1], "seq": [1, 1], "prompt": "class CoinURI implements Serializable {\n\n    public Value getAmount() {\n        return (Value) parameterMap.get(FIELD_AMOUNT);\n    }\n\n    public  CoinURI(String uri);\n    public  CoinURI(@Nullable CoinType uriType, String input);\n\n    private static URI getUri(String input);\n    private void parseParameters(String[] nameValuePairTokens, List<CoinType> possibleTypes);\n    private void putWithValidation(String key, Object value);\n    public CoinType getTypeRequired();\n    @Nullable public CoinType getType();\n    public boolean hasType();\n    @Nullable public AbstractAddress getAddress();\n    public String getLabel();\n    public String getMessage();\n    public String getPublicKey();\n    public String getPaymentRequestUrl();\n    public URI getAddressRequestUri();\n    public boolean isAddressRequest();\n    public URI getAddressRequestUriResponse(AbstractAddress address);\n    public URI getAddressRequestUriResponse(String address);\n    public Object getParameterByName(String name);\n    @Override public String toString();\n    public static String convertToCoinURI(AbstractAddress address);\n    public static String convertToCoinURI(AbstractAddress address, @Nullable Value amount,\n                                          @Nullable String label, @Nullable String message);\n    public static String convertToCoinURI(AbstractAddress address, @Nullable Value amount,\n                                          @Nullable String label, @Nullable String message,\n                                          @Nullable String pubkey);\n    static String encodeURLString(String stringToEncode);\n    public String toUriString();\n\n    private CoinURI testObject;\n    final CoinType BTC;\n    final CoinType BTC_TEST;\n    final CoinType LTC;\n    final CoinType DOGE;\n    final CoinType PPC;\n    final CoinType DASH;\n    final CoinType NBT;\n    final CoinType NSR;\n    final CoinType NXT;\n    private static final String MAINNET_GOOD_ADDRESS;\n\n}\n\nclass CoinURITest {\n\n    private CoinURI testObject;\n    final CoinType BTC;\n    final CoinType BTC_TEST;\n    final CoinType LTC;\n    final CoinType DOGE;\n    final CoinType PPC;\n    final CoinType DASH;\n    final CoinType NBT;\n    final CoinType NSR;\n    final CoinType NXT;\n    private static final String MAINNET_GOOD_ADDRESS;\n\n    @Test\n    public void testGood_Amount() throws CoinURIParseException {\n", "reference": "        // Test the decimal parsing\n        testObject = new CoinURI(BitcoinMain.get(), BitcoinMain.get().getUriScheme() + \":\" + MAINNET_GOOD_ADDRESS\n                + \"?amount=6543210.12345678\");\n        assertEquals(654321012345678L, testObject.getAmount().value);\n\n        // Test the decimal parsing\n        testObject = new CoinURI(BitcoinMain.get(), BitcoinMain.get().getUriScheme() + \":\" + MAINNET_GOOD_ADDRESS\n                + \"?amount=.12345678\");\n        assertEquals(12345678L, testObject.getAmount().value);\n\n        // Test the integer parsing\n        testObject = new CoinURI(BitcoinMain.get(), BitcoinMain.get().getUriScheme() + \":\" + MAINNET_GOOD_ADDRESS\n                + \"?amount=6543210\");\n        assertEquals(654321000000000L, testObject.getAmount().value);\n    }\n\n}", "prediction": "        CoinURI uri = new CoinURI(\"bitcoin:12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX?amount=1.23\");\n        assertEquals(new Value(123000000), uri.getAmount());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "93984344_0", "part": [1, 1], "seq": [1, 1], "prompt": "class AdminAuthGroupService {\n\n    @Transactional\n    public Result delete(AdminAuthGroup group) {\n        //  \u5220\u9664\u7528\u6237\u7ec4\n        adminAuthGroupDao.delete(group.getId());\n        //  \u6e05\u7406\u7528\u6237\u7ec4\u4e0b\u7684\u7528\u6237\n        adminAuthGroupAccessDao.deleteByGroupId(group.getId());\n        return Result.wrapResult(AdminAuthRuleLang.DROP_SUCCESS);\n    }\n\n    public Result add(AdminAuthGroup group);\n    @Transactional public Result modifyRules(AdminAuthGroup group, List<AdminAuthRule> rules);\n    public Result edit(AdminAuthGroup group);\n    public Result<List<AdminAuthGroup>> getGroupsByUserId(Long uid);\n    public PagingResult<AdminAuthGroup> search(SearchParam param, PageParam pageParam);\n\n    @Autowired\n    private AdminAuthGroupService adminAuthGroupService;\n\n}\n\nclass TestAdminAuthGroupService  {\n\n    @Autowired\n    private AdminAuthGroupService adminAuthGroupService;\n\n    @Test\n    public void testDelete() {\n", "reference": "        AdminAuthGroup group = new AdminAuthGroup();\n        group.setId(4l);\n        adminAuthGroupService.delete(group);\n    }\n\n}", "prediction": "        adminAuthGroupService.delete(new AdminAuthGroup());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "95594455_9", "part": [1, 1], "seq": [1, 1], "prompt": "class ConcreteExtendedTimedBean extends AbstractTimedBean {\n\n    public void anotherTimedMethod() {\n    }\n\n    private final static String TIMED_NAME;\n    private final static String EXTENDED_TIMED_NAME;\n    private static MetricID timedMID;\n    private static MetricID extendedTimedMID;\n    @Inject\n    private ConcreteExtendedTimedBean bean;\n\n}\n\nclass ConcreteExtendedTimedBeanTest {\n\n    private final static String TIMED_NAME;\n    private final static String EXTENDED_TIMED_NAME;\n    private static MetricID timedMID;\n    private static MetricID extendedTimedMID;\n    @Inject\n    private ConcreteExtendedTimedBean bean;\n\n    @Test\n    @InSequence(4)\n    public void callExtendedTimedMethodOnce(MetricRegistry registry) {\n", "reference": "        Timer timer = registry.getTimer(extendedTimedMID);\n        assertThat(\"Timer is not registered correctly\", timer, notNullValue());\n\n        // Call the timed method and assert it's been timed\n        bean.anotherTimedMethod();\n\n        // Make sure that the timer has been called\n        assertThat(\"Timer count is incorrect\", timer.getCount(), is(equalTo(1L)));\n    }\n\n}", "prediction": "        bean.extendedTimedMethod();\n        assertEquals(1, registry.getTimers().get(extendedTimedMID).getCount());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "95635499_116", "part": [1, 1], "seq": [1, 1], "prompt": "class TransformDistance extends AWeightedTrigometricDistance {\n\n\t@Override\n\tpublic double distance(final double[] a, final double[] b) {\n\t\tdouble[] transformA = this.transform.transform(a);\n\t\tdouble[] transformB = this.transform.transform(b);\n\t\treturn this.getA() * this.timeSeriesDistance.distance(a, b) + this.getB() * this.baseTransformDistance.distance(transformA, transformB);\n\t}\n\n\tpublic  TransformDistance(final double alpha, final IVectorTransform transform, final IDistanceMetric timeSeriesDistance, final IDistanceMetric transformDistance);\n\tpublic  TransformDistance(final double alpha, final IDistanceMetric timeSeriesDistance, final IDistanceMetric transformDistance);\n\tpublic  TransformDistance(final double alpha, final IVectorTransform transform, final IDistanceMetric distance);\n\tpublic  TransformDistance(final double alpha, final IDistanceMetric distance);\n\n}\n\nclass TransformDistanceTest {\n\n\t@Test\n\tpublic void testCorrectnessForDistanceCalculation() {\n", "reference": "\t\t// Input.\n\t\tdouble[] timeSeries1 = { 1, 1, 1, 1, 1, 1 };\n\t\tdouble[] timeSeries2 = { 1, 1, 1, 1, 1, 1 };\n\t\t// Expectation.\n\t\tdouble expectation = 0;\n\n\t\tTransformDistance td = new TransformDistance(0.5, new DynamicTimeWarping());\n\t\tdouble distance = td.distance(timeSeries1, timeSeries2);\n\n\t\tassertEquals(expectation, distance, 0);\n\t}\n\n}", "prediction": "\t\tfinal double[] a = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n\t\tfinal double[] b = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n\t\tfinal double[] c = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 };\n\t\tfinal double[] d = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 };\n\t\tfinal double[] e = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 };\n\t\tfinal double[] f = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14 };\n\t\tfinal double[] g = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };\n\t\tfinal double[] h = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 };\n\t\tfinal double[] i = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17 };\n\t\tfinal double[] j = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18 };\n\t\tfinal double[] k = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19 };\n\t\tfinal double[] l = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20 };\n\t\tfinal double[] m = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21 };\n\t\tfinal double[] n = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22 };\n\t\tfinal double[] o = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23 };\n\t\tfinal double[] p = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24 };\n\t\tfinal double[] q = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25 };\n\t\tfinal double[] r = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26 };\n\t\tfinal double[] s = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27 };\n\t\tfinal double[] t = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 1", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "95789248_0", "part": [1, 1], "seq": [1, 1], "prompt": "class TracingHandler implements Handler<RoutingContext> {\n\n    public static SpanContext serverSpanContext(RoutingContext routingContext) {\n        SpanContext serverContext = null;\n\n        Object object = routingContext.get(CURRENT_SPAN);\n        if (object instanceof Span) {\n            Span span = (Span) object;\n            serverContext = span.context();\n        } else {\n            log.error(\"Sever SpanContext is null or not an instance of SpanContext\");\n        }\n\n        return serverContext;\n    }\n\n    public  TracingHandler(Tracer tracer);\n    public  TracingHandler(Tracer tracer, List<WebSpanDecorator> decorators);\n\n    @Override public void handle(RoutingContext routingContext);\n    protected void handlerNormal(RoutingContext routingContext);\n    protected void handlerFailure(RoutingContext routingContext);\n    private Handler<Void> finishEndHandler(RoutingContext routingContext, Span span);\n\n    protected MockTracer mockTracer;\n\n}\n\nclass TracingHandlerTest  {\n\n    protected MockTracer mockTracer;\n\n    @Test\n    public void testLocalSpan() throws Exception {\n", "reference": "        {\n            router.route(\"/localSpan\").handler(routingContext -> {\n                SpanContext serverSpanContext = TracingHandler.serverSpanContext(routingContext);\n                io.opentracing.Tracer.SpanBuilder spanBuilder = mockTracer.buildSpan(\"localSpan\");\n\n                spanBuilder.asChildOf(serverSpanContext)\n                        .start()\n                        .finish();\n\n                routingContext.response()\n                        .setStatusCode(202)\n                        .end();\n            });\n\n            request(\"/localSpan\", HttpMethod.GET, 202);\n            Awaitility.await().until(reportedSpansSize(), IsEqual.equalTo(2));\n        }\n        List<MockSpan> mockSpans = mockTracer.finishedSpans();\n        Assert.assertEquals(2, mockSpans.size());\n\n        Assert.assertEquals(mockSpans.get(0).parentId(), mockSpans.get(1).context().spanId());\n        Assert.assertEquals(mockSpans.get(0).context().traceId(), mockSpans.get(1).context().traceId());\n    }\n\n}", "prediction": "        TracingHandler tracingHandler = new TracingHandler(mockTracer);\n        RoutingContext routingContext = mock(RoutingContext.class);\n        Span span = mock(Span.class);\n        when(routingContext.get(CURRENT_SPAN)).thenReturn(span);\n        tracingHandler.handle(routingContext);\n        verify(span, times(1)).finish();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "95800582_12", "part": [1, 1], "seq": [1, 1], "prompt": "class ListUtils {\n\n    public static <Item> SparseIntArray getReorderings(List<? extends Item> oldList, List<? extends Item> newList){\n        List<Pair<Integer, Integer>> moveList = calculateMoves(oldList, newList);\n        List<Integer> netMoveScores = calculateNetMoveScores(moveList);\n        SparseIntArray reorderings = new SparseIntArray();\n        while(extractReordering(moveList, netMoveScores, reorderings));\n        return reorderings;\n    }\n\n    public static SparseBooleanArray getInsertions(@Nullable List<? extends Item> oldList, @NonNull List<? extends Item> newList);\n    public static SparseBooleanArray getDeletions(@Nullable List<? extends Item> oldList, @NonNull List<? extends Item> newList);\n    private static List<Pair<Integer, Integer>> calculateMoves(List<? extends Item> oldList, List<? extends Item> newList);\n    private static List<Integer> calculateNetMoveScores(List<Pair<Integer, Integer>> moveList);\n    private static boolean extractReordering(List<Pair<Integer, Integer>> moveList, List<Integer> netMoveScores, SparseIntArray reorderings);\n    private static String generateString(List<Pair<Integer, Integer>> moveList);\n    private static void cleanNetMoveList(List<Integer> netMoveScores, List<Pair<Integer, Integer>> moveList);\n    private static int indexOfHighestNetMove(List<Integer> netMoveScores);\n    private static List<Integer> getNewIndicesOfOldIndicesAboveIndex(Integer index, List<Pair<Integer, Integer>> moveList);\n\n    private static final List<Integer> list05;\n    private static final List<Integer> list15;\n    private static final List<Integer> list06;\n    private static final List<Integer> listFlip;\n    private static final List<Integer> listGap;\n    private static final List<Integer> listMultiReorder;\n    private static final List<Integer> listSwap;\n\n}\n\nclass ListUtilsTest {\n\n    private static final List<Integer> list05;\n    private static final List<Integer> list15;\n    private static final List<Integer> list06;\n    private static final List<Integer> listFlip;\n    private static final List<Integer> listGap;\n    private static final List<Integer> listMultiReorder;\n    private static final List<Integer> listSwap;\n\n    @Test\n    public void testReorderSwap() {\n", "reference": "        SparseIntArray reorderings = ListUtils.getReorderings(list05, listSwap);\n        assertThat(reorderings.size(), is(2));\n        assertThat(reorderings.get(5), is(0));\n        assertThat(reorderings.get(0), is(5));\n    }\n\n}", "prediction": "        SparseIntArray reorderings = ListUtils.getReorderings(list05, list15);\n        assertEquals(1, reorderings.size());\n        assertEquals(1, reorderings.keyAt(0));\n        assertEquals(1, reorderings.valueAt(0));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "97669395_92", "part": [1, 1], "seq": [1, 1], "prompt": "class CookbookLoader {\n\n  public Cookbook load(InputStream ingredients) {\n    ObjectMapper mapper = new ObjectMapper(new YAMLFactory());\n    Cookbook cookbook = null;\n    try {\n      cookbook = mapper.readValue(ingredients, Cookbook.class);\n    } catch (IOException e) {\n      throw new RuntimeException(\"could not load recipe cookbook from input stream\", e);\n    }\n    validate(cookbook);\n    return cookbook;\n  }\n\n  private void validate(Cookbook cookbook);\n  private void validateDomain(Cookbook cookbook);\n  private void validateIngredients(Cookbook cookbook);\n  private void validateEnums(Cookbook cookbook);\n  private void validateInitializersContainRequiredFields(Cookbook cookbook);\n  private void validateNoDuplicateIngredientNames(Cookbook cookbook);\n  private void validateParamTypes(Cookbook cookbook);\n  private void validateNoDuplicateFieldNames(Cookbook cookbook);\n  private void validateInitializerSignaturesUnique(Cookbook cookbook);\n  private void validateRequiredHaveDefaultOrAppearInAllInitializers(Cookbook cookbook);\n  private void validateVaragParamsAppearLastInParamLists(Cookbook cookbook);\n  private void validateConstantNames(Cookbook cookbook);\n  private void validateNoDuplicateConstantNames(Cookbook cookbook);\n  private void validateDefaultKey(Cookbook cookbook);\n  private void validateNoDuplicateEnumNames(Cookbook cookbook);\n  private void validateNoEmptyEnumValues(Cookbook cookbook);\n  private void validateNoDuplicateEnumValues(Cookbook cookbook);\n\n  private CookbookLoader loader;\n\n}\n\nclass CookbookLoaderTest {\n\n  private CookbookLoader loader;\n\n  @Test(expected = RuntimeException.class)\n  public void testLoad_throwsOnOptionalWithoutName() {\n", "reference": "    String ingredients =\n        String.join(\n            \"\\n\",\n            \"domain: 'test'\",\n            \"ingredients:\",\n            \"  - name: 'fooIngredient'\",\n            \"    optionals:\",\n            \"      - type: 'string'\");\n\n    loader.load(toStream(ingredients));\n  }\n\n}", "prediction": "    loader.load(getClass().getResourceAsStream(\"cookbook_with_optional_without_name.yaml\"));\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "97776141_21", "part": [1, 1], "seq": [1, 1], "prompt": "class UserController {\n\n    @RequestMapping(value = \"check\", method = RequestMethod.GET)\n    public LoginResponse check(final HttpServletResponse response) {\n        if (JwtFilter.SUBJECT_ANONYMOUS.equals(response.getHeader(JwtFilter.HEADER_CLAIMS_SUBJECT))) {\n            return new LoginResponse(JwtFilter.ANONYMOUS_USER_ID, response.getHeader(JwtFilter.HEADER_CLAIMS_SUBJECT),\n                authenticationService.anonymousToken());\n        }\n\n        return new LoginResponse(response.getHeader(JwtFilter.HEADER_CLAIMS_USER_ID),\n            response.getHeader(JwtFilter.HEADER_CLAIMS_SUBJECT),\n            response.getHeader(JwtFilter.JWT_TOKEN));\n    }\n\n    @Autowired  UserController(final UserService userService, final AuthenticationService authenticationService);\n\n    @RequestMapping(value = \"login\", method = RequestMethod.POST) public LoginResponse login(@NonNull @RequestBody final LoginRequest login);\n    @RequestMapping(value = \"role/{role}\", method = RequestMethod.GET) public Boolean claimContainsRole(@PathVariable final String role,\n        final HttpServletRequest request);\n    @SuppressWarnings(\"unchecked\") private List<LinkedHashMap<String, String>> getRoles(final Claims claims);\n\n    private static final String USERNAME;\n    private static final String PASSWORD;\n    private static final String ROLE;\n    @Mock\n    private UserService mockUserService;\n    @Mock\n    private AuthenticationService mockAuthenticationService;\n    @Mock\n    private HttpServletRequest mockHttpServletRequest;\n    @Mock\n    private HttpServletResponse mockHttpServletResponse;\n    @Mock\n    private UserEntity mockUserEntity;\n    private UserController userController;\n\n}\n\nclass UserControllerTest {\n\n    private static final String USERNAME;\n    private static final String PASSWORD;\n    private static final String ROLE;\n    @Mock\n    private UserService mockUserService;\n    @Mock\n    private AuthenticationService mockAuthenticationService;\n    @Mock\n    private HttpServletRequest mockHttpServletRequest;\n    @Mock\n    private HttpServletResponse mockHttpServletResponse;\n    @Mock\n    private UserEntity mockUserEntity;\n    private UserController userController;\n\n    @Test\n    public void testCheckNotAnonymousHeader() {\n", "reference": "        Mockito.when(mockHttpServletResponse.getHeader(JwtFilter.HEADER_CLAIMS_SUBJECT)).thenReturn(\"not anonymous\");\n        Mockito.when(mockHttpServletResponse.getHeader(JwtFilter.JWT_TOKEN)).thenReturn(\"token\");\n\n        final LoginResponse loginResponse = userController.check(mockHttpServletResponse);\n\n        assertNotNull(loginResponse);\n\n        Mockito.verify(mockHttpServletResponse, Mockito.times(2)).getHeader(JwtFilter.HEADER_CLAIMS_SUBJECT);\n        Mockito.verify(mockHttpServletResponse).getHeader(JwtFilter.JWT_TOKEN);\n    }\n\n}", "prediction": "        when(mockHttpServletResponse.getHeader(JwtFilter.HEADER_CLAIMS_SUBJECT)).thenReturn(USERNAME);\n        when(mockHttpServletResponse.getHeader(JwtFilter.HEADER_CLAIMS_USER_ID)).thenReturn(USERNAME);\n        when(mockHttpServletResponse.getHeader(JwtFilter.JWT_TOKEN)).thenReturn(USERNAME);\n\n        final LoginResponse loginResponse = userController.check(mockHttpServletResponse);\n\n        assertEquals(USERNAME, loginResponse.getUserId());\n        assertEquals(USERNAME, loginResponse.getSubject());\n        assertEquals(USERNAME, loginResponse.getToken());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "98203629_0", "part": [1, 1], "seq": [1, 1], "prompt": "class AMQP10JMSProperties {\n\n    public String getRemoteUrl() {\n        return remoteUrl;\n    }\n\n    public void setRemoteUrl(String remoteUrl);\n    public String getUsername();\n    public void setUsername(String username);\n    public String getPassword();\n    public void setPassword(String password);\n    public String getClientId();\n    public void setClientId(String clientId);\n    public boolean isReceiveLocalOnly();\n    public void setReceiveLocalOnly(boolean receiveLocalOnly);\n    public boolean isReceiveNoWaitLocalOnly();\n    public void setReceiveNoWaitLocalOnly(boolean receiveNoWaitLocalOnly);\n    public DeserializationPolicy getDeserializationPolicy();\n    public Pool getPool();\n    public void setPool(Pool pool);\n\n    private static final String DEFAULT_AMQP_REMOTE_URL;\n    private final AMQP10JMSProperties properties;\n\n}\n\nclass AMQP10JMSPropertiesTest {\n\n    private static final String DEFAULT_AMQP_REMOTE_URL;\n    private final AMQP10JMSProperties properties;\n\n    @Test\n    public void testAMQPDefaultRemoteURL() {\n", "reference": "        assertEquals(DEFAULT_AMQP_REMOTE_URL, properties.getRemoteUrl());\n    }\n\n}", "prediction": "        assertEquals(DEFAULT_AMQP_REMOTE_URL, properties.getRemoteUrl());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "99149191_8", "part": [1, 1], "seq": [1, 1], "prompt": "class VClock {\n\n    public long lastUpdate() {\n        long last = 0;\n        for (Map.Entry<String, Long> clock : this.vc.entrySet()) {\n            if (clock.getValue() > last) {\n                last = clock.getValue();\n            }\n        }\n        return last;\n    }\n\n    public  VClock();\n\n    private TreeMap<String, Long> clockInit();\n    public void tick(String pid);\n    public void set(String pid, long ticks);\n    public VClock copy();\n    public long findTicks(String pid);\n    public void merge(VClock other);\n    public String returnVCString();\n    public void printVC();\n    public TreeMap<String, Long> getClockMap();\n\n     VClock testClock;\n\n}\n\nclass VClockTest {\n\n     VClock testClock;\n\n    @Test\n    public void lastUpdate() throws Exception {\n", "reference": "        testClock.set(\"Proc1\", 2);\n        testClock.set(\"Proc3\", 3);\n        testClock.set(\"Proc2\", 7);\n        long clockTicks = testClock.lastUpdate();\n        assertEquals(\"Copy failed! The clock values do not match.\", 7L, clockTicks);\n\n    }\n\n}", "prediction": "        testClock.tick(\"1\");\n        testClock.tick(\"2\");\n        testClock.tick(\"3\");\n        testClock.tick(\"4\");\n        testClock.tick(\"5\");\n        testClock.tick(\"6\");\n        testClock.tick(\"7\");\n        testClock.tick(\"8\");\n        testClock.tick(\"9\");\n        testClock.tick(\"10\");\n        testClock.tick(\"11\");\n        testClock.tick(\"12\");\n        testClock.tick(\"13\");\n        testClock.tick(\"14\");\n        testClock.tick(\"15\");\n        testClock.tick(\"16\");\n        testClock.tick(\"17\");\n        testClock.tick(\"18\");\n        testClock.tick(\"19\");\n        testClock.tick(\"20\");\n        testClock.tick(\"21\");\n        testClock.tick(\"22\");\n        testClock.tick(\"23\");\n        testClock.tick(\"24\");\n        testClock.tick(\"25\");\n        testClock.tick(\"26\");\n        testClock.tick(\"27\");\n        testClock.tick(\"28\");\n        testClock.tick(\"29\");\n        testClock.tick(\"30\");\n        testClock.tick(\"31\");\n        testClock.tick(\"32\");\n        testClock.tick(\"33\");\n        testClock.tick(\"34\");\n        testClock.tick(\"35\");\n        testClock.tick(\"36\");\n        testClock.tick(\"37\");\n        testClock.tick(\"38\");\n        testClock.tick(\"39\");\n        testClock.tick(\"40\");\n        testClock.tick(\"41\");\n        testClock.tick(\"42\");\n        testClock.tick(\"43\");\n        testClock.tick(\"44\");\n        testClock.tick(\"45\");\n        testClock.tick(\"46\");\n        testClock.tick(\"47\");\n        testClock.tick(\"48\");\n        testClock.tick(\"49\");\n        testClock.tick(\"50\");\n        testClock.tick(\"51\");\n        testClock.tick(\"52\");\n        testClock.tick(\"53\");\n        testClock.tick(\"54\");\n        testClock.tick(\"55\");\n        testClock.tick(\"56\");\n        testClock.tick(\"57\");\n        testClock.tick(\"58\");\n        testClock.tick(\"59\");\n        testClock.tick(\"60\");\n        testClock.tick(\"61\");\n        testClock.tick(\"62\");\n        testClock.tick(\"63\");\n        testClock.tick(\"64\");\n        testClock.tick(\"65\");\n        testClock.tick(\"66\");\n        testClock.tick(\"67\");\n        testClock.tick(\"68\");\n        testClock.tick(\"69\");\n        testClock.tick(\"70\");\n        testClock.tick(\"71\");\n        testClock.tick(\"72\");\n        testClock.tick(\"73\");\n        testClock.tick(\"74\");\n        testClock.tick(\"75\");\n        testClock.tick(\"76\");\n        testClock.tick(\"77\");\n        testClock.tick(\"78\");\n        testClock.tick(\"79\");\n        testClock.tick(\"80\");\n        testClock.tick(\"81\");\n        testClock.tick(\"82\");\n        testClock.tick(\"83\");\n        testClock.tick(\"84\");\n        testClock.tick(\"85\");\n        testClock.tick(\"86\");\n        testClock.tick(\"87\");\n        testClock.tick(\"88\");\n        testClock.tick(\"89\");\n        testClock.tick(\"90\");\n        testClock.tick(\"91\");\n        testClock.tick(\"92\");\n        testClock.tick(\"93\");\n        testClock.tick(\"94\");\n        testClock.tick(\"95\");\n        testClock.tick(\"96\");\n        testClock.tick(\"97\");\n        testClock.tick(\"98\");\n        testClock.tick(\"99\");\n        testClock.tick(\"100\");\n        testClock.tick(\"101\");\n        testClock.tick(\"102\");\n        testClock.tick(\"103\");\n        testClock.tick(\"104\");\n        testClock.tick(\"105\");\n        testClock.tick(\"106\");\n        testClock.tick(\"107\");\n        testClock.tick(\"108\");\n        testClock.tick(\"109\");\n        testClock.tick(\"110\");\n        testClock.tick(\"111\");\n        testClock.tick(\"112\");\n        testClock.tick(\"113\");\n        testClock.tick(\"114\");\n        testClock.tick(\"115\");\n        testClock.tick(\"116\");\n        testClock.tick(\"117\");\n        testClock.tick(\"118\");\n        testClock.tick(\"119\");\n        testClock.tick(\"120\");\n        testClock.tick(\"121\");\n        testClock.tick(\"122\");\n        testClock.tick(\"123\");\n        testClock.tick(\"124\");\n        testClock.tick(\"125\");\n        testClock.tick(\"126\");\n        testClock.tick(\"127\");\n        testClock.tick(\"128\");\n        testClock.tick(\"129\");\n        testClock.tick(\"130\");\n        testClock.tick(\"131\");\n        testClock.tick(\"132\");\n        testClock", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "100366560_19", "part": [1, 1], "seq": [1, 1], "prompt": "class PrimitiveTypeUtils {\n\n    public static Class<?> toWrapper(final TypeToken<?> primitiveTypeToken) {\n        return toWrapper((Class<?>) primitiveTypeToken.getType());\n    }\n\n    public static TypeToken<?> toWrapperTypeToken(final TypeToken<?> primitiveTypeToken);\n    public static Class<?> toWrapper(final Class<?> primitiveType);\n    public static Object toWrapperListToPrimitiveArray(final List wrapperList, Class<?> primitiveType);\n\n}\n\nclass PrimitiveTypeUtilsTest {\n\n    @Test(expected = IllegalArgumentException.class)\n    public void raiseArgumentErrorByNonPrimitiveType() {\n", "reference": "        PrimitiveTypeUtils.toWrapper(Integer.class);\n    }\n\n}", "prediction": "        PrimitiveTypeUtils.toWrapper(new TypeToken<String>() {});\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "100394760_1", "part": [1, 1], "seq": [1, 1], "prompt": "class ObjectPropertyField {\n\n  void applyValueParser(Object instance, String value) {\n    try {\n      field.set(instance, valueParser.apply(value));\n    } catch (IllegalAccessException e) {\n      throw ThrowableUtil.propagate(e);\n    }\n  }\n\n    ObjectPropertyField(Field field, String propertyName);\n\n  private boolean isList(ParameterizedType paramType);\n  private boolean isMultimap(ParameterizedType paramType);\n  private Function<String, ?> getValueParser(Type type);\n   String getPropertyName();\n\n  private static final String propName;\n\n}\n\nclass ObjectPropertyFieldTest {\n\n  private static final String propName;\n\n  @Test\n  void testNonPrimitiveObjectPropertyField() throws Exception {\n", "reference": "    NonPrimitiveClass instance = new NonPrimitiveClass();\n\n    Class<NonPrimitiveClass> clazz = NonPrimitiveClass.class;\n    ObjectPropertyField field_string =\n        new ObjectPropertyField(clazz.getDeclaredField(\"str\"), propName);\n    ObjectPropertyField field_duration =\n        new ObjectPropertyField(clazz.getDeclaredField(\"duration\"), propName);\n\n    field_string.applyValueParser(instance, \"just str\");\n    field_duration.applyValueParser(instance, \"100ms\");\n\n    assertEquals(\"just str\", instance.str);\n    assertEquals(Duration.ofMillis(100), instance.duration);\n  }\n\n}", "prediction": "    ObjectPropertyField field = new ObjectPropertyField(ObjectPropertyFieldTest.class.getDeclaredField(\"propName\"), \"propName\");\n    assertEquals(\"propName\", field.getPropertyName());\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "100600744_6", "part": [1, 1], "seq": [1, 1], "prompt": "class JmsMessageListener implements MessageListener {\n\n\t@Override\n\tpublic void onMessage(Message msg) {\n\t\tlogger.debug(\"received new message from queue '{}'\", queue);\n\t\tString text = Exceptions.sneak().get(() -> extractTextFromMessage(msg));\n\t\tSimpleMessage message = new SimpleMessage(text, queue, getMessageProperties(msg));\n\t\tstorage.addMessage(message);\n\t}\n\n\tpublic  JmsMessageListener(String queue, LocalMessageStorage storage, List<String> propertiesToExtract,\n\t\t\tString encoding);\n\n\tprivate String extractTextFromMessage(Message msg);\n\tprivate String encodingFromMessageOrDefault(BytesMessage bytesMessage);\n\tpublic Map<String, String> getMessageProperties(Message msg);\n\n\tprivate JmsMessageListener sut;\n\tprivate LocalMessageStorage storage;\n\n}\n\nclass JmsMessageListenerTest {\n\n\tprivate JmsMessageListener sut;\n\tprivate LocalMessageStorage storage;\n\n\t@Test\n\tpublic void shouldAddNewMapMessageToStorage() throws JMSException {\n", "reference": "\t\tMockMapMessage message = new MockMapMessage();\n\t\tmessage.setString(\"myText\", \"my awesome message \\uF609\");\n\n\t\tsut.onMessage(message);\n\n\t\tCollection<SimpleMessage> resultInStorage = storage.getMessagesAfter(0);\n\t\tassertThat(resultInStorage).hasSize(1);\n\t\tSimpleMessage first = resultInStorage.iterator().next();\n\n\t\tassertThat(first.getText()).isNotNull();\n\t\tassertThat(first.getProps()).isEmpty();\n\t}\n\n}", "prediction": "\t\t// given\n\t\tMapMessage msg = mock(MapMessage.class);\n\t\tgiven(msg.getString(\"key\")).willReturn(\"value\");\n\t\t// when\n\t\tsut.onMessage(msg);\n\t\t// then\n\t\tassertThat(storage.getMessages()).hasSize(1);\n\t\tassertThat(storage.getMessages().get(0).getProperties()).containsEntry(\"key\", \"value\");\n\t}", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "100679870_30", "part": [1, 1], "seq": [1, 1], "prompt": "class StoreImage implements ICachable<StoreImage> {\n\n  @Override\n  public long getByteSize() {\n    return data.length;\n  }\n\n  public  StoreImage(final long id, BufferedImage image, ImageSize size);\n  public  StoreImage(final long id, byte[] base64, ImageSize size);\n  public  StoreImage(StoreImage image);\n\n  private void setImageSize(ImageSize size);\n  public long getId();\n  private void setImage(BufferedImage image);\n  public BufferedImage getImage();\n  public ImageSize getSize();\n  public String getBase64();\n  public byte[] getByteArray();\n  @Override public String toString();\n  @Override public int hashCode();\n  @Override public boolean equals(Object obj);\n\n  private static final String IMG_STRING;\n  private static final String IMG_DATA;\n  private static final long IMG_ID0;\n  private static final long IMG_ID1;\n  private BufferedImage img;\n  @Mock\n  private StoreImage mockedImg0;\n  @Mock\n  private StoreImage mockedImg1;\n\n}\n\nclass TestStoreImage {\n\n  private static final String IMG_STRING;\n  private static final String IMG_DATA;\n  private static final long IMG_ID0;\n  private static final long IMG_ID1;\n  private BufferedImage img;\n  @Mock\n  private StoreImage mockedImg0;\n  @Mock\n  private StoreImage mockedImg1;\n\n  @Test\n  public void testGetByteSize() {\n", "reference": "    StoreImage uut = new StoreImage(IMG_ID1, IMG_DATA.getBytes(), ImageSizePreset.ICON.getSize());\n    assertEquals(IMG_DATA.getBytes().length, uut.getByteSize());\n  }\n\n}", "prediction": "    assertEquals(img.getByteSize(), img.getByteArray().length);\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "102614080_4", "part": [1, 1], "seq": [1, 1], "prompt": "class EtcdWatcherSplittingConsumer implements CheckedBiConsumer<Long, List<WatchEvent>, EtcdException> {\n\n    @Override\n    public void accept(Long revision, List<WatchEvent> allWatchEvents) throws EtcdException {\n        Builder<ByteSequence, List<WatchEvent>> listsBuilder = builderWithExpectedSize(splitConsumers.size());\n        ImmutableSet<ByteSequence> prefixes = splitConsumers.keySet();\n        for (ByteSequence keyPrefix : prefixes) {\n            listsBuilder.put(keyPrefix, new ArrayList<WatchEvent>());\n        }\n        ImmutableMap<ByteSequence, List<WatchEvent>> lists = listsBuilder.build();\n\n        for (WatchEvent watchEvent : allWatchEvents) {\n            for (ByteSequence keyPrefix : prefixes) {\n                if (watchEvent.getKeyValue().getKey().startsWith(keyPrefix)) {\n                    lists.get(keyPrefix).add(watchEvent);\n                }\n            }\n        }\n\n        for (Map.Entry<ByteSequence, List<WatchEvent>> list: lists.entrySet()) {\n            List<WatchEvent> eventsList = list.getValue();\n            // Important optimization, because with separate Oper/Config, one or the other is typically empty\n            if (!eventsList.isEmpty()) {\n                splitConsumers.get(list.getKey()).accept(eventsList);\n            }\n        }\n\n        revAwaiter.ifPresent(revAwait -> revAwait.update(revision));\n    }\n\n      EtcdWatcherSplittingConsumer(Optional<RevAwaiter> revAwaiter,\n            Map<ByteSequence, CheckedConsumer<List<WatchEvent>, EtcdException>> splitConsumers);\n\n    private final TestConsumer configConsumer;\n    private final TestConsumer operConsumer;\n    private final Map<ByteSequence, CheckedConsumer<List<WatchEvent>, EtcdException>> consumers;\n\n}\n\nclass EtcdWatcherSplittingConsumerTest {\n\n    private final TestConsumer configConsumer;\n    private final TestConsumer operConsumer;\n    private final Map<ByteSequence, CheckedConsumer<List<WatchEvent>, EtcdException>> consumers;\n\n    @Test\n    public void testOnlyConfigAndOperAndAnotherOneToIgnore() throws EtcdException {\n", "reference": "        EtcdWatcherSplittingConsumer splitter = new EtcdWatcherSplittingConsumer(empty(), consumers);\n        splitter.accept(1L, Lists.newArrayList(\n                newWatchEvent(append(CONFIGURATION_PREFIX, (byte) 123)),\n                newWatchEvent(fromBytes((byte) 234, (byte) 123)),\n                newWatchEvent(append(OPERATIONAL_PREFIX, (byte) 123))));\n        assertThat(configConsumer.counter.get()).isEqualTo(1L);\n        assertThat(operConsumer.counter.get()).isEqualTo(1L);\n    }\n\n}", "prediction": "        EtcdWatcherSplittingConsumer consumer = new EtcdWatcherSplittingConsumer(Optional.empty(), consumers);\n        consumer.accept(1L, Arrays.asList(\n                new WatchEvent(new KeyValue(ByteSequence.from(\"config/a\", UTF_8), ByteSequence.from(\"value\", UTF_8), 1L, 0L, 0L, 0L, 0L)),\n                new WatchEvent(new KeyValue(ByteSequence.from(\"oper/a\", UTF_8), ByteSequence.from(\"value\", UTF_8), 1L, 0L, 0L, 0L, 0L)),\n                new WatchEvent(new KeyValue(ByteSequence.from(\"another/a\", UTF_8), ByteSequence.from(\"value\", UTF_8), 1L, 0L, 0L, 0L, 0L))\n        ));\n\n        assertThat(configConsumer.getEvents(), contains(\n                new WatchEvent(new KeyValue(ByteSequence.from(\"config/a\", UTF_8), ByteSequence.from(\"value\", UTF_8), 1L, 0L, 0L, 0L, 0L))\n        ));\n        assertThat(operConsumer.getEvents(), contains(\n                new WatchEvent(new KeyValue(ByteSequence.from(\"oper/a\", UTF_8), ByteSequence.from(\"value\", UTF_8), 1L, 0L, 0L, 0L, 0L))\n        ));\n        assertThat(consumers.get(ByteSequence.from(\"another/a\", UTF_8)).getEvents(), empty());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "102814088_13", "part": [1, 1], "seq": [1, 1], "prompt": "class EmailValidator {\n\n  public boolean validate(final String hex) {\n\n    matcher = pattern.matcher(hex);\n    return matcher.matches();\n  }\n\n  public  EmailValidator();\n\n  private EmailValidator tested;\n\n}\n\nclass EmailValidatorTest {\n\n  private EmailValidator tested;\n\n  @Test\n  public void testValidate_invalidEmail() throws Exception {\n", "reference": "    assertThat(tested.validate(\"foo\")).isFalse();\n    assertThat(tested.validate(\"foo@\")).isFalse();\n    assertThat(tested.validate(\"foo@gmail\")).isFalse();\n  }\n\n}", "prediction": "    assertFalse(tested.validate(\"invalid\"));\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "103289349_0", "part": [1, 1], "seq": [1, 1], "prompt": "class Primitive {\n\n    public static AutoValue_Primitive.PrimitiveIntStep step() {\n        return AutoValue_Primitive.step();\n    }\n\n    public abstract int primitiveInt();\n    public abstract long primitiveLong();\n    public abstract double primitiveDouble();\n    public abstract float primitiveFloat();\n    public abstract boolean primitiveBoolean();\n    public abstract byte primitiveByte();\n    public abstract char primitiveChar();\n    public static AutoValue_Primitive.PrimitiveIntLazyStep lazyStep();\n\n    private static final int PRIMITIVE_INT;\n    private static final long PRIMITIVE_LONG;\n    private static final double PRIMITIVE_DOUBLE;\n    private static final float PRIMITIVE_FLOAT;\n    private static final boolean PRIMITIVE_BOOLEAN;\n    private static final byte PRIMITIVE_BYTE;\n    private static final char PRIMITIVE_CHAR;\n\n}\n\nclass PrimitiveTest {\n\n    private static final int PRIMITIVE_INT;\n    private static final long PRIMITIVE_LONG;\n    private static final double PRIMITIVE_DOUBLE;\n    private static final float PRIMITIVE_FLOAT;\n    private static final boolean PRIMITIVE_BOOLEAN;\n    private static final byte PRIMITIVE_BYTE;\n    private static final char PRIMITIVE_CHAR;\n\n    @Test\n    public void step() throws Exception {\n", "reference": "\n        Primitive primitive = Primitive.step()\n                .primitiveInt(PRIMITIVE_INT)\n                .primitiveLong(PRIMITIVE_LONG)\n                .primitiveDouble(PRIMITIVE_DOUBLE)\n                .primitiveFloat(PRIMITIVE_FLOAT)\n                .primitiveBoolean(PRIMITIVE_BOOLEAN)\n                .primitiveByte(PRIMITIVE_BYTE)\n                .primitiveChar(PRIMITIVE_CHAR)\n                .build();\n\n        assertPrimitive(primitive);\n    }\n\n}", "prediction": "        assertThat(Primitive.step().primitiveInt(PRIMITIVE_INT).primitiveLong(PRIMITIVE_LONG).primitiveDouble(PRIMITIVE_DOUBLE).primitiveFloat(PRIMITIVE_FLOAT).primitiveBoolean(PRIMITIVE_BOOLEAN).primitiveByte(PRIMITIVE_BYTE).primitiveChar(PRIMITIVE_CHAR).build().primitiveInt()).isEqualTo(PRIMITIVE_INT);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "103437385_44", "part": [1, 1], "seq": [1, 1], "prompt": "class MavenEmbedder {\n\n    public MavenProject readProject( final InputStream mavenProjectStream ) throws ProjectBuildingException, MavenEmbedderException {\n        ModelSource modelSource = new ModelSource() {\n            @Override\n            public InputStream getInputStream() {\n                return mavenProjectStream;\n            }\n\n            @Override\n            public String getLocation() {\n                return \"\";\n            }\n        };\n\n        ClassLoader originalCl = Thread.currentThread().getContextClassLoader();\n        try {\n            org.eclipse.aether.artifact.Artifact lastArtifact = null;\n            do {\n                Thread.currentThread().setContextClassLoader(componentProvider.getSystemClassLoader());\n                ProjectBuilder projectBuilder = componentProvider.lookup(ProjectBuilder.class);\n                // BZ-1007894: Check if added dependencies are resolvable.\n                ProjectBuildingResult result = projectBuilder.build(modelSource, getProjectBuildingRequest());\n                if (result != null && result.getDependencyResolutionResult() != null && !result.getDependencyResolutionResult().getCollectionErrors().isEmpty()) {\n                    // A dependency resolution error has been produced. It can contains some error. Throw the first one to the client, so the user will fix every one sequentially.\n                    final Exception depedencyResolutionException = result.getDependencyResolutionResult().getCollectionErrors().get(0);\n                    if (depedencyResolutionException instanceof ArtifactDescriptorException) {\n                        final org.eclipse.aether.artifact.Artifact artifact = ((ArtifactDescriptorException) depedencyResolutionException).getResult().getArtifact();\n                        if (!artifact.equals(lastArtifact)) {\n                            tryRemoveLocalArtifact(artifact);\n                            lastArtifact = artifact;\n                            continue;\n                        }\n                    }\n                    if (depedencyResolutionException != null) {\n                        throw new MavenEmbedderException(depedencyResolutionException.getMessage(), depedencyResolutionException);\n                    }\n                }\n                return (result == null || result.getProject() == null ) ? null : result.getProject();\n            } while (true);\n        } catch ( ComponentLookupException e ) {\n            throw new MavenEmbedderException( e.getMessage(), e );\n        } finally {\n            Thread.currentThread().setContextClassLoader( originalCl );\n            try {\n                mavenProjectStream.close();\n            } catch ( IOException e ) {\n            }\n        }\n    }\n\n    public  MavenEmbedder( MavenRequest mavenRequest );\n    public  MavenEmbedder( ClassLoader mavenClassLoader,\n                          ClassLoader parent,\n                          MavenRequest mavenRequest );\n    protected  MavenEmbedder( MavenRequest mavenRequest,\n                             ComponentProvider componentProvider );\n\n     void init();\n    protected MavenExecutionRequest buildMavenExecutionRequest( MavenRequest mavenRequest );\n    protected MavenRepositoryConfiguration getMavenRepositoryConfiguration();\n    private Properties getEnvVars();\n    public Settings getSettings();\n    public ArtifactRepository getLocalRepository();\n    public String getLocalRepositoryPath();\n     void tryRemoveLocalArtifact(Artifact artifact);\n    public MavenProject readProject( File mavenProject );\n    public List<MavenProject> readProjects( File mavenProject,\n                                            boolean recursive );\n    public List<ProjectBuildingResult> buildProjects( File mavenProject,\n                                                      boolean recursive );\n     ProjectBuildingRequest getProjectBuildingRequest();\n    public MavenSession getMavenSession();\n    public MavenExecutionRequest getMavenExecutionRequest();\n    public void dispose();\n    public MavenExecutionResult execute( final MavenRequest mavenRequest );\n\n    private final String EMPTY_SETTINGS;\n    final ComponentProvider componentProviderMocked;\n\n}\n\nclass MavenEmbedderTest {\n\n    private final String EMPTY_SETTINGS;\n    final ComponentProvider componentProviderMocked;\n\n    @Test\n    public void testInvalidLocalDependency() throws MavenEmbedderException, ProjectBuildingException, ComponentLookupException, SettingsBuildingException, InvalidRepositoryException {\n", "reference": "        final MavenExecutionRequestPopulator mavenExecutionRequestPopulator =  mock(MavenExecutionRequestPopulator.class);\n        final Logger logger =  mock(Logger.class);\n        final RepositorySystem repositorySystem = mock(RepositorySystem.class);\n        final ArtifactRepository artifactRepository = mock(ArtifactRepository.class);\n\n        final SettingsBuilder settingsBuilder =  mock(SettingsBuilder.class);\n        final SettingsBuildingResult settingsBuildingResult = mock(SettingsBuildingResult.class);\n        final ProjectBuilder projectBuilderMock =  mock(ProjectBuilder.class);\n        final DependencyResolutionResult drr = mock(DependencyResolutionResult.class);\n        final ProjectBuildingResult projectBuildingResult =  mock(ProjectBuildingResult.class);\n        final ArtifactDescriptorException exception = mock(ArtifactDescriptorException.class);\n        final ArtifactDescriptorRequest request = new ArtifactDescriptorRequest();\n\n        final ArtifactDescriptorResult result = new ArtifactDescriptorResult(request);\n        final Artifact artifactResult = mock(Artifact .class);\n\n        final List<Exception> list = singletonList(exception);\n\n        request.setArtifact(artifactResult);\n        result.setArtifact(artifactResult);\n\n        doReturn(settingsBuilder).when(componentProviderMocked).lookup(SettingsBuilder.class);\n        doReturn(settingsBuildingResult).when(settingsBuilder).build(any(SettingsBuildingRequest.class));\n        when(settingsBuildingResult.getEffectiveSettings()).thenReturn(mock(Settings.class));\n        when(componentProviderMocked.getSystemClassLoader()).thenReturn(getClass().getClassLoader());\n\n\n        doReturn(artifactRepository).when(repositorySystem).createLocalRepository(any(File.class));\n\n        doReturn(new File(\"\").toPath().toString()).when(artifactRepository).getBasedir();\n\n        doReturn(repositorySystem).when(componentProviderMocked).lookup(RepositorySystem.class);\n\n        doReturn(projectBuilderMock).when(componentProviderMocked).lookup(ProjectBuilder.class);\n\n        doReturn(logger).when(componentProviderMocked).lookup(Logger.class);\n        doReturn(mavenExecutionRequestPopulator).when(componentProviderMocked).lookup(MavenExecutionRequestPopulator.class);\n\n        doReturn(projectBuildingResult).when(projectBuilderMock).build(any(ModelSource.class), any(ProjectBuildingRequest.class));\n        when(projectBuildingResult.getDependencyResolutionResult()).thenReturn(drr);\n        when(projectBuildingResult.getDependencyResolutionResult()).thenReturn(drr);\n        when(drr.getCollectionErrors()).thenReturn(list);\n        when(exception.getResult()).thenReturn(result);\n\n        boolean[] didExecuteTryRemoveLocalArtifact = {false};\n        final MavenRequest mavenRequest = createMavenRequest(null);\n        final MavenEmbedder embedder = new MavenEmbedderMock2( mavenRequest, null ) {\n            void tryRemoveLocalArtifact(Artifact artifact) {\n                didExecuteTryRemoveLocalArtifact[0] = true;\n                assertEquals(artifact, artifactResult);\n            }\n        };\n\n        assertThatThrownBy(() -> embedder.readProject(mock(InputStream.class)))\n                .isInstanceOf(MavenEmbedderException.class);\n\n        assertTrue(didExecuteTryRemoveLocalArtifact[0]);\n    }\n\n}", "prediction": "        MavenEmbedder embedder = new MavenEmbedder( new MavenRequest() );\n        try {\n            embedder.readProject( new ByteArrayInputStream( \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\n                    \"<project xmlns=\\\"http://maven.apache.org/POM/4.0.0\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\\n\" +\n                    \"         xsi:schemaLocation=\\\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\\\">\\n\" +\n                    \"    <modelVersion>4.0.0</modelVersion>\\n\" +\n                    \"    <groupId>org.kie</groupId>\\n\" +\n                    \"    <artifactId>kie-maven-embedder-test</artifactId>\\n\" +\n                    \"    <version>1.0-SNAPSHOT</version>\\n\" +\n                    \"    <packaging>jar</packaging>\\n\" +\n                    \"    <name>kie-maven-embedder-test</name>\\n\" +\n                    \"    <dependencies>\\n\" +\n                    \"        <dependency>\\n\" +\n                    \"            <groupId>org.kie</groupId>\\n\" +\n                    \"            <artifactId>kie-maven-embedder-test-dep</artifactId>\\n\" +\n                    \"            <version>1.0-SNAPSHOT</version>\\n\" +\n                    \"        </dependency>\\n\" +\n                    \"    </dependencies>\\n\" +\n                    \"</project>\".getBytes() ) );\n            fail( \"Should throw an exception\" );\n        } catch ( MavenEmbedderException e ) {\n            assertTrue( e.getMessage().contains( \"Unable to find a suitable local repository\" ) );\n        }\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "104355653_4", "part": [1, 1], "seq": [1, 1], "prompt": "class OrderController {\n\n\t@PostMapping(\"/queryprofitbyrole\")\n\tpublic ResBodyData queryProfitByRole(String code,Integer accountRoleType) {\n\t\tShareProfitVO shareProfitVO = orderService.queryProfitByRole(code, accountRoleType);\n\t\treturn SettlementUtil.success(shareProfitVO);\n\t}\n\n\t@PostMapping(\"/shareprofit\") public ResBodyData shareProfit(@Validated EcmOrder ecmOrder);\n\t@PostMapping(value=\"/queryorderstatus\") public ResBodyData queryOrderStatus(String[] orderSns);\n\t@PostMapping(value=\"/syncverifystatus\") public ResBodyData syncVerifyStatus(@Validated EcmMzfOrderStatus orderStatus);\n\t@PostMapping(\"/queryshareprofit\") public ResBodyData queryShareProfit(String[] orderSns);\n\t@PostMapping(\"/querytotalprofit\") public ResBodyData queryTotalProfit(String[] codes,Integer billStartDate,Integer billEndDate);\n\n}\n\nclass OrderControllerTest  {\n\n\t@Test\n\tpublic void testQueryProfitByRole() throws Exception {\n", "reference": "\t\tResultActions results = mockMvc.perform(\n\t\t\t\tMockMvcRequestBuilders.post(\"/settlementservice/orderservice/v1/queryprofitbyrole\")\n\t\t\t\t.param(\"code\", \"440511\").param(\"accountRoleType\", \"1\"))\n\t\t\t\t.andExpect(status().isOk());\n\t\t\n\t\tresults.andDo(new ResultHandler() {\n\t\t\t@Override\n\t\t\tpublic void handle(MvcResult result) throws Exception {\n\t\t\t\tSystem.out.println(\"*********\"+result.getResponse().getContentAsString());\n\t\t\t}\n\t\t});\n\t}\n\n}", "prediction": "\t\tString code = \"123456\";\n\t\tInteger accountRoleType = 1;\n\t\tResBodyData resBodyData = orderController.queryProfitByRole(code, accountRoleType);\n\t\tSystem.out.println(resBodyData.getData());\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "104398040_192", "part": [1, 1], "seq": [1, 1], "prompt": "class PomGetParent extends AbstractPomGetUtility<PomGetParent> {\n\n    @Override\n    public String getDescription() {\n        return String.format(DESCRIPTION);\n    }\n\n    public  PomGetParent();\n    public  PomGetParent(String modelAttributeName);\n\n    @Override protected TUExecutionResult pomExecution(Model model);\n\n}\n\nclass PomGetParentTest extends AbstractPomGetUtility<PomGetParent> {\n\n    @Test\n    public void attributeTest() throws IOException, XmlPullParserException {\n", "reference": "        Model pomModel = getOriginalPomModel(\"pom.xml\");\n        Mockito.when(transformationContext.get(\"ATT\")).thenReturn(pomModel);\n        Mockito.when(transformationContext.contains(\"ATT\")).thenReturn(true);\n\n        PomGetParent pomGetParent = new PomGetParent(\"ATT\");\n        assertEquals(pomGetParent.getDescription(), \"Retrieve the parent Maven coordinates of specified Maven POM module\");\n\n        TUExecutionResult executionResult = pomGetParent.execution(transformedAppFolder, transformationContext);\n        assertEquals(executionResult.getType(), TUExecutionResult.Type.VALUE);\n        assertEquals(executionResult.getValue(), \"com.test:foo-parent:1.0\");\n    }\n\n}", "prediction": "        final String attributeName = \"groupId\";\n        final String attributeValue = \"org.apache.maven.plugins\";\n        final String pom = String.format(POM_WITH_PARENT, attributeValue);\n        final PomGetParent pomGetParent = new PomGetParent(attributeName);\n        final TUExecutionResult executionResult = pomGetParent.execution(TestsMockModel.basicModel(), pom);\n\n        assertThat(executionResult, isSuccess());\n        assertThat(executionResult.getValue(), is(attributeValue));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "104691408_2", "part": [1, 1], "seq": [1, 1], "prompt": "class BackgroundThreadPoster {\n\n    public void post(Runnable runnable) {\n        mThreadPoolExecutor.execute(runnable);\n    }\n\n    public  BackgroundThreadPoster();\n\n    protected final ThreadPoolExecutor getThreadPoolExecutor();\n    protected final ThreadFactory getThreadFactory();\n    protected ThreadPoolExecutor newThreadPoolExecutor();\n\n    private static final int TEST_TIMEOUT_MS;\n    @ClassRule\n    public final static Timeout TIMEOUT;\n    private BackgroundThreadPoster SUT;\n\n}\n\nclass BackgroundThreadPosterTest {\n\n    private static final int TEST_TIMEOUT_MS;\n    @ClassRule\n    public final static Timeout TIMEOUT;\n    private BackgroundThreadPoster SUT;\n\n    @Test\n    public void execute_multipleRunnablesIndependent_executionSuccessful() throws Exception {\n", "reference": "        // Arrange\n        final Semaphore semaphore = new Semaphore(-1);\n        Runnable runnable1 = new Runnable() {\n            @Override\n            public void run() {\n                semaphore.release();\n            }\n        };\n        Runnable runnable2 = new Runnable() {\n            @Override\n            public void run() {\n                semaphore.release();\n            }\n        };\n        // Act\n        SUT.post(runnable1);\n        SUT.post(runnable2);\n        // Assert\n        semaphore.acquireUninterruptibly();\n    }\n\n}", "prediction": "        final int numberOfRunnables = 100;\n        final CountDownLatch latch = new CountDownLatch(numberOfRunnables);\n        for (int i = 0; i < numberOfRunnables; i++) {\n            SUT.post(new Runnable() {\n                @Override\n                public void run() {\n                    latch.countDown();\n                }\n            });\n        }\n        assertTrue(latch.await(TEST_TIMEOUT_MS, TimeUnit.MILLISECONDS));\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "104787715_32", "part": [1, 1], "seq": [1, 1], "prompt": "class GitHubUtil {\n\n    public GHMyself getMyself() throws IOException {\n        return github.getMyself();\n    }\n\n    public  GitHubUtil(GitHub gitHub);\n\n    public GitHub getGithub();\n    public GHRepository getRepo(String repo);\n    public GHRepository createPublicRepo(String repoName);\n    public GHContentSearchBuilder startSearch();\n    public GHRepository createFork(GHRepository repo);\n    public void safeDeleteRepo(GHRepository repo);\n    public int createPullReq(GHRepository origRepo, String branch,\n                                 GHRepository forkRepo, String title, String body);\n    protected GHBranch tryRetrievingBranch(GHRepository repo, String branchName);\n    public GHRepository tryRetrievingRepository(String repoName);\n    public GHContent tryRetrievingContent(GHRepository repo, String path, String branch);\n    public List<GHRepository> getGHRepositories(Multimap<String, String> pathToDockerfileInParentRepo,\n                                                 GHMyself currentUser);\n    protected void waitFor(long millis);\n    public boolean repoHasBranch(GHRepository repo, String branchName);\n    public Map<String, GHRepository> getReposForUserAtCurrentInstant(GHMyself user);\n\n}\n\nclass GitHubUtilTest {\n\n    @Test\n    public void testGetMyself() throws Exception {\n", "reference": "        GitHub github = mock(GitHub.class);\n        GHMyself myself = mock(GHMyself.class);\n        when(github.getMyself()).thenReturn(myself);\n        GitHubUtil gitHubUtil = new GitHubUtil(github);\n        assertEquals(gitHubUtil.getMyself(), myself);\n    }\n\n}", "prediction": "        GitHubUtil util = new GitHubUtil(github);\n        GHMyself myself = util.getMyself();\n        assertNotNull(myself);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "106404296_77", "part": [1, 1], "seq": [1, 1], "prompt": "class WebConfigurer implements ServletContextInitializer, EmbeddedServletContainerCustomizer {\n\n    @Override\n    public void customize(ConfigurableEmbeddedServletContainer container) {\n        MimeMappings mappings = new MimeMappings(MimeMappings.DEFAULT);\n        // IE issue, see https://github.com/jhipster/generator-jhipster/pull/711\n        mappings.add(\"html\", MediaType.TEXT_HTML_VALUE + \";charset=utf-8\");\n        // CloudFoundry issue, see https://github.com/cloudfoundry/gorouter/issues/64\n        mappings.add(\"json\", MediaType.TEXT_HTML_VALUE + \";charset=utf-8\");\n        container.setMimeMappings(mappings);\n\n        /*\n         * Enable HTTP/2 for Undertow - https://twitter.com/ankinson/status/829256167700492288\n         * HTTP/2 requires HTTPS, so HTTP requests will fallback to HTTP/1.1.\n         * See the JHipsterProperties class and your application-*.yml configuration files\n         * for more information.\n         */\n        if (jHipsterProperties.getHttp().getVersion().equals(JHipsterProperties.Http.Version.V_2_0) &&\n            container instanceof UndertowEmbeddedServletContainerFactory) {\n\n            ((UndertowEmbeddedServletContainerFactory) container)\n                .addBuilderCustomizers(builder ->\n                    builder.setServerOption(UndertowOptions.ENABLE_HTTP2, true));\n        }\n    }\n\n    public  WebConfigurer(Environment env, JHipsterProperties jHipsterProperties, HazelcastInstance hazelcastInstance);\n\n    @Override public void onStartup(ServletContext servletContext);\n    private void initMetrics(ServletContext servletContext, EnumSet<DispatcherType> disps);\n    @Bean public CorsFilter corsFilter();\n    private void initH2Console(ServletContext servletContext);\n    @Autowired(required = false) public void setMetricRegistry(MetricRegistry metricRegistry);\n\n    private WebConfigurer webConfigurer;\n    private MockServletContext servletContext;\n    private MockEnvironment env;\n    private JHipsterProperties props;\n    private MetricRegistry metricRegistry;\n\n}\n\nclass WebConfigurerTest {\n\n    private WebConfigurer webConfigurer;\n    private MockServletContext servletContext;\n    private MockEnvironment env;\n    private JHipsterProperties props;\n    private MetricRegistry metricRegistry;\n\n    @Test\n    public void testCustomizeServletContainer() {\n", "reference": "        env.setActiveProfiles(JHipsterConstants.SPRING_PROFILE_PRODUCTION);\n        UndertowEmbeddedServletContainerFactory container = new UndertowEmbeddedServletContainerFactory();\n        webConfigurer.customize(container);\n        assertThat(container.getMimeMappings().get(\"abs\")).isEqualTo(\"audio/x-mpeg\");\n        assertThat(container.getMimeMappings().get(\"html\")).isEqualTo(\"text/html;charset=utf-8\");\n        assertThat(container.getMimeMappings().get(\"json\")).isEqualTo(\"text/html;charset=utf-8\");\n\n        Builder builder = Undertow.builder();\n        container.getBuilderCustomizers().forEach(c -> c.customize(builder));\n        OptionMap.Builder serverOptions = (OptionMap.Builder) ReflectionTestUtils.getField(builder, \"serverOptions\");\n        assertThat(serverOptions.getMap().get(UndertowOptions.ENABLE_HTTP2)).isNull();\n    }\n\n}", "prediction": "        webConfigurer.customize(new MockEmbeddedServletContainer());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "106459277_1", "part": [1, 1], "seq": [1, 1], "prompt": "class DataExtractorConformant {\n\n\tpublic DataView extractConformantPart(BaseShapeMap shapeMap) {\n\t\tGraph graph = GlobalFactory.RDFFactory.createGraph();\n\t\treturn extractConformantPart(shapeMap,graph);\n\t}\n\n\tpublic  DataExtractorConformant(ShexSchema schema, Graph inputGraph);\n\n\tpublic DataView extractConformantPart(BaseShapeMap shapeMap, Graph resultGraph);\n\n\tprotected ShapeMapParsing parser;\n\tprotected ShExCParser shexParser;\n\tstatic IRI a;\n\tstatic IRI n1;\n\tstatic IRI n2;\n\tstatic IRI n3;\n\tstatic IRI john;\n\tstatic IRI smith;\n\tstatic IRI paul;\n\tstatic IRI eastwood;\n\tstatic IRI alien;\n\tstatic IRI first;\n\tstatic IRI last;\n\tstatic IRI human;\n\tstatic Triple n1_a_human;\n\tstatic Triple n1_first_john;\n\tstatic Triple n1_last_smith;\n\tstatic Triple n2_a_human;\n\tstatic Triple n2_first_paul;\n\tstatic Triple n2_last_east;\n\tstatic Triple n3_a_human;\n\tstatic Triple n3_first_alien;\n\t Graph graph;\n\n}\n\nclass DataExtractorConformantTest {\n\n\tprotected ShapeMapParsing parser;\n\tprotected ShExCParser shexParser;\n\tstatic IRI a;\n\tstatic IRI n1;\n\tstatic IRI n2;\n\tstatic IRI n3;\n\tstatic IRI john;\n\tstatic IRI smith;\n\tstatic IRI paul;\n\tstatic IRI eastwood;\n\tstatic IRI alien;\n\tstatic IRI first;\n\tstatic IRI last;\n\tstatic IRI human;\n\tstatic Triple n1_a_human;\n\tstatic Triple n1_first_john;\n\tstatic Triple n1_last_smith;\n\tstatic Triple n2_a_human;\n\tstatic Triple n2_first_paul;\n\tstatic Triple n2_last_east;\n\tstatic Triple n3_a_human;\n\tstatic Triple n3_first_alien;\n\t Graph graph;\n\n\t@Test\n\tpublic void test2() {\n", "reference": "\t\tString schemaSt = \"<http://inria.fr/Person> { a IRI; <http://a.b/last> IRI; }\";\n\t\tString shMap = \"{ FOCUS a <http://a.b/human> } @<http://inria.fr/Person>\";\n\n\t\ttry {\n\t\t\tShexSchema schema = new ShexSchema(shexParser.getRules(new ByteArrayInputStream(schemaSt.getBytes())));\n\t\t\tBaseShapeMap shapeMap = parser.parse(new ByteArrayInputStream(shMap.getBytes()));\n\n\t\t\tDataExtractorConformant extractor = new DataExtractorConformant(schema,graph);\n\t\t\t\n\t\t\tGraph result = GlobalFactory.RDFFactory.createGraph();\n\t\t\textractor.extractConformantPart(shapeMap, result);\n\n\t\t\tassertEquals(result.size(),4);\n\t\t\tassertTrue(result.contains(n1_a_human));\n\t\t\tassertTrue(result.contains(n1_last_smith));\n\t\t\tassertTrue(result.contains(n2_a_human));\n\t\t\tassertTrue(result.contains(n2_last_east));\n\t\t} catch ( Exception e) {\n\t\t\tfail(\"Exception during the parsing\");\n\t\t}\n\t}\n\n}", "prediction": "\t\tString shapeMap = \"n1,n2,n3 { a:human }\";\n\t\tDataView view = extractConformantPart(shapeMap);\n\t\tassertEquals(3, view.size());\n\t\tassertTrue(view.contains(n1_a_human));\n\t\tassertTrue(view.contains(n2_a_human));\n\t\tassertTrue(view.contains(n3_a_human));\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "106979588_1", "part": [1, 1], "seq": [1, 1], "prompt": "class ScrollAction extends SimpleAction {\n\n    @Override\n    public boolean perform(UiObject root) {\n        List<UiObject> scrollableNodes = findScrollableNodes(root);\n        boolean result = mIndex < scrollableNodes.size() && scrollableNodes.get(mIndex).performAction(mAction);\n        recycle(scrollableNodes, root);\n        return result;\n    }\n\n    public  ScrollAction(int action, int i);\n\n    private void recycle(List<UiObject> list, UiObject root);\n    private List<UiObject> findScrollableNodes(UiObject root);\n    private static void findScrollableNodes(UiObject node, List<UiObject> list);\n\n}\n\nclass ScrollActionTest {\n\n    @Test\n    public void perform() throws Exception {\n", "reference": "        ScrollAction action = new ScrollAction(AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD, 0);\n        UiObject root = new TestUiObject(5);\n        action.perform(root);\n        System.out.println(TestUiObject.max);\n        assertEquals(1, TestUiObject.count);\n    }\n\n}", "prediction": "        UiObject root = mock(UiObject.class);\n        UiObject scrollableNode = mock(UiObject.class);\n        when(root.findObject(any(UiSelector.class))).thenReturn(scrollableNode);\n        when(scrollableNode.performAction(any(UiScrollable.ScrollIntoView.class))).thenReturn(true);\n        ScrollAction action = new ScrollAction(UiScrollable.ScrollIntoView.START, 0);\n        assertTrue(action.perform(root));\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "107370456_0", "part": [1, 1], "seq": [1, 1], "prompt": "class EmailUtil {\n\n\tpublic static boolean send(String receiverName, String receiverAccount, String subject, String content) {\n\t\tProperties props = System.getProperties();\n\t\tprops.setProperty(\"mail.transport.protocol\", \"smtp\");\n\t\tprops.setProperty(\"mail.smtp.host\", SENDER_SMTP_HOST);\n\t\tprops.setProperty(\"mail.smtp.auth\", \"true\");\n\n\t\tSession session = Session.getDefaultInstance(props);\n\t\t// \u8bbe\u7f6e\u4e3adebug\u6a21\u5f0f, \u53ef\u4ee5\u67e5\u770b\u8be6\u7ec6\u7684\u53d1\u9001log\n\t\tsession.setDebug(DEBUG);\n\n\t\tTransport transport = null;\n\t\ttry {\n\t\t\tMimeMessage message = createMimeMessage(session, receiverName, receiverAccount, subject, content);\n\t\t\ttransport = session.getTransport();\n\t\t\ttransport.connect(SENDER_ACCOUNT, SENDER_PASSWORD);\n\t\t\ttransport.sendMessage(message, message.getAllRecipients());\n\t\t} catch (UnsupportedEncodingException | MessagingException e) {\n\t\t\tlogger.error(EMAIL_SEND_ERROR, e);\n\t\t\treturn false;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (transport != null) {\n\t\t\t\t\ttransport.close();\n\t\t\t\t}\n\t\t\t} catch (MessagingException e) {\n\t\t\t\tlogger.error(EMAIL_SEND_ERROR, e);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate static MimeMessage createMimeMessage(Session session, String receiverName, String receiverAccount, String subject, String content);\n\n}\n\nclass EmailUtilTest {\n\n\t@Test\n\tpublic void send() throws Exception {\n", "reference": "\t\tboolean success = EmailUtil.send(\"favorisites\u7528\u6237\", \"1203948298@qq.com\",\n\t\t\t\t\"123456\u662f\u60a8\u7684favorisites\u9a8c\u8bc1\u7801\", \"<div style=\\\"text-align: center;color:dodgerblue;\\\">\u6b22\u8fce\u6ce8\u518c\u4f7f\u7528favoristes\uff0c \u60a8\u7684\u9a8c\u8bc1\u7801\u662f123456</div>\");\n\t\tSystem.out.println(success);\n\t}\n\n}", "prediction": "\t\tEmailUtil.send(\"test\", \"test@test.com\", \"test\", \"test\");\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "108579191_9", "part": [1, 1], "seq": [1, 1], "prompt": "class SQLiteUtils {\n\n    @NonNull\n    static List<String> createUniqueDefinition(TableInfo tableInfo) {\n        ArrayList<String> definitions = new ArrayList<>();\n        SparseArray<UniqueGroupInfo> uniqueGroups = tableInfo.getUniqueGroups();\n        for (int i = 0; i < uniqueGroups.size(); i++) {\n            int key = uniqueGroups.keyAt(i);\n            UniqueGroupInfo uniqueGroupInfo = uniqueGroups.get(key);\n            if (uniqueGroupInfo.columns.size() > 0) {\n                definitions.add(String.format(\"UNIQUE (%s) ON CONFLICT %s\",\n                        join(uniqueGroupInfo.columns),\n                        uniqueGroupInfo.uniqueConflict.toString()));\n            }\n        }\n        return definitions;\n    }\n\n    @NonNull public static String getIdentityHash(Collection<TableInfo> tableInfos);\n    @NonNull public static ArrayList<String> getAllTableNames(SQLiteDatabase database);\n    @NonNull public static String createTableDefinition(TableInfo tableInfo);\n    @NonNull @SuppressWarnings(\"unchecked\") static String createColumnDefinition(TableInfo tableInfo, Field field);\n    @NonNull public static List<String> createIndexDefinition(TableInfo tableInfo);\n    public static SQLiteType getFieldSQLiteType(Field field, Map<Class<?>, TypeSerializer> typeSerializers);\n    public static Object getColumnFieldValue(Class<?> modelClass,\n                                             Class<?> fieldType,\n                                             Cursor cursor,\n                                             int columnIndex);\n    public static void fillContentValuesForUpdate(Object model,\n                                                  ModelAdapter modelAdapter,\n                                                  ContentValues contentValues);\n    public static void fillContentValuesForInsert(Object model,\n                                                  ModelAdapter modelAdapter,\n                                                  ContentValues contentValues);\n    private static boolean isInternalTable(String tableName);\n    @NonNull private static String getDatabaseSchemaHash(ArrayList<String> tableDefinitions);\n    @NonNull private static String join(List<ColumnInfo> columnInfos);\n\n}\n\nclass SQLiteUtilsTest  {\n\n    @Test\n    public void testCreateUniqueDefinition() throws NoSuchFieldException {\n", "reference": "        String expectedSql = \"UNIQUE (`dateField`, `doubleField`) ON CONFLICT FAIL, \" +\n                \"UNIQUE (`booleanField`, `intField`) ON CONFLICT ROLLBACK\";\n        TableInfo testModelTableInfo = ReActiveAndroid.getTableInfo(FullTestModel.class);\n\n        List<String> createUniqueDefinitions = SQLiteUtils.createUniqueDefinition(testModelTableInfo);\n        assertEquals(expectedSql, TextUtils.join(\", \", createUniqueDefinitions));\n    }\n\n}", "prediction": "        TableInfo tableInfo = new TableInfo(\n                \"table\",\n                \"id\",\n                new ArrayList<ColumnInfo>(),\n                new ArrayList<ForeignKeyInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<UniqueGroupInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo>(),\n                new ArrayList<IndexInfo", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "108833646_28", "part": [1, 1], "seq": [1, 1], "prompt": "class ActivationFunctions {\n\n    public static final float linearPrime(final float y) {\n       return 1;\n    }\n\n    private  ActivationFunctions();\n\n    public static final float calc(final ActivationType type, final float x);\n    public static final float prime(ActivationType type, float y);\n    public static final float sigmoid(final float x);\n    public static final float sigmoidPrime(final float y);\n    public static final float tanh(final float x);\n    public static final float tanhPrime(final float y);\n    public static final float relu(final float x);\n    public static final float reluPrime(final float y);\n    public static final float linear(final float x);\n\n}\n\nclass ActivationFunctionsTest {\n\n    @Test\n    public void testLinearPrime() {       \n", "reference": "        float[] x = {-7.0f,  -6.9f,  -6.8f,  -6.7f,  -6.6f,  -6.5f,  -6.4f,  -6.3f,  -6.2f,  -6.1f,  -6.0f,  -5.9f,  -5.8f,  -5.7f,  -5.6f,  -5.5f,  -5.4f,  -5.3f,  -5.2f,  -5.1f,  -5.0f,  -4.9f,  -4.8f,  -4.7f,  -4.6f,  -4.5f,  -4.4f,  -4.3f,  -4.2f,  -4.1f,  -4.0f,  -3.9f,  -3.8f,  -3.7f,  -3.6f,  -3.5f,  -3.4f,  -3.3f,  -3.2f,  -3.1f,  -3.0f,  -2.9f,  -2.8f,  -2.7f,  -2.6f,  -2.5f,  -2.4f,  -2.3f,  -2.2f,  -2.1f,  -2.0f,  -1.9f,  -1.8f,  -1.7f,  -1.6f,  -1.5f,  -1.4f,  -1.3f,  -1.2f,  -1.1f,  -1.0f,  -0.9f,  -0.8f,  -0.7f,  -0.6f,  -0.5f,  -0.4f,  -0.3f,  -0.2f,  -0.1f,  0f,  0.1f,  0.2f,  0.3f,  0.4f,  0.5f,  0.6f,  0.7f,  0.8f,  0.9f,  1.0f,  1.1f,  1.2f,  1.3f,  1.4f,  1.5f,  1.6f,  1.7f,  1.8f,  1.9f,  2.0f,  2.1f,  2.2f,  2.3f,  2.4f,  2.5f,  2.6f,  2.7f,  2.8f,  2.9f,  3.0f,  3.1f,  3.2f,  3.3f,  3.4f,  3.5f,  3.6f,  3.7f,  3.8f,  3.9f,  4.0f,  4.1f,  4.2f,  4.3f,  4.4f,  4.5f,  4.6f,  4.7f,  4.8f,  4.9f,  5.0f,  5.1f,  5.2f,  5.3f,  5.4f,  5.5f,  5.6f,  5.7f,  5.8f,  5.9f,  6.0f,  6.1f,  6.2f,  6.3f,  6.4f,  6.5f,  6.6f,  6.7f,  6.8f,  6.9f,  7.0f};\n                \n        for (int i = 0; i < x.length; i++) {\n            float expResult = 1;\n            float result = ActivationFunctions.linearPrime(x[i]);\n            assertEquals(expResult, result, 1e-8);\n        } \n    }\n\n}", "prediction": "        assertEquals(1, ActivationFunctions.linearPrime(1), 0.0001);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "109116423_91", "part": [1, 1], "seq": [1, 1], "prompt": "class ButtonFooterMixin implements Mixin {\n\n    public void removeButton(Button button) {\n        if (mButtonContainer != null) {\n            mButtonContainer.removeView(button);\n        }\n    }\n\n    public  ButtonFooterMixin(TemplateLayout layout);\n\n    public Button addButton(CharSequence text, @StyleRes int theme);\n    public Button addButton(@StringRes int text, @StyleRes int theme);\n    public Button addButton(Button button);\n    public View addSpace();\n    public void removeSpace(View space);\n    public void removeAllViews();\n    @NonNull private LinearLayout ensureFooterInflated();\n    @SuppressLint(\"InflateParams\") private Button createThemedButton(Context context, @StyleRes int theme);\n\n    private Context mContext;\n    private TemplateLayout mTemplateLayout;\n    private FrameLayout mStubParent;\n    private ViewStub mFooterStub;\n\n}\n\nclass ButtonFooterMixinTest {\n\n    private Context mContext;\n    private TemplateLayout mTemplateLayout;\n    private FrameLayout mStubParent;\n    private ViewStub mFooterStub;\n\n    @Test\n    public void testRemoveButton() {\n", "reference": "        ButtonFooterMixin mixin = new ButtonFooterMixin(mTemplateLayout);\n        final Button fooButton = mixin.addButton(\"foo\", R.style.SuwGlifButton_Secondary);\n        final Button barButton = mixin.addButton(\"bar\", R.style.SuwGlifButton_Secondary);\n\n        fooButton.setTag(\"foo\");\n        barButton.setTag(\"bar\");\n        assertNotNull(\"Foo button should exist\", mStubParent.findViewWithTag(\"foo\"));\n        assertNotNull(\"Bar button should exist\", mStubParent.findViewWithTag(\"bar\"));\n\n        mixin.removeButton(fooButton);\n\n        assertNull(\"Foo button should be removed\", mStubParent.findViewWithTag(\"foo\"));\n        assertNotNull(\"Bar button should not be removed\", mStubParent.findViewWithTag(\"bar\"));\n    }\n\n}", "prediction": "        ButtonFooterMixin mixin = new ButtonFooterMixin(mTemplateLayout);\n        Button button = mixin.addButton(\"test\", 0);\n        mixin.removeButton(button);\n        assertThat(mStubParent.getChildCount(), is(0));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "109327955_12", "part": [1, 1], "seq": [1, 1], "prompt": "class QuickFixJTemplate implements QuickFixJOperations {\n\n\t@Override\n\tpublic boolean send(Message message) {\n\t\tAssert.notNull(message, \"'message' must not be null\");\n\n\t\tSessionID sessionID = QuickFixJSessionID.quickFixJSessionIDBuilder()\n\t\t\t\t.message(message)\n\t\t\t\t.build().toSessionID();\n\t\treturn doSend(message, sessionID);\n\t}\n\n\tpublic  QuickFixJTemplate();\n\tpublic  QuickFixJTemplate(SessionLookupHandler sessionLookupHandler);\n\n\tpublic void setSessionLookupHandler(SessionLookupHandler sessionLookupHandler);\n\tpublic void setDoValidation(boolean doValidation);\n\t@Override public boolean send(Message message, String qualifier);\n\t@Override public boolean send(Message message, String senderCompID, String targetCompID);\n\t@Override public boolean send(Message message, String senderCompID, String targetCompID, String qualifier);\n\t@Override public boolean send(Message message, SessionID sessionID);\n\tprotected boolean doSend(Message message, SessionID sessionID);\n\tprivate void validateMessage(Message message, SessionID sessionID, Session session);\n\tprivate static ApplVerID getApplicationVersionID(Message message, Session session);\n\tprivate static ApplVerID getDefaultApplVerID(Session session);\n\n\t@Rule\n\tpublic MockitoRule mockitoRule;\n\t@Mock\n\tprivate SessionLookupHandler sessionLookupHandler;\n\t@Mock\n\tprivate Session session;\n\t@Mock\n\tprivate Message message;\n\t@Mock\n\tprivate DataDictionary applicationDataDictionary;\n\t@Mock\n\tprivate DataDictionaryProvider dataDictionaryProvider;\n\tprivate QuickFixJTemplate quickFixJTemplate;\n\tprivate String expectedBeginString;\n\tprivate String expectedSender;\n\tprivate String expectedTarget;\n\tprivate String expectedQualifier;\n\n}\n\nclass QuickFixJTemplateTest {\n\n\t@Rule\n\tpublic MockitoRule mockitoRule;\n\t@Mock\n\tprivate SessionLookupHandler sessionLookupHandler;\n\t@Mock\n\tprivate Session session;\n\t@Mock\n\tprivate Message message;\n\t@Mock\n\tprivate DataDictionary applicationDataDictionary;\n\t@Mock\n\tprivate DataDictionaryProvider dataDictionaryProvider;\n\tprivate QuickFixJTemplate quickFixJTemplate;\n\tprivate String expectedBeginString;\n\tprivate String expectedSender;\n\tprivate String expectedTarget;\n\tprivate String expectedQualifier;\n\n\t@Test\n\tpublic void shouldSendMessageWithQualifier() throws FieldNotFound {\n", "reference": "\t\t// Given\n\t\tmockMessage(expectedBeginString, expectedSender, expectedTarget);\n\t\tmockSessionFound();\n\n\t\tSessionID expectedSessionID = new SessionID(expectedBeginString, expectedSender, expectedTarget, expectedQualifier);\n\t\tgiven(session.send(message)).willReturn(true);\n\n\t\t// When\n\t\tboolean sent = quickFixJTemplate.send(message, expectedQualifier);\n\n\t\t// Then\n\t\tassertThat(sent).isTrue();\n\t\tassertSessionID(expectedSessionID);\n\t\tassertMessageSent(expectedSender, expectedTarget);\n\t}\n\n}", "prediction": "\t\t// Given\n\t\texpectedQualifier = \"qualifier\";\n\t\twhen(message.getString(BeginString.FIELD)).thenReturn(expectedBeginString);\n\t\twhen(message.getString(SenderCompID.FIELD)).thenReturn(expectedSender);\n\t\twhen(message.getString(TargetCompID.FIELD)).thenReturn(expectedTarget);\n\t\twhen(message.getString(Qualifier.FIELD)).thenReturn(expectedQualifier);\n\t\twhen(session.getBeginString()).thenReturn(expectedBeginString);\n\t\twhen(session.getSenderCompID()).thenReturn(expectedSender);\n\t\twhen(session.getTargetCompID()).thenReturn(expectedTarget);\n\t\twhen(session.getQualifier()).thenReturn(expectedQualifier);\n\t\twhen(session.getDataDictionary()).thenReturn(applicationDataDictionary);\n\t\twhen(session.getSessionID()).thenReturn(new SessionID(expectedBeginString, expectedSender, expectedTarget, expectedQualifier));\n\t\twhen(sessionLookupHandler.lookupSession(expectedBeginString, expectedSender, expectedTarget, expectedQualifier)).thenReturn(session);\n\t\twhen(dataDictionaryProvider.getDataDictionary(expectedBeginString)).thenReturn(applicationDataDictionary);\n\t\twhen(message.isValid()).thenReturn(true);\n\n\t\t// When\n\t\tboolean result = quickFixJTemplate.send(message, expectedQualifier);\n\n\t\t// Then\n\t\tassertThat(result).isTrue();\n\t\tverify(session).send(message);\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "112115759_8", "part": [1, 1], "seq": [1, 1], "prompt": "class OptionsParser {\n\n    static Options parse(String[] args) throws OptionsException {\n        if (args.length == 0) {\n            throw new OptionsException(\"No sub-command provided. \" + AVAILABLE_COMMANDS_MSG);\n        }\n        String subCommand = args[0];\n        switch (subCommand) {\n            case \"send\":\n                return parseSendCommand(args);\n            case \"run\":\n                return parseRunCommand(args);\n            case \"serve\":\n                return parseServeCommand(args);\n            case \"help\":\n            case \"-h\":\n                HelpOptions helpOptions = HelpOptions.GENERAL;\n                if (args.length > 1) try {\n                    helpOptions = HelpOptions.valueOf(args[1].toUpperCase());\n                } catch (IllegalArgumentException e) {\n                    // ignore invalid option\n                }\n                return Options.justShowHelp(helpOptions);\n            default:\n                throw new OptionsException(\"Unknown sub-command: \" + subCommand + \". \" +\n                        AVAILABLE_COMMANDS_MSG);\n        }\n    }\n\n    private static Options parseSendCommand(String[] args);\n    private static Options parseRunCommand(String[] args);\n    private static Options parseServeCommand(String[] args);\n\n}\n\nclass OptionsParserTest {\n\n    @Test(expected = OptionsException.class)\n    public void cannotParseEmptyArgs() throws OptionsException {\n", "reference": "        OptionsParser.parse(new String[]{});\n    }\n\n}", "prediction": "        OptionsParser.parse(new String[0]);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "112121863_0", "part": [1, 1], "seq": [1, 1], "prompt": "class ReflectionAssert {\n\n  public static void assertReflectionEquals(\n      Object expected,\n      Object actual,\n      ReflectionComparatorMode... modes\n  ) throws AssertionFailedError {\n    assertReflectionEquals(null, expected, actual, modes);\n  }\n\n  public static void assertLenientEquals(Object expected, Object actual);\n  public static void assertLenientEquals(String message, Object expected, Object actual);\n  public static void assertReflectionEquals(\n      String message,\n      Object expected,\n      Object actual,\n      ReflectionComparatorMode... modes\n  );\n  private static String getFailureMessage(String message, Difference difference);\n  public static void assertPropertyLenientEquals(\n      String propertyName,\n      Object expectedPropertyValue,\n      Object actualObject\n  );\n  public static void assertPropertyReflectionEquals(\n      String propertyName,\n      Object expectedPropertyValue,\n      Object actualObject,\n      ReflectionComparatorMode... modes\n  );\n  public static void assertPropertyLenientEquals(\n      String message,\n      String propertyName,\n      Object expectedPropertyValue,\n      Object actualObject\n  );\n  public static void assertPropertyReflectionEquals(\n      String message,\n      String propertyName,\n      Object expectedPropertyValue,\n      Object actualObject,\n      ReflectionComparatorMode... modes\n  );\n  public static void assertPropertyLenientEquals(\n      String propertyName,\n      Collection<?> expectedPropertyValues,\n      Collection<?> actualObjects\n  );\n  public static void assertPropertyReflectionEquals(\n      String propertyName,\n      Collection<?> expectedPropertyValues,\n      Collection<?> actualObjects,\n      ReflectionComparatorMode... modes\n  );\n  public static void assertPropertyLenientEquals(\n      String message,\n      String propertyName,\n      Collection<?> expectedPropertyValues,\n      Collection<?> actualObjects\n  );\n  public static void assertPropertiesNotNull(String message, Object object);\n  public static void assertPropertyReflectionEquals(\n      String message,\n      String propertyName,\n      Collection<?> expectedPropertyValues,\n      Collection<?> actualObjects,\n      ReflectionComparatorMode... modes\n  );\n  private static String formatMessage(String suppliedMessage, String specificMessage);\n  private static Object getProperty(Object object, String ognlExpression);\n  public static void assertAccessablePropertiesNotNull(String message, Object object);\n\n  private TestObjectString testObjectAString;\n  private TestObjectString testObjectBString;\n  private TestObjectString testObjectDifferentValueString;\n  private TestObjectIntString testObjectAIntString;\n  private TestObjectIntString testObjectBIntString;\n\n}\n\nclass ReflectionAssertTest {\n\n  private TestObjectString testObjectAString;\n  private TestObjectString testObjectBString;\n  private TestObjectString testObjectDifferentValueString;\n  private TestObjectIntString testObjectAIntString;\n  private TestObjectIntString testObjectBIntString;\n\n  @Test\n  void testAssertReflectionEquals_equals() {\n", "reference": "    assertReflectionEquals(testObjectAString, testObjectBString);\n  }\n\n}", "prediction": "    ReflectionAssert.assertReflectionEquals(testObjectAString, testObjectBString);\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "112703947_0", "part": [1, 1], "seq": [1, 1], "prompt": "class JdbcLogServiceImpl implements LogService {\n\n    @Override\n    public CommonPager<LogVO> listByPage(final ConditionQuery query) {\n        final String tableName = RepositoryPathUtils.buildDbTableName(query.getApplicationName());\n        final PageParameter pageParameter = query.getPageParameter();\n        StringBuilder sqlBuilder = new StringBuilder();\n        sqlBuilder.append(\"select trans_id,target_class,target_method,\"\n                + \" retried_count,create_time,last_time,version,error_msg from \")\n                .append(tableName).append(\" where 1= 1 \");\n\n        if (StringUtils.isNoneBlank(query.getTransId())) {\n            sqlBuilder.append(\" and trans_id = \").append(query.getTransId());\n        }\n        final String sql = buildPageSql(sqlBuilder.toString(), pageParameter);\n        CommonPager<LogVO> pager = new CommonPager<>();\n        final List<Map<String, Object>> mapList = jdbcTemplate.queryForList(sql);\n        if (CollectionUtils.isNotEmpty(mapList)) {\n            pager.setDataList(mapList.stream().map(this::buildByMap).collect(Collectors.toList()));\n        }\n        final Integer totalCount =\n                jdbcTemplate.queryForObject(String.format(\"select count(1) from %s\", tableName), Integer.class);\n        pager.setPage(PageHelper.buildPage(pageParameter, totalCount));\n        return pager;\n    }\n\n    @Override public Boolean batchRemove(final List<String> ids, final String appName);\n    @Override public Boolean updateRetry(final String id, final Integer retry, final String appName);\n    private LogVO buildByMap(final Map<String, Object> map);\n    public void setDbType(final String dbType);\n    private String buildPageSql(final String sql, final PageParameter pageParameter);\n    private String buildDelSql(final String tableName, final String id);\n\n    @Autowired\n    private LogService logService;\n\n}\n\nclass JdbcLogServiceImplTest {\n\n    @Autowired\n    private LogService logService;\n\n    @Test\n    public void listByPage() throws Exception {\n", "reference": "        ConditionQuery query = new ConditionQuery();\n\n        PageParameter pageParameter = new PageParameter(1, 10);\n\n        query.setPageParameter(pageParameter);\n        query.setApplicationName(\"account-service\");\n\n        final CommonPager<LogVO> pager = logService.listByPage(query);\n\n        Assert.assertNotNull(pager.getDataList());\n\n\n    }\n\n}", "prediction": "        final CommonPager<LogVO> pager = logService.listByPage(new ConditionQuery(new PageParameter(1, 10), \"test\"));\n        Assert.assertNotNull(pager);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "112947883_12", "part": [1, 1], "seq": [1, 1], "prompt": "class ValidateTor {\n\n  public boolean isPhoneNumber(String str) {\n    return regexMatcher.validate(str, RegexPresetPattern.PHONE);\n  }\n\n  public  ValidateTor();\n\n  public boolean containsSubstring(String str, String seed);\n  public boolean isAlpha(String str);\n  public boolean isAlphanumeric(String str);\n  public boolean isBoolean(String str);\n  public boolean isIPAddress(String str);\n  public boolean isEmail(String str);\n  public boolean isEmpty(String str);\n  public boolean isBase64(String str);\n  public boolean isDecimal(String str);\n  public boolean isAtleastLength(String str, int len);\n  public boolean isAtMostLength(String str, int len);\n  public boolean isLowercase(String str);\n  public boolean isUppercase(String str);\n  public boolean isValidMD5(String str);\n  public boolean isNumeric(String str);\n  public boolean isMACAddress(String str);\n  public boolean isJSON(String str);\n  public boolean isInteger(String str);\n  public boolean isIn(String str, String[] values);\n  public boolean isHexadecimal(String str);\n  public boolean isPinCode(String str);\n  public boolean isHexColor(String str);\n  public boolean hasAtleastOneDigit(String str);\n  public boolean hasAtleastOneLetter(String str);\n  public boolean hasAtleastOneLowercaseCharacter(String str);\n  public boolean hasAtleastOneUppercaseCharacter(String str);\n  public boolean hasAtleastOneSpecialCharacter(String str);\n  public boolean validateCreditCard(String str);\n  public CardInformation getCreditCardInfo(String str);\n\n  private ValidateTor validateTor;\n\n}\n\nclass ValidateTorTest {\n\n  private ValidateTor validateTor;\n\n  @Test\n  public void isPhoneNumber_shouldReturnFalse_whenStringIsInvalidPhoneNumber() throws Exception {\n", "reference": "    assertEquals(false, validateTor.isPhoneNumber(\"000-000-0000\"));\n    assertEquals(false, validateTor.isPhoneNumber(\"123-456-7890\"));\n    assertEquals(false, validateTor.isPhoneNumber(\"2126661234\"));\n\n  }\n\n}", "prediction": "    assertFalse(validateTor.isPhoneNumber(\"1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "115371169_20", "part": [1, 1], "seq": [1, 1], "prompt": "class ObjectTypeValidator implements BiPredicate<Object, Object> {\n\n    @Override\n    public boolean test(@NonNull Object objectOne, @NonNull Object objectTwo) {\n        ObjectTypeRetriever retriever = new ObjectTypeRetriever();\n        return retriever.apply(objectOne).equals(retriever.apply(objectTwo));\n    }\n\n}\n\nclass ObjectTypeValidatorTest {\n\n    @Test\n    public void compareInvalidObjectAndClassThenReturnFalse() {\n", "reference": "        boolean result = new ObjectTypeValidator().test(new A(), B.class);\n        assertFalse(result);\n    }\n\n}", "prediction": "        BiPredicate<Object, Object> validator = new ObjectTypeValidator();\n        assertFalse(validator.test(new Object(), String.class));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "115379439_0", "part": [1, 1], "seq": [1, 1], "prompt": "class ReflectionUtils {\n\n    public static <T> T newInstance(Class<T> type) throws ReflectiveOperationException {\n        Constructor<T> constructor = type.getDeclaredConstructor(new Class<?>[]{});\n        constructor.setAccessible(true);\n        return constructor.newInstance(new Object[]{});\n    }\n\n    public static Class<T> getActualType(Class<?> type);\n    @SuppressWarnings(\"unchecked\") public static Class<T> getActualType(Class<?> type, int index);\n\n}\n\nclass ReflectionUtilsTest {\n\n    @Test\n    public void newInstance() throws Exception {\n", "reference": "        A a = ReflectionUtils.newInstance(A.class);\n        assertNotNull(a);\n        B b = ReflectionUtils.newInstance(B.class);\n        assertNotNull(b);\n        C c = ReflectionUtils.newInstance(C.class);\n        assertNotNull(c);\n        b.setB(a);\n        assertEquals(b.getB(), a);\n    }\n\n}", "prediction": "        ReflectionUtils.newInstance(String.class);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "117291995_2", "part": [1, 1], "seq": [1, 1], "prompt": "class Cookie {\n\n    @SuppressWarnings({ \"StringEquality\", \"RedundantIfStatement\" })\n    @Override\n    public boolean equals(final Object obj) {\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n        final Cookie other = (Cookie) obj;\n        if (this.name != other.name && (this.name == null || !this.name.equals(other.name))) {\n            return false;\n        }\n        if (this.value != other.value && (this.value == null || !this.value.equals(other.value))) {\n            return false;\n        }\n        if (this.version != other.version) {\n            return false;\n        }\n        if (this.path != other.path && (this.path == null || !this.path.equals(other.path))) {\n            return false;\n        }\n        if (this.domain != other.domain && (this.domain == null || !this.domain.equals(other.domain))) {\n            return false;\n        }\n        return true;\n    }\n\n    public  Cookie(final String name, final String value, final String path, final String domain, final int version);\n    public  Cookie(final String name, final String value, final String path, final String domain);\n    public  Cookie(final String name, final String value);\n\n    @Deprecated public static Cookie valueOf(final String value);\n    public String getName();\n    public String getValue();\n    public int getVersion();\n    public String getDomain();\n    public String getPath();\n    @Override @Deprecated public String toString();\n    @Override public int hashCode();\n\n}\n\nclass CookieTest {\n\n    @Test\n    public void testEquals() {\n", "reference": "        Object nullObj = null;\n        Cookie cookie = new Cookie(\"name\", \"value\");\n        Cookie cookie1 = new Cookie(\"name\", \"value\");\n        Cookie cookie2 = new Cookie(\"name\", \"value2\");\n        NewCookie newCookie = new NewCookie(\"name\", \"value\");\n        NewCookie newCookie1 = new NewCookie(\"name\", \"value\");\n        NewCookie newCookie2 = new NewCookie(\"name\", \"value2\");\n        assertFalse(cookie.equals(nullObj));\n        assertFalse(cookie.equals(newCookie));\n        assertFalse(cookie.equals(cookie2));\n        assertTrue(cookie.equals(cookie1));\n        assertTrue(cookie.equals(newCookie.toCookie()));\n        assertTrue(newCookie.equals(newCookie1));\n        assertFalse(newCookie.equals(newCookie2));\n    }\n\n}", "prediction": "        final Cookie cookie = new Cookie(\"name\", \"value\");\n        assertEquals(cookie, cookie);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "117845334_2", "part": [1, 1], "seq": [1, 1], "prompt": "class TaskScheduer {\n\n    public void schedule(final IErrorHandler iErrorHandler, long timeout, ITimeoutHandler iTimeoutHandler, final ITasksFinishCallback iTasksFinishCallback) {\n        final AtomicInteger taskDoneCounter = new AtomicInteger(0);\n        final int taskCount = mTasks.size();\n        for (final LaunchTask task : mTasks) {\n            task.runOn().execute(new Worker(iErrorHandler, task, mTasks, new Worker.TaskDoneCallback() {\n                @Override\n                public void onTaskDone() {\n                    if (taskDoneCounter.addAndGet(1) == taskCount && iTasksFinishCallback != null) {\n                        iTasksFinishCallback.onTasksFinished();\n                    }\n                }\n            }));\n        }\n        TaskDelayChecker.delayCheckTaskAlive(mTasks, timeout, iTimeoutHandler);\n    }\n\n    public  TaskScheduer(List<LaunchTask> originTasks);\n\n    private synchronized List<LaunchTask> topologicalSort(List<LaunchTask> originTasks);\n    private int getIndexOfTask(List<LaunchTask> originTasks, String taskName);\n\n}\n\nclass TaskScheduerTest {\n\n    @Test\n    public void schedule3() throws Exception {\n", "reference": "        final Executor executor = Executors.newCachedThreadPool();\n        final CountDownLatch downLatch = new CountDownLatch(3);\n        final long[] taskStartTime = {0, 0, 0};\n        final long[] taskEndTime = {0, 0, 0};\n        LaunchTask task0 = TaskFactory.create(\"task0\", 1000, new ArrayList<String>(), executor, new TestTaskCallback() {\n            @Override\n            public void taskStart() {\n                taskStartTime[0] = System.nanoTime();\n            }\n\n            @Override\n            public void taskEnd() {\n                taskEndTime[0] = System.nanoTime();\n                downLatch.countDown();\n            }\n        });\n        LaunchTask task1 = TaskFactory.create(\"task1\", 1000, Collections.singletonList(\"task0\"), executor, new TestTaskCallback() {\n            @Override\n            public void taskStart() {\n                taskStartTime[1] = System.nanoTime();\n            }\n\n            @Override\n            public void taskEnd() {\n                taskEndTime[1] = System.nanoTime();\n                downLatch.countDown();\n            }\n        });\n        LaunchTask task2 = TaskFactory.create(\"task2\", 1000, Arrays.asList(\"task0\", \"task1\"), executor, new TestTaskCallback() {\n            @Override\n            public void taskStart() {\n                taskStartTime[2] = System.nanoTime();\n            }\n\n            @Override\n            public void taskEnd() {\n                taskEndTime[2] = System.nanoTime();\n                downLatch.countDown();\n            }\n        });\n        new TaskScheduer(Arrays.asList(task2, task1, task0)).schedule(null, 0, null);\n        downLatch.await();\n        //1 \u4f9d\u8d56 0 ,2 \u4f9d\u8d56 1 ,2 \u4f9d\u8d560\n        Assert.assertTrue(taskEndTime[0] < taskStartTime[1]);\n        Assert.assertTrue(taskEndTime[1] < taskStartTime[2]);\n    }\n\n}", "prediction": "        final List<LaunchTask> tasks = new ArrayList<>();\n        tasks.add(new LaunchTask(\"task1\", new ITask() {\n            @Override\n            public void run() {\n                System.out.println(\"task1\");\n            }\n        }));\n        tasks.add(new LaunchTask(\"task2\", new ITask() {\n            @Override\n            public void run() {\n                System.out.println(\"task2\");\n            }\n        }));\n        tasks.add(new LaunchTask(\"task3\", new ITask() {\n            @Override\n            public void run() {\n                System.out.println(\"task3\");\n            }\n        }));\n        tasks.add(new LaunchTask(\"task4\", new ITask() {\n            @Override\n            public void run() {\n                System.out.println(\"task4\");\n            }\n        }));\n        tasks.add(new LaunchTask(\"task5\", new ITask() {\n            @Override\n            public void run() {\n                System.out.println(\"task5\");\n            }\n        }));\n        tasks.add(new LaunchTask(\"task6\", new ITask() {\n            @Override\n            public void run() {\n                System.out.println(\"task6\");\n            }\n        }));\n        tasks.add(new LaunchTask(\"task7\", new ITask() {\n            @Override\n            public void run() {\n                System.out.println(\"task7\");\n            }\n        }));\n        tasks.add(new LaunchTask(\"task8\", new ITask() {\n            @Override\n            public void run() {\n                System.out.println(\"task8\");\n            }\n        }));\n        tasks.add(new LaunchTask(\"task9\", new ITask() {\n            @Override\n            public void run() {\n                System.out.println(\"task9\");\n            }\n        }));\n        tasks.add(new LaunchTask(\"task10\", new ITask() {\n            @Override\n            public void run() {\n                System.out.println(\"task10\");\n            }\n        }));\n        tasks.add(new LaunchTask(\"task11\", new ITask() {\n            @Override\n            public void run() {\n                System.out.println(\"task11\");\n            }\n        }));\n        tasks.add(new LaunchTask(\"task12\", new ITask() {\n            @Override\n            public void run() {\n                System.out.println(\"task12\");\n            }\n        }));\n        tasks.add(new LaunchTask(\"task13\", new ITask() {\n            @Override\n            public void run() {\n                System.out.println(\"task13\");\n            }\n        }));\n        tasks.add(new LaunchTask(\"task14\", new ITask() {\n            @Override\n            public void run() {\n                System.out.println(\"task14\");\n            }\n        }));\n        tasks.add(new LaunchTask(\"task15\", new ITask() {\n            @Override\n            public void run() {\n                System.out.println(\"task15\");\n            }\n        }));\n        tasks.add(new LaunchTask(\"task16\", new ITask() {\n            @Override\n            public void run() {\n                System.out.println(\"task16\");\n            }\n        }));\n        tasks.add(new LaunchTask(\"task17\", new ITask() {\n            @Override\n            public void run() {\n                System.out.println(\"task17\");\n            }\n        }));\n        tasks.add(new LaunchTask(\"task18\", new ITask() {\n            @Override\n            public void run() {\n                System.out.println(\"task18\");\n            }\n        }));\n        tasks.add(new LaunchTask(\"task19\", new ITask() {\n            @Override\n            public void run() {\n                System.out.println(\"task19\");\n            }\n        }));\n        tasks.add(new LaunchTask(\"task20\", new ITask() {\n            @Override\n            public void run() {\n                System.out.println(\"task20\");\n            }\n        }));\n        tasks.add(new LaunchTask(\"task21\", new ITask() {\n            @Override\n            public void run() {\n                System.out.println(\"task21\");\n            }\n        }));\n        tasks.add(new LaunchTask(\"task22\", new ITask() {\n            @Override\n            public void run() {\n                System.out.println(\"task22\");\n            }\n        }));\n        tasks.add(new LaunchTask(\"task23\", new ITask() {\n            @Override\n            public void run() {\n                System.out.println(\"task23\");\n            }\n        }));\n        tasks.add(new LaunchTask(\"task24\", new ITask() {\n            @Override\n            public void run() {\n                System.out.println(\"task24\");\n            }\n        }));\n        tasks.add(new LaunchTask(\"task25\", new ITask() {\n            @Override\n            public void run() {\n                System.out.println(\"task25\");\n            }\n        }));\n        tasks.add(new LaunchTask(\"task26\", new ITask() {\n            @Override\n            public void run() {\n                System.out.println(\"task26\");\n            }\n        }));\n        tasks.add(new LaunchTask(\"task27\", new ITask() {\n            @Override\n            public void run() {\n                System.out.println(\"task27\");\n            }\n        }));\n        tasks.add(new LaunchTask(\"task28\", new ITask() {\n            @Override\n            public void run() {\n                System.out.println(\"task28\");\n            }\n        }));\n        tasks.add(new LaunchTask(\"task29\", new ITask() {\n            @Override\n            public void run() {\n                System.out.println(\"task29\");\n            }\n        }));\n        tasks.add(new LaunchTask(\"task30\", new ITask() {\n            @Override\n            public void run() {\n                System.out.println(\"task30\");\n            }\n        }));\n        tasks.add(new LaunchTask(\"task31\", new ITask() {\n            @Override\n            public void run() {\n                System.out.println(\"task31\");\n            }\n        }));\n        tasks.add(new LaunchTask(\"task32\", new ITask() {\n            @Override\n            public void run() {\n                System.out.println(\"task32\");\n            }\n        }));\n        tasks.add(new LaunchTask", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "119080111_49", "part": [1, 1], "seq": [1, 1], "prompt": "class DoubleGenotype extends ArrayList<Double> implements ListGenotype<Double> {\n\n\tpublic void init(Random random, int n) {\n\t\ttry {\n\t\t\tgetLowerBound(n - 1);\n\t\t\tgetUpperBound(n - 1);\n\t\t} catch (IndexOutOfBoundsException outOfBoundException) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Cannot initialize a genotype with \" + n + \" entries with the specified bounds\",\n\t\t\t\t\toutOfBoundException);\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdouble lo = getLowerBound(i);\n\t\t\tdouble hi = getUpperBound(i);\n\t\t\tdouble value = lo + random.nextDouble() * (hi - lo);\n\t\t\tif (i >= size()) {\n\t\t\t\tadd(value);\n\t\t\t} else {\n\t\t\t\tset(i, value);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic  DoubleGenotype();\n\tpublic  DoubleGenotype(double lowerBound, double upperBound);\n\tpublic  DoubleGenotype(Bounds<Double> bounds);\n\n\tpublic double getLowerBound(int index);\n\tpublic double getUpperBound(int index);\n\t@Override @SuppressWarnings(\"unchecked\") public G newInstance();\n\n}\n\nclass DoubleGenotypeTest {\n\n\t@Test(expected = IllegalArgumentException.class)\n\tpublic void testWrongBoundSettingArray() {\n", "reference": "\t\tRandom rand = new Random();\n\t\tdouble[] lowerBounds = { -1.0, -0.5, 0.0 };\n\t\tdouble[] upperBounds = { -0.5, 0.0, 0.5 };\n\t\tDoubleBounds bounds = new DoubleBounds(lowerBounds, upperBounds);\n\t\tDoubleGenotype listGeno = new DoubleGenotype(bounds);\n\t\tassertTrue(listGeno.isEmpty());\n\t\tlistGeno.init(rand, 4);\n\t}\n\n}", "prediction": "\t\tDoubleGenotype genotype = new DoubleGenotype();\n\t\tgenotype.setLowerBound(new double[] { 1.0, 2.0, 3.0 });\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "119170338_36", "part": [1, 1], "seq": [1, 1], "prompt": "class PairwiseResnikSimilarity implements PairwiseSimilarity {\n\n  @Override\n  public double computeScore(TermId query, TermId target) {\n    return computeScoreImpl(query, target);\n  }\n\n  protected  PairwiseResnikSimilarity();\n  public  PairwiseResnikSimilarity(Ontology ontology, Map<TermId, Double> termToIc);\n\n  private double computeScoreImpl(TermId query, TermId target);\n  public Ontology getOntology();\n  public Map<TermId, Double> getTermToIc();\n\n  private PairwiseResnikSimilarity similarity;\n\n}\n\nclass PairwiseResnikSimilarityTest  {\n\n  private PairwiseResnikSimilarity similarity;\n\n  @Test\n  public void testComputeSimilarities() {\n", "reference": "    assertEquals(0.0, similarity.computeScore(idBeet, idCarrot), 0.01);\n    assertEquals(0.405, similarity.computeScore(idBlueCarrot, idCarrot), 0.01);\n    assertEquals(0.0, similarity.computeScore(idPumpkin, idCarrot), 0.01);\n    assertEquals(0.0, similarity.computeScore(idLeafVegetable, idCarrot), 0.01);\n  }\n\n}", "prediction": "    Map<TermId, Double> termToIc = new HashMap<>();\n    termToIc.put(TermId.of(\"HP:0000001\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000002\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000003\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000004\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000005\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000006\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000007\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000008\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000009\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000010\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000011\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000012\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000013\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000014\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000015\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000016\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000017\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000018\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000019\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000020\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000021\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000022\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000023\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000024\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000025\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000026\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000027\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000028\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000029\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000030\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000031\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000032\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000033\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000034\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000035\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000036\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000037\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000038\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000039\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000040\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000041\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000042\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000043\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000044\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000045\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000046\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000047\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000048\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000049\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000050\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000051\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000052\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000053\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000054\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000055\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000056\"), 0.0);\n    termToIc.put(TermId.of(\"HP:0000057\"), 0.0);\n    termToIc.put", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "119258092_1", "part": [1, 1], "seq": [1, 1], "prompt": "class ExternalService {\n\n    public String sendPostRequest(String body){\n        String accessCode=getToken();\n        String externalResponse=\"\";\n        if(accessCode==\"\"){\n            return \"Invalid Access code provided\";\n        }\n\n        try{\n            String externalUrl=\"https://graph.facebook.com/v2.6/me/messages?access_token=\"+accessCode;\n            HttpHeaders headers=new HttpHeaders();\n            headers.setContentType(MediaType.APPLICATION_JSON);\n\n            HttpEntity<String> httpEntity=new HttpEntity<String>(body,headers);\n            RestTemplate template=new RestTemplate();\n\n            System.out.println(httpEntity.getBody());\n            externalResponse=template.postForObject(externalUrl,httpEntity,String.class);\n        }\n        catch (Exception ex){\n            ex.printStackTrace();\n        }\n\n        return externalResponse;\n    }\n\n    public String sendGetRequest(String url);\n    public String getToken();\n    public String getLeagueStanding(int leagueID);\n    public String getLeagueFixture(int leagueID, int matchDay);\n\n}\n\nclass ExternalServiceTest {\n\n    @Test\n    public void sendPostRequest() {\n", "reference": "//        fail();\n    }\n\n}", "prediction": "        ExternalService externalService=new ExternalService();\n        String response=externalService.sendPostRequest(\"{\\\"recipient\\\":{\\\"id\\\":\\\"1427444889002743\\\"},\\\"message\\\":{\\\"text\\\":\\\"Hello World\\\"}}\");\n        assertEquals(\"{\\\"recipient_id\\\":\\\"1427444889002743\\\",\\\"message_id\\\":\\\"mid.1457764197618:41d102a307\\\"}\",response);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "119930717_0", "part": [1, 1], "seq": [1, 1], "prompt": "class MergeSortedArraysChallenge {\n\n    void mergeSortedArrays(int[] src1, int[] src2, int[] dest){\n\n        // write your logic here\n\n    }\n\n    public static void main(String[] args);\n\n     MergeSortedArraysChallenge challenge;\n\n}\n\nclass MergeSortedArraysChallengeTest {\n\n     MergeSortedArraysChallenge challenge;\n\n    @Test\n    public void test(){\n", "reference": "        int[] src1 = new int[]{0, 2, 2, 6, 8, 8, 11};\n        int[] src2 = new int[]{ 0 ,3 ,6 ,7 ,10 ,11     };\n        int[] dest = new int[src1.length + src2.length];\n\n        challenge.mergeSortedArrays(src1, src2, dest);\n\n        assertThat(dest).containsExactly(0, 0, 2, 2, 3, 6, 6, 7, 8, 8, 10, 11, 11);\n    }\n\n}", "prediction": "\n        int[] src1 = {1, 3, 5, 7, 9};\n        int[] src2 = {2, 4, 6, 8, 10};\n        int[] dest = new int[10];\n\n        challenge.mergeSortedArrays(src1, src2, dest);\n\n        assertArrayEquals(new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, dest);\n\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "120829698_23", "part": [1, 1], "seq": [1, 1], "prompt": "class P2PathUtils {\n\n  public static TokenMatcher.State matcherState(final Context context) {\n    return context.getAttributes().require(TokenMatcher.State.class);\n  }\n\n  private  P2PathUtils();\n\n  public static String path(final TokenMatcher.State state);\n  public static String maybePath(final TokenMatcher.State state);\n  private static String match(final TokenMatcher.State state, final String name);\n  public static String path(final String path, final String filename);\n  public static String path(final String path, final String filename, final String extension);\n  public static String binaryPath(final String path, final String name, final String version);\n  public static String name(final TokenMatcher.State state);\n  public static String filename(final TokenMatcher.State state);\n  public static String version(final TokenMatcher.State state);\n  public static String componentName(final TokenMatcher.State state);\n  public static String componentVersion(final TokenMatcher.State state);\n  public static String extension(final TokenMatcher.State state);\n  public static P2Attributes toP2Attributes(final String path, final TokenMatcher.State state);\n  public static P2Attributes toP2AttributesBinary(final String path, final TokenMatcher.State state);\n  public static P2Attributes getBinaryAttributesFromBlobName(final String blobName);\n  public static P2Attributes getPackageAttributesFromBlob(final StorageFacet storageFacet,\n                                                          final P2TempBlobUtils p2TempBlobUtils,\n                                                          final Blob blob,\n                                                          final String blobName);\n  private static String getBinaryNameFromBlobName(final String blobName, final String version);\n  private static String getBinaryVersionFromBlobName(final String blobName);\n  private static String getPackageExtensionFromBlobName(final String blobName);\n  public static AssetKind getAssetKind(final String path);\n\n  @Mock Context context;\n  @Mock TokenMatcher.State state;\n  @Mock AttributesMap attributesMap;\n  private final String fakePath;\n  private final String fakeComponentName;\n  private final String fakeFileName;\n  private final String fakeExtension;\n\n}\n\nclass P2PathUtilsTest  {\n\n  @Mock Context context;\n  @Mock TokenMatcher.State state;\n  @Mock AttributesMap attributesMap;\n  private final String fakePath;\n  private final String fakeComponentName;\n  private final String fakeFileName;\n  private final String fakeExtension;\n\n  @Test\n  public void matcherState() throws Exception {\n", "reference": "    when(context.getAttributes())\n        .thenReturn(attributesMap);\n    when(attributesMap.require(TokenMatcher.State.class))\n        .thenReturn(state);\n    TokenMatcher.State testState = P2PathUtils.matcherState(context);\n    assertThat(testState, instanceOf(TokenMatcher.State.class));\n  }\n\n}", "prediction": "    when(context.getAttributes()).thenReturn(attributesMap);\n    when(attributesMap.require(TokenMatcher.State.class)).thenReturn(state);\n    assertThat(P2PathUtils.matcherState(context)).isEqualTo(state);\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "121694310_68", "part": [1, 1], "seq": [1, 1], "prompt": "class Element implements IAttributes {\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic <O> O getAttribute(String identifier) {\n\t\tif (attributes.getAttributes().containsKey(identifier)) {\n\t\t\treturn (O) attributes.getAttribute(identifier);\n\t\t} else if (parent != null) {\n\t\t\treturn (O) parent.getAttribute(identifier);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic  Element(String id);\n\tpublic  Element(Element parent);\n\n\tpublic String getId();\n\tpublic Element getParent();\n\tpublic void setParent(Element element);\n\t@Override public boolean isDefined(String identifier);\n\t@Override public Attributes getAttributes();\n\tpublic Attributes getLocalAttributes();\n\tpublic Set<String> getLocalAttributeNames();\n\t@Override public void setAttribute(String identifier, Object object);\n\t@Override public int hashCode();\n\t@Override public boolean equals(Object obj);\n\t@Override public String toString();\n\t@Override public Parameter getAttributeParameter(String identifier);\n\t@Override public Set<String> getAttributeNames();\n\tpublic String getType();\n\tpublic void setType(String type);\n\n}\n\nclass ElementTest {\n\n\t@Test\n\tpublic void testGetAttribute() {\n", "reference": "\t\tElement element = new Element(\"id\");\n\t\tString id = \"attribute name\";\n\t\telement.setAttribute(id, 0);\n\n\t\tAssert.assertEquals(0, (int) element.<Integer> getAttribute(id));\n\t\tAssert.assertNull(element.getAttribute(\"other\"));\n\t}\n\n}", "prediction": "\t\tElement element = new Element(\"test\");\n\t\telement.setAttribute(\"test\", \"test\");\n\t\tassertEquals(\"test\", element.getAttribute(\"test\"));\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "122685352_1", "part": [1, 1], "seq": [1, 1], "prompt": "class PostViewModel extends ViewModel {\n\n    public Post getPost() {\n        Post post = new Post(name.get(), content.get(), category.get(), HttpUrl.parse(inReplyTo.get()));\n        if (!this.photo.get().equals(\"\")) {\n            post.setPhoto(this.photo.get());\n        }\n        if (!this.likeOf.get().equals(\"\")) {\n            post.setLikeOf(HttpUrl.parse(likeOf.get()));\n        }\n        if (!this.bookmarkOf.get().equals(\"\")) {\n            post.setBookmarkOf(HttpUrl.parse(bookmarkOf.get()));\n        }\n        if (!this.postStatus.get().equals(\"\")) {\n            post.setPostStatus((postStatus.get()));\n        }\n\n        int id = this.checkedVisibility.get();\n        switch (id) {\n            case R.id.radioButtonPublic:\n                this.visibility.set(\"public\");\n                break;\n\n            case R.id.radioButtonUnlisted:\n                this.visibility.set(\"unlisted\");\n                break;\n\n            case R.id.radioButtonProtected:\n                this.visibility.set(\"protected\");\n                break;\n\n            case R.id.radioButtonPrivate:\n                this.visibility.set(\"private\");\n                break;\n        }\n\n        if (!this.visibility.get().equals(\"\")) {\n            post.setVisibility((visibility.get()));\n        }\n        return post;\n    }\n\n    public  PostViewModel();\n\n    public void clear();\n    public void findReplyTo(String urlOrNote);\n    public void findLikeOf(String urlOrNote);\n    public void findBookmarkOf(String urlOrNote);\n    public void setPhoto(String url);\n    @BindingAdapter(\"android:visibility\") public static void setVisibility(View view, Boolean value);\n\n    private static final Pattern urlPattern;\n\n}\n\nclass PostViewModelTest {\n\n    private static final Pattern urlPattern;\n\n    @Test\n    public void postStatusSetToDraft() {\n", "reference": "        PostViewModel postModel = new PostViewModel();\n        postModel.postStatus.set(\"draft\");\n        Post post = postModel.getPost();\n        assertEquals(\"draft\", post.getPostStatus());\n    }\n\n}", "prediction": "        PostViewModel viewModel = new PostViewModel();\n        viewModel.postStatus.set(\"draft\");\n        assertEquals(\"draft\", viewModel.getPost().getPostStatus());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "122696956_1", "part": [1, 1], "seq": [1, 1], "prompt": "class FileHttpDownload extends FileHttpHandler {\n\n\tpublic void download(String http, String savaPath, String fileName, FileAction<File> fileAction) {\n\t\tdownload(http, savaPath, fileName, false, fileAction);\n\t}\n\n\tpublic void download(String http, String savaPath, String fileName, boolean onlyReplaceName, FileAction<File> fileAction);\n\tpublic void download(String http, String method, String savaPath, String fileName, boolean onlyReplaceName, FileAction<File> fileAction);\n\tpublic void download(String http, String filePath, FileAction<File> fileAction);\n\tpublic void download(String http, File saveFile, FileAction<File> fileAction);\n\tpublic static String getFileNameFromUrl(String url);\n\tpublic String getFileName(String http, String disposition, String fileName, boolean onlyReplaceName);\n\tpublic String getFileNameO(String http, String disposition, String fileName, boolean onlyReplaceName);\n\tpublic static void main(String[] arg);\n\n}\n\nclass FileHttpDownloadTest {\n\n\t@Test\n\tpublic void testUpload() {\n", "reference": "\t\tMap<String, String> dataMap = new HashMap<String, String>();\n\t\tdataMap.put(\"userId\", \"110\");\n\n\t\tFileAction<File> action = new FileAction<File>() {\n\n\t\t\t@Override\n\t\t\tpublic void progress(long speed, long size, long finishSize, double progress) {\n\n\t\t\t\tString speedText = \"0MB/s\";\n\t\t\t\tif (speed < 1024) {\n\t\t\t\t\tspeedText = speed + \"B/s\";\n\t\t\t\t} else if (1024 <= speed && speed < (1024 * 1024)) {\n\t\t\t\t\tString s = OnlyNumberUtil.format(((double) speed / 1024d));\n\t\t\t\t\tspeedText = s + \"KB/s\";\n\t\t\t\t} else {\n\t\t\t\t\tString s = OnlyNumberUtil.format(((double) speed / (double) (1024 * 1024)));\n\t\t\t\t\tspeedText = s + \"MB/s\";\n\t\t\t\t}\n\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tsb.append(\"size:\" + size);\n\t\t\t\tsb.append(\" \");\n\t\t\t\tsb.append(\"finishSize:\" + finishSize);\n\t\t\t\tsb.append(\" \");\n\t\t\t\tsb.append(\"progress:\" + progress);\n\t\t\t\tsb.append(\" \");\n\t\t\t\tsb.append(\"speed:\");\n\t\t\t\tsb.append(speedText);\n\t\t\t\tsb.append(\" \");\n\t\t\t\tSystem.out.println(sb);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void success(File t) {\n\t\t\t\tSystem.out.println(t.getAbsolutePath());\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void lost(File t) {\n\t\t\t\t// TODO Auto-generated method stub\n\n\t\t\t}\n\t\t};\n\t\tString http = \"http://download.netbeans.org/netbeans/8.2/final/bundles/netbeans-8.2-windows.exe\";\n\t\tString savaPath = \"Temp/\";\n\t\tString fileName = \"\";\n\n\t\tboolean onlyReplaceName = false;\n\t\tFileHttpDownload fhd = new FileHttpDownload();\n\t\tfhd.download(http,\"\", savaPath, fileName, onlyReplaceName, action);\n\t}\n\n}", "prediction": "\t\tFileHttpDownload fileHttpDownload = new FileHttpDownload();\n\t\tfileHttpDownload.download(\"http://www.baidu.com/img/bd_logo1.png\", \"D:\\\\\", \"baidu.png\", new FileAction<File>() {\n\t\t\t@Override\n\t\t\tpublic void action(File file) {\n\t\t\t\tSystem.out.println(file.getAbsolutePath());\n\t\t\t}\n\t\t});\n\t}", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "124698942_2", "part": [1, 1], "seq": [1, 1], "prompt": "class Expression implements Parcelable {\n\n    @NonNull\n    BigDecimal evaluate(boolean priority, int scale, RoundingMode roundingMode) {\n        if (numbers.size() != operators.size() + 1) {\n            throw new IllegalStateException(\"Numbers and operators aren't balanced.\");\n        }\n\n        if (numbers.size() == 1) return numbers.get(0);\n\n        List<BigDecimal> nbs = new ArrayList<>(numbers);\n        List<Operator> ops = new ArrayList<>(operators);\n\n        if (priority) {\n            // Evaluate products and quotients\n            int i = 0;\n            while (i < ops.size()) {\n                Operator op = ops.get(i);\n                if (op == Operator.MULTIPLY) {\n                    ops.remove(i);\n                    BigDecimal n1 = nbs.get(i);\n                    BigDecimal n2 = nbs.remove(i + 1);\n                    nbs.set(i, n1.multiply(n2));\n                } else if (op == Operator.DIVIDE) {\n                    ops.remove(i);\n                    BigDecimal n1 = nbs.get(i);\n                    BigDecimal n2 = nbs.remove(i + 1);\n                    nbs.set(i, n1.divide(n2, scale, roundingMode));\n                } else {\n                    i++;\n                }\n            }\n        }\n\n        // Evaluate the rest\n        while (!ops.isEmpty()) {\n            Operator op = ops.remove(0);\n            BigDecimal n1 = nbs.get(0);\n            BigDecimal n2 = nbs.remove(1);\n            if (op == Operator.ADD) {\n                nbs.set(0, n1.add(n2));\n            } else if (op == Operator.SUBTRACT) {\n                nbs.set(0, n1.subtract(n2));\n            } else if (op == Operator.MULTIPLY) {\n                nbs.set(0, n1.multiply(n2));\n            } else {\n                nbs.set(0, n1.divide(n2, scale, roundingMode));\n            }\n        }\n\n        return nbs.remove(0).stripTrailingZeros();\n    }\n\n      Expression();\n    private  Expression(Parcel in);\n\n     void clear();\n     boolean isEmpty();\n     String format(NumberFormat nbFormat);\n    @NonNull @Override public String toString();\n    @Override public void writeToParcel(@NonNull Parcel out, int flags);\n    @Override public int describeContents();\n\n}\n\nclass ExpressionTest {\n\n    @Test\n    public void longExpression() {\n", "reference": "        Expression expr = new Expression();\n        expr.numbers.add(new BigDecimal(\"-1\"));\n        expr.operators.add(Expression.Operator.DIVIDE);\n        expr.numbers.add(new BigDecimal(\"6\"));\n        expr.operators.add(Expression.Operator.ADD);\n        expr.numbers.add(new BigDecimal(\"5\"));\n        expr.operators.add(Expression.Operator.MULTIPLY);\n        expr.numbers.add(new BigDecimal(\"12\"));\n        expr.operators.add(Expression.Operator.DIVIDE);\n        expr.numbers.add(new BigDecimal(\"3\"));\n        expr.operators.add(Expression.Operator.DIVIDE);\n        expr.numbers.add(new BigDecimal(\"8\"));\n        expr.operators.add(Expression.Operator.SUBTRACT);\n        expr.numbers.add(new BigDecimal(\"-10\"));\n\n        BigDecimal result1 = expr.evaluate(false, 8, RoundingMode.HALF_UP);\n        assertEquals(result1, new BigDecimal(\"12.41666667\"));\n\n        BigDecimal result2 = expr.evaluate(true, 8, RoundingMode.HALF_UP);\n        assertEquals(result2, new BigDecimal(\"12.33333333\"));\n    }\n\n}", "prediction": "        Expression e = new Expression();\n        e.addNumber(new BigDecimal(\"123456789012345678901234567890\"));\n        e.addOperator(Operator.ADD);\n        e.addNumber(new BigDecimal(\"123456789012345678901234567890\"));\n        e.addOperator(Operator.ADD);\n        e.addNumber(new BigDecimal(\"123456789012345678901234567890\"));\n        e.addOperator(Operator.ADD);\n        e.addNumber(new BigDecimal(\"123456789012345678901234567890\"));\n        e.addOperator(Operator.ADD);\n        e.addNumber(new BigDecimal(\"123456789012345678901234567890\"));\n        e.addOperator(Operator.ADD);\n        e.addNumber(new BigDecimal(\"123456789012345678901234567890\"));\n        e.addOperator(Operator.ADD);\n        e.addNumber(new BigDecimal(\"123456789012345678901234567890\"));\n        e.addOperator(Operator.ADD);\n        e.addNumber(new BigDecimal(\"123456789012345678901234567890\"));\n        e.addOperator(Operator.ADD);\n        e.addNumber(new BigDecimal(\"123456789012345678901234567890\"));\n        e.addOperator(Operator.ADD);\n        e.addNumber(new BigDecimal(\"123456789012345678901234567890\"));\n        e.addOperator(Operator.ADD);\n        e.addNumber(new BigDecimal(\"123456789012345678901234567890\"));\n        e.addOperator(Operator.ADD);\n        e.addNumber(new BigDecimal(\"123456789012345678901234567890\"));\n        e.addOperator(Operator.ADD);\n        e.addNumber(new BigDecimal(\"123456789012345678901234567890\"));\n        e.addOperator(Operator.ADD);\n        e.addNumber(new BigDecimal(\"123456789012345678901234567890\"));\n        e.addOperator(Operator.ADD);\n        e.addNumber(new BigDecimal(\"123456789012345678901234567890\"));\n        e.addOperator(Operator.ADD);\n        e.addNumber(new BigDecimal(\"123456789012345678901234567890\"));\n        e.addOperator(Operator.ADD);\n        e.addNumber(new BigDecimal(\"123456789012345678901234567890\"));\n        e.addOperator(Operator.ADD);\n        e.addNumber(new BigDecimal(\"123456789012345678901234567890\"));\n        e.addOperator(Operator.ADD);\n        e.addNumber(new BigDecimal(\"123456789012345678901234567890\"));\n        e.addOperator(Operator.ADD);\n        e.addNumber(new BigDecimal(\"123456789012345678901234567890\"));\n        e.addOperator(Operator.ADD);\n        e.addNumber(new BigDecimal(\"123456789012345678901234567890\"));\n        e.addOperator(Operator.ADD);\n        e.addNumber(new BigDecimal(\"123456789012345678901234567890\"));\n        e.addOperator(Operator.ADD);\n        e.addNumber(new BigDecimal(\"123456789012345678901234567890\"));\n        e.addOperator(Operator.ADD);\n        e.addNumber(new BigDecimal(\"123456789012345678901234567890\"));\n        e.addOperator(Operator.ADD);\n        e.addNumber(new BigDecimal(\"123456789012345678901234567890\"));\n        e.addOperator(Operator.ADD);\n        e.addNumber(new BigDecimal(\"123456789012345678901234567890\"));", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "125030262_0", "part": [1, 1], "seq": [1, 1], "prompt": "class DemoApplicationProperties {\n\n    public List<String> getEmailAddresses() {\n        return emailAddresses;\n    }\n\n    public Integer getNumber();\n    public void setNumber(Integer number);\n    public String getTelephoneNumber();\n    public void setTelephoneNumber(String telephoneNumber);\n    public void setEmailAddresses(List<String> emailAddresses);\n    public String getUsername();\n    public void setUsername(String username);\n    public String getFirstName();\n    public void setFirstName(String firstName);\n    public String getLastName();\n    public void setLastName(String lastName);\n    public Duration getWorkingTime();\n    public void setWorkingTime(Duration workingTime);\n\n    @Autowired\n    private DemoApplicationProperties demoApplicationProperties;\n\n}\n\nclass DemoApplicationPropertiesTest {\n\n    @Autowired\n    private DemoApplicationProperties demoApplicationProperties;\n\n    @Test\n    public void getEmailAddresses_DefaultValueMustBeOverwrittenByValuesInPropertiesFile() {\n", "reference": "        //When\n        List<String> emailAddresses = demoApplicationProperties.getEmailAddresses();\n        //Then\n        assertThat(emailAddresses).containsOnly(\"shazin.sadakath@gmail.com\", \"shazin.swe@gmail.com\");\n    }\n\n}", "prediction": "        assertThat(demoApplicationProperties.getEmailAddresses()).containsExactly(\"demo@example.com\");\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "125550262_32", "part": [1, 1], "seq": [1, 1], "prompt": "class Delete extends Operation {\n\n  @Override\n  public boolean equals(Object other) {\n    if (this == other) {\n      return true;\n    }\n    if (!(other instanceof Delete)) {\n      return false;\n    }\n    Delete that = (Delete) other;\n    return Objects.equals(table, that.getTable())\n        && Objects.equals(conditions, that.getWhere());\n  }\n\n  public  Delete(String table);\n  public  Delete(String table, List<Condition> conditions);\n\n  public Delete where(String column, Function function, Value value);\n  public Delete where(String column, Function function, String string);\n  public Delete where(String column, Function function, long integer);\n  public Delete where(String column, Function function, boolean bool);\n  public Delete where(String column, Function function, Uuid uuid);\n  public Delete where(String column, Function function, NamedUuid namedUuid);\n  public Delete where(\n      String column, Function function, java.util.Map<K, V> map\n  );\n  public Delete where(\n      String column, Function function, java.util.Set<T> set\n  );\n  public String getTable();\n  public List<Condition> getWhere();\n  @Override public int hashCode();\n  @Override public String toString();\n\n  private final UUID uuid;\n  private final Delete delete;\n\n}\n\nclass DeleteTest {\n\n  private final UUID uuid;\n  private final Delete delete;\n\n  @Test\n  public void testEquals() {\n", "reference": "    List<Condition> conditions = Stream.of(\n        new Condition(\"string_column\", Function.INCLUDES, Atom.string(\"A string\")),\n        new Condition(\"integer_column\", Function.LESS_THAN, Atom.integer(42)),\n        new Condition(\"bool_column\", Function.EQUALS, Atom.bool(true)),\n        new Condition(\"uuid_column\", Function.NOT_EQUALS, Atom.uuid(uuid)),\n        new Condition(\"named-uuid_column\", Function.EXCLUDES, Atom.namedUuid(\"uuid-name\")),\n        new Condition(\"map_column\", Function.GREATER_THAN_OR_EQUALS,\n            new Map<>(ImmutableList.of(new Pair<>(Atom.string(\"key\"), Atom.string(\"value\"))))\n        ),\n        new Condition(\"set_column\", Function.LESS_THAN_OR_EQUALS,\n            new Set(ImmutableSet.of(Atom.string(\"value1\"), Atom.string(\"value2\")))\n        )\n    ).collect(Collectors.toList());\n    new EqualsTester().addEqualityGroup(delete, new Delete(\"Logical_Switch\", conditions)).testEquals();\n  }\n\n}", "prediction": "    assertEquals(delete, delete);\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "125830136_6", "part": [1, 1], "seq": [1, 1], "prompt": "class InstanceTaskServiceImpl implements InstanceTaskService {\n\n\t@Override\n\tpublic int[] batchInsert(List<InstanceTaskDB> entityList) {\n\t\treturn instanceTaskDao.batchInsert(entityList);\n\t}\n\n\tpublic int cleanHistory(Date minKeepTime);\n\t@Override public List<InstanceTaskDB> getByQuery(InstanceTaskQuery query);\n\t@Override public InstanceTaskDB getById(String instanceFlowId, Integer fileId);\n\n\tprivate InstanceTaskService instanceTaskService;\n\n}\n\nclass InstanceTaskServiceImplTest  {\n\n\tprivate InstanceTaskService instanceTaskService;\n\n\t@Test\n\tpublic void testBatchInsert(){\n", "reference": "\t\tList<InstanceTaskDB> instanceTaskDBList = new ArrayList<InstanceTaskDB>();\n\t\tfor (int i=0; i<10; i++) {\n\t\t\tInstanceTaskDB instanceDB = new InstanceTaskDB();\n\t\t\tinstanceDB.setInstanceFlowId(UUID.randomUUID().toString().replace(\"-\", \"\"));\n\t\t\tinstanceDB.setFileId(100);\n\t\t\tinstanceDB.setFileBody(\"{xxxx}\");\n\t\t\tinstanceDB.setReadyTime(new Date());\n\t\t\tinstanceDB.setStartTime(new Date());\n\t\t\tinstanceDB.setEndTime(new Date());\n\t\t\tinstanceDB.setStatus(ExecStatus.Success.name());\n\t\t\tinstanceDB.setRetriedTimes(2);\n\t\t\tinstanceDB.setLog(null);\n\t\t\tinstanceDB.setPoolActiveCount(10);\n\t\t\tinstanceDB.setPoolQueueSize(10);\n\t\t\tinstanceTaskDBList.add(instanceDB);\n\t\t}\n\t\tinstanceTaskService.batchInsert(instanceTaskDBList);\n\t}\n\n}", "prediction": "\t\tList<InstanceTaskDB> entityList = new ArrayList<InstanceTaskDB>();\n\t\tInstanceTaskDB instanceTaskDB = new InstanceTaskDB();\n\t\tinstanceTaskDB.setInstanceFlowId(\"1\");\n\t\tinstanceTaskDB.setFileId(1);\n\t\tinstanceTaskDB.setTaskType(TaskType.INSTANCE_START);\n\t\tinstanceTaskDB.setTaskStatus(TaskStatus.INIT);\n\t\tinstanceTaskDB.setCreateTime(new Date());\n\t\tentityList.add(instanceTaskDB);\n\t\tinstanceTaskDB = new InstanceTaskDB();\n\t\tinstanceTaskDB.setInstanceFlowId(\"1\");\n\t\tinstanceTaskDB.setFileId(2);\n\t\tinstanceTaskDB.setTaskType(TaskType.INSTANCE_START);\n\t\tinstanceTaskDB.setTaskStatus(TaskStatus.INIT);\n\t\tinstanceTaskDB.setCreateTime(new Date());\n\t\tentityList.add(instanceTaskDB);\n\t\tinstanceTaskDB = new InstanceTaskDB();\n\t\tinstanceTaskDB.setInstanceFlowId(\"1\");\n\t\tinstanceTaskDB.setFileId(3);\n\t\tinstanceTaskDB.setTaskType(TaskType.INSTANCE_START);\n\t\tinstanceTaskDB.setTaskStatus(TaskStatus.INIT);\n\t\tinstanceTaskDB.setCreateTime(new Date());\n\t\tentityList.add(instanceTaskDB);\n\t\tinstanceTaskDB = new InstanceTaskDB();\n\t\tinstanceTaskDB.setInstanceFlowId(\"1\");\n\t\tinstanceTaskDB.setFileId(4);\n\t\tinstanceTaskDB.setTaskType(TaskType.INSTANCE_START);\n\t\tinstanceTaskDB.setTaskStatus(TaskStatus.INIT);\n\t\tinstanceTaskDB.setCreateTime(new Date());\n\t\tentityList.add(instanceTaskDB);\n\t\tinstanceTaskDB = new InstanceTaskDB();\n\t\tinstanceTaskDB.setInstanceFlowId(\"1\");\n\t\tinstanceTaskDB.setFileId(5);\n\t\tinstanceTaskDB.setTaskType(TaskType.INSTANCE_START);\n\t\tinstanceTaskDB.setTaskStatus(TaskStatus.INIT);\n\t\tinstanceTaskDB.setCreateTime(new Date());\n\t\tentityList.add(instanceTaskDB);\n\t\tinstanceTaskDB = new InstanceTaskDB();\n\t\tinstanceTaskDB.setInstanceFlowId(\"1\");\n\t\tinstanceTaskDB.setFileId(6);\n\t\tinstanceTaskDB.setTaskType(TaskType.INSTANCE_START);\n\t\tinstanceTaskDB.setTaskStatus(TaskStatus.INIT);\n\t\tinstanceTaskDB.setCreateTime(new Date());\n\t\tentityList.add(instanceTaskDB);\n\t\tinstanceTaskDB = new InstanceTaskDB();\n\t\tinstanceTaskDB.setInstanceFlowId(\"1\");\n\t\tinstanceTaskDB.setFileId(7);\n\t\tinstanceTaskDB.setTaskType(TaskType.INSTANCE_START);\n\t\tinstanceTaskDB.setTaskStatus(TaskStatus.INIT);\n\t\tinstanceTaskDB.setCreateTime(new Date());\n\t\tentityList.add(instanceTaskDB);\n\t\tinstanceTaskDB = new InstanceTaskDB();\n\t\tinstanceTaskDB.setInstanceFlowId(\"1\");\n\t\tinstanceTaskDB.setFileId(8);\n\t\tinstanceTaskDB.setTaskType(TaskType.INSTANCE_START);\n\t\tinstanceTaskDB.setTaskStatus(TaskStatus.INIT);\n\t\tinstanceTaskDB.setCreateTime(new Date());\n\t\tentityList.add(instanceTaskDB);\n\t\tinstanceTaskDB = new InstanceTaskDB();\n\t\tinstanceTaskDB.setInstanceFlowId(\"1\");\n\t\tinstanceTaskDB.setFileId(9);\n\t\tinstanceTaskDB.setTaskType(TaskType.INSTANCE_START);\n\t\tinstanceTaskDB.setTaskStatus(TaskStatus.INIT);\n\t\tinstanceTaskDB.setCreateTime(new Date());\n\t\tentityList.add(instanceTaskDB);\n\t\tinstanceTaskDB = new InstanceTaskDB();\n\t\tinstanceTaskDB.setInstanceFlowId(\"1\");\n\t\tinstanceTaskDB.setFileId(10);\n\t\tinstanceTaskDB.setTaskType(TaskType.INSTANCE_START);\n\t\tinstanceTaskDB.setTaskStatus(TaskStatus.INIT);\n\t\tinstanceTaskDB.setCreateTime(new Date());\n\t\tentityList.add(instanceTaskDB);\n\t\tinstanceTaskDB = new InstanceTaskDB();\n\t\tinstanceTaskDB.setInstanceFlowId(\"1\");\n\t\tinstanceTaskDB.setFileId(11);\n\t\tinstanceTaskDB.setTaskType(TaskType.INSTANCE_START);\n\t\tinstanceTaskDB.setTaskStatus(TaskStatus.INIT);\n\t\tinstanceTaskDB.setCreateTime(new Date());\n\t\tentityList.add(instanceTaskDB);\n\t\tinstanceTaskDB = new InstanceTaskDB();\n\t\tinstanceTaskDB.setInstanceFlowId(\"1\");\n\t\tinstanceTaskDB.setFileId(12);\n\t\tinstanceTaskDB.setTaskType(TaskType.INSTANCE_START);\n\t\tinstanceTaskDB.setTaskStatus(TaskStatus.INIT);\n\t\tinstanceTaskDB.setCreateTime(new Date());\n\t\tentityList.add(instanceTaskDB);\n\t\tinstanceTaskDB = new InstanceTaskDB();\n\t\tinstanceTaskDB.setInstanceFlowId(\"1\");\n\t\tinstanceTaskDB.setFileId(13);\n\t\tinstanceTaskDB.setTaskType(TaskType.INSTANCE_START);\n\t\tinstanceTaskDB.setTaskStatus(TaskStatus.INIT);\n\t\tinstanceTaskDB.setCreateTime(new Date());\n\t\tentityList.add(instanceTaskDB);\n\t\tinstanceTaskDB = new InstanceTaskDB();\n\t\tinstanceTaskDB.setInstanceFlowId(\"1\");\n\t\tinstanceTaskDB.set", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "128709824_200", "part": [1, 1], "seq": [1, 1], "prompt": "class StringUtils {\n\n    public static String[] splitWithCommaOrSemicolon(String src) {\n        if (isEmpty(src)) {\n            return StringUtils.EMPTY_STRING_ARRAY;\n        }\n        String[] ss = split(src.replace(',', ';'), \";\");\n        List<String> list = new ArrayList<String>();\n        for (String s : ss) {\n            if (!isBlank(s)) {\n                list.add(s.trim());\n            }\n        }\n        return list.toArray(new String[list.size()]);\n    }\n\n    public static boolean isEmpty(CharSequence cs);\n    public static boolean isNotEmpty(CharSequence cs);\n    public static boolean isBlank(CharSequence cs);\n    public static boolean isNotBlank(CharSequence cs);\n    public static String trim(String str);\n    public static String trimToNull(String str);\n    public static String trimToEmpty(String str);\n    public static String toString(byte[] bytes, String charsetName);\n    public static String defaultString(final Object str);\n    public static String toString(Object o, String defaultVal);\n    public static String toString(Object o);\n    public static String objectsToString(Object[] args);\n    public static boolean equals(CharSequence s1, CharSequence s2);\n    public static String[] split(String src, String separator);\n    public static String join(String[] strings, String separator);\n    public static String joinWithComma(String... strings);\n    public static String substringAfter(String str, String separator);\n    public static String substringBefore(String str, String separator);\n\n}\n\nclass StringUtilsTest {\n\n    @Test\n    public void testSplitWithCommaOrSemicolon() throws Exception {\n", "reference": "        String[] s = StringUtils.splitWithCommaOrSemicolon(null);\n        Assert.assertTrue(CommonUtils.isEmpty(s));\n\n        s = StringUtils.splitWithCommaOrSemicolon(\"\");\n        Assert.assertTrue(CommonUtils.isEmpty(s));\n\n        s = StringUtils.splitWithCommaOrSemicolon(\"1\");\n        Assert.assertNotNull(s);\n        Assert.assertEquals(s.length, 1);\n\n        s = StringUtils.splitWithCommaOrSemicolon(\"1,\");\n        Assert.assertNotNull(s);\n        Assert.assertEquals(s.length, 1);\n\n        s = StringUtils.splitWithCommaOrSemicolon(\" 1,\");\n        Assert.assertNotNull(s);\n        Assert.assertEquals(s.length, 1);\n\n        s = StringUtils.splitWithCommaOrSemicolon(\" 1,2\");\n        Assert.assertNotNull(s);\n        Assert.assertEquals(s.length, 2);\n\n        s = StringUtils.splitWithCommaOrSemicolon(\" 1;2\");\n        Assert.assertNotNull(s);\n        Assert.assertEquals(s.length, 2);\n    }\n\n}", "prediction": "        assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, StringUtils.splitWithCommaOrSemicolon(\"a,b,c\"));\n        assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, StringUtils.splitWithCommaOrSemicolon(\"a;b;c\"));\n        assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, StringUtils.splitWithCommaOrSemicolon(\"a;b,c\"));\n        assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, StringUtils.splitWithCommaOrSemicolon(\"a,b;c\"));\n        assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, StringUtils.splitWithCommaOrSemicolon(\"a;b,c\"));\n        assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, StringUtils.splitWithCommaOrSemicolon(\"a,b;c\"));\n        assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, StringUtils.splitWithCommaOrSemicolon(\"a;b,c\"));\n        assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, StringUtils.splitWithCommaOrSemicolon(\"a,b;c\"));\n        assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, StringUtils.splitWithCommaOrSemicolon(\"a;b,c\"));\n        assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, StringUtils.splitWithCommaOrSemicolon(\"a,b;c\"));\n        assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, StringUtils.splitWithCommaOrSemicolon(\"a;b,c\"));\n        assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, StringUtils.splitWithCommaOrSemicolon(\"a,b;c\"));\n        assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, StringUtils.splitWithCommaOrSemicolon(\"a;b,c\"));\n        assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, StringUtils.splitWithCommaOrSemicolon(\"a,b;c\"));\n        assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, StringUtils.splitWithCommaOrSemicolon(\"a;b,c\"));\n        assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, StringUtils.splitWithCommaOrSemicolon(\"a,b;c\"));\n        assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, StringUtils.splitWithCommaOrSemicolon(\"a;b,c\"));\n        assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, StringUtils.splitWithCommaOrSemicolon(\"a,b;c\"));\n        assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, StringUtils.splitWithCommaOrSemicolon(\"a;b,c\"));\n        assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, StringUtils.splitWithCommaOrSemicolon(\"a,b;c\"));\n        assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, StringUtils.splitWithCommaOrSemicolon(\"a;b,c\"));\n        assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, StringUtils.splitWithCommaOrSemicolon(\"a,b;c\"));\n        assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, StringUtils.splitWithCommaOrSemicolon(\"a;b,c\"));\n        assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, StringUtils.splitWithCommaOrSemicolon(\"a,b;c\"));\n        assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, StringUtils.splitWithCommaOrSemicolon(\"a;b,c\"));\n        assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, StringUtils.splitWithCommaOrSemicolon(\"a,b;c\"));\n        assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, StringUtils.splitWithCommaOrSemicolon(\"a;b,c\"));\n        assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, StringUtils.splitWithCommaOrSemicolon(\"a,b;c\"));\n        assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, StringUtils.splitWithCommaOrSemicolon(\"a;b,c\"));\n        assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, StringUtils.splitWithCommaOrSemicolon(\"a,b;c\"));\n        assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, StringUtils.splitWithCommaOrSemicolon(\"a;b,c\"));\n        assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, StringUtils.splitWithCommaOrSemicolon(\"a,b;c\"));\n        assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, StringUtils.splitWithCommaOrSemicolon(\"a;b,c\"));\n        assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, StringUtils.splitWithCommaOrSemicolon(\"a,b;c\"));\n        assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, StringUtils.splitWithCommaOrSemicolon(\"a;b,c\"));\n        assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, StringUtils.splitWithCommaOrSemicolon(\"a,b;c\"));\n        assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, StringUtils.splitWithCommaOrSemicolon(\"a;b,c\"));\n        assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, StringUtils.splitWithCommaOrSemicolon(\"a,b;c\"));\n        assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, StringUtils.splitWithCommaOrSemicolon(\"a;b,c\"));\n        assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, StringUtils.splitWithCommaOrSemicolon(\"a,b;c\"));\n        assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, StringUtils.splitWithCommaOrSemicolon(\"a;b,c\"));\n        assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, StringUtils.splitWithCommaOrSemicolon(\"a,b;c\"));\n        assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, StringUtils.splitWithCommaOrSemicolon(\"a;b,c\"));\n        assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, StringUtils.splitWithCommaOrSemicolon(\"a,b;c\"));\n        assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, StringUtils.splitWithCommaOrSemicolon(\"a;b,c\"));\n        assertArrayEquals(new String[]{\"a\", \"b\", \"c\"},", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "128830029_7", "part": [1, 1], "seq": [1, 1], "prompt": "class PerPlayerMenuItem extends AbstractMenuItem {\n\n    @Override\n    public MenuIcon getIcon(IconRequest iconRequest) {\n        return iconRequestConsumer.apply(iconRequest);\n    }\n\n      PerPlayerMenuItem(Consumer<MenuItemClick> itemClickConsumer, Function<IconRequest, MenuIcon> iconRequestConsumer,\n                      Predicate<IconRequest> available);\n\n    @Mock\n    private MenuSession menuSession;\n    @Mock\n    private Player player;\n    @Mock\n    private MenuIcon icon;\n    @Spy Function<IconRequest, MenuIcon> iconRequestConsumer;\n    @Spy Predicate<IconRequest> availableListener;\n    private PerPlayerMenuItem menuItem;\n\n}\n\nclass PerPlayerMenuItemTest {\n\n    @Mock\n    private MenuSession menuSession;\n    @Mock\n    private Player player;\n    @Mock\n    private MenuIcon icon;\n    @Spy Function<IconRequest, MenuIcon> iconRequestConsumer;\n    @Spy Predicate<IconRequest> availableListener;\n    private PerPlayerMenuItem menuItem;\n\n    @Test\n    public void getIcon() {\n", "reference": "        IconRequest request = new IconRequest(player, menuSession);\n        MenuIcon icon = menuItem.getIcon(request);\n        assertEquals(this.icon, icon);\n    }\n\n}", "prediction": "        IconRequest iconRequest = new IconRequest(menuSession, player);\n        when(iconRequestConsumer.apply(iconRequest)).thenReturn(icon);\n        assertThat(menuItem.getIcon(iconRequest), is(icon));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "128915122_0", "part": [1, 1], "seq": [1, 1], "prompt": "class CoffeeShop {\n\n    @Scheduled(every = \"2s\")\n    public void processUnfinishedOrders() {\n        entityManager.createNamedQuery(Order.FIND_UNFINISHED, Order.class)\n                .getResultList()\n                .forEach(orderProcessor::processOrder);\n    }\n\n    public Set<CoffeeType> getCoffeeTypes();\n    public Set<Origin> getOrigins(final CoffeeType type);\n    public Origin getOrigin(String name);\n    public void createOrder(Order order);\n    public Order getOrder(UUID id);\n    public List<Order> getOrders();\n    public void updateOrder(UUID id, Order order);\n\n    private CoffeeShop testObject;\n\n}\n\nclass CoffeeShopTest {\n\n    private CoffeeShop testObject;\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    void testProcessUnfinishedOrders() {\n", "reference": "        List<Order> desiredOrders = TestData.unfinishedOrders();\n\n        TypedQuery mockQuery = mock(TypedQuery.class);\n        when(testObject.entityManager.createNamedQuery(Order.FIND_UNFINISHED, Order.class)).thenReturn(mockQuery);\n        when(mockQuery.getResultList()).thenReturn(desiredOrders);\n        ArgumentCaptor<Order> orderCaptor = ArgumentCaptor.forClass(Order.class);\n\n        testObject.processUnfinishedOrders();\n\n        verify(testObject.entityManager).createNamedQuery(Order.FIND_UNFINISHED, Order.class);\n        verify(testObject.orderProcessor, times(desiredOrders.size())).processOrder(orderCaptor.capture());\n\n        assertThat(orderCaptor.getAllValues()).containsExactlyElementsOf(desiredOrders);\n\n        orderCaptor.getAllValues().forEach(o -> assertThat(o).isPreparing());\n    }\n\n}", "prediction": "        final List<Order> orders = new ArrayList<>();\n        final Order order1 = new Order(UUID.randomUUID(), Coffee.COFFEE, Order.Status.INITIALIZED);\n        final Order order2 = new Order(UUID.randomUUID(), Coffee.COFFEE, Order.Status.INITIALIZED);\n        orders.add(order1);\n        orders.add(order2);\n        when(entityManager.createNamedQuery(Order.FIND_UNFINISHED, Order.class).getResultList()).thenReturn(orders);\n\n        testObject.processUnfinishedOrders();\n\n        verify(orderProcessor).processOrder(order1);\n        verify(orderProcessor).processOrder(order2);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "129125498_46", "part": [1, 1], "seq": [1, 1], "prompt": "class AnomalyConsumer {\n\n    public boolean process(KafkaConsumer kafkaConsumer, boolean continueProcessing) {\n        try {\n            ConsumerRecords<String, MappedMetricData> metricRecords = kafkaConsumer.poll(POLL_INTERVAL);\n            log.trace(\"Read {} metric records from topic={}\", metricRecords.count(), consumerConfig.getString(TOPIC));\n            anomaliesProcessor.processMetrics(metricRecords, executorService);\n        } catch (WakeupException e) {\n            kafkaConsumer.close();\n            continueProcessing = false;\n        } catch (Exception e) {\n            log.error(e.getLocalizedMessage());\n            e.printStackTrace();\n        }\n\n        return continueProcessing;\n    }\n\n    public  AnomalyConsumer();\n\n    public void listen();\n    @VisibleForTesting public void setKafkaConsumer(KafkaConsumer<String, MappedMetricData> kafkaConsumer);\n    @VisibleForTesting public void setExecutorService(ExecutorService executorService);\n    public AnomaliesProcessor getAnomaliesProcessor();\n\n    private KafkaConsumer<String, MappedMetricData> kafkaConsumer;\n    private ExecutorService executorService;\n    private AnomalyConsumer anomalyConsumer;\n\n}\n\nclass AnomalyConsumerTest {\n\n    private KafkaConsumer<String, MappedMetricData> kafkaConsumer;\n    private ExecutorService executorService;\n    private AnomalyConsumer anomalyConsumer;\n\n    @Test\n    public void testProcessZeroMetrics() {\n", "reference": "        ConsumerRecords<String, MappedMetricData> metricRecords = AnomaliesProcessorTest.buildMetricRecords(0,\n                AnomalyLevel.STRONG);\n        when(kafkaConsumer.poll(anyLong())).thenReturn(metricRecords);\n        assertTrue(anomalyConsumer.process(kafkaConsumer, true));\n\n    }\n\n}", "prediction": "        assertTrue(anomalyConsumer.process(kafkaConsumer, true));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "131678192_1", "part": [1, 1], "seq": [1, 1], "prompt": "class LwM2MImporter {\n\n\tpublic byte[] convert(InputStream fileInput) {\n\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n\t\tZipOutputStream zip = new ZipOutputStream(baos);\n\n\t\ttry {\n\t\t\tLWM2M lwm2m = parse(fileInput);\n\n\t\t\ttry {\n\t\t\t\tfor (LWM2M.Object obj : lwm2m.getObject()) {\n\n\t\t\t\t\tfinal ModelId modelId = createModelId(obj);\n\n\t\t\t\t\tZipEntry fbEntry = new ZipEntry(modelId.getName() + \".fbmodel\");\n\t\t\t\t\tzip.putNextEntry(fbEntry);\n\t\t\t\t\tzip.write(FB_TEMPLATE.create(obj, modelId).getBytes());\n\t\t\t\t\tzip.closeEntry();\n\n\t\t\t\t\tZipEntry mappingEntry = new ZipEntry(modelId.getName() + \".mapping\");\n\t\t\t\t\tzip.putNextEntry(mappingEntry);\n\t\t\t\t\tzip.write(MAPPING_TEMPLATE.create(obj, modelId).getBytes());\n\t\t\t\t\tzip.closeEntry();\n\t\t\t\t}\n\t\t\t} catch (Exception ex) {\n\t\t\t\tex.printStackTrace();\n\t\t\t} finally {\n\t\t\t\tif (zip != null) {\n\t\t\t\t\tzip.close();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn baos.toByteArray();\n\t\t} catch (Exception e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t} finally {\n\t\t\tif (baos != null) {\n\t\t\t\ttry {\n\t\t\t\t\tbaos.close();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic ValidationReport validate(InputStream fileInput);\n\tprivate LWM2M parse(InputStream fileInput);\n\tprivate ModelId createModelId(Object obj);\n\tprivate String parseId(String name);\n\n}\n\nclass LwM2MImporterTest {\n\n  @Test\n  public void testConversion()throws Exception {\n", "reference": "    final String filename = \"3328_1_1.xml\";\n    \n    InputStream lwm2mXml = Thread.currentThread().getContextClassLoader().getResourceAsStream(filename);    \n    \n    LwM2MImporter importer = new LwM2MImporter();\n    \n    byte[] convertedContent = importer.convert(lwm2mXml);\n    \n    ZipInputStream zis = new ZipInputStream(new ByteArrayInputStream(convertedContent));\n    ZipEntry entry = null;\n    \n    Map<String,byte[]> content = new HashMap<>();\n    while ((entry = zis.getNextEntry()) != null) {\n      ByteArrayOutputStream baos = new ByteArrayOutputStream();\n      IOUtils.copy(zis, baos);\n      content.put(entry.getName(),baos.toByteArray());\n    }\n    \n    assertEquals(2,content.keySet().size());\n    assertTrue(content.keySet().contains(\"Power.fbmodel\"));\n    assertTrue(content.keySet().contains(\"Power.mapping\"));\n    \n    System.out.println(new String(content.get(\"Power.fbmodel\")));\n    System.out.println(new String(content.get(\"Power.mapping\")));\n  }\n\n}", "prediction": "    LwM2MImporter importer = new LwM2MImporter();\n    byte[] result = importer.convert(getClass().getResourceAsStream(\"/lwm2m-1.0.zip\"));\n    assertNotNull(result);\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "132454935_45", "part": [1, 1], "seq": [1, 1], "prompt": "class AppContext implements Serializable {\n\n    public void setStrAddressMint(String strAddressMint) {\n        Util.check(!(strAddressMint==null || strAddressMint.isEmpty()), \"strAddressMint!=null\");\n        this.strAddressMint = strAddressMint;\n    }\n\n    public String getNodeName();\n    public void setNodeName(String nodeName);\n    public Integer getPort();\n    public void setPort(Integer port);\n    public String getMasterPeerIpAddress();\n    public void setMasterPeerIpAddress(String masterPeerIpAddress);\n    public Integer getMasterPeerPort();\n    public void setMasterPeerPort(Integer masterPeerPort);\n    public String getStorageBasePath();\n    public void setStorageBasePath(String storageBasePath);\n    public BootstrapType getBootstrapType();\n    public void setBootstrapType(BootstrapType bootstrapType);\n    public String getStrAddressMint();\n    public BigInteger getValueMint();\n    public void setPrivateKey(PrivateKey privateKey);\n    public PrivateKey getPrivateKey();\n    public List<String> getListNTPServers();\n\n     AppContext context;\n\n}\n\nclass AppContextTest {\n\n     AppContext context;\n\n    @Test\n    public void testSetStrAddressMint(){\n", "reference": "        String addressMint = \"path\";\n        context.setStrAddressMint(addressMint);\n        Assert.assertEquals(addressMint, context.getStrAddressMint());\n    }\n\n}", "prediction": "        context.setStrAddressMint(\"123\");\n        assertEquals(\"123\", context.getStrAddressMint());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "132660065_22", "part": [1, 1], "seq": [1, 1], "prompt": "class JsonNodeConverter implements NodeConverter {\n\n    @Override\n    public NormalizedNode<?, ?> deserialize(final SchemaNode schemaNode, final Reader inputData)\n            throws SerializationException {\n        NormalizedNodeResult result = new NormalizedNodeResult();\n        JSONCodecFactory jsonCodecFactory =\n                JSONCodecFactorySupplier.DRAFT_LHOTKA_NETMOD_YANG_JSON_02.createLazy(schemaContext);\n        try (JsonReader reader = new JsonReader(inputData);\n                NormalizedNodeStreamWriter streamWriter = ImmutableNormalizedNodeStreamWriter.from(result);\n\n                JsonParserStream jsonParser = JsonParserStream.create(streamWriter, jsonCodecFactory, schemaNode)) {\n            jsonParser.parse(reader);\n        } catch (IOException e) {\n            throw new SerializationException(e);\n        }\n        return result.getResult();\n    }\n\n    public  JsonNodeConverter(final SchemaContext schemaContext);\n\n    @Override public Writer serializeData(final SchemaNode schemaNode, final NormalizedNode<?, ?> normalizedNode);\n    @Override public Writer serializeRpc(final SchemaNode schemaNode, final NormalizedNode<?, ?> normalizedNode);\n\n    private static final Logger LOG;\n    private final NodeConverter bindingSerializer;\n\n}\n\nclass JsonNodeConverterTest  {\n\n    private static final Logger LOG;\n    private final NodeConverter bindingSerializer;\n\n    @Test\n    public void testDeserialize_in() throws Exception {\n", "reference": "        Optional<RpcDefinition> loadRpc = ConverterUtils.loadRpc(schemaContext, SIMPLE_IO_RPC_QNAME);\n        String loadIoRpcIn = loadResourceAsString(\"input-output-rpc-in.json\");\n        NormalizedNode<?, ?> deserializeRpc =\n                bindingSerializer.deserialize(loadRpc.get(), new StringReader(loadIoRpcIn));\n        Assert.assertNotNull(deserializeRpc);\n        LOG.info(deserializeRpc.toString());\n    }\n\n}", "prediction": "        SchemaContext schemaContext = SchemaContextFactory.create(\n                \"urn:ietf:params:xml:ns:yang:ietf-interfaces\",\n                \"src/test/resources/modules/ietf-interfaces.yang\");\n        SchemaNode schemaNode = schemaContext.getChild(\"interfaces\", \"ietf-interfaces\", \"2014-05-08\")\n                .getChild(\"interface\", \"ietf-interfaces\", \"2014-05-08\");\n        String json = \"{\\\"name\\\":\\\"eth0\\\",\\\"type\\\":\\\"iana-if-type:ethernetCsmacd\\\"}\";\n        NormalizedNode<?, ?> node = bindingSerializer.deserialize(schemaNode, new StringReader(json));\n        assertEquals(\"eth0\", node.getValue(schemaNode.getChild(\"name\", \"ietf-interfaces\", \"2014-05-08\")));\n        assertEquals(\"iana-if-type:ethernetCsmacd\",\n                node.getValue(schemaNode.getChild(\"type\", \"ietf-interfaces\", \"2014-05-08\")));\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "132759831_30", "part": [1, 1], "seq": [1, 1], "prompt": "class CinemaResponseToCinema {\n\n    public List<Cinema> map(CinemaResponse cinemaResponse) {\n        List<Cinema> cinemas = new ArrayList<>();\n        if (cinemaResponse.getCinemas() != null){\n            for (int i = 0; i < cinemaResponse.getCinemas().size(); i++){\n                final Cinema cinema = new Cinema();\n                final CinemaNetwork response = cinemaResponse.getCinemas().get(i);\n                cinema.setPage(cinemaResponse.getPage());\n                cinema.setTotalPages(cinemaResponse.getTotalPages());\n                cinema.setTotalResults(cinemaResponse.getTotalResults());\n                cinema.setId(response.getId());\n                cinema.setVoteAverage(response.getVoteAverage());\n                cinema.setTitle(response.getTitle());\n                cinema.setAdult(response.isAdult());\n                cinema.setDescription(response.getDescription());\n                cinema.setPosterUrl(response.getPosterUrl());\n                cinema.setReleaseDate(response.getReleaseDate());\n                cinema.setPopularity(response.getPopularity());\n                cinema.setGenres(response.getGenreIds());\n                cinemas.add(cinema);\n            }\n        }\n        return cinemas;\n    }\n\n    public Cinema map(CinemaDetailResponse response);\n    private void setGenres(CinemaDetailResponse response , Cinema cinema);\n    private void setActors(CinemaDetailResponse response , Cinema cinema);\n    private void setDirectorName(CinemaDetailResponse response , Cinema cinema);\n    private void setPosters(CinemaDetailResponse response , Cinema cinema);\n\n    @Mock private CinemaDetailResponse cinemaDetailResponseMock;\n    @Mock private CinemaResponse cinemaResponseMock;\n    @Mock private List<CinemaNetwork> cinemaNetworkListMock;\n    @Mock private Iterator<CinemaNetwork> cinemaNetworkIteratorMock;\n    private CinemaResponseToCinema mapper;\n\n}\n\nclass CinemaResponseToCinemaTest  {\n\n    @Mock private CinemaDetailResponse cinemaDetailResponseMock;\n    @Mock private CinemaResponse cinemaResponseMock;\n    @Mock private List<CinemaNetwork> cinemaNetworkListMock;\n    @Mock private Iterator<CinemaNetwork> cinemaNetworkIteratorMock;\n    private CinemaResponseToCinema mapper;\n\n    @Test\n    public void shouldMapId(){\n", "reference": "        doReturn(77).when(cinemaDetailResponseMock).getId();\n\n        final Cinema cinema = mapper.map(cinemaDetailResponseMock);\n        assertThat(cinema.getId() , is(cinemaDetailResponseMock.getId()));\n    }\n\n}", "prediction": "        when(cinemaResponseMock.getCinemas()).thenReturn(cinemaNetworkListMock);\n        when(cinemaNetworkListMock.iterator()).thenReturn(cinemaNetworkIteratorMock);\n        when(cinemaNetworkIteratorMock.hasNext()).thenReturn(true).thenReturn(false);\n        when(cinemaNetworkIteratorMock.next()).thenReturn(cinemaNetworkMock);\n        when(cinemaNetworkMock.getId()).thenReturn(1);\n\n        Cinema cinema = mapper.map(cinemaResponseMock);\n\n        assertThat(cinema.getId(), is(1));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "134164777_6", "part": [1, 1], "seq": [1, 1], "prompt": "class TrieTree {\n\n    public List<String> prefixSearch(String key) {\n        List<String> value = new ArrayList<String>();\n        if (StringUtil.isEmpty(key)) {\n            return value;\n        }\n\n        char k = key.charAt(0);\n        int index;\n        if (Character.isUpperCase(k)) {\n            index = k - UPPERCASE_STAR;\n        } else {\n            index = k - LOWERCASE_STAR;\n\n        }\n        if (root.children != null && root.children[index] != null) {\n            return query(root.children[index], value,\n                    key.substring(1), String.valueOf(k));\n        }\n        return value;\n    }\n\n    public  TrieTree();\n\n    public void insert(String data);\n    private void insert(Node root, String data);\n    private List<String> query(Node child, List<String> value, String key, String result);\n    public List<String> all();\n    public List<String> depth(Node node, List<String> list, char[] chars, int index);\n\n}\n\nclass TrieTreeTest {\n\n    @Test\n    public void prefixSearch8() throws Exception {\n", "reference": "        TrieTree trieTree = new TrieTree();\n\n        List<String> ab = trieTree.prefixSearch(\"\");\n        String result = \"\";\n        for (String s : ab) {\n            result += s + \",\";\n            System.out.println(s);\n        }\n        Assert.assertTrue(result.equals(\"\"));\n    }\n\n}", "prediction": "        TrieTree trieTree = new TrieTree();\n        trieTree.insert(\"apple\");\n        trieTree.insert(\"app\");\n        trieTree.insert(\"appl\");\n        trieTree.insert(\"apples\");\n        trieTree.insert(\"applesauce\");\n        trieTree.insert(\"applesauce1\");\n        trieTree.insert(\"applesauce2\");\n        trieTree.insert(\"applesauce3\");\n        trieTree.insert(\"applesauce4\");\n        trieTree.insert(\"applesauce5\");\n        trieTree.insert(\"applesauce6\");\n        trieTree.insert(\"applesauce7\");\n        trieTree.insert(\"applesauce8\");\n        trieTree.insert(\"applesauce9\");\n        trieTree.insert(\"applesauce10\");\n        trieTree.insert(\"applesauce11\");\n        trieTree.insert(\"applesauce12\");\n        trieTree.insert(\"applesauce13\");\n        trieTree.insert(\"applesauce14\");\n        trieTree.insert(\"applesauce15\");\n        trieTree.insert(\"applesauce16\");\n        trieTree.insert(\"applesauce17\");\n        trieTree.insert(\"applesauce18\");\n        trieTree.insert(\"applesauce19\");\n        trieTree.insert(\"applesauce20\");\n        trieTree.insert(\"applesauce21\");\n        trieTree.insert(\"applesauce22\");\n        trieTree.insert(\"applesauce23\");\n        trieTree.insert(\"applesauce24\");\n        trieTree.insert(\"applesauce25\");\n        trieTree.insert(\"applesauce26\");\n        trieTree.insert(\"applesauce27\");\n        trieTree.insert(\"applesauce28\");\n        trieTree.insert(\"applesauce29\");\n        trieTree.insert(\"applesauce30\");\n        trieTree.insert(\"applesauce31\");\n        trieTree.insert(\"applesauce32\");\n        trieTree.insert(\"applesauce33\");\n        trieTree.insert(\"applesauce34\");\n        trieTree.insert(\"applesauce35\");\n        trieTree.insert(\"applesauce36\");\n        trieTree.insert(\"applesauce37\");\n        trieTree.insert(\"applesauce38\");\n        trieTree.insert(\"applesauce39\");\n        trieTree.insert(\"applesauce40\");\n        trieTree.insert(\"applesauce41\");\n        trieTree.insert(\"applesauce42\");\n        trieTree.insert(\"applesauce43\");\n        trieTree.insert(\"applesauce44\");\n        trieTree.insert(\"applesauce45\");\n        trieTree.insert(\"applesauce46\");\n        trieTree.insert(\"applesauce47\");\n        trieTree.insert(\"applesauce48\");\n        trieTree.insert(\"applesauce49\");\n        trieTree.insert(\"applesauce50\");\n        trieTree.insert(\"applesauce51\");\n        trieTree.insert(\"applesauce52\");\n        trieTree.insert(\"applesauce53\");\n        trieTree.insert(\"applesauce54\");\n        trieTree.insert(\"applesauce55\");\n        trieTree.insert(\"applesauce56\");\n        trieTree.insert(\"applesauce57\");\n        trieTree.insert(\"applesauce58\");\n        trieTree.insert(\"applesauce59\");\n        trieTree.insert(\"applesauce60\");\n        trieTree.insert(\"applesauce61\");\n        trieTree.insert(\"applesauce62\");\n        trieTree.insert(\"applesauce63\");\n        trieTree.insert(\"applesauce64\");\n        trieTree.insert(\"applesauce65\");\n        trieTree.insert(\"applesauce66\");\n        trieTree.insert(\"applesauce67\");\n        trieTree.insert(\"applesauce68\");\n        trieTree.insert(\"applesauce69\");\n        trieTree.insert(\"applesauce70\");\n        trieTree.insert(\"applesauce71\");\n        trieTree.insert(\"applesauce72\");\n        trieTree.insert(\"applesauce73\");\n        trieTree.insert(\"applesauce74\");\n        trieTree.insert(\"applesauce75\");\n        trieTree.insert(\"applesauce76\");\n        trieTree.insert(\"applesauce77\");\n        trieTree.insert(\"applesauce78\");\n        trieTree.insert(\"applesauce79\");\n        trieTree.insert(\"applesauce80\");\n        trieTree.insert(\"applesauce81\");\n        trieTree.insert(\"applesauce82\");\n        trieTree.insert(\"applesauce83\");\n        trieTree.insert(\"applesauce84\");\n        trieTree.insert(\"applesauce85\");\n        trieTree.insert(\"applesauce86\");\n        trieTree.insert(\"applesauce87\");\n        trieTree.insert(\"applesauce88\");\n        trieTree.insert(\"applesauce89\");\n        trieTree.insert(\"applesauce90\");\n        trieTree.insert(\"applesauce91\");\n        trieTree.insert(\"", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "134616422_1", "part": [1, 1], "seq": [1, 1], "prompt": "class CaseConverter {\n\n    public static String toCase(String name, Case targetCase) {\n        return nameCase(name).convertTo(name, targetCase);\n    }\n\n    private  CaseConverter();\n\n    private static Case nameCase(String name);\n\n}\n\nclass CaseConverterTest {\n\n    @Test\n    public void convertFromKebabCase() {\n", "reference": "        assertThat(CaseConverter.toCase(\"foo-bar-baz\", CaseConverter.Case.LOWER_CAMEL_CASE))\n                .isEqualTo(\"fooBarBaz\");\n        assertThat(CaseConverter.toCase(\"foo-bar-baz\", CaseConverter.Case.SNAKE_CASE))\n                .isEqualTo(\"foo_bar_baz\");\n    }\n\n}", "prediction": "        assertEquals(\"FooBar\", CaseConverter.toCase(\"foo-bar\", Case.Pascal));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "134901097_12", "part": [1, 1], "seq": [1, 1], "prompt": "class AbstractBearerTokenExtractor {\n\n    public String getBearerToken() {\n        final String tokenHeaderName = authContextInfo.getTokenHeader();\n        final boolean fallbackToHeader = authContextInfo.isAlwaysCheckAuthorization();\n        AuthLogging.log.tokenHeaderName(tokenHeaderName);\n\n        final String bearerValue;\n\n        if (COOKIE_HEADER.equals(tokenHeaderName)) {\n            String intermediateBearerValue = getBearerTokenCookie();\n            if (intermediateBearerValue == null && fallbackToHeader) {\n                bearerValue = getBearerTokenAuthHeader();\n            } else {\n                bearerValue = intermediateBearerValue;\n            }\n        } else if (AUTHORIZATION_HEADER.equals(tokenHeaderName)) {\n            bearerValue = getBearerTokenAuthHeader();\n        } else {\n            String customHeaderValue = getHeaderValue(tokenHeaderName);\n\n            if (customHeaderValue == null) {\n                AuthLogging.log.headerIsNull(tokenHeaderName);\n            } else {\n                String customHeaderSchemeValue = getTokenWithConfiguredScheme(customHeaderValue);\n                if (customHeaderSchemeValue != null) {\n                    customHeaderValue = customHeaderSchemeValue;\n                }\n            }\n            bearerValue = customHeaderValue;\n        }\n\n        return bearerValue;\n    }\n\n    protected  AbstractBearerTokenExtractor(JWTAuthContextInfo authContextInfo);\n\n    private String getBearerTokenCookie();\n    private String getBearerTokenAuthHeader();\n    private String getTokenWithConfiguredScheme(String tokenHeader);\n    private static boolean isTokenScheme(String headerValue, String schemePrefix);\n    protected abstract String getHeaderValue(String headerName);\n    protected abstract String getCookieValue(String cookieName);\n\n    private static final String AUTHORIZATION;\n    private static final String COOKIE;\n    private static final List<String> BEARER_SCHEME;\n    @Mock JWTAuthContextInfo authContextInfo;\n     AbstractBearerTokenExtractor target;\n\n}\n\nclass AbstractBearerTokenExtractorTest {\n\n    private static final String AUTHORIZATION;\n    private static final String COOKIE;\n    private static final List<String> BEARER_SCHEME;\n    @Mock JWTAuthContextInfo authContextInfo;\n     AbstractBearerTokenExtractor target;\n\n    @Test\n    public void testGetBearerTokenFallbackToHeaderWithCookieHeader() {\n", "reference": "        when(authContextInfo.getTokenHeader()).thenReturn(COOKIE);\n        when(authContextInfo.isAlwaysCheckAuthorization()).thenReturn(true);\n        AbstractBearerTokenExtractor target = newTarget(h -> \"Bearer THE_HEADER_TOKEN\", c -> \"THE_COOKIE_TOKEN\");\n        String bearerToken = target.getBearerToken();\n        assertEquals(\"THE_COOKIE_TOKEN\", bearerToken);\n    }\n\n}", "prediction": "        String cookieValue = \"cookieValue\";\n        String authHeaderValue = \"authHeaderValue\";\n        when(authContextInfo.getTokenHeader()).thenReturn(COOKIE);\n        when(authContextInfo.isAlwaysCheckAuthorization()).thenReturn(true);\n        when(target.getCookieValue(COOKIE)).thenReturn(cookieValue);\n        when(target.getBearerTokenAuthHeader()).thenReturn(authHeaderValue);\n\n        String bearerToken = target.getBearerToken();\n\n        assertEquals(authHeaderValue, bearerToken);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "135978112_8", "part": [1, 1], "seq": [1, 1], "prompt": "class JsonConverter implements Converter {\n\n    @Override\n    public SchemaAndValue toConnectData(String topic, byte[] value) {\n        JsonNode jsonValue;\n        try {\n            jsonValue = deserializer.deserialize(topic, value);\n        } catch (SerializationException e) {\n            throw new DataException(\"Converting byte[] to Kafka Connect data failed due to serialization error: \", e);\n        }\n\n        if (enableSchemas && (jsonValue == null || !jsonValue.isObject() || jsonValue.size() != 2 || !jsonValue.has(\"schema\") || !jsonValue.has(\"payload\")))\n            throw new DataException(\"JsonDeserializer with schemas.enable requires \\\"schema\\\" and \\\"payload\\\" fields and may not contain additional fields\");\n\n        // The deserialized data should either be an envelope object containing the schema and the payload or the schema\n        // was stripped during serialization and we need to fill in an all-encompassing schema.\n        if (!enableSchemas) {\n            ObjectNode envelope = JsonNodeFactory.instance.objectNode();\n            envelope.set(\"schema\", null);\n            envelope.set(\"payload\", jsonValue);\n            jsonValue = envelope;\n        }\n\n        return jsonToConnect(jsonValue);\n    }\n\n    private static Object checkOptionalAndDefault(Schema schema);\n    @Override public void configure(Map<String, ?> configs, boolean isKey);\n    @Override public byte[] fromConnectData(String topic, Schema schema, Object value);\n    private SchemaAndValue jsonToConnect(JsonNode jsonValue);\n    private ObjectNode asJsonSchema(Schema schema);\n    private Schema asConnectSchema(JsonNode jsonSchema);\n    private JsonNode convertToJsonWithEnvelope(Schema schema, Object value);\n    private JsonNode convertToJsonWithoutEnvelope(Schema schema, Object value);\n    private static JsonNode convertToJson(Schema schema, Object logicalValue);\n    private static Object convertToConnect(Schema schema, JsonNode jsonValue);\n\n    private static final String TOPIC;\n     ObjectMapper objectMapper;\n     JsonConverter converter;\n\n}\n\nclass JsonConverterTest {\n\n    private static final String TOPIC;\n     ObjectMapper objectMapper;\n     JsonConverter converter;\n\n    @Test\n    public void bytesToConnect() throws UnsupportedEncodingException {\n", "reference": "        ByteBuffer reference = ByteBuffer.wrap(\"test-string\".getBytes(\"UTF-8\"));\n        String msg = \"{ \\\"schema\\\": { \\\"type\\\": \\\"bytes\\\" }, \\\"payload\\\": \\\"dGVzdC1zdHJpbmc=\\\" }\";\n        SchemaAndValue schemaAndValue = converter.toConnectData(TOPIC, msg.getBytes());\n        ByteBuffer converted = ByteBuffer.wrap((byte[]) schemaAndValue.value());\n        assertEquals(reference, converted);\n    }\n\n}", "prediction": "        SchemaAndValue result = converter.toConnectData(TOPIC, \"{\\\"schema\\\":\\\"string\\\",\\\"payload\\\":\\\"test\\\"}\".getBytes(\"UTF-8\"));\n        assertEquals(Schema.STRING_SCHEMA, result.schema());\n        assertEquals(\"test\", result.value());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "137522340_0", "part": [1, 1], "seq": [1, 1], "prompt": "class ContentUriModel {\n\n    @Override\n    public String toString() {\n        return PREFIX + server + \"/\" + mediaId;\n    }\n\n    public  ContentUriModel(String server, String mediaId);\n\n    public String getServer();\n    public String getMediaId();\n    public static ContentUriModel valueOf(String uri);\n\n}\n\nclass ContentUriModelTest {\n\n    @Test\n    public void toStringTest() {\n", "reference": "        ContentUriModel model = new ContentUriModel(\"ru-matrix.org\", \"123\");\n        assertEquals(\"mxc://ru-matrix.org/123\", model.toString());\n    }\n\n}", "prediction": "        ContentUriModel model = new ContentUriModel(\"server\", \"mediaId\");\n        assertEquals(\"content://server/mediaId\", model.toString());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "137736536_4", "part": [1, 1], "seq": [1, 1], "prompt": "class GetEidLpadWorker implements LpadWorker<LpadWorkerExchange<String>, String> {\n\n    public String run(final LpadWorkerExchange<String> lpadWorkerExchange) {\n\n        progress.setTotalSteps(3);\n        progress.stepExecuted(ProgressStep.GET_EID_RETRIEVING, \"getEID retrieving...\");\n\n        inputValidation(lpadWorkerExchange == null, \"Lpa dWorker Exchange must be provided\");\n        inputValidation(StringUtils.isBlank(lpadWorkerExchange.getBody()), \"EID APDU must be provided\");\n\n        logDebug(\"EID APDU: \" + lpadWorkerExchange);\n\n\n        String eidapduResponseStr = apduChannel.transmitAPDU(lpadWorkerExchange.getBody());\n\n        logDebug(\"Response: \" + eidapduResponseStr);\n\n        return convertGetEuiccData(eidapduResponseStr, progress);\n    }\n\n    public  GetEidLpadWorker(final Progress progress,\n                            final ApduChannel apduChannel);\n\n    private String convertGetEuiccData(final String eidapduResponseStr,\n                                       final Progress progress);\n    private void logDebug(final String errorMessage);\n    private void inputValidation(final boolean invalidCondition, final String errorMessage);\n\n    private GetEidLpadWorker getIdWorker;\n    @Mock\n    private Progress mockProgress;\n    @Mock\n    private ApduChannel mockApduChannel;\n\n}\n\nclass GetEidLpadWorkerTest {\n\n    private GetEidLpadWorker getIdWorker;\n    @Mock\n    private Progress mockProgress;\n    @Mock\n    private ApduChannel mockApduChannel;\n\n    @Test(expected = RuntimeException.class)\n    public void shouldThrowRuntimeExceptionWhenEidApduIsNull() {\n", "reference": "        getIdWorker.run(buildStringLpadWorkerExchange(null));\n    }\n\n}", "prediction": "        getIdWorker.run(new LpadWorkerExchange<String>(null));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "139009007_65", "part": [1, 1], "seq": [1, 1], "prompt": "class FlatMapIterableStageFactory implements ProcessingStageFactory<Stage.FlatMapIterable> {\n\n    @Override\n    public <I, O> ProcessingStage<I, O> create(Engine engine, Stage.FlatMapIterable stage) {\n        Function<I, Iterable<O>> mapper = Casts.cast(stage.getMapper());\n        return new FlatMapIterable<>(mapper);\n    }\n\n    private final FlatMapIterableStageFactory factory;\n    private final ExecutorService executor;\n\n}\n\nclass FlatMapIterableStageFactoryTest  {\n\n    private final FlatMapIterableStageFactory factory;\n    private final ExecutorService executor;\n\n    @Test\n    public void create() throws ExecutionException, InterruptedException {\n", "reference": "        Flowable<Integer> flowable = Flowable.fromArray(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n                .subscribeOn(Schedulers.computation());\n\n        List<String> list = ReactiveStreams.fromPublisher(flowable)\n                .filter(i -> i < 4)\n                .flatMapIterable(this::duplicate)\n                .flatMapCompletionStage(this::asString)\n                .toList()\n                .run().toCompletableFuture().get();\n\n        assertThat(list).containsExactly(\"1\", \"1\", \"2\", \"2\", \"3\", \"3\");\n    }\n\n}", "prediction": "        List<Integer> input = Arrays.asList(1, 2, 3);\n        List<Integer> expected = Arrays.asList(1, 1, 2, 2, 3, 3);\n        List<Integer> actual = new ArrayList<>();\n        ProcessingStage<Integer, Integer> stage = factory.create(new Engine(), new Stage.FlatMapIterable(i -> Arrays.asList(i, i)));\n        stage.process(input, actual::addAll);\n        assertEquals(expected, actual);\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "139111229_0", "part": [1, 1], "seq": [1, 1], "prompt": "class CHexConvert {\n\n    public static byte[] hexStr2Bytes(String src){  \n        src = src.trim().replace(\" \", \"\").toUpperCase(Locale.US);  \n \n        int m=0,n=0;  \n        int iLen=src.length()/2;  \n        byte[] ret = new byte[iLen];  \n          \n        for (int i = 0; i < iLen; i++){  \n            m=i*2+1;  \n            n=m+1;  \n            ret[i] = (byte)(Integer.decode(\"0x\"+ src.substring(i*2, m) + src.substring(m,n)) & 0xFF);  \n        }  \n        return ret;  \n    }\n\n}\n\nclass CHexConvertTest  {\n\n    @Test\n    public void testCHextConvert(){\n", "reference": "        byte[] output = CHexConvert.hexStr2Bytes(\"3132333435363738393031323334353637383931\");\n        byte[] expect = {49, 50, 51, 52, 53, 54, 55, 56, 57, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 49};\n\n        assertEquals(expect.length, output.length);\n        for(int i=0; i<expect.length; i++)\n            assertEquals(expect[i], output[i]);\n    }\n\n}", "prediction": "       String src = \"0123456789ABCDEF\";\n        byte[] bytes = CHexConvert.hexStr2Bytes(src);\n        String str = CHexConvert.bytes2HexStr(bytes);\n        Assert.assertEquals(src, str);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "141680627_89", "part": [1, 1], "seq": [1, 1], "prompt": "class SpeedFormatterUtil {\n\n    public static int format(final double metersPerSecond, final UnitSystem system) {\n        SpeedConverter speedConverter = new SpeedConverter();\n        Measurement speedMeterPerSecond = new Measurement(metersPerSecond,\n                MeasurementUnit.METERS_PER_SECOND);\n        double ret;\n        switch (system) {\n            case IMPERIAL_UK:\n            case IMPERIAL_US:\n                ret = speedConverter.convert(speedMeterPerSecond.getValue(),\n                        speedMeterPerSecond.getUnit(), MeasurementUnit.MILES_PER_HOUR).getValue();\n                break;\n            case METRIC:\n            default: // metric\n                ret = speedConverter.convert(speedMeterPerSecond.getValue(),\n                        speedMeterPerSecond.getUnit(), MeasurementUnit.KILOMETERS_PER_HOUR).getValue();\n                break;\n        }\n        return (int) Math.round(ret);\n    }\n\n    private  SpeedFormatterUtil();\n\n    public static String getUnitString(final Context context, final UnitSystem system);\n\n    private static final double METERS_PER_SECOND_SPEED;\n    private static final double KILOMETERS_PER_HOUR_SPEED;\n    private static final double MILES_PER_HOUR_SPEED;\n\n}\n\nclass SpeedFormatterUtilTest  {\n\n    private static final double METERS_PER_SECOND_SPEED;\n    private static final double KILOMETERS_PER_HOUR_SPEED;\n    private static final double MILES_PER_HOUR_SPEED;\n\n    @Test\n    public void testFormat() {\n", "reference": "        assertEquals(\n                SpeedFormatterUtil.format(METERS_PER_SECOND_SPEED, UnitSystem.METRIC),\n                (int) KILOMETERS_PER_HOUR_SPEED);\n        assertEquals(\n                SpeedFormatterUtil.format(METERS_PER_SECOND_SPEED, UnitSystem.IMPERIAL_UK),\n                (int) MILES_PER_HOUR_SPEED);\n        assertEquals(\n                SpeedFormatterUtil.format(METERS_PER_SECOND_SPEED, UnitSystem.IMPERIAL_US),\n                (int) MILES_PER_HOUR_SPEED);\n    }\n\n}", "prediction": "        assertEquals(10, SpeedFormatterUtil.format(METERS_PER_SECOND_SPEED, UnitSystem.METRIC));\n        assertEquals(10, SpeedFormatterUtil.format(KILOMETERS_PER_HOUR_SPEED, UnitSystem.METRIC));\n        assertEquals(10, SpeedFormatterUtil.format(MILES_PER_HOUR_SPEED, UnitSystem.METRIC));\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "142194679_0", "part": [1, 1], "seq": [1, 1], "prompt": "class SharedUtilities {\n\n  static boolean compareReferenceToId(String reference, String id) {\n    String[] refParts = reference.split(\"/\");\n    String[] idParts = id.split(\"/\");\n    if (refParts.length > idParts.length) {\n      return refParts[1].equals(idParts[0]);\n    } else if (refParts.length < idParts.length) {\n      return refParts[0].equals(idParts[1]);\n    } else { // same length\n      if (refParts.length == 1) {\n        return refParts[0].equals(idParts[0]);\n      } else {\n        return refParts[0].equals(idParts[0]) && refParts[1].equals(idParts[1]);\n      }\n    }\n  }\n\n  public static int calculateAge(Date birthDate);\n\n}\n\nclass SharedUtilitiesTest {\n\n  @Test\n  public void testCompareReferenceToId() {\n", "reference": "    assertTrue(SharedUtilities.compareReferenceToId(\"Patient/1234\", \"1234\"));\n    assertTrue(SharedUtilities.compareReferenceToId(\"1234\", \"Patient/1234\"));\n    assertTrue(SharedUtilities.compareReferenceToId(\"1234\", \"1234\"));\n    assertTrue(SharedUtilities.compareReferenceToId(\"Patient/1234\", \"Patient/1234\"));\n\n    assertFalse(SharedUtilities.compareReferenceToId(\"Patient/1234\", \"4321\"));\n    assertFalse(SharedUtilities.compareReferenceToId(\"1234\", \"Patient/4321\"));\n    assertFalse(SharedUtilities.compareReferenceToId(\"1234\", \"4321\"));\n    assertFalse(SharedUtilities.compareReferenceToId(\"Patient/1234\", \"Patient/4321\"));\n\n    assertFalse(SharedUtilities.compareReferenceToId(\"Patient/1234\", \"Practitioner/1234\"));\n    assertFalse(SharedUtilities.compareReferenceToId(\"Patient/1234\", \"Practitioner/4321\"));\n  }\n\n}", "prediction": "    assertTrue(SharedUtilities.compareReferenceToId(\"Patient/123\", \"Patient/123\"));\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "142603842_63", "part": [1, 1], "seq": [1, 1], "prompt": "class WebSocketController {\n\n    @MessageMapping(\"/vehicle/{id}/delete\")\n    void removeVehicle(@DestinationVariable long id) {\n        vehicleService.removeVehicle(id);\n    }\n\n    @Autowired  WebSocketController(\n            RouteListener routeListener,\n            RegionService regionService,\n            LocationService locationService,\n            VehicleService vehicleService,\n            DemoService demoService,\n            ApplicationEventPublisher eventPublisher);\n\n    @MessageExceptionHandler void handleException(Exception exception);\n    @SubscribeMapping(\"/serverInfo\") ServerInfo subscribeToServerInfoTopic();\n    @SubscribeMapping(\"/route\") PortableRoutingPlan subscribeToRouteTopic();\n    @MessageMapping(\"/location\") void addLocation(PortableLocation request);\n    @MessageMapping(\"/location/{id}/delete\") void removeLocation(@DestinationVariable long id);\n    @MessageMapping(\"/demo/{name}\") void demo(@DestinationVariable String name);\n    @MessageMapping(\"/clear\") void clear();\n    @MessageMapping(\"vehicle\") void addVehicle();\n    @MessageMapping(\"/vehicle/deleteAny\") void removeAnyVehicle();\n    @MessageMapping(\"/vehicle/{id}/capacity\") void changeCapacity(@DestinationVariable long id, int capacity);\n\n    @Mock\n    private RouteListener routeListener;\n    @Mock\n    private RegionService regionService;\n    @Mock\n    private LocationService locationService;\n    @Mock\n    private VehicleService vehicleService;\n    @Mock\n    private DemoService demoService;\n    @Mock\n    private ApplicationEventPublisher eventPublisher;\n    @InjectMocks\n    private WebSocketController webSocketController;\n\n}\n\nclass WebSocketControllerTest {\n\n    @Mock\n    private RouteListener routeListener;\n    @Mock\n    private RegionService regionService;\n    @Mock\n    private LocationService locationService;\n    @Mock\n    private VehicleService vehicleService;\n    @Mock\n    private DemoService demoService;\n    @Mock\n    private ApplicationEventPublisher eventPublisher;\n    @InjectMocks\n    private WebSocketController webSocketController;\n\n    @Test\n    void removeVehicle() {\n", "reference": "        webSocketController.removeVehicle(11L);\n        verify(vehicleService).removeVehicle(11);\n    }\n\n}", "prediction": "        webSocketController.removeVehicle(1L);\n        verify(vehicleService).removeVehicle(1L);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "142944814_232", "part": [1, 1], "seq": [1, 1], "prompt": "class SystemPropertiesConfiguration extends AbstractConfiguration implements Configuration {\n\n  @Override\n  public Configuration getSubconfiguration(final String key) {\n    final String prefix = key + \".\";\n    final InMemoryConfiguration subconfiguration = new InMemoryConfiguration();\n\n    Set<String> stringProperties = getProperties().stringPropertyNames();\n    for (final String name : stringProperties) {\n      if (name.startsWith(prefix)) {\n        final String subname = name.substring(prefix.length());\n        subconfiguration.define(subname, getProperty(name));\n      }\n    }\n    return subconfiguration;\n  }\n\n  @SuppressWarnings(\"unchecked\") @Override public Map<String, Object> asMap();\n  @Override public void define(final String key, final Object value);\n  @Override public Object getValue(final String key);\n  @Override public void remove(final String key);\n\n}\n\nclass SystemPropertiesConfigurationTest extends AbstractConfiguration {\n\n  @Test\n  public void testGetSubConfiguration() {\n", "reference": "    final SystemPropertiesConfiguration configuration = new SystemPropertiesConfiguration();\n    final Configuration subConfiguration =\n        configuration.getSubconfiguration(randomUUID().toString());\n    assertNotNull(subConfiguration);\n  }\n\n}", "prediction": "    final InMemoryConfiguration subconfiguration = new InMemoryConfiguration();\n    subconfiguration.define(\"key\", \"value\");\n    final InMemoryConfiguration configuration = new InMemoryConfiguration();\n    configuration.define(\"sub\", subconfiguration);\n    final Configuration sub = configuration.getSubconfiguration(\"sub\");\n    assertEquals(\"value\", sub.getValue(\"key\"));\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "144251992_258", "part": [1, 1], "seq": [1, 1], "prompt": "class HibernateSimpleQueryUtils {\n\n    static List<Pair<Integer, Integer>> getReplaceableTermsOfQuery(String simpleQuery) {\n        var termIndexPairs = new ArrayList<Pair<Integer, Integer>>();\n        var queryCharCount = simpleQuery.length();\n\n        var index = 0;\n        while(index >= 0 && index < queryCharCount) {\n            var currentChar = simpleQuery.charAt(index);\n\n            // skip term delimiters\n            if(TERM_DELIMITER.contains(currentChar)) {\n                index++;\n                continue;\n            }\n\n            // ignore phrase terms and near operators\n            if(currentChar == '\"') {\n                index = getIndexAfterPhraseTerm(index, simpleQuery);\n                continue;\n            }\n\n            var nextSpecialCharIndex = getIndexOfFirstAppearanceOfAny(index, SPECIAL_CHARACTERS, simpleQuery);\n            var nextTermDelimiterIndex = getIndexOfFirstAppearanceOfAny(index, TERM_DELIMITER, simpleQuery);\n\n            // no term delimiter found after the current term\n            if(nextTermDelimiterIndex < 0) {\n                nextTermDelimiterIndex = queryCharCount;\n            }\n            var termEndIndex = nextTermDelimiterIndex - 1;\n\n            // when a term delimiter is present and the term is not a fuzzy or prefix term add\n            // the pair -> ignore fuzzy and prefix terms\n            var isSimpleTerm = nextSpecialCharIndex < 0 || nextTermDelimiterIndex < nextSpecialCharIndex;\n            if(isSimpleTerm) {\n                termIndexPairs.add(Pair.of(index, termEndIndex));\n\n                index = nextTermDelimiterIndex + 1;\n            } else {\n                // skip this term\n                index = getIndexAfterFirstAppearanceOfAny(nextSpecialCharIndex, TERM_DELIMITER, simpleQuery);\n            }\n        }\n\n        return termIndexPairs;\n    }\n\n    public static String makeQueryPrefixAndFuzzy(@NonNull String simpleQuery);\n    static String replaceTermWithFuzzyAndPrefixDisjunction(Pair<Integer, Integer> startEndIndexPair, String simpleQuery);\n    static String replaceSubstring(Pair<Integer, Integer> startEndIndexPair, String stringToReplaceIn, String replacement);\n    static int getIndexAfterFirstAppearanceOfAny(int startIndex, Set<Character> characters, String searchedString);\n    static int getIndexAfterFirstAppearanceOf(int startIndex, char character, String searchedString);\n    static int getIndexOfFirstAppearanceOfAny(int startIndex, Set<Character> characters, String searchedString);\n    static int getIndexAfterPhraseTerm(int startIndex, String simpleQuery);\n    public static String createLuceneQueryString(Collection<String> values, String operator,\n                                                  Function<String, String> function);\n    public static String createLuceneQueryString(Collection<String> values, String operator);\n\n}\n\nclass HibernateSimpleQueryUtilsTest {\n\n    @Test\n    public void getReplaceableTermsOfQueryIgnoresNearOperatorOfPhraseTerms() {\n", "reference": "        // given\n        var simpleQuery = \"\\\"test\\\"~10\";\n\n        // when\n        var actualPairs = HibernateSimpleQueryUtils.getReplaceableTermsOfQuery(simpleQuery);\n\n        // then\n        assertThat(actualPairs).isEmpty();\n    }\n\n}", "prediction": "        var simpleQuery = \"\\\"term1\\\" near \\\"term2\\\"\";\n        var termIndexPairs = HibernateSimpleQueryUtils.getReplaceableTermsOfQuery(simpleQuery);\n\n        assertThat(termIndexPairs).hasSize(1);\n        assertThat(termIndexPairs.get(0).getFirst()).isEqualTo(0);\n        assertThat(termIndexPairs.get(0).getSecond()).isEqualTo(simpleQuery.length() - 1);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "144309611_105", "part": [1, 1], "seq": [1, 1], "prompt": "class ServerViewController extends ViewController {\n\n\tpublic TOMMessage[] clearUpdates() {\n\t\tTOMMessage[] ret = new TOMMessage[updates.size()];\n\t\tfor (int i = 0; i < updates.size(); i++) {\n\t\t\tret[i] = updates.get(i);\n\t\t}\n\t\tupdates.clear();\n\t\treturn ret;\n\t}\n\n\tpublic  ServerViewController(int procId);\n\tpublic  ServerViewController(int procId, String configHome);\n\n\tprivate InetSocketAddress[] getInitAdddresses();\n\tpublic void setTomLayer(TOMLayer tomLayer);\n\tpublic boolean isInCurrentView();\n\tpublic int[] getCurrentViewOtherAcceptors();\n\tpublic int[] getCurrentViewAcceptors();\n\tpublic boolean hasUpdates();\n\tpublic void enqueueUpdate(TOMMessage up);\n\tpublic byte[] executeUpdates(int cid);\n\tprivate boolean contains(int id, List<Integer> list);\n\tprivate byte[] reconfigure(List<String> jSetInfo, List<Integer> jSet, List<Integer> rSet, int f, int cid);\n\tpublic boolean isInLastJoinSet(int id);\n\tpublic void processJoinResult(ReconfigureReply r);\n\t@Override public final void reconfigureTo(View newView);\n\tpublic int getQuorum();\n\n}\n\nclass ServerViewControllerTest {\n\n\t@Test\n\tpublic void testClearUpdates() {\n", "reference": "\t\tfail(\"Not yet implemented\");\n\t}\n\n}", "prediction": "\t\tServerViewController svc = new ServerViewController(0);\n\t\tTOMMessage[] updates = new TOMMessage[10];\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tupdates[i] = new TOMMessage(0, 0, 0, new byte[0], 0, 0, 0, 0);\n\t\t}\n\t\tsvc.enqueueUpdate(updates[0]);\n\t\tsvc.enqueueUpdate(updates[1]);\n\t\tsvc.enqueueUpdate(updates[2]);\n\t\tsvc.enqueueUpdate(updates[3]);\n\t\tsvc.enqueueUpdate(updates[4]);\n\t\tsvc.enqueueUpdate(updates[5]);\n\t\tsvc.enqueueUpdate(updates[6]);\n\t\tsvc.enqueueUpdate(updates[7]);\n\t\tsvc.enqueueUpdate(updates[8]);\n\t\tsvc.enqueueUpdate(updates[9]);\n\t\tassertEquals(10, svc.updates.size());\n\t\tTOMMessage[] ret = svc.clearUpdates();\n\t\tassertEquals(10, ret.length);\n\t\tassertEquals(0, svc.updates.size());\n\t}", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "144712336_0", "part": [1, 1], "seq": [1, 1], "prompt": "class NacosConfigEndpoint implements ApplicationListener<NacosConfigMetadataEvent> {\n\n\t@ReadOperation\n\tpublic Map<String, Object> invoke() {\n\t\tMap<String, Object> result = new HashMap<>(8);\n\n\t\tif (!(ClassUtils.isAssignable(applicationContext.getEnvironment().getClass(),\n\t\t\t\tConfigurableEnvironment.class))) {\n\t\t\tresult.put(\"error\", \"environment type not match ConfigurableEnvironment: \"\n\t\t\t\t\t+ applicationContext.getEnvironment().getClass().getName());\n\t\t}\n\t\telse {\n\n\t\t\tresult.put(\"nacosConfigMetadata\", nacosConfigMetadataMap.values());\n\n\t\t\tresult.put(\"nacosConfigGlobalProperties\",\n\t\t\t\t\tPropertiesUtils.extractSafeProperties(applicationContext.getBean(\n\t\t\t\t\t\t\tCONFIG_GLOBAL_NACOS_PROPERTIES_BEAN_NAME, Properties.class)));\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t@Override public void onApplicationEvent(NacosConfigMetadataEvent event);\n\tprivate String buildMetadataKey(NacosConfigMetadataEvent event);\n\n\t@Autowired\n\tprivate NacosConfigEndpoint nacosConfigEndpoint;\n\n}\n\nclass NacosConfigEndpointTest {\n\n\t@Autowired\n\tprivate NacosConfigEndpoint nacosConfigEndpoint;\n\n\t@Test\n\tpublic void testInvoke() {\n", "reference": "\t\tMap<String, Object> metadata = nacosConfigEndpoint.invoke();\n\t\tAssert.assertNotNull(metadata.get(\"nacosConfigMetadata\"));\n\t}\n\n}", "prediction": "\t\tMap<String, Object> result = nacosConfigEndpoint.invoke();\n\t\tassertThat(result).isNotNull();\n\t\tassertThat(result.get(\"nacosConfigMetadata\")).isNotNull();\n\t\tassertThat(result.get(\"nacosConfigGlobalProperties\")).isNotNull();\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "144740389_18", "part": [1, 1], "seq": [1, 1], "prompt": "class SocketIoMemoryAdapter extends SocketIoAdapter {\n\n    @Override\n    public String[] listClientRooms(SocketIoSocket socket) throws IllegalArgumentException {\n        if (socket == null) {\n            throw new IllegalArgumentException(\"socket must not be null.\");\n        }\n\n        if (mSocketRooms.containsKey(socket.getId())) {\n            return mSocketRooms.get(socket.getId()).toArray(new String[0]);\n        } else {\n            return new String[0];\n        }\n    }\n\n    private  SocketIoMemoryAdapter(SocketIoNamespace namespace);\n\n    @Override public synchronized void broadcast(Packet packet, String[] rooms, String[] socketsExcluded);\n    @Override public synchronized void add(String room, SocketIoSocket socket);\n    @Override public synchronized void remove(String room, SocketIoSocket socket);\n    @Override public SocketIoSocket[] listClients(String room);\n\n    private static final SocketIoMemoryAdapter.AdapterFactory ADAPTER_FACTORY;\n\n}\n\nclass SocketIoMemoryAdapterTest {\n\n    private static final SocketIoMemoryAdapter.AdapterFactory ADAPTER_FACTORY;\n\n    @Test\n    public void test_listClientRooms_unknown_socket() {\n", "reference": "        final SocketIoAdapter adapter = ADAPTER_FACTORY.createAdapter(null);\n\n        final SocketIoSocket socket1 = createDummySocket();\n        final SocketIoSocket socket2 = createDummySocket();\n\n        assertEquals(0, adapter.listClientRooms(socket1).length);\n        assertEquals(0, adapter.listClientRooms(socket2).length);\n    }\n\n}", "prediction": "        SocketIoMemoryAdapter adapter = new SocketIoMemoryAdapter(null);\n        SocketIoSocket socket = new SocketIoSocket(null, null);\n        String[] rooms = adapter.listClientRooms(socket);\n        assertEquals(0, rooms.length);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "147606002_1", "part": [1, 1], "seq": [1, 1], "prompt": "class MailUtil {\n\n\tpublic static String sendMail() {\n\t\t// to do something about send email\n\t\treturn \"send email\";\n\t}\n\n}\n\nclass MailUtilTest {\n\n\t@Test\n\tpublic void testSendMail() {\n", "reference": "\t\tassertEquals(MailUtil.sendMail(), \"send email\");\n\t}\n\n}", "prediction": "\t\tassertEquals(\"send email\", MailUtil.sendMail());\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "147673645_2", "part": [1, 1], "seq": [1, 1], "prompt": "class S3File {\n\n\tpublic String getBucket() {\n\t\treturn bucket;\n\t}\n\n\tpublic  S3File(String fullPath);\n\n\tpublic static void initClient();\n\tpublic static void setAmazonClient(AmazonS3 s3);\n\tprivate InputStream open(int retry);\n\tpublic InputStream open();\n\tpublic OutputStream create();\n\tpublic OutputStream append();\n\tpublic void delete();\n\tpublic void rename(S3File dstKey);\n\tpublic void save();\n\tprivate static void showStats();\n\n}\n\nclass S3FileTest {\n\n\t@Test\n\tpublic void testWithProtocol() {\n", "reference": "\t\tS3File file = new S3File(\"s3a://root/folder\");\n\t\tAssert.assertEquals(\"root\", file.getBucket());\n\t}\n\n}", "prediction": "\t\tS3File s3File = new S3File(\"s3://bucket/key\");\n\t\tassertEquals(\"bucket\", s3File.getBucket());\n\t\tassertEquals(\"key\", s3File.getKey());\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "149647886_3", "part": [1, 1], "seq": [1, 1], "prompt": "class CentrifugeConfig {\n\n    public List<WarmerConfig> getWarmerConfigs() {\n        return ImmutableList.copyOf(this.warmerConfigs);\n    }\n\n    public  CentrifugeConfig();\n    public  CentrifugeConfig(final String pathToConfig);\n\n    public CentrifugeConfig addWarmerConfig(final WarmerConfig config);\n    public int getLogIntervalSeconds();\n    public CentrifugeConfig setLogIntervalSeconds(int logIntervalSeconds);\n    public int getCleanupIntervalMillis();\n    public CentrifugeConfig setCleanupIntervalMillis(int cleanupIntervalMillis);\n    public int getParallelism();\n    public CentrifugeConfig setParallelism(int parallelism);\n\n}\n\nclass CentrifugeConfigTest {\n\n    @Test\n    public void testConstructorWithResource() {\n", "reference": "        final CentrifugeConfig centrifugeConfig = new CentrifugeConfig(\"centrifuge-config-test.conf\");\n        assertEquals(centrifugeConfig.getWarmerConfigs().size(), 1);\n        assertEquals(centrifugeConfig.getWarmerConfigs().get(0).getWarmerClass(), EchoWarmer.class);\n        assertEquals(centrifugeConfig.getWarmerConfigs().get(0).getMaxIterations(), 7777);\n        assertEquals(centrifugeConfig.getWarmerConfigs().get(0).getTimeoutMillis(), 1000);\n        assertEquals(centrifugeConfig.getWarmerConfigs().get(0).getYieldMillis(), 77);\n        assertEquals(centrifugeConfig.getWarmerConfigs().get(0).getMaxFailure(), 777);\n        assertEquals(centrifugeConfig.getWarmerConfigs().get(0).getConcurrency(), 7);\n        assertEquals(String.valueOf(centrifugeConfig.getWarmerConfigs().get(0).getParams().get(\"text\")), \"this is a sample warmer implementation\");\n    }\n\n}", "prediction": "        final CentrifugeConfig config = new CentrifugeConfig(\"centrifuge.properties\");\n        assertEquals(10, config.getLogIntervalSeconds());\n        assertEquals(1000, config.getCleanupIntervalMillis());\n        assertEquals(10, config.getParallelism());\n        assertEquals(2, config.getWarmerConfigs().size());\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "149694816_17", "part": [1, 1], "seq": [1, 1], "prompt": "class Router {\n\n  @GetMapping(\"build/{uuid}\")\n  public BuildDetails getBuild(@PathVariable(\"uuid\") final String buildUuid) {\n    return buildService.get(buildUuid).orElseThrow(ResourceNotFoundException::new);\n  }\n\n  @PostConstruct public void initialize();\n  @GetMapping(\"contract\") public DeploymentResult getLatestContract();\n  @GetMapping(\"builds\") public List<BuildSummary> getLatestBuilds();\n  @PostMapping(\"build/{uuid}/deploy\") public DeploymentResult deploy(@PathVariable(\"uuid\") final String buildUuid);\n  @PostMapping(value = \"contract/{tx}/{function}\") public ExecutionResult execute(\n      @PathVariable(\"tx\") final String contractTransactionHash,\n      @PathVariable(\"function\") final String functionName,\n      @RequestBody final ContractInput contractInput);\n  @GetMapping(value = \"contract/{tx}/{function}\") public QueryResult query(\n      @PathVariable(\"tx\") final String contractTransactionHash,\n      @PathVariable(\"function\") final String functionName,\n      @RequestParam(value = \"arguments\", required = false) final String[] arguments\n  );\n  @ExceptionHandler(value = { HttpException.class }) protected ResponseEntity handleHttpException(final HttpException ex, final WebRequest request);\n  @ExceptionHandler(value = { Throwable.class }) @ResponseStatus(INTERNAL_SERVER_ERROR) @ResponseBody protected Object handleThrowable(Throwable ex, WebRequest request);\n\n  protected Router router;\n  @Mock\n  protected BuildService buildService;\n  @Mock\n  protected ContractService contractService;\n  @Mock\n  protected LiveUpdateService liveUpdateService;\n\n}\n\nclass RouterTest  {\n\n  protected Router router;\n  @Mock\n  protected BuildService buildService;\n  @Mock\n  protected ContractService contractService;\n  @Mock\n  protected LiveUpdateService liveUpdateService;\n\n  @Test\n  public void testGetBuild() {\n", "reference": "    final String buildUuid = randomUUID().toString();\n    when(buildService.get(anyString())).thenReturn(ofNullable(new BuildDetails()));\n    router.getBuild(buildUuid);\n  }\n\n}", "prediction": "    final BuildDetails build = new BuildDetails();\n    when(buildService.get(\"123\")).thenReturn(Optional.of(build));\n\n    final BuildDetails result = router.getBuild(\"123\");\n\n    assertThat(result).isEqualTo(build);\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "151625754_0", "part": [1, 1], "seq": [1, 1], "prompt": "class RSACoder extends Coder {\n\n    public static String sign(byte[] data, String privateKey) throws Exception {\n        // \u89e3\u5bc6\u7531base64\u7f16\u7801\u7684\u79c1\u94a5\n        byte[] keyBytes = decryptBASE64(privateKey);\n\n        // \u6784\u9020PKCS8EncodedKeySpec\u5bf9\u8c61\n        PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes);\n\n        // KEY_ALGORITHM \u6307\u5b9a\u7684\u52a0\u5bc6\u7b97\u6cd5\n        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);\n\n        // \u53d6\u79c1\u94a5\u5319\u5bf9\u8c61\n        PrivateKey priKey = keyFactory.generatePrivate(pkcs8KeySpec);\n\n        // \u7528\u79c1\u94a5\u5bf9\u4fe1\u606f\u751f\u6210\u6570\u5b57\u7b7e\u540d\n        Signature signature = Signature.getInstance(SIGNATURE_ALGORITHM);\n        signature.initSign(priKey);\n        signature.update(data);\n\n        return encryptBASE64(signature.sign());\n    }\n\n    public static boolean verify(byte[] data, String publicKey, String sign);\n    public static byte[] decryptByPrivateKey(byte[] data, String key);\n    public static byte[] decryptByPublicKey(byte[] data, String key);\n    public static byte[] encryptByPublicKey(byte[] data, String key);\n    public static byte[] encryptByPrivateKey(byte[] data, String key);\n    public static String getPrivateKey(Map<String, Object> keyMap);\n    public static String getPublicKey(Map<String, Object> keyMap);\n    public static Map<String, Object> initKey();\n\n    private String publicKey;\n    private String privateKey;\n\n}\n\nclass RSACoderTest {\n\n    private String publicKey;\n    private String privateKey;\n\n    @Test\n    public void testSign() throws Exception {\n", "reference": "        System.out.println(\"\u79c1\u94a5\u52a0\u5bc6\u2014\u2014\u516c\u94a5\u89e3\u5bc6\");\n        String inputStr = \"sign\";\n        byte[] data = inputStr.getBytes();\n\n        byte[] encodedData = RSACoder.encryptByPrivateKey(data, privateKey);\n\n        byte[] decodedData = RSACoder.decryptByPublicKey(encodedData, publicKey);\n\n        String outputStr = new String(decodedData);\n        System.out.println(\"\u52a0\u5bc6\u524d: \" + inputStr + \"\\n\\r\" + \"\u89e3\u5bc6\u540e: \" + outputStr);\n        assertEquals(inputStr, outputStr);\n\n        System.out.println(\"\u79c1\u94a5\u7b7e\u540d\u2014\u2014\u516c\u94a5\u9a8c\u8bc1\u7b7e\u540d\");\n        // \u4ea7\u751f\u7b7e\u540d\n        String sign = RSACoder.sign(encodedData, privateKey);\n        System.out.println(\"\u7b7e\u540d:\" + sign);\n\n        // \u9a8c\u8bc1\u7b7e\u540d\n        boolean status = RSACoder.verify(encodedData, publicKey, sign);\n        System.out.println(\"\u72b6\u6001:\" + status);\n        assertTrue(status);\n\n    }\n\n}", "prediction": "        String data = \"hello world\";\n        String sign = RSACoder.sign(data.getBytes(), privateKey);\n        System.out.println(sign);\n        Assert.assertTrue(RSACoder.verify(data.getBytes(), publicKey, sign));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "152217753_8", "part": [1, 1], "seq": [1, 1], "prompt": "class MyController {\n\n    @GetMapping(\"/hello/{name}\")\n    public @ResponseBody\n    String helloName(@PathVariable String name) {\n        return \"hello \" + name;\n    }\n\n    @GetMapping(\"/hello\") public String hello(Model model);\n    @GetMapping(\"/hello/{name1}/{name2}\") public @ResponseBody String helloName(@PathVariable(name = \"name1\") String name1, @PathVariable(name = \"name2\") String name2);\n\n    @Autowired\n    private MockMvc mockMvc;\n\n}\n\nclass MyControllerTest {\n\n    @Autowired\n    private MockMvc mockMvc;\n\n    @Test\n    public void helloNameTest() throws Exception {\n", "reference": "        String name = \"siyoon\";\n\n        mockMvc.perform(get(\"/hello/{name}\", name).accept(MediaType.TEXT_HTML))\n                .andExpect(status().isOk())\n                .andDo(print());\n    }\n\n}", "prediction": "        mockMvc.perform(get(\"/hello/John\"))\n                .andExpect(status().isOk())\n                .andExpect(content().string(equalTo(\"hello John\")));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "152714817_8", "part": [1, 1], "seq": [1, 1], "prompt": "class SecurityPoliciesProcessDefinitionRestrictionApplier implements SecurityPoliciesRestrictionApplier<GetProcessDefinitionsPayload> {\n\n    @Override\n    public GetProcessDefinitionsPayload restrictToKeys(Set<String> keys) {\n        return ProcessPayloadBuilder.processDefinitions().withProcessDefinitionKeys(keys).build();\n    }\n\n    @Override public GetProcessDefinitionsPayload denyAll();\n    @Override public GetProcessDefinitionsPayload allowAll();\n\n    private SecurityPoliciesProcessDefinitionRestrictionApplier restrictionApplier;\n\n}\n\nclass SecurityPoliciesProcessDefinitionRestrictionApplierTest {\n\n    private SecurityPoliciesProcessDefinitionRestrictionApplier restrictionApplier;\n\n    @Test\n    public void restrictToKeysAddFilterOnGivenKeys() {\n", "reference": "        //given\n        Set<String> keys = Collections.singleton(\"procDef\");\n\n        //when\n        GetProcessDefinitionsPayload filter = restrictionApplier.restrictToKeys(keys);\n\n        //then\n        assertThat(filter.getProcessDefinitionKeys()).isEqualTo(keys);\n    }\n\n}", "prediction": "        Set<String> keys = new HashSet<>();\n        keys.add(\"key1\");\n        keys.add(\"key2\");\n\n        GetProcessDefinitionsPayload payload = restrictionApplier.restrictToKeys(keys);\n\n        assertThat(payload.getProcessDefinitionKeys()).isEqualTo(keys);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "152814648_21", "part": [1, 1], "seq": [1, 1], "prompt": "class TaskScanner {\n\n    Report scanTasks(final Iterator<String> lines, final IssueBuilder builder) {\n        Report report = new Report();\n\n        if (isPatternInvalid) {\n            report.logError(\"%s\", errors.toString());\n            return report;\n        }\n\n        for (int lineNumber = 1; lines.hasNext(); lineNumber++) {\n            String line = lines.next();\n\n            for (Severity severity : Severity.getPredefinedValues()) {\n                if (patterns.containsKey(severity)) {\n                    Matcher matcher = patterns.get(severity).matcher(line);\n                    if (matcher.matches() && matcher.groupCount() == 2) {\n                        String message = matcher.group(2).trim();\n                        builder.setMessage(StringUtils.removeStart(message, \":\").trim());\n\n                        String tag = matcher.group(1);\n                        if (isUppercase) {\n                            builder.setType(StringUtils.upperCase(tag));\n                        }\n                        else {\n                            builder.setType(tag);\n                        }\n                        report.add(builder.setSeverity(severity).setLineStart(lineNumber).build());\n                    }\n                }\n            }\n        }\n        return report;\n    }\n\n      TaskScanner(final @CheckForNull String highTags, final @CheckForNull String normalTags,\n            final @CheckForNull String lowTags,\n            final CaseMode caseMode, final MatcherMode matcherMode);\n\n     String getTaskTags();\n     boolean isInvalidPattern();\n    public String getErrors();\n    private Pattern compile(final String tagIdentifiers, final CaseMode caseMode, final MatcherMode matcherMode);\n    private String[] splitTags(final String tagIdentifiers);\n    public Report scan(final Path file, final Charset charset);\n\n    private static final String FIXME;\n    private static final String CASE_TEST_FILE;\n    private static final String PRIORITY_HIGH_MESSAGE;\n    private static final String PRIORITY_NORMAL_MESSAGE;\n    private static final String FILE_WITH_TASKS;\n    private static final IssueBuilder ISSUE_BUILDER;\n\n}\n\nclass TaskScannerTest  {\n\n    private static final String FIXME;\n    private static final String CASE_TEST_FILE;\n    private static final String PRIORITY_HIGH_MESSAGE;\n    private static final String PRIORITY_NORMAL_MESSAGE;\n    private static final String FILE_WITH_TASKS;\n    private static final IssueBuilder ISSUE_BUILDER;\n\n    @Test\n    void shouldScanFileWithoutTasks() {\n", "reference": "        Report tasks = new TaskScannerBuilder().setHighTasks(\"FIXME\")\n                .setNormalTasks(\"TODO\")\n                .setLowTasks(\"@deprecated\")\n                .setCaseMode(CaseMode.CASE_SENSITIVE)\n                .setMatcherMode(MatcherMode.STRING_MATCH)\n                .build()\n                .scanTasks(read(\"file-without-tasks.txt\"), ISSUE_BUILDER);\n\n        assertThat(tasks).hasSize(0);\n    }\n\n}", "prediction": "        Report report = new TaskScanner(FIXME, CASE_TEST_FILE, CASE_TEST_FILE, CaseMode.UPPERCASE, MatcherMode.REGEX).scan(Paths.get(FILE_WITH_TASKS), StandardCharsets.UTF_8);\n        assertThat(report.getIssues()).isEmpty();\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "155277206_0", "part": [1, 1], "seq": [1, 1], "prompt": "class AgentRuleUtil {\n\n  @SuppressWarnings(\"unchecked\")\n  public static <T>T[] subArray(final T[] array, final int beginIndex, final int endIndex) {\n    if (endIndex < beginIndex)\n      throw new IllegalArgumentException(\"endIndex (\" + endIndex + \") < beginIndex (\" + beginIndex + \")\");\n\n    final Class<?> componentType = array.getClass().getComponentType();\n    final T[] subArray = (T[])Array.newInstance(componentType, endIndex - beginIndex);\n    if (beginIndex == endIndex)\n      return subArray;\n\n    System.arraycopy(array, beginIndex, subArray, 0, endIndex - beginIndex);\n    return subArray;\n  }\n\n  private  AgentRuleUtil();\n\n  public static String getNameId(final Object obj);\n  public static String getSimpleNameId(final Object obj);\n  public static T[] subArray(final T[] array, final int beginIndex);\n  public static Class<?>[] getExecutionStack();\n  public static StackTraceElement[] getCallStack();\n  public static boolean callerEquals(int frameIndex, final String name);\n  public static boolean callerEquals(int startFrame, int endFrame, final String name);\n  public static boolean callerEquals(int frameIndex, final String ... names);\n  public static boolean callerEquals(int startFrame, int endFrame, final String ...  names);\n  public static boolean hasMethodNamed(TypeDefinition typeDefinition, final String methodName);\n  @SuppressWarnings(\"unchecked\") public static T getFieldInBootstrapClass(final Class<?> cls, final String fieldName);\n  public static boolean isFromClassLoader(final Class<?>[] callStack, final ClassLoader classLoader);\n  public static URL[] classPathToURLs(final String classpath);\n\n}\n\nclass AgentRuleUtilTest {\n\n  @Test\n  public void testSubArray() {\n", "reference": "    try {\n      AgentRuleUtil.subArray(null, 0);\n      fail(\"Expected NullPointerException\");\n    }\n    catch (final NullPointerException e) {\n    }\n\n    try {\n      AgentRuleUtil.subArray(new String[] {\"\"}, 0, -1);\n      fail(\"Expected IllegalArgumentException\");\n    }\n    catch (final IllegalArgumentException e) {\n    }\n\n    final Integer[] array = {0, 1, 2, 3, 4, 5, 6, 7, 8};\n    assertArrayEquals(new Integer[] {2, 3}, AgentRuleUtil.subArray(array, 2, 4));\n    assertArrayEquals(new Integer[] {6, 7, 8}, AgentRuleUtil.subArray(array, 6));\n  }\n\n}", "prediction": "    final String[] array = new String[] { \"a\", \"b\", \"c\", \"d\", \"e\" };\n    assertArrayEquals(new String[] { \"b\", \"c\", \"d\", \"e\" }, AgentRuleUtil.subArray(array, 1));\n    assertArrayEquals(new String[] { \"b\", \"c\", \"d\" }, AgentRuleUtil.subArray(array, 1, 4));\n    assertArrayEquals(new String[] { \"b\", \"c\" }, AgentRuleUtil.subArray(array, 1, 3));\n    assertArrayEquals(new String[] { \"b\" }, AgentRuleUtil.subArray(array, 1, 2));\n    assertArrayEquals(new String[] {}, AgentRuleUtil.subArray(array, 1, 1));\n    assertArrayEquals(new String[] {}, AgentRuleUtil.subArray(array, 1, 0));\n    assertArrayEquals(new String[] {}, AgentRuleUtil.subArray(array, 0, 0));\n    assertArrayEquals(new String[] { \"a\", \"b\", \"c\", \"d\", \"e\" }, AgentRuleUtil.subArray(array, 0, 5));\n  }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "155883728_446", "part": [1, 1], "seq": [1, 1], "prompt": "class RowFacade implements Row {\n\n    @Override\n    public String getPath() throws RepositoryException {\n        return delegate.getPath();\n    }\n\n    @SuppressWarnings(\"WeakerAccess\") public  RowFacade(final @NotNull Row delegate, final @NotNull SessionFacade<S> session);\n\n    @Override public Value[] getValues();\n    @Override public Value getValue(String columnName);\n    @Override public Node getNode();\n    @Override public Node getNode(String selectorName);\n    @Override public String getPath(String selectorName);\n    @Override public double getScore();\n    @Override public double getScore(String selectorName);\n\n}\n\nclass RowFacadeTest {\n\n    @Test\n    public void testGetPath() throws Exception {\n", "reference": "        Row delegate = mock(Row.class);\n        RowFacade<Session> facade = getFacade(delegate);\n        final String value = \"/correct/path\";\n        when(delegate.getPath()).thenReturn(value);\n        assertSame(\"same value\", value, facade.getPath());\n    }\n\n}", "prediction": "        RowFacade row = new RowFacade(null, null);\n        assertNull(row.getPath());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "156408389_11", "part": [1, 1], "seq": [1, 1], "prompt": "class KinClient {\n\n    public @NonNull\n    KinAccount addAccount() throws CreateAccountException {\n        return kinClientInternal.addAccount();\n    }\n\n    public  KinClient(@NonNull Context context, @NonNull Environment environment, String appId);\n    public  KinClient(@NonNull Context context, @NonNull Environment environment, @NonNull String appId, @NonNull String storeKey);\n    @VisibleForTesting  KinClient(Environment environment, KeyStore keyStore, TransactionSender transactionSender,\n              AccountInfoRetriever accountInfoRetriever, GeneralBlockchainInfoRetrieverImpl generalBlockchainInfoRetriever,\n              BlockchainEventsCreator blockchainEventsCreator, BackupRestore backupRestore, String appId, String storeKey);\n\n    private KeyStore createKeyStore(Context context, String id);\n    @NonNull public KinAccount importAccount(@NonNull String exportedJson, @NonNull String passphrase);\n    public KinAccount getAccount(int index);\n    public boolean hasAccount();\n    public int getAccountCount();\n    public boolean deleteAccount(int index);\n    public void clearAllAccounts();\n    public Environment getEnvironment();\n    public Request<Long> getMinimumFee();\n    public long getMinimumFeeSync();\n    public String getAppId();\n    public String getStoreKey();\n\n    private static final String APP_ID;\n    @Rule\n    public ExpectedException expectedEx;\n    @Mock\n    private TransactionSender mockTransactionSender;\n    @Mock\n    private GeneralBlockchainInfoRetrieverImpl mockGeneralBlockchainInfoRetriever;\n    @Mock\n    private AccountInfoRetriever mockAccountInfoRetriever;\n    @Mock\n    private BlockchainEventsCreator mockBlockchainEventsCreator;\n    private KinClient kinClient;\n    private KeyStore fakeKeyStore;\n    private Environment fakeEnvironment;\n\n}\n\nclass KinClientTest {\n\n    private static final String APP_ID;\n    @Rule\n    public ExpectedException expectedEx;\n    @Mock\n    private TransactionSender mockTransactionSender;\n    @Mock\n    private GeneralBlockchainInfoRetrieverImpl mockGeneralBlockchainInfoRetriever;\n    @Mock\n    private AccountInfoRetriever mockAccountInfoRetriever;\n    @Mock\n    private BlockchainEventsCreator mockBlockchainEventsCreator;\n    private KinClient kinClient;\n    private KeyStore fakeKeyStore;\n    private Environment fakeEnvironment;\n\n    @Test\n    public void createAccount_AddAccount() throws Exception {\n", "reference": "        KinAccount kinAccount = kinClient.addAccount();\n\n        assertNotNull(kinAccount);\n        assertThat(kinAccount.getPublicAddress(), not(isEmptyOrNullString()));\n    }\n\n}", "prediction": "        kinClient.addAccount();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "156416177_113", "part": [1, 1], "seq": [1, 1], "prompt": "class SvReloadCmdBuild extends AbstractPoCommandBuilder<SvReloadRespPars> {\n\n  public void finalizeBuilder(byte[] reloadComplementaryData) {\n    if ((poRevision == PoRevision.REV3_2 && reloadComplementaryData.length != 20)\n        || (poRevision != PoRevision.REV3_2 && reloadComplementaryData.length != 15)) {\n      throw new IllegalArgumentException(\"Bad SV prepare load data length.\");\n    }\n\n    byte p1 = reloadComplementaryData[4];\n    byte p2 = reloadComplementaryData[5];\n\n    dataIn[0] = reloadComplementaryData[6];\n    System.arraycopy(reloadComplementaryData, 0, dataIn, 11, 4);\n    System.arraycopy(reloadComplementaryData, 7, dataIn, 15, 3);\n    System.arraycopy(reloadComplementaryData, 10, dataIn, 18, reloadComplementaryData.length - 10);\n\n    this.request = setApduRequest(poClass.getValue(), command, p1, p2, dataIn, null);\n  }\n\n  public  SvReloadCmdBuild(\n      PoClass poClass,\n      PoRevision poRevision,\n      int amount,\n      byte kvc,\n      byte[] date,\n      byte[] time,\n      byte[] free);\n\n  public byte[] getSvReloadData();\n  @Override public SvReloadRespPars createResponseParser(ApduResponse apduResponse);\n  @Override public boolean isSessionBufferUsed();\n\n}\n\nclass SvReloadCmdBuildTest {\n\n  @Test(expected = IllegalArgumentException.class)\n  public void svReloadCmdBuild_mode_compat_bad_signature_length_1() {\n", "reference": "    SvReloadCmdBuild svReloadCmdBuild =\n        new SvReloadCmdBuild(\n            PoClass.ISO,\n            PoRevision.REV3_1,\n            /* amount */ 1, /* KVC */\n            (byte) 0xAA, /* date */\n            ByteArrayUtil.fromHex(\"1122\"),\n            /* time */ ByteArrayUtil.fromHex(\"3344\"), /* free */\n            ByteArrayUtil.fromHex(\"F3EE\"));\n    svReloadCmdBuild.finalizeBuilder(\n        /* SAM ID + prepare SV Reload data */ ByteArrayUtil.fromHex(\n            \"AABBCCDD55667712345611223344556677889900\"));\n  }\n\n}", "prediction": "    byte[] data = new byte[15];\n    new SvReloadCmdBuild(PoClass.SV, PoRevision.REV3_2, 0, (byte) 0, new byte[4], new byte[3], new byte[15]);\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "158975124_110", "part": [1, 1], "seq": [1, 1], "prompt": "class CompressionRatio {\n\n  void restore() {\n    if (!directory.exists()) {\n      return;\n    }\n    File[] ratioFiles = directory.listFiles((dir, name) -> name.startsWith(FILE_PREFIX));\n    if (ratioFiles != null && ratioFiles.length > 0) {\n      long maxTimes = 0;\n      double maxCompressionRatioSum = 0;\n      int maxRatioIndex = 0;\n      for (int i = 0; i < ratioFiles.length; i++) {\n        String[] splits = ratioFiles[i].getName().split(\"-\");\n        long times = Long.parseLong(splits[2]);\n        if (times > maxTimes) {\n          maxTimes = times;\n          maxCompressionRatioSum = Double.parseDouble(splits[1]);\n          maxRatioIndex = i;\n        }\n      }\n      calcTimes = maxTimes;\n      compressionRatioSum = maxCompressionRatioSum;\n      if (calcTimes != 0) {\n        compressionRatio.set(compressionRatioSum / calcTimes);\n      }\n      LOGGER.debug(\n          \"After restoring from compression ratio file, compressionRatioSum = {}, calcTimes = {}\",\n          compressionRatioSum, calcTimes);\n      for (int i = 0; i < ratioFiles.length; i++) {\n        if (i != maxRatioIndex) {\n          ratioFiles[i].delete();\n        }\n      }\n    }\n  }\n\n  private  CompressionRatio();\n\n  public synchronized void updateRatio(double currentCompressionRatio);\n  public double getRatio();\n  private void persist(File oldFile, File newFile);\n  private void checkDirectoryExist();\n   void reset();\n  public double getCompressionRatioSum();\n   long getCalcTimes();\n  public static CompressionRatio getInstance();\n\n  private static final IoTDBConfig CONFIG;\n  private CompressionRatio compressionRatio;\n  private static final String directory;\n\n}\n\nclass CompressionRatioTest {\n\n  private static final IoTDBConfig CONFIG;\n  private CompressionRatio compressionRatio;\n  private static final String directory;\n\n  @Test\n  public void testRestore() throws IOException {\n", "reference": "    double compressionRatioSum = 0;\n    int calcuTimes = 0;\n    if (new File(directory, String.format(Locale.ENGLISH, CompressionRatio.RATIO_FILE_PATH_FORMAT, compressionRatioSum , calcuTimes)).exists()) {\n      fail();\n    }\n    int compressionRatio = 10;\n    for(int i = 0; i < 100 ; i+= compressionRatio){\n      this.compressionRatio.updateRatio(compressionRatio);\n      if (new File(directory, String.format(Locale.ENGLISH, CompressionRatio.RATIO_FILE_PATH_FORMAT, compressionRatioSum , calcuTimes)).exists()) {\n        fail();\n      }\n      calcuTimes++;\n      compressionRatioSum += compressionRatio;\n      if (!new File(directory, String.format(Locale.ENGLISH, CompressionRatio.RATIO_FILE_PATH_FORMAT, compressionRatioSum , calcuTimes)).exists()) {\n        fail();\n      }\n      assertEquals(0, Double\n          .compare(compressionRatioSum / calcuTimes, this.compressionRatio.getRatio()));\n    }\n    this.compressionRatio.restore();\n    assertEquals(10, this.compressionRatio.getCalcTimes());\n    assertEquals(0, Double\n        .compare(compressionRatioSum / calcuTimes, this.compressionRatio.getRatio()));\n  }\n\n}", "prediction": "    File file = new File(directory);\n    file.mkdir();\n    File file1 = new File(directory + File.separator + \"ratio-1.0-1000000000000000000.txt\");\n    file1.createNewFile();\n    compressionRatio.restore();\n    Assert.assertEquals(1.0, compressionRatio.getRatio(), 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "159422409_0", "part": [1, 1], "seq": [1, 1], "prompt": "class AsyncService {\n\n  @Async\n  public CompletableFuture<List<String>> completableFutureTask(String start) {\n    logger.warn(Thread.currentThread().getName() + \"start this task!\");\n    // \u627e\u51fa\u6240\u6709\u4ee5 F \u5f00\u5934\u7684\u7535\u5f71\n    List<String> results =\n        movies.stream().filter(movie -> movie.startsWith(start)).collect(Collectors.toList());\n    // \u6a21\u62df\u8fd9\u662f\u4e00\u4e2a\u8017\u65f6\u7684\u4efb\u52a1\n    try {\n      Thread.sleep(1000L);\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    }\n    // \u8fd4\u56de\u4e00\u4e2a\u5df2\u7ecf\u7528\u7ed9\u5b9a\u503c\u5b8c\u6210\u7684\u65b0\u7684CompletableFuture\u3002\n    return CompletableFuture.completedFuture(results);\n  }\n\n  @Autowired AsyncService asyncService;\n\n}\n\nclass AsyncServiceTest {\n\n  @Autowired AsyncService asyncService;\n\n  @Test\n  public void testCompletableFutureTask() throws InterruptedException, ExecutionException {\n", "reference": "    // \u5f00\u59cb\u65f6\u95f4\n    long start = System.currentTimeMillis();\n    // \u5f00\u59cb\u6267\u884c\u5927\u91cf\u7684\u5f02\u6b65\u4efb\u52a1\n    List<String> words = Arrays.asList(\"F\", \"T\", \"S\", \"Z\", \"J\", \"C\");\n    List<CompletableFuture<List<String>>> completableFutureList =\n        words.stream()\n            .map(word -> asyncService.completableFutureTask(word))\n            .collect(Collectors.toList());\n    // CompletableFuture.join\uff08\uff09\u65b9\u6cd5\u53ef\u4ee5\u83b7\u53d6\u4ed6\u4eec\u7684\u7ed3\u679c\u5e76\u5c06\u7ed3\u679c\u8fde\u63a5\u8d77\u6765\n    List<List<String>> results =\n        completableFutureList.stream().map(CompletableFuture::join).collect(Collectors.toList());\n    // \u6253\u5370\u7ed3\u679c\u4ee5\u53ca\u8fd0\u884c\u7a0b\u5e8f\u8fd0\u884c\u82b1\u8d39\u65f6\u95f4\n    System.out.println(\"Elapsed time: \" + (System.currentTimeMillis() - start));\n    System.out.println(results.toString());\n  }\n\n}", "prediction": "   CompletableFuture<List<String>> completableFuture = asyncService.completableFutureTask(\"F\");\n    List<String> results = completableFuture.get();\n    assertThat(results).contains(\"Fast and Furious\");\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "159454491_1", "part": [1, 1], "seq": [1, 1], "prompt": "class WebApiUrlProtectedController {\n\n    @PostMapping(\"game\")\n    public Mono<Game> createGame(@RequestBody Map<String, Object> gameRequest) {\n        return webApiService.createGame(gameRequest);\n    }\n\n    public  WebApiUrlProtectedController(WebApiService webApiService);\n\n    @GetMapping(\"games\") public Flux<Game> getAllGames();\n\n    @Autowired\n    private TestConfig testConfig;\n    private WebTestClient webTestClient;\n    private WebClient webClient;\n\n}\n\nclass WebApiUrlProtectedControllerTest {\n\n    @Autowired\n    private TestConfig testConfig;\n    private WebTestClient webTestClient;\n    private WebClient webClient;\n\n    @Test\n    public void createGame_BaseAuth_User_Forbidden() {\n", "reference": "        List<User> users = webClient\n                .get()\n                .uri(USERS_URL)\n                .headers(basicAuthHeaders(testConfig.getAdminName(), testConfig.getAdminPassword()))\n                .retrieve()\n                .bodyToFlux(User.class)\n                .collect(Collectors.toList())\n                .block();\n        assertNotNull(users);\n        assertTrue(users.size() > 3);\n        webTestClient\n                .post()\n                .uri(GAME_URL)\n                .body(BodyInserters.fromObject(createGame(users.get(0), users.get(1))))\n                .headers(basicAuthHeaders(testConfig.getUserName(), testConfig.getUserPassword()))\n                .exchange()\n                .expectStatus().isForbidden();\n    }\n\n}", "prediction": "        webTestClient.post()\n                .uri(\"/api/game\")\n                .header(\"Authorization\", \"Basic \" + Base64.getEncoder().encodeToString(\"user:password\".getBytes()))\n                .body(BodyInserters.fromValue(new Game(\"test\")))\n                .exchange()\n                .expectStatus().isForbidden();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "159966756_0", "part": [1, 1], "seq": [1, 1], "prompt": "class DownloadInfo implements Parcelable, Comparable<DownloadInfo> {\n\n    public void setNumPieces(int numPieces)\n    {\n        if (numPieces <= 0)\n            throw new IllegalArgumentException(\"Piece number can't be less or equal zero\");\n\n        if (!partialSupport && numPieces > 1)\n            throw new IllegalStateException(\"The download doesn't support partial download\");\n\n        if ((totalBytes <= 0 && numPieces != 1) || (totalBytes > 0 && totalBytes < numPieces))\n            throw new IllegalStateException(\"The number of pieces can't be more than the number of total bytes\");\n\n        this.numPieces = numPieces;\n    }\n\n    public  DownloadInfo(@NonNull Uri dirPath,\n                        @NonNull String url,\n                        @NonNull String fileName);\n    @Ignore public  DownloadInfo(@NonNull Parcel source);\n\n    @Override public int describeContents();\n    @Override public void writeToParcel(Parcel dest, int flags);\n    public int getNumPieces();\n    public List<DownloadPiece> makePieces();\n    public long pieceStartPos(@NonNull DownloadPiece piece);\n    public long pieceEndPos(@NonNull DownloadPiece piece);\n    public long getDownloadedBytes(@NonNull DownloadPiece piece);\n    @Override public int compareTo(@NonNull DownloadInfo another);\n    @Override public int hashCode();\n    @Override public boolean equals(Object o);\n    @Override public String toString();\n\n    private DownloadInfo info;\n\n}\n\nclass DownloadInfoTest {\n\n    private DownloadInfo info;\n\n    @Test\n    public void testSetNumPieces()\n    {\n", "reference": "        try {\n            info.setNumPieces(0);\n            fail(\"Zero pieces test failed\");\n        } catch (IllegalArgumentException e) { }\n\n        info.partialSupport = false;\n        try {\n            info.setNumPieces(3);\n            fail(\"Partial support test failed\");\n        } catch (IllegalStateException e) { }\n\n        info.partialSupport = true;\n        info.totalBytes = -1;\n        try {\n            info.setNumPieces(3);\n            fail(\"Multipart with unavailable size test failed\");\n        } catch (IllegalStateException e) { }\n\n        info.totalBytes = 0;\n        try {\n            info.setNumPieces(3);\n            fail(\"Multipart with zero size test failed\");\n        } catch (IllegalStateException e) { }\n\n        info.totalBytes = 2;\n        try {\n            info.setNumPieces(3);\n            fail(\"Size less than pieces test failed\");\n        } catch (IllegalStateException e) { }\n    }\n\n}", "prediction": "        info.setNumPieces(1);\n        assertEquals(1, info.getNumPieces());\n\n        info.setNumPieces(2);\n        assertEquals(2, info.getNumPieces());\n\n        info.setNumPieces(3);\n        assertEquals(3, info.getNumPieces());\n\n        info.setNumPieces(4);\n        assertEquals(4, info.getNumPieces());\n\n        info.setNumPieces(5);\n        assertEquals(5, info.getNumPieces());\n\n        info.setNumPieces(6);\n        assertEquals(6, info.getNumPieces());\n\n        info.setNumPieces(7);\n        assertEquals(7, info.getNumPieces());\n\n        info.setNumPieces(8);\n        assertEquals(8, info.getNumPieces());\n\n        info.setNumPieces(9);\n        assertEquals(9, info.getNumPieces());\n\n        info.setNumPieces(10);\n        assertEquals(10, info.getNumPieces());\n\n        info.setNumPieces(11);\n        assertEquals(11, info.getNumPieces());\n\n        info.setNumPieces(12);\n        assertEquals(12, info.getNumPieces());\n\n        info.setNumPieces(13);\n        assertEquals(13, info.getNumPieces());\n\n        info.setNumPieces(14);\n        assertEquals(14, info.getNumPieces());\n\n        info.setNumPieces(15);\n        assertEquals(15, info.getNumPieces());\n\n        info.setNumPieces(16);\n        assertEquals(16, info.getNumPieces());\n\n        info.setNumPieces(17);\n        assertEquals(17, info.getNumPieces());\n\n        info.setNumPieces(18);\n        assertEquals(18, info.getNumPieces());\n\n        info.setNumPieces(19);\n        assertEquals(19, info.getNumPieces());\n\n        info.setNumPieces(20);\n        assertEquals(20, info.getNumPieces());\n\n        info.setNumPieces(21);\n        assertEquals(21, info.getNumPieces());\n\n        info.setNumPieces(22);\n        assertEquals(22, info.getNumPieces());\n\n        info.setNumPieces(23);\n        assertEquals(23, info.getNumPieces());\n\n        info.setNumPieces(24);\n        assertEquals(24, info.getNumPieces());\n\n        info.setNumPieces(25);\n        assertEquals(25, info.getNumPieces());\n\n        info.setNumPieces(26);\n        assertEquals(26, info.getNumPieces());\n\n        info.setNumPieces(27);\n        assertEquals(27, info.getNumPieces());\n\n        info.setNumPieces(28);\n        assertEquals(28, info.getNumPieces());\n\n        info.setNumPieces(29);\n        assertEquals(29, info.getNumPieces());\n\n        info.setNumPieces(30);\n        assertEquals(30, info.getNumPieces());\n\n        info.setNumPieces(31);\n        assertEquals(31, info.getNumPieces());\n\n        info.setNumPieces(32);\n        assertEquals(32, info.getNumPieces());\n\n        info.setNumPieces(33);\n        assertEquals(33, info.getNumPieces());\n\n        info.setNumPieces(34);\n        assertEquals(34, info.getNumPieces());\n\n        info.setNumPieces(35);\n        assertEquals(35, info.getNumPieces());\n\n        info.setNumPieces(36);\n        assertEquals(36, info.getNumPieces());\n\n        info.setNumPieces(37);\n        assertEquals(37, info.getNumPieces());\n\n        info.setNumPieces(38);\n        assertEquals(38, info.getNumPieces());\n\n        info.setNumPieces(39);\n        assertEquals(39, info.getNumPieces());\n\n        info.setNumPieces(40);\n        assertEquals(40, info.getNumPieces());\n\n        info.setNumPieces(41);\n        assertEquals(41, info.getNumPieces());\n\n        info.setNumPieces(42);\n        assertEquals(42, info.getNumPieces());\n\n        info.setNumPieces(43);\n        assertEquals(43, info.getNumPieces());\n\n        info.setNumPieces(44);\n        assertEquals(44, info.getNumPieces());\n\n        info.setNumPieces(45);\n        assertEquals(45, info.getNumPieces());\n\n        info.setNumPieces(46);\n        assertEquals(46, info.getNumPieces());\n\n        info.setNumPieces(47);\n        assertEquals(47, info.getNumPieces());\n\n        info.setNumPieces(48);\n        assertEquals(48, info.getNumPieces());\n\n        info.setNumPieces(49);\n        assertEquals(49, info.getNumPieces());\n\n        info.setNumPieces(50);\n        assertEquals(50, info.getNumPieces());\n\n        info.setNumPieces(51);\n        assertEquals(51, info", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "164308818_0", "part": [1, 1], "seq": [1, 1], "prompt": "class ArgsParser {\n\n    public static ArgsParser parse(String[] args) {\n\n        // commons-cli 1.2\n\n        Options options = new Options();\n\n        Option source = new Option(\"s\", \"source\", true,\n                \"the source graph file path on HDFS (Required)\");\n        source.setRequired(true);\n\n        Option target = new Option(\"t\", \"target\", true,\n                \"the target graph file path on HDFS (Required)\");\n        target.setRequired(true);\n\n        Option output = new Option(\"o\", \"output\", true,\n                \"the output folder path of MapReduce result on HDFS (Required)\");\n        output.setRequired(true);\n\n        Option help = new Option(\"h\", \"help\", false,\n                \"show this help message and exit program\");\n\n        options.addOption(source)\n                .addOption(target)\n                .addOption(output)\n                .addOption(help);\n\n        CommandLineParser parser = new BasicParser();\n        HelpFormatter formatter = new HelpFormatter();\n        CommandLine cmd = null;\n\n        try {\n            cmd = parser.parse(options, args);\n            arguments.put(SOURCE, cmd.getOptionValue(\"s\"));\n            arguments.put(TARGET, cmd.getOptionValue(\"t\"));\n            arguments.put(OUTPUT, cmd.getOptionValue(\"o\"));\n        } catch (ParseException e) {\n            System.out.println(e.getMessage());\n            formatter.printHelp(\"sub-Graph Isomorphism\", options, true);\n            System.exit(1);\n        }\n\n        if (cmd.hasOption(\"h\")) {\n            formatter.printHelp(\"sub-Graph Isomorphism\", options, true);\n            System.exit(0);\n        }\n\n        return new ArgsParser();\n    }\n\n    private  ArgsParser();\n\n    public String getSourceGraphFilePath();\n    public String getTargetGraphFilePath();\n    public String getOutputFolderPath();\n\n}\n\nclass ArgsParserTest {\n\n    @Test\n    public void parse() {\n", "reference": "        ArrayList<String[]> args = new ArrayList<>();\n        args.add(new String[]{\"-h\"});\n        args.add(new String[]{\"-s/home/source\"});\n        args.add(new String[]{\"-s\", \"/home/source\", \"-t\", \"/home/innofang/target\", \"-o\", \"/output\"});\n        args.add(new String[]{\"-s=/home/source\", \"-t=/home/innofang/target\", \"-o=/output\"});\n\n        ArgsParser parser = ArgsParser.parse(args.get(2));\n        System.out.println(parser.getSourceGraphFilePath());\n        System.out.println(parser.getTargetGraphFilePath());\n        System.out.println(parser.getOutputFolderPath());\n    }\n\n}", "prediction": "        ArgsParser.parse(new String[]{\"-s\", \"source\", \"-t\", \"target\", \"-o\", \"output\"});\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "164392211_89", "part": [1, 1], "seq": [1, 1], "prompt": "class IntTimSort {\n\n    public static void sort(int[] a, IntComparator c) {\n        sort(a, 0, a.length, c);\n    }\n\n    private  IntTimSort(int[] a, IntComparator c);\n\n    public static void sort(int[] a, int lo, int hi, IntComparator c);\n    @SuppressWarnings(\"fallthrough\") private static void binarySort(int[] a, int lo, int hi, int start, IntComparator c);\n    private static int countRunAndMakeAscending(int[] a, int lo, int hi, IntComparator c);\n    private static void reverseRange(int[] a, int lo, int hi);\n    private static int minRunLength(int n);\n    private static int gallopLeft(int key, int[] a, int base, int len, int hint, IntComparator c);\n    private static int gallopRight(int key, int[] a, int base, int len, int hint, IntComparator c);\n    private void pushRun(int runBase, int runLen);\n    private void mergeCollapse();\n    private void mergeForceCollapse();\n    private void mergeAt(int i);\n    private void mergeLo(int base1, int len1, int base2, int len2);\n    private void mergeHi(int base1, int len1, int base2, int len2);\n    private int[] ensureCapacity(int minCapacity);\n\n    private Random random;\n    private IntComparator reverseSort;\n\n}\n\nclass IntTimSortTest {\n\n    private Random random;\n    private IntComparator reverseSort;\n\n    @Test\n    public void testSort_Random() {\n", "reference": "\n        int[] ints = randomInts(15);\n        IntTimSort.sort(ints, reverseSort);\n\n        for (int i = 1; i < ints.length; i++) {\n            assertTrue(ints[i - 1] >= ints[i], \"Failed at \" + i + \": \" + ints[i - 1] + \" vs \" + ints[i]);\n        }\n    }\n\n}", "prediction": "        int[] a = new int[1000];\n        for (int i = 0; i < a.length; i++) {\n            a[i] = random.nextInt();\n        }\n        IntTimSort.sort(a, reverseSort);\n        assertTrue(isSorted(a, reverseSort));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "165012876_2", "part": [1, 1], "seq": [1, 1], "prompt": "class Runfiles {\n\n  public static Runfiles create() throws IOException {\n    return create(System.getenv());\n  }\n\n  private  Runfiles();\n\n  public static Runfiles create(Map<String, String> env);\n  public final String rlocation(String path);\n  public abstract Map<String, String> getEnvVars();\n  private static boolean isManifestOnly(Map<String, String> env);\n  private static String getManifestPath(Map<String, String> env);\n  private static String getRunfilesDir(Map<String, String> env);\n  abstract String rlocationChecked(String path);\n  static Runfiles createManifestBasedForTesting(String manifestPath);\n  static Runfiles createDirectoryBasedForTesting(String runfilesDir);\n\n}\n\nclass RunfilesTest {\n\n  @Test\n  public void testRlocationArgumentValidation() throws Exception {\n", "reference": "    Path dir =\n        Files.createTempDirectory(\n            FileSystems.getDefault().getPath(System.getenv(\"TEST_TMPDIR\")), null);\n\n    Runfiles r = Runfiles.create(ImmutableMap.of(\"RUNFILES_DIR\", dir.toString()));\n    assertRlocationArg(r, null, null);\n    assertRlocationArg(r, \"\", null);\n    assertRlocationArg(r, \"../foo\", \"is not normalized\");\n    assertRlocationArg(r, \"foo/..\", \"is not normalized\");\n    assertRlocationArg(r, \"foo/../bar\", \"is not normalized\");\n    assertRlocationArg(r, \"./foo\", \"is not normalized\");\n    assertRlocationArg(r, \"foo/.\", \"is not normalized\");\n    assertRlocationArg(r, \"foo/./bar\", \"is not normalized\");\n    assertRlocationArg(r, \"//foobar\", \"is not normalized\");\n    assertRlocationArg(r, \"foo//\", \"is not normalized\");\n    assertRlocationArg(r, \"foo//bar\", \"is not normalized\");\n    assertRlocationArg(r, \"\\\\foo\", \"path is absolute without a drive letter\");\n  }\n\n}", "prediction": "    Runfiles runfiles = Runfiles.create();\n    try {\n      runfiles.rlocation(null);\n      fail();\n    } catch (NullPointerException expected) {\n    }\n    try {\n      runfiles.rlocation(\"\");\n      fail();\n    } catch (IllegalArgumentException expected) {\n    }\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "165370485_20", "part": [1, 1], "seq": [1, 1], "prompt": "class Socks5IqHandler extends DefaultIQHandler {\n\n    @Override\n    protected List<Stanza> handleSet(IQStanza stanza, ServerRuntimeContext serverRuntimeContext, SessionContext sessionContext, StanzaBroker stanzaBroker) {\n        /*\n            C: <iq from='requester@example.com/foo'\n                    id='oqx6t1c9'\n                    to='streamer.example.com'\n                    type='set'>\n                  <query xmlns='http://jabber.org/protocol/bytestreams'\n                     sid='vxf9n471bn46'>\n                    <activate>target@example.org/bar</activate>\n                  </query>\n               </iq>\n               \n            S: <iq from='streamer.example.com'\n                    id='oqx6t1c9'\n                    to='requester@example.com/foo'\n                    type='result'/>\n                    \n                    \n            SHA1 Hash of: (SID + Requester JID + Target JID)\n         */\n        \n        try {\n            XMLElement queryElm = stanza.getSingleInnerElementsNamed(\"query\", NamespaceURIs.XEP0065_SOCKS5_BYTESTREAMS);\n            XMLElement activateElm = queryElm.getSingleInnerElementsNamed(\"activate\", NamespaceURIs.XEP0065_SOCKS5_BYTESTREAMS);\n            \n            String sid = queryElm.getAttributeValue(\"sid\");\n            \n            Entity target = EntityImpl.parse(activateElm.getInnerText().getText());\n            \n            Entity requester = stanza.getFrom();\n            \n            String hash = DigestUtils.shaHex(sid + requester.getFullQualifiedName() + target.getFullQualifiedName());\n            \n            if(connections.activate(hash)) {\n                Stanza result = StanzaBuilder.createIQStanza(jid, requester, IQStanzaType.RESULT, stanza.getID()).build();\n                return Collections.singletonList(result);\n            } else {\n                throw new RuntimeException(\"Pair not found\");\n            }\n        } catch(Exception e) {\n            return Collections.singletonList(ServerErrorResponses.getStanzaError(StanzaErrorCondition.BAD_REQUEST, stanza, StanzaErrorType.CANCEL, null, null, null));\n        }\n    }\n\n    public  Socks5IqHandler(Entity jid, InetSocketAddress proxyAddress, Socks5ConnectionsRegistry connections);\n\n    @Override protected boolean verifyInnerElement(Stanza stanza);\n    @Override protected List<Stanza> handleGet(IQStanza stanza, ServerRuntimeContext serverRuntimeContext, SessionContext sessionContext, StanzaBroker stanzaBroker);\n\n    private static final Entity FROM;\n    private static final Entity TARGET;\n    private static final Entity TO;\n    private ServerRuntimeContext serverRuntimeContext;\n    private SessionContext sessionContext;\n    private IQStanza stanza;\n    private Socks5ConnectionsRegistry connectionsRegistry;\n    private Entity jid;\n    private InetSocketAddress proxyAddress;\n    private Socks5IqHandler handler;\n\n}\n\nclass Socks5IqHandlerTest extends DefaultIQHandler {\n\n    private static final Entity FROM;\n    private static final Entity TARGET;\n    private static final Entity TO;\n    private ServerRuntimeContext serverRuntimeContext;\n    private SessionContext sessionContext;\n    private IQStanza stanza;\n    private Socks5ConnectionsRegistry connectionsRegistry;\n    private Entity jid;\n    private InetSocketAddress proxyAddress;\n    private Socks5IqHandler handler;\n\n    @Test\n    public void handleSetActivate() throws BindException, XMLSemanticError {\n", "reference": "        IQStanza request = (IQStanza) IQStanza.getWrapper(StanzaBuilder\n                .createIQStanza(FROM, TO, IQStanzaType.SET, \"id1\")\n                .startInnerElement(\"query\", NamespaceURIs.XEP0065_SOCKS5_BYTESTREAMS).addAttribute(\"sid\", \"sid1\")\n                .startInnerElement(\"activate\", NamespaceURIs.XEP0065_SOCKS5_BYTESTREAMS)\n                .addText(TARGET.getFullQualifiedName()).build());\n\n        String hash = DigestUtils.shaHex(\"sid1\" + FROM.getFullQualifiedName() + TARGET.getFullQualifiedName());\n        when(connectionsRegistry.activate(hash)).thenReturn(true);\n\n        List<Stanza> responses = handler.handleSet(request, serverRuntimeContext, sessionContext, null);\n        Stanza response = responses.get(0);\n\n        Stanza expected = StanzaBuilder.createIQStanza(TO, FROM, IQStanzaType.RESULT, \"id1\").build();\n\n        StanzaAssert.assertEquals(expected, response);\n\n        verify(connectionsRegistry).activate(hash);\n    }\n\n}", "prediction": "       \n        XMLElement queryElm = stanza.getSingleInnerElementsNamed(\"query\", NamespaceURIs.XEP0065_SOCKS5_BYTESTREAMS);\n        XMLElement activateElm = queryElm.getSingleInnerElementsNamed(\"activate\", NamespaceURIs.XEP0065_SOCKS5_BYTESTREAMS);\n        \n        String sid = queryElm.getAttributeValue(\"sid\");\n        \n        Entity target = EntityImpl.parse(activateElm.getInnerText().getText());\n        \n        Entity requester = stanza.getFrom();\n        \n        String hash = DigestUtils.shaHex(sid + requester.getFullQualifiedName() + target.getFullQualifiedName());\n        \n        Socks5Connection connection = new Socks5Connection(proxyAddress, target, requester);\n        \n        connectionsRegistry.register(hash, connection);\n        \n        List<Stanza> result = handler.handleSet(stanza, serverRuntimeContext, sessionContext, null);\n        \n        assertEquals(1, result.size());\n        \n        Stanza iqResult = result.get(0);\n        \n        assertEquals(IQStanzaType.RESULT, iqResult.getType());\n        assertEquals(stanza.getID(), iqResult.getID());\n        assertEquals(stanza.getFrom(), iqResult.getTo());\n        \n        assertEquals(0, connectionsRegistry.getConnections().size());\n        \n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "166984581_1", "part": [1, 1], "seq": [1, 1], "prompt": "class UserController {\n\n    @PostMapping(\"/create/user\")\n    public CreateUserResponse createUser(@RequestBody CreateUserRequest request) throws AdException {\n        log.info(\"ad-sponsor: createUser -> {}\", JSON.toJSONString(request));\n        return iUserService.createUser(request);\n    }\n\n    @Autowired public  UserController(IUserService iUserService);\n\n    @Autowired\n    private RestTemplate template;\n    @Autowired\n    private IUserService iUserService;\n\n}\n\nclass UserControllerTest {\n\n    @Autowired\n    private RestTemplate template;\n    @Autowired\n    private IUserService iUserService;\n\n    @Test\n    public void testCreateUser() {\n", "reference": "        Map<String, String> map = new HashMap<>();\n        map.put(\"username\", \"qinyi\");\n        HttpHeaders headers = new HttpHeaders();\n        headers.setContentType(MediaType.APPLICATION_JSON);\n        HttpEntity<Map<String, String>> entity = new HttpEntity<>(map, headers);\n        CommonResponse response = template.postForEntity(\"http://127.0.0.1:7000/ad-sponsor/create/user\",\n                entity,\n                CommonResponse.class).getBody();\n        log.debug(JSON.toJSONString(response));\n    }\n\n}", "prediction": "        CreateUserRequest request = new CreateUserRequest();\n        request.setUserId(\"123456\");\n        request.setUserName(\"\u5f20\u4e09\");\n        request.setPassword(\"123456\");\n        request.setEmail(\"123456@qq.com\");\n        request.setMobile(\"123456\");\n        request.setStatus(1);\n        request.setCreateTime(new Date());\n        request.setUpdateTime(new Date());\n        CreateUserResponse response = template.postForObject(\"http://localhost:8080/create/user\", request, CreateUserResponse.class);\n        log.info(\"ad-sponsor: testCreateUser -> {}\", JSON.toJSONString(response));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "167169496_1", "part": [1, 1], "seq": [1, 1], "prompt": "class Dispatcher {\n\n    public static Object execute(String name, Object... args) {\n        final Handler handler = ref.get().get(name);\n        if (handler == null) {\n            return DefaultHandler.INSTANCE.execute(args);\n        } else {\n            return handler.execute(args);\n        }\n    }\n\n    private  Dispatcher();\n\n    static void register(String name, Handler handler);\n    static void registerAll(Map<String, Handler> handlers);\n    private static Map<String, Handler> update(Map<String, Handler> cur, Map<String, Handler> handlers);\n\n}\n\nclass DispatcherTest {\n\n    @Test\n    public void should_handle_default() {\n", "reference": "        assertNull(Dispatcher.execute(\"x\"));\n    }\n\n}", "prediction": "        assertEquals(\"default\", Dispatcher.execute(\"unknown\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "169146883_3", "part": [1, 1], "seq": [1, 1], "prompt": "class Jeu {\n\n    public final boolean finJeu() {\n        return age >= 3;\n    }\n\n    public  Jeu(int nbJoueurs);\n\n    public final int getTour();\n    public final int getAge();\n    public final ArrayList<ArrayList<Carte>> getDecks();\n    public final int getTailleDeck();\n    public final ArrayList<Carte> getDeckPrincipal();\n    public final ArrayList<Joueur> getJoueurs();\n    public final void tourSuivant();\n    public final void initCartes();\n    public final void roulementCarte();\n    public final void distributionCarte();\n    public final void distributionPlateau();\n    public final String jouerAction(Action ja);\n    public final boolean finAge();\n    private final void compareConfiltsJoueur(Joueur j1, Joueur j2);\n    public final void ageSuivant();\n    public final ArrayList<int[]> getClassement();\n    public final ArrayList<VisionJeu> getVisionsJeu();\n\n    private Jeu testDuJeu;\n\n}\n\nclass JeuTest {\n\n    private Jeu testDuJeu;\n\n    @Test\n    public final void finJeuTest() {\n", "reference": "        changeField(\"age\", 1);\n        assertEquals(false, testDuJeu.finJeu());\n        changeField(\"age\", 4);\n        assertEquals(true, testDuJeu.finJeu());\n    }\n\n}", "prediction": "        assertTrue(testDuJeu.finJeu());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "169301877_0", "part": [1, 1], "seq": [1, 1], "prompt": "class ChainedHostResolver implements AdvancedHostResolver {\n\n    @Override\n    public Collection<InetAddress> resolve(String host) {\n        readLock.lock();\n        try {\n            // attempt to resolve the host using all resolvers. returns the results from the first successful resolution.\n            return resolvers.stream()\n                    .map(resolver -> resolver.resolve(host))\n                    .filter(results -> !results.isEmpty())\n                    .findFirst()\n                    .orElse(emptyList());\n\n            // no resolvers returned results\n        } finally {\n            readLock.unlock();\n        }\n    }\n\n    public  ChainedHostResolver(Collection<? extends AdvancedHostResolver> resolvers);\n\n    public Collection<? extends AdvancedHostResolver> getResolvers();\n    @Override public void remapHosts(Map<String, String> hostRemappings);\n    @Override public void remapHost(String originalHost, String remappedHost);\n    @Override public void removeHostRemapping(String originalHost);\n    @Override public void clearHostRemappings();\n    @Override public Map<String, String> getHostRemappings();\n    @Override public Collection<String> getOriginalHostnames(String remappedHost);\n    @Override public void clearDNSCache();\n    @Override public void setPositiveDNSCacheTimeout(int timeout, TimeUnit timeUnit);\n    @Override public void setNegativeDNSCacheTimeout(int timeout, TimeUnit timeUnit);\n\n}\n\nclass ChainedHostResolverTest {\n\n    @Test\n    public void testResolveReturnsFirstResults() {\n", "reference": "        AdvancedHostResolver firstResolver = mock(AdvancedHostResolver.class);\n        AdvancedHostResolver secondResolver = mock(AdvancedHostResolver.class);\n        ChainedHostResolver chainResolver = new ChainedHostResolver(ImmutableList.of(firstResolver, secondResolver));\n\n        when(firstResolver.resolve(\"1.1.1.1\")).thenReturn(TestConstants.addressOnesList);\n        when(secondResolver.resolve(\"1.1.1.1\")).thenReturn(Collections.<InetAddress>emptyList());\n\n        Collection<InetAddress> results = chainResolver.resolve(\"1.1.1.1\");\n        assertNotNull(\"Resolver should not return null results\", results);\n        assertThat(\"Expected resolver to return a result\", results, not(empty()));\n        Assert.assertEquals(\"Resolver returned unexpected result\", TestConstants.addressOnes, Iterables.get(results, 0));\n\n        verify(secondResolver, never()).resolve(\"1.1.1.1\");\n\n        reset(firstResolver);\n        reset(secondResolver);\n\n        when(firstResolver.resolve(\"2.2.2.2\")).thenReturn(Collections.<InetAddress>emptyList());\n        when(secondResolver.resolve(\"2.2.2.2\")).thenReturn(TestConstants.addressTwosList);\n\n        results = chainResolver.resolve(\"2.2.2.2\");\n        assertNotNull(\"Resolver should not return null results\", results);\n        assertThat(\"Expected resolver to return a result\", results, not(empty()));\n        Assert.assertEquals(\"Resolver returned unexpected result\", TestConstants.addressTwos, Iterables.get(results, 0));\n\n        verify(firstResolver).resolve(\"2.2.2.2\");\n        verify(secondResolver).resolve(\"2.2.2.2\");\n    }\n\n}", "prediction": "        AdvancedHostResolver resolver1 = mock(AdvancedHostResolver.class);\n        AdvancedHostResolver resolver2 = mock(AdvancedHostResolver.class);\n        AdvancedHostResolver resolver3 = mock(AdvancedHostResolver.class);\n        when(resolver1.resolve(\"host\")).thenReturn(Collections.singletonList(InetAddress.getByName(\"1.1.1.1\")));\n        when(resolver2.resolve(\"host\")).thenReturn(Collections.singletonList(InetAddress.getByName(\"2.2.2.2\")));\n        when(resolver3.resolve(\"host\")).thenReturn(Collections.singletonList(InetAddress.getByName(\"3.3.3.3\")));\n\n        ChainedHostResolver chainedResolver = new ChainedHostResolver(Arrays.asList(resolver1, resolver2, resolver3));\n        Collection<InetAddress> results = chainedResolver.resolve(\"host\");\n\n        assertThat(results).containsExactly(InetAddress.getByName(\"1.1.1.1\"));\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "171409385_0", "part": [1, 1], "seq": [1, 1], "prompt": "class StockAPI {\n\n    @GetMapping\n    public ResponseEntity<List<Stock>> findAll() {\n        return ResponseEntity.ok(stockService.findAll());\n    }\n\n    @GetMapping(\"/{stockId}\") public ResponseEntity<Stock> findById(@PathVariable Long stockId);\n    @PostMapping public ResponseEntity create(@RequestBody Stock stock);\n    @PatchMapping(\"/{stockId}\") public ResponseEntity<Stock> update(@PathVariable Long stockId, @RequestBody Stock updatingStock);\n    @DeleteMapping(\"/{id}\") public ResponseEntity delete(@PathVariable Long id);\n\n    @Autowired\n    private MockMvc mockMvc;\n    @MockBean\n    private StockService stockService;\n\n}\n\nclass StockAPITest {\n\n    @Autowired\n    private MockMvc mockMvc;\n    @MockBean\n    private StockService stockService;\n\n    @Test\n    public void findAll() throws Exception {\n", "reference": "        // given\n        Stock stock = new Stock();\n        stock.setId(1L);\n        stock.setName(\"Stock 1\");\n        stock.setPrice(new BigDecimal(1));\n\n        List<Stock> stocks = Arrays.asList(stock);\n        given(stockService.findAll()).willReturn(stocks);\n\n        // when + then\n        this.mockMvc.perform(get(\"/api/v1/stocks\"))\n                .andExpect(status().isOk())\n                .andExpect(content().json(\"[{'id': 1,'name': 'Stock 1';'price': 1}]\"));\n    }\n\n}", "prediction": "        mockMvc.perform(get(\"/stocks\"))\n                .andExpect(status().isOk())\n                .andExpect(content().contentType(MediaType.APPLICATION_JSON_UTF8))\n                .andExpect(jsonPath(\"$\", hasSize(2)))\n                .andExpect(jsonPath(\"$[0].id\", is(1)))\n                .andExpect(jsonPath(\"$[0].name\", is(\"Apple\")))\n                .andExpect(jsonPath(\"$[0].price\", is(100.0)))\n                .andExpect(jsonPath(\"$[1].id\", is(2)))\n                .andExpect(jsonPath(\"$[1].name\", is(\"Google\")))\n                .andExpect(jsonPath(\"$[1].price\", is(200.0)));\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "171415041_4", "part": [1, 1], "seq": [1, 1], "prompt": "class Producer {\n\n    public void produceProject(String config) throws Exception {\n        codes = Config.yamlInit(config);\n        String projectPath = codes.getProject().getBaseDir() + File.separator + codes.getProject().getName();\n        String createProjectResponse = GradleUtil.executeGradleCmd(projectPath, \"init\");\n        System.out.println(createProjectResponse);\n        configGradle();\n        copyConfig();\n    }\n\n    public void produceProject();\n    public void produceCodes();\n    public void produceCodes(String config);\n    private void baseProduceCodes(Codes codes);\n    private boolean isMac();\n    private boolean delDir(String filePath);\n    public void deleteOutput();\n    protected void produceFile(String templateDir, String outPath, Table table);\n    protected void init();\n    protected void configGradle();\n    private void createFilesFromTemplate();\n    protected void copyConfig();\n\n}\n\nclass ProducerTest {\n\n    @Test\n    public void productProject() throws IOException, InterruptedException {\n", "reference": "        Producer producer = new Producer();\n        producer.produceProject();\n    }\n\n}", "prediction": "        Producer producer = new Producer();\n        producer.produceProject(\"src/test/resources/config.yaml\");\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "171677657_3", "part": [1, 1], "seq": [1, 1], "prompt": "class CompletableFutureToObservable {\n\n    public static <T>Observable<T> fromCompletableFuture(CompletableFuture<T> cf) {\n        return Observable.create(subscriber -> cf.thenAccept(value -> { subscriber.onNext(value); subscriber.onComplete(); })\n                .exceptionally(ex -> { subscriber.onError(ex); return null;} ));\n    }\n\n    public static Observable<T> fromCompletableFutureWhichShouldNotBeUsed(CompletableFuture<T> cf);\n\n}\n\nclass CompletableFutureToObservableTest {\n\n    @Test\n    public void fromCompletableFuture() {\n", "reference": "        final CompletableFuture<String> cf = CompletableFuture.supplyAsync(CompletableFutureToObservableTest::supplyValue);\n\n        //final Observable<String> observable = CompletableFutureToObservable.fromCompletableFuture(cf);\n        final Observable<String> observable = CompletableFutureToObservable.fromCompletableFuture(cf);\n\n        observable.blockingSubscribe(System.out::println);\n\n\n        System.out.println(\"Done\");\n\n    }\n\n}", "prediction": "        CompletableFuture<String> cf = new CompletableFuture<>();\n        Observable<String> obs = CompletableFutureToObservable.fromCompletableFuture(cf);\n        TestSubscriber<String> ts = new TestSubscriber<>();\n        obs.subscribe(ts);\n        cf.complete(\"Hello\");\n        ts.assertValue(\"Hello\");\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "172529766_21", "part": [1, 1], "seq": [1, 1], "prompt": "class ScreenService extends BasicService implements OwnerAPISupport<Screen> {\n\n\t@GET\n\t@Path(\"/onboardings\")\n\t@Produces(MediaType.APPLICATION_JSON)\n\tpublic List<Screen> getOnboardings() {\n\t\tif (!isAdmin()) {\n\t\t\tthrowUnauthorized();\n\t\t}\n\n\t\treturn ScreenDAO.getOnboardings();\n\t}\n\n\t@GET @Path(\"/screens\") @Produces(MediaType.APPLICATION_JSON) public List<Screen> getScreens(@QueryParam(\"userId\") String userId);\n\t@GET @Path(\"/screens/{id}\") @Produces(MediaType.APPLICATION_JSON) public Screen getScreen(@PathParam(\"id\") long screenId,\n\t\t\t@DefaultValue(\"true\") @QueryParam(\"includeMetrics\") boolean includeMetrics,\n\t\t\t@DefaultValue(\"false\") @QueryParam(\"live\") boolean live);\n\t@GET @Path(\"/screens/bykey/{key}\") @Produces(MediaType.APPLICATION_JSON) public Screen getScreenByKey(@PathParam(\"key\") String key,\n\t\t\t@DefaultValue(\"true\") @QueryParam(\"includeMetrics\") boolean includeMetrics,\n\t\t\t@DefaultValue(\"false\") @QueryParam(\"live\") boolean live,\n\t\t\t@DefaultValue(\"false\") @QueryParam(\"autoOnboard\") boolean doOnboarding,\n\t\t\t@QueryParam(\"owner\") String requestedOwner);\n\tprivate Playlist getScreenshotPlaylist();\n\tprivate void removeMetrics(Screen result);\n\tprivate void checkRemoteValidity(Screen result);\n\tprivate void addOnboardingScreen(Screen screen);\n\t@POST @Path(\"/screens\") @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) public Screen createScreen(Screen screen);\n\t@PUT @Path(\"/screens/{id}\") @Produces(MediaType.APPLICATION_JSON) public Screen updateScreen(@PathParam(\"id\") long screenId, Screen screenData);\n\t@PUT @Path(\"/screens/{id}/statistics\") @Produces(MediaType.APPLICATION_JSON) public Screen updateScreenStatstics(@PathParam(\"id\") long screenId, Screen screenData);\n\t@GET @Path(\"/screens/{id}/health\") @Produces(MediaType.APPLICATION_JSON) public Screen.AliveState getScreenHealth(@PathParam(\"id\") long screenId);\n\t@GET @Path(\"/screens/{id}/events\") @Produces(MediaType.APPLICATION_JSON) public List<EventHistory> getScreenEvents(@PathParam(\"id\") long screenId);\n\t@GET @Path(\"/screens/{id}/eventsperhour\") @Produces(MediaType.APPLICATION_JSON) public List<BasicNameValuePair> getScreenEventsPerHour(@PathParam(\"id\") long screenId);\n\tprivate Map<DateTime, Long> calculateCount(List<EventHistory> data);\n\tprivate List<BasicNameValuePair> calculateHistogram(Map<DateTime, Long> data, int hourCount);\n\t@GET @Path(\"/screens/{id}/control\") @Produces(MediaType.APPLICATION_JSON) public Integer getRemoteKey(@PathParam(\"id\") long screenId);\n\t@PUT @Path(\"/screens/{id}/control/{key}\") @Produces(MediaType.APPLICATION_JSON) public Screen remoteControlScreen(@PathParam(\"id\") long screenId, Screen screenData, @PathParam(\"key\") int key);\n\t@POST @Path(\"/screens/{id}/copy\") @Consumes(MediaType.APPLICATION_JSON) public Screen copyScreen(@PathParam(\"id\") long screenId, Screen newScreen);\n\t@PUT @Path(\"/screens/{id}/requestedOwner\") @Produces(MediaType.APPLICATION_JSON) public Screen updateRequestedOwner(@PathParam(\"id\") long screenId, Screen screenData);\n\t@POST @Path(\"/screens/{id}/onboard\") @Produces(MediaType.APPLICATION_JSON) public Screen onboardScreen(@PathParam(\"id\") long screenId);\n\t@POST @Path(\"/claim/{key}\") @Produces(MediaType.APPLICATION_JSON) public Screen claimScreen(@PathParam(\"key\") String key, @DefaultValue(\"0\") @QueryParam(\"screenId\") long screenId);\n\t@DELETE @Path(\"/screens/{screenId}\") public Response deleteScreen(@PathParam(\"screenId\") long screenId);\n\t@Override @POST @Path(\"/screens/{screenId}/owners\") @Consumes(MediaType.APPLICATION_JSON) public Screen addOwners(@PathParam(\"screenId\") long screenId, Owner[] ownerData);\n\t@Override @DELETE @Path(\"/screens/{screenId}/owners/{ownerId}\") @Produces(MediaType.APPLICATION_JSON) public Screen deleteOwner(@PathParam(\"screenId\") long screenId, @PathParam(\"ownerId\") long ownerId);\n\t@POST @Path(\"/screenkey/{key}/appliancestart\") @Consumes(MediaType.APPLICATION_JSON) public Response registerApplianceStart(@PathParam(\"key\") String key, ApplianceInfo logContent);\n\n\tprivate PageService pageService;\n\tprivate PlaylistService playlistService;\n\tprivate ScreenService screenService;\n\tprivate FileService fileService;\n\tprivate Playlist playlist;\n\n}\n\nclass ScreenServiceTest extends BasicService {\n\n\tprivate PageService pageService;\n\tprivate PlaylistService playlistService;\n\tprivate ScreenService screenService;\n\tprivate FileService fileService;\n\tprivate Playlist playlist;\n\n\t@Test(expected = WebApplicationException.class)\n\tpublic void testUnauthorizedOnboarding() throws Exception {\n", "reference": "\t\tscreenService.getOnboardings();\n\t}\n\n}", "prediction": "\t\tscreenService.getOnboardings();\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "173924701_0", "part": [1, 1], "seq": [1, 1], "prompt": "class NewsViewModel extends BaseViewModel {\n\n\tpublic void createNewsPagedList() {\n\t\tif (newsPagedListLiveData.getValue() == null){\n\t\t\texecute(\n\t\t\tdisposable -> pagingDataStatus.postValue(DataStatus.LOADING),\n\t\t\tnewsUIPagedList -> {\n\t\t\t\tnewsPagedListLiveData.postValue(newsUIPagedList);\n\t\t\t\tpagingDataStatus.setValue(DataStatus.SUCCESS);\n\t\t\t},\n\t\t\tthrowable -> pagingDataStatus.postValue(DataStatus.ERROR),\n\t\t\tnewsUseCase.getNewsPagedList()\n\t\t\t);\n\t\t}\n\t}\n\n\t@Inject  NewsViewModel(@Named(value = IO_SCHEDULER) Scheduler subscribeOn, @Named(value = MAIN_THREAD_SCHEDULER) Scheduler observeOn, GetNewsUseCase<NewsUI> newsUsecase, PagingState pagingState);\n\n\tpublic void loadNews(int pageNumber);\n\tpublic LiveData<PagedList<NewsUI>> getNewsPagedListLiveData();\n\tpublic SingleLiveEvent<DataStatus> getLoadNewsStats();\n\tpublic LiveData<DataStatus> getPagingDataStatus();\n\tpublic PagingState getPagingState();\n\n\t@Rule\n\tpublic InstantTaskExecutorRule instantTaskExecutorRule;\n\t@Mock GetNewsUseCase<NewsUI> usecase;\n\t@Mock PagedList<NewsUI> pagedList;\n\tprivate NewsViewModel viewModel;\n\n}\n\nclass NewsViewModelTest {\n\n\t@Rule\n\tpublic InstantTaskExecutorRule instantTaskExecutorRule;\n\t@Mock GetNewsUseCase<NewsUI> usecase;\n\t@Mock PagedList<NewsUI> pagedList;\n\tprivate NewsViewModel viewModel;\n\n\t@Test\n\tpublic void verify_create_paged_list_called_only_once_in_success() throws InterruptedException {\n", "reference": "\t\twhen(usecase.getNewsPagedList()).thenReturn(Observable.just(pagedList));\n\t\tverify(usecase, times(0)).getNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tverify(usecase, times(1)).getNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tverify(usecase, times(1)).getNewsPagedList();\n\t}\n\n}", "prediction": "\t\t// Given\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNews", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "174306645_82", "part": [1, 1], "seq": [1, 1], "prompt": "class ProcessInstanceManagementResource extends BaseProcessInstanceManagementResource<Response> {\n\n    @Override\n    @DELETE\n    @Path(\"{processId}/instances/{processInstanceId}\")\n    @Produces(MediaType.APPLICATION_JSON)\n    public Response cancelProcessInstanceId(@PathParam(\"processId\") String processId, @PathParam(\"processInstanceId\") String processInstanceId) {\n        return doCancelProcessInstanceId(processId, processInstanceId);\n    }\n\n    public  ProcessInstanceManagementResource();\n    @Inject public  ProcessInstanceManagementResource(Processes processes, Application application);\n\n    @Override protected Response buildOkResponse(R body);\n    @Override protected Response badRequestResponse(String message);\n    @Override protected Response notFoundResponse(String message);\n    @Override @GET @Path(\"{processId}/nodes\") @Produces(MediaType.APPLICATION_JSON) public Response getProcessNodes(@PathParam(\"processId\") String processId);\n    @Override @GET @Path(\"{processId}/instances/{processInstanceId}/error\") @Produces(MediaType.APPLICATION_JSON) public Response getInstanceInError(@PathParam(\"processId\") String processId, @PathParam(\"processInstanceId\") String processInstanceId);\n    @Override @GET @Path(\"{processId}/instances/{processInstanceId}/nodeInstances\") @Produces(MediaType.APPLICATION_JSON) public Response getWorkItemsInProcessInstance(@PathParam(\"processId\") String processId, @PathParam(\"processInstanceId\") String processInstanceId);\n    @Override @POST @Path(\"{processId}/instances/{processInstanceId}/retrigger\") @Produces(MediaType.APPLICATION_JSON) public Response retriggerInstanceInError(@PathParam(\"processId\") String processId, @PathParam(\"processInstanceId\") String processInstanceId);\n    @Override @POST @Path(\"{processId}/instances/{processInstanceId}/skip\") @Produces(MediaType.APPLICATION_JSON) public Response skipInstanceInError(@PathParam(\"processId\") String processId, @PathParam(\"processInstanceId\") String processInstanceId);\n    @Override @POST @Path(\"{processId}/instances/{processInstanceId}/nodes/{nodeId}\") @Produces(MediaType.APPLICATION_JSON) public Response triggerNodeInstanceId(@PathParam(\"processId\") String processId, @PathParam(\"processInstanceId\") String processInstanceId, @PathParam(\"nodeId\") String nodeId);\n    @Override @POST @Path(\"{processId}/instances/{processInstanceId}/nodeInstances/{nodeInstanceId}\") @Produces(MediaType.APPLICATION_JSON) public Response retriggerNodeInstanceId(@PathParam(\"processId\") String processId, @PathParam(\"processInstanceId\") String processInstanceId, @PathParam(\"nodeInstanceId\") String nodeInstanceId);\n    @Override @DELETE @Path(\"{processId}/instances/{processInstanceId}/nodeInstances/{nodeInstanceId}\") @Produces(MediaType.APPLICATION_JSON) public Response cancelNodeInstanceId(@PathParam(\"processId\") String processId, @PathParam(\"processInstanceId\") String processInstanceId, @PathParam(\"nodeInstanceId\") String nodeInstanceId);\n\n    public static final String MESSAGE;\n    public static final String PROCESS_ID;\n    public static final String PROCESS_INSTANCE_ID;\n    public static final String NODE_ID;\n    private static RuntimeDelegate runtimeDelegate;\n    private ResponseBuilder responseBuilder;\n    private Processes processes;\n    @SuppressWarnings(\"rawtypes\")\n    private ProcessInstance processInstance;\n    private ProcessError error;\n    private Application application;\n    private ProcessInstanceManagementResource resource;\n\n}\n\nclass ProcessInstanceManagementResourceTest {\n\n    public static final String MESSAGE;\n    public static final String PROCESS_ID;\n    public static final String PROCESS_INSTANCE_ID;\n    public static final String NODE_ID;\n    private static RuntimeDelegate runtimeDelegate;\n    private ResponseBuilder responseBuilder;\n    private Processes processes;\n    @SuppressWarnings(\"rawtypes\")\n    private ProcessInstance processInstance;\n    private ProcessError error;\n    private Application application;\n    private ProcessInstanceManagementResource resource;\n\n    @Test\n    public void testCancelProcessInstanceId() {\n", "reference": "        resource.cancelProcessInstanceId(PROCESS_ID, PROCESS_INSTANCE_ID);\n        verify(resource).doCancelProcessInstanceId(PROCESS_ID, PROCESS_INSTANCE_ID);\n    }\n\n}", "prediction": "        Response response = resource.cancelProcessInstanceId(PROCESS_ID, PROCESS_INSTANCE_ID);\n        assertEquals(204, response.getStatus());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "174508778_0", "part": [1, 1], "seq": [1, 1], "prompt": "class RedisService {\n\n    public long getCurrentVersion() {\n        Object obj = this.redisTemplate.opsForValue().get(Constant.TRUNK_VERSIONS);\n        return null == obj ? 0L : Long.valueOf(obj.toString());\n    }\n\n    public long incrementVersion();\n    public void report(Set<String> urls, Set<String> trunks, long version);\n    public Set<String> getTrunks();\n    public void deleteTrunks();\n\n}\n\nclass TestRedisService  {\n\n    @Test\n    public void testCurrentVersion() {\n", "reference": "        System.out.println(this.redisService.getCurrentVersion());\n    }\n\n}", "prediction": "        long version = redisService.getCurrentVersion();\n        Assert.assertEquals(0, version);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "175026830_6", "part": [1, 1], "seq": [1, 1], "prompt": "class EmailAddressTokenizer {\n\n    public static Collection<EmailAddressToken> tokenize(final CharSequence cs) {\n        return tokenize(cs, false);\n    }\n\n    public static Collection<EmailAddressToken> tokenize(final CharSequence cs, final boolean requireExplicitDelimiter);\n    private static boolean moreThanJustWhiteSpaces(List<Token> tokens);\n    private static boolean isWhitespaceOrDelimiter(Token token);\n    private static EmailAddressToken combine(final CharSequence charSequence, List<Token> tokenList);\n    private static Token findFirstNonWhiteSpace(List<Token> tokens, boolean removeQuote);\n    private static Token findLastNonWhiteSpace(List<Token> tokens, boolean removeQuote);\n\n}\n\nclass EmailAddressTokenizerTest {\n\n    @Test\n    public void bracketedCommaSeparated() {\n", "reference": "        final String input = \"<a@example.com>, <b@example.com>\";\n        final Collection<EmailAddressToken> expected = ImmutableList.of(\n                new EmailAddressToken(\n                        0,\n                        15,\n                        EmailAddress.builder().email(\"a@example.com\").build()\n                ),\n                new EmailAddressToken(\n                        16,\n                        31,\n                        EmailAddress.builder().email(\"b@example.com\").build()\n                )\n        );\n        final Collection<EmailAddressToken> actual = EmailAddressTokenizer.tokenize(input);\n\n        Assert.assertArrayEquals(\n                expected.toArray(new EmailAddressToken[0]),\n                actual.toArray(new EmailAddressToken[0])\n        );\n    }\n\n}", "prediction": "        assertEquals(Arrays.asList(new EmailAddressToken(\"a\", false), new EmailAddressToken(\"b\", false)),\n                EmailAddressTokenizer.tokenize(\"a, b\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "176837289_44", "part": [1, 1], "seq": [1, 1], "prompt": "class SessionCacheFetcher extends CacheFetcher {\n\n    @Override\n    protected Object computeResult() {\n        return SessionTokenUtils.getSessionFromRawToken(rawToken);\n    }\n\n    public  SessionCacheFetcher(String rawToken);\n\n    @Override protected String getCacheKey();\n    @Override protected int getLocalCacheTime();\n    @Override protected int getRemoteCacheTime();\n    @Override protected Object fromJson(String json);\n\n    private static final String GCS;\n    private static final String BIGQUERY;\n    private static final String ALICE;\n    private static final String MOCK_BUCKET;\n    private static final Long SESSION_RENEW_PERIOD;\n    private static final Long SESSION_MAXIMUM_LIFETIME;\n    @ClassRule\n    public static SettingsOverride settingsOverride;\n\n}\n\nclass SessionCacheFetcherTest {\n\n    private static final String GCS;\n    private static final String BIGQUERY;\n    private static final String ALICE;\n    private static final String MOCK_BUCKET;\n    private static final Long SESSION_RENEW_PERIOD;\n    private static final Long SESSION_MAXIMUM_LIFETIME;\n    @ClassRule\n    public static SettingsOverride settingsOverride;\n\n    @Test\n    public void testComputeResult() {\n", "reference": "        Session session = createSession();\n        String rawToken = SessionTokenUtils.marshallSessionToken(session);\n        SessionCacheFetcher fetcher = new SessionCacheFetcher(rawToken);\n        Session computed = (Session) fetcher.computeResult();\n        assertEquals(session.getId(), computed.getId());\n    }\n\n}", "prediction": "        SessionCacheFetcher fetcher = new SessionCacheFetcher(rawToken);\n        assertEquals(SessionTokenUtils.getSessionFromRawToken(rawToken), fetcher.computeResult());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "180337008_32", "part": [1, 1], "seq": [1, 1], "prompt": "class RightsService {\n\n    public List<String> getRights() {\n        List<String> rights = new ArrayList<>();\n\n        modulesService.activeBusinessApplications().forEach(application -> {\n            InstanceInfo instanceInfo = application.getInstances().get(0);\n            String serviceName = modulesService.extractServiceName(application.getName());\n            try {\n                String[] response =\n                        restTemplate.getForObject(this.buildRightsEndpointUrl(serviceName), String[].class);\n                rights.addAll(Arrays.asList(Objects.requireNonNull(response)));\n            } catch(RestClientException e) {\n                LOGGER.warn(\"[getRights] An error occured in module {} : {}\", application.getName(), e.getMessage());\n            }\n        });\n\n        return rights;\n    }\n\n    @Autowired public  RightsService(RestTemplateBuilder builder, ModulesService modulesService, DiscoveryUtils discoveryUtils);\n\n    private String buildRightsEndpointUrl(String applicationName);\n\n    @SpyBean\n    private RightsService rightsService;\n    @MockBean\n    private ModulesService modulesService;\n    @MockBean\n    private DiscoveryUtils discoveryUtils;\n    @MockBean\n    private EurekaClient discoveryClient;\n    @Mock\n    private InstanceInfo instanceInfo;\n    @Mock\n    private InstanceInfo instanceInfo1;\n    @Mock\n    private Application application;\n    @Rule\n    public WireMockRule wireMockRule;\n\n}\n\nclass RightsServiceTest {\n\n    @SpyBean\n    private RightsService rightsService;\n    @MockBean\n    private ModulesService modulesService;\n    @MockBean\n    private DiscoveryUtils discoveryUtils;\n    @MockBean\n    private EurekaClient discoveryClient;\n    @Mock\n    private InstanceInfo instanceInfo;\n    @Mock\n    private InstanceInfo instanceInfo1;\n    @Mock\n    private Application application;\n    @Rule\n    public WireMockRule wireMockRule;\n\n    @Test\n    public void getRights() {\n", "reference": "        InstanceInfo instanceInfoActe = this.instanceInfo(\"acte\", \"acte-service\", \"BUSINESS\");\n        InstanceInfo instanceInfoPes = this.instanceInfo(\"pes\", \"pes-service\", \"BUSINESS\");\n        InstanceInfo instanceInfoConvocation = this.instanceInfo(\"convocation\", \"convocation-service\", \"BUSINESS\");\n\n        Application applicationActe = this.application(instanceInfoActe, \"acte-service\");\n        Application applicationPes = this.application(instanceInfoPes, \"pes-service\");\n        Application applicationConvocation = this.application(instanceInfoConvocation, \"convocation-service\");\n\n\n        List<Application> applications = new ArrayList<>();\n\n        applications.add(applicationActe);\n        applications.add(applicationPes);\n        applications.add(applicationConvocation);\n\n        given(modulesService.activeBusinessApplications()).willReturn(applications);\n\n        List<String> rights = rightsService.getRights();\n\n        Assert.assertEquals(6, rights.size());\n    }\n\n}", "prediction": "        List<String> rights = rightsService.getRights();\n\n        assertThat(rights).contains(\"right1\", \"right2\");\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "181071001_137", "part": [1, 1], "seq": [1, 1], "prompt": "class DatabaseFDFlowManager extends BaseService implements FDFlowManager {\n\n    @Override\n    public FDFlowEvent deleteFlowEvent(final String flowEventId) {\n        if (StringUtils.isBlank(flowEventId)) {\n            throw new IllegalArgumentException(\"Flow event id cannot be null or blank\");\n        }\n\n        final Optional<FDFlowEventEntity> flowEventEntity = flowEventRepository.findById(flowEventId);\n        if (!flowEventEntity.isPresent()) {\n            throw new ResourceNotFoundException(\"No flow event exists for the given id\");\n        }\n\n        if (flowEventEntity.get().getEventType() == FDFlowEventType.FLOW_PUBLISHED) {\n            throw new IllegalArgumentException(\"Cannot delete event because deleting events of type \"\n                    + FDFlowEventType.FLOW_PUBLISHED + \" is not allowed\");\n        }\n\n        final FDFlowEntity flowEntity = flowEventEntity.get().getFlow();\n\n        final Long numEventsForFlow = flowEventRepository.countByFlow(flowEntity);\n        if (numEventsForFlow <= 1) {\n            throw new IllegalStateException(\"Cannot delete event because there is only one event for the given flow\");\n        }\n\n        flowEventRepository.delete(flowEventEntity.get());\n\n        // we don't know if the event being deleted is the latest event, and if it is then the cached version of\n        // the flow is no longer accurate because it was based on the deleted event\n        if (flowsById.containsKey(flowEntity.getId())) {\n            flowsById.remove(flowEntity.getId());\n        }\n\n        return modelMapper.map(flowEventEntity.get(), FDFlowEvent.class);\n    }\n\n    @Autowired public  DatabaseFDFlowManager(final FDFlowRepository flowRepository,\n                                 final FDFlowEventRepository flowEventRepository,\n                                 final OptionalModelMapper modelMapper,\n                                 final ObjectMapper objectMapper,\n                                 final Validator validator);\n\n    @Override public Optional<FDFlowMetadata> getFlowMetadata(final String flowId);\n    @Override public Optional<FDFlow> getFlow(final String flowId);\n    @Override public FDFlowMetadata createFlow(final String agentClass, final NiFiUser user);\n    @Override public List<FDFlowMetadata> getAvailableFlows();\n    @Override public List<FDFlowSummary> getFlowSummaries();\n    @Override public FDFlowMetadata deleteFlow(final String flowId);\n    @Override public List<FDFlowEvent> getFlowEvents(final String flowId);\n    @Override public Optional<FDFlowEvent> getLatestFlowEvent(final String flowId);\n    private Optional<FDFlowEventEntity> getLatestFlowEventEntity(final String flowId);\n    @Override public Optional<FDFlowEvent> getLatestPublishFlowEvent(final String flowId);\n    @Override public Optional<FDFlowEvent> getFlowEvent(final String flowEventId);\n    @Override public FDFlowEvent addFlowEvent(final FDFlowEvent flowEvent, final VersionedProcessGroup flowContent, final NiFiUser user);\n    @Override public void retainPublishEvents(final String flowId);\n    @Override public void revertToFlowRevision(final String flowId, final BigInteger flowRevision);\n    private String serializeFlowContent(final VersionedProcessGroup flowContent);\n    private VersionedProcessGroup deserialize(String flowContent);\n    private FDVersionInfo createVersionInfo(final FDFlowEventEntity flowEvent);\n\n    @Autowired\n    private FDFlowManager flowManager;\n\n}\n\nclass TestDatabaseFDFlowManager extends BaseService {\n\n    @Autowired\n    private FDFlowManager flowManager;\n\n    @Test\n    public void testDeleteFlowEvent() {\n", "reference": "        // Verify that we start with 3 events for flow #2\n        final String flowId = \"2\";\n        final List<FDFlowEvent> flowEvents = flowManager.getFlowEvents(flowId);\n        assertEquals(3, flowEvents.size());\n\n        final FDFlowEvent flowEvent2 = flowManager.deleteFlowEvent(\"2\");\n        assertNotNull(flowEvent2);\n\n        final FDFlowEvent flowEvent3 = flowManager.deleteFlowEvent(\"3\");\n        assertNotNull(flowEvent3);\n\n        try {\n            flowManager.deleteFlowEvent(\"4\");\n            Assert.fail(\"Should have thrown exception\");\n        } catch (Exception e) {\n\n        }\n    }\n\n}", "prediction": "        final FDFlowEvent flowEvent = flowManager.getLatestFlowEvent(\"12345678-1234-1234-1234-1234567890ab\").get();\n        final FDFlowEventEntity flowEventEntity = flowEventRepository.findById(flowEvent.getId()).get();\n        assertEquals(flowEvent.getEventType(), flowEventEntity.getEventType());\n\n        flowManager.deleteFlowEvent(flowEvent.getId());\n\n        assertFalse(flowEventRepository.findById(flowEvent.getId()).isPresent());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "181421086_38", "part": [1, 1], "seq": [1, 1], "prompt": "class TCP extends BasePacket {\n\n    public byte[] serialize() {\n        int length;\n        if (dataOffset == 0)\n            dataOffset = 5;  // default header length\n        length = dataOffset << 2;\n        byte[] payloadData = null;\n        if (payload != null) {\n            payload.setParent(this);\n            payloadData = payload.serialize();\n            length += payloadData.length;\n        }\n\n        byte[] data = new byte[length];\n        ByteBuffer bb = ByteBuffer.wrap(data);\n\n        bb.putShort((short)this.sourcePort.getPort()); //TCP ports are defined to be 16 bits\n        bb.putShort((short)this.destinationPort.getPort());\n        bb.putInt(this.sequence);\n        bb.putInt(this.acknowledge);\n        bb.putShort((short) (this.flags | (dataOffset << 12)));\n        bb.putShort(this.windowSize);\n        bb.putShort(this.checksum);\n        bb.putShort(this.urgentPointer);\n        if (dataOffset > 5) {\n            int padding;\n            bb.put(options);\n            padding = (dataOffset << 2) - 20 - options.length;\n            for (int i = 0; i < padding; i++)\n                bb.put((byte) 0);\n        }\n        if (payloadData != null)\n            bb.put(payloadData);\n\n        if (this.parent != null && this.parent instanceof IPv4)\n            ((IPv4)this.parent).setProtocol(IpProtocol.TCP);\n\n        // compute checksum if needed\n        if (this.checksum == 0) {\n            bb.rewind();\n            int accumulation = 0;\n\n            // compute pseudo header mac\n            if (this.parent != null && this.parent instanceof IPv4) {\n                IPv4 ipv4 = (IPv4) this.parent;\n                accumulation += ((ipv4.getSourceAddress().getInt() >> 16) & 0xffff)\n                        + (ipv4.getSourceAddress().getInt() & 0xffff);\n                accumulation += ((ipv4.getDestinationAddress().getInt() >> 16) & 0xffff)\n                        + (ipv4.getDestinationAddress().getInt() & 0xffff);\n                accumulation += ipv4.getProtocol().getIpProtocolNumber() & 0xff;\n                accumulation += length & 0xffff;\n            }\n\n            for (int i = 0; i < length / 2; ++i) {\n                accumulation += 0xffff & bb.getShort();\n            }\n            // pad to an even number of shorts\n            if (length % 2 > 0) {\n                accumulation += (bb.get() & 0xff) << 8;\n            }\n\n            accumulation = ((accumulation >> 16) & 0xffff)\n                    + (accumulation & 0xffff);\n            this.checksum = (short) (~accumulation & 0xffff);\n            bb.putShort(16, this.checksum);\n        }\n        return data;\n    }\n\n    public TransportPort getSourcePort();\n    public TCP setSourcePort(TransportPort sourcePort);\n    public TCP setSourcePort(int sourcePort);\n    public TransportPort getDestinationPort();\n    public TCP setDestinationPort(TransportPort destinationPort);\n    public TCP setDestinationPort(int destinationPort);\n    public short getChecksum();\n    public int getSequence();\n    public TCP setSequence(int seq);\n    public int getAcknowledge();\n    public TCP setAcknowledge(int ack);\n    public byte getDataOffset();\n    public TCP setDataOffset(byte offset);\n    public short getFlags();\n    public TCP setFlags(short flags);\n    public short getWindowSize();\n    public TCP setWindowSize(short windowSize);\n    public short getTcpChecksum();\n    public TCP setTcpChecksum(short checksum);\n    @Override public void resetChecksum();\n    public short getUrgentPointer(short urgentPointer);\n    public TCP setUrgentPointer(short urgentPointer);\n    public byte[] getOptions();\n    public TCP setOptions(byte[] options);\n    public TCP setChecksum(short checksum);\n    @Override public int hashCode();\n    @Override public boolean equals(Object obj);\n    @Override public IPacket deserialize(byte[] data, int offset, int length);\n\n    private byte[] pktSerialized;\n\n}\n\nclass TCPTest {\n\n    private byte[] pktSerialized;\n\n    @Test\n    public void testSerialize() {\n", "reference": "        IPacket packet = new IPv4()\n        .setDiffServ((byte) 0x20)\n        .setIdentification((short) 0x1d85)\n        .setFlags((byte) 0x00)\n        .setTtl((byte) 50)\n        .setSourceAddress(\"74.125.45.109\")\n        .setDestinationAddress(\"192.168.1.111\")\n        .setPayload(new TCP()\n                        .setSourcePort(993)\n                        .setDestinationPort(49202)\n                        .setSequence(0xe3adee88)\n                        .setAcknowledge(0xb7dad824)\n                        .setDataOffset((byte) 8)\n                        .setFlags((short) 0x10)\n                        .setWindowSize((short) 267)\n                        .setOptions(new byte[] {0x01, 0x01, 0x08, 0x0a, 0x20, (byte) 0x9a,\n                                                0x41, 0x04, 0x07, 0x76, 0x53, 0x1f})\n                        .setPayload(null)\n                   );\n        byte[] actual = packet.serialize();\n        assertTrue(Arrays.equals(pktSerialized, actual));\n    }\n\n}", "prediction": "        TCP tcp = new TCP();\n        tcp.setSourcePort(1234);\n        tcp.setDestinationPort(5678);\n        tcp.setSequence(12345);\n        tcp.setAcknowledge(54321);\n        tcp.setDataOffset((byte) 5);\n        tcp.setFlags((short) 0x0000);\n        tcp.setWindowSize((short) 1024);\n        tcp.setTcpChecksum((short) 0x0000);\n        tcp.setUrgentPointer((short) 0x0000);\n        tcp.setOptions(new byte[] { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10 });\n        tcp.setPayload(new Data());\n        tcp.getPayload().setParent(tcp);\n        tcp.setParent(new IPv4());\n        tcp.getParent().setParent(new Ethernet());\n        tcp.getParent().getParent().setParent(new Packet());\n        tcp.getParent().getParent().getParent().setParent(new Packet());\n        tcp.getParent().getParent().getParent().getParent().setParent(new Packet());\n        tcp.getParent().getParent().getParent().getParent().getParent().setParent(new Packet());\n        tcp.getParent().getParent().getParent().getParent().getParent().getParent().setParent(new Packet());\n        tcp.getParent().getParent().getParent().getParent().getParent().getParent().getParent().setParent(new Packet());\n        tcp.getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().setParent(new Packet());\n        tcp.getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().setParent(new Packet());\n        tcp.getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().setParent(new Packet());\n        tcp.getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().setParent(new Packet());\n        tcp.getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().setParent(new Packet());\n        tcp.getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().setParent(new Packet());\n        tcp.getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().setParent(new Packet());\n        tcp.getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().setParent(new Packet());\n        tcp.getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().getParent().setParent(new Packet());\n        tcp.getParent().getParent().getParent().getParent().", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "183540010_2", "part": [1, 1], "seq": [1, 1], "prompt": "class CircularQueue {\n\n    public void put(Object item) {\n        precondition(item != null, \"put() null item\");\n        precondition(!full(),\n                \"put() into full CircularQueue\");\n        assert invariant();\n        data[in++] = item;\n        if (in >= data.length) {\n            in = 0;\n            wrapped = true;\n        }\n        assert invariant();\n    }\n\n    public  CircularQueue(int size);\n\n    public boolean empty();\n    public boolean full();\n    public boolean isWrapped();\n    public Object get();\n    private static void precondition(boolean cond, String msg);\n    private static boolean postcondition(boolean cond, String msg);\n    private boolean invariant();\n    public String dump();\n\n    private CircularQueue queue;\n    private int i;\n\n}\n\nclass CircularQueueTest {\n\n    private CircularQueue queue;\n    private int i;\n\n    @Test\n    public void nullPut() {\n", "reference": "        System.out.println(\"testNullPut\");\n        String msg = \"\";\n        try {\n            queue.put(null);\n        } catch (CircularQueueException e) {\n            msg = e.getMessage();\n            System.out.println(msg);\n        }\n        assertEquals(msg, \"put() null item\");\n    }\n\n}", "prediction": "        queue.put(null);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "184603374_4", "part": [1, 1], "seq": [1, 1], "prompt": "class Sort {\n\n    public static void buildHeap(int[] arr, int length) {\n        for (int i = 0; i < length; i++) {\n            adjustHeap(arr, i, length);\n        }\n    }\n\n    public static void maopaoSort(int[] data);\n    public static void quickSort(int[] data);\n    public static void insertSort(int[] data);\n    public static void selectSort(int[] data);\n    public static void quickSort(int[] data, int left, int right);\n    public static void quickSort2(int[] arr, int l, int r);\n    public static void heapSort(int[] arr, int node);\n    public static void adjustHeap(int[] arr, int index, int length);\n    public static void swap(int[] arr, int a_index, int b_index);\n\n}\n\nclass SortTest {\n\n    @Test\n    public void buildHeapTest() {\n", "reference": "        int[] data = {1, 4, 5, 3, 2};\n        Sort.buildHeap(data, data.length);\n        for (int i : data) {\n            System.out.println(i);\n        }\n    }\n\n}", "prediction": "        int[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n        Sort.buildHeap(arr, arr.length);\n        for (int i = 0; i < arr.length; i++) {\n            System.out.print(arr[i] + \" \");\n        }\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "184611677_5", "part": [1, 1], "seq": [1, 1], "prompt": "class SmsServiceImpl implements SmsService {\n\n    @Override\n    public void batchSend(List<String> mobileList, Integer smsTemplateId, Map<String, String> params) {\n        SmsTemplateDO smsTemplateDO = smsTemplateMapper.selectOne(\n                new QueryWrapper<SmsTemplateDO>().eq(\"id\", smsTemplateId));\n\n        if (smsTemplateDO == null\n                || smsTemplateDO.getDeleted().equals(DeletedStatusEnum.DELETED_YES.getValue())) {\n            throw new ServiceException(AdminErrorCodeEnum.SMS_TEMPLATE_NOT_EXISTENT.getCode(),\n                    AdminErrorCodeEnum.SMS_TEMPLATE_NOT_EXISTENT.getMessage());\n        }\n\n        SmsSignDO smsSignDO = smsSignMapper.selectOne(\n                new QueryWrapper<SmsSignDO>().eq(\"id\", smsTemplateDO.getSmsSignId()));\n\n        if (smsSignDO == null) {\n            // \u6dfb\u52a0\u65e5\u5fd7\n            smsSendMapper.insert(\n                    (SmsSendLogDO) new SmsSendLogDO()\n                            .setTemplateId(smsTemplateDO.getId())\n                            .setTemplate(smsTemplateDO.getTemplate())\n                            .setMessage(\"\u53d1\u9001\u6210\u529f!\")\n                            .setCreateTime(new Date())\n            );\n\n            throw new ServiceException(AdminErrorCodeEnum.SMS_SIGN_NOT_EXISTENT.getCode(),\n                    AdminErrorCodeEnum.SMS_SIGN_NOT_EXISTENT.getMessage());\n        }\n\n        // \u83b7\u53d6 client\n        SmsClient smsClient = getSmsClient(smsTemplateDO.getPlatform());\n\n        // \u53d1\u9001\u77ed\u4fe1\n        SmsClient.SendResult sendResult = smsClient.batchSend(mobileList, smsSignDO.getSign(),\n                smsTemplateDO.getTemplateCode(), smsTemplateDO.getTemplate(), params);\n\n        // \u6dfb\u52a0\u65e5\u5fd7\n        smsSendMapper.insert(\n                (SmsSendLogDO) new SmsSendLogDO()\n                        .setTemplateId(smsTemplateDO.getId())\n                        .setTemplate(smsTemplateDO.getTemplate())\n                        .setMessage(sendResult.getMessage())\n                        .setCreateTime(new Date())\n        );\n    }\n\n    @Override public PageSmsSignBO pageSmsSign(PageQuerySmsSignDTO queryDTO);\n    @Override public PageSmsTemplateBO pageSmsTemplate(PageQuerySmsTemplateDTO queryDTO);\n    @Override @Transactional public void addSign(String sign, Integer platform);\n    @Override public SmsSignBO getSign(Integer signId);\n    @Override @Transactional public void updateSign(Integer id, String newSign, Integer platform);\n    @Override public void deleteSign(Integer id);\n    @Override @Transactional public void addTemplate(Integer smsSignId, String templateCode,\n                            String template, Integer platform, Integer smsType);\n    @Override public SmsTemplateBO getTemplate(Integer id, Integer platform);\n    @Override @Transactional public void updateTemplate(Integer id, Integer smsSignId, String templateCode,\n                               String template, Integer platform, Integer smsType);\n    @Override @Transactional public void deleteTemplate(Integer id);\n    @Override public void singleSend(String mobile, Integer smsTemplateId, Map<String, String> params);\n    private SmsClient getSmsClient(Integer platform);\n\n    @Autowired\n    private SmsService smsService;\n\n}\n\nclass SmsServiceImplTest {\n\n    @Autowired\n    private SmsService smsService;\n\n    @Test\n    public void batchSendTest() {\n", "reference": "        String mobile = \"13302926050\";\n        Integer templateId = 7;\n        smsService.batchSend(Lists.newArrayList(mobile), templateId, ImmutableMap.of(\"code\", \"8888\"));\n    }\n\n}", "prediction": "        List<String> mobileList = new ArrayList<>();\n        mobileList.add(\"13800138000\");\n        mobileList.add(\"13800138001\");\n        mobileList.add(\"13800138002\");\n        mobileList.add(\"13800138003\");\n        mobileList.add(\"13800138004\");\n        mobileList.add(\"13800138005\");\n        mobileList.add(\"13800138006\");\n        mobileList.add(\"13800138007\");\n        mobileList.add(\"13800138008\");\n        mobileList.add(\"13800138009\");\n        mobileList.add(\"13800138010\");\n        mobileList.add(\"13800138011\");\n        mobileList.add(\"13800138012\");\n        mobileList.add(\"13800138013\");\n        mobileList.add(\"13800138014\");\n        mobileList.add(\"13800138015\");\n        mobileList.add(\"13800138016\");\n        mobileList.add(\"13800138017\");\n        mobileList.add(\"13800138018\");\n        mobileList.add(\"13800138019\");\n        mobileList.add(\"13800138020\");\n        mobileList.add(\"13800138021\");\n        mobileList.add(\"13800138022\");\n        mobileList.add(\"13800138023\");\n        mobileList.add(\"13800138024\");\n        mobileList.add(\"13800138025\");\n        mobileList.add(\"13800138026\");\n        mobileList.add(\"13800138027\");\n        mobileList.add(\"13800138028\");\n        mobileList.add(\"13800138029\");\n        mobileList.add(\"13800138030\");\n        mobileList.add(\"13800138031\");\n        mobileList.add(\"13800138032\");\n        mobileList.add(\"13800138033\");\n        mobileList.add(\"13800138034\");\n        mobileList.add(\"13800138035\");\n        mobileList.add(\"13800138036\");\n        mobileList.add(\"13800138037\");\n        mobileList.add(\"13800138038\");\n        mobileList.add(\"13800138039\");\n        mobileList.add(\"13800138040\");\n        mobileList.add(\"13800138041\");\n        mobileList.add(\"13800138042\");\n        mobileList.add(\"13800138043\");\n        mobileList.add(\"13800138044\");\n        mobileList.add(\"13800138045\");\n        mobileList.add(\"13800138046\");\n        mobileList.add(\"13800138047\");\n        mobileList.add(\"13800138048\");\n        mobileList.add(\"13800138049\");\n        mobileList.add(\"13800138050\");\n        mobileList.add(\"13800138051\");\n        mobileList.add(\"13800138052\");\n        mobileList.add(\"13800138053\");\n        mobileList.add(\"13800138054\");\n        mobileList.add(\"13800138055\");\n        mobileList.add(\"13800138056\");\n        mobileList.add(\"13800138057\");\n        mobileList.add(\"13800138058\");\n        mobileList.add(\"1380013805", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "187195345_62", "part": [1, 1], "seq": [1, 1], "prompt": "class OpenLRProtoDecoder implements PhysicalDecoder {\n\n    @Override\n    public RawLocationReference decodeData(LocationReference data) throws PhysicalFormatException {\n        LocationType locationType = data.getLocationType();\n        LocationReferenceDecoder locationReferenceDecoder = locationTypeDecoderRegistry.getDecoder(locationType);\n\n        if (locationReferenceDecoder == null) {\n            throw new OpenLRProtoException(OpenLRProtoStatusCode.UNSUPPORTED_LOCATION_TYPE);\n        }\n\n        Object locationReferenceData = data.getLocationReferenceData();\n\n        if (!(locationReferenceData instanceof LocationReferenceData)) {\n            throw new OpenLRProtoException(OpenLRProtoStatusCode.INVALID_DATA_TYPE);\n        }\n\n        return locationReferenceDecoder.decode(data.getID(), (LocationReferenceData) locationReferenceData);\n    }\n\n    @Override public Class<?> getDataClass();\n    @Override public String getDataFormatIdentifier();\n\n     OpenLRProtoDecoder decoder;\n\n}\n\nclass OpenLRProtoDecoderTest {\n\n     OpenLRProtoDecoder decoder;\n\n    @Test\n    public void testInvalidLocationReference() {\n", "reference": "        Coordinates firstCoordinates = Coordinates.newBuilder()\n                .setLongitude(1)\n                .setLatitude(2)\n                .build();\n\n        LineAttributes firstLineAttributes = LineAttributes.newBuilder()\n                .setBearing(90)\n                .setFrc(FRC.FRC_0)\n                .setFow(FOW.FOW_MOTORWAY)\n                .build();\n\n        PathAttributes firstPathAttributes = PathAttributes.newBuilder()\n                .setDistanceToNext(100)\n                .setLowestFrcAlongPath(FRC.FRC_1)\n                .build();\n\n        LocationReferencePoint first = LocationReferencePoint.newBuilder()\n                .setCoordinates(firstCoordinates)\n                .setLineAttributes(firstLineAttributes)\n                .setPathAttributes(firstPathAttributes)\n                .build();\n\n        LineLocationReference lineLocationReference = LineLocationReference.newBuilder()\n                .addLocationReferencePoints(first)\n                .setPositiveOffset(1)\n                .setNegativeOffset(2)\n                .build();\n\n        LocationReferenceData locationReferenceData = LocationReferenceData.newBuilder()\n                .setLineLocationReference(lineLocationReference)\n                .build();\n\n        LocationReference locationReference = new LocationReferenceProtoImpl(\"1\", LocationType.LINE_LOCATION, locationReferenceData);\n\n        try {\n            decoder.decodeData(locationReference);\n            fail();\n        } catch (PhysicalFormatException e) {\n            assertEquals(e.getErrorCode(), OpenLRProtoStatusCode.INVALID_LOCATION_REFERENCE);\n        }\n    }\n\n}", "prediction": "        LocationReferenceData data = new LocationReferenceData();\n        data.setLocationType(LocationType.GEO_COORDINATES);\n        LocationReference reference = new LocationReference();\n        reference.setLocationReferenceData(data);\n        reference.setLocationType(LocationType.GEO_COORDINATES);\n        try {\n            decoder.decodeData(reference);\n            fail(\"Expected PhysicalFormatException\");\n        } catch (PhysicalFormatException e) {\n            assertEquals(OpenLRProtoStatusCode.UNSUPPORTED_LOCATION_TYPE, e.getStatusCode());\n        }\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "190938308_0", "part": [1, 1], "seq": [1, 1], "prompt": "class ShowMessageLogic {\n\n    public boolean shouldShowMessage() {\n        return counterPreferences.getCounter() >= 42;\n    }\n\n    public  ShowMessageLogic(final CounterPreferences counterPreferences);\n\n    private final SPMockBuilder spMockBuilder;\n    private CounterPreferences counterPreferences;\n    private ShowMessageLogic showMessageLogic;\n\n}\n\nclass ShowMessageLogicTest {\n\n    private final SPMockBuilder spMockBuilder;\n    private CounterPreferences counterPreferences;\n    private ShowMessageLogic showMessageLogic;\n\n    @Test\n    public void on42CounterItShouldShowMessage() {\n", "reference": "        counterPreferences.setCounter(42);\n\n        Assert.assertTrue(showMessageLogic.shouldShowMessage());\n    }\n\n}", "prediction": "        counterPreferences.setCounter(42);\n        assertTrue(showMessageLogic.shouldShowMessage());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "192201753_7", "part": [1, 1], "seq": [1, 1], "prompt": "class RuleMatcher {\n\n    public boolean canCrawl(String agent, String path, String rules) {\n        // Fixes #29\n        if (path == null || path.isEmpty()) path = \"/\";\n\n        // if path is /robots.txt then allow always\n        if (\"/robots.txt\".equals(path)) return true;\n\n        Content content = gson.fromJson(rules, type);\n        List<Group> groups = content.getGroups();\n\n        // if no groups found, then allow all\n        if (groups.isEmpty()) return true;\n\n        List<String> userAgents = groups.stream()\n                .flatMap(group -> group.getUserAgents().stream().map(String::toLowerCase))\n                .collect(Collectors.toList());\n\n        if (userAgents.isEmpty()) return true;\n        if (userAgents.parallelStream().noneMatch(ALL::equals) && ALL.equals(agent)) return true;\n\n        agent = agent.toLowerCase();\n        if (noneMatch(agent, userAgents) && noneMatch(ALL, userAgents) && !ALL.equals(agent)) return true;\n\n        // Flag used to check if the given user agent match any saved agent.\n        // Note that if no user agent match, it will use * as base user agent\n        boolean foundUserAgent = false;\n\n        for (Group group : groups) {\n            // Directive priority is decided using length, that is, longest first\n            Collections.sort(group.getRules());\n\n            for (String ua : group.getUserAgents()) {\n                // Check if user agent match. User agent case is ignored as\n                // google documentation says\n                if (agent.contains(ua.toLowerCase())) {\n                    foundUserAgent = true;\n                    // If rules check, then allow\n                    if (checkGroupRules(group, path)) return true;\n                }\n            }\n\n            // Check with default user agent (*)\n            if (!foundUserAgent) {\n                for (String ua : group.getUserAgents()) {\n                    // Continue loop until * found\n                    if (!ALL.equals(ua)) continue;\n                    if (checkGroupRules(group, path)) return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private boolean noneMatch(String agent, List<String> userAgents);\n    private boolean checkGroupRules(Group group, String path);\n    private boolean matchesRule(String path, String directive, Rule rule);\n    private boolean checkRulePath(String path, String directive, Rule rule);\n\n    private RuleMatcher ruleMatcher;\n\n}\n\nclass RuleMatcherTest {\n\n    private RuleMatcher ruleMatcher;\n\n    @Test\n    public void testNoGroupsFound() throws IOException {\n", "reference": "        InputStream stream = this.getClass().getClassLoader().getResourceAsStream(\"empty-group.json\");\n        String content = TestUtils.readFile(stream);\n\n        assertTrue(ruleMatcher.canCrawl(\"*\", \"/\", content));\n        assertTrue(ruleMatcher.canCrawl(\"abc\", \"/\", content));\n        assertTrue(ruleMatcher.canCrawl(\"abc\", \"/test\", content));\n    }\n\n}", "prediction": "        String rules = \"{}\";\n        assertFalse(ruleMatcher.canCrawl(\"Googlebot\", \"/\", rules));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "193537999_18", "part": [1, 1], "seq": [1, 1], "prompt": "class NetcdfDataReader extends DataReader {\n\n    @Override\n    public List<VortexData> getDtos() {\n        try (NetcdfDataset ncd = NetcdfDatasets.openDataset(path);  Formatter errlog = new Formatter()) {\n            FeatureDataset dataset = FeatureDatasetFactoryManager.wrap(FeatureType.GRID, ncd, null, errlog);\n            if (dataset != null) {\n                FeatureType ftype = dataset.getFeatureType();\n                if (ftype == FeatureType.GRID) {\n                    assert (dataset instanceof GridDataset);\n                    GridDataset gridDataset = (GridDataset) dataset;\n                    return getData(gridDataset, variableName);\n                }\n            } else {\n                List<Variable> variables = ncd.getVariables();\n                for (Variable variable : variables) {\n                    if (variable.getShortName().equals(variableName) && variable instanceof VariableDS) {\n                        VariableDS variableDS = (VariableDS) variable;\n                        int count = getDtoCount(variableDS);\n\n                        VariableDsReader reader = VariableDsReader.builder()\n                                .setNetcdfFile(ncd)\n                                .setVariableName(variableName)\n                                .build();\n\n                        List<VortexData> dataList = new ArrayList<>();\n                        for (int i = 0; i < count; i++) {\n                            VortexData data = reader.read(i);\n                            dataList.add(data);\n                        }\n                        return dataList;\n                    }\n                }\n            }\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, e, e::getMessage);\n            return Collections.emptyList();\n        }\n        return Collections.emptyList();\n    }\n\n      NetcdfDataReader(DataReaderBuilder builder);\n\n    @Override public VortexData getDto(int idx);\n    @Override public int getDtoCount();\n    public static Set<String> getVariables(String path);\n    private float[] getFloatArray(Array array);\n    private List<VortexData> getData(GridDataset dataset, String variable);\n    private static String getWkt(Projection projection);\n    private List<ZonedDateTime[]> getTimeBounds(GridCoordSystem gcs);\n    private static ZonedDateTime convert(CalendarDate date);\n    private static Grid getGrid(GridCoordSystem coordinateSystem);\n    private static Grid shiftGrid(Grid grid);\n    private static Grid scaleGrid(Grid grid, Unit<?> cellUnits, Unit<?> csUnits);\n    private int getDtoCount(GridDataset dataset, String variable);\n    private int getDtoCount(VariableDS variableDS);\n    private VortexData getData(GridDataset dataset, String variable, int idx);\n\n}\n\nclass NetcdfDataReaderTest {\n\n    @Test\n    void GpcpPrecipImport(){\n", "reference": "        String inFile = new File(getClass().getResource(\"/gpcp_cdr_v23rB1_y2019_m01.nc\").getFile()).toString();\n        String variableName = \"precip\";\n\n        DataReader reader = DataReader.builder()\n                .path(inFile)\n                .variable(variableName)\n                .build();\n\n        List<VortexGrid> dtos = reader.getDtos().stream().map(grid -> (VortexGrid) grid).collect(Collectors.toList());\n        assertEquals(1, dtos.size());\n        assertEquals(10368, dtos.get(0).data().length);\n    }\n\n}", "prediction": "        DataReaderBuilder builder = DataReaderBuilder.builder()\n                .setPath(\"src/test/resources/gpcp/precip.nc\")\n                .setVariableName(\"precipitation\")\n                .build();\n\n        NetcdfDataReader reader = new NetcdfDataReader(builder);\n        List<VortexData> dataList = reader.getDtos();\n        assertEquals(1, dataList.size());\n\n        VortexData data = dataList.get(0);\n        assertEquals(1, data.getData().size());\n        assertEquals(1, data.getData().get(0).size());\n        assertEquals(1, data.getData().get(0).get(0).size());\n        assertEquals(1, data.getData().get(0).get(0).get(0).size());\n        assertEquals(1, data.getData().get(0).get(0).get(0).get(0).size());\n        assertEquals(1, data.getData().get(0).get(0).get(0).get(0).get(0).size());\n        assertEquals(1, data.getData().get(0).get(0).get(0).get(0).get(0).get(0).size());\n        assertEquals(1, data.getData().get(0).get(0).get(0).get(0).get(0).get(0).get(0).size());\n        assertEquals(1, data.getData().get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).size());\n        assertEquals(1, data.getData().get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).size());\n        assertEquals(1, data.getData().get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).size());\n        assertEquals(1, data.getData().get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).size());\n        assertEquals(1, data.getData().get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).size());\n        assertEquals(1, data.getData().get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).size());\n        assertEquals(1, data.getData().get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).size());\n        assertEquals(1, data.getData().get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).size());\n        assertEquals(1, data.getData().get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).size());\n        assertEquals(1, data.getData().get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).size());\n        assertEquals(1, data.getData().get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).size());\n        assertEquals(1, data.getData().get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).size());\n        assertEquals(1, data.getData().get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).size());\n        assertEquals(1, data.getData().get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "195232251_4", "part": [1, 1], "seq": [1, 1], "prompt": "class IReBlogEsServiceImpl implements IReBlogEsService {\n\n    @Override\n    public Page<ReBlog> query(String condition, PageDTO pageDTO) {\n        SearchQuery searchQuery = new NativeSearchQueryBuilder()\n                .withQuery(QueryBuilders.multiMatchQuery(condition, \"title\", \"author\", \"contentMarkdown\", \"summary\"))\n                .withPageable(PageRequest.of(pageDTO.getPage() - 1, pageDTO.getCount()))\n                .build();\n        return repository.search(searchQuery);\n    }\n\n    public  IReBlogEsServiceImpl(IReBlogEsRepository repository);\n\n    @Override public ReBlog save(ReBlog reBlog);\n    @Override public void delete(ReBlog reBlog);\n    @Override public Iterable<ReBlog> getAll();\n    @Override public long count();\n    @Override public void deleteAll();\n\n    @Autowired\n    private IReBlogEsService service;\n\n}\n\nclass IReBlogEsServiceImplTest {\n\n    @Autowired\n    private IReBlogEsService service;\n\n    @Test\n    void query() {\n", "reference": "        Page<ReBlog> query = service.query(\"git\", new PageDTO(1, 10));\n        query.forEach(System.out::println);\n    }\n\n}", "prediction": "        Page<ReBlog> page = service.query(\"java\", new PageDTO(1, 10));\n        System.out.println(page.getTotalElements());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "201420026_6", "part": [1, 1], "seq": [1, 1], "prompt": "class LideaLogDAO {\n\n    public LideaLogResp scan(LideaLogReq req) {\n\n        Scan scan = createScan(req);\n\n        ResultsExtractor<List<LideaLogBO>> extractor = new LideaLogResultsExtractor();\n        List<LideaLogBO> list = hbaseTemplate.find(Const.LIDEA_LOG_TABLE, scan, extractor);\n\n        LideaLogResp resp = new LideaLogResp();\n        resp.setData(list);\n        resp.setAppName(req.getAppName());\n        resp.setServiceName(req.getServiceName());\n        resp.setMethodName(req.getMethodName());\n\n        return resp;\n    }\n\n    public void put(LideaLogBO bo);\n    private Scan createScan(LideaLogReq bo);\n    public LideaLogResp get(LideaLogReq req);\n\n    @Resource\n    private LideaLogDAO lideaLogDAO;\n\n}\n\nclass LideaLogDAOTest {\n\n    @Resource\n    private LideaLogDAO lideaLogDAO;\n\n    @Test\n    public void testScan() {\n", "reference": "\n        LideaLogReq req = new LideaLogReq();\n\n        req.setAppName(\"cabinet-base-server\");\n        req.setServiceName(\"com.fcbox.edms.terminal.api.CabinetServiceFacade\");\n        req.setMethodName(\"getCabinetInfo\");\n\n        req.setFrom(TimeUtil.stringToLong(\"2019-07-20 00:00:00\"));\n        req.setTo(TimeUtil.stringToLong(\"2019-08-29 23:00:00\"));\n\n        LideaLogResp resp = lideaLogDAO.scan(req);\n        System.out.println(\"==========================================================================================\");\n        System.out.println(JSON.toJSONString(resp));\n    }\n\n}", "prediction": "        LideaLogReq req = new LideaLogReq();\n        req.setAppName(\"app\");\n        req.setServiceName(\"service\");\n        req.setMethodName(\"method\");\n        LideaLogResp resp = lideaLogDAO.scan(req);\n        System.out.println(resp);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "201843970_1", "part": [1, 1], "seq": [1, 1], "prompt": "class LoginPresenter extends BasePresenter<LoginContract.Model, LoginContract.View> {\n\n    public void login() {\n        if(mRootView.getMobileStr().length() != 11){\n            mRootView.showMessage(\"\u624b\u673a\u53f7\u7801\u4e0d\u6b63\u786e\");\n            return;\n        }\n        if(mRootView.getPassWordStr().length() < 1){\n            mRootView.showMessage(\"\u5bc6\u7801\u592a\u77ed\");\n            return;\n        }\n        //\u8c03\u7528\u767b\u5f55\u63a5\u53e3\uff0c\u6b63\u786e\u7684\u5bc6\u7801\uff1aabc  \u624b\u673a\u53f7\u53ea\u8981\u7b49\u4e8e11\u4f4d\u5224\u65ad\u8d26\u53f7\u4e3a\u6b63\u786e\n        mModel.login(mRootView.getMobileStr(),mRootView.getPassWordStr())\n                .compose(RxUtils.applySchedulers(mRootView))\n                .subscribe(new MyErrorHandleSubscriber<User>(mErrorHandler) {\n                    //\u8fd9\u4e2a\u7c7b\u662f\u6211\u81ea\u5b9a\u4e49\u7684\u4e00\u4e2a\u7c7b\uff0c\u7edf\u4e00\u62e6\u622a\u6240\u6709error \u5e76\u56de\u8c03\u7ed9\uff1a ResponseErrorListenerImpl\n                    @Override\n                    public void onNext(User user) {\n                            mRootView.loginSuccess();\n                    }\n                });\n\n    }\n\n    @Inject public  LoginPresenter(LoginContract.Model model, LoginContract.View rootView);\n\n    @Override public void onDestroy();\n\n    @Rule\n    public MockitoRule mockitoRule;\n    private LoginPresenter mPresenter;\n    private LoginModel model;\n    private LoginContract.View view;\n\n}\n\nclass LoginPresenterTest {\n\n    @Rule\n    public MockitoRule mockitoRule;\n    private LoginPresenter mPresenter;\n    private LoginModel model;\n    private LoginContract.View view;\n\n    @Test\n    public  void loginSuccess(){\n", "reference": "        //\u6a21\u62df\u6570\u636e\n        Mockito.when(view.getMobileStr()).thenReturn(\"13547250999\");\n        Mockito.when(view.getPassWordStr()).thenReturn(\"abc\");\n\n        //\u5b9e\u73b0loginModel login \u65b9\u6cd5\n        //\u7531\u4e8e\u4e0d\u77e5\u9053\u4e0a\u54ea\u91cc\u53bb\u627e\u4e00\u4e2a\u7a33\u5b9a\u4e14\u957f\u671f\u53ef\u7528\u7684\u767b\u5f55\u63a5\u53e3\uff0c\n        // \u6240\u4ee5\u7528\u7684\u63a5\u53e3\u662fgithub \u4e0a\u7684\u67e5\u8be2\u63a5\u53e3\uff1ahttps://api.github.com/users/drchengit\n        // \u8fd9\u91cc\u7684\u5904\u7406\u662f\u6b63\u786e\u7684\u5bc6\u7801\uff0c\u8bf7\u6c42\u5b58\u5728\u7684\u7528\u6237\u540d\uff1adrchengit  \u9519\u8bef\u7684\u5bc6\u7801\u8bf7\u6c42\u4e0d\u5b58\u5728\u7684\u7528\u6237\u540d\uff1a drchengi\n        Observable<User> observable = ArmsUtils.obtainAppComponentFromContext(\n                RuntimeEnvironment.application).repositoryManager()\n                .obtainRetrofitService(CommonService.class)\n                .getUser(\"drchengit\");\n\n        //\u6a21\u62df\u65e0\u8bba\u600e\u4e48\u8c03\u7528\uff0clogin\u90fd\u662f\u8fd4\u56de\u4e0a\u9762\u7684Observable\u5bf9\u8c61\n        Mockito.when(model.login(Mockito.anyString(),Mockito.anyString()))\n                .thenReturn(observable);\n        //\u767b\u5f55\n        mPresenter.login();\n        Mockito.verify(view).loginSuccess();\n    }\n\n}", "prediction": "        mPresenter.login();\n        verify(view).loginSuccess();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "204657216_31", "part": [1, 1], "seq": [1, 1], "prompt": "class PartitionComparator implements Callable<PartitionStats> {\n\n    public PartitionStats call() {\n        PartitionStats partitionStats = new PartitionStats();\n\n        if (source == null || target == null) {\n            logger.error(\"Skipping partition because one result was null (timeout despite retries)\");\n            partitionStats.skipped = true;\n            return partitionStats;\n        }\n\n        while (hasNextRow(Type.SOURCE) && hasNextRow(Type.TARGET)) {\n\n            Row sourceRow = getNextRow(Type.SOURCE);\n            Row targetRow = getNextRow(Type.TARGET);\n\n            // if primary keys don't match don't proceed any further, just mark the\n            // partition as mismatched and be done\n            if (!clusteringsEqual(sourceRow, targetRow)) {\n                partitionStats.allClusteringsMatch = false;\n                return partitionStats;\n            }\n\n            partitionStats.matchedRows++;\n\n            // if the rows match, but there are mismatching values in the regular columns\n            // we can continue processing the partition, so just flag it as mismatched and continue\n            checkRegularColumnEquality(partitionStats, sourceRow, targetRow);\n        }\n\n        // if one of the iterators isn't exhausted, then there's a mismatch at the partition level\n        if (hasNextRow(Type.SOURCE) || hasNextRow(Type.TARGET))\n            partitionStats.allClusteringsMatch = false;\n\n        return partitionStats;\n    }\n\n    public  PartitionComparator(TableSpec tableSpec,\n                               Iterator<Row> source,\n                               Iterator<Row> target,\n                               RetryStrategyProvider retryStrategyProvider);\n\n    private boolean hasNextRow(Type type);\n    private Row getNextRow(Type type);\n    private boolean clusteringsEqual(Row source, Row target);\n    private void checkRegularColumnEquality(PartitionStats stats, Row source, Row target);\n\n}\n\nclass PartitionComparatorTest {\n\n    @Test\n    public void sourceContainsExtraRowsAtEnd() {\n", "reference": "        TableSpec t = spec(\"table1\", names(\"c1\", \"c2\"), names(\"v1\", \"v2\"));\n        PartitionComparator comparator = comparator(t,\n                                                    rows(row(t, 0, 1, 2, 3),\n                                                         row(t, 10, 11, 12, 13)),\n                                                    rows(row(t, 0, 1, 2, 3)));\n        PartitionStats stats = comparator.call();\n        // The fact that the first row & all its v1 & v2 values match should be reflected in the stats\n        assertStats(stats, false, false, 1, 2, 0);\n    }\n\n}", "prediction": "        List<Row> sourceRows = Arrays.asList(\n                new Row(new Object[] { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "206073932_9", "part": [1, 1], "seq": [1, 1], "prompt": "class DeptService extends BaseService<Dept,Long,DeptRepository> {\n\n    public void deleteDept(Long deptId) {\n        Dept dept = get(deptId);\n\n        List<Dept> subDepts = deptRepository.findByPidsLike(\"%[\" + dept.getId() + \"]%\");\n        deptRepository.deleteAll(subDepts);\n        deptRepository.delete(dept);\n    }\n\n    public List<ZTreeNode> tree();\n    private ZTreeNode transfer(Object[] obj);\n    public List<Dept> query(String condition);\n    public List<DeptNode> queryAllNode();\n    public void deptSetPids(Dept dept);\n    private List<DeptNode> generateTree(List<Dept> list);\n\n    @Autowired\n    private DeptService deptService;\n\n}\n\nclass DeptServiceTest extends BaseService<Dept,Long,DeptRepository> {\n\n    @Autowired\n    private DeptService deptService;\n\n    @Test\n    public void deleteDept() throws Exception {\n", "reference": "\n    }\n\n    public List<ZTreeNode> tree();\n    private ZTreeNode transfer(Object[] obj);\n    public List<Dept> query(String condition);\n    public List<DeptNode> queryAllNode();\n    public void deptSetPids(Dept dept);\n    private List<DeptNode> generateTree(List<Dept> list);\n\n    @Autowired\n    private DeptService deptService;\n\n}\n\nclass DeptServiceTest extends BaseService<Dept,Long,DeptRepository> {\n\n    @Autowired\n    private DeptService deptService;\n\n    @Test\n    public void deleteDept() throws Exception {\n\n    }\n\n}", "prediction": "        deptService.deleteDept(1L);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "209830490_7", "part": [1, 1], "seq": [1, 1], "prompt": "class CompiledResourceCreatorConfiguration {\n\n    public Collection<VirtualTerraformResource> apply(TerraformResource resource) {\n        Object values;\n        try {\n            values = valuesPath.read(resource.getValues());\n        } catch (PathNotFoundException e) {\n            return Collections.emptyList();\n        }\n\n        if (values instanceof List) {\n            return createResource(resource, (List<?>)values);\n        }\n        List<Object> valueList = new ArrayList<>();\n        valueList.add(values);\n        return createResource(resource, valueList);\n    }\n\n    public  CompiledResourceCreatorConfiguration(ResourceCreatorConfiguration resourceCreatorConfiguration);\n\n    public boolean matches(TerraformResource resource);\n    private Collection<VirtualTerraformResource> createResource(TerraformResource originalResource, List<?> values);\n    private Map<String, Object> convertMap(Map<?, ?> rawMap);\n\n    private static final Gson GSON;\n\n}\n\nclass CompiledResourceCreatorConfigurationTest {\n\n    private static final Gson GSON;\n\n    @Test\n    void applyShouldReturnOneResourceIfValueSelectorMatchesOneElmentThatContainsThePropertySelectedByTheNameSelector() {\n", "reference": "        // Arrange\n        ResourceCreatorConfiguration configuration = createSelectorTestConfiguration(\"$.name\", \"$.tmp\");\n        CompiledResourceCreatorConfiguration compiledResourceCreatorConfiguration = new CompiledResourceCreatorConfiguration(configuration);\n        TerraformResource terraformResource = mockSelectorTestResource(\"{ \\\"foo\\\": \\\"bar\\\", \\\"tmp\\\": { \\\"a\\\": 1, \\\"b\\\": 2, \\\"name\\\": \\\"i am a name\\\" } }\");\n\n        // Act\n        Collection<VirtualTerraformResource> results = compiledResourceCreatorConfiguration.apply(terraformResource);\n\n        // Verrify\n        assertThat(results).hasSize(1);\n        Optional<VirtualTerraformResource> resourceOptional = results.stream().findFirst();\n        assertThat(resourceOptional).isPresent();\n        VirtualTerraformResource resource = resourceOptional.get();\n        assertThat(resource.getOriginalResource()).isSameAs(terraformResource);\n        assertThat(resource.getName()).isEqualTo(\"i am a name\");\n        Map<String, Object> values = resource.getValues();\n        assertThat(values.get(\"a\")).isEqualTo(1d);\n        assertThat(values.get(\"b\")).isEqualTo(2d);\n        assertThat(values.get(\"name\")).isEqualTo(resource.getName());\n    }\n\n}", "prediction": "        // given\n        TerraformResource resource = new TerraformResource(\"aws_instance\", \"test\",\n                singletonMap(\"tags\", singletonMap(\"Name\", \"test\")));\n        ResourceCreatorConfiguration resourceCreatorConfiguration = new ResourceCreatorConfiguration(\n                \"aws_instance\",\n                \"tags\",\n                \"Name\",\n                \"aws_instance\",\n                \"test\",\n                \"tags\",\n                \"Name\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n                \"test\",\n               ", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "212184596_1", "part": [1, 1], "seq": [1, 1], "prompt": "class Money {\n\n  public boolean isGreaterThanOrEqual(Money other) {\n    return amount.compareTo(other.amount) >= 0;\n  }\n\n  public  Money();\n  public  Money(int i);\n  public  Money(BigDecimal amount);\n\n  public Money add(Money other);\n  public Money subtract(Money other);\n  @Override public String toString();\n  @Override public boolean equals(Object obj);\n  @Override public int hashCode();\n  public BigDecimal getAmount();\n  public void setAmount(BigDecimal amount);\n\n  private Money m1;\n  private Money m2;\n\n}\n\nclass MoneyTest {\n\n  private Money m1;\n  private Money m2;\n\n  @Test\n  public void shouldCompare() {\n", "reference": "    assertTrue(m2.isGreaterThanOrEqual(m2));\n    assertTrue(m2.isGreaterThanOrEqual(m1));\n  }\n\n}", "prediction": "    assertTrue(m1.isGreaterThanOrEqual(m2));\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "214744362_0", "part": [1, 1], "seq": [1, 1], "prompt": "class BookService implements Service {\n\n    public BookRepresentaion getBookById(String id) {\n        Book book = bookRepository.byId(id);\n        return book.toRepresentation();\n    }\n\n    public  BookService(BookFactory bookFactory, BookRepository bookRepository);\n\n    @Transactional public String createBook(CreateBookCommand command);\n    public List<BookRepresentaion> getBooksLists();\n    public BookRepresentaion updateBook(String id, @Valid UpdateBookCommand command);\n\n    @InjectMocks\n    private BookService applicationService;\n    @Mock BookRepository bookRepository;\n\n}\n\nclass BookServiceTest {\n\n    @InjectMocks\n    private BookService applicationService;\n    @Mock BookRepository bookRepository;\n\n    @Test\n    void should_return_book_representation_when_get_by_id() {\n", "reference": "        Book value = Book.create(\"123\", \"isbn\", \"name\");\n        when(bookRepository.byId(anyString())).thenReturn(value);\n\n        BookRepresentaion represention = applicationService.getBookById(\"123\");\n\n        assertEquals(represention.getName(), \"name\");\n    }\n\n}", "prediction": "        Book book = new Book();\n        book.setId(\"1\");\n        book.setTitle(\"title\");\n        book.setAuthor(\"author\");\n        book.setDescription(\"description\");\n        book.setPrice(100);\n        book.setPublisher(\"publisher\");\n        book.setPublishDate(LocalDate.now());\n        book.setIsbn(\"isbn\");\n        book.setPageCount(100);\n        book.setLanguage(\"language\");\n        book.setCoverUrl(\"coverUrl\");\n        book.setCoverType(\"coverType\");\n        book.setCoverWidth(100);\n        book.setCoverHeight(100);\n        book.setCoverColor(\"coverColor\");\n        book.setCoverDescription(\"coverDescription\");\n        book.setCoverImage(new byte[100]);\n        book.setCoverImageType(\"coverImageType\");\n        book.setCoverImageWidth(100);\n        book.setCoverImageHeight(100);\n        book.setCoverImageColor(\"coverImageColor\");\n        book.setCoverImageDescription(\"coverImageDescription\");\n        book.setCoverImage(new byte[100]);\n        book.setCoverImageType(\"coverImageType\");\n        book.setCoverImageWidth(100);\n        book.setCoverImageHeight(100);\n        book.setCoverImageColor(\"coverImageColor\");\n        book.setCoverImageDescription(\"coverImageDescription\");\n        book.setCoverImage(new byte[100]);\n        book.setCoverImageType(\"coverImageType\");\n        book.setCoverImageWidth(100);\n        book.setCoverImageHeight(100);\n        book.setCoverImageColor(\"coverImageColor\");\n        book.setCoverImageDescription(\"coverImageDescription\");\n        book.setCoverImage(new byte[100]);\n        book.setCoverImageType(\"coverImageType\");\n        book.setCoverImageWidth(100);\n        book.setCoverImageHeight(100);\n        book.setCoverImageColor(\"coverImageColor\");\n        book.setCoverImageDescription(\"coverImageDescription\");\n        book.setCoverImage(new byte[100]);\n        book.setCoverImageType(\"coverImageType\");\n        book.setCoverImageWidth(100);\n        book.setCoverImageHeight(100);\n        book.setCoverImageColor(\"coverImageColor\");\n        book.setCoverImageDescription(\"coverImageDescription\");\n        book.setCoverImage(new byte[100]);\n        book.setCoverImageType(\"coverImageType\");\n        book.setCoverImageWidth(100);\n        book.setCoverImageHeight(100);\n        book.setCoverImageColor(\"coverImageColor\");\n        book.setCoverImageDescription(\"coverImageDescription\");\n        book.setCoverImage(new byte[100]);\n        book.setCoverImageType(\"coverImageType\");\n        book.setCoverImageWidth(100);\n        book.setCoverImageHeight(100);\n        book.setCoverImageColor(\"coverImageColor\");\n        book.setCoverImageDescription(\"coverImageDescription\");\n        book.setCoverImage(new byte[100]);\n        book.setCoverImageType(\"coverImageType\");\n        book.setCoverImageWidth(100);\n        book.setCoverImageHeight(100);\n        book.setCoverImageColor(\"coverImageColor\");\n        book.setCoverImageDescription(\"coverImageDescription\");\n        book.setCoverImage(new byte[100]);\n        book.setCoverImageType(\"coverImageType\");\n        book.setCoverImageWidth(100);\n        book.setCoverImageHeight(100);\n        book.setCoverImageColor(\"coverImageColor\");\n        book.setCoverImageDescription(\"coverImageDescription\");\n        book.setCoverImage(new byte[100]);\n        book.setCoverImageType(\"coverImageType\");\n        book.setCoverImageWidth(100);\n        book.setCoverImageHeight(100);\n        book.setCoverImageColor(\"coverImageColor\");\n        book.setCoverImageDescription(\"coverImageDescription\");\n        book.set", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "214933909_202", "part": [1, 1], "seq": [1, 1], "prompt": "class ProjectController {\n\n    @RequestMapping(value = \"/group\")\n    public ServiceResult<List<Project>> getGroupProjects(@RequestParam(\"groupId\") Long groupId) throws Exception {\n        return ServiceResult.success(projectDao.getProjectByGroupId(groupId));\n    }\n\n    @RequestMapping(value = \"/projects\") public ServiceResult<List<Project>> getProjects(@RequestParam(value = \"name\", defaultValue = \"\") String name);\n    @RequestMapping(value = \"/projectsNoGroup\") public ServiceResult<List<Project>> getProjectsNoGroup(@RequestParam(value = \"appGroupId\", defaultValue = \"0\") Long appGroupId);\n    @RequestMapping(value = \"/projectsByAppGroupId\") public ServiceResult<List<Project>> getProjectsByAppGroupId(@RequestParam(value = \"appGroupId\") Long appGroupId);\n    @RequestMapping(value = \"/list\", method = RequestMethod.POST) public ServiceResult<ListResult<ProjectView>> getGroupUsers(@RequestBody Paging<ProjectModel> paging, @CurrentUser LoginUser user);\n    @RequestMapping(value = \"/add\", method = RequestMethod.POST) public ServiceResult<String> add(@Validated(AddProject.class) @RequestBody Project project, @CurrentUser LoginUser user, Errors errors);\n    @RequestMapping(value = \"/update\", method = RequestMethod.PUT) public ServiceResult<String> update(@Validated(UpdateProject.class) @RequestBody Project project, @CurrentUser LoginUser user, Errors errors);\n    @RequestMapping(value = \"/delete\", method = RequestMethod.DELETE) public ServiceResult<String> delete(@Validated(DeleteProject.class) @RequestBody Project project, @CurrentUser LoginUser user, Errors errors);\n    @RequestMapping(value = \"/sync\") public ServiceResult<String> sync(@RequestParam(\"id\") Long id, @CurrentUser LoginUser user);\n    @RequestMapping(value = \"/check\") public ConfigCkeckResult check(@CurrentUser LoginUser user, @RequestParam(\"id\") Long id);\n    @RequestMapping(value = \"/syncdb\") public ServiceResult<String> syncdb(@Validated(AddProject.class) @RequestBody Project project, @CurrentUser LoginUser user, Errors errors);\n    private ServiceResult<String> addProject(@Validated(AddProject.class) @RequestBody Project project, @CurrentUser LoginUser user, Errors errors);\n    @RequestMapping(value = \"/generate\", method = RequestMethod.POST) public ServiceResult generateProject(@CurrentUser LoginUser user, @RequestBody GenerateCodeModel generateCodeRequest);\n    @RequestMapping(\"/download\") public String download(@RequestParam(value = \"projectId\") Long projectId, @CurrentUser LoginUser user, HttpServletResponse response);\n    @RequestMapping(\"/buttons\") public ServiceResult getProjectButton(@CurrentUser LoginUser user);\n\n    @Autowired\n    private WebApplicationContext webApplicationContext;\n    @MockBean\n    private UserLoginInterceptor userLoginInterceptor;\n    @MockBean\n    private CommStatusInterceptor commStatusInterceptor;\n    @MockBean\n    private PermissionService permissionService;\n    @MockBean\n    private Message message;\n    @MockBean\n    private ProjectDao projectDao;\n    @MockBean\n    private DatabaseSetDao databaseSetDao;\n    @MockBean\n    private ProjectService projectService;\n    @MockBean\n    private GroupService groupService;\n    @MockBean\n    private GroupDao groupDao;\n    private MockMvc mockMvc;\n    private String requestJson;\n\n}\n\nclass ProjectControllerTest {\n\n    @Autowired\n    private WebApplicationContext webApplicationContext;\n    @MockBean\n    private UserLoginInterceptor userLoginInterceptor;\n    @MockBean\n    private CommStatusInterceptor commStatusInterceptor;\n    @MockBean\n    private PermissionService permissionService;\n    @MockBean\n    private Message message;\n    @MockBean\n    private ProjectDao projectDao;\n    @MockBean\n    private DatabaseSetDao databaseSetDao;\n    @MockBean\n    private ProjectService projectService;\n    @MockBean\n    private GroupService groupService;\n    @MockBean\n    private GroupDao groupDao;\n    private MockMvc mockMvc;\n    private String requestJson;\n\n    @Test\n    public void getGroupProjects() throws Exception {\n", "reference": "        mockMvc.perform(MockMvcRequestBuilders.post(\"/project/group\")\n                .contentType(MediaType.APPLICATION_JSON_UTF8)\n                .param(\"groupId\",\"1\")\n                .accept(MediaType.APPLICATION_JSON_UTF8))\n                .andExpect(MockMvcResultMatchers.status().isOk())\n                .andDo(MockMvcResultHandlers.print());\n    }\n\n}", "prediction": "        mockMvc.perform(MockMvcRequestBuilders.get(\"/project/group?groupId=1\")\n                .contentType(MediaType.APPLICATION_JSON_UTF8))\n                .andExpect(MockMvcResultMatchers.status().isOk())\n                .andExpect(MockMvcResultMatchers.content().contentType(MediaType.APPLICATION_JSON_UTF8))\n                .andExpect(MockMvcResultMatchers.jsonPath(\"$.code\").value(ResultCode.SUCCESS.getCode()))\n                .andExpect(MockMvcResultMatchers.jsonPath(\"$.data\").isArray())\n                .andExpect(MockMvcResultMatchers.jsonPath(\"$.data.length()\").value(1));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "224353263_4", "part": [1, 1], "seq": [1, 1], "prompt": "class AuthenticationServiceJwtImpl implements AuthenticationService {\n\n    @Override\n    @Nullable\n    public RSocketAppPrincipal auth(String type, String credentials) {\n        int tokenHashCode = credentials.hashCode();\n        RSocketAppPrincipal principal = jwtVerifyCache.getIfPresent(tokenHashCode);\n        for (JWTVerifier verifier : verifiers) {\n            try {\n                principal = new JwtPrincipal(verifier.verify(credentials), credentials);\n                jwtVerifyCache.put(tokenHashCode, principal);\n                break;\n            } catch (JWTVerificationException ignore) {\n\n            }\n        }\n        return principal;\n    }\n\n    public  AuthenticationServiceJwtImpl();\n\n    public String generateCredentials(String id, String[] organizations, String[] serviceAccounts, String[] roles, String[] authorities, String sub, String[] audience);\n    public RSAPrivateKey readPrivateKey();\n    public RSAPublicKey readPublicKey();\n    public byte[] toBytes(InputStream inputStream);\n    private void generateRSAKeyPairs(File rsocketKeysDir);\n\n    public AuthenticationServiceJwtImpl authenticationService;\n\n}\n\nclass AuthenticationServiceJwtImplTest {\n\n    public AuthenticationServiceJwtImpl authenticationService;\n\n    @Test\n    public void testAuth() throws Exception {\n", "reference": "        String subject = \"testing-only\";\n        String credentials = authenticationService.generateCredentials(UUID.randomUUID().toString(), new String[]{\"alibaba\"}, new String[]{\"default\"}, new String[]{\"internal\"}, null, subject, new String[]{\"leijuan\"});\n        System.out.println(credentials);\n        Principal principal = authenticationService.auth(\"JWT\", credentials);\n        Assertions.assertNotNull(principal);\n        Assertions.assertEquals(subject, principal.getName());\n    }\n\n}", "prediction": "        authenticationService.auth(\"jwt\", \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\");\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "224557146_3", "part": [1, 1], "seq": [1, 1], "prompt": "class AuctionResult {\n\n\tpublic BiddingResponse getWinner(){\n\t\treturn winner;\n\t}\n\n\tpublic String getTransactionId();\n\tpublic void setTransactionId(String transactionId);\n\tpublic String getUnitId();\n\tpublic void setUnitId(String unitId);\n\tpublic void setWinner(BiddingResponse winner);\n\tpublic List<BiddingResponse> getOtherBidders();\n\tpublic void setOtherBidders(List<BiddingResponse> otherBidders);\n\n    private BiddingResponse br1;\n    private BiddingResponse br2;\n    private AuctionResult auctionResult;\n\n}\n\nclass AuctionResultTest {\n\n    private BiddingResponse br1;\n    private BiddingResponse br2;\n    private AuctionResult auctionResult;\n\n    @Test\n    public void testGetWinner() {\n", "reference": "        assertEquals(br2, auctionResult.getWinner());\n    }\n\n}", "prediction": "        assertEquals(br1, auctionResult.getWinner());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "225164634_22", "part": [1, 1], "seq": [1, 1], "prompt": "class BackCategoryDAO extends MyBatisDAO<BackCategory> {\n\n    public List<BackCategory> findByPid(Long pid) {\n        return getSqlSession().selectList(sqlId(\"findByPid\"), pid);\n    }\n\n    private BackCategory bc;\n    @Autowired\n    private BackCategoryDAO backCategoryDao;\n\n}\n\nclass BackCategoryDAOTest extends MyBatisDAO<BackCategory> {\n\n    private BackCategory bc;\n    @Autowired\n    private BackCategoryDAO backCategoryDao;\n\n    @Test\n    public void testFindByPid() {\n", "reference": "        BackCategory bc2 = create(\"\u4e00\u7ea7\u7c7b\u76ee1\", 1, 0L);\n        backCategoryDao.create(bc2);\n\n        List<BackCategory> children = backCategoryDao.findByPid(0L);\n        assertThat(children).isNotEmpty().hasSize(2);\n    }\n\n}", "prediction": "       List<BackCategory> list = backCategoryDao.findByPid(1L);\n        System.out.println(list);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "227543326_43", "part": [1, 1], "seq": [1, 1], "prompt": "class DistinctQueryResult implements QueryResult {\n\n    @Override\n    public String getColumnLabel(final int columnIndex) throws SQLException {\n        String columnLabel = queryResultMetaData.getColumnLabel(columnIndex);\n        if (null != columnLabel) {\n            return columnLabel;\n        }\n        throw new SQLException(\"Column index out of range\", \"9999\");\n    }\n\n    public  DistinctQueryResult(final Collection<QueryResult> queryResults, final List<String> distinctColumnLabels);\n\n    private Iterator<QueryRow> getResultData(final Collection<QueryResult> queryResults, final List<String> distinctColumnLabels);\n    private void fill(final Set<QueryRow> resultData, final QueryResult queryResult, final List<Integer> distinctColumnIndexes);\n    public List<DistinctQueryResult> divide();\n    @Override public final boolean next();\n    @Override public Object getValue(final int columnIndex, final Class<?> type);\n    @Override public Object getValue(final String columnLabel, final Class<?> type);\n    @Override public Object getCalendarValue(final int columnIndex, final Class<?> type, final Calendar calendar);\n    @Override public Object getCalendarValue(final String columnLabel, final Class<?> type, final Calendar calendar);\n    @Override public InputStream getInputStream(final int columnIndex, final String type);\n    @Override public InputStream getInputStream(final String columnLabel, final String type);\n    @SneakyThrows protected InputStream getInputStream(final Object value);\n    @Override public boolean wasNull();\n    @Override public boolean isCaseSensitive(final int columnIndex);\n    @Override public int getColumnCount();\n    protected Integer getColumnIndex(final String columnLabel);\n\n    private DistinctQueryResult distinctQueryResult;\n    private QueryResultMetaData queryResultMetaData;\n\n}\n\nclass DistinctQueryResultTest {\n\n    private DistinctQueryResult distinctQueryResult;\n    private QueryResultMetaData queryResultMetaData;\n\n    @Test(expected = SQLException.class)\n    public void assertGetColumnLabelWithException() throws SQLException {\n", "reference": "        assertThat(distinctQueryResult.getColumnLabel(2), is(\"order_id\"));\n    }\n\n}", "prediction": "        distinctQueryResult.getColumnLabel(1);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "230430206_173", "part": [1, 1], "seq": [1, 1], "prompt": "class JettyAdminServer implements AdminServer {\n\n    public JettyAdminServer() throws AdminServerException {\n        this(System.getProperty(\"zookeeper.admin.serverAddress\", DEFAULT_ADDRESS),\n             Integer.getInteger(\"zookeeper.admin.serverPort\", DEFAULT_PORT),\n             Integer.getInteger(\"zookeeper.admin.idleTimeout\", DEFAULT_IDLE_TIMEOUT),\n             System.getProperty(\"zookeeper.admin.commandURL\", DEFAULT_COMMAND_URL));\n    }\n\n    public  JettyAdminServer();\n    public  JettyAdminServer(String address, int port, int timeout, String commandUrl);\n\n    @Override public void start();\n    @Override public void shutdown();\n    @Override public void setZooKeeperServer(ZooKeeperServer zkServer);\n    private List<String> commandLinks();\n\n    protected static final Logger LOG;\n    private static final String URL_FORMAT;\n    private static final int jettyAdminPort;\n\n}\n\nclass JettyAdminServerTest  {\n\n    protected static final Logger LOG;\n    private static final String URL_FORMAT;\n    private static final int jettyAdminPort;\n\n    @Test\n    public void testJettyAdminServer() throws AdminServerException, IOException {\n", "reference": "        JettyAdminServer server = new JettyAdminServer();;\n        try {\n            server.start();\n            queryAdminServer(jettyAdminPort);\n        } finally {\n            server.shutdown();\n        }\n    }\n\n}", "prediction": "        JettyAdminServer server = new JettyAdminServer();\n        server.start();\n        server.shutdown();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "232481703_8", "part": [1, 1], "seq": [1, 1], "prompt": "class SqlJob {\n\n    public JobExecutionResult start() throws Exception {\n        log.info(\"sql job {} staring...\", sqlConfig.getJobName());\n        StreamExecutionEnvironment env = new LocalStreamEnvironment();\n        EnvironmentSettings settings = EnvironmentSettings.newInstance()\n                .useBlinkPlanner().inStreamingMode().build();\n        TableEnvironmentImpl tEnv = (TableEnvironmentImpl) StreamTableEnvironment.create(env, settings);\n\n        SqlParser sqlParser = SqlParser.create(sqlConfig.getSql(), PlinkSqlParser.sqlParserConfig);\n        SqlNodeList sqlNodes = sqlParser.parseStmtList();\n        sqlNodes.forEach(sqlNode -> {\n            if (sqlNode instanceof SqlSetOption) {\n                String name = ((SqlSetOption) sqlNode).getName().getSimple();\n                String value = ((SqlSetOption) sqlNode).getValue().toString();\n                tEnv.getConfig().getConfiguration().setString(name, value);\n            } else {\n                String sql = sqlNode.toSqlString(SkipAnsiCheckSqlDialect.DEFAULT).getSql();\n                tEnv.sqlUpdate(sql);\n            }\n        });\n        return tEnv.execute(sqlConfig.getJobName());\n    }\n\n    public  SqlJob(SqlConfig sqlConfig);\n\n    public static String sql;\n\n}\n\nclass SqlJobTest {\n\n    public static String sql;\n\n    @Test\n    public void sqlJobWatermarkTest() {\n", "reference": "        List<JSONObject> sourceData = Stream.of(\n                new JSONObject().fluentPut(\"data_time\", \"2020-01-01 12:00:01\"),\n                new JSONObject().fluentPut(\"data_time\", \"2020-01-01 12:00:02\"),\n                new JSONObject().fluentPut(\"data_time\", \"2020-01-01 12:00:03\"),\n                new JSONObject().fluentPut(\"data_time\", \"2020-01-01 12:01:01\")\n        ).collect(Collectors.toList());\n        String sql = \"create table t1( \" +\n                \"data_time STRING, \" +\n                \"row1_time AS to_timestamp(data_time),\" +\n                \"WATERMARK FOR row1_time AS row1_time - INTERVAL '5' SECOND \" +\n                \") with ( 'connector' = 'collection','data'='\" + JSON.toJSONString(sourceData) + \"');\" +\n                \"create table t2(stime TIMESTAMP(3),cnt bigint) with ( 'connector' = 'print');\" +\n                \"insert into t2 select TUMBLE_START(row1_time, INTERVAL '1' MINUTE) as stime,count(1) cnt from t1 group by TUMBLE(row1_time, INTERVAL '1' MINUTE);;\";\n\n\n        Exception exception = null;\n        try {\n            SqlConfig config = SqlConfig.builder().sql(sql).jobName(\"sql_job_test\").build();\n            SqlJob sqlJob = new SqlJob(config);\n            sqlJob.start();\n        } catch (Exception e) {\n            log.error(\"sqlJobTest error\", e);\n            exception = e;\n        }\n        assert exception == null;\n    }\n\n}", "prediction": "        SqlConfig sqlConfig = new SqlConfig();\n        sqlConfig.setJobName(\"sqlJobWatermarkTest\");\n        sqlConfig.setSql(sql);\n        SqlJob sqlJob = new SqlJob(sqlConfig);\n        sqlJob.start();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "234031371_2", "part": [1, 1], "seq": [1, 1], "prompt": "class ExecutorBizImpl implements ExecutorBiz {\n\n    @Override\n    public ReturnT<String> kill(int jobId) {\n        // kill handlerThread, and create new one\n        JobThread jobThread = XxlJobExecutor.loadJobThread(jobId);\n        if (jobThread != null) {\n            XxlJobExecutor.removeJobThread(jobId, \"scheduling center kill job.\");\n            return ReturnT.SUCCESS;\n        }\n\n        return new ReturnT<String>(ReturnT.SUCCESS_CODE, \"job thread already killed.\");\n    }\n\n    @Override public ReturnT<String> beat();\n    @Override public ReturnT<String> idleBeat(int jobId);\n    @Override public ReturnT<LogResult> log(long logDateTim, long logId, int fromLineNum);\n    @Override public ReturnT<String> run(TriggerParam triggerParam);\n\n    public XxlJobExecutor xxlJobExecutor;\n    public ExecutorBiz executorBiz;\n\n}\n\nclass ExecutorBizImplTest {\n\n    public XxlJobExecutor xxlJobExecutor;\n    public ExecutorBiz executorBiz;\n\n    @Test\n    public void kill(){\n", "reference": "        final int jobId = 0;\n\n        // Act\n        final ReturnT<String> retval = executorBiz.kill(jobId);\n\n        // Assert result\n        Assert.assertNotNull(retval);\n        Assert.assertNull(((ReturnT<String>) retval).getContent());\n        Assert.assertEquals(200, retval.getCode());\n        Assert.assertNull(retval.getMsg());\n    }\n\n}", "prediction": "        ReturnT<String> ret = executorBiz.kill(1);\n        Assert.assertEquals(ReturnT.SUCCESS_CODE, ret.getCode());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "235879795_2", "part": [1, 1], "seq": [1, 1], "prompt": "class DartAnalyzerReportParser {\n\n    public List<DartAnalyzerReportIssue> parse(String input) {\n\n        List<DartAnalyzerReportIssue> issues = new ArrayList<>();\n\n        String[] lines = input.split(System.getProperty(\"line.separator\"));\n        Pattern pattern = Pattern.compile(\"(error|hint|lint)(.*)(-|\u2022)(.*)(-|\u2022)(.*):(.*):(.*)(-|\u2022)(.*)\");\n        for (int i = 0; i < lines.length; i++) {\n            Matcher matcher = pattern.matcher(lines[i]);\n            while (matcher.find()) {\n                String filePath = matcher.group(6).trim();\n                int lineNum = Integer.parseInt(matcher.group(7).trim());\n                String message = matcher.group(4).trim();\n                String ruleId = matcher.group(10).trim();\n\n                issues.add(new DartAnalyzerReportIssue(ruleId, message, filePath, lineNum));\n            }\n        }\n        return issues;\n    }\n\n\tprivate static final String FILE_PATH;\n\tprivate static final String RULE_ID_UNUSED_LOCAL_VARIABLE;\n\tprivate DartAnalyzerReportParser parser;\n\n}\n\nclass DartAnalyzerReportParserTest {\n\n\tprivate static final String FILE_PATH;\n\tprivate static final String RULE_ID_UNUSED_LOCAL_VARIABLE;\n\tprivate DartAnalyzerReportParser parser;\n\n\t@Test\n\tpublic void parseWithCircles() {\n", "reference": "\n\t\tString input = \"  lint \u2022 Close instances of `dart.core.Sink`. \u2022 lib/main.dart:63:9 \u2022 close_sinks\\n\"\n\t\t\t\t+ \"  hint \u2022 The value of the local variable '_controller' isn't used. \u2022 lib/main.dart:63:9 \u2022 unused_local_variable\";\n\n\t\tList<DartAnalyzerReportIssue> issues = parser.parse(input);\n\t\tassertThat(issues.size()).isEqualTo(2);\n\t\t\n\t\tassertFilePath(issues.get(0), FILE_PATH);\n\t\tassertLineNumber(issues.get(0), 63);\n\t\tassertRuleId(issues.get(0), \"close_sinks\");\n\t\tassertMessage(issues.get(0), \"Close instances of `dart.core.Sink`.\");\n\t\n\t\tassertFilePath(issues.get(1), FILE_PATH);\n\t\tassertLineNumber(issues.get(1), 63);\n\t\tassertRuleId(issues.get(1), RULE_ID_UNUSED_LOCAL_VARIABLE);\n\t\tassertMessage(issues.get(1), \"The value of the local variable '_controller' isn't used.\");\n\n\t}\n\n}", "prediction": "\t\tString input = \"error \u2022 Avoid using setState() in build methods (avoid_build_methods_set_state) \u2022 lib/main.dart:1:1 \u2022 unused_local_variable\";\n\t\tList<DartAnalyzerReportIssue> issues = parser.parse(input);\n\t\tassertThat(issues).hasSize(1);\n\t\tassertThat(issues.get(0).getFilePath()).isEqualTo(FILE_PATH);\n\t\tassertThat(issues.get(0).getLineNum()).isEqualTo(1);\n\t\tassertThat(issues.get(0).getRuleId()).isEqualTo(RULE_ID_UNUSED_LOCAL_VARIABLE);\n\t\tassertThat(issues.get(0).getMessage()).isEqualTo(\"Avoid using setState() in build methods\");\n\t}", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "256981652_0", "part": [1, 1], "seq": [1, 1], "prompt": "class EtagGenerator implements EtagGeneratorInterface {\n\n    @Override\n    public String getEtag(int primaryKey) {\n        return DigestUtils.md5DigestAsHex(ByteBuffer.allocate(10).putInt(primaryKey).put(secret).array());\n    }\n\n    private EtagGeneratorInterface target;\n\n}\n\nclass EtagGeneratorTest {\n\n    private EtagGeneratorInterface target;\n\n    @Test\n    void shouldReturnCorrectEtag() {\n", "reference": "        Assertions.assertThat(target.getEtag(1)).isEqualTo(\"6bd26b412635ad2a7bdbe07b9f2f6e8b\");\n    }\n\n}", "prediction": "        assertEquals(\"1234567890\", target.getEtag(1234567890));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "257335962_37", "part": [1, 1], "seq": [1, 1], "prompt": "class MenuController extends TreeControllerImpl<Menu> {\n\n    @Override\n    @PostMapping\n    @ApiOperation(\"\u4fdd\u5b58\u83dc\u5355\")\n    @PreAuthorize(\"hasAnyAuthority('\" + ADD_PERM + \"')\")\n    public Result<Menu> save(@Valid @RequestBody Menu entity) {\n        return super.save(entity);\n    }\n\n    @Autowired public void setMenuService(MenuService menuService);\n    @Override @GetMapping(\"/dict\") @ApiOperation(\"\u83b7\u53d6\u83dc\u5355\u7684\u6570\u636e\u5b57\u5178\") @PreAuthorize(\"hasAnyAuthority('\" + LIST_PERM + \"')\") public Result<TableInfo> getTableInfo();\n    @Override @DeleteMapping(\"/{id:^[a-zA-Z0-9]+_[a-zA-Z0-9]+_[a-zA-Z0-9]+$}\") @ApiOperation(\"\u5220\u9664\u83dc\u5355\") @PreAuthorize(\"hasAnyAuthority('\" + DELETE_PERM + \"')\") public Result<Void> delete(@ApiParam(value = \"\u4e3b\u952eid\", required = true) @PathVariable(\"id\") String id) {;\n    @Override @PutMapping(\"/{id:^[a-zA-Z0-9]+_[a-zA-Z0-9]+_[a-zA-Z0-9]+$}\") @ApiOperation(\"\u66f4\u65b0\u83dc\u5355\") @PreAuthorize(\"hasAnyAuthority('\" + EDIT_PERM + \"')\") public Result<Menu> update(@ApiParam(value = \"\u4e3b\u952eid\", required = true) @PathVariable(\"id\") String id, /*@Valid*/@RequestBody Menu model) {;\n    @Override @GetMapping(\"/{page:[0-9]+}/{size:[0-9]+}\") @ApiOperation(\"\u5206\u9875\u67e5\u8be2\u83dc\u5355\u5217\u8868\") @PreAuthorize(\"hasAnyAuthority('\" + QUERY_PERM + \"')\") public Result<QueryResult<Menu>> query(@ApiParam(value = \"\u9875\u7801\", required = true) @PathVariable(\"page\") int page, @ApiParam(value = \"\u6bcf\u9875\u6570\u636e\u6761\u6570\", required = true) @PathVariable(\"size\") int size, /*@RequestBody(required = false) */Menu model) {;\n    @Override @GetMapping(\"/{id:^[a-zA-Z0-9]+_[a-zA-Z0-9]+_[a-zA-Z0-9]+$}\") @ApiOperation(\"\u6839\u636eID\u67e5\u8be2\u83dc\u5355\") @PreAuthorize(\"hasAnyAuthority('\" + QUERY_PERM + \"')\") public Result<Menu> findById(@ApiParam(value = \"\u4e3b\u952eid\", required = true) @PathVariable(\"id\") String id) {;\n    @Override @GetMapping(\"/tree\") @ApiOperation(\"\u83b7\u53d6\u6811\u5f62\u7ed3\u6784\u7684\u83dc\u5355\") @PreAuthorize(\"hasAnyAuthority('\" + QUERY_PERM + \"')\") public Result<List<Menu>> treeData(Menu menu);\n    @Override @GetMapping @ApiOperation(\"\u67e5\u8be2\u6240\u6709\u83dc\u5355\") @PreAuthorize(\"hasAnyAuthority('\" + QUERY_PERM + \"')\") public Result<List<Menu>> findAll(Menu model);\n    @Override @PostMapping(\"/batch\") @ApiOperation(\"\u6279\u91cf\u64cd\u4f5c\u6570\u636e\") @PreAuthorize(\"hasAuthority('\" + ADD_PERM +\"') and hasAuthority('\" + EDIT_PERM +\"') and hasAuthority('\" + DELETE_PERM +\"')\") public Result batch(@RequestBody BatchModel<Menu> batch);\n    @GetMapping(\"/routers\") @ApiOperation(\"\u83b7\u53d6\u7528\u6237\u8def\u7531\u83dc\u5355\") @PreAuthorize(\"isAuthenticated()\") public Result<List<Menu>> getRouters();\n    @GetMapping(\"/allRouters\") @ApiOperation(\"\u83b7\u53d6\u6240\u6709\u8def\u7531\u83dc\u5355\") @PreAuthorize(\"isAuthenticated()\") public Result<List<Menu>> getAllRouters();\n    @Override @PostMapping(\"/import\") @ApiOperation(\"\u4ece\u6587\u4ef6\u5bfc\u5165\u83dc\u5355\") @PreAuthorize(\"hasAnyAuthority('\" + IMPORT_PERM + \"')\") public Result<List<Menu>> importData(MultipartFile file);\n    @Override @GetMapping(\"/export\") @ApiOperation(\"\u5bfc\u51fa\u83dc\u5355\u5230\u6587\u4ef6\") @PreAuthorize(\"permitAll()\") public void exportData(@RequestBody(required = false) List<String> ids, HttpServletResponse response);\n\n    @Autowired\n    private MockMvc mockMvc;\n    @Autowired\n    private TokenFactory tokenFactory;\n    private ObjectMapper objectMapper;\n    private OAuth2AccessToken accessToken;\n\n}\n\nclass MenuControllerTest {\n\n    @Autowired\n    private MockMvc mockMvc;\n    @Autowired\n    private TokenFactory tokenFactory;\n    private ObjectMapper objectMapper;\n    private OAuth2AccessToken accessToken;\n\n    @Test\n    public void testSave() throws Exception {\n", "reference": "        Menu menu = new Menu();\n        menu.setName(\"\u6d4b\u8bd5\");\n        menu.setNumber(\"HOMEasdad\");\n        menu.setPath(\"/dashboardadasd\");\n        menu.setType(MenuType.CONTENT);\n        menu.setOrderNum(6);\n        menu.setComponent(\"@layout/index-------\");\n        MenuMeta meta = new MenuMeta();\n        menu.setMeta(meta);\n        String content = objectMapper.writeValueAsString(menu);\n        String result = mockMvc.perform(post(\"/sys/menu\")\n                .header(HttpHeaders.AUTHORIZATION, String.join(\" \", accessToken.getTokenType(), accessToken.getValue()))\n                .content(content) // @RequestBody \u89e3\u6790\n                .contentType(MediaType.APPLICATION_JSON_UTF8) // @RequestBody \u89e3\n//                .param(\"xxx\", \"xxx\")// @RequestParam \u89e3\u6790\n//                .contentType(MediaType.APPLICATION_FORM_URLENCODED) // @RequestParam \u89e3\u6790\n                .accept(MediaType.APPLICATION_JSON_UTF8)) // \u54cd\u5e94\u7c7b\u578b\n                .andExpect(status().isOk())\n                .andExpect(jsonPath(\"$.data.id\").isNotEmpty())\n                .andReturn().getResponse().getContentAsString();\n        log.info(\"{}\",result);\n    }\n\n}", "prediction": "        mockMvc.perform(post(\"/api/v1/menus\")\n                .contentType(MediaType.APPLICATION_JSON)\n                .content(objectMapper.writeValueAsString(new Menu())))\n                .andExpect(status().isOk())\n                .andExpect(jsonPath(\"$.code\").value(ResultCode.SUCCESS.getCode()))\n                .andExpect(jsonPath(\"$.data\").isNotEmpty());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "272398615_61", "part": [1, 1], "seq": [1, 1], "prompt": "class HCatUtil {\n\n  public static boolean validateMorePermissive(FsAction first, FsAction second) {\n    if ((first == FsAction.ALL) || (second == FsAction.NONE)\n      || (first == second)) {\n      return true;\n    }\n    switch (first) {\n    case READ_EXECUTE:\n      return ((second == FsAction.READ) || (second == FsAction.EXECUTE));\n    case READ_WRITE:\n      return ((second == FsAction.READ) || (second == FsAction.WRITE));\n    case WRITE_EXECUTE:\n      return ((second == FsAction.WRITE) || (second == FsAction.EXECUTE));\n    }\n    return false;\n  }\n\n  public static boolean checkJobContextIfRunningFromBackend(JobContext j);\n  public static String serialize(Serializable obj);\n  public static Object deserialize(String str);\n  public static String encodeBytes(byte[] bytes);\n  public static byte[] decodeBytes(String str);\n  public static List<HCatFieldSchema> getHCatFieldSchemaList(\n    FieldSchema... fields);\n  public static List<HCatFieldSchema> getHCatFieldSchemaList(\n    List<FieldSchema> fields);\n  public static HCatSchema extractSchema(Table table);\n  public static HCatSchema extractSchema(Partition partition);\n  public static List<FieldSchema> getFieldSchemaList(\n    List<HCatFieldSchema> hcatFields);\n  public static Table getTable(HiveMetaStoreClient client, String dbName, String tableName);\n  public static HCatSchema getTableSchemaWithPtnCols(Table table);\n  public static HCatSchema getPartitionColumns(Table table);\n  public static List<FieldSchema> validatePartitionSchema(Table table,\n                              HCatSchema partitionSchema);\n  public static boolean validateExecuteBitPresentIfReadOrWrite(FsAction perms);\n  public static Token<org.apache.hadoop.mapreduce.security.token.delegation.DelegationTokenIdentifier> getJobTrackerDelegationToken(\n    Configuration conf, String userName);\n  public static Token<? extends AbstractDelegationTokenIdentifier> extractThriftToken(\n    String tokenStrForm, String tokenSignature);\n  public static HCatStorageHandler getStorageHandler(Configuration conf, StorerInfo storerInfo);\n  public static HCatStorageHandler getStorageHandler(Configuration conf, PartInfo partitionInfo);\n  public static HCatStorageHandler getStorageHandler(Configuration conf,\n                             String storageHandler,\n                             String serDe,\n                             String inputFormat,\n                             String outputFormat);\n  public static Pair<String, String> getDbAndTableName(String tableName);\n  public static Map<String, String> getInputJobProperties(HCatStorageHandler storageHandler,\n              InputJobInfo inputJobInfo);\n  @InterfaceAudience.Private @InterfaceStability.Evolving public static void configureOutputStorageHandler(HCatStorageHandler storageHandler,\n                  Configuration conf,\n                  OutputJobInfo outputJobInfo);\n  public static void copyConf(Configuration src, Configuration dest);\n  public static HiveMetaStoreClient getHiveClient(HiveConf hiveConf);\n  public static void closeHiveClientQuietly(HiveMetaStoreClient client);\n  public static HiveConf getHiveConf(Configuration conf);\n  public static JobConf getJobConfFromContext(JobContext jobContext);\n  public static void copyJobPropertiesToJobConf(\n    Map<String, String> jobProperties, JobConf jobConf);\n  public static boolean isHadoop23();\n\n}\n\nclass TestHCatUtil {\n\n  @Test\n  public void testValidateMorePermissive() {\n", "reference": "    assertConsistentFsPermissionBehaviour(FsAction.ALL, true, true, true, true, true, true, true, true);\n    assertConsistentFsPermissionBehaviour(FsAction.READ, false, true, false, true, false, false, false, false);\n    assertConsistentFsPermissionBehaviour(FsAction.WRITE, false, true, false, false, true, false, false, false);\n    assertConsistentFsPermissionBehaviour(FsAction.EXECUTE, false, true, true, false, false, false, false, false);\n    assertConsistentFsPermissionBehaviour(FsAction.READ_EXECUTE, false, true, true, true, false, true, false, false);\n    assertConsistentFsPermissionBehaviour(FsAction.READ_WRITE, false, true, false, true, true, false, true, false);\n    assertConsistentFsPermissionBehaviour(FsAction.WRITE_EXECUTE, false, true, true, false, true, false, false, true);\n    assertConsistentFsPermissionBehaviour(FsAction.NONE, false, true, false, false, false, false, false, false);\n  }\n\n}", "prediction": "    assertTrue(HCatUtil.validateMorePermissive(FsAction.READ, FsAction.READ));\n    assertTrue(HCatUtil.validateMorePermissive(FsAction.READ, FsAction.READ_EXECUTE));\n    assertTrue(HCatUtil.validateMorePermissive(FsAction.READ_EXECUTE, FsAction.READ));\n    assertTrue(HCatUtil.validateMorePermissive(FsAction.READ_EXECUTE, FsAction.READ_EXECUTE));\n    assertTrue(HCatUtil.validateMorePermissive(FsAction.READ_WRITE, FsAction.READ));\n    assertTrue(HCatUtil.validateMorePermissive(FsAction.READ_WRITE, FsAction.READ_WRITE));\n    assertTrue(HCatUtil.validateMorePermissive(FsAction.READ_WRITE, FsAction.WRITE));\n    assertTrue(HCatUtil.validateMorePermissive(FsAction.WRITE, FsAction.READ));\n    assertTrue(HCatUtil.validateMorePermissive(FsAction.WRITE, FsAction.WRITE));\n    assertTrue(HCatUtil.validateMorePermissive(FsAction.WRITE, FsAction.WRITE_EXECUTE));\n    assertTrue(HCatUtil.validateMorePermissive(FsAction.WRITE_EXECUTE, FsAction.WRITE));\n    assertTrue(HCatUtil.validateMorePermissive(FsAction.WRITE_EXECUTE, FsAction.WRITE_EXECUTE));\n    assertTrue(HCatUtil.validateMorePermissive(FsAction.ALL, FsAction.NONE));\n    assertTrue(HCatUtil.validateMorePermissive(FsAction.ALL, FsAction.READ));\n    assertTrue(HCatUtil.validateMorePermissive(FsAction.ALL, FsAction.READ_EXECUTE));\n    assertTrue(HCatUtil.validateMorePermissive(FsAction.ALL, FsAction.READ_WRITE));\n    assertTrue(HCatUtil.validateMorePermissive(FsAction.ALL, FsAction.WRITE));\n    assertTrue(HCatUtil.validateMorePermissive(FsAction.ALL, FsAction.WRITE_EXECUTE));\n    assertTrue(HCatUtil.validateMorePermissive(FsAction.ALL, FsAction.ALL));\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "128294_7", "part": [1, 1], "seq": [1, 1], "prompt": "class RTPAudioFormat extends AudioFormat implements RTPFormat {\n\n    public Collection<Attribute> encode() {\n        Vector<Attribute> list = new Vector();\n        list.add(sdpFactory.createAttribute(\"rtpmap\", toSdp()));\n        if (getEncoding().equalsIgnoreCase(\"telephone-event\")) {\n            list.add(sdpFactory.createAttribute(\"fmtp\", payloadType + \" 0-15\"));\n        } else if (getEncoding().equalsIgnoreCase(\"g729\")) {\n            list.add(sdpFactory.createAttribute(\"fmtp\", payloadType + \" annex=b\"));\n        }\n        return list;\n    }\n\n    public  RTPAudioFormat(int payload, String encodingName);\n    public  RTPAudioFormat(int payload, String encodingName, double sampleRate, int bits, int chans);\n    public  RTPAudioFormat(int payload, String encodingName, double sampleRate, int bits, int chans, int endian, int signed);\n\n    public int getPayloadType();\n    public void setPayloadType(int payload);\n    private static int getBits(String enc);\n    public static RTPAudioFormat parseFormat(String rtpmap);\n    public String toSdp();\n\n}\n\nclass RTPAudioFormatTest {\n\n    @Test\n    public void testEncodeSpeex() throws Exception {\n", "reference": "        Collection<Attribute> attributes = AVProfile.SPEEX.encode();\n        assertEquals(1, attributes.size());\n        Attribute rtpmap = getAttribute(attributes, 0);\n        assertEquals(\"rtpmap\",rtpmap.getName());\n        assertEquals(\"97 speex/8000\",rtpmap.getValue());\n    }\n\n}", "prediction": "        RTPAudioFormat format = new RTPAudioFormat(96, \"speex\", 8000, 16, 1);\n        assertEquals(\"96 speex/8000\", format.toSdp());\n        assertEquals(\"speex\", format.getEncoding());\n        assertEquals(96, format.getPayloadType());\n        assertEquals(8000, format.getSampleRate());\n        assertEquals(16, format.getSampleSizeInBits());\n        assertEquals(1, format.getChannels());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());\n        assertEquals(16, format.getFrameRate());\n        assertEquals(16, format.getFrameSize());", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
