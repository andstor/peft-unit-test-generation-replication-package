{"id": "440622_6", "part": [1, 1], "seq": [1, 1], "prompt": "class EsperStatement implements EsperStatementOperations {\n\n\tpublic <T> List<T> concurrentUnsafeQuery(ParameterizedEsperRowMapper<T> rm) {\n\t\tLOG.info(\"Concurrent unsafe query being executed\");\n\n\t\tif (epStatement.isStopped() || epStatement.isDestroyed()) {\n\t\t\tLOG\n\t\t\t\t\t.error(\"Concurrent unsafe query was attempted when the statement was stopped or destroyed\");\n\t\t\tthrow new EsperStatementInvalidStateException(\n\t\t\t\t\t\"Attempted to execute a concurrent unsafe query when esper statement resource had state of \"\n\t\t\t\t\t\t\t+ epStatement.getState());\n\t\t}\n\n\t\tIterator<EventBean> safeIter = this.epStatement.iterator();\n\n\t\tList<T> objectList = new ArrayList<T>();\n\t\tfor (; safeIter.hasNext();) {\n\t\t\tEventBean event = safeIter.next();\n\t\t\tobjectList.add(rm.mapRow(event));\n\t\t}\n\n\t\tLOG.info(\"Concurrent unsafe query was completed\");\n\t\treturn objectList;\n\t}\n\n\tpublic  EsperStatement(String epl);\n\tpublic  EsperStatement(String id, String epl);\n\n\tpublic String getEPL();\n\tpublic EPStatementState getState();\n\tpublic void start();\n\tpublic void stop();\n\tpublic void destroy();\n\tpublic void doWithNativeEPStatement(NativeEPStatementCallback callback);\n\tpublic void setListeners(Set<UpdateListener> listeners);\n\tpublic Set<UpdateListener> getListeners();\n\tpublic void setSubscriber(Object subscriber);\n\tpublic void addListener(UpdateListener listener);\n\tprivate void refreshEPStatmentListeners();\n\tprivate void addEPStatementListener(UpdateListener listener);\n\t void setEPStatement(EPStatement epStatement);\n\tpublic List<T> concurrentSafeQuery(ParameterizedEsperRowMapper<T> rm);\n\tpublic T concurrentSafeQueryForObject(ParameterizedEsperRowMapper<T> rm);\n\tpublic T concurrentUnsafeQueryForObject(\n\t\t\tParameterizedEsperRowMapper<T> rm);\n\tpublic String getId();\n\t@Override public boolean equals(Object o);\n\t@Override public int hashCode();\n\t@Override public String toString();\n\n    private EsperTemplate template;\n    private EsperStatement statement;\n    private ParameterizedEsperRowMapper<SampleEvent> rowMapper;\n\n}\n\nclass TestEsperStatement {\n\n    private EsperTemplate template;\n    private EsperStatement statement;\n    private ParameterizedEsperRowMapper<SampleEvent> rowMapper;\n\n    @Test\n    public void testConcurrencyUnsafeQuery() throws Exception {\n", "reference": "\n        SampleEvent event = new SampleEvent();\n        template.sendEvent(event);\n\n        List<SampleEvent> events = statement.concurrentUnsafeQuery(this.rowMapper);\n\n        assertEquals(events.size(), 1);\n        assertEquals(events.get(0), event);\n    }\n\n}", "prediction": "\tList<SampleEvent> events = statement.concurrentUnsafeQuery(rowMapper);\n\tAssert.assertEquals(1, events.size());\n\tAssert.assertEquals(\"test\", events.get(0).getName());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "466142_72", "part": [1, 1], "seq": [1, 1], "prompt": "class ConnectionPartition implements Serializable {\n\n\tprotected void trackConnectionFinalizer(ConnectionHandle connectionHandle) {\n\t\tif (!this.disableTracking){\n\t\t//\tassert!connectionHandle.getPool().getFinalizableRefs().containsKey(connectionHandle) : \"Already tracking this handle\";\n\t\t\tConnection con = connectionHandle.getInternalConnection();\n\t\t\tif (con!= null && con instanceof Proxy && Proxy.getInvocationHandler(con) instanceof MemorizeTransactionProxy){\n\t\t\t\ttry {\n\t\t\t\t\t// if this is a proxy, get the correct target so that when we call close we're actually calling close on the database\n\t\t\t\t\t// handle and not a proxy-based close.\n\t\t\t\t\tcon = (Connection) Proxy.getInvocationHandler(con).invoke(con, ConnectionHandle.class.getMethod(\"getProxyTarget\"), null);\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\tlogger.error(\"Error while attempting to track internal db connection\", t); // should never happen\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinal Connection internalDBConnection = con;\n\t\t\tfinal BoneCP pool = connectionHandle.getPool();\n\t\t\tconnectionHandle.getPool().getFinalizableRefs().put(internalDBConnection, new FinalizableWeakReference<ConnectionHandle>(connectionHandle, connectionHandle.getPool().getFinalizableRefQueue()) {\n\t\t\t\t@SuppressWarnings(\"synthetic-access\")\n\t\t\t\tpublic void finalizeReferent() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tpool.getFinalizableRefs().remove(internalDBConnection);\n\t\t\t\t\t\tif (internalDBConnection!= null &&!internalDBConnection.isClosed()){ // safety!\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tlogger.warn(\"BoneCP detected an unclosed connection \"+ConnectionPartition.this.poolName + \"and will now attempt to close it for you. \" +\n\t\t\t\t\t\t\t\"You should be closing this connection in your application - enable connectionWatch for additional debugging assistance or set disableConnectionTracking to true to disable this feature entirely.\");\n\t\t\t\t\t\t\tinternalDBConnection.close();\n\t\t\t\t\t\t\tupdateCreatedConnections(-1);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\t\tlogger.error(\"Error while closing off internal db connection\", t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tpublic  ConnectionPartition(BoneCP pool);\n\n\tprotected BlockingQueue<Object> getPoolWatchThreadSignalQueue();\n\tprotected void updateCreatedConnections(int increment);\n\tprotected void addFreeConnection(ConnectionHandle connectionHandle);\n\tprotected BlockingQueue<ConnectionHandle> getFreeConnections();\n\tprotected void setFreeConnections(BlockingQueue<ConnectionHandle> freeConnections);\n\tprotected int getAcquireIncrement();\n\tprotected int getMinConnections();\n\tprotected int getMaxConnections();\n\tprotected int getCreatedConnections();\n\tprotected String getUrl();\n\tprotected String getUsername();\n\tprotected String getPassword();\n\tprotected boolean isUnableToCreateMoreTransactions();\n\tprotected void setUnableToCreateMoreTransactions(boolean unableToCreateMoreTransactions);\n\tprotected int getAvailableConnections();\n\tpublic int getRemainingCapacity();\n\tprotected long getQueryExecuteTimeLimitinNanoSeconds();\n\t@Override public String toString();\n\n\tprivate BoneCP mockPool;\n\tprivate Logger mockLogger;\n\tprivate BoneCPConfig mockConfig;\n\tprivate ConnectionPartition testClass;\n\n}\n\nclass TestConnectionPartition {\n\n\tprivate BoneCP mockPool;\n\tprivate Logger mockLogger;\n\tprivate BoneCPConfig mockConfig;\n\tprivate ConnectionPartition testClass;\n\n\t@Test\n\tpublic void testFinalizerException2() throws SQLException, InterruptedException, SecurityException, NoSuchFieldException, IllegalArgumentException, IllegalAccessException{\n", "reference": "\t\tConnectionHandle mockConnectionHandle = createNiceMock(ConnectionHandle.class); \n\t\texpect(mockConnectionHandle.isInReplayMode()).andReturn(true).anyTimes();\n\t\tConnection mockConnection = createNiceMock(Connection.class);\n\t\tConnection connection = new MemorizeTransactionProxyDummy(null,null).memorizeDummy(mockConnection, mockConnectionHandle);\n\t\texpect(mockConnectionHandle.getInternalConnection()).andReturn(connection).anyTimes();\n\t\tmakeThreadSafe(mockConnectionHandle, true);\n\t\tmakeThreadSafe(mockConnection, true);\n\t\tmockLogger = TestUtils.mockLogger(testClass.getClass());\n\t\t\n\t\treset(mockLogger);\n\t\tmakeThreadSafe(mockLogger, true);\n\t\treset(this.mockPool);\n\t\tMap<Connection, Reference<ConnectionHandle>> refs = new HashMap<Connection, Reference<ConnectionHandle>>();\n\t\texpect(this.mockPool.getFinalizableRefs()).andReturn(refs).anyTimes();\n\t\tFinalizableReferenceQueue finalizableRefQueue = new FinalizableReferenceQueue();\n\t\texpect(this.mockPool.getFinalizableRefQueue()).andReturn(finalizableRefQueue).anyTimes();\n\t\texpect(mockConnectionHandle.getPool()).andReturn(this.mockPool).anyTimes();\n\n\t\treplay(mockConnection, mockConnectionHandle, this.mockPool);\n\n\t\ttestClass.trackConnectionFinalizer(mockConnectionHandle);\n\t\treset(mockConnectionHandle);\n\t\tmockConnectionHandle = null; // prompt GC to kick in\n\t\tfor (int i=0; i < 100; i++){\n\t\t\tSystem.gc();System.gc();System.gc();\n\t\t\tThread.sleep(20);\n\t\t\ttry{\n\t\t\t\tverify(mockConnection);\n\t\t\t\tbreak; // we succeeded\n\t\t\t} catch (Throwable t){\n\t\t\t\tt.printStackTrace();\n\t\t\t\t// do nothing, try again\n\t\t\t\tThread.sleep(20);\n\t\t\t}\n\t\t}\n\t}\n\n}", "prediction": "\t\ttestClass = new ConnectionPartition(mockPool) {\n\t\t\t@Override\n\t\t\tprotected void trackConnectionFinalizer(ConnectionHandle connectionHandle) {\n\t\t\t\tthrow new RuntimeException(\"test\");\n\t\t\t}\n\t\t};\n\t\ttestClass.trackConnectionFinalizer(new ConnectionHandle(mockPool, mockLogger, mockConfig, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "486214_0", "part": [1, 1], "seq": [1, 1], "prompt": "class CommonSource extends ReflectiveExpressionSource {\n\n\t@Property\n\tpublic Object emit()\n\t{\n\t\treturn Attribute.ATTR_EMIT;\n\t}\n\n\t@Inject public  CommonSource(Stage stage);\n\n\t@Property public Object skip();\n\t@Method public String urlencode(String in);\n\t@Method(\"urlencode\") public String urlencodeInput(@Instance String in);\n\t@Method public String htmlencode(String in);\n\t@Method(\"htmlencode\") public String htmlencodeInput(@Instance String in);\n\n}\n\nclass CommonSourceTest extends ReflectiveExpressionSource {\n\n\t@Test\n\tpublic void testEmit()\n\t{\n", "reference": "\t\tAssert.assertEquals(Attribute.ATTR_EMIT, execute(\"t:emit\", \"\"));\n\t\tAssert.assertEquals(Attribute.ATTR_EMIT, execute(\"true ? t:emit\", \"\"));\n\t}\n\n}", "prediction": "\t\tassertEquals(Attribute.ATTR_EMIT, emit());\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "526150_13", "part": [1, 1], "seq": [1, 1], "prompt": "class WorldFireReader extends AbstractProductReader {\n\n    @Override\n    public TreeNode<File> getProductComponents() {\n        final File inputFile = new File(getInput().toString());\n        final File parent = inputFile.getParentFile();\n        final TreeNode<File> result = new TreeNode<File>(parent.getName());\n        result.setContent(parent);\n\n        final TreeNode<File> productFile = new TreeNode<File>(inputFile.getName());\n        productFile.setContent(inputFile);\n        result.addChild(productFile);\n\n        return result;\n    }\n\n    protected  WorldFireReader(WorldFireReaderPlugIn readerPlugIn);\n\n    @Override protected Product readProductNodesImpl();\n    private void attachGeoCoding(Product product);\n    private MultiLevelImage createFireImage(List<Placemark> fireList, final Product product);\n    private List<Placemark> getFireSpotList(File inputFile, GeoCoding geoCoding);\n     String getProductType(File inputFile);\n    @Override protected void readBandRasterDataImpl(int sourceOffsetX, int sourceOffsetY,\n                                          int sourceWidth, int sourceHeight,\n                                          int sourceStepX, int sourceStepY,\n                                          Band destBand,\n                                          int destOffsetX, int destOffsetY,\n                                          int destWidth, int destHeight,\n                                          ProductData destBuffer, ProgressMonitor pm);\n    @Override public WorldFireReaderPlugIn getReaderPlugIn();\n    private static Placemark parseLine(String text, int index, GeoCoding geoCoding);\n\n    private WorldFireReader reader;\n\n}\n\nclass WorldFireReaderTest {\n\n    private WorldFireReader reader;\n\n    @Test\n    public void testReader() throws IOException {\n", "reference": "        final File file = TestResourceHelper.getAatsrAlgo1AsFile();\n        reader.readProductNodes(file, null);\n        assertNotNull(reader.getInput());\n        assertNull(reader.getSubsetDef());\n        assertSame(file, reader.getInput());\n        final TreeNode<File> productComponents = reader.getProductComponents();\n        assertNotNull(productComponents);\n        assertEquals(1, productComponents.getChildren().length);\n    }\n\n}", "prediction": "        final File inputFile = new File(getClass().getResource(\"/worldfire/worldfire.kml\").getFile());\n        final Product product = reader.readProductNodes(inputFile);\n        assertNotNull(product);\n        assertEquals(1, product.getBandCount());\n        assertEquals(1, product.getSceneRasterWidth());\n        assertEquals(1, product.getSceneRasterHeight());\n        assertEquals(1, product.getSceneRasterSize());\n        assertEquals(1, product.getSceneRasterBands().length);\n        assertEquals(1, product.getSceneRasterBands()[0].getSampleModels().length);\n        assertEquals(1, product.getSceneRasterBands()[0].getSampleSize());\n        assertEquals(1, product.getSceneRasterBands()[0].getSampleModel().getNumDataElements());\n        assertEquals(1, product.getSceneRasterBands()[0].getSampleModel().getDataType());\n        assertEquals(1, product.getSceneRasterBands()[0].getSampleModel().getPixelStride());\n        assertEquals(1, product.getSceneRasterBands()[0].getSampleModel().getScanlineStride());\n        assertEquals(1, product.getSceneRasterBands()[0].getSampleModel().getTransferType());\n        assertEquals(1, product.getSceneRasterBands()[0].getSampleModel().getTransferDataBuffer().getSize());\n        assertEquals(1, product.getSceneRasterBands()[0].getSampleModel().getTransferDataBuffer().getNumElements());\n        assertEquals(1, product.getSceneRasterBands()[0].getSampleModel().getTransferDataBuffer().getDataType());\n        assertEquals(1, product.getSceneRasterBands()[0].getSampleModel().getTransferDataBuffer().getOffset());\n        assertEquals(1, product.getSceneRasterBands()[0].getSampleModel().getTransferDataBuffer().getLength());\n        assertEquals(1, product.getSceneRasterBands()[0].getSampleModel().getTransferDataBuffer().getCapacity());\n        assertEquals(1, product.getSceneRasterBands()[0].getSampleModel().getTransferDataBuffer().getArray().length);\n        assertEquals(1, product.getSceneRasterBands()[0].getSampleModel().getTransferDataBuffer().getArrayOffset());\n        assertEquals(1, product.getSceneRasterBands()[0].getSampleModel().getTransferDataBuffer().getArrayLength());\n        assertEquals(1, product.getSceneRasterBands()[0].getSampleModel().getTransferDataBuffer().getArrayOffset());\n        assertEquals(1, product.getSceneRasterBands()[0].getSampleModel().getTransferDataBuffer().getArrayLength());\n        assertEquals(1, product.getSceneRasterBands()[0].getSampleModel().getTransferDataBuffer().getArrayOffset());\n        assertEquals(1, product.getSceneRasterBands()[0].getSampleModel().getTransferDataBuffer().getArrayLength());\n        assertEquals(1, product.getSceneRasterBands()[0].getSampleModel().getTransferDataBuffer().getArrayOffset());\n        assertEquals(1, product.getSceneRasterBands()[0].getSampleModel().getTransferDataBuffer().getArrayLength());\n        assertEquals(1, product.getSceneRasterBands()[0].getSampleModel().getTransferDataBuffer().getArrayOffset());\n        assertEquals(1, product.getSceneRasterBands()[0].getSampleModel().getTransferDataBuffer().getArrayLength());\n        assertEquals(1, product.getSceneRasterBands()[0].getSampleModel().getTransferDataBuffer().getArrayOffset());\n        assertEquals(1, product.getSceneRasterBands()[0].getSampleModel().getTransferDataBuffer().getArrayLength());\n        assertEquals(1, product.getSceneRasterBands()[0].getSampleModel().getTransferDataBuffer().getArrayOffset());\n        assertEquals(1, product.getSceneRasterBands()[0].getSampleModel().getTransferDataBuffer().getArrayLength());\n        assertEquals(1, product.getSceneRasterBands()[0].getSampleModel().getTransferDataBuffer().getArrayOffset());\n        assertEquals(1, product.getSceneRasterBands()[0].getSampleModel().getTransferDataBuffer().getArrayLength());\n        assertEquals(1, product.getSceneRasterBands()[0].getSampleModel().getTransferDataBuffer().getArrayOffset());\n        assertEquals(1, product.getSceneRasterBands()[0].getSampleModel().getTransferDataBuffer().getArrayLength());\n        assertEquals(1, product.getSceneRasterBands()[0].getSampleModel().getTransferDataBuffer().getArrayOffset());\n        assertEquals(1, product.getSceneRasterBands()[0].getSampleModel().getTransferDataBuffer().getArrayLength());\n        assertEquals(1, product.getSceneRasterBands()[0].getSampleModel().getTransferDataBuffer().getArrayOffset());\n        assertEquals(1, product.getSceneRasterBands()[0].getSampleModel().getTransferDataBuffer().getArrayLength());\n        assertEquals(1, product.getSceneRasterBands()[0].getSampleModel().getTransferDataBuffer().getArrayOffset());\n        assertEquals(1, product.getSceneRasterBands()[0].getSampleModel().getTransferDataBuffer().getArrayLength());\n        assertEquals(1, product.getSceneRasterBands()[0].getSampleModel().getTransferDataBuffer().getArrayOffset());\n        assertEquals(1, product.getSceneRasterBands()[0].getSampleModel().getTransferDataBuffer().getArrayLength());\n        assertEquals(1, product.getSceneRasterBands()[0].getSampleModel().getTransferDataBuffer().getArrayOffset());\n        assertEquals(1, product.getSceneRasterBands()[0].getSampleModel().getTransferDataBuffer().getArrayLength());\n        assertEquals(1, product.getSceneRasterBands()[0].getSampleModel().getTransferDataBuffer().getArrayOffset());\n        assertEquals(1, product.getSceneRasterBands()[0].get", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "772158_1", "part": [1, 1], "seq": [1, 1], "prompt": "class ArrayUtils {\n\n\tpublic static int fuzzySearch(final float[] base, final float value, final boolean orGreater) {\n\n\t\t// no point in searching an empty array\n\t\tif (base == null || base.length == 0)\n\t\t\treturn -1;\n\n\t\t// quick check if the searched value is inside\n\t\tif (value < base[0]) {\n\t\t\tif (orGreater)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tfinal int last = base.length - 1;\n\t\tif (value > base[last]) {\n\t\t\tif (orGreater)\n\t\t\t\treturn -1;\n\t\t\telse\n\t\t\t\treturn last;\n\t\t}\n\n\t\treturn fuzzySearch(base, value, 0, base.length - 1, orGreater);\n\t}\n\n\tpublic static int[] fuzzyIntervalSearch(final float[] base, final float startValue, final float endValue);\n\tprivate static int[] searchStartAndEnd(final float[] base, final float startValue, final float endValue, final int leftLimit,\n\t\t\tfinal int rightLimit);\n\tprivate static int fuzzySearch(final float[] base, final float value, final int leftLimit, final int rightLimit,\n\t\t\tfinal boolean orGreater);\n\n}\n\nclass ArrayUtilsTest {\n\n\t@Test\n\tpublic void testFuzzySearch() {\n", "reference": "\t\tfinal float[] base = new float[] { 1, 4, 4, 5, 7.3f, 8, 10, 23.4f, 23.4f, 34 };\n\t\tfinal float[] nullBase = null;\n\t\tfinal float[] emptyBase = new float[0];\n\n\t\t// empty arrays\n\t\tassertEquals(-1, ArrayUtils.fuzzySearch(nullBase, 5, true));\n\t\tassertEquals(-1, ArrayUtils.fuzzySearch(emptyBase, 5, false));\n\n\t\t// value outside the array\n\t\tassertEquals(0, ArrayUtils.fuzzySearch(base, 0.1f, true));\n\t\tassertEquals(-1, ArrayUtils.fuzzySearch(base, 0.1f, false));\n\t\tassertEquals(-1, ArrayUtils.fuzzySearch(base, 101, true));\n\t\tassertEquals(base.length - 1, ArrayUtils.fuzzySearch(base, 101, false));\n\n\t\t// normal case\n\t\tassertEquals(3, ArrayUtils.fuzzySearch(base, 5, true));\n\n\t\t// toTheRight in case of exact match\n\t\tassertEquals(1, ArrayUtils.fuzzySearch(base, 4, true));\n\t\tassertEquals(2, ArrayUtils.fuzzySearch(base, 4, false));\n\n\t\t// fuzzy match\n\t\tassertEquals(4, ArrayUtils.fuzzySearch(base, 7, true));\n\t\tassertEquals(3, ArrayUtils.fuzzySearch(base, 7, false));\n\t}\n\n}", "prediction": "\t\tfinal float[] base = new float[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n\t\tassertEquals(0, ArrayUtils.fuzzySearch(base, 1, false));\n\t\tassertEquals(0, ArrayUtils.fuzzySearch(base, 1, true));\n\t\tassertEquals(1, ArrayUtils.fuzzySearch(base, 2, false));\n\t\tassertEquals(1, ArrayUtils.fuzzySearch(base, 2, true));\n\t\tassertEquals(2, ArrayUtils.fuzzySearch(base, 3, false));\n\t\tassertEquals(2, ArrayUtils.fuzzySearch(base, 3, true));\n\t\tassertEquals(3, ArrayUtils.fuzzySearch(base, 4, false));\n\t\tassertEquals(3, ArrayUtils.fuzzySearch(base, 4, true));\n\t\tassertEquals(4, ArrayUtils.fuzzySearch(base, 5, false));\n\t\tassertEquals(4, ArrayUtils.fuzzySearch(base, 5, true));\n\t\tassertEquals(5, ArrayUtils.fuzzySearch(base, 6, false));\n\t\tassertEquals(5, ArrayUtils.fuzzySearch(base, 6, true));\n\t\tassertEquals(6, ArrayUtils.fuzzySearch(base, 7, false));\n\t\tassertEquals(6, ArrayUtils.fuzzySearch(base, 7, true));\n\t\tassertEquals(7, ArrayUtils.fuzzySearch(base, 8, false));\n\t\tassertEquals(7, ArrayUtils.fuzzySearch(base, 8, true));\n\t\tassertEquals(8, ArrayUtils.fuzzySearch(base, 9, false));\n\t\tassertEquals(8, ArrayUtils.fuzzySearch(base, 9, true));\n\t\tassertEquals(9, ArrayUtils.fuzzySearch(base, 10, false));\n\t\tassertEquals(9, ArrayUtils.fuzzySearch(base, 10, true));\n\t\tassertEquals(-1, ArrayUtils.fuzzySearch(base, 0, false));\n\t\tassertEquals(-1, ArrayUtils.fuzzySearch(base, 0, true));\n\t\tassertEquals(-1, ArrayUtils.fuzzySearch(base, 11, false));\n\t\tassertEquals(-1, ArrayUtils.fuzzySearch(base, 11, true));\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "777444_210", "part": [1, 1], "seq": [1, 1], "prompt": "class TabularDataExtractor implements Extractor {\n\n    public Class getType() {\n        return TabularData.class;\n    }\n\n    public Object extractObject(ObjectToJsonConverter pConverter, Object pValue,\n                                Stack<String> pPathParts,boolean pJsonify);\n    private boolean checkForMxBeanMap(TabularType pType);\n    private Object convertTabularDataToJson(TabularData pTd, Stack<String> pExtraArgs, ObjectToJsonConverter pConverter);\n    private boolean hasComplexKeys(TabularType pType);\n    private Object convertToMaps(TabularData pTd, Stack<String> pExtraArgs, ObjectToJsonConverter pConverter);\n    private Object convertTabularDataDirectly(TabularData pTd, Stack<String> pExtraArgs, ObjectToJsonConverter pConverter);\n    private JSONObject getNextMap(JSONObject pJsonObject, Object pKey);\n    private CompositeData extractCompositeDataFromPath(TabularData pTd, Stack<String> pPathStack);\n    private void checkPathFitsIndexNames(Stack<String> pPathStack, List<String> pIndexNames);\n    private Object getKey(CompositeType rowType, String key, String value);\n    private Object convertMxBeanMapToJson(TabularData pTd, Stack<String> pExtraArgs, ObjectToJsonConverter pConverter);\n    public Object setObjectValue(StringToObjectConverter pConverter, Object pInner, String pAttribute, Object pValue);\n    public boolean canSetValue();\n\n    private static final String TEST_VALUE;\n     TabularDataExtractor extractor;\n     ObjectToJsonConverter converter;\n\n}\n\nclass TabularDataExtractorTest {\n\n    private static final String TEST_VALUE;\n     TabularDataExtractor extractor;\n     ObjectToJsonConverter converter;\n\n    @Test(expectedExceptions = IllegalArgumentException.class,expectedExceptionsMessageRegExp = \".*Boolean.*\")\n    void extractTabularDataWithPathButWrongIndexType() throws OpenDataException, AttributeNotFoundException {\n", "reference": "        TabularTypeAndJson taj = new TabularTypeAndJson(\n                new String[] { \"verein\", \"absteiger\" },\n                new CompositeTypeAndJson(\n                        STRING,\"verein\",null,\n                        INTEGER,\"platz\",null,\n                        BOOLEAN,\"absteiger\",null\n                ));\n        TabularData data = new TabularDataSupport(taj.getType());\n        data.put(new CompositeDataSupport(\n                taj.getType().getRowType(),\n                new String[] { \"verein\", \"platz\", \"absteiger\" },\n                new Object[] { \"fcn\", 6, false }\n        ));\n        extract(true,data,\"fcn\",\"true\");\n    }\n\n}", "prediction": "        extractor.extractObject(converter, TEST_VALUE, new Stack<String>(), false);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "781084_0", "part": [1, 1], "seq": [1, 1], "prompt": "class WebHookSecurityInterceptor extends HandlerInterceptorAdapter {\n\n  @Override\n  public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n    return webHookAdapter.isValidRequest(request);\n  }\n\n}\n\nclass TestWebHookSecurityInterceptor {\n\n  @Test\n  public void testPreHandle() throws Exception {\n", "reference": "    MyTestWebHookAdapter adapter = new MyTestWebHookAdapter();\n    WebHookSecurityInterceptor interceptor = new WebHookSecurityInterceptor();\n    // set the adapter like spring would do.\n    Field field = WebHookSecurityInterceptor.class.getDeclaredField(\"webHookAdapter\");\n    field.setAccessible(true);\n    field.set(interceptor, adapter);\n    field.setAccessible(false);\n    // call the interceptor.\n    interceptor.preHandle(new MockHttpServletRequest(), new MockHttpServletResponse(), null);\n    // all we have to check is if the adapter was called.\n    assertTrue(adapter.wasCalled(\"isValidRequest\"));\n  }\n\n}", "prediction": "    WebHookSecurityInterceptor interceptor = new WebHookSecurityInterceptor();\n    MockHttpServletRequest request = new MockHttpServletRequest();\n    MockHttpServletResponse response = new MockHttpServletResponse();\n    Object handler = new Object();\n    boolean result = interceptor.preHandle(request, response, handler);\n    assertThat(result).isTrue();\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "793164_35", "part": [1, 1], "seq": [1, 1], "prompt": "class PatientInfoTransformer {\n\n    public List<String> toHL7(PatientInfo patientInfo) {\n        if (patientInfo == null) {\n            return Collections.emptyList();\n        }\n        \n        List<String> hl7Strings = new ArrayList<String>();\n        for (Map.Entry<Integer, PIDTransformer> entry : pidTransformers.entrySet()) {\n            String pidNoStr = PID_PREFIX + entry.getKey();\n            List<String> repetitions = entry.getValue().toHL7(patientInfo);\n            if (repetitions!= null) {\n                for (String repetition : repetitions) {\n                    hl7Strings.add(pidNoStr + '|' + repetition);\n                }\n            }\n        }\n        \n        return hl7Strings;\n    }\n\n    public PatientInfo fromHL7(List<String> hl7PID);\n    private Integer getPidNumber(String pidNoStr);\n\n    private PatientInfoTransformer transformer;\n\n}\n\nclass PatientInfoTransformerTest {\n\n    private PatientInfoTransformer transformer;\n\n    @Test\n    public void testToHL7MultiId() {\n", "reference": "        PatientInfo patientInfo = new PatientInfo();\n\n        Identifiable id = new Identifiable();\n        id.setId(\"abcdef\");\n        patientInfo.getIds().add(id);\n        Identifiable id2 = new Identifiable();\n        id2.setId(\"ghijkl\");\n        patientInfo.getIds().add(id2);\n\n        Name name = new XpnName();\n        name.setFamilyName(\"Joman\");\n        patientInfo.setName(name);\n\n        Address address = new Address();\n        address.setStreetAddress(\"Jo Str. 3\");\n        patientInfo.setAddress(address);\n\n        patientInfo.setDateOfBirth(\"1234\");\n        patientInfo.setGender(\"A\");\n\n        List<String> hl7Data = transformer.toHL7(patientInfo);\n        assertEquals(6, hl7Data.size());\n\n        assertEquals(\"PID-3|abcdef\", hl7Data.get(0));\n        assertEquals(\"PID-3|ghijkl\", hl7Data.get(1));\n        assertEquals(\"PID-5|Joman\", hl7Data.get(2));\n        assertEquals(\"PID-7|1234\", hl7Data.get(3));\n        assertEquals(\"PID-8|A\", hl7Data.get(4));\n        assertEquals(\"PID-11|Jo Str. 3\", hl7Data.get(5));\n    }\n\n}", "prediction": "        PatientInfo patientInfo = new PatientInfo();\n        patientInfo.setPatientId(\"1234567890\");\n        patientInfo.setPatientName(\"\");\n        patientInfo.setPatientBirthDate(\"19800101\");\n        patientInfo.setPatientSex(\"M\");\n        patientInfo.setPatientAddress(\"123 Main St\");\n        patientInfo.setPatientCity(\"Anytown\");\n        patientInfo.setPatientState(\"CA\");\n        patientInfo.setPatientZip(\"90210\");\n        patientInfo.setPatientPhone(\"1234567890\");\n        patientInfo.setPatientEmail(\"\");\n        patientInfo.setPatientSSN(\"123456789\");\n        patientInfo.setPatientMRN(\"1234567890\");\n        patientInfo.setPatientAccountNumber(\"1234567890\");\n        patientInfo.setPatientAccountType(\"1234567890\");\n        patientInfo.setPatientAccountStatus(\"1234567890\");\n        patientInfo.setPatientAccountBalance(\"1234567890\");\n        patientInfo.setPatientAccountBalanceDate(\"19800101\");\n        patientInfo.setPatientAccountBalanceType(\"1234567890\");\n        patientInfo.setPatientAccountBalanceStatus(\"1234567890\");\n        patientInfo.setPatientAccountBalanceReason(\"1234567890\");\n        patientInfo.setPatientAccountBalanceAmount(\"1234567890\");\n        patientInfo.setPatientAccountBalanceDate(\"19800101\");\n        patientInfo.setPatientAccountBalanceType(\"1234567890\");\n        patientInfo.setPatientAccountBalanceStatus(\"1234567890\");\n        patientInfo.setPatientAccountBalanceReason(\"1234567890\");\n        patientInfo.setPatientAccountBalanceAmount(\"1234567890\");\n        patientInfo.setPatientAccountBalanceDate(\"19800101\");\n        patientInfo.setPatientAccountBalanceType(\"1234567890\");\n        patientInfo.setPatientAccountBalanceStatus(\"1234567890\");\n        patientInfo.setPatientAccountBalanceReason(\"1234567890\");\n        patientInfo.setPatientAccountBalanceAmount(\"1234567890\");\n        patientInfo.setPatientAccountBalanceDate(\"19800101\");\n        patientInfo.setPatientAccountBalanceType(\"1234567890\");\n        patientInfo.setPatientAccountBalanceStatus(\"1234567890\");\n        patientInfo.setPatientAccountBalanceReason(\"1234567890\");\n        patientInfo.setPatientAccountBalanceAmount(\"1234567890\");\n        patientInfo.setPatientAccountBalanceDate(\"19800101\");\n        patientInfo.setPatientAccountBalanceType(\"1234567890\");\n        patientInfo.setPatientAccountBalanceStatus(\"1234567890\");\n        patientInfo.setPatientAccountBalanceReason(\"1234567890\");\n        patientInfo.setPatientAccountBalanceAmount(\"1234567890\");\n        patientInfo.setPatientAccountBalanceDate(\"19800101\");\n        patientInfo.setPatientAccountBalanceType(\"1234567890\");\n        patientInfo.setPatientAccountBalanceStatus(\"1234567890\");\n        patientInfo.setPatientAccountBalanceReason(\"1234567890\");\n        patientInfo.setPatientAccountBalanceAmount(\"1234567890\");\n        patientInfo.setPatientAccountBalanceDate(\"19800101\");\n        patientInfo.setPatientAccountBalanceType(\"1234567890\");\n        patientInfo.setPatientAccountBalanceStatus(\"1234567890\");\n        patientInfo.setPatientAccountBalanceReason(\"1234567890\");\n        patientInfo.setPatientAccountBalanceAmount(\"1234567890\");\n        patientInfo.setPatientAccountBalanceDate(\"19800101\");\n        patientInfo.setPatientAccountBalanceType(\"1234567890\");\n        patientInfo.setPatientAccountBalanceStatus(\"1234567890\");\n        patientInfo.setPatientAccountBalanceReason(\"1234567890\");\n        patientInfo.setPatientAccountBalanceAmount(\"1234567890\");\n        patientInfo.setPatientAccountBalanceDate(\"19800101\");\n        patientInfo.setPatientAccountBalanceType(\"1234567890\");\n        patientInfo.setPatientAccountBalanceStatus(\"1234567890\");\n        patientInfo.setPatientAccountBalanceReason(\"1234567890\");\n        patientInfo.setPatientAccountBalanceAmount(\"1234567890\");\n        patientInfo.setPatientAccountBalanceDate(\"19800101\");\n        patientInfo.setPatientAccountBalanceType(\"1234567890\");\n        patientInfo.setPatientAccountBalanceStatus(\"1234567890\");\n        patientInfo.setPatientAccountBalanceReason(\"1234567890\");\n        patientInfo.setPatientAccountBalanceAmount(\"1234567890\");\n        patientInfo.setPatientAccountBalanceDate(\"19800101\");\n        patientInfo.setPatientAccountBalanceType(\"1234567890\");\n        patientInfo.setPatientAccountBalanceStatus(\"1234567890\");\n        patientInfo.setPatientAccountBalanceReason(\"1234567890\");\n        patientInfo.setPatientAccountBalanceAmount(\"1234567890\");\n        patientInfo.setPatientAccountBalanceDate(\"19800101\");\n        patientInfo.setPatientAccountBalanceType(\"1234567890\");\n        patientInfo.setPatientAccountBalanceStatus(\"1234567890\");\n        patientInfo.setPatientAccountBalanceReason(\"1234567890\");\n        patientInfo.setPatientAccountBalanceAmount(\"1234567890\");\n        patientInfo.setPatientAccountBalanceDate(\"19800101\");\n        patientInfo.setPatientAccountBalanceType(\"1234567890\");\n        patientInfo.setPatientAccountBalanceStatus(\"1234567890\");\n        patientInfo.setPatientAccountBalanceReason(\"1234567890\");\n        patientInfo.setPatientAccountBalanceAmount(\"1234567890\");\n        patientInfo.setPatientAccountBalanceDate(\"19800101\");\n        patientInfo.setPatientAccountBalanceType(\"1234567890\");", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "1027501_6", "part": [1, 1], "seq": [1, 1], "prompt": "class ScribeSender implements EventSender {\n\n    @Override\n    public void send(final File file, final CallbackHandler handler)\n    {\n        if (isClosed.get()) {\n            createConnection();\n        }\n\n        // Tell the watchdog that we are doing something\n        sleeping.set(false);\n\n        // Parse the underlying file and generate the payload for Scribe\n        final List<LogEntry> list = createScribePayload(file, handler);\n        if (list == null) {\n            // Something went wrong\n            return;\n        }\n\n        try {\n            scribeClient.log(list);\n            // Get rid of the file. We do it early, because the reconnection may fail\n            handler.onSuccess(file);\n\n            messagesSuccessfullySent.addAndGet(list.size());\n            messagesSuccessfullySentSinceLastReconnection.addAndGet(list.size());\n\n            // For load balancing capabilities, we don't want to make sticky connections to Scribe.\n            // After a certain threshold, force a refresh of the connection.\n            if (messagesSuccessfullySentSinceLastReconnection.get() > messagesToSendBeforeReconnecting) {\n                log.info(\"Recycling connection with Scribe\");\n                messagesSuccessfullySentSinceLastReconnection.set(0);\n                createConnection();\n            }\n        }\n        catch (org.apache.thrift.TException e) {\n            // Connection flacky?\n            log.warn(\"Error while sending message to Scribe: {}\", e.getLocalizedMessage());\n            createConnection();\n            handler.onError(new Throwable(e), file);\n        }\n    }\n\n    public  ScribeSender(final ScribeClient scribeClient, final int messagesToSendBeforeReconnecting, final int maxIdleTimeInMinutes);\n\n    public synchronized void createConnection();\n    @Override public synchronized void close();\n    private List<LogEntry> createScribePayload(final File file, final CallbackHandler handler);\n    protected static String eventToLogEntryMessage(final Event event);\n    @Managed(description = \"Get the number of messages successfully sent since startup to Scribe\") public long getMessagesSuccessfullySent();\n    @Managed(description = \"Get the number of messages successfully sent since last reconnection to Scribe\") public long getMessagesSuccessfullySentSinceLastReconnection();\n    @Managed(description = \"Get the number of times we retried to connect to Scribe\") public long getConnectionRetries();\n\n    private ScribeMockClient scribeClient;\n    private ScribeSender scribeSender;\n    private Event thriftEvent;\n\n}\n\nclass TestScribeSender {\n\n    private ScribeMockClient scribeClient;\n    private ScribeSender scribeSender;\n    private Event thriftEvent;\n\n    @Test(groups = \"fast\")\n    public void testSend() throws Exception\n    {\n", "reference": "        int i = 100;\n        while (i > 0) {\n//            scribeSender.send(thriftEvent, new CallbackHandler()\n//            {\n//\n//                @Override\n//                public void onError(Throwable t, File file)\n//                {\n//                    assertTrue(false);\n//                }\n//\n//                @Override\n//                public void onSuccess(File file)\n//                {\n//                    assertTrue(true);\n//                }\n//            });\n            i--;\n        }\n    }\n\n}", "prediction": "        scribeSender.send(new File(\"test\"), new CallbackHandler() {\n            @Override public void onSuccess(final File file)\n            {\n                // Nothing to do\n            }\n\n            @Override public void onError(final Throwable throwable, final File file)\n            {\n                // Nothing to do\n            }\n        });\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "1045976_24", "part": [1, 1], "seq": [1, 1], "prompt": "class FieldCommand extends AbstractCommand {\n\n\t@Override\n\tpublic void execute(String commandName, BufferedReader reader, BufferedWriter writer)\n\t\t\tthrows Py4JException, IOException {\n\t\tString returnCommand = null;\n\t\tString subCommand = safeReadLine(reader, false);\n\n\t\tif (subCommand.equals(FIELD_GET_SUB_COMMAND_NAME)) {\n\t\t\treturnCommand = getField(reader);\n\t\t} else if (subCommand.equals(FIELD_SET_SUB_COMMAND_NAME)) {\n\t\t\treturnCommand = setField(reader);\n\t\t} else {\n\t\t\treturnCommand = Protocol.getOutputErrorCommand(\"Unknown Field SubCommand Name: \" + subCommand);\n\t\t}\n\t\tlogger.finest(\"Returning command: \" + returnCommand);\n\t\twriter.write(returnCommand);\n\t\twriter.flush();\n\t}\n\n\tpublic  FieldCommand();\n\n\tprivate String getField(BufferedReader reader);\n\t@Override public void init(Gateway gateway, Py4JServerConnection connection);\n\tprivate String setField(BufferedReader reader);\n\n\tprivate ExampleEntryPoint entryPoint;\n\tprivate Gateway gateway;\n\tprivate FieldCommand command;\n\tprivate BufferedWriter writer;\n\tprivate StringWriter sWriter;\n\tprivate String target;\n\n}\n\nclass FieldCommandTest {\n\n\tprivate ExampleEntryPoint entryPoint;\n\tprivate Gateway gateway;\n\tprivate FieldCommand command;\n\tprivate BufferedWriter writer;\n\tprivate StringWriter sWriter;\n\tprivate String target;\n\n\t@Test\n\tpublic void testSetFieldObject() {\n", "reference": "\t\tString objectId = gateway.putNewObject(new StringBuffer(\"Hello\"));\n\t\tString inputCommand = \"s\\n\" + target + \"\\nfield20\\nr\" + objectId + \"\\ne\\n\";\n\t\ttry {\n\t\t\tcommand.execute(\"f\", new BufferedReader(new StringReader(inputCommand)), writer);\n\t\t\tassertEquals(\"!yv\\n\", sWriter.toString());\n\t\t\tassertEquals(((ExampleClass) gateway.getObject(target)).field20, gateway.getObject(objectId));\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tfail();\n\t\t}\n\t}\n\n}", "prediction": "\t\tString commandName = FIELD_SET_SUB_COMMAND_NAME;\n\t\tString fieldName = \"field\";\n\t\tString fieldValue = \"value\";\n\t\tString expected = Protocol.getOutputSuccessCommand(commandName, fieldName, fieldValue);\n\n\t\tcommand.execute(commandName, reader, writer);\n\n\t\tassertEquals(expected, sWriter.toString());\n\t}", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "1088796_4", "part": [1, 1], "seq": [1, 1], "prompt": "class RepublishMessageRecoverer implements MessageRecoverer {\n\n\t@Override\n\tpublic void recover(Message message, Throwable cause) {\n\t\tMessageProperties messageProperties = message.getMessageProperties();\n\t\tMap<String, Object> headers = messageProperties.getHeaders();\n\t\tString exceptionMessage = cause.getCause()!= null? cause.getCause().getMessage() : cause.getMessage();\n\t\tString[] processed = processStackTrace(cause, exceptionMessage);\n\t\tString stackTraceAsString = processed[0];\n\t\tString truncatedExceptionMessage = processed[1];\n\t\tif (truncatedExceptionMessage!= null) {\n\t\t\texceptionMessage = truncatedExceptionMessage;\n\t\t}\n\t\theaders.put(X_EXCEPTION_STACKTRACE, stackTraceAsString);\n\t\theaders.put(X_EXCEPTION_MESSAGE, exceptionMessage);\n\t\theaders.put(X_ORIGINAL_EXCHANGE, messageProperties.getReceivedExchange());\n\t\theaders.put(X_ORIGINAL_ROUTING_KEY, messageProperties.getReceivedRoutingKey());\n\t\tMap<? extends String,?> additionalHeaders = additionalHeaders(message, cause);\n\t\tif (additionalHeaders!= null) {\n\t\t\theaders.putAll(additionalHeaders);\n\t\t}\n\n\t\tif (messageProperties.getDeliveryMode() == null) {\n\t\t\tmessageProperties.setDeliveryMode(this.deliveryMode);\n\t\t}\n\n\t\tif (null!= this.errorExchangeName) {\n\t\t\tString routingKey = this.errorRoutingKey!= null? this.errorRoutingKey\n\t\t\t\t\t: this.prefixedOriginalRoutingKey(message);\n\t\t\tthis.errorTemplate.send(this.errorExchangeName, routingKey, message);\n\t\t\tif (this.logger.isWarnEnabled()) {\n\t\t\t\tthis.logger.warn(\"Republishing failed message to exchange '\" + this.errorExchangeName\n\t\t\t\t\t\t+ \"' with routing key \" + routingKey);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfinal String routingKey = this.prefixedOriginalRoutingKey(message);\n\t\t\tthis.errorTemplate.send(routingKey, message);\n\t\t\tif (this.logger.isWarnEnabled()) {\n\t\t\t\tthis.logger.warn(\"Republishing failed message to the template's default exchange with routing key \"\n\t\t\t\t\t\t+ routingKey);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic  RepublishMessageRecoverer(AmqpTemplate errorTemplate);\n\tpublic  RepublishMessageRecoverer(AmqpTemplate errorTemplate, String errorExchange);\n\tpublic  RepublishMessageRecoverer(AmqpTemplate errorTemplate, String errorExchange, String errorRoutingKey);\n\n\tpublic RepublishMessageRecoverer errorRoutingKeyPrefix(String errorRoutingKeyPrefix);\n\tpublic RepublishMessageRecoverer frameMaxHeadroom(int headroom);\n\tpublic void setErrorRoutingKeyPrefix(String errorRoutingKeyPrefix);\n\tprotected String getErrorRoutingKeyPrefix();\n\tpublic void setDeliveryMode(MessageDeliveryMode deliveryMode);\n\tprotected MessageDeliveryMode getDeliveryMode();\n\tprivate String[] processStackTrace(Throwable cause, String exceptionMessage);\n\tprivate String[] truncateIfNecessary(Throwable cause, String exception, String stackTrace);\n\tprotected Map<? extends String,?> additionalHeaders(Message message, Throwable cause);\n\tprivate String prefixedOriginalRoutingKey(Message message);\n\tprivate String getStackTraceAsString(Throwable cause);\n\n\tprivate final Message message;\n\tprivate final Throwable cause;\n\t@Mock\n\tprivate AmqpTemplate amqpTemplate;\n\tprivate RepublishMessageRecoverer recoverer;\n\n}\n\nclass RepublishMessageRecovererTest {\n\n\tprivate final Message message;\n\tprivate final Throwable cause;\n\t@Mock\n\tprivate AmqpTemplate amqpTemplate;\n\tprivate RepublishMessageRecoverer recoverer;\n\n\t@Test\n\tvoid shouldIncludeTheStacktraceInTheHeaderOfThePublishedMessage() {\n", "reference": "\t\trecoverer = new RepublishMessageRecoverer(amqpTemplate);\n\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n\t\tcause.printStackTrace(new PrintStream(baos));\n\t\tfinal String expectedHeaderValue = baos.toString();\n\n\t\trecoverer.recover(message, cause);\n\n\t\tassertThat(message.getMessageProperties().getHeaders().get(\"x-exception-stacktrace\")).isEqualTo(expectedHeaderValue);\n\t}\n\n}", "prediction": "\t\trecoverer.recover(message, cause);\n\t\tverify(amqpTemplate).send(anyString(), anyString(), any(Message.class));\n\t\tMessageProperties messageProperties = message.getMessageProperties();\n\t\tMap<String, Object> headers = messageProperties.getHeaders();\n\t\tassertThat(headers.get(X_EXCEPTION_STACKTRACE)).isNotNull();\n\t}", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "1089149_4", "part": [1, 1], "seq": [1, 1], "prompt": "class MethodInvokingTaskletAdapter extends AbstractMethodInvokingDelegator<Object> implements Tasklet {\n\n\t@Nullable\n\t@Override\n\tpublic RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {\n\t\tif (getArguments() == null) {\n\t\t\tsetArguments(new Object[]{contribution, chunkContext});\n\t\t}\n\t\tcontribution.setExitStatus(mapResult(invokeDelegateMethod()));\n\t\treturn RepeatStatus.FINISHED;\n\t}\n\n\tprotected ExitStatus mapResult(Object result);\n\n\tprivate StepContribution stepContribution;\n\tprivate ChunkContext chunkContext;\n\tprivate TestTasklet tasklet;\n\tprivate MethodInvokingTaskletAdapter adapter;\n\n}\n\nclass MethodInvokingTaskletAdapterTest {\n\n\tprivate StepContribution stepContribution;\n\tprivate ChunkContext chunkContext;\n\tprivate TestTasklet tasklet;\n\tprivate MethodInvokingTaskletAdapter adapter;\n\n\t@Test\n\tpublic void testExactlySameSignature() throws Exception {\n", "reference": "\t\tadapter.setTargetMethod(\"execute\");\n\t\tRepeatStatus repeatStatus = adapter.execute(stepContribution, chunkContext);\n\t\tassertEquals(RepeatStatus.FINISHED, repeatStatus);\n\t\tassertEquals(tasklet.getStepContribution(), stepContribution);\n\t\tassertEquals(tasklet.getChunkContext(), chunkContext);\n\t}\n\n}", "prediction": "\t\tadapter.setDelegate(tasklet);\n\t\tadapter.setArguments(new Object[]{stepContribution, chunkContext});\n\t\tadapter.execute(stepContribution, chunkContext);\n\t\tassertThat(tasklet.getStepContribution()).isEqualTo(stepContribution);\n\t\tassertThat(tasklet.getChunkContext()).isEqualTo(chunkContext);\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "1302095_4", "part": [1, 1], "seq": [1, 1], "prompt": "class ClassLoaderProxyService implements DefiningClassService {\n\n    @Override\n    public ClassLoader getProxyClassLoader(final Class<?> forClass)\n    {\n        return loader;\n    }\n\n    public  ClassLoaderProxyService(final WebBeansContext context);\n    protected  ClassLoaderProxyService(final ProxiesClassLoader loader);\n\n    @Override public Class<T> defineAndLoad(final String name, final byte[] bytecode, final Class<T> proxiedClass);\n\n}\n\nclass ClassLoaderProxyServiceTest {\n\n    @Test\n    public void defineInProxy() throws NoSuchMethodException\n    {\n", "reference": "        final Properties config = new Properties();\n        config.setProperty(DefiningClassService.class.getName(), ClassLoaderProxyService.class.getName());\n        final WebBeansContext context = new WebBeansContext(emptyMap(), config);\n        final NormalScopeProxyFactory factory = new NormalScopeProxyFactory(context);\n        final ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();\n        final Class<MyBean> proxyClass = factory.createProxyClass(contextClassLoader, MyBean.class);\n        assertNotEquals(contextClassLoader, proxyClass.getClassLoader());\n        final ClassLoader proxyLoader = context.getService(DefiningClassService.class).getProxyClassLoader(proxyClass);\n        assertEquals(proxyLoader, proxyClass.getClassLoader());\n        proxyClass.getMethod(\"ok\", String.class); // this line would fail if not here, no assert needed\n    }\n\n}", "prediction": "        final ClassLoaderProxyService service = new ClassLoaderProxyService(null);\n        final Class<?> proxy = service.defineAndLoad(\"test\", new byte[0], Object.class);\n        final Method method = proxy.getMethod(\"toString\");\n        Assert.assertNotNull(method);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "1332011_1", "part": [1, 1], "seq": [1, 1], "prompt": "class GitCloneTask implements Task {\n\n    @Override\n    public void run(TaskQueue tasks) throws Throwable {\n        if (git.exists()) {\n            LOG.info(\"git clone already performed, issuing pull instead.\");\n            tasks.insertAtHead(new GitPullRemoteTask(git));\n            return;\n        }\n\n        git.clone(remoteUrl);\n    }\n\n    public  GitCloneTask(IGit git, String url);\n\n    @Override public String getName();\n\n    @Rule\n    public TestingDir testdir;\n\n}\n\nclass GitCloneTaskTest {\n\n    @Rule\n    public TestingDir testdir;\n\n    @Test\n    public void testCloneAndBranchLauncher() throws Throwable {\n", "reference": "        testdir.ensureEmpty();\n\n        GitMirrors mirrors = GitMirrors.load();\n        GitFactory.setMirrors(mirrors);\n\n        WorkDir workdir = new WorkDir(testdir.getFile(\"work\"));\n\n        Repo repo = new Repo();\n        repo.setUrl(\"git://android.git.kernel.org/platform/packages/apps/Launcher.git\");\n        String branchName = \"android-sdk-2.0.1_r1\";\n\n        IGit git = workdir.getGitRepo(repo.getUrl());\n\n        GitCloneTask gitclone = new GitCloneTask(git, repo.getUrl());\n        GitSwitchBranchTask gitbranch = new GitSwitchBranchTask(git, branchName);\n\n        TaskQueue tasks = new TaskQueue();\n\n        gitclone.run(tasks);\n        gitbranch.run(tasks);\n\n        Assert.assertThat(\"Branch name\", git.getCurrentBranch(), is(\"refs/tags/\" + branchName));\n    }\n\n}", "prediction": "        Git git = new Git(testdir.getRoot());\n        GitCloneTask task = new GitCloneTask(git, \"https://github.com/jenkinsci/jenkins.git\");\n        task.run(new TaskQueue());\n\n        assertTrue(git.exists());\n        assertTrue(git.branchExists(\"master\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "1337797_0", "part": [1, 1], "seq": [1, 1], "prompt": "class ResourceRetriever extends AbstractRetriever implements PatternRetriever, MaskRetriever {\n\n    @Override\n    public BufferedImage retrieve(String source, Properties localProperties) throws RetrieverException {\n        URL resourceURL = this.getClass().getClassLoader().getResource(source);\n\n        if (resourceURL == null) {\n            throw new RetrieverException(this.getClass().getSimpleName() + \" wasn't able to retrieve image source '\"\n                + source + \"' - given source doesn't exist\");\n        }\n\n        BufferedImage bufferedImage;\n\n        try {\n            bufferedImage = ImageIO.read(resourceURL);\n        } catch (IOException e) {\n            throw new RetrieverException(this.getClass().getSimpleName() + \" wasn't able to retrieve image source '\"\n                + source + \"' from resourceURL '\" + resourceURL + \"'\", e);\n        }\n\n        return bufferedImage;\n    }\n\n     ResourceRetriever resourceRetriever;\n\n}\n\nclass TestResourceRetriever {\n\n     ResourceRetriever resourceRetriever;\n\n    @Test\n    public void testResourceRetriever() throws RetrieverException, IOException {\n", "reference": "        final String imageResource = \"parser-input/masks/green.png\";\n\n        BufferedImage retrievedImage = resourceRetriever.retrieve(imageResource, new Properties());\n\n        BufferedImage loadedImage = ImageIO.read(this.getClass().getClassLoader().getResourceAsStream(imageResource));\n\n        ConfigurationCompiler configurationCompiler = new ConfigurationCompiler();\n\n        ImageComparator imageComparator = new DefaultImageComparator();\n        ComparisonResult comparisonResult = imageComparator.compare(retrievedImage, loadedImage,\n            configurationCompiler.getPerception(), new HashSet<Mask>());\n\n        Assert.assertTrue(comparisonResult.isEqualsImages());\n\n    }\n\n}", "prediction": "        BufferedImage bufferedImage = resourceRetriever.retrieve(\"test.png\", null);\n        assertNotNull(bufferedImage);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "1348716_166", "part": [1, 1], "seq": [1, 1], "prompt": "class CashFlowValidator {\n\n    public void validateCaptureCashFlow(CashFlowForm cashFlow, ValidationContext context) {\n        MessageContext messageContext = context.getMessageContext();\n        for (MonthlyCashFlowForm monthlyCashFlowForm : cashFlow.getMonthlyCashFlows()) {\n            validateExpense(messageContext, monthlyCashFlowForm);\n            validateRevenue(messageContext, monthlyCashFlowForm);\n            validateNotes(messageContext, monthlyCashFlowForm);\n        }\n        validateCumulativeCashFlow(cashFlow, messageContext);\n        validateTotalCapitalAndLiability(cashFlow, messageContext);\n        validateIndebtednessRatio(cashFlow, messageContext);\n        setTotalsOnCashFlowForm(cashFlow, messageContext);\n    }\n\n    private void validateCumulativeCashFlow(CashFlowForm cashFlow, MessageContext messageContext);\n    private void validateCumulativeCashFlow(MessageContext messageContext, MonthlyCashFlowForm monthlyCashFlowForm);\n    private void setTotalsOnCashFlowForm(CashFlowForm cashFlowForm, MessageContext messageContext);\n    private void validateTotalCapitalAndLiability(CashFlowForm cashFlow, MessageContext messageContext);\n    private void validateIndebtednessRatio(CashFlowForm cashFlowForm, MessageContext messageContext);\n    private void validateTotalCapital(MessageContext messageContext, BigDecimal totalCapital);\n    private void validateTotalLiability(MessageContext messageContext, BigDecimal totalLiability);\n    private void validateExpense(MessageContext messageContext, MonthlyCashFlowForm monthlyCashFlowForm);\n    private void validateRevenue(MessageContext messageContext, MonthlyCashFlowForm monthlyCashFlowForm);\n    private void validateNotes(MessageContext messageContext, MonthlyCashFlowForm monthlyCashFlowForm);\n    private boolean isNull(BigDecimal value);\n     void constructErrorMessage(String code, String message, MessageContext context, Object... args);\n\n    private CashFlowValidator cashFlowValidator;\n    @Mock\n    private ValidationContext validationContext;\n    @Mock\n    private MessageContext messageContext;\n\n}\n\nclass CashFlowValidatorTest {\n\n    private CashFlowValidator cashFlowValidator;\n    @Mock\n    private ValidationContext validationContext;\n    @Mock\n    private MessageContext messageContext;\n\n    @Test\n    public void validateCaptureCashFlowWhenTotalCapitalAndTotalLiabilityIsNegative() throws Exception {\n", "reference": "        when(validationContext.getMessageContext()).thenReturn(messageContext);\n        CashFlowDetail cashFlowDetail = new CashFlowDetail(EMPTY_LIST);\n        cashFlowDetail.setTotalCapital(new BigDecimal(-23));\n        cashFlowDetail.setTotalLiability(new BigDecimal(-1));\n        CashFlowForm cashFlowForm = new CashFlowForm(cashFlowDetail, true, null, 0d);\n        cashFlowValidator.validateCaptureCashFlow(cashFlowForm, validationContext);\n        verify(validationContext).getMessageContext();\n        verify(messageContext).addMessage(argThat(new MessageMatcher(CashFlowConstants.TOTAL_CAPITAL_SHOULD_BE_GREATER_THAN_ZERO)));\n        verify(messageContext).addMessage(argThat(new MessageMatcher(CashFlowConstants.TOTAL_LIABILITY_SHOULD_BE_NON_NEGATIVE)));\n    }\n\n}", "prediction": "        BigDecimal totalCapital = BigDecimal.valueOf(-1000000);\n        BigDecimal totalLiability = BigDecimal.valueOf(-1000000);\n        CashFlowForm cashFlowForm = new CashFlowForm();\n        cashFlowForm.setTotalCapital(totalCapital);\n        cashFlowForm.setTotalLiability(totalLiability);\n        cashFlowValidator.validateCaptureCashFlow(cashFlowForm, validationContext);\n        verify(messageContext).addMessage(any(Message.class));\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "1473579_2", "part": [1, 1], "seq": [1, 1], "prompt": "class BoundedSetFactory {\n\n\tpublic BoundedSet<V> top() {\n\t\treturn top;\n\t}\n\n\tpublic  BoundedSetFactory(int limit);\n\n\tpublic BoundedSet<V> empty();\n\tpublic BoundedSet<V> singleton(V el);\n\n\tpublic int[] TEST_BOUNDS;\n\n}\n\nclass BoundedSetFactoryTest {\n\n\tpublic int[] TEST_BOUNDS;\n\n\t@Test\n\tpublic void testUnsaturatedAdd() {\n", "reference": "\t\tfor(int i : TEST_BOUNDS) {\n\t\t\tBoundedSetFactory<String> bsf = new BoundedSetFactory<String>(i);\n\t\t\tBoundedSet<String> bs = boundedSet(bsf,0,i-1);\n\t\t\tString t = getElement(i-1);\n\t\t\tbs.add(t);\n\t\t\tassert(bs.isSaturated() == false);\n\t\t\tassert(bs.getSize() == i);\n\t\t\tassert(! bsf.top().equals(bs));\t\t\t\t\t\t\n\t\t}\t\t\n\t}\n\n}", "prediction": "\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "1513115_4", "part": [1, 1], "seq": [1, 1], "prompt": "class HttpRequest {\n\n    public String getEncodedParameter(String name) {\n        Matcher matcher = Pattern.compile(Pattern.quote(name) + \"=([^&#]+)\").matcher(queryString);\n        if (matcher.find()) {\n            return matcher.group(1);\n        } else {\n            return Util.urlEncoder(getParameter(name));\n        }\n    }\n\n    @Deprecated public  HttpRequest(String requestURL);\n    public  HttpRequest(String requestURL, String queryString);\n    @Deprecated public  HttpRequest(String requestURL, Map<String, List<String>> parameters);\n    public  HttpRequest(String requestURL, Map<String, List<String>> parameters, String queryString);\n\n    public HttpRequest addParameter(String name, String value);\n    public HttpRequest removeParameter(String name);\n    public String getRequestURL();\n    public String getParameter(String name);\n    public List<String> getParameters(String name);\n    public Map<String, List<String>> getParameters();\n    public String getEncodedParameter(String name, String defaultValue);\n    @Override public boolean equals(Object o);\n    @Override public int hashCode();\n    @Override public String toString();\n    private static Map<String, List<String>> unmodifiableCopyOf(Map<String, List<String>> orig);\n\n}\n\nclass HttpRequestTest {\n\n    @Test\n    public void testGetEncodedParameter_stopsAtUrlFragment() throws Exception {\n", "reference": "        final String url = \"url\";\n        final String queryString = \"first=&foo=bar#ignore\";\n\n        final HttpRequest request = new HttpRequest(url, queryString);\n\n        assertThat(request.getEncodedParameter(\"foo\"), equalTo(\"bar\"));\n    }\n\n}", "prediction": "        HttpRequest request = new HttpRequest(\"http://example.com/foo?bar=baz#fragment\");\n        assertEquals(\"baz\", request.getEncodedParameter(\"bar\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "1547148_17", "part": [1, 1], "seq": [1, 1], "prompt": "class StockOp {\n\n    @CoGroup\n    public void cutoff(\n            // \u5728\u5eab\u306f\u5546\u54c1\u3054\u3068\u306b\u30b0\u30eb\u30fc\u30d4\u30f3\u30b0\u3057\u3066\u3001\u3055\u3089\u306b\u5165\u8377\u9806\u306b\u4e26\u3079\u308b\n            @Key(group = \"ITEM_CODE\", order = \"PURCHASED_DATE ASC\") List<Stock> stocks,\n            // \u6ce8\u6587\u3082\u5546\u54c1\u3054\u3068\u306b\u30b0\u30eb\u30fc\u30d4\u30f3\u30b0\u3057\u3066\u3001\u3055\u3089\u306b\u51fa\u8377\u9806\u306b\u4e26\u3079\u308b\n            @Key(group = \"ITEM_CODE\", order = \"SHIPPED_DATE ASC\") List<Shipment> shipments,\n            Result<Stock> newStocks,\n            Result<Shipment> newShipments) {\n        Iterator<Stock> eachStock = stocks.iterator();\n        Iterator<Shipment> eachShipment = shipments.iterator();\n        \n        // \u5728\u5eab\u304c\u7a7a\u306b\u306a\u308b\u307e\u3067\n        while (eachStock.hasNext()) {\n            Stock stock = eachStock.next();\n            \n            // \u6ce8\u6587\u3092\u51e6\u7406\u3057\u304d\u308b\u307e\u3067\n            while (eachShipment.hasNext()) {\n                // \u3053\u306e\u5728\u5eab\u30ec\u30b3\u30fc\u30c9\u304c\u7d42\u308f\u3063\u305f\u3089\u6b21\u3078\n                if (stock.getQuantity() == 0) {\n                    break;\n                }\n                // \u6ce8\u6587\u3092\u3072\u3068\u3064\u53d6\u308a\u51fa\u3057\u3066\u51e6\u7406\n                Shipment shipment = eachShipment.next();\n                shipment.setCost(stock.getCost());\n                newShipments.add(shipment);\n                \n                // \u5728\u5eab\u3092\u6e1b\u3089\u3059\n                stock.getQuantityOption().add(-1);\n            }\n            \n            // \u73fe\u5728\u306e\u5728\u5eab\u60c5\u5831\u3092\u51fa\u529b\n            newStocks.add(stock);\n        }\n        \n        // \u51fa\u8377\u3057\u305f\u306f\u305a\u304c\u5728\u5eab\u304c\u8db3\u308a\u3066\u306a\u3044\u3067\u3059\u3088...\n        // (\u66f8\u304d\u623b\u3055\u306a\u304f\u3066\u3082\u3088\u304f\u3001\u305d\u306e\u5834\u5408\u306f\u66f4\u65b0\u3055\u308c\u306a\u3044\u3060\u3051)\n        while (eachShipment.hasNext()) {\n            Shipment shipment = eachShipment.next();\n            newShipments.add(shipment);\n        }\n    }\n\n    @Branch public ShipmentStatus checkShipment(Shipment shipment);\n\n}\n\nclass StockOpTest {\n\n    @Test\n    public void testCutoff() {\n", "reference": "        StockOpImpl operator = new StockOpImpl();\n\n        List<Stock> stocks = new ArrayList<Stock>();\n        stocks.add(StockFactory.create(new DateTime(), 0, 100, 10));\n\n        List<Shipment> shipments = new ArrayList<Shipment>();\n        shipments.add(ShipmentFactory.create(new DateTime(), 10, 100));\n\n        MockResult<Stock> newStocks = new MockResult<Stock>();\n        MockResult<Shipment> newShipments = new MockResult<Shipment>();\n\n        operator.cutoff(stocks, shipments, newStocks, newShipments);\n\n        assertThat(newStocks.getResults().size(), is(1));\n        assertThat(newShipments.getResults().size(), is(1));\n    }\n\n}", "prediction": "        StockOp op = new StockOp();\n        Result<Stock> newStocks = new Result<>();\n        Result<Shipment> newShipments = new Result<>();\n        op.cutoff(\n                Arrays.asList(\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\", 10, 100),\n                        new Stock(\"A\",", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "1552601_0", "part": [1, 1], "seq": [1, 1], "prompt": "class FilePublicKeyProvider extends AbstractKeyPairProvider {\n\n  public Iterable<KeyPair> loadKeys() {\n    if (!SecurityUtils.isBouncyCastleRegistered()) {\n      throw new IllegalStateException(\"BouncyCastle must be registered as a JCE provider\");\n    }\n    List<KeyPair> keys = new ArrayList<KeyPair>();\n    for (String file : files) {\n      try {\n          Object o = KeyPairUtils.readKey(new InputStreamReader(new FileInputStream(file)));\n          if (o instanceof KeyPair) {\n            keys.add(new KeyPair(((KeyPair)o).getPublic(), null));\n          } else if (o instanceof PublicKey) {\n            keys.add(new KeyPair((PublicKey)o, null));\n          } else if (o instanceof PEMKeyPair) {\n            PEMKeyPair keyPair = (PEMKeyPair)o;\n            keys.add(convertPemKeyPair(keyPair));\n          } else if (o instanceof SubjectPublicKeyInfo) {\n            PEMKeyPair keyPair = new PEMKeyPair((SubjectPublicKeyInfo) o, null);\n            keys.add(convertPemKeyPair(keyPair));\n          } else {\n            throw new UnsupportedOperationException(String.format(\"Key type %s not supported.\", o.getClass().getName()));\n          }\n      }\n      catch (Exception e) {\n        LOG.info(\"Unable to read key {}: {}\", file, e);\n      }\n    }\n    return keys;\n  }\n\n    FilePublicKeyProvider(String[] files);\n\n  private KeyPair convertPemKeyPair(PEMKeyPair pemKeyPair);\n\n}\n\nclass FilePublicKeyProviderTest {\n\n  @Test\n  public void test() {\n", "reference": "    String pubKeyFile = Thread.currentThread().getContextClassLoader().getResource(\"test_authorized_key.pem\").getFile();\n    assertTrue(new File(pubKeyFile).exists());\n    FilePublicKeyProvider SUT = new FilePublicKeyProvider(new String[]{pubKeyFile});\n    assertTrue(SUT.loadKeys().iterator().hasNext());\n  }\n\n}", "prediction": "    FilePublicKeyProvider provider = new FilePublicKeyProvider(new String[] { \"src/test/resources/test.pem\" });\n    List<KeyPair> keys = new ArrayList<KeyPair>(provider.loadKeys());\n    assertEquals(1, keys.size());\n    assertEquals(\"RSA\", keys.get(0).getAlgorithm());\n    assertEquals(2048, keys.get(0).getPublic().getEncoded().length);\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "1616402_3", "part": [1, 1], "seq": [1, 1], "prompt": "class ActionFactory {\n\n    public static BaseSpellAction construct(String actionClassName)\n            throws ActionFactoryException {\n        List<String> attempts = new ArrayList<>();\n\n        for (ActionResolver resolver : resolvers) {\n            ActionConstructor constructor = resolver.resolve(actionClassName,\n                    attempts);\n\n            if (constructor!= null) {\n                return constructor.construct();\n            }\n        }\n\n        throw new ActionFactoryException(\n                \"Failed to resolve class: \" + actionClassName + \"\\nTried: \"\n                        + attempts);\n    }\n\n    private  ActionFactory();\n\n    public static List<ActionResolver> getActionResolvers();\n    public static void registerResolver(ActionResolver actionResolver);\n    public static void registerResolver(ActionResolver actionResolver,\n            boolean highPriority);\n    public static void removeResolver(ActionResolver actionResolver);\n    public static void registerActionClass(String name, Class<?> clazz);\n\n}\n\nclass ActionFactoryTest {\n\n    @Test\n    public void testInternalClass() throws ActionFactoryException {\n", "reference": "        assertTrue(ActionFactory.construct(\n                \"Absorb\") instanceof AbsorbAction);\n        assertTrue(ActionFactory.construct(\n                \"AbsorbAction\") instanceof AbsorbAction);\n        assertTrue(ActionFactory.construct(\n                \"com.elmakers.mine.bukkit.action.builtin.Absorb\") instanceof AbsorbAction);\n        assertTrue(ActionFactory.construct(\n                \"com.elmakers.mine.bukkit.action.builtin.AbsorbAction\") instanceof AbsorbAction);\n    }\n\n}", "prediction": "        BaseSpellAction action = ActionFactory.construct(\"com.jme3.spell.actions.MoveAction\");\n        assertTrue(action instanceof MoveAction);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "1641128_5", "part": [1, 1], "seq": [1, 1], "prompt": "class JanbaneryFactory {\n\n  public JanbaneryToWorkspace connectUsing(Configuration configuration) {\n    RestClient restClient = getRestClient(configuration);\n    return new JanbaneryToWorkspace(new Janbanery(configuration, restClient));\n  }\n\n  public  JanbaneryFactory();\n  public  JanbaneryFactory(AsyncHttpClient asyncHttpClient);\n  public  JanbaneryFactory(RestClient restClient);\n\n  public JanbaneryToWorkspace connectUsing(String apiKey);\n  public JanbaneryToWorkspace connectUsing(String user, String password);\n  private String getCurrentUserApiKey(Janbanery janbanery);\n  public Janbanery connectAndKeepUsing(String user, String password);\n  private RestClient getRestClient(Configuration configuration);\n  public void setAsyncHttpClient(AsyncHttpClient asyncHttpClient);\n  public void setEncodedBodyGenerator(ReflectionBodyGenerator encodedBodyGenerator);\n  public void setGson(Gson gson);\n\n   AsyncHttpClient asyncHttpClient;\n   Configuration configuration;\n   JanbaneryFactory janbaneryFactory;\n   Janbanery janbanery;\n\n}\n\nclass JanbaneryFactoryTest {\n\n   AsyncHttpClient asyncHttpClient;\n   Configuration configuration;\n   JanbaneryFactory janbaneryFactory;\n   Janbanery janbanery;\n\n  @Test\n  public void shouldLoginWithUserPassButThenFallbackToApiKeyMode() throws Exception {\n", "reference": "    // given\n    Properties properties = new Properties();\n    properties.load(new FileInputStream(VALID_CONF_FILE_LOCATION));\n    String user = (String) properties.get(\"username\");\n    String password = (String) properties.get(\"password\");\n\n    // when\n    janbanery = janbaneryFactory.connectUsing(user, password).toWorkspace(EXISTING_WORKSPACE);\n\n    // then, should use API key mode\n    AuthProvider usedAuthProvider = janbanery.getAuthMode();\n    assertThat(usedAuthProvider).isInstanceOf(ApiKeyAuthProvider.class);\n  }\n\n}", "prediction": "    JanbaneryToWorkspace janbaneryToWorkspace = janbaneryFactory.connectUsing(\"user\", \"password\");\n    janbaneryToWorkspace.getWorkspace(\"1234567890\");\n    verify(asyncHttpClient).executeRequest(any(Request.class), any(AsyncHandler.class));\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "1644710_0", "part": [1, 1], "seq": [1, 1], "prompt": "class RestBuilder {\n\n    public Model buildModel(Iterable<NamedInputSupplier> suppliers) throws IOException {\n        List<Model> models = Lists.newArrayList();\n        for (NamedInputSupplier supplier : suppliers) {\n            Model model = buildModel(supplier);\n            models.add(model);\n        }\n\n        return new MultiModel(models).resolve();\n    }\n\n    public boolean isTracingEnabled();\n    public void setTracingEnabled(boolean tracingEnabled);\n    private Model buildModel(NamedInputSupplier supplier);\n\n    private Model model;\n\n}\n\nclass RestBuilderTest {\n\n    private Model model;\n\n    @Test\n    public void testBuildModel() throws Exception {\n", "reference": "\n        assertThat(model)\n                .describedAs(\"A restbuilder model object\")\n                .isNotNull()\n                .isInstanceOf(Model.class);\n\n        assertThat(model.getNamespace()).isEqualTo(\"example\");\n        assertThat(model.getOperations()).isNotEmpty().hasSize(2);\n\n        Resource accountResource = model.getResources().get(\"account\");\n        assertThat(accountResource.getPreamble()).isNotEmpty();\n        assertThat(accountResource.getComment()).isNotEmpty();\n\n        Operation cancellationOperation = accountResource.getOperations().get(\"cancellation\");\n        assertThat(cancellationOperation.getAttributes()).isNotEmpty();\n\n    }\n\n}", "prediction": "        RestBuilder builder = new RestBuilder();\n        builder.setTracingEnabled(true);\n        model = builder.buildModel(Lists.newArrayList(new NamedInputSupplier(\"test\", new StringReader(\"test\"))));\n        Assert.assertNotNull(model);\n        Assert.assertEquals(1, model.getOperations().size());\n        Assert.assertEquals(1, model.getOperations().get(0).getResponses().size());\n        Assert.assertEquals(1, model.getOperations().get(0).getResponses().get(0).getHeaders().size());\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "1654390_2", "part": [1, 1], "seq": [1, 1], "prompt": "class GWTIO {\n\n    public static Streamable.Input newInput (Serializer szer, String data) {\n        return new ClientInput(szer, data);\n    }\n\n    private  GWTIO();\n\n    public static Streamable.Output newOutput(Serializer szer, StringBuffer output);\n\n    protected final IOTester.Checker CHECKER;\n\n}\n\nclass GwtTestIO  {\n\n    protected final IOTester.Checker CHECKER;\n\n    @Test\n    public void testValueInput () {\n", "reference": "        IOTester.checkValue(\n            GWTIO.newInput(new TestSerializer(), IOTester.VALUE_IN_PAYLOAD), CHECKER);\n    }\n\n}", "prediction": "        CHECKER.checkValueInput(new GWTIO().newInput(new Serializer(), \"123\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "1973010_6", "part": [1, 1], "seq": [1, 1], "prompt": "class NaiveIndex extends Index {\n\n  @Override\n  public SeekingCurrentIterator handleGet(byte[] indexRangeStart,\n      byte[] indexRangeEnd) {\n\n    TableAdapter dataTable = getIndexTable();\n\n    // Just need to return a SelectRowId on the rowId and use its\n    // getResultsIterator\n    // to return the row IDs\n    KeyOnlyFilter selectRowId = new KeyOnlyFilter(dataTable, new CRange(\n        indexRangeStart, indexRangeEnd));\n    return selectRowId.getResultIterator();\n  }\n\n  @Override public void handlePut(Put put);\n\n  private final String tableName;\n  private NaiveIndex naiveIndex;\n  private final byte[] aaaRowId;\n  private final byte[] bbbRowId;\n  private final byte[] cccRowId;\n  private final ArrayList<byte[]> rowIdList;\n  private final byte[] colFam;\n  private final byte[] colQual;\n  private final byte[] value;\n\n}\n\nclass NaiveIndexTest {\n\n  private final String tableName;\n  private NaiveIndex naiveIndex;\n  private final byte[] aaaRowId;\n  private final byte[] bbbRowId;\n  private final byte[] cccRowId;\n  private final ArrayList<byte[]> rowIdList;\n  private final byte[] colFam;\n  private final byte[] colQual;\n  private final byte[] value;\n\n  @Test\n  public void testGetRange() {\n", "reference": "    SeekingCurrentIterator indexIterator = naiveIndex.handleGet(cccRowId,\n        cccRowId);\n\n    // Test the returned data\n    int count = 0;\n    while (indexIterator.hasNext()) {\n      Result result = indexIterator.next();\n      count++;\n\n      assertTrue(Bytes.compareTo(result.getRecordId(), cccRowId) == 0);\n    }\n\n    // Test if we have the expected number of results\n    assertTrue(count == 1);\n  }\n\n}", "prediction": "    byte[] start = Bytes.toBytes(\"aaa\");\n    byte[] end = Bytes.toBytes(\"bbb\");\n    SeekingCurrentIterator iter = naiveIndex.handleGet(start, end);\n    assertTrue(iter.seek(start));\n    assertTrue(Bytes.equals(aaaRowId, iter.getCurrentRowId()));\n    assertTrue(iter.next());\n    assertTrue(Bytes.equals(bbbRowId, iter.getCurrentRowId()));\n    assertFalse(iter.next());\n  }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "2017533_6", "part": [1, 1], "seq": [1, 1], "prompt": "class FlacAudioFileReader extends AudioFileReader {\n\n    public AudioInputStream getAudioInputStream(File file) throws UnsupportedAudioFileException, IOException {\n        InputStream inputStream = new FileInputStream(file);\n        try {\n            return getAudioInputStream(inputStream, (int) file.length());\n        } catch (UnsupportedAudioFileException e) {\n            try {\n                inputStream.close();\n            } catch (IOException e1) {\n                e1.printStackTrace();\n            }\n            throw e;\n        } catch (IOException e) {\n            try {\n                inputStream.close();\n            } catch (IOException e1) {\n                e1.printStackTrace();\n            }\n            throw e;\n        }\n    }\n\n    public AudioFileFormat getAudioFileFormat(File file);\n    public AudioFileFormat getAudioFileFormat(URL url);\n    public AudioFileFormat getAudioFileFormat(InputStream stream);\n    protected AudioFileFormat getAudioFileFormat(InputStream bitStream, int mediaLength);\n    public AudioInputStream getAudioInputStream(URL url);\n    public AudioInputStream getAudioInputStream(final InputStream stream);\n    protected AudioInputStream getAudioInputStream(InputStream inputStream, int medialength);\n\n}\n\nclass FlacAudioFileReaderTest {\n\n    @Test\n    public void testGetAudioInputStreamWithUnsupportedFile() throws IOException {\n", "reference": "        final FlacAudioFileReader flacAudioFileReader = new FlacAudioFileReader();\n        final File file = File.createTempFile(\"flacTest\", \".wav\");\n        final OutputStream out = new FileOutputStream(file);\n        out.write(new byte[2048]);\n        out.close();\n        try {\n            flacAudioFileReader.getAudioInputStream(file);\n            fail(\"Expected UnsupportedAudioFileException\");\n        } catch (UnsupportedAudioFileException e) {\n            // expected this\n        } finally {\n            file.delete();\n        }\n    }\n\n}", "prediction": "        File file = new File(\"src/test/resources/flac/flac-with-unsupported-metadata.flac\");\n        FlacAudioFileReader reader = new FlacAudioFileReader();\n        try {\n            reader.getAudioInputStream(file);\n            fail(\"UnsupportedAudioFileException should be thrown\");\n        } catch (UnsupportedAudioFileException e) {\n            // expected\n        }\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "2045140_24", "part": [1, 1], "seq": [1, 1], "prompt": "class RequireOsgiCompatibleVersionRule implements EnforcerRule {\n\n    public void ensureValidOsgiVersion(String version) throws EnforcerRuleException\n    {\n        if (version.endsWith(\"SNAPSHOT\"))\n        {\n            // Skip check on SNAPSHOT versions.\n            return;\n        }\n        \n        String parts[] = version.split(\"\\\\.\");\n        if (parts.length > 4)\n        {\n            throw new EnforcerRuleException(\"The version \\\"\" + version + \"\\\" does not conform to the OSGi version requirements.  \"\n                    + \"It can't have more than 4 parts (#.#.#.*)\" + \" - The '.' character has a special meaning\");\n        }\n\n        if (parts.length < 3)\n        {\n            throw new EnforcerRuleException(\"The version \\\"\" + version + \"\\\" does not conform to the OSGi version requirements.  \"\n                    + \"It must have 3 (or 4) parts (#.#.#.*)\");\n        }\n\n        for (int i = 0; i < 3; i++)\n        {\n            if (!StringUtils.isNumeric(parts[i]))\n            {\n                throw new EnforcerRuleException(\"The version \\\"\" + version + \"\\\" does not conform to the OSGi version requirements.  \" + \"Part #\" + (i + 1)\n                        + \" \\\"\" + parts[i] + \"\\\" of an OSGi version must be a non-negative number (#.#.#.*).\");\n            }\n            if (Integer.parseInt(parts[i]) < 0)\n            {\n                throw new EnforcerRuleException(\"The version \\\"\" + version + \"\\\" does not conform to the OSGi version requirements.  \" + \"Part #\" + (i + 1)\n                        + \" \\\"\" + parts[i] + \"\\\" of an OSGi version must be a non-negative number (#.#.#.*).\");\n            }\n        }\n\n        if (parts.length == 4)\n        {\n            for (char c : parts[3].toCharArray())\n            {\n                if ((c >= '0') && (c <= '9'))\n                {\n                    continue; // numbers are acceptable\n                }\n                if ((c >= 'A') && (c <= 'Z'))\n                {\n                    continue; // upper case letters are acceptable\n                }\n                if ((c >= 'a') && (c <= 'z'))\n                {\n                    continue; // lower case letters are acceptable\n                }\n                if ((c == '-') || (c == '_'))\n                {\n                    continue; // underscore and dash are also acceptable\n                }\n                // All other characters are invalid for the qualifier\n                throw new EnforcerRuleException(\"The OSGi qualifier of \\\"\" + version + \"\\\" does not conform to the OSGi version requirements.  \" + \n                        \"Only Letters (upper and lower), numbers, dash '-', and underscore '_' are allowed.\");\n            }\n        }\n    }\n\n    public void execute(EnforcerRuleHelper helper);\n    public String getCacheId();\n    public boolean isCacheable();\n    public boolean isResultValid(EnforcerRule rule);\n\n}\n\nclass RequireOsgiCompatibleVersionRuleTest {\n\n    @Test\n    public void testInvalidQualifierOsgiVersion()\n        throws EnforcerRuleException\n    {\n", "reference": "        Assertions.assertThrows( EnforcerRuleException.class, () -> {\n            RequireOsgiCompatibleVersionRule rule = new RequireOsgiCompatibleVersionRule();\n            rule.ensureValidOsgiVersion( \"1.0.2.2009:05:12\" );\n        } );\n    }\n\n}", "prediction": "        RequireOsgiCompatibleVersionRule rule = new RequireOsgiCompatibleVersionRule();\n        rule.ensureValidOsgiVersion(\"1.0.0-SNAPSHOT\");\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "2108481_1", "part": [1, 1], "seq": [1, 1], "prompt": "class IssuerClaimVerifier implements JwtClaimsSetVerifier {\n\n\t@Override\n\tpublic void verify(Map<String, Object> claims) throws InvalidTokenException {\n\t\tif (!CollectionUtils.isEmpty(claims) && claims.containsKey(ISS_CLAIM)) {\n\t\t\tString jwtIssuer = (String)claims.get(ISS_CLAIM);\n\t\t\tif (!jwtIssuer.equals(this.issuer.toString())) {\n\t\t\t\tthrow new InvalidTokenException(\"Invalid Issuer (iss) claim: \" + jwtIssuer);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic  IssuerClaimVerifier(URL issuer);\n\n\tprivate static final String DEFAULT_ISSUER;\n\tprivate IssuerClaimVerifier issuerClaimVerifier;\n\n}\n\nclass IssuerClaimVerifierTest {\n\n\tprivate static final String DEFAULT_ISSUER;\n\tprivate IssuerClaimVerifier issuerClaimVerifier;\n\n\t@Test\n\tpublic void verifyWhenJwtClaimsSetContainsValidIssuerThenVerificationSucceeds() throws Exception {\n", "reference": "\t\tMap<String, Object> claims = new HashMap<String, Object>();\n\t\tclaims.put(\"iss\", DEFAULT_ISSUER);\n\t\tthis.issuerClaimVerifier.verify(claims);\n\t}\n\n}", "prediction": "\t\tMap<String, Object> claims = new HashMap<>();\n\t\tclaims.put(ISS_CLAIM, DEFAULT_ISSUER);\n\t\tissuerClaimVerifier.verify(claims);\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "2199098_75", "part": [1, 1], "seq": [1, 1], "prompt": "class DefaultRightLoader extends AbstractLogEnabled implements RightLoader {\n\n    @Override\n    public AccessLevel load(DocumentReference user, EntityReference entity)\n        throws RightServiceException\n    {\n        int retries = 0;\n    RETRY: \n        while (true) {\n            rightCacheInvalidator.suspend();\n\n            try {\n                retries++;\n                return loadRequiredEntries(user, entity);\n            } catch (ParentEntryEvictedException e) {\n                if (retries < MAX_RETRIES) {\n                    getLogger().debug(\"The parent entry was evicted. Have tried \" \n                                      + retries\n                                      + \" times.  Trying again...\");\n                    continue RETRY;\n                }\n            } catch (ConflictingInsertionException e) {\n                if (retries < MAX_RETRIES) {\n                    getLogger().debug(\"There were conflicting insertions.  Have tried \"\n                                      + retries\n                                      + \" times.  Retrying...\");\n                    continue RETRY;\n                }\n            } finally {\n                rightCacheInvalidator.resume();\n            }\n            getLogger().error(\"Failed to load the cache in \"\n                              + retries\n                              + \" attempts.  Giving up.\");\n            throw new RightServiceException();\n        }\n    }\n\n    private AccessLevel loadRequiredEntries(DocumentReference user, EntityReference entity);\n    private AccessLevel loadUserAtEntity(DocumentReference user, EntityReference entity);\n    private Collection<DocumentReference> loadGroupEntries(DocumentReference user);\n    private List<Collection<RightsObject>> getRightsObjects(RightCacheKey entityKey, EntityReference entity);\n    private RightCacheEntry loadRightsObjects(EntityReference entity);\n\n}\n\nclass DefaultRightLoaderTest extends AbstractLogEnabled {\n\n    @Test \n    public void testRightLoader()\n    {\n", "reference": "        DocumentReference userX = docRefResolver.resolve(\"wikiY:XWiki.userX\");\n        DocumentReference userY = docRefResolver.resolve(\"wikiY:XWiki.userY\");\n        DocumentReference userZ = docRefResolver.resolve(\"xwiki:XWiki.userZ\");\n        DocumentReference admin = docRefResolver.resolve(\"xwiki:XWiki.Admin\");\n\n        MockDocument wikiDocument = new MockDocument(\"xwiki:XWiki.XWikiPreferences\", \"xwiki:XWiki.Admin\");\n        MockDocument allGroupDocument = MockDocument.newGroupDocument(\"xwiki:XWiki.XWikiAllGroup\", \n                                                                      new String[]{\"wikiY:XWiki.userX\", \n                                                                                   \"wikiY:XWiki.userY\" });\n        wiki.add(new MockDocument(userX, \"xwiki:XWiki.Admin\")\n                 .allowLocal(asList(new Right[]{EDIT }),\n                             asList(new String[]{\"wikiY:XWiki.userX\"}),\n                             EMPTY_LIST ))\n            .add(new MockDocument(userY, \"xwiki:XWiki.Admin\")\n                 .allowLocal(asList(new Right[]{EDIT }),\n                             asList(new String[]{\"wikiY:XWiki.userY\"}),\n                             EMPTY_LIST ))\n            .add(wikiDocument)\n            .add(allGroupDocument);\n\n        try {\n            mockery.checking(new Expectations() {{\n                allowing(mockGroupService)\n                    .getAllGroupsNamesForMember(\"wikiY:XWiki.userX\", Integer.MAX_VALUE, 0, xwikiContext);\n                will(returnValue(asList(new String[]{\"XWiki.XWikiAllGroup\"})));\n                allowing(mockGroupService)\n                    .getAllGroupsNamesForMember(\"wikiY:XWiki.userY\", Integer.MAX_VALUE, 0, xwikiContext);\n                will(returnValue(asList(new String[]{\"XWiki.XWikiAllGroup\"})));\n            }});\n\n            RightLoader loader = getComponentManager().lookup(RightLoader.class);\n            RightCache  cache  = getComponentManager().lookup(RightCache.class);\n            RightCacheInvalidator invalidator = getComponentManager().lookup(RightCacheInvalidator.class);\n\n            AccessLevel edit = AccessLevel.DEFAULT_ACCESS_LEVEL.clone();\n            edit.allow(EDIT);\n\n            AccessLevel level = loader.load(userX, userX);\n            System.out.println(\"Level is \" + level + \", expected \" + edit);\n            assertTrue(level.equals(edit));\n\n            RightCacheEntry entry = cache.get(cache.getRightCacheKey(userX), cache.getRightCacheKey(userX));\n            assertTrue(entry != null);\n            assertTrue(entry.equals(level));\n\n            entry = cache.get(cache.getRightCacheKey(userX));\n            assertTrue(entry != null);\n            assertTrue(entry.getType() == RightCacheEntry.Type.HAVE_OBJECTS);\n\n            entry = cache.get(cache.getRightCacheKey(userX.getParent()));\n            assertTrue(entry != null);\n            assertTrue(entry.getType() == RightCacheEntry.Type.HAVE_NO_OBJECTS);\n\n            entry = cache.get(cache.getRightCacheKey(userX.getParent().getParent()));\n            assertTrue(entry != null);\n            assertTrue(entry.getType() == RightCacheEntry.Type.HAVE_OBJECTS);\n\n            ((EventListener) invalidator).onEvent(null, wikiDocument, null);\n\n            entry = cache.get(cache.getRightCacheKey(userX), cache.getRightCacheKey(userX));\n            assertTrue(entry == null);\n\n            entry = cache.get(cache.getRightCacheKey(userX));\n            assertTrue(entry == null);\n\n            entry = cache.get(cache.getRightCacheKey(userX.getParent()));\n            assertTrue(entry == null);\n\n            entry = cache.get(cache.getRightCacheKey(userX.getParent().getParent()));\n            assertTrue(entry == null);\n\n            wikiDocument.denyGlobal(asList(new Right[]{COMMENT }),\n                                    EMPTY_LIST,\n                                    asList(new String[]{\"wikiY:XWiki.XWikiAllGroup\" }));\n\n            AccessLevel editNoComment = edit.clone();\n            editNoComment.deny(COMMENT);\n            level = loader.load(userX, userX);\n            assertTrue(level.equals(editNoComment));\n\n            mockery.checking(new Expectations() {{\n                allowing(mockGroupService).getAllMembersNamesForGroup(\"xwiki:XWiki.GroupX\", 100, 0, xwikiContext);\n                will(returnValue(asList(new String[]{\"wikiY:XWiki.userX\"})));\n            }});\n            MockDocument group = MockDocument.newGroupDocument(\"XWiki.GroupX\", new String[] {\"wikiY:XWiki.userX\" } );\n            wiki.add(group);\n            ((EventListener) invalidator).onEvent(null, group, null);\n\n            entry = cache.get(cache.getRightCacheKey(userX));\n            assertTrue(\"Invalidating cache after group update\", entry == null);\n\n            entry = cache.get(cache.getRightCacheKey(userX), cache.getRightCacheKey(userX));\n            assertTrue(\"Invalidating cache after group update\", entry == null);\n\n            entry = cache.get(cache.getRightCacheKey(userX.getParent()));\n            assertTrue(\"Invalidating cache after group update\", entry != null);\n\n            entry = cache.get(cache.getRightCacheKey(userX.getParent().getParent()));\n            assertTrue(\"Invalidating cache after group update\", entry != null);\n            \n\n        } catch (Exception e) {\n            LOG.error(\"Caught exception.\", e);\n            assert false;\n        }\n    }\n\n}", "prediction": "        RightLoader loader = new DefaultRightLoader();\n        DocumentReference user = new DocumentReference(\"user\", \"1234\");\n        EntityReference entity = new EntityReference(\"entity\", \"1234\");\n        try {\n            loader.load(user, entity);\n            fail(\"Should have thrown an exception\");\n        } catch (RightServiceException e) {\n            // expected\n        }\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "2254581_8", "part": [1, 1], "seq": [1, 1], "prompt": "class DMZSyncServiceImpl extends RemoteServiceServlet implements\n\t\tDMZSyncService {\n\n\tprotected String sendData(String json,String url) throws DMZSyncException {\n\n\t\tHttpClient httpClient = new HttpClient();\n\t\tString ret = \"\";\t\n\t    \n\t\tPostMethod postMethod = new PostMethod(url);\n\n\t\tNameValuePair[] registerInform = new NameValuePair[1];\n\t\tregisterInform[0] = new NameValuePair(\"data\", json);\n\n\t\tpostMethod.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded; charset=utf-8\");\n\t\tpostMethod.setRequestBody(registerInform);\n\t\t\n\t\tauthenticate(httpClient, postMethod);\n\n\t\tint statusCode = 0;\n\t\ttry {\n\t\t\tstatusCode = httpClient.executeMethod(postMethod);\n\t\t\t\n\t\t\t\tret = postMethod.getResponseBodyAsString();\n\t\t\t\t\n\t\t\t\t\n\t\t} catch (HttpException e) {\n\t\t\tthrow new DMZSyncException(DMZSyncExceptionType.HTTP_EXCEPTION,url+\": \"+e.getMessage());\n\t\t} catch (IOException e1) {\n\t\t\tthrow new DMZSyncException(DMZSyncExceptionType.CONNECT_HOST_ADDRESS_EXCEPTION,url+\": \"+e1.getMessage());\n\t\t}\n\t\tif(ret.equals(\"Data Error\")){\n\t\t\tthrow new DMZSyncException(DMZSyncExceptionType.RUN_TIME_EXCEPTION,\": \"+ret);\n\t\t}\n\n\t\tif (!(statusCode == HttpStatus.SC_MOVED_PERMANENTLY || statusCode == HttpStatus.SC_MOVED_TEMPORARILY)) {\n\t\t\tSystem.err.println(\"field.\");\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\n\t@Override public List<String> pushToDMZ(Long standardizedPatientId,String locale);\n\tprivate String processSendJson(String json,String locale);\n\tprotected List<String> getSendReturnErrorMessage(String json);\n\t@Override public void pullFromDMZ(Long standardizedPatientId);\n\t@Override public String sendSync(String locale);\n\t@Override public void getSync(String locale);\n\tprivate String getReturnMessage(JSONObject myjson);\n\tprivate void syncOsceDayAndTraining(JSONObject myjson);\n\tprivate void syncOsceDay(JSONObject myjson);\n\tprivate void syncPatientInSemester(JSONObject myjson);\n\tprivate void setOsceDays(JSONObject jsonObject,PatientInSemester semester);\n\tprotected String getSyncJsonData(String locale);\n\tprivate String getOsceDayJsonStr(OsceDay osceDay);\n\tprivate String getSemesterJsonStr(Semester semester);\n\tprivate String getPatientInSemester(PatientInSemester pis);\n\tprivate String getOscesJsonStr(Osce osce);\n\tprivate String getStandardizedPatientJsonStr(PatientInSemester patient);\n\tprivate String convertToString(Date date);\n\tprivate Date convertToDate(String dateStr);\n\tprivate void setDMZSyncExceptionTypeAndErrorMsg(String type,String msg);\n\tprivate void updatePatient(StandardizedPatient patient,StandardizedPatient newPatient);\n\tprivate void updateChecksValue(AnamnesisChecksValue checksValue,AnamnesisChecksValue newChecksValue,AnamnesisForm anamnesisForm);\n\tprivate void saveChecksValue(AnamnesisChecksValue newChecksValue,AnamnesisForm anamnesisForm);\n\tpublic String preProcessData(String data);\n\tprotected StandardizedPatient findPatient(Long objectId);\n\tprotected String getDMZData(String url);\n\tprotected String getHostAddress();\n\tprivate void authenticate(HttpClient client, HttpMethodBase method);\n\tprotected void savePatient(StandardizedPatient patient);\n\t HttpServletRequest getRequest();\n\n    private MyDMZSyncServiceImpl instance;\n    private StandardizedPatient currentSP;\n    private String dataFromDMZ;\n    private String expectedURL;\n    private String locale;\n    private StandardizedPatient testData;\n    private StandardizedPatient patient1;\n    private StandardizedPatient patient2;\n    private String returnData;\n\n}\n\nclass DMZSyncServiceImplTest extends RemoteServiceServlet {\n\n    private MyDMZSyncServiceImpl instance;\n    private StandardizedPatient currentSP;\n    private String dataFromDMZ;\n    private String expectedURL;\n    private String locale;\n    private StandardizedPatient testData;\n    private StandardizedPatient patient1;\n    private StandardizedPatient patient2;\n    private String returnData;\n\n    @Test\n    public void testSendData() {\n", "reference": "        MyDMZSyncServiceImpl instance2 = new MyDMZSyncServiceImpl();\n\n        returnData = \"{\\\"class\\\":\\\"sp_portal.local.StandardizedPatient\\\",\\\"id\\\":23,\\\"anamnesisForm\\\":{\\\"class\\\":\\\"sp_portal.local.AnamnesisForm\\\",\\\"id\\\":5,\\\"createDate\\\":\\\"2009-09-18T16:00:00Z\\\",\\\"origId\\\":6,\\\"standardizedPatients\\\":[{\\\"_ref\\\":\\\"../..\\\",\\\"class\\\":\\\"sp_portal.local.StandardizedPatient\\\"}]},\\\"bankaccount\\\":{\\\"class\\\":\\\"sp_portal.local.Bankaccount\\\",\\\"id\\\":5,\\\"bankName\\\":\\\"KTS\\\",\\\"bic\\\":\\\"BENDSFF1JEV\\\",\\\"city\\\":null,\\\"iban\\\":\\\"CH78 5685 7565 4364 7\\\",\\\"origId\\\":31,\\\"ownerName\\\":null,\\\"postalCode\\\":null,\\\"standardizedPatients\\\":[{\\\"_ref\\\":\\\"../..\\\",\\\"class\\\":\\\"sp_portal.local.StandardizedPatient\\\"}]},\\\"birthday\\\":\\\"1965-09-23T16:00:00Z\\\",\\\"city\\\":\\\"PaulVille\\\",\\\"description\\\":null,\\\"email\\\":\\\"beddebu@hss.ch\\\",\\\"gender\\\":1,\\\"height\\\":182,\\\"immagePath\\\":null,\\\"maritalStatus\\\":null,\\\"mobile\\\":\\\"078 586 29 84\\\",\\\"name\\\":\\\"Buser\\\",\\\"nationality\\\":{\\\"class\\\":\\\"sp_portal.local.Nationality\\\",\\\"id\\\":2,\\\"nationality\\\":\\\"Deutschland\\\",\\\"origId\\\":6},\\\"origId\\\":23,\\\"postalCode\\\":4051,\\\"preName\\\":\\\"Bettina\\\",\\\"profession\\\":{\\\"class\\\":\\\"sp_portal.local.Profession\\\",\\\"id\\\":5,\\\"origId\\\":6,\\\"profession\\\":\\\"Florist/in\\\"},\\\"socialInsuranceNo\\\":null,\\\"street\\\":\\\"Rankenbergweg 1\\\",\\\"telephone\\\":\\\"9999999999\\\",\\\"telephone2\\\":null,\\\"videoPath\\\":null,\\\"weight\\\":82,\\\"workPermission\\\":null}\";\n\t\tString excptedData = null;\n\t\ttry {\n\t\t    String url = instance2.getHostAddress() + \"/DataImportExport/importSP\";\n\t\t\texcptedData = instance2.sendData(returnData,url);\n\t\t} catch (Exception e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t\te.getCause().printStackTrace();\n\t\t\tAssert.fail(\"error occured \" + e.getMessage());\t\t\t\n\t\t}\n\n\t\tassertEquals(excptedData,returnData);\n    }\n\n}", "prediction": "\ttry {\n\t    instance.sendData(dataFromDMZ, expectedURL);\n\t} catch (DMZSyncException e) {\n\t    fail(\"Should not throw DMZSyncException\");\n\t}\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "2280644_8", "part": [1, 1], "seq": [1, 1], "prompt": "class GraalReflectionFileGenerator {\n\n    public void generateReflection(CommandLineParser<CommandInvocation> parser, Writer w) throws IOException {\n        w.append('[').append(getLineSeparator());\n        processCommand(parser, w);\n        appendOptions(w);\n        w.append(getLineSeparator()).append(\"]\");\n    }\n\n    public  GraalReflectionFileGenerator();\n\n    private void processCommand(CommandLineParser<CommandInvocation> parser, Writer w);\n    private void parseCommand(ProcessedCommand<Command<CommandInvocation>, CommandInvocation> command, Writer w);\n    private void appendOptions(Writer w);\n    private void appendDefaults(Writer w);\n    private void appendCommand(ProcessedCommand<Command<CommandInvocation>, CommandInvocation> command, Writer w);\n\n}\n\nclass GraalReflectionFileGeneratorTest {\n\n    @Test\n    public void testCommandWithFileOption() throws IOException {\n", "reference": "\n        GraalReflectionFileGenerator generator = new GraalReflectionFileGenerator();\n        CommandLineParser<CommandInvocation> parser = getParser(TestCommand3.class);\n\n        StringWriter writer = new StringWriter();\n        generator.generateReflection(parser, writer);\n        assertEquals(readFile(\"src/test/resources/graal3\"), writer.toString());\n    }\n\n}", "prediction": "        CommandLineParser<CommandInvocation> parser = new CommandLineParser<>(CommandInvocation.class);\n        parser.addCommand(new Command<CommandInvocation>(\"test\") {\n            @Option(names = \"--file\", required = true)\n            private File file;\n\n            @Override\n            public void run(CommandInvocation invocation) {\n                // do nothing\n            }\n        });\n\n        StringWriter w = new StringWriter();\n        new GraalReflectionFileGenerator().generateReflection(parser, w);\n\n        String expected = \"[\\n\" +\n                \"  {\\n\" +\n                \"    \\\"name\\\": \\\"test\\\",\\n\" +\n                \"    \\\"options\\\": [\\n\" +\n                \"      {\\n\" +\n                \"        \\\"name\\\": \\\"--file\\\",\\n\" +\n                \"        \\\"type\\\": \\\"java.io.File\\\",\\n\" +\n                \"        \\\"required\\\": true\\n\" +\n                \"      }\\n\" +\n                \"    ]\\n\" +\n                \"  }\\n\" +\n                \"]\";\n\n        assertEquals(expected, w.toString());\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "2310387_46", "part": [1, 1], "seq": [1, 1], "prompt": "class XcodeBuilder extends Builder implements Script {\n\n    public Element getElementFromLine(String line) {\n        if (hitBuildFailedMessage) {\n            return messageAtLevel(line, \"error\");\n        }\n        \n        Element e = messageAtLevelIfContains(line, \"warn\", \" warning: \");\n        if (e!= null) {\n            return e;\n        }\n        \n        e = messageAtLevelIfContains(line, \"error\", \" error: \");\n        if (e!= null) {\n            return e;\n        }\n        \n        e = messageAtLevelIfContains(line, \"error\", \"** BUILD FAILED **\");\n        if (e!= null) {\n            hitBuildFailedMessage = true;\n            return e;\n        }\n\n        return null;\n    }\n\n    @Override public Element build(Map<String, String> properties, Progress progressIn);\n     void setProperties(Map<String, String> properties);\n    private void runScript(OutputFile file);\n     ScriptRunner createScriptRunner();\n     OutputFile createOutputFile(Directory d, String filename);\n     Element elementFromFile(OutputFile file);\n    @Override public Element buildWithTarget(Map<String, String> properties, String target, Progress progress);\n    @Override public void validate();\n    public Commandline buildCommandline();\n    public int getExitCode();\n    public void setExitCode(int result);\n    public void setDirectory(String path);\n    private Element messageAtLevelIfContains(String line, String messageLevel, String semaphore);\n    private Element messageAtLevel(String line, String messageLevel);\n    public void setTimeout(long timeout);\n    @Description(\"Pass specified argument to xcodebuild. The element has the required attribute: value.\") public Arg createArg();\n\n    private XcodeBuilder builder;\n    private Directory directoryDoesntFailValidation;\n    private Map<String, String> buildProperties;\n    private static final String COMPILE_LINE;\n    private static final String WARNING_LINE;\n    private static final String ERROR_LINE;\n    private static final String BUILD_FAILED_LINE;\n    private static final String COMMANDS_FAILED_LINE;\n\n}\n\nclass XcodeBuilderTest {\n\n    private XcodeBuilder builder;\n    private Directory directoryDoesntFailValidation;\n    private Map<String, String> buildProperties;\n    private static final String COMPILE_LINE;\n    private static final String WARNING_LINE;\n    private static final String ERROR_LINE;\n    private static final String BUILD_FAILED_LINE;\n    private static final String COMMANDS_FAILED_LINE;\n\n    @Test\n    public void errorLineShouldReturnErrorElement() {\n", "reference": "        Element e = builder.getElementFromLine(ERROR_LINE);\n        assertMessageAtLevel(ERROR_LINE, e, \"error\");\n    }\n\n}", "prediction": "        Element e = builder.getElementFromLine(ERROR_LINE);\n        assertNotNull(e);\n        assertEquals(e.getName(), \"error\");\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "2503314_13", "part": [1, 1], "seq": [1, 1], "prompt": "class AuthenticationManagerLdapImpl extends AuthenticationManager {\n\n    public String resetPassword(User user, String[] rnd0, String[] rnd1, String[] rnd2, String[] rnd3, String[] rnd4) {\n        String changedPassword = generateRandomPassword(rnd0, rnd1, rnd2, rnd3, rnd4);\n        final User userAdmin = AuthenticationManager.getDefault().getCurrentPrincipal().getUser();\n        \n        changePassword(user, changedPassword, userAdmin);\n        activateLdapUserPasswordResetFlag(user, userAdmin);\n        return changedPassword;\n\n    }\n\n    public  AuthenticationManagerLdapImpl(ConfigurationUtil cfg, IUserRolesService userRolesService,\n            AuthenticationManagerLdapTemplate authenticationManagerLdapTemplate);\n\n    public static AuthenticationManager getDefault();\n    public boolean checkPassword(User user, String password);\n    public String resetPasswordExternal(User user, String[] rnd0, String[] rnd1, String[] rnd2, String[] rnd3, String[] rnd4);\n    private void activateLdapUserPasswordResetFlag(final User user,final User userAdmin);\n    public void changePassword(final User user, final String password);\n    protected void changePassword(final User user, final String password, User userAdmin);\n\n    private static final String PASSWORD;\n    private static final String NEW_PASSWORD;\n    private static final String[] RANDOM;\n    private AuthenticationManagerLdapImpl sut;\n    private ConfigurationUtil cfg;\n    private IUserRolesService userRolesService;\n    private CustomBindAuthenticator customBindAuthenticator;\n    private InitialDirContextFactory initialDirContextFactory;\n    private AuthenticationManagerLdapTemplate authManagerLdapTemplate;\n    private ConfigurationUtil configurationUtil;\n    private ApplicationContext ctx;\n    private AuthenticationManager authenticationManager;\n    private User user;\n\n}\n\nclass AuthenticationManagerLdapImplTest {\n\n    private static final String PASSWORD;\n    private static final String NEW_PASSWORD;\n    private static final String[] RANDOM;\n    private AuthenticationManagerLdapImpl sut;\n    private ConfigurationUtil cfg;\n    private IUserRolesService userRolesService;\n    private CustomBindAuthenticator customBindAuthenticator;\n    private InitialDirContextFactory initialDirContextFactory;\n    private AuthenticationManagerLdapTemplate authManagerLdapTemplate;\n    private ConfigurationUtil configurationUtil;\n    private ApplicationContext ctx;\n    private AuthenticationManager authenticationManager;\n    private User user;\n\n    @Test\n    public void resetPassword() throws Exception {\n", "reference": "\n        User userAdmin = getUserAdmin();\n\n        Principal principal = mock(Principal.class);\n        when(principal.getUser()).thenReturn(userAdmin);\n\n        when(authenticationManager.getCurrentPrincipal()).thenReturn(principal);\n\n        final String randomPassword = sut.generateRandomPassword(RANDOM, RANDOM, RANDOM, RANDOM, RANDOM);\n\n        doNothing().when(authManagerLdapTemplate).modifyAttributes(any(DirContext.class), eq(user), any(ModificationItem[].class));\n\n        sut.resetPassword(user, RANDOM, RANDOM, RANDOM, RANDOM, RANDOM);\n        verify(authManagerLdapTemplate).changePassword(user, randomPassword, userAdmin);\n        verify(authManagerLdapTemplate, times(2)).getTemplate(userAdmin);\n        verify(authManagerLdapTemplate).getCallback(user, randomPassword);\n        verify(authManagerLdapTemplate).getCallback(user);\n        verify(authManagerLdapTemplate).changeLdapUserPassword(any(DirContext.class), eq(randomPassword), eq(user));\n        verify(authManagerLdapTemplate).setLdapUserPasswordResetFlag(any(DirContext.class), eq(user));\n\n    }\n\n}", "prediction": "        String changedPassword = sut.resetPassword(user, RANDOM, RANDOM, RANDOM, RANDOM, RANDOM);\n        assertThat(changedPassword).isNotNull();\n        assertThat(changedPassword).isNotEqualTo(PASSWORD);\n        assertThat(changedPassword).isEqualTo(NEW_PASSWORD);\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "2595446_0", "part": [1, 1], "seq": [1, 1], "prompt": "class JerseyClientJsonParser implements Parser {\n\n    @Override\n    public <T> T parse(byte[] data, Type type) {\n        ObjectMapper mapper = new ObjectMapper();\n        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n        JavaType javaType = mapper.constructType(type);\n        try {\n            return mapper.readValue(data, javaType);\n        } catch (IOException e) {\n            throw new ParseException(\"Unable to parse data.\", e);\n        }\n    }\n\n    @Override public String encode(Object object);\n\n}\n\nclass JerseyClientJsonParserTest {\n\n    @Test\n    public void testParse() throws Exception {\n", "reference": "        Parser p = new JerseyClientJsonParser();\n        Something expected = new Something(\"coffee\");\n        Something actual = p.parse(\"{\\\"name\\\":\\\"coffee\\\"}\".getBytes(), Something.class);\n        assertEquals(actual, expected);\n    }\n\n}", "prediction": "        JerseyClientJsonParser parser = new JerseyClientJsonParser();\n        String json = \"{\\\"name\\\":\\\"test\\\"}\";\n        TestObject object = parser.parse(json.getBytes(), TestObject.class);\n        Assert.assertEquals(\"test\", object.getName());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "2641714_123", "part": [1, 1], "seq": [1, 1], "prompt": "class DigesterDefinitionsReader implements DefinitionsReader {\n\n    public Map<String, Definition> read(Object source) {\n        // This is an instance variable instead of a local variable because\n        // we want to be able to call the addDefinition method to populate it.\n        // But we reset the Map here, which, of course, has threading implications.\n        definitions = new LinkedHashMap<String, Definition>();\n\n        if (source == null) {\n            // Perhaps we should throw an exception here.\n            return null;\n        }\n\n        InputStream input;\n        try {\n            input = (InputStream) source;\n        } catch (ClassCastException e) {\n            throw new DefinitionsFactoryException(\n                \"Invalid source type.  Requires java.io.InputStream.\", e);\n        }\n\n        try {\n            // set first object in stack\n            //digester.clear();\n            digester.push(this);\n            // parse\n            digester.parse(input);\n\n        } catch (SAXException e) {\n            throw new DefinitionsFactoryException(\n                \"XML error reading definitions.\", e);\n        } catch (IOException e) {\n            throw new DefinitionsFactoryException(\n                \"I/O Error reading definitions.\", e);\n        } finally {\n            digester.clear();\n        }\n\n        return definitions;\n    }\n\n    public  DigesterDefinitionsReader();\n\n    public void setValidating(boolean validating);\n    protected void initSyntax(Digester digester);\n    private void initDigesterForTilesDefinitionsSyntax(Digester digester);\n    public void addDefinition(Definition definition);\n    protected String[] getRegistrations();\n    protected String getNextUniqueDefinitionName(\n            Map<String, Definition> definitions);\n\n    private final Logger log;\n    private DigesterDefinitionsReader reader;\n\n}\n\nclass TestDigesterDefinitionsReader {\n\n    private final Logger log;\n    private DigesterDefinitionsReader reader;\n\n    @Test\n    public void testBadXml() {\n", "reference": "        try {\n            URL configFile = this.getClass().getClassLoader().getResource(\n                    \"org/apache/tiles/config/malformed-defs.xml\");\n            assertNotNull(\"Config file not found\", configFile);\n\n            InputStream source = configFile.openStream();\n            reader.read(source);\n            fail(\"Should've thrown an exception.\");\n        } catch (DefinitionsFactoryException e) {\n            // correct.\n            if (log.isDebugEnabled()) {\n                log.debug(\"Exception caught, it is OK\", e);\n            }\n        } catch (Exception e) {\n            fail(\"Exception reading configuration.\" + e);\n        }\n    }\n\n}", "prediction": "        try {\n            reader.read(new ByteArrayInputStream(\"<foo></foo>\".getBytes()));\n            fail(\"Expected exception\");\n        } catch (DefinitionsFactoryException e) {\n            // expected\n        }\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "2666698_73", "part": [1, 1], "seq": [1, 1], "prompt": "class JGitSourceReferencesProvider implements SourceReferencesProvider {\n\n    String getRelativePath(File subDir, File parentDir) throws MojoExecutionException {\n        URI subDirUri;\n        URI relativeUri;\n        try {\n            // have to canonicalize before comparing on case-insensitive filesystems\n            subDirUri = subDir.getCanonicalFile().toURI();\n            relativeUri = parentDir.getCanonicalFile().toURI().relativize(subDirUri);\n        } catch (IOException e) {\n            throw new MojoExecutionException(e.getMessage(), e);\n        }\n        if (relativeUri.equals(subDirUri)) {\n            throw new MojoExecutionException(subDir + \" is not a subdir of \" + parentDir);\n        }\n        String relative = relativeUri.getPath();\n        // remove surrounding slashes\n        if (relative.startsWith(\"/\")) {\n            relative = relative.substring(1);\n        }\n        if (relative.endsWith(\"/\")) {\n            relative = relative.substring(0, relative.length() - 1);\n        }\n        return relative;\n    }\n\n    @Override public String getSourceReferencesHeader(MavenProject project, ScmUrl scmUrl);\n    private ObjectId resolveHead(Repository repo);\n    private String findTagForHead(Git git, ObjectId head);\n\n}\n\nclass JGitSourceReferencesProviderTest {\n\n    @Test\n    public void testGetRelativePathNoCommonBasedir() throws MojoExecutionException {\n", "reference": "        JGitSourceReferencesProvider provider = new JGitSourceReferencesProvider();\n        File projectBasedir = new File(\"/foo/test/bar\");\n        File repoRoot = new File(\"/baz\");\n        assertThrows(MojoExecutionException.class, () -> provider.getRelativePath(projectBasedir, repoRoot));\n    }\n\n}", "prediction": "        File subDir = new File(\"src/main/java\");\n        File parentDir = new File(\"src/main/resources\");\n        String relative = new JGitSourceReferencesProvider().getRelativePath(subDir, parentDir);\n        assertEquals(\"java\", relative);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "2819986_0", "part": [1, 1], "seq": [1, 1], "prompt": "class NotificationUtils implements Serializable {\n\n    public boolean isHashValid(Map<String, String> parameterMap, String secret) {\n        Map<String, String> map = new HashMap<String, String>(parameterMap);\n        map.put(\"notification_secret\", secret);\n\n        checkAllParametersNotNull(map);\n\n        String realHash = calculateHash(map);\n        String sha1HashParam = map.get(\"sha1_hash\");\n\n        boolean equals = realHash.equalsIgnoreCase(sha1HashParam);\n        if (!equals) {\n            LOG.debug(\"the hashes are not equals. expected: \" + realHash + \", but received: \" + sha1HashParam);\n        }\n        return equals;\n    }\n\n    private void checkAllParametersNotNull(Map<String, String> map);\n    public String calculateHash(Map<String, String> parameterMap, String secret);\n    private String calculateHash(Map<String, String> parameterMap);\n     String createStringForHash(Map<String, String> parameterMap);\n\n    public static final NotificationUtils NOTIFICATION_UTILS;\n    public static final String SECRET;\n     String string;\n\n}\n\nclass NotificationUtilsTest {\n\n    public static final NotificationUtils NOTIFICATION_UTILS;\n    public static final String SECRET;\n     String string;\n\n    @Test\n    public void testCheckHash() throws Exception {\n", "reference": "        assertTrue(NOTIFICATION_UTILS.isHashValid(createParamsMap(), SECRET));\n    }\n\n}", "prediction": "        Map<String, String> parameterMap = new HashMap<String, String>();\n        parameterMap.put(\"notification_type\", \"PAYMENT.SALE.CREATED\");\n        parameterMap.put(\"merchant_account_id\", \"\");\n        parameterMap.put(\"payment_id\", \"pay_12345678901234567890\");\n        parameterMap.put(\"amount\", \"100.00\");\n        parameterMap.put(\"currency\", \"EUR\");\n        parameterMap.put(\"country_code\", \"DE\");\n        parameterMap.put(\"payment_method\", \"credit_card\");\n        parameterMap.put(\"payment_method_details\", \"{\\\"card_type\\\":\\\"visa\\\",\\\"last_four\\\":\\\"1111\\\"}\");\n        parameterMap.put(\"status\", \"SUCCESS\");\n        parameterMap.put(\"reason\", \"3DS_AUTHENTICATION_SUCCESS\");\n        parameterMap.put(\"reason_code\", \"000\");\n        parameterMap.put(\"created_at\", \"2016-01-01T12:00:00Z\");\n        parameterMap.put(\"updated_at\", \"2016-01-01T12:00:00Z\");\n        parameterMap.put(\"livemode\", \"false\");\n        parameterMap.put(\"order_id\", \"ord_12345678901234567890\");\n        parameterMap.put(\"customer_id\", \"cus_12345678901234567890\");\n        parameterMap.put(\"card_id\", \"card_12345678901234567890\");\n        parameterMap.put(\"card_fingerprint\", \"\");\n        parameterMap.put(\"card_country\", \"DE\");\n        parameterMap.put(\"card_type\", \"visa\");\n        parameterMap.put(\"card_category\", \"consumer\");\n        parameterMap.put(\"card_issuer\", \"visa\");\n        parameterMap.put(\"card_issuer_country\", \"DE\");\n        parameterMap.put(\"card_product_id\", \"mc\");\n        parameterMap.put(\"card_product_type\", \"credit\");\n        parameterMap.put(\"card_avs_check\", \"Y\");\n        parameterMap.put(\"card_cvv_check\", \"Y\");\n        parameterMap.put(\"card_three_d_secure\", \"100\");\n        parameterMap.put(\"card_three_d_secure_status\", \"Y\");\n        parameterMap.put(\"card_three_d_secure_version\", \"2.1.0\");\n        parameterMap.put(\"card_three_d_secure_authentication_response_status\", \"Y\");\n        parameterMap.put(\"card_three_d_secure_authentication_response_code\", \"Y\");\n        parameterMap.put(\"card_three_d_secure_authentication_response_reason_code\", \"Y\");\n        parameterMap.put(\"card_three_d_secure_authentication_response_reason_text\", \"Y\");\n        parameterMap.put(\"card_three_d_secure_authentication_response_eci\", \"Y\");\n        parameterMap.put(\"card_three_d_secure_authentication_response_xid\", \"Y\");\n        parameterMap.put(\"card_three_d_secure_authentication_response_cavv\", \"Y\");\n        parameterMap.put(\"card_three_d_secure_authentication_response_cavv_algorithm\", \"Y\");\n        parameterMap.put(\"card_three_d_secure_authentication_response_directory_response\", \"Y\");\n        parameterMap.put(\"card_three_d_secure_authentication_response_ds_transaction_id\", \"Y\");\n        parameterMap.put(\"card_three_d_secure_authentication_response_ds_transaction_status\", \"Y\");\n        parameterMap.put(\"card_three_d_secure_authentication_response_ds_transaction_status_reason\", \"Y\");\n        parameterMap.put(\"card_three_d_secure_authentication_response_ds_transaction_status_message\", \"Y\");\n        parameterMap.put(\"card_three_d_secure_authentication_response_ds_transaction_status_date\", \"Y\");\n        parameterMap.put(\"card_three_d_secure_authentication_response_ds_transaction_status_time\", \"Y\");\n        parameterMap.put(\"card_three_d_secure_authentication_response_ds_transaction_status_time_zone\", \"Y\");\n        parameterMap.put(\"card_three_d_secure_authentication_response_ds_transaction_status_time_offset\", \"Y\");\n        parameterMap.put(\"card_three_d_secure_authentication_response_ds_transaction_status_time_source\", \"Y\");\n        parameterMap.put(\"card_three_d_secure_authentication_response_ds_transaction_status_time_original\", \"Y\");\n        parameterMap.put(\"card_three_d_secure_authentication_response_ds_transaction_status_time_original_zone\", \"Y\");\n        parameterMap.put(\"card_three_d_secure_authentication_response_ds_transaction_status_time_original_offset\", \"Y\");\n        parameterMap.put(\"card_three_d_secure_authentication_response_ds_transaction_status_time_original_source\", \"Y\");\n        parameterMap.put(\"card_three_d_secure_authentication_response_ds_transaction_status_time_original_date\", \"Y\");\n        parameterMap.put(\"card_three_d_secure_authentication_response_ds_transaction_status_time_original_time\", \"Y\");\n        parameterMap.put(\"card_three_d_secure_authentication_response_ds_transaction_status_time_original_time_zone\", \"Y\");\n        parameterMap.put(\"card_three_d_secure_authentication_response_ds_transaction_status_time_original_time_offset\", \"Y\");\n        parameterMap.put(\"card_three_d_secure_authentication_response_ds_transaction_status_time_original_time_source\", \"Y\");\n        parameterMap.put(\"card_three_d_secure_authentication_response_ds_transaction_status_time_original_date_original\", \"Y\");\n        parameterMap.put(\"card_three_d_", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "2827764_0", "part": [1, 1], "seq": [1, 1], "prompt": "class App {\n\n\tpublic String getMessage() {\n\t\treturn message;\n\t}\n\n\tpublic  App();\n\tpublic  App(String message);\n\n\tpublic static void main(String[] args);\n\tpublic void setMessage(String message);\n\tpublic void run();\n\tprotected void readMessageFromFile(String file);\n\n\tprivate static final Logger LOG;\n\tprivate App app;\n\n}\n\nclass AppTest {\n\n\tprivate static final Logger LOG;\n\tprivate App app;\n\n\t@Test\n\tpublic void testDefaultMessage() {\n", "reference": "\t\tString message = app.getMessage();\n\t\tassertEquals(\"Hello, world!\", message);\n\t\tLOG.debug(message);\n\t}\n\n}", "prediction": "\t\tassertEquals(\"Hello World!\", app.getMessage());\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "2836228_31", "part": [1, 1], "seq": [1, 1], "prompt": "class ProcessEntityParser extends EntityParser<Process> {\n\n    @Override\n    public void validate(Process process) throws IvoryException {\n        if(process.getTimezone() == null)\n            process.setTimezone(TimeZone.getTimeZone(\"UTC\"));\n\n        // check if dependent entities exists\n        Set<String> clusters = new HashSet<String>();\n        for (org.apache.ivory.entity.v0.process.Cluster cluster : process.getClusters().getClusters()) {\n            String clusterName = cluster.getName();\n\t\t\tif (!clusters.add(cluster.getName())) {\n\t\t\t\tthrow new ValidationException(\"Cluster: \" + cluster.getName()\n\t\t\t\t\t\t+ \" is defined more than once for process: \"+process.getName());\n\t\t\t}\n            validateEntityExists(EntityType.CLUSTER, clusterName);\n            validateProcessValidity(cluster.getValidity().getStart(), cluster.getValidity().getEnd());\n            validateHDFSpaths(process, clusterName);\n\n            if (process.getInputs()!= null) {\n                for (Input input : process.getInputs().getInputs()) {\n                    validateEntityExists(EntityType.FEED, input.getFeed());\n                    Feed feed = (Feed) ConfigurationStore.get().get(EntityType.FEED, input.getFeed());\n                    CrossEntityValidations.validateFeedDefinedForCluster(feed, clusterName);\n                    CrossEntityValidations.validateFeedRetentionPeriod(input.getStart(), feed, clusterName);\n                    CrossEntityValidations.validateInstanceRange(process, input, feed);\n                    if (input.getPartition()!= null) {\n                        CrossEntityValidations.validateInputPartition(input, feed);\n                    }\n                }\n            }\n\n            if (process.getOutputs()!= null) {\n                for (Output output : process.getOutputs().getOutputs()) {\n                    validateEntityExists(EntityType.FEED, output.getFeed());\n                    Feed feed = (Feed) ConfigurationStore.get().get(EntityType.FEED, output.getFeed());\n                    CrossEntityValidations.validateFeedDefinedForCluster(feed, clusterName);\n                    CrossEntityValidations.validateInstance(process, output, feed);\n                }\n            }\n        }\n        validateDatasetName(process.getInputs(), process.getOutputs());\n        validateLateInputs(process);\n    }\n\n    public  ProcessEntityParser();\n\n    private void validateHDFSpaths(Process process, String clusterName);\n    private String getNameNode(Cluster cluster, String clusterName);\n    private void validateProcessValidity(Date start, Date end);\n    private void validateDatasetName(Inputs inputs, Outputs outputs);\n    private void validateLateInputs(Process process);\n\n\tprivate final ProcessEntityParser parser;\n\tprivate String INVALID_PROCESS_XML;\n\n}\n\nclass ProcessEntityParserTest extends EntityParser<Process> {\n\n\tprivate final ProcessEntityParser parser;\n\tprivate String INVALID_PROCESS_XML;\n\n\t@Test(expectedExceptions = ValidationException.class)\n\tpublic void testInvalidProcessValidity() throws Exception {\n", "reference": "\t\tProcess process = parser\n\t\t\t\t.parseAndValidate((ProcessEntityParserTest.class\n\t\t\t\t\t\t.getResourceAsStream(PROCESS_XML)));\n\t\tprocess.getClusters().getClusters().get(0).getValidity().setStart(SchemaHelper.parseDateUTC(\"2011-12-31T00:00Z\"));\n\t\tparser.validate(process);\n\t}\n\n}", "prediction": "\t\tparser.parse(INVALID_PROCESS_XML);\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "2846293_39", "part": [1, 1], "seq": [1, 1], "prompt": "class ActionsGenerator {\n\n    public Actions builder() {\n        return new Actions();\n    }\n\n    public  ActionsGenerator(String mouseObject, String keyboardObject, String actionObject);\n\n    public Keyboard keyboard();\n    public Mouse mouse();\n\n    private ActionsGenerator action;\n    private String webElement;\n    private String altWebElement;\n\n}\n\nclass ActionsGeneratorTest {\n\n    private ActionsGenerator action;\n    private String webElement;\n    private String altWebElement;\n\n    @Test\n    public void generateCodeActionClick() throws Exception {\n", "reference": "        assertThat(this.action.builder().click(), is(equalTo(\"builder.click()\")));\n    }\n\n}", "prediction": "        action = new ActionsGenerator(webElement, null, null);\n        action.builder().click();\n        assertEquals(\"Actions.builder().click(By.id(\\\"webElement\\\")).perform();\", action.builder().toString());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "3145735_8", "part": [1, 1], "seq": [1, 1], "prompt": "class DummyReader implements ProfileVersionReader {\n\n  public String getObjectsAvgSize() {\n    final Element size = this.getSizePropertyElement();\n    return this.getAttributeValue(size, \"avg\");\n  }\n\n  public void setStream(final InputStream is);\n  public String getCollectionName();\n  public String getObjectsCount();\n  public String getCollectionSize();\n  public String getObjectsMaxSize();\n  public String getObjectsMinSize();\n  public Map<String, String> getDistribution(final String name);\n  private Element getCollectionElement();\n  private Element getSizePropertyElement();\n  private Element getPropertyElement(final String name);\n  private String getAttributeValue(final Element element, final String name);\n  private void getDocument(final InputStream is);\n\n  private DummyReader reader;\n\n}\n\nclass DummyReaderTest {\n\n  private DummyReader reader;\n\n  @Test\n  public void shouldObtainObjectsAvgSize() throws Exception {\n", "reference": "    final String size = this.reader.getObjectsAvgSize();\n    Assert.assertEquals(\"35000.42\", size);\n  }\n\n}", "prediction": "    // given\n    final String expected = \"100\";\n\n    // when\n    final String actual = this.reader.getObjectsAvgSize();\n\n    // then\n    assertEquals(expected, actual);\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "3173086_42", "part": [1, 1], "seq": [1, 1], "prompt": "class ExporterImpl implements Exporter {\n\n    public List<File> exportReport(ExportSettings settings, List<Participant> participants, Trip trip,\n                                   ResourceResolver resourceResolver, ActivityResolver activityResolver, AmountFactory amountFactory) {\n\n        List<File> filesCreated = new ArrayList<>();\n\n        StringBuilder fileNamePrefix = new StringBuilder(resourceResolver.resolve(R.string.fileExportPrefix))\n               .append(FILE_NAME_SEPARATOR)\n               .append(ExporterFileNameUtils.clean(trip.getName()));\n        StringBuilder timestamp = new StringBuilder(ExporterFileNameUtils.getTimeStamp(resourceResolver.getLocale()));\n\n        HtmlExportCharResolver htmlExportCharResolver = null;\n        CsvExportCharResolver csvExportCharResolver = null;\n        TxtExportCharResolver txtExportCharResolver = null;\n\n        if (settings.isFormatHtml()) {\n            htmlExportCharResolver = new HtmlExportCharResolver();\n            htmlExportCharResolver.setLang(resourceResolver.getLocale().getLanguage());\n        }\n        if (settings.isFormatCsv()) {\n            csvExportCharResolver = new CsvExportCharResolver();\n        }\n        if (settings.isFormatTxt()) {\n            txtExportCharResolver = new TxtExportCharResolver();\n        }\n\n        if (participants.size() > 1 && settings.isSeparateFilesForIndividuals()) {\n            ArrayList<Participant> participantsSubset;\n            for (Participant p : participants) {\n                participantsSubset = new ArrayList<>(1);\n                participantsSubset.add(p);\n                createAndWriteFiles(settings,\n                        participantsSubset,\n                        trip,\n                        resourceResolver,\n                        fileWriter,\n                        filesCreated,\n                        fileNamePrefix,\n                        timestamp,\n                        htmlExportCharResolver,\n                        csvExportCharResolver,\n                        txtExportCharResolver,\n                        amountFactory);\n            }\n        } else {\n            createAndWriteFiles(settings,\n                    participants,\n                    trip,\n                    resourceResolver,\n                    fileWriter,\n                    filesCreated,\n                    fileNamePrefix,\n                    timestamp,\n                    htmlExportCharResolver,\n                    csvExportCharResolver,\n                    txtExportCharResolver,\n                    amountFactory);\n        }\n\n        StreamSender streamSender = new StreamSenderImpl();\n        StringBuilder exportSubject = new StringBuilder()\n               .append(resourceResolver.resolve(R.string.fileExportEmailSubjectPrefix))\n               .append(SPACE)\n               .append(trip.getName())\n               .append(SPACE)\n               .append(timestamp);\n\n        if (activityResolver.getActivity()!= null) {\n            List<Uri> contentUrisFromFiles = FileUtils.getContentUrisFromFiles(filesCreated, TrickyTripperFileProvider.AUTHORITY);\n            if (settings.getOutputChannel()!= null) {\n                streamSender.sendStream(\n                        (Activity) activityResolver.getActivity(),\n                        exportSubject.toString(),\n                        resourceResolver.resolve(R.string.fileExportEmailContent),\n                        contentUrisFromFiles, settings.getOutputChannel());\n            }\n        }\n\n        return filesCreated;\n\n    }\n\n    public  ExporterImpl(FileWriter fileWriter);\n\n    private void createAndWriteFiles(ExportSettings settings, List<Participant> participants, Trip trip,\n                                     ResourceResolver resourceResolver, FileWriter fileWriter, List<File> filesCreated,\n                                     StringBuilder fileNamePrefix, StringBuilder timestamp, HtmlExportCharResolver htmlExportCharResolver,\n                                     CsvExportCharResolver csvExportCharResolver, TxtExportCharResolver txtExportCharResolver,\n                                     AmountFactory amountFactory);\n    private String[] getReportMetaInfo(List<Participant> participants, Trip trip, ResourceResolver resourceResolver);\n    private StringBuilder buildFileName(StringBuilder fileNamePrefix, StringBuilder timestamp,\n                                        List<Participant> participants, ResourceResolver resourceResolver);\n\n    private final Pattern patternCsvIndividual;\n    private final Pattern patternCsvAll;\n    private final Pattern patternHtmlIndividual;\n    private final Pattern patternHtmlAll;\n    private final Pattern patternTxtIndividual;\n    private final Pattern patternTxtAll;\n    @SuppressWarnings(\"FieldCanBeLocal\")\n    private final boolean deleteCreatedFiles;\n    private Exporter exporter;\n    private Trip tripToExport;\n    private ResourceResolver resourceResolver;\n    private Participant participant;\n    private AmountFactory amountFactory;\n    private TestDataFactory factory;\n\n}\n\nclass ExporterImplTest {\n\n    private final Pattern patternCsvIndividual;\n    private final Pattern patternCsvAll;\n    private final Pattern patternHtmlIndividual;\n    private final Pattern patternHtmlAll;\n    private final Pattern patternTxtIndividual;\n    private final Pattern patternTxtAll;\n    @SuppressWarnings(\"FieldCanBeLocal\")\n    private final boolean deleteCreatedFiles;\n    private Exporter exporter;\n    private Trip tripToExport;\n    private ResourceResolver resourceResolver;\n    private Participant participant;\n    private AmountFactory amountFactory;\n    private TestDataFactory factory;\n\n    @Test\n    public void testOutputTxtForAllSplit() {\n", "reference": "        ExportSettings exportSettings = createExportSettings(true, true, true, true, false, false, true, false, true);\n        List<File> result = exporter.exportReport(exportSettings, tripToExport.getParticipant(), tripToExport,\n                resourceResolver,\n                new ActivityResolver() {\n\n                    @Override\n                    public Object getActivity() {\n                        return null;\n                    }\n                },\n                amountFactory);\n\n        Throwable exceptionCaught = null;\n        try {\n            Assert.assertEquals(3, result.size());\n            Assert.assertTrue(patternTxtIndividual.matcher(result.get(0).getName()).matches());\n            Assert.assertTrue(patternTxtIndividual.matcher(result.get(1).getName()).matches());\n            Assert.assertTrue(patternTxtIndividual.matcher(result.get(2).getName()).matches());\n\n            for (int i = 0; i < result.size(); i++) {\n                String name;\n                if (i == 0) {\n                    name = factory.chris.getName();\n                }\n                else if (i == 1) {\n                    name = factory.niko.getName();\n                }\n                else {\n                    name = factory.wolfram.getName();\n                }\n                Assert.assertTrue(nameContains(result.get(i), name));\n            }\n        }\n        catch (Exception e) {\n            exceptionCaught = e;\n        }\n        finally {\n            deleteCreatedFiles(result);\n        }\n        if (exceptionCaught != null) {\n            throw new RuntimeException(exceptionCaught);\n        }\n    }\n\n}", "prediction": "        ExportSettings settings = new ExportSettings();\n        settings.setFormatTxt(true);\n        settings.setSeparateFilesForIndividuals(true);\n        settings.setOutputChannel(OutputChannel.EMAIL);\n\n        List<Participant> participants = factory.createParticipants(10);\n        tripToExport = factory.createTrip();\n\n        List<File> filesCreated = exporter.exportReport(settings, participants, tripToExport, resourceResolver,\n                new ActivityResolverImpl(), amountFactory);\n\n        assertEquals(1, filesCreated.size());\n        assertTrue(filesCreated.get(0).getName().matches(patternTxtAll.pattern()));\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "3223269_0", "part": [1, 1], "seq": [1, 1], "prompt": "class GaugesService {\n\n    public List<Gauge> getGauges() throws IOException {\n        try {\n            HttpRequest request = execute(HttpRequest.get(URL_EMBEDDED));\n            GaugesWrapper response = fromJson(request, GaugesWrapper.class);\n            if (response!= null && response.gauges!= null)\n                return response.gauges;\n            return Collections.emptyList();\n        } catch (HttpRequestException e) {\n            throw e.getCause();\n        }\n    }\n\n    public  GaugesService(final String username, final String password);\n    public  GaugesService(final String apiKey);\n\n    protected HttpRequest execute(HttpRequest request);\n    private HttpRequest configure(final HttpRequest request);\n    private HttpRequest addCredentialsTo(HttpRequest request);\n    private V fromJson(HttpRequest request, Class<V> target);\n    public List<PageContent> getContent(String gaugeId);\n    public List<Referrer> getReferrers(String gaugeId);\n    public Client createClient(String description);\n    public Client getClient(String description);\n    public Gauge getGauge(String gaugeId);\n    public String getPusherAuth(final String socketId, final String channelName);\n\n    @Mock\n    private HttpRequest request;\n    private GaugesService service;\n\n}\n\nclass GaugesServiceTest {\n\n    @Mock\n    private HttpRequest request;\n    private GaugesService service;\n\n    @Test\n    public void getGaugesEmptyResponse() throws IOException {\n", "reference": "        doReturn(createReader(\"\")).when(request).bufferedReader();\n        List<Gauge> gauges = service.getGauges();\n        assertNotNull(gauges);\n        assertTrue(gauges.isEmpty());\n    }\n\n}", "prediction": "        when(request.send()).thenReturn(new HttpResponse(200, \"{}\"));\n        List<Gauge> gauges = service.getGauges();\n        assertThat(gauges).isEmpty();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "3384018_43", "part": [1, 1], "seq": [1, 1], "prompt": "class RequestAcceptEncoding implements HttpRequestInterceptor {\n\n    public void process(\n            final HttpRequest request,\n            final HttpContext context) throws HttpException, IOException {\n\n        /* Signal support for Accept-Encoding transfer encodings. */\n        request.addHeader(\"Accept-Encoding\", \"gzip,deflate\");\n    }\n\n}\n\nclass TestRequestAcceptEncoding {\n\n    @Test\n    public void testAcceptEncoding() throws Exception {\n", "reference": "        HttpRequest request = new BasicHttpRequest(\"GET\", \"/\");\n        HttpContext context = new BasicHttpContext();\n\n        HttpRequestInterceptor interceptor = new RequestAcceptEncoding();\n        interceptor.process(request, context);\n        Header header = request.getFirstHeader(\"Accept-Encoding\");\n        Assert.assertNotNull(header);\n        Assert.assertEquals(\"gzip,deflate\", header.getValue());\n    }\n\n}", "prediction": "        final HttpClient client = new HttpClient();\n        final HttpGet get = new HttpGet(\"http://localhost:8080/test\");\n        final RequestAcceptEncoding interceptor = new RequestAcceptEncoding();\n        client.addRequestInterceptor(interceptor);\n        client.execute(get);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "3604591_7", "part": [1, 1], "seq": [1, 1], "prompt": "class PackageNameMatcher {\n\n    public static PackageNameMatcher compile(final List<String> specs) {\n        if (specs == null) {\n            throw new IllegalArgumentException(\"null package name specifications\");\n        }\n\n        final List<Pattern> list = new ArrayList<>();\n\n        for (String part : specs) {\n            list.add(buildPattern(part));\n        }\n\n        return new PackageNameMatcher(list);\n    }\n\n    private  PackageNameMatcher(List<Pattern> patterns);\n\n    private static Pattern buildPattern(final String spec);\n    private String buildDescription();\n    public boolean matches(String packageName);\n    @Override public String toString();\n\n}\n\nclass PackageNameMatcherTest {\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testPattern07() {\n", "reference": "        final List<String> specs = new ArrayList<>();\n        specs.add(\"com.example.*\");\n        specs.add(\"org.example.!\");\n        PackageNameMatcher.compile(specs);\n    }\n\n}", "prediction": "        PackageNameMatcher.compile(null);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "3865446_27", "part": [1, 1], "seq": [1, 1], "prompt": "class SimplePhenotypeRepresentation implements PhenotypeRepresentation {\n\n    public double[] getDoubleValue() {\n        if (this.representation!= null){\n            return Arrays.copyOf(this.representation, this.representation.length);\n        } else {\n            return new double[0];\n        }\n\n    }\n\n    public  SimplePhenotypeRepresentation();\n    public  SimplePhenotypeRepresentation(double[] phenotypeValue);\n    public  SimplePhenotypeRepresentation(SimplePhenotypeRepresentation second);\n\n    public void setDoubleValue(double[] phenotypeValue);\n    public Representation copy();\n\n    protected PhenotypeRepresentation representation;\n\n}\n\nclass SimplePhenotypeRepresentationTest  {\n\n    protected PhenotypeRepresentation representation;\n\n    @Test\n    // test that arrays are equal but not the same\n    public void testGetDoubleValue() throws Exception {\n", "reference": "        double[] input = new double[]{1.2, 4.8, 6.3, 9.9, 10E18};\n        this.representation.setDoubleValue(input);\n        double[] output = this.representation.getDoubleValue();\n        Assert.assertArrayEquals(input, output, 0.0d);\n        Assert.assertNotSame(input, output);\n    }\n\n}", "prediction": "        double[] expected = {1.0, 2.0, 3.0};\n        representation.setDoubleValue(expected);\n        double[] actual = representation.getDoubleValue();\n        assertArrayEquals(expected, actual);\n        assertNotSame(expected, actual);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "3926525_1", "part": [1, 1], "seq": [1, 1], "prompt": "class ValueSetter {\n\n\tpublic void invoke(String aKey, Object anOn, String aWith) {\n\t\ttry {\n\t\t\tif (twoArgSetter) {\n\t\t\t\tsetter.invoke(anOn, aKey, converter.convert(aWith));\n\t\t\t} else {\n\t\t\t\tsetter.invoke(anOn, converter.convert(aWith));\n\t\t\t}\n\t\t} catch (ParsingException anExc) {\n\t\t\tthrow anExc;\n        } catch (IllegalArgumentException anExc) {\n            throw new ParsingException(\n                anExc.getMessage() +\n                \" while trying to invoke \" + setter +\n                \" on \" + anOn +\n                \" with \" + ((aKey!= null)? aKey + \" and \" : \"\") + aWith +\n                \" converted by \" + converter, anExc);\n\t\t} catch (Exception anExc) {\n\t\t\tthrow new RuntimeException(anExc);\n\t\t}\n\t}\n\n\tpublic  ValueSetter(ConverterRegistry aConverters, Class<?> aContextType, String... aMaybeNames);\n\tpublic  ValueSetter(ConverterRegistry aConverters, Class<?> aContextType, Class<?> aValueType, String... aMaybeNames);\n\n\tpublic String toString();\n\tprivate Method getMethod(Class<?> aContextType, String... aMaybeNames);\n\n\tprivate ConverterRegistry converters;\n\tprivate TestModel model;\n\tprivate StringConverter<Integer> integerConverter;\n\tprivate Mockery mockery;\n\n}\n\nclass ValueSetterTest {\n\n\tprivate ConverterRegistry converters;\n\tprivate TestModel model;\n\tprivate StringConverter<Integer> integerConverter;\n\tprivate Mockery mockery;\n\n\t@Test\n\tpublic void introspectsModelClassToFindAndInvokeAddMethods() {\n", "reference": "\t\tmockery.checking(new Expectations() {{\n\t\t\toneOf(converters).getConverter(Integer.class); // parameter to the setFieldOne method is of type Integer\n\t\t\twill(returnValue(integerConverter));\n\t\t\t\n\t\t\toneOf(integerConverter).convert(\"17\");\n\t\t\twill(returnValue(new Integer(17)));\n\t\t\t\n\t\t\toneOf(model).addFieldTwo(new Integer(17));\n\t\t}});\n\t\t\n\t\tValueSetter _s = new ValueSetter(converters, TestModel.class, \"fieldTwo\");\n\t\t_s.invoke(\"fieldTwo\", model, \"17\");\n\t}\n\n}", "prediction": "\t\tValueSetter setter = new ValueSetter(converters, TestModel.class, \"add\");\n\t\tsetter.invoke(\"foo\", model, \"1\");\n\t\tsetter.invoke(\"bar\", model, \"2\");\n\t\tsetter.invoke(\"baz\", model, \"3\");\n\t\tassertEquals(3, model.getFoo().size());\n\t\tassertEquals(3, model.getBar().size());\n\t\tassertEquals(3, model.getBaz().size());\n\t}", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "3933719_1", "part": [1, 1], "seq": [1, 1], "prompt": "class LazyListImpl extends ArrayList<User> implements ListAccess<User> {\n\n   public int getSize() throws Exception\n   {\n      return size();\n   }\n\n   public User[] load(int index, int length);\n\n   private LazyListImpl list;\n\n}\n\nclass TestLazyListImpl {\n\n   private LazyListImpl list;\n\n   @Test\n   public void testGetSize() throws Exception\n   {\n", "reference": "      assertEquals(5, list.getSize());\n   }\n\n}", "prediction": "      list.getSize();\n   }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "4085998_299", "part": [1, 1], "seq": [1, 1], "prompt": "class urn_perun_facility_attribute_def_def_homeMountPoint_passwd_scp extends FacilityAttributesModuleAbstract implements FacilityAttributesModuleImplApi {\n\n\t@Override\n\tpublic void checkAttributeSemantics(PerunSessionImpl perunSession, Facility facility, Attribute attribute) throws WrongReferenceAttributeValueException {\n\t\tif (attribute.getValue() == null) throw new WrongReferenceAttributeValueException(attribute, null, facility, null, \"Value can't be null\");\n\t}\n\n\t@Override public void checkAttributeSyntax(PerunSessionImpl perunSession, Facility facility, Attribute attribute);\n\t@Override public Attribute fillAttribute(PerunSessionImpl session, Facility facility, AttributeDefinition attribute);\n\t@Override public AttributeDefinition getAttributeDefinition();\n\n\tprivate static urn_perun_facility_attribute_def_def_homeMountPoint_passwd_scp classInstance;\n\tprivate static PerunSessionImpl session;\n\tprivate static Facility facility;\n\tprivate static Attribute attributeToCheck;\n\n}\n\nclass urn_perun_facility_attribute_def_def_homeMountPoint_passwd_scpTest {\n\n\tprivate static urn_perun_facility_attribute_def_def_homeMountPoint_passwd_scp classInstance;\n\tprivate static PerunSessionImpl session;\n\tprivate static Facility facility;\n\tprivate static Attribute attributeToCheck;\n\n\t@Test(expected = WrongReferenceAttributeValueException.class)\n\tpublic void testCheckAttributeSemanticsWithoutReqAttribute() throws Exception {\n", "reference": "\t\tSystem.out.println(\"testCheckAttributeSemanticsWithoutReqAttribute()\");\n\t\tattributeToCheck.setValue(null);\n\n\t\tclassInstance.checkAttributeSemantics(session, facility, attributeToCheck);\n\t}\n\n}", "prediction": "\t\tclassInstance.checkAttributeSemantics(session, facility, attributeToCheck);\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "4086423_8", "part": [1, 1], "seq": [1, 1], "prompt": "class AssessmentPackageFileImporter {\n\n    public AssessmentPackage importAssessmentPackageData(final File importSandboxDirectory,\n            final MultipartFile multipartFile)\n            throws AssessmentPackageDataImportException {\n        Assert.notNull(importSandboxDirectory, \"importSandboxDirectory\");\n        Assert.notNull(multipartFile, \"multipartFile\");\n        AssessmentPackage assessmentPackage = null;\n\n        final String contentType = ServiceUtilities.computeContentType(multipartFile);\n        if (\"application/xml\".equals(contentType) || \"text/xml\".equals(contentType) || contentType.endsWith(\"+xml\")) {\n            /* Looks like an XML content type */\n            logger.debug(\"Import data uses a known XML MIME type {} so saving to {} and treating as XML\", contentType, importSandboxDirectory);\n            assessmentPackage = importStandaloneXml(importSandboxDirectory, multipartFile);\n        }\n        else {\n            /* Try to treat as a ZIP */\n            final boolean zipSuccess = tryUnpackZipFile(importSandboxDirectory, multipartFile);\n            if (zipSuccess) {\n                logger.debug(\"Import data was successfully expanded as a ZIP file\");\n                assessmentPackage = processUnpackedZip(importSandboxDirectory);\n            }\n            else {\n                logger.warn(\"Import data with MIME type {} was neither a supported XML MIME type nor a ZIP file (containing at least one entry)\", contentType);\n                throw new AssessmentPackageDataImportException(ImportFailureReason.NOT_XML_OR_ZIP);\n            }\n        }\n\n        logger.info(\"Successfully imported data for new {}\", assessmentPackage);\n        return assessmentPackage;\n    }\n\n    private AssessmentPackage importStandaloneXml(final File importSandboxDirectory, final MultipartFile multipartFile);\n    private boolean tryUnpackZipFile(final File importSandboxDirectory, final MultipartFile multipartFile);\n    private AssessmentPackage processUnpackedZip(final File importSandboxDirectory);\n    private void buildPackageFileMap(final File importSandboxDirectory,\n            final Set<String> packageQtiFileBuilder, final Set<String> packageSafeFileBuilder,\n            final List<ContentPackageResource> qtiResources);\n    private String checkPackageFile(final File importSandboxDirectory, final URI href);\n\n    private AssessmentPackageFileImporter assessmentPackageFileImporter;\n    private File importSandboxDirectory;\n\n}\n\nclass AssessmentPackageFileImporterTest {\n\n    private AssessmentPackageFileImporter assessmentPackageFileImporter;\n    private File importSandboxDirectory;\n\n    @Test\n    public void notContentPackage() throws Exception {\n", "reference": "        final MultipartFile multipartFile = getThisUnitTestMultipartFile(\"uk/ac/ed/ph/qtiworks/services/NotContentPackage.zip\", \"application/zip\");\n        try {\n            assessmentPackageFileImporter.importAssessmentPackageData(importSandboxDirectory, multipartFile);\n            Assert.fail(\"Should have failed\");\n        }\n        catch (final AssessmentPackageDataImportException e) {\n            Assert.assertEquals(ImportFailureReason.NOT_CONTENT_PACKAGE, e.getFailure().getReason());\n        }\n    }\n\n}", "prediction": "        final File file = new File(getClass().getResource(\"/import/not-content-package.zip\").toURI());\n        final MultipartFile multipartFile = new MockMultipartFile(\"file\", file.getName(), \"application/zip\", file);\n        try {\n            assessmentPackageFileImporter.importAssessmentPackageData(importSandboxDirectory, multipartFile);\n            fail(\"Expected AssessmentPackageDataImportException\");\n        }\n        catch (AssessmentPackageDataImportException e) {\n            assertEquals(ImportFailureReason.NOT_XML_OR_ZIP, e.getImportFailureReason());\n        }\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "4089097_0", "part": [1, 1], "seq": [1, 1], "prompt": "class StringUtils {\n\n\tpublic static int countWords(String str, boolean all) {\n\t\tif (str == null || str.length() == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tString[] words;\n\t\tif (all) {\n\t\t\twords = str.split(\"\\\\s+\"); // Splits at whitespaces.\n\t\t} else {\n\t\t\twords = str.split(\"[\\\\s\\\\*\\\\#\\\\_\\\\|]+\");\n\t\t}\n\n\t\tint count = 0;\n\t\tfor (String word : words) {\n\t\t\tif (word.length() > 0) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\n\t\treturn count;\n\t}\n\n\tpublic static String join(String[] array, String delimiter);\n\tpublic static String quoteMetacharacters(String str);\n\tpublic static String stripNasties(String str);\n\n}\n\nclass StringUtilTests {\n\n\t@Test\n\tpublic void testCountWords() {\n", "reference": "\t\tassertThat(StringUtils.countWords(\"Hi\", true), is(equalTo(1)));\n\t\tassertThat(StringUtils.countWords(\"Hi there\", true), is(equalTo(2)));\n\t\tassertThat(StringUtils.countWords(\"Hi  there\", true), is(equalTo(2)));\n\t\tassertThat(StringUtils.countWords(\"The quick brown fox jumps over the lazy dog\", true), is(equalTo(9)));\n\t\tassertThat(StringUtils.countWords(\"The * quick # brown _ fox | jumps over the lazy dog\", true), is(equalTo(13)));\n\t\tassertThat(StringUtils.countWords(\"The * quick # brown _ fox | jumps over the lazy dog\", false), is(equalTo(9)));\n\t}\n\n}", "prediction": "\t\tassertEquals(0, StringUtils.countWords(null, false));\n\t\tassertEquals(0, StringUtils.countWords(\"\", false));\n\t\tassertEquals(0, StringUtils.countWords(\" \", false));\n\t\tassertEquals(0, StringUtils.countWords(\"  \", false));\n\t\tassertEquals(0, StringUtils.countWords(\"  \", true));\n\t\tassertEquals(1, StringUtils.countWords(\"a\", false));\n\t\tassertEquals(1, StringUtils.countWords(\"a\", true));\n\t\tassertEquals(2, StringUtils.countWords(\"a b\", false));\n\t\tassertEquals(2, StringUtils.countWords(\"a b\", true));\n\t\tassertEquals(2, StringUtils.countWords(\"a b\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", false));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals(3, StringUtils.countWords(\"a b c\", true));\n\t\tassertEquals", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "4114800_10", "part": [1, 1], "seq": [1, 1], "prompt": "class HadoopTwitterTokenTool extends Configured implements Tool {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\ttry {\n\t\t\tToolRunner.run(new HadoopTwitterTokenTool(args), args);\n\t\t} catch (CmdLineException e) {\n\t\t\tSystem.err.print(e);\n\t\t}\n\t}\n\n\tpublic  HadoopTwitterTokenTool(String[] originalArgs);\n\n\t@Override public int run(String[] args);\n\n\t@Rule\n\tpublic TemporaryFolder folder;\n\tprivate String hadoopCommand;\n\tprivate File outputLocation;\n\tprivate File resultsOutputLocation;\n\tprivate File stemmedTweets;\n\tprivate File jsonTweets;\n\tprivate File monthLongTweets;\n\tprivate static final String JSON_TWITTER;\n\tprivate static int counter;\n\n}\n\nclass HadoopTwitterTokenToolTest {\n\n\t@Rule\n\tpublic TemporaryFolder folder;\n\tprivate String hadoopCommand;\n\tprivate File outputLocation;\n\tprivate File resultsOutputLocation;\n\tprivate File stemmedTweets;\n\tprivate File jsonTweets;\n\tprivate File monthLongTweets;\n\tprivate static final String JSON_TWITTER;\n\tprivate static int counter;\n\n\t@Test\n\tpublic void testMonthLongDFIDFCSVByTime() throws Exception {\n", "reference": "//\t\thadoopCommand = \"-i %s -o %s -om %s -ro %s -m %s -j %s -t 1 -wt . -wt !\";\n\t\tString command = String.format(hadoopCommand,\n\t\t\t\tmonthLongTweets.getAbsolutePath(),\n\t\t\t\toutputLocation.getAbsolutePath(), \"CSV\",\n\t\t\t\tresultsOutputLocation.getAbsolutePath(), \"DFIDF\",\n\t\t\t\t\"analysis.stemmed\");\n\t\tcommand += \" -svbt\";\n\t\tString[] args = command.split(\" \");\n\t\targs = (String[]) ArrayUtils.addAll(args, new String[] { \"-pp\",\"-m PORTER_STEM\" });\n\t\tSystem.out.println(Arrays.toString(args));\n\t\tHadoopTwitterTokenTool.main(args);\n\t\tPath p = new Path(resultsOutputLocation.getAbsolutePath());\n\t\tSystem.out.println(p);\n\t}\n\n}", "prediction": "\t\tString[] args = {\n\t\t\t\t\"-input\", monthLongTweets.getAbsolutePath(),\n\t\t\t\t\"-output\", resultsOutputLocation.getAbsolutePath(),\n\t\t\t\t\"-stemmed\", stemmedTweets.getAbsolutePath(),\n\t\t\t\t\"-json\", jsonTweets.getAbsolutePath(),\n\t\t\t\t\"-hadoopCommand\", hadoopCommand,\n\t\t\t\t\"-monthLongDFIDFCSVByTime\"\n\t\t};\n\t\tHadoopTwitterTokenTool tool = new HadoopTwitterTokenTool(args);\n\t\ttool.run(args);\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "4260851_21", "part": [1, 1], "seq": [1, 1], "prompt": "class Binders {\n\n    public static Binder defaultBinder() {\n        return DEFAULT_BINDER;\n    }\n\n    private  Binders();\n\n    public static Binder stringBinder();\n    public static Binder dateBinder();\n    public static Binder timestampBinder();\n    public static Binder timeBinder();\n    public static Binder decimalBinder();\n    public static Binder integerBinder();\n\n    private PreparedStatement stmt;\n\n}\n\nclass BindersTest {\n\n    private PreparedStatement stmt;\n\n    @Test\n    public void defaultBinderBindsLocalDateTime() throws SQLException {\n", "reference": "        LocalDateTime localDateTime = LocalDateTime.parse(\"1975-07-19T01:02:03.000\");\n        Binder binder = Binders.defaultBinder();\n        binder.bind(stmt, 1, localDateTime);\n        verify(stmt).setTimestamp(1, Timestamp.valueOf(\"1975-07-19 01:02:03\"));\n    }\n\n}", "prediction": "        stmt.setObject(1, LocalDateTime.now());\n        stmt.execute();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "4263930_0", "part": [1, 1], "seq": [1, 1], "prompt": "class StreamUtils {\n\n    public static String getStreamContents(InputStream is) {\n        Preconditions.checkNotNull(is, \"Cannot get String from a null object\");\n        try {\n            final char[] buffer = new char[0x10000];\n            StringBuilder out = new StringBuilder();\n            Reader in = new InputStreamReader(is, \"UTF-8\");\n            int read;\n            do {\n                read = in.read(buffer, 0, buffer.length);\n                if (read > 0) {\n                    out.append(buffer, 0, read);\n                }\n            } while (read >= 0);\n            in.close();\n            return out.toString();\n        } catch (IOException ioe) {\n            throw new IllegalStateException(\"Error while reading response body\", ioe);\n        }\n    }\n\n    private  StreamUtils();\n\n}\n\nclass StreamUtilsTest {\n\n    @Test\n    public void shouldCorrectlyDecodeAStream() {\n", "reference": "        String value = \"expected\";\n        InputStream is = new ByteArrayInputStream(value.getBytes());\n        String decoded = StreamUtils.getStreamContents(is);\n        assertEquals(\"expected\", decoded);\n    }\n\n}", "prediction": "        InputStream is = getClass().getResourceAsStream(\"/test.txt\");\n        String result = StreamUtils.getStreamContents(is);\n        assertThat(result, is(\"This is a test\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "4269155_325", "part": [1, 1], "seq": [1, 1], "prompt": "class StateAwareParameterMap implements Map<String, String[]> {\n\n    @Override\n    public int size() {\n        return requestMap.size();\n    }\n\n    public  StateAwareParameterMap(Map<String, String[]> requestMap,\n            Map<String, String[]> responseMap);\n\n    @Override public void clear();\n    @Override public boolean containsKey(Object key);\n    @Override public boolean containsValue(Object value);\n    @Override public Set<java.util.Map.Entry<String, String[]>> entrySet();\n    @Override public String[] get(Object key);\n    @Override public boolean isEmpty();\n    @Override public Set<String> keySet();\n    @Override public String[] put(String key, String[] value);\n    @Override public void putAll(Map<? extends String,? extends String[]> m);\n    @Override public String[] remove(Object key);\n    @Override public Collection<String[]> values();\n\n    private Map<String, String[]> requestMap;\n    private Map<String, String[]> responseMap;\n    private StateAwareParameterMap map;\n\n}\n\nclass StateAwareParameterMapTest {\n\n    private Map<String, String[]> requestMap;\n    private Map<String, String[]> responseMap;\n    private StateAwareParameterMap map;\n\n    @Test\n    public void testSize() {\n", "reference": "        expect(requestMap.size()).andReturn(1);\n\n        replay(requestMap, responseMap);\n        assertEquals(1, map.size());\n        verify(requestMap, responseMap);\n    }\n\n}", "prediction": "        assertEquals(requestMap.size(), map.size());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "4354801_2", "part": [1, 1], "seq": [1, 1], "prompt": "class TaintFrame extends Frame<Taint> {\n\n    public String toString(MethodGen method) {\n        String[] variables = new String[method.getLocalVariables().length];\n        LocalVariableGen[] variablesGen = method.getLocalVariables();\n        for(int i=0; i<variablesGen.length ;i++) {\n            variables[i] = variablesGen[i].getName();\n        }\n        return toString(variables);\n    }\n\n    public  TaintFrame(int numLocals);\n\n    @Override public String toString();\n    public String toString(String[] variableNames);\n\n}\n\nclass TaintFrameTest {\n\n    @Test\n    public void validateSimpleTaintFrameWithLocal() {\n", "reference": "\n        TaintFrame frame = new TaintFrame(4);\n        frame.setValue(0, new Taint(Taint.State.TAINTED));\n        frame.setValue(1, new Taint(Taint.State.TAINTED));\n        frame.setValue(2, new Taint(Taint.State.UNKNOWN));\n        frame.setValue(3, new Taint(Taint.State.UNKNOWN));\n        frame.pushValue(new Taint(Taint.State.TAINTED));\n        frame.pushValue(new Taint(Taint.State.UNKNOWN));\n        frame.pushValue(new Taint(Taint.State.NULL));\n        frame.pushValue(new Taint(Taint.State.SAFE));\n\n        String[] variables = new String[] {\"safe\",\"null_value\",\"external\",\"modifyMe\"};\n        String debugOutput = frame.toString(variables);\n        System.out.println(debugOutput);\n        assertTrue(debugOutput.contains(\"0. SAFE {S}\"));\n        assertTrue(debugOutput.contains(\"1. NULL {N}\"));\n        assertTrue(debugOutput.contains(\"2. UNKNOWN {U}\"));\n        assertTrue(debugOutput.contains(\"3. TAINTED {T}\"));\n\n        for(String variable : variables) {\n            assertTrue(debugOutput.contains(\"| \"+variable));\n        }\n    }\n\n}", "prediction": "        TaintFrame frame = new TaintFrame(1);\n        frame.setTaint(0, new Taint(Taint.Type.TAINTED));\n        assertEquals(\"Tainted\", frame.toString(new MethodGen()));\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "4622542_24", "part": [1, 1], "seq": [1, 1], "prompt": "class ResourceUtils {\n\n    public static InputStream getResourceWithAbsolutePackagePathAsStream(String absolutePackagePath, String resourceName) {\n        return getResourceWithAbsolutePackagePathAsStream(ResourceUtils.class, absolutePackagePath, resourceName);\n    }\n\n    public static URL getResourceWithAbsolutePackagePath(String absolutePackagePath, String resourceName);\n    private static String getFullPath(String resourcePath);\n    private static Path parsePath(String resourcePath);\n    public static URL getResource(String resourcePath);\n    public static URL getResource(Class<?> clazz, String resourcePath);\n    public static InputStream getResourceAsStream(String resourcePath);\n    public static InputStream getResourceAsStream(Class<?> clazz, String resourcePath);\n    public static URL getResourceWithAbsolutePackagePath(Class<?> clazz, String absolutePackagePath, String resourceName);\n    public static InputStream getResourceWithAbsolutePackagePathAsStream(Class<?> clazz, String absolutePackagePath, String resourceName);\n    private static String getResourcePath(String absolutePackagePath, String resourceName);\n    private static String formatArgument(String argument);\n    private static String constructResourcePath(String packagePath, String resourceName);\n    private static String removeLeadingUnixSeparators(String argument);\n\n}\n\nclass ResourceUtilsTest {\n\n    @Test\n    public void testResourceLoadingGetClass() {\n", "reference": "        InputStream stream = ResourceUtils.getResourceWithAbsolutePackagePathAsStream(getClass(), \"/org/reficio/ws/common/test/\", \"soapEncoding.xsd\");\n        Assert.assertNotNull(stream);\n    }\n\n}", "prediction": "        URL resource = ResourceUtils.getResource(ResourceUtilsTest.class, \"test.txt\");\n        assertNotNull(resource);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "4654729_5", "part": [1, 1], "seq": [1, 1], "prompt": "class BindingConditions {\n\n    public static <T> BindingCondition<T> isNamedIgnoringCase(Class<? extends T> type, final CharSequence value) {\n        return new BindingCondition<T>() {\n            \n            @Override\n            public boolean fulfilled(ClassInjector injector, Class<T> type, Map<String, Class<? extends T>[]> inheritanceTree, Annotation qualifier,\n                    ClassLoader classLoader) {\n                return qualifier instanceof Named && ((Named) qualifier).value().equalsIgnoreCase(value.toString());\n            }\n            \n        };\n    }\n\n    @SuppressWarnings(\"unchecked\") public static BindingCondition<T> annotationIsPresent(Class<? extends T> type, Class<? extends Annotation> annotation);\n    public static BindingCondition<T> qualifierIs(Class<? extends T> type, final Class<? extends Annotation> expectedQualifier);\n    public static BindingCondition<T> isNamed(Class<? extends T> type, final CharSequence value);\n    public static BindingCondition<T> allAnnotationsArePresent(Class<? extends T> type, final Class<? extends Annotation>... annotations);\n    public static BindingCondition<T> anyAnnotationIsPresent(Class<? extends T> type, final Class<? extends Annotation>... annotations);\n    public static BindingCondition<T> and(final BindingCondition<T>... conditions);\n    public static BindingCondition<T> or(final BindingCondition<T>... conditions);\n    public static BindingCondition<T> xor(final BindingCondition<T> condition1, final BindingCondition<T> condition2);\n\n     ClassLoader classLoader;\n     BindingCondition<Object> nonConfirming;\n     BindingCondition<Object> confirming;\n\n}\n\nclass BindingConditionsTest {\n\n     ClassLoader classLoader;\n     BindingCondition<Object> nonConfirming;\n     BindingCondition<Object> confirming;\n\n    @Test\n    public void isNotNamedIgnoringCase() {\n", "reference": "        assertFalse(BindingConditions.isNamedIgnoringCase(Tire.class, \"spare\").fulfilled(null, Tire.class, null, new Named() {\n            \n            @Override\n            public Class<? extends Annotation> annotationType() {\n                return Named.class;\n            }\n            \n            @Override\n            public String value() {\n                return \"notspare\";\n            }\n            \n        }, classLoader));\n    }\n\n}", "prediction": "        assertFalse(BindingConditions.isNamedIgnoringCase(Object.class, \"foo\").fulfilled(null, Object.class, null, null, classLoader));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "4671935_62", "part": [1, 1], "seq": [1, 1], "prompt": "class StringBuilderUtil {\n\n    public static void format2f(@NonNull StringBuilder sb, float x) {\n        final int x100 = Math.round(x * 100);\n        final int whole = x100 / 100;\n        final int tenths = x100 / 10 % 10;\n        final int hundredths = x100 % 10;\n        sb.append(whole);\n        sb.append(\".\");\n        sb.append(tenths);\n        sb.append(hundredths);\n    }\n\n    public static void format3f(@NonNull StringBuilder sb, double x);\n    public static void format2d(@NonNull StringBuilder sb, long x);\n    public static void format3d(@NonNull StringBuilder sb, long x);\n\n    private final double[] testDoubles;\n    private final float[] testFloats;\n    private final long[] testLongs;\n\n}\n\nclass StringBuilderUtilTest {\n\n    private final double[] testDoubles;\n    private final float[] testFloats;\n    private final long[] testLongs;\n\n    @Test\n    public void format2f() {\n", "reference": "        StringBuilder sb = new StringBuilder();\n\n        for (float value : testFloats) {\n            sb.setLength(0);\n            StringBuilderUtil.format2f(sb, value);\n            assertEquals(String.format(\"%.2f\", value), sb.toString());\n        }\n    }\n\n}", "prediction": "        final StringBuilder sb = new StringBuilder();\n        for (float f : testFloats) {\n            StringBuilderUtil.format2f(sb, f);\n            assertEquals(String.format(\"%.2f\", f), sb.toString());\n            sb.setLength(0);\n        }\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "4705783_5", "part": [1, 1], "seq": [1, 1], "prompt": "class XmlCredentialsUtil {\n\n    public static XMLConfiguration createXmlConfiguration(final String fileName) {\n        try {\n            return new XMLConfiguration(IntegrityUtil.ensure(fileName, \"Must provide a file name\"));\n        } catch (final ConfigurationException configurationException) {\n            throw new RuntimeException(\"Trouble using file name [\" + fileName + \"]\", configurationException);\n        }\n    }\n\n    public static XMLConfiguration createXmlConfiguration(final File file);\n    public static XMLConfiguration createXmlConfiguration(final URL url);\n    public static Credentials convertToCredentials(final HierarchicalConfiguration hierarchicalConfiguration, final Object url, final String userNameElement, final String passwordElement, final String tokenElement, final Object apiVersion);\n    public static Collection<Credentials> getCredentials(final XMLConfiguration xmlConfiguration, final String rootElement, final String urlElement, final String userNameElement, final String passwordElement, final String tokenElement, final String apiVersionElement);\n    public static Collection<Credentials> getCredentials(final String fileName, final String rootElement, final String urlElement, final String userNameElement, final String passwordElement, final String tokenElement, final String apiVersionElement);\n    public static Collection<Credentials> getCredentials(final File file, final String rootElement, final String urlElement, final String userNameElement, final String passwordElement, final String tokenElement, final String apiVersionElement);\n    public static Collection<Credentials> getCredentials(final URL url, final String rootElement, final String urlElement, final String userNameElement, final String passwordElement, final String tokenElement, final String apiVersionElement);\n\n}\n\nclass XmlCredentialsUtilTest {\n\n    @Test(expected = RuntimeException.class)\n    public void test_createXmlConfiguration_emptyString() {\n", "reference": "        XmlCredentialsUtil.createXmlConfiguration(\"\");\n    }\n\n}", "prediction": "        XmlCredentialsUtil.createXmlConfiguration(\"\");\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "4750321_632", "part": [1, 1], "seq": [1, 1], "prompt": "class FilterToCQL implements FilterVisitor, ExpressionVisitor {\n\n    private StringBuffer after( PropertyIsGreaterThan filter, StringBuffer output ){\n        LOGGER.finer(\"exporting AFTER\");\n        \n        Object expr1 = filter.getExpression1();\n        if( expr1 instanceof PropertyName){\n        \tPropertyName propertyName = (PropertyName) expr1;\n        \tpropertyName.accept(this, output);\n        \toutput.append(\" AFTER \");\n            filter.getExpression2().accept(this, output);        \n        }else { \n        \tPropertyName propertyName = (PropertyName) filter.getExpression2();\n            propertyName.accept(this, output);\n            output.append(\" BEFORE \");\n            filter.getExpression1().accept(this, output);        \n        }\n        return output;\n        \n    }\n\n    protected StringBuffer asStringBuffer( Object extraData);\n    public Object visit(ExcludeFilter filter, Object extraData);\n    public Object visit(IncludeFilter filter, Object extraData);\n    public Object visit(And filter, Object extraData);\n    public Object visit(Id filter, Object extraData);\n    public Object visit(Not filter, Object extraData);\n    public Object visit(Or filter, Object extraData);\n    public Object visit(PropertyIsBetween filter, Object extraData);\n    public Object visit(PropertyIsEqualTo filter, Object extraData);\n    public Object visit(PropertyIsNotEqualTo filter, Object extraData);\n    public Object visit(PropertyIsGreaterThan filter, Object extraData);\n    private boolean comparisonHasDate( Filter filter);\n    public Object visit(PropertyIsGreaterThanOrEqualTo filter, Object extraData);\n    public Object visit(PropertyIsLessThan filter, Object extraData);\n    public Object visit(PropertyIsLessThanOrEqualTo filter, Object extraData);\n    public Object visit(PropertyIsLike filter, Object extraData);\n    public Object visit(PropertyIsNull filter, Object extraData);\n    public Object visit(BBOX filter, Object extraData);\n    public Object visit(Beyond filter, Object extraData);\n    public Object visit(Contains filter, Object extraData);\n    public Object visit(Crosses filter, Object extraData);\n    public Object visit(Disjoint filter, Object extraData);\n    public Object visit(DWithin filter, Object extraData);\n    public Object visit(Equals filter, Object extraData);\n    public Object visit(Intersects filter, Object extraData);\n    public Object visit(Overlaps filter, Object extraData);\n    public Object visit(Touches filter, Object extraData);\n    public Object visit(Within filter, Object extraData);\n    public Object visitNullFilter(Object extraData);\n    public Object visit(NilExpression expression, Object extraData);\n    public Object visit(Add expression, Object extraData);\n    public Object visit(Divide expression, Object extraData);\n    public Object visit(Function function, Object extraData);\n    public Object visit(Literal expression, Object extraData);\n    public StringBuffer date( Date date, StringBuffer output );\n    public Object visit(Multiply expression, Object extraData);\n    public Object visit(PropertyName expression, Object extraData);\n    public Object visit(Subtract expression, Object extraData);\n    public Object visit(After after, Object extraData);\n    public Object visit(AnyInteracts anyInteracts, Object extraData);\n    public Object visit(Before before, Object extraData);\n    public Object visit(Begins begins, Object extraData);\n    public Object visit(BegunBy begunBy, Object extraData);\n    public Object visit(During during, Object extraData);\n    public Object visit(EndedBy endedBy, Object extraData);\n    public Object visit(Ends ends, Object extraData);\n    public Object visit(Meets meets, Object extraData);\n    public Object visit(MetBy metBy, Object extraData);\n    public Object visit(OverlappedBy overlappedBy, Object extraData);\n    public Object visit(TContains contains, Object extraData);\n    public Object visit(TEquals equals, Object extraData);\n    public Object visit(TOverlaps contains, Object extraData);\n\n     FilterToCQL toCQL;\n\n}\n\nclass FilterToCQLTest {\n\n     FilterToCQL toCQL;\n\n    @Test \n    public void testAfter() throws Exception{\n", "reference": "    \t\n    \tcqlTest(\"attr AFTER 2006-12-31T01:30:00Z\");\n    }\n\n}", "prediction": "        PropertyName propertyName = new PropertyName(\"foo\");\n        PropertyIsGreaterThan filter = new PropertyIsGreaterThan(propertyName, new Literal(1));\n        StringBuffer output = new StringBuffer();\n        toCQL.after(filter, output);\n        assertEquals(\"foo AFTER 1\", output.toString());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "4797319_38", "part": [1, 1], "seq": [1, 1], "prompt": "class PointOfFocusProcessor {\n\n  public static RecommendationType process(ASTQueryContainer ast)\n  throws VisitorException {\n    final List<String> v = new ArrayList<String>();\n\n    if (!(ast.getQuery() instanceof ASTSelectQuery)) { // Change to a SelectQuery\n      final ASTSelectQuery selectQuery = new ASTSelectQuery(SyntaxTreeBuilderTreeConstants.JJTSELECTQUERY);\n      final ASTSelect select = new ASTSelect(SyntaxTreeBuilderTreeConstants.JJTSELECT);\n\n      selectQuery.jjtAppendChild(select);\n      for (ASTDatasetClause d : ast.getQuery().getDatasetClauseList()) {\n        selectQuery.jjtAppendChild(d);\n      }\n      selectQuery.jjtAppendChild(ast.getQuery().getWhereClause());\n      if (!(ast.getQuery() instanceof ASTAskQuery)) {\n        if (ast.getQuery().getGroupClause()!= null) {\n          selectQuery.jjtAppendChild(ast.getQuery().getGroupClause());\n        }\n        if (ast.getQuery().getHavingClause()!= null) {\n          selectQuery.jjtAppendChild(ast.getQuery().getHavingClause());\n        }\n        if (ast.getQuery().getOrderClause()!= null) {\n          selectQuery.jjtAppendChild(ast.getQuery().getOrderClause());\n        }\n        if (ast.getQuery().getLimit()!= null) {\n          selectQuery.jjtAppendChild(ast.getQuery().getLimit());\n        }\n        if (ast.getQuery().getOffset()!= null) {\n          selectQuery.jjtAppendChild(ast.getQuery().getOffset());\n        }\n      }\n      if (ast.getQuery().getBindingsClause()!= null) {\n        selectQuery.jjtAppendChild(ast.getQuery().getBindingsClause());\n      }\n      ast.getQuery().jjtReplaceWith(selectQuery);\n    }\n    final ASTMaterializePointOfFocus matPOF = new ASTMaterializePointOfFocus();\n    matPOF.visit(ast, v);\n    final POFRecType type = new POFRecType();\n    return (RecommendationType) type.visit(ast, RecommendationType.NONE);\n  }\n\n  private  PointOfFocusProcessor();\n\n  private ASTQueryContainer ast;\n\n}\n\nclass TestPointOfFocusProcessor {\n\n  private ASTQueryContainer ast;\n\n  @Test(expected=DGSException.class)\n  public void testWrongRecommendationType()\n  throws Exception {\n", "reference": "    final String q = \"SELECT ?s WHERE { GRAPH ?g { < ?p ?o } }\";\n    ast = SyntaxTreeBuilder.parseQuery(q);\n    PointOfFocusProcessor.process(ast);\n  }\n\n}", "prediction": "    final RecommendationType type = new RecommendationType();\n    type.visit(ast, RecommendationType.NONE);\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "4802269_26", "part": [1, 1], "seq": [1, 1], "prompt": "class DXProject extends DXContainer {\n\n    public static Builder newProject() {\n        return new Builder();\n    }\n\n    private  DXProject(String projectId);\n    private  DXProject(String projectId, DXEnvironment env);\n\n    private static void checkProjectId(String projectId);\n    public static DXProject getInstance(String projectId);\n    public static DXProject getInstanceWithEnvironment(String projectId, DXEnvironment env);\n    public static Builder newProjectWithEnvironment(DXEnvironment env);\n    public Describe describe();\n    public void destroy();\n    public void destroy(boolean terminateJobs);\n\n    private DXProject testProject;\n\n}\n\nclass DXProjectTest {\n\n    private DXProject testProject;\n\n    @Test\n    public void testCreatProjectSerialization() throws IOException {\n", "reference": "        Assert.assertEquals(DXJSON.parseJson(\"{\\\"name\\\": \\\"projectname\\\"}\"), DXProject.newProject()\n                .setName(\"projectname\").buildRequestHash());\n    }\n\n}", "prediction": "        String projectId = \"test-project\";\n        DXProject project = DXProject.getInstance(projectId);\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        ObjectOutputStream oos = new ObjectOutputStream(baos);\n        oos.writeObject(project);\n        oos.close();\n        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\n        ObjectInputStream ois = new ObjectInputStream(bais);\n        DXProject deserializedProject = (DXProject) ois.readObject();\n        ois.close();\n        assertEquals(project, deserializedProject);\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "5012085_4", "part": [1, 1], "seq": [1, 1], "prompt": "class NullValuePredicate implements ValuePredicate<Object> {\n\n    @Override\n    public boolean apply(final Object input) {\n\t    return input == null;\n    }\n\n    private  NullValuePredicate();\n\n    @Override public String toString();\n    @Override public final int hashCode();\n    @Override public final boolean equals(Object obj);\n\n}\n\nclass NullValuePredicateTest {\n\n\t@Test\n\tpublic void testNullIsAccepted() {\n", "reference": "\t\tassertTrue(NullValuePredicate.INSTANCE.apply(null));\n\t}\n\n}", "prediction": "\t\tassertTrue(NullValuePredicate.INSTANCE.apply(null));\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "5264970_4", "part": [1, 1], "seq": [1, 1], "prompt": "class JsonSerializer extends BaseSerializer {\n\n    @Override\n    protected byte[] serialize(Object data) throws IOException {\n        return gson.toJson(data).getBytes(Charsets.UTF_8);\n    }\n\n    @Inject public  JsonSerializer(Gson gson);\n\n}\n\nclass JsonSerializerTest {\n\n    @Test\n    public void serializeOneAnnotated() throws Exception {\n", "reference": "        Gson gson = new Gson();\n        JsonSerializer serializer = new JsonSerializer(gson);\n\n        Invokable<?, Object> method = Invokable.from(Methods.class.getMethod(\"oneAnnotated\", Pojo.class));\n        Parameter[] parameters = Iterables.toArray(method.getParameters(), Parameter.class);\n\n        Pojo pojo = new Pojo(\"Hello world!\", 42);\n        byte[] bytes = serializer.serialize(parameters, new Object[] { pojo });\n\n        String expected = gson.toJson(Collections.singletonMap(\"value\", pojo));\n        JSONAssert.assertEquals(expected, new String(bytes, Charsets.UTF_8), true);\n    }\n\n}", "prediction": "        final String json = new JsonSerializer().serialize(new OneAnnotated());\n        assertThat(json, is(\"{\\\"a\\\":\\\"a\\\"}\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "5342001_1", "part": [1, 1], "seq": [1, 1], "prompt": "class Mapper implements ResourceLoaderAware {\n\n\tpublic Object map(Object toMap) {\n\t\t\n\t\tif (toMap == null) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tClass<?> mappedClass = mappings.get(toMap.getClass());\n\t\tif (mappedClass!= null) {\n\t\t\treturn modelMapper.map(toMap, mappedClass);\t\t\t\n\t\t} else {\n\t\t\treturn toMap;\n\t\t}\n\t}\n\n\tpublic void setPackages(List<String> packages);\n\t@PostConstruct public void init();\n\t@Override public void setResourceLoader(ResourceLoader resourceLoader);\n\n\t@Autowired\n\tprivate Mapper mapper;\n\n}\n\nclass MapperTest {\n\n\t@Autowired\n\tprivate Mapper mapper;\n\n\t@Test\n\tpublic void shouldDetectAnnotationAndMapObjectToDTO() {\n", "reference": "\t\tMovieInfo m = new MovieInfo(\"Iron Man 3\", 2013, \"HD\");\n\t\tObject dto = mapper.map(m);\n\t\tassertTrue(dto instanceof Movie);\n\t\tassertEquals(\"Iron Man 3\", ((Movie)dto).getName());\n\t\tassertEquals(new Integer(2013), ((Movie)dto).getYear());\n\t\tassertEquals(Quality.HD, ((Movie)dto).getQuality());\n\t}\n\n}", "prediction": "\t\tUser user = new User();\n\t\tuser.setId(1L);\n\t\tuser.setUsername(\"username\");\n\t\tuser.setPassword(\"\");\n\t\tuser.setEmail(\"\");\n\t\tuser.setFirstName(\"firstName\");\n\t\tuser.setLastName(\"lastName\");\n\t\tuser.setRole(Role.USER);\n\t\tuser.setCreated(new Date());\n\t\tuser.setUpdated(new Date());\n\n\t\tUserDTO userDTO = mapper.map(user);\n\n\t\tassertThat(userDTO.getId()).isEqualTo(1L);\n\t\tassertThat(userDTO.getUsername()).isEqualTo(\"username\");\n\t\tassertThat(userDTO.getPassword()).isEqualTo(\"\");\n\t\tassertThat(userDTO.getEmail()).isEqualTo(\"\");\n\t\tassertThat(userDTO.getFirstName()).isEqualTo(\"firstName\");\n\t\tassertThat(userDTO.getLastName()).isEqualTo(\"lastName\");\n\t\tassertThat(userDTO.getRole()).isEqualTo(Role.USER);\n\t\tassertThat(userDTO.getCreated()).isEqualTo(user.getCreated());\n\t\tassertThat(userDTO.getUpdated()).isEqualTo(user.getUpdated());\n\t}", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "5426789_20", "part": [1, 1], "seq": [1, 1], "prompt": "class CrescentIndexerExecutor {\n\n\tpublic String indexing(CrescentCollection collection, IndexingRequestForm indexingRequestForm) {\n\t\t\n\t\tlogger.info(\"indexingRequestForm : {}\", indexingRequestForm);\n\t\t\n\t\tIndexingType indexingType = IndexingType.valueOf(indexingRequestForm.getIndexingType().toUpperCase());\n\t\tIndexingCommand indexingCommand = IndexingCommand.valueOf(indexingRequestForm.getCommand().toUpperCase());\n\t\tString query = indexingRequestForm.getQuery();\n\t\t\n\t\tlogger.info(\"Indexing type : {}, Indexing command : {} \", indexingType, indexingCommand);\n\t\tlogger.info(\"Query : {}\", query);\n\t\t\n\t\tString resultMessage = \"Nothing To Execute...\";\n\t\t\n\t\t//CrescentIndexer crescentIndexer = new CrescentIndexer(collection.getName());\n\t\t\n\t\tif(IndexingCommand.ADD == indexingCommand) {\n\t\t\tList<Document> documentList = LuceneDocumentBuilder.buildDocumentList(indexingRequestForm.getDocumentList(), collection.getCrescentFieldByName());\n\t\t\tcrescentIndexer.addDocument(documentList, collection.getName());\n\t\t\n\t\t\tresultMessage = documentList.size() + \"\uac74\uc758 \uc0c9\uc778\uc774 \uc644\ub8cc\ub418\uc5c8\uc2b5\ub2c8\ub2e4.\";\n\t\t\t\n\t\t} else if (IndexingCommand.UPDATE == indexingCommand) {\n\t\t\t\n\t\t\tList<Document> documentList = LuceneDocumentBuilder.buildDocumentList(indexingRequestForm.getDocumentList(), collection.getCrescentFieldByName());\n\t\t\t\n\t\t\tif(documentList.size() == 0) {\n\t\t\t\tlogger.error(\"\uc5c5\ub370\uc774\ud2b8 \ud560 document\uac00 \uc5c6\uc2b5\ub2c8\ub2e4.\");\n\t\t\t\tthrow new IllegalStateException(\"\uc5c5\ub370\uc774\ud2b8 \ud560 document\uac00 \uc5c6\uc2b5\ub2c8\ub2e4.\");\n\t\t\t}\n\t\t\t\n\t\t\t//Document updateDoc = documentList.get(0);\n\t\t\t\n\t\t\tString[] splitQuery = query.split(\":\");\n\t\t\tif(splitQuery.length!= 2) {\n\t\t\t\tlogger.error(\"Update \ub300\uc0c1 \ubb38\uc11c\ub97c \ucc3e\uc744 Query\uc2dd\uc774 \uc798\ubabb\ub418\uc5c8\uc2b5\ub2c8\ub2e4. [{}]\", query);\n\t\t\t\tthrow new IllegalStateException(\"Update \ub300\uc0c1 \ubb38\uc11c\ub97c \ucc3e\uc744 Query\uc2dd\uc774 \uc798\ubabb\ub418\uc5c8\uc2b5\ub2c8\ub2e4. [\"+query+\"]\");\n\t\t\t}\n\t\t\tString field = query.split(\":\")[0];\n\t\t\tString value = query.split(\":\")[1];\n\t\t\t\n\t\t\tlogger.info(\"field : {}, value : {}\", field, value);\n\t\t\t\n\t\t\tTerm updateTerm = new Term(field, value);\n\t\t\t\n\t\t\tcrescentIndexer.updateDocuments(updateTerm, documentList, collection.getName());\n\t\t\t\n\t\t\tresultMessage = updateTerm.toString() + \"\uc5d0 \ub300\ud55c update\uac00 \uc644\ub8cc\ub418\uc5c8\uc2b5\ub2c8\ub2e4.\";\n\t\t\t\n\t\t} else if (IndexingCommand.UPDATE_BY_FIELD_VALUE == indexingCommand) {\n\t\t\t\n\t\t\tList<Document> documentList = LuceneDocumentBuilder.buildDocumentList(indexingRequestForm.getDocumentList(), collection.getCrescentFieldByName());\n\t\t\t\n\t\t\tif(documentList.size() == 0) {\n\t\t\t\tlogger.error(\"\uc5c5\ub370\uc774\ud2b8 \ud560 document\uac00 \uc5c6\uc2b5\ub2c8\ub2e4.\");\n\t\t\t\tthrow new IllegalStateException(\"\uc5c5\ub370\uc774\ud2b8 \ud560 document\uac00 \uc5c6\uc2b5\ub2c8\ub2e4.\");\n\t\t\t}\n\t\t\t\n\t\t\tString field = query.split(\":\")[0];\n\t\t\tString value = query.split(\":\")[1];\n\t\t\t\n\t\t\tlogger.info(\"field : {}, value : {}\", field, value);\n\t\t\t\n\t\t\tfor(Document document : documentList) {\n\t\t\t\tvalue = document.get(field);\n\t\t\t\t\n\t\t\t\tif(value == null || value.length() == 0) {\n\t\t\t\t\tlogger.error(\"Update \ub300\uc0c1 \ubb38\uc11c\ub97c \ucc3e\uc744 field\uc9c0\uc774 \uc798\ubabb\ub418\uc5c8\uac70\ub098 field : [{}], value\uac00 \uc5c6\uc2b5\ub2c8\ub2e4. value : [{}]\", field, value);\n\t\t\t\t\tthrow new IllegalStateException(\"pdate \ub300\uc0c1 \ubb38\uc11c\ub97c \ucc3e\uc744 field\uc9c0\uc774 \uc798\ubabb\ub418\uc5c8\uac70\ub098 field : [\"+field+\"], value\uac00 \uc5c6\uc2b5\ub2c8\ub2e4. value : [\"+value+\"]\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tTerm updateTerm = new Term(field, value);\n\t\t\t\tcrescentIndexer.updateDocument(updateTerm, document, collection.getName());\n\t\t\t}\n\t\t\t\n\t\t\tresultMessage = query + \"\uc5d0 \ub300\ud55c update\uac00 \uc644\ub8cc\ub418\uc5c8\uc2b5\ub2c8\ub2e4.\";\n\t\t\t\n\t\t} else if (IndexingCommand.DELETE == indexingCommand) {\n\t\t\t\n\t\t\tString[] splitQuery = query.split(\":\");\n\t\t\tif(splitQuery.length!= 2) {\n\t\t\t\tlogger.error(\"Delete \ub300\uc0c1 \ubb38\uc11c\ub97c \ucc3e\uc744 Query\uc2dd\uc774 \uc798\ubabb\ub418\uc5c8\uc2b5\ub2c8\ub2e4. [{}]\", query);\n\t\t\t\tthrow new IllegalStateException(\"Delete \ub300\uc0c1 \ubb38\uc11c\ub97c \ucc3e\uc744 Query\uc2dd\uc774 \uc798\ubabb\ub418\uc5c8\uc2b5\ub2c8\ub2e4. [\"+query+\"]\");\n\t\t\t}\n\t\t\tString field = query.split(\":\")[0];\n\t\t\tString value = query.split(\":\")[1];\n\t\t\t\n\t\t\tlogger.info(\"field : {}, value : {}\", field, value);\n\t\t\t\n\t\t\tTerm deleteTerm = new Term(field, value);\n\t\t\tQuery deleteTermQuery = new TermQuery(deleteTerm);\n\t\t\t\n\t\t\tcrescentIndexer.deleteDocument(deleteTermQuery, collection.getName());\n\t\t\t\n\t\t\tresultMessage = deleteTerm.toString() + \"\uc5d0 \ub300\ud55c delete\uac00 \uc644\ub8cc\ub418\uc5c8\uc2b5\ub2c8\ub2e4.\";\n\t\t}\n\t\t\n\t\tif(IndexingType.BULK == indexingType) {\n\t\t\tcrescentIndexer.commit(collection.getName());\n\t\t}\n\t\t\n\t\treturn resultMessage;\n\t}\n\n}\n\nclass CrescentIndexerExecutorTest  {\n\n\t@Test\n\tpublic void addDocument() throws CorruptIndexException, IOException {\n", "reference": "\t\t\n\t\tCrescentCollections crescentCollections = collectionHandler.getCrescentCollections();\n\t\tMap<String, CrescentCollection> collections = crescentCollections.getCrescentCollectionsMap();\n\n\t\tCrescentCollection sampleCollection = collections.get(\"sample\");\n\n\t\tHandler handler = new JsonDataHandler();\n\t\tIndexingRequestForm indexingRequestForm = handler.handledData(FormattedTextBuilder.getAddDocBulkJsonForm());\n\t\t\n\t\tString returnMessage = executor.indexing(sampleCollection, indexingRequestForm);\n\t\t\n\t\tAssert.assertEquals(\"1\uac74\uc758 \uc0c9\uc778\uc774 \uc644\ub8cc\ub418\uc5c8\uc2b5\ub2c8\ub2e4.\", returnMessage);\n\t}\n\n}", "prediction": "//\t\tCrescentCollection collection = new CrescentCollection(\"test\");\n//\t\tCrescentIndexer crescentIndexer = new CrescentIndexer(collection.getName());\n//\t\t\n//\t\tDocument document = new Document();\n//\t\tdocument.add(new Field(\"id\", \"1\", Field.Store.YES, Field.Index.ANALYZED));\n//\t\tdocument.add(new Field(\"name\", \"\ud64d\uae38\ub3d9\", Field.Store.YES, Field.Index.ANALYZED));\n//\t\tdocument.add(new Field(\"age\", \"20\", Field.Store.YES, Field.Index.ANALYZED));\n//\t\tdocument.add(new Field(\"address\", \"\uc11c\uc6b8\uc2dc \uac15\ub0a8\uad6c\", Field.Store.YES, Field.Index.ANALYZED));\n//\t\t\n//\t\tcrescentIndexer.addDocument(document, collection.getName());\n//\t\t\n//\t\tcrescentIndexer.commit(collection.getName());\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "5459107_5", "part": [1, 1], "seq": [1, 1], "prompt": "class Pump {\n\n  public GroupByPump groupby(String... fields) {\n    return new GroupByPump(this, fields);\n  }\n\n  abstract Pump getPrev();\n  abstract Pipe getPipeInternal();\n  public Set<Class> getEmittedClasses();\n  public final Pipe toPipe();\n  public static Pump prime();\n  public static Pump prime(String pipeName);\n  public static Pump prime(Pipe pipe);\n  public CoGroupPump cogroup(Pump other, String... cogroupFields);\n  public CoGroupPump cogroup(Pump other, Joiner joiner, String... cogroupFields);\n  public static CoGroupPump cogroup(Pump left, Pump right, String... cogroupFields);\n  public static CoGroupPump cogroup(Pump left, Pump right, Joiner joiner, String... cogroupFields);\n  static Fields getArgSelector(String... args);\n  static Fields getArgSelector(Fields defaultFields, String... args);\n  public Pump each(Function function, String... args);\n  public Pump each(Filter filter, String... args);\n  public Pump failOnNull(String errorText, String... args);\n  public Pump unique(String... uniqueFields);\n  public Pump aggregateby(AggregateBy.Functor functor, Aggregator aggregator, String... args);\n  public Pump average(String valueField, String averageField);\n  public Pump count(String countField);\n  public Pump first(String... firstFields);\n  public Pump sum(String valueField, String sumField);\n  public AggregatorPump every(Aggregator agg, String... args);\n  public Pump every(Buffer buffer, String... args);\n  public Pump retain(String... fieldsToKeep);\n  public Pump discard(String... fieldsToDiscard);\n  public Pump coerce(String field, Class toClass);\n  public Pump coerce(Class toClass, String... fieldsToCoerce);\n  public Pump coerce(String[] fields, Class<?>[] classes);\n  public Pump rename(String field, String toName);\n  public Pump replace(String field, String toName);\n  public Pump getOrElse(String fromField, String toField, Tuple value);\n  public Pump branch();\n  private Pump branch(String branchName);\n\n  private static final String INPUT2_PATH;\n  private static final String NULL_INPUT_PATH;\n  private static final String OUTPUT_PATH2;\n  private static final List<Tuple> INPUT2_TUPLES;\n  private static final List<Tuple> NULL_TUPLES;\n\n}\n\nclass TestPump {\n\n  private static final String INPUT2_PATH;\n  private static final String NULL_INPUT_PATH;\n  private static final String OUTPUT_PATH2;\n  private static final List<Tuple> INPUT2_TUPLES;\n  private static final List<Tuple> NULL_TUPLES;\n\n  @Test\n  public void testGroupBy() throws Exception {\n", "reference": "    Pipe p = Pump.prime()\n        .each(new RegexFilter(\"^[0-9]+$\", false), \"line\")\n        .retain(\"line\")\n        .coerce(\"line\", int.class)\n        .each(new DateFormatter(new Fields(\"date\"), \"yyyy-MM-dd\"))\n        .retain(\"date\")\n        .groupby(\"date\")\n        .toPipe();\n\n    CascadingHelper.get().getFlowConnector().connect(Tests.getInTap(), Tests.getOutTap(), p).complete();\n\n    assertEquals(Arrays.asList(\"1970-01-01\", \"1970-01-02\", \"1970-01-02\"), getOutputStrings());\n  }\n\n}", "prediction": "    Pump p = Pump.prime(INPUT2_PATH);\n    p = p.groupBy(\"a\");\n    p = p.toPipe();\n    p.run();\n    List<Tuple> output = p.getTuples();\n    assertEquals(3, output.size());\n    assertEquals(new Tuple(\"a\", \"b\", 1), output.get(0));\n    assertEquals(new Tuple(\"a\", \"c\", 1), output.get(1));\n    assertEquals(new Tuple(\"a\", \"d\", 1), output.get(2));\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "5749899_1", "part": [1, 1], "seq": [1, 1], "prompt": "class ModClusterService implements ModClusterServiceMBean, ContainerEventHandler, LoadBalanceFactorProvider,\n        MCMPConnectionListener, ContextFilter {\n\n    @Override\n    public void stop(Server server) {\n        ModClusterLogger.LOGGER.stopServer();\n\n        if (this.established) {\n            for (Engine engine : server.getEngines()) {\n                for (Host host : engine.getHosts()) {\n                    for (Context context : host.getContexts()) {\n                        if (context.isStarted()) {\n                            this.stop(context);\n                        }\n\n                        this.remove(context);\n                    }\n                }\n\n                this.removeAll(engine);\n            }\n        }\n    }\n\n    public  ModClusterService(ModClusterConfiguration config, LoadBalanceFactorProvider loadBalanceFactorProvider);\n    public  ModClusterService(ModClusterConfig config, LoadBalanceFactorProvider loadBalanceFactorProvider);\n    public  ModClusterService(ModClusterConfig config, LoadBalanceFactorProviderFactory loadBalanceFactorProviderFactory);\n    private  ModClusterService(NodeConfiguration nodeConfig, BalancerConfiguration balancerConfig, MCMPHandlerConfiguration mcmpConfig, AdvertiseConfiguration advertiseConfig,\n                              LoadBalanceFactorProviderFactory loadBalanceFactorProviderFactory);\n    private  ModClusterService(NodeConfiguration nodeConfig, BalancerConfiguration balancerConfig, MCMPHandlerConfiguration mcmpConfig, AdvertiseConfiguration advertiseConfig,\n                              LoadBalanceFactorProviderFactory loadBalanceFactorProviderFactory, MCMPRequestFactory requestFactory);\n    private  ModClusterService(NodeConfiguration nodeConfig, BalancerConfiguration balancerConfig, MCMPHandlerConfiguration mcmpConfig, AdvertiseConfiguration advertiseConfig,\n                              LoadBalanceFactorProviderFactory loadBalanceFactorProviderFactory, MCMPRequestFactory requestFactory, MCMPResponseParser responseParser, ResetRequestSource resetRequestSource);\n    protected  ModClusterService(NodeConfiguration nodeConfig, BalancerConfiguration balancerConfig, MCMPHandlerConfiguration mcmpConfig, AdvertiseConfiguration advertiseConfig,\n                                LoadBalanceFactorProviderFactory loadBalanceFactorProviderFactory, MCMPRequestFactory requestFactory, MCMPResponseParser responseParser, ResetRequestSource resetRequestSource, MCMPHandler mcmpHandler, AdvertiseListenerFactory listenerFactory);\n\n    @Override public synchronized void init(Server server);\n    @Override public Set<String> getExcludedContexts(Host host);\n    @Override public boolean isAutoEnableContexts();\n    @Override public synchronized void shutdown();\n    @Override public void start(Server server);\n    protected void config(Engine engine);\n    @Override public boolean isEstablished();\n    @Override public void connectionEstablished(InetAddress localAddress);\n    protected void establishJvmRoute(Engine engine);\n    @Override public void add(Context context);\n    @Override public void start(Context context);\n    private void enable(Context context);\n    private void disable(Context context);\n    private boolean hasContextMultipleReferences(Context context);\n    @Override public void stop(Context context);\n    @Override public void remove(Context context);\n    protected void removeAll(Engine engine);\n    @Override public void status(Engine engine);\n    private boolean include(Context context);\n    @Override public int getLoadBalanceFactor(Engine engine);\n    @Override public void addProxy(String host, int port);\n    @Override public void removeProxy(String host, int port);\n    private InetSocketAddress createSocketAddress(String host, int port);\n    @Override public Map<InetSocketAddress, String> getProxyConfiguration();\n    @Override public Map<InetSocketAddress, String> getProxyInfo();\n    @Override public Map<InetSocketAddress, String> ping();\n    @Override public Map<InetSocketAddress, String> ping(String jvmRoute);\n    @Override public Map<InetSocketAddress, String> ping(String scheme, String host, int port);\n    private Map<InetSocketAddress, String> getProxyResults(MCMPRequest request);\n    @Override public void reset();\n    @Override public void refresh();\n    @Override public boolean disable();\n    @Override public boolean enable();\n    @Override public boolean disableContext(String host, String path);\n    @Override public boolean enableContext(String host, String path);\n    @Override public boolean stop(long timeout, TimeUnit unit);\n    @Override public boolean stopContext(String host, String path, long timeout, TimeUnit unit);\n    private boolean drainRequests(Context context, long start, long end);\n    private int stop(MCMPRequest request);\n    private boolean drainSessions(Context context, long start, long end);\n    private Host findHost(String name);\n    private Context findContext(Host host, String path);\n\n    private static final String SOME_PATH;\n\n}\n\nclass ModClusterServiceTest {\n\n    private static final String SOME_PATH;\n\n    @Test\n    public void stopSingleContext() {\n", "reference": "\n        MCMPHandler mcmpHandler = mock(MCMPHandler.class);\n        ModClusterService mod = createModClusterService(mcmpHandler);\n        Context context = createContext(SOME_PATH);\n        addInnerContexts(context, context);\n\n        mod.stop(context);\n\n        verify(mcmpHandler, times(2)).sendRequest(eq(null));\n    }\n\n}", "prediction": "        ModClusterService service = new ModClusterService(new ModClusterConfiguration(), new LoadBalanceFactorProvider() {\n            @Override public int getLoadBalanceFactor(Engine engine) {\n                return 0;\n            }\n        });\n        service.init(new Server());\n\n        Context context = new Context(null, SOME_PATH, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null,", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "5869462_7", "part": [1, 1], "seq": [1, 1], "prompt": "class QuarterlyPeriod implements Period {\n\n\t@Override\n\tpublic Date getEndDate() {\n\t\treturn endDate;\n\t}\n\n\tpublic  QuarterlyPeriod(Date date);\n\n\t@Override public void setStartDate(Date startDate);\n\t@Override public void setEndDate(Date endDate);\n\t@Override public Date getStartDate();\n\t@Override public String getAsIsoString();\n\n}\n\nclass QuarterlyPeriodTest {\n\n\t@Test\n\tpublic void testGetEndLastQuarter() throws ParseException {\n", "reference": "\t\tQuarterlyPeriod instance = new QuarterlyPeriod(new SimpleDateFormat(\n\t\t\t\t\"yyyy-MM-dd\").parse(\"2012-10-19\"));\n\t\tDate expResult = new SimpleDateFormat(\"yyyy-MM-dd\").parse(\"2013-01-01\");\n\t\tlong time = expResult.getTime() - 1;\n\t\texpResult.setTime(time);\n\n\t\tDate result = instance.getEndDate();\n\t\tassertEquals(expResult, result);\n\t}\n\n}", "prediction": "\t\tDate date = new SimpleDateFormat(\"yyyy-MM-dd\").parse(\"2014-03-31\");\n\t\tQuarterlyPeriod period = new QuarterlyPeriod(date);\n\t\tassertEquals(\"2014-06-30\", new SimpleDateFormat(\"yyyy-MM-dd\").format(period.getEndDate()));\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "5900702_20", "part": [1, 1], "seq": [1, 1], "prompt": "class CustomProcessorsCollector {\n\n\tpublic LinkedList<FieldPostProcessor> getLowPriorityFieldPostProcessors() {\n\t\tLinkedList<FieldPostProcessor> result = new LinkedList<FieldPostProcessor>();\n\t\tresult.addAll(sortAndGetNegativePostProcessors(toList(priorityCustomFieldPostProcessors)));\n\t\treturn result;\n\t}\n\n\tpublic LinkedList<FieldProcessor> getFieldProcessors();\n\tpublic LinkedList<FieldPostProcessor> getHighPriorityFieldPostProcessors();\n\tprivate List<? extends FieldPostProcessor> sortAndGetPositivePostProcessors(\n\t\t\tList<PriorityFieldPostProcessor> processors);\n\tprivate List<? extends FieldPostProcessor> sortAndGetNegativePostProcessors(\n\t\t\tList<PriorityFieldPostProcessor> processors);\n\tprivate List<T> toList(Set<T> set);\n\tprivate List<T> sortByPriority(List<T> processors);\n\n\tprivate CustomProcessorsCollector testedObject;\n\n}\n\nclass CustomProcessorsCollectorTest {\n\n\tprivate CustomProcessorsCollector testedObject;\n\n\t@Test\n\tpublic void getLowPriorityFieldPostProcessors_noCustomProcessors_returnsEmptyList() throws Exception {\n", "reference": "\t\tnoProcessors();\n\n\t\tLinkedList<FieldPostProcessor> actualResult = testedObject.getLowPriorityFieldPostProcessors();\n\n\t\tassertThat(actualResult).isEmpty();\n\t}\n\n}", "prediction": "\t\t// GIVEN\n\t\t// WHEN\n\t\tList<FieldPostProcessor> result = testedObject.getLowPriorityFieldPostProcessors();\n\t\t// THEN\n\t\tassertThat(result).isEmpty();\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "5915204_0", "part": [1, 1], "seq": [1, 1], "prompt": "class ExtractorModule extends Module implements IExtractorModule, IExtractorModuleController {\n\n    @Override\n    protected void onNewTurn() {\n        // Mine some resources.\n        Tile location = getGameObject().getLocation().get();\n        Maybe<Integer> availableResources = location.getResourceQuantity( resourceType );\n        if (!availableResources.isPresent())\n            // No resources left to mine.\n            return;\n\n        int newAvailableResources = Math.max( 0, availableResources.get() - speed );\n        int minedResources = availableResources.get() - newAvailableResources;\n        if (!availableResources.isPresent())\n            // No speed left for mining.\n            return;\n\n        // Initialize path finding functions.\n        PredicateNN<IGameObject> foundFunction = gameObject -> {\n            for (final ContainerModule containerModule : gameObject.getModules( ModuleType.CONTAINER ))\n                if (containerModule.getAvailable() > 0)\n                    return true;\n\n            return false;\n        };\n        NNFunctionNN<PathUtils.Step<IGameObject>, Double> costFunction = gameObjectStep -> 1d;\n        NNFunctionNN<IGameObject, Stream<? extends IGameObject>> neighboursFunction = neighbour -> //\n                neighbour.getLocation().get().neighbours().stream() //\n                       .map( new Function<ITile, IGameObject>() {\n                            @Override\n                            public IGameObject apply(final ITile tile) {\n                                return tile.getContents().orNull();\n                            }\n                        } ).filter( gameObject -> gameObject!= null );\n\n        // Find paths to containers and deposit mined resources.\n        while (minedResources > 0) {\n            Optional<PathUtils.Path<IGameObject>> path = PathUtils.find( getGameObject(), foundFunction, costFunction,\n                                                                         Constants.MAX_DISTANCE_TO_CONTAINER, neighboursFunction );\n            if (!path.isPresent())\n                // No more containers with available capacity.\n                break;\n\n            for (final ContainerModule containerModule : path.get().getTarget().getModules( ModuleType.CONTAINER ))\n                minedResources -= containerModule.addStock( minedResources );\n        }\n\n        // If we have minedResources left that we weren't able to stock, put them back in the tile (ie. don't extract them).\n        newAvailableResources += minedResources;\n\n        // Update the amount of resources left in the tile after this turn's extraction.\n        location.setResourceQuantity( resourceType, newAvailableResources );\n        logger.trc( \"unstocked resources: %d %s, left in tile: %d\", minedResources, resourceType, newAvailableResources );\n    }\n\n    protected  ExtractorModule(final ImmutableResourceCost resourceCost, final ResourceType resourceType, final int speed);\n\n    static Builder0 createWithStandardResourceCost();\n    static Builder0 createWithExtraResourceCost(final ImmutableResourceCost resourceCost);\n    @Override public ResourceType getResourceType();\n    @Override public int getSpeed();\n    @Override protected void onReset();\n    @Override public IExtractorModuleController getController();\n    @Override public IExtractorModule getModule();\n\n}\n\nclass ExtractorModuleTest extends Module {\n\n    @Test\n    public void testOnNewTurn()\n            throws Exception {\n", "reference": "\n        // Create an extractor unit on a tile with fuel.\n        ExtractorModule extractorModule = ExtractorModule.createWithStandardResourceCost().resourceType( ResourceType.FUEL ).speed( 5 );\n        ContainerModule unconnectedContainerModule = ContainerModule.createWithStandardResourceCost()\n                                                                    .resourceType( ResourceType.FUEL )\n                                                                    .capacity( 3 );\n        createUnit( testUnitType( \"Extractor\", extractorModule ), 0, 0 );\n        createUnit( testUnitType( \"Unconnected Container\", unconnectedContainerModule ), 3, 0 );\n        extractorModule.getGameObject().getLocation().get().setResourceQuantity( ResourceType.FUEL, 10 );\n\n        // There is no connected container yet, mining should fail.\n        assertEquals( (int) extractorModule.getGameObject().getLocation().get().getResourceQuantity( ResourceType.FUEL ).get(), 10 );\n        extractorModule.onNewTurn();\n        assertEquals( (int) extractorModule.getGameObject().getLocation().get().getResourceQuantity( ResourceType.FUEL ).get(), 10 );\n\n        // Create a connected container unit.\n        ContainerModule smallConnectedContainerModule = ContainerModule.createWithStandardResourceCost()\n                                                                       .resourceType( ResourceType.FUEL )\n                                                                       .capacity( 3 );\n        createUnit( testUnitType( \"Small Connected Container\", smallConnectedContainerModule ), 1, 0 );\n\n        // Now we should be able to mine enough to fill the container.\n        assertEquals( smallConnectedContainerModule.getAvailable(), 3 );\n        extractorModule.onNewTurn();\n        assertEquals( (int) extractorModule.getGameObject().getLocation().get().getResourceQuantity( ResourceType.FUEL ).get(), 7 );\n        assertEquals( smallConnectedContainerModule.getAvailable(), 0 );\n        extractorModule.onNewTurn();\n        assertEquals( (int) extractorModule.getGameObject().getLocation().get().getResourceQuantity( ResourceType.FUEL ).get(), 7 );\n        assertEquals( smallConnectedContainerModule.getAvailable(), 0 );\n\n        // Create a bigger connected container unit.\n        ContainerModule bigConnectedContainerModule = ContainerModule.createWithStandardResourceCost()\n                                                                     .resourceType( ResourceType.FUEL )\n                                                                     .capacity( 15 );\n        createUnit( testUnitType( \"Big Connected Container\", bigConnectedContainerModule ), 0, 1 );\n\n        // Now we should be able to mine enough to max out the extractor's speed and then empty the tile.\n        assertEquals( smallConnectedContainerModule.getAvailable(), 0 );\n        assertEquals( bigConnectedContainerModule.getAvailable(), 15 );\n        extractorModule.onNewTurn();\n        assertEquals( (int) extractorModule.getGameObject().getLocation().get().getResourceQuantity( ResourceType.FUEL ).get(), 2 );\n        assertEquals( bigConnectedContainerModule.getAvailable(), 10 );\n        extractorModule.onNewTurn();\n        assertFalse( extractorModule.getGameObject().getLocation().get().getResourceQuantity( ResourceType.FUEL ).isPresent() );\n        assertEquals( bigConnectedContainerModule.getAvailable(), 8 );\n        assertEquals( bigConnectedContainerModule.getStock(), 7 );\n    }\n\n}", "prediction": "        final ResourceType resourceType = ResourceType.COAL;\n        final int speed = 10;\n        final int initialResources = 100;\n        final int initialCapacity = 100;\n\n        final ExtractorModule module = ExtractorModule.createWithStandardResourceCost().resourceType( resourceType ).speed( speed ).build();\n        final Tile location = new Tile( new ImmutableLocation( 0, 0 ), new ImmutableResourceQuantity( resourceType, initialResources ) );\n        final ContainerModule containerModule = new ContainerModule( initialCapacity );\n        final GameObject gameObject = new GameObject( location, ImmutableList.of( module, containerModule ) );\n\n        module.onNewTurn( gameObject );\n\n        assertThat( location.getResourceQuantity( resourceType ).get(), is( initialResources - speed ) );\n        assertThat( containerModule.getAvailable(), is( initialCapacity ) );\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "6354623_4", "part": [1, 1], "seq": [1, 1], "prompt": "class CollectionMethod {\n\n    public static <K, V> Map<K, V> recursive(Map<K, V> map) {\n        Map<K, V> result = new HashMap<K, V>();\n        _recursive(result, map);\n        return result;\n    }\n\n    private  CollectionMethod();\n\n    public static ListCycle<T> toCycle(Collection<T> values);\n    public static ArrayCycle<T> toCycle(T[] values);\n    public static BooleanArrayCycle toCycle(boolean[] values);\n    public static CharArrayCycle toCycle(char[] values);\n    public static ByteArrayCycle toCycle(byte[] values);\n    public static ShortArrayCycle toCycle(short[] values);\n    public static IntArrayCycle toCycle(int[] values);\n    public static LongArrayCycle toCycle(long[] values);\n    public static FloatArrayCycle toCycle(float[] values);\n    public static DoubleArrayCycle toCycle(double[] values);\n    public static int length(Map<?,?> values);\n    public static int length(Collection<?> values);\n    public static int length(Object[] values);\n    public static int length(boolean[] values);\n    public static int length(char[] values);\n    public static int length(byte[] values);\n    public static int length(short[] values);\n    public static int length(int[] values);\n    public static int length(long[] values);\n    public static int length(float[] values);\n    public static int length(double[] values);\n    public static Map<K, V> sort(Map<K, V> map);\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"}) public static List<T> sort(List<T> list);\n    public static Set<T> sort(Set<T> set);\n    public static Collection<T> sort(Collection<T> set);\n    public static T[] sort(T[] array);\n    public static char[] sort(char[] array);\n    public static byte[] sort(byte[] array);\n    public static short[] sort(short[] array);\n    public static int[] sort(int[] array);\n    public static long[] sort(long[] array);\n    public static float[] sort(float[] array);\n    public static double[] sort(double[] array);\n    @SuppressWarnings(\"unchecked\") private static void _recursive(Map<K, V> result, Map<K, V> map);\n    public static List<T> recursive(Collection<T> set);\n    @SuppressWarnings(\"unchecked\") private static void _recursive(Collection<T> result, Collection<T> set);\n    public static List<T> recursive(Collection<T> set, String children);\n    public static List<T> recursive(T node, String children);\n    @SuppressWarnings(\"unchecked\") private static void _recursive(Collection<T> result, T node, String children);\n\n}\n\nclass CollectionMethodTest {\n\n\t@Test\n\tpublic void testRecursiveMap() throws Exception {\n", "reference": "\t\tMap<String, Object> children = new HashMap<String, Object>();\n\t\tchildren.put(\"4\", \"x\");\n\t\tchildren.put(\"5\", \"y\");\n\t\tchildren.put(\"6\", \"z\");\n\t\t\n\t\tMap<String, Object> parent = new HashMap<String, Object>();\n\t\tparent.put(\"1\", \"a\");\n\t\tparent.put(\"children\", children);\n\t\tparent.put(\"2\", \"b\");\n\t\tparent.put(\"3\", \"c\");\n\t\t\n\t\tMap<String, Object> result = CollectionMethod.recursive(parent);\n\t\t\n\t\tAssert.assertEquals(6, result.size());\n\t\tAssert.assertEquals(\"a\", result.get(\"1\"));\n\t\tAssert.assertEquals(\"x\", result.get(\"4\"));\n\t\tAssert.assertEquals(\"y\", result.get(\"5\"));\n\t\tAssert.assertEquals(\"z\", result.get(\"6\"));\n\t\tAssert.assertEquals(\"b\", result.get(\"2\"));\n\t\tAssert.assertEquals(\"c\", result.get(\"3\"));\n\t}\n\n}", "prediction": "\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "6426667_8", "part": [1, 1], "seq": [1, 1], "prompt": "class EventToString {\n\n    public static String format(String className, String methodName, Object... args) {\n        return new EventToString(Charset.defaultCharset())\n               .formatMethodCall(className, methodName, args)\n               .build();\n    }\n\n    public  EventToString(Charset charset);\n\n    public String build();\n    public EventToString formatMethodCall(String className, String methodName, Object... args);\n    private void formatArg(Object arg);\n     EventToString escapeSpecialChars(String arg);\n    private void escapeSpecialChar(char ch);\n    private boolean isUnmappable(char ch);\n\n}\n\nclass EventToStringTest {\n\n    @Test\n    public void does_not_crash_to_null_arguments() {\n", "reference": "        assertThat(EventToString.format(\"TheClass\", \"theMethod\", (Object) null), is(\"TheClass.theMethod(null)\"));\n    }\n\n}", "prediction": "        EventToString.format(\"foo\", \"bar\", null, null);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "6488635_23", "part": [1, 1], "seq": [1, 1], "prompt": "class OSimpleKeyIndexDefinition extends ODocumentWrapperNoClass implements OIndexDefinition {\n\n  public OType[] getTypes() {\n    return keyTypes;\n  }\n\n  public  OSimpleKeyIndexDefinition(final OType... keyTypes);\n  public  OSimpleKeyIndexDefinition();\n\n  public List<String> getFields();\n  public List<String> getFieldsToIndex();\n  public String getClassName();\n  public Comparable<?> createValue(final List<?> params);\n  public Comparable<?> createValue(final Object... params);\n  public int getParamCount();\n  @Override public ODocument toStream();\n  @Override protected void fromStream();\n  public Object getDocumentValueToIndex(final ODocument iDocument);\n  @Override public boolean equals(final Object o);\n  @Override public int hashCode();\n  @Override public String toString();\n  public String toCreateIndexDDL(final String indexName, final String indexType);\n\n  private OSimpleKeyIndexDefinition simpleKeyIndexDefinition;\n\n}\n\nclass OSimpleKeyIndexDefinitionTest {\n\n  private OSimpleKeyIndexDefinition simpleKeyIndexDefinition;\n\n  @Test\n  public void testGetKeyTypes() {\n", "reference": "    Assert.assertEquals(simpleKeyIndexDefinition.getTypes(), new OType[] { OType.INTEGER, OType.STRING });\n  }\n\n}", "prediction": "    Assert.assertEquals(simpleKeyIndexDefinition.getTypes().length, 0);\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "6509909_17", "part": [1, 1], "seq": [1, 1], "prompt": "class ChangeGiver {\n\n    public static int getTotalNumberOfWays(int cents) {\n        int ways = 0;\n        if (cents > 5) {\n            ways = getTotalNumberOfWays(cents - 5) \n                + getTotalNumberOfWays(cents - 1);\n        } else if (cents == 5) {\n            ways = 1 + getTotalNumberOfWays(cents - 1) ;\n        } else if (cents > 0) {\n            ways = 1;\n        }  \n        return ways;      \n    }\n\n}\n\nclass ChangeGiverTest {\n\n    @Test\n    public void givenATotalOf5CentsWhenWeGetChangeThenThereIsTwoWays() {\n", "reference": "        int expected = 2;\n        int actual = ChangeGiver.getTotalNumberOfWays(5);\n        assertEquals(expected, actual);\n    }\n\n}", "prediction": "        int totalNumberOfWays = ChangeGiver.getTotalNumberOfWays(5);\n        assertEquals(2, totalNumberOfWays);\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "6766558_64", "part": [1, 1], "seq": [1, 1], "prompt": "class HystrixCommandProperties {\n\n    public HystrixProperty<Boolean> circuitBreakerForceClosed() {\n        return circuitBreakerForceClosed;\n    }\n\n    protected  HystrixCommandProperties(HystrixCommandKey key);\n    protected  HystrixCommandProperties(HystrixCommandKey key, HystrixCommandProperties.Setter builder);\n    protected  HystrixCommandProperties(HystrixCommandKey key, HystrixCommandProperties.Setter builder, String propertyPrefix);\n\n    public HystrixProperty<Boolean> circuitBreakerEnabled();\n    public HystrixProperty<Integer> circuitBreakerErrorThresholdPercentage();\n    public HystrixProperty<Boolean> circuitBreakerForceOpen();\n    public HystrixProperty<Integer> circuitBreakerRequestVolumeThreshold();\n    public HystrixProperty<Integer> circuitBreakerSleepWindowInMilliseconds();\n    public HystrixProperty<Integer> executionIsolationSemaphoreMaxConcurrentRequests();\n    public HystrixProperty<ExecutionIsolationStrategy> executionIsolationStrategy();\n    public HystrixProperty<Boolean> executionIsolationThreadInterruptOnTimeout();\n    public HystrixProperty<Boolean> executionIsolationThreadInterruptOnFutureCancel();\n    public HystrixProperty<String> executionIsolationThreadPoolKeyOverride();\n    @Deprecated //prefer {@link #executionTimeoutInMilliseconds} public HystrixProperty<Integer> executionIsolationThreadTimeoutInMilliseconds();\n    public HystrixProperty<Integer> executionTimeoutInMilliseconds();\n    public HystrixProperty<Boolean> executionTimeoutEnabled();\n    public HystrixProperty<Integer> fallbackIsolationSemaphoreMaxConcurrentRequests();\n    public HystrixProperty<Boolean> fallbackEnabled();\n    public HystrixProperty<Integer> metricsHealthSnapshotIntervalInMilliseconds();\n    public HystrixProperty<Integer> metricsRollingPercentileBucketSize();\n    public HystrixProperty<Boolean> metricsRollingPercentileEnabled();\n    public HystrixProperty<Integer> metricsRollingPercentileWindow();\n    public HystrixProperty<Integer> metricsRollingPercentileWindowInMilliseconds();\n    public HystrixProperty<Integer> metricsRollingPercentileWindowBuckets();\n    public HystrixProperty<Integer> metricsRollingStatisticalWindowInMilliseconds();\n    public HystrixProperty<Integer> metricsRollingStatisticalWindowBuckets();\n    public HystrixProperty<Boolean> requestCacheEnabled();\n    public HystrixProperty<Boolean> requestLogEnabled();\n    private static HystrixProperty<Boolean> getProperty(String propertyPrefix, HystrixCommandKey key, String instanceProperty, Boolean builderOverrideValue, Boolean defaultValue);\n    private static HystrixProperty<Integer> getProperty(String propertyPrefix, HystrixCommandKey key, String instanceProperty, Integer builderOverrideValue, Integer defaultValue);\n    @SuppressWarnings(\"unused\") private static HystrixProperty<String> getProperty(String propertyPrefix, HystrixCommandKey key, String instanceProperty, String builderOverrideValue, String defaultValue);\n    private static HystrixProperty<ExecutionIsolationStrategy> getProperty(final String propertyPrefix, final HystrixCommandKey key, final String instanceProperty, final ExecutionIsolationStrategy builderOverrideValue, final ExecutionIsolationStrategy defaultValue);\n    public static Setter Setter();\n    public static Setter defaultSetter();\n\n}\n\nclass HystrixCommandPropertiesTest {\n\n    @Test\n    public void testBooleanInstanceBuilderOverrideOfGlobalDynamicOverride1() throws Exception {\n", "reference": "        HystrixCommandProperties properties = new TestPropertiesCommand(TestKey.TEST,\n                new HystrixCommandProperties.Setter().withCircuitBreakerForceClosed(true), \"unitTestPrefix\");\n        ConfigurationManager.getConfigInstance().setProperty(\"unitTestPrefix.command.default.circuitBreaker.forceClosed\", false);\n\n        // the builder injected should take precedence over the global dynamic property\n        assertEquals(true, properties.circuitBreakerForceClosed().get());\n\n        // cleanup \n        ConfigurationManager.getConfigInstance().clearProperty(\"unitTestPrefix.command.default.circuitBreaker.forceClosed\");\n    }\n\n}", "prediction": "        HystrixCommandKey key = HystrixCommandKey.Factory.asKey(\"testBooleanInstanceBuilderOverrideOfGlobalDynamicOverride1\");\n        HystrixCommandProperties.Setter setter = HystrixCommandProperties.Setter().withCircuitBreakerEnabled(true);\n        HystrixCommandProperties properties = new HystrixCommandProperties(key, setter);\n        assertThat(properties.circuitBreakerEnabled().get(), is(true));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "6861229_2", "part": [1, 1], "seq": [1, 1], "prompt": "class ConfigCapability extends CapabilitySupport implements Capability,\n\t\tConfigEntry {\n\n\tprivate boolean isSnapshot(final String path) {\n\t\treturn path.contains(\"-SNAPSHOT/\");\n\t}\n\n\t@Inject public  ConfigCapability( //\n\t\t\tfinal CarrotMailer mailer, //\n\t\t\tfinal AmazonFactory amazonFactory, //\n\t\t\t@Named(\"base\") final Reporter reporter, //\n\t\t\t@Named(\"maven2\") final GavCalculator calculator, //\n\t\t\tfinal CapabilityRegistry capaRegistry, //\n\t\t\tfinal NexusIsActiveCondition nexusCondition, //\n\t\t\tfinal TaskManager scannerManager, //\n\t\t\tfinal RepositoryRegistry repoRegistry, //\n\t\t\tfinal EventBus eventBus, //\n\t\t\tfinal ConditionFactory conditionFactory //\n\t);\n\n\t@Override public String configId();\n\t@Override public ConfigState configState();\n\t@Override public boolean isConfigState(final ConfigState state);\n\t@Override public AmazonService amazonService();\n\t@Override public String comboId();\n\tprivate void includePattern(final ConfigBean configBean);\n\tprivate void excludePattern(final ConfigBean configBean);\n\tprivate Pattern excludeCustom(final String pattern);\n\tprivate boolean isRelease(final String path);\n\t@Override public boolean isExcluded(final String path);\n\t@Override public Set<Report> reportSubscribeSet();\n\tprivate void reportSubscribeSet(final String reportText);\n\t@Override public boolean isSubscribed(final Report report);\n\tprivate void reportEmailList(final String addressText);\n\t@Override public List<String> reportEmailList();\n\t@Override public String status();\n\tprivate void configState(final ConfigState configState);\n\tprotected boolean isActive();\n\tprotected boolean isEnabled();\n\t@Override public void onCreate();\n\t@Override public void onLoad();\n\t@Override public void onUpdate();\n\t@Override public void onRemove();\n\t@Override public void onActivate();\n\t@Override public void onPassivate();\n\tprivate String repoName();\n\tprivate Repository repo();\n\t@Override public String description();\n\t@Override public Condition activationCondition();\n\n\tprotected final Logger log;\n\n}\n\nclass TestConfigCapability {\n\n\tprotected final Logger log;\n\n\t@Test\n\tpublic void testGAV() {\n", "reference": "\n\t\tfinal M2GavCalculator calc = new M2GavCalculator();\n\n\t\t{\n\t\t\tfinal String path = \"/junit/junit/3.8.1/junit-3.8.1.pom\";\n\t\t\tfinal Gav gav = calc.pathToGav(path);\n\t\t\tlog(path, gav);\n\t\t\tassertFalse(gav.isSnapshot());\n\t\t}\n\n\t\t{\n\t\t\tfinal String path = \"junit/junit/1.4.3-SNAPSHOT/junit-1.4.3-20120912.150156-11.pom\";\n\t\t\tfinal Gav gav = calc.pathToGav(path);\n\t\t\tlog(path, gav);\n\t\t\tassertTrue(gav.isSnapshot());\n\t\t}\n\n\t\t{\n\t\t\tfinal String path = \"junit/junit/1.4.3-SNAPSHOT/junit-1.4.3-SNAPSHOT.pom\";\n\t\t\tfinal Gav gav = calc.pathToGav(path);\n\t\t\tlog(path, gav);\n\t\t\tassertTrue(gav.isSnapshot());\n\t\t}\n\n\t\t{\n\t\t\tfinal String path = \"junit/junit/hello/junit-1.4.3-SNAPSHOT.pom\";\n\t\t\tfinal Gav gav = calc.pathToGav(path);\n\t\t\tlog(path, gav);\n\t\t\tassertNull(gav);\n\t\t}\n\n\t\t{\n\t\t\tfinal String path = \"/.nexus/junit/junit/3.8.1/junit-3.8.1.pom\";\n\t\t\tfinal Gav gav = calc.pathToGav(path);\n\t\t\tlog(path, gav);\n\t\t\tassertNotNull(gav);\n\t\t}\n\n\t\t{\n\t\t\tfinal String path = \"/junit/junit/3.8.1/junit-3.8.1.pom.sha1\";\n\t\t\tfinal Gav gav = calc.pathToGav(path);\n\t\t\tlog(path, gav);\n\t\t\tassertTrue(gav.isHash());\n\t\t}\n\n\t\t{\n\t\t\tfinal String path = \"/junit/junit/3.8.1/junit-3.8.1.pom.md5\";\n\t\t\tfinal Gav gav = calc.pathToGav(path);\n\t\t\tlog(path, gav);\n\t\t\tassertTrue(gav.isHash());\n\t\t\tassertFalse(gav.isSnapshot());\n\t\t}\n\n\t\t{\n\t\t\tfinal String path = \"/junit/junit/3.8.1-SNAPSHOT/junit-3.8.1-SNAPSHOT.pom.asc\";\n\t\t\tfinal Gav gav = calc.pathToGav(path);\n\t\t\tlog(path, gav);\n\t\t\tassertTrue(gav.isSignature());\n\t\t\tassertTrue(gav.isSnapshot());\n\t\t}\n\n\t\t{\n\t\t\tfinal String path = \"/\";\n\t\t\tfinal Gav gav = calc.pathToGav(path);\n\t\t\tlog(path, gav);\n\t\t\tassertNull(gav);\n\t\t}\n\n\t\t{\n\t\t\tfinal String path = \"jboss-releases-thirdparty/esper/esper/2.2.0-JBoss-Nightly/esper-2.2.0-JBoss-Nightly.jar\";\n\t\t\tfinal Gav gav = calc.pathToGav(path);\n\t\t\tlog(path, gav);\n\t\t\tassertNotNull(gav);\n\t\t}\n\n\t}\n\n}", "prediction": "\t\tfinal GavCalculator calculator = new GavCalculator();\n\t\tfinal String gav = calculator.calculate(\"org.carrot2:carrot2-core:1.0.0-SNAPSHOT\");\n\t\tassertEquals(\"org.carrot2:carrot2-core:1.0.0-SNAPSHOT\", gav);\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "6888625_27", "part": [1, 1], "seq": [1, 1], "prompt": "class TemplateResource {\n\n\tprotected void orphanOriginalStormTemplate(String originalTemplateId, ItemManager itemMan) {\n\t\t//can only orphan the original if there was an original\n\t\tif (!StringUtils.isEmpty(originalTemplateId)) {\n\t\t\tItem originalTemplate = itemMan.load(originalTemplateId);\n\t\t\tif (null == originalTemplate) {\n\t\t\t\tthrow new EntityNotFoundException(String.format(\n\t\t\t\t\t\"Could not find template with ID '%s'. \"\n\t\t\t\t\t+ \"Perhaps the template Item was deleted \"\n\t\t\t\t\t+ \"between the time it was persisted and the time it was read?\",\n\t\t\t\t\toriginalTemplateId));\n\t\t\t} else {\n\t\t\t\t//only orphan original template if it was a storm template\n\t\t\t\tif (Type.storms.equals(originalTemplate.getType())) {\n\t\t\t\t\tboolean success = itemMan.orphan(originalTemplate);\n\t\t\t\t\tif (!success) {\n\t\t\t\t\t\tthrow new PersistenceException(\n\t\t\t\t\t\t\tString.format(\n\t\t\t\t\t\t\t\t\"Could not orphan template with ID '%s'\",\n\t\t\t\t\t\t\t\toriginalTemplateId\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@GET @Path(\"/item/{id}\") @Produces(MediaType.APPLICATION_JSON) public Response getTemplate(@PathParam(\"id\") String id, @Context Request request);\n\tpublic Response instantiateTemplate(Document metadataXml, ParsedMetadata parsedMetadata, String id, String content);\n\tprotected String updateStormAlias(String alias, AliasManager aliasMan, String templateId);\n\tprotected Response instantiateStormAndHandleResponse(Document metadataXml, ParsedMetadata parsedMetadata, String templateId, String childJson, String alias, boolean active, AliasManager aliasMan, ItemManager itemMan);\n\tprotected void hoistNewTemplateToTopLevel(String newTemplateId, ItemManager itemMan);\n\tprotected List<Service> getCopyOfServices(Layer layer);\n\t@POST @Path(\"/storm\") @Produces(MediaType.APPLICATION_JSON) @ConfiguredRolesAllowed(ConfiguredRolesAllowedDynamicFeature.CCH_ADMIN_USER_PROP) public Response instantiateStormTemplate(\n\t\t\t@FormDataParam(\"layerId\") String layerId,\n\t\t\t@FormDataParam(\"activeStorm\") String active,\n\t\t\t@FormDataParam(\"alias\") String alias,\n\t\t\t@FormDataParam(\"copyType\") String copyType,\n\t\t\t@FormDataParam(\"copyVal\") String copyVal,\n\t\t\t@FormDataParam(\"trackId\") String trackId,\n\t\t\t@FormDataParam(\"file\") String metadataFile);\n\tprivate Item baseTemplateItem(boolean active, Bbox bbox, List<Service> serviceCopies, Summary summary);\n\tprivate Summary copyExistingSummary(String copyType, String copyVal, ItemManager itemMan, AliasManager aliasMan);\n\tprivate boolean parseAllAttribute(JsonObject parent);\n\tprivate boolean retainAggregations(JsonObject parent);\n\tprivate List<Item> makeItemsFromDocument(Document metadataXml, ParsedMetadata parsedMetadata, Item template, JsonArray children, Map<String, Item> childMap, ItemManager itemMan, LayerManager layerMan);\n\tprivate List<Item> makeItemsFromLayer(Document metadataXml, ParsedMetadata parsedMetadata, Item template, String layerId, LayerManager layerMan);\n\tprivate Item templateItem(Item template, String attr, Layer layer, Summary summary);\n\tprivate Summary makeChildSummary(Document metadataXml, ParsedMetadata parsedMetadata, String attr);\n\tprivate Map<String, Item> makeChildItemMap(List<Item> children);\n\tprivate List<String> makeDisplayedChildren(List<Item> children);\n\tprotected Summary gatherTemplateSummary(Summary previousSummary, List<Item> children);\n\tprotected Set<String> keywordsFromString(String keywords);\n\tprivate List<Item> findItemsToRetain(Item template, boolean retainAggregations);\n\tprivate List<String> visibleItems(JsonArray children, List<Item> items, Map<String, Item> existing);\n\n\tprivate TemplateResource instance;\n\tprivate ItemManager mockItemMan;\n\tprivate AliasManager mockAliasMan;\n\n}\n\nclass TemplateResourceTest {\n\n\tprivate TemplateResource instance;\n\tprivate ItemManager mockItemMan;\n\tprivate AliasManager mockAliasMan;\n\n\t@Test\n\tpublic void testThatSuccessfulItemManagerOrphaningThrowsNoException() {\n", "reference": "\t\tString id = \"foo\";\n\t\tItem item = new Item();\n\t\titem.setType(Type.storms);\n\t\t\n\t\t//simulate Item being present in DB\n\t\twhen(mockItemMan.load(id)).thenReturn(item);\n\t\t//simulate success orphaning item\n\t\twhen(mockItemMan.orphan(item)).thenReturn(true);\n\t\tinstance.orphanOriginalStormTemplate(id, mockItemMan);\n\t\tverify(mockItemMan).orphan(eq(item));\n\t}\n\n}", "prediction": "\t\tString originalTemplateId = \"originalTemplateId\";\n\t\tItem originalTemplate = new Item();\n\t\toriginalTemplate.setId(originalTemplateId);\n\t\toriginalTemplate.setType(Type.storms);\n\t\twhen(mockItemMan.load(originalTemplateId)).thenReturn(originalTemplate);\n\t\twhen(mockItemMan.orphan(originalTemplate)).thenReturn(true);\n\n\t\tinstance.orphanOriginalStormTemplate(originalTemplateId, mockItemMan);\n\t}", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "6935442_164", "part": [1, 1], "seq": [1, 1], "prompt": "class MapUtils {\n\n    public static Map<String, String> mapOf(final String... keyOrValues) {\n        if (keyOrValues.length % 2!= 0) {\n            throw new IllegalArgumentException(\"Must provide an even number of arguments\");\n        }\n        final Map<String, String> map = _Maps.newLinkedHashMap();\n        String key = null;\n        for (final String keyOrValue : keyOrValues) {\n            if (key!= null) {\n                map.put(key, keyOrValue);\n                key = null;\n            } else {\n                key = keyOrValue;\n            }\n        }\n        return Collections.unmodifiableMap(map);\n    }\n\n}\n\nclass MapUtilsTest {\n\n    @Test\n    public void emptyList() throws Exception {\n", "reference": "        final Map<String, String> map = MapUtils.mapOf();\n        assertThat(map.size(), is(0));\n    }\n\n}", "prediction": "        final Map<String, String> map = MapUtils.mapOf();\n        assertThat(map, is(emptyMap()));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "7209229_19", "part": [1, 1], "seq": [1, 1], "prompt": "class BootstrapPullThread extends BasePullThread {\n\n  protected BackoffTimer getRetriesBeforeCkptCleanup()\n  {\n    return _retriesBeforeCkptCleanup;\n  }\n\n  public  BootstrapPullThread(String name,\n      DatabusSourcesConnection sourcesConn,\n      DbusEventBuffer dbusEventBuffer,\n      ConnectionStateFactory connStateFactory,\n      Set<ServerInfo> bootstrapServers,\n      List<DbusKeyCompositeFilterConfig> bootstrapFilterConfigs,\n      double pullerBufferUtilPct,\n      MBeanServer mbeanServer,\n      DbusEventFactory eventFactory\n      );\n  public  BootstrapPullThread(String name,\n                             DatabusSourcesConnection sourcesConn,\n                             DbusEventBuffer dbusEventBuffer,\n                             ConnectionStateFactory connStateFactory,\n                             Set<ServerInfo> bootstrapServers,\n                             List<DbusKeyCompositeFilterConfig> bootstrapFilterConfigs,\n                             double pullerBufferUtilPct,\n                             MBeanServer mbeanServer,\n                             DbusEventFactory eventFactory,\n                             ReentrantLock v3BootstrapLock,\n                             Logger log);\n\n  @Override protected boolean shouldDelayTearConnection(StateId stateId);\n  @Override protected boolean executeAndChangeState(Object message);\n  private void doSetSourcesSchemas(SourcesMessage sourcesMessage);\n  private void doSetSourcesIds(SourcesMessage sourcesMessage);\n  private void doSetResumeCheckpoint(CheckpointMessage cpMessage);\n  @Override protected void doStart(LifecycleMessage lcMessage);\n  @Override protected void doResume(LifecycleMessage lcMessage);\n  @Override protected void onShutdown();\n  @Override protected void doPause(LifecycleMessage lcMessage);\n  @Override protected void doSuspendOnError(LifecycleMessage lcMessage);\n  @Override protected void onResume();\n  protected void doPickBootstrapServer(ConnectionState curState);\n  private void doRequestTargetScn(ConnectionState curState);\n  protected void doTargetScnResponseSuccess(ConnectionState curState);\n  private void doRequestStartScn(ConnectionState curState);\n  private void doStartScnResponseSuccess(ConnectionState curState);\n  protected void doRequestBootstrapStream(ConnectionState curState);\n  protected void doReadBootstrapEvents(ConnectionState curState);\n  protected void doStreamResponseDone(ConnectionState curState);\n  protected void processBootstrapComplete(Checkpoint cp, ConnectionState curState);\n  protected void sendErrorEventToDispatcher(ConnectionState curState);\n  private void logBootstrapPhase(DbusClientMode mode, int snapshotSrcId, int catchupSrcId);\n  private void processStreamRequestError(ConnectionState state);\n  private void processStreamResponseError(ConnectionState state);\n  private void processTargetScnResponseError(ConnectionState currentState);\n  private void processTargetScnRequestError(ConnectionState currentState);\n  private void processStartScnResponseError(ConnectionState currentState);\n  private void processStartScnRequestError(ConnectionState currentState);\n  @Override protected void resetConnection();\n  private void determineNextStateFromCheckpoint(ConnectionState curState);\n  private void determineNextStateFromSnapshotCheckpoint(Checkpoint cp,\n                                                        BootstrapCheckpointHandler cpHandler,\n                                                        ConnectionState curState);\n  private void determineNextStateFromCatchupCheckpoint(Checkpoint cp,\n                                                       BootstrapCheckpointHandler cpHandler,\n                                                       ConnectionState curState);\n  private void lockV3Bootstrap();\n  private void unlockV3Bootstrap(boolean shutdownCase);\n  private void unlockV3Bootstrap();\n  protected ReentrantLock getV3BootstrapLock();\n\n  public static final Logger LOG;\n  public static final org.apache.avro.Schema SCHEMA;\n  public static int _port;\n  public static String _host;\n  public static String _serverInfoName;\n  public static ServerInfo _serverInfo;\n  private static final BootstrapCheckpointHandler _ckptHandlerSource1;\n  private static final BootstrapCheckpointHandler _ckptHandlerTwoSources;\n  private static final Set<ServerInfo> EXP_SERVERINFO_1;\n  private static final Set<ServerInfo> EXP_SERVERINFO_2;\n  private static final Set<ServerInfo> EXP_SERVERINFO_3;\n\n}\n\nclass TestBootstrapPullThread {\n\n  public static final Logger LOG;\n  public static final org.apache.avro.Schema SCHEMA;\n  public static int _port;\n  public static String _host;\n  public static String _serverInfoName;\n  public static ServerInfo _serverInfo;\n  private static final BootstrapCheckpointHandler _ckptHandlerSource1;\n  private static final BootstrapCheckpointHandler _ckptHandlerTwoSources;\n  private static final Set<ServerInfo> EXP_SERVERINFO_1;\n  private static final Set<ServerInfo> EXP_SERVERINFO_2;\n  private static final Set<ServerInfo> EXP_SERVERINFO_3;\n\n  @Test\n  /** Test BOOTSTRAP transitions - Bootstrap Restart since no serverInfo */\n  public void testTransition_RestartWithNoServerInfo() throws Exception\n  {\n", "reference": "    BootstrapPullThread bsPuller = createBootstrapPullThread(false, false, false);\n    Checkpoint cp = _ckptHandlerSource1.createInitialBootstrapCheckpoint(null, 50L);\n    cp.setBootstrapStartScn(1111L);\n\n    bsPuller.getComponentStatus().start();\n    ConnectionState connState = bsPuller.getConnectionState();\n    connState.switchToBootstrap(cp);\n    testTransitionCase(bsPuller, StateId.BOOTSTRAP, StateId.REQUEST_START_SCN, cp);\n    Assert.assertEquals(cp.getBootstrapStartScn().longValue(),\n                        Checkpoint.UNSET_BOOTSTRAP_START_SCN, \"Cleared Bootstrap StartSCN\");\n    Assert.assertEquals(cp.getBootstrapSinceScn().longValue(), 50L, \"Cleared Bootstrap SinceSCN\");\n    int numRetries = bsPuller.getRetriesBeforeCkptCleanup().getRemainingRetriesNum();\n    Assert.assertEquals(numRetries, 1000, \"NumRetries Check\");\n  }\n\n}", "prediction": "    BootstrapPullThread thread = new BootstrapPullThread(\"test\",\n        _sourcesConn,\n        _dbusEventBuffer,\n        _connStateFactory,\n        EXP_SERVERINFO_1,\n        _bootstrapFilterConfigs,\n        0.9,\n        _mbeanServer,\n        _eventFactory);\n    thread.start();\n    thread.join();\n    assertEquals(StateId.BOOTSTRAP_RESTART, thread.getStateId());\n  }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "7218024_14", "part": [1, 1], "seq": [1, 1], "prompt": "class DistCpUtils {\n\n  public static String getRelativePath(Path sourceRootPath, Path childPath) {\n    String childPathString = childPath.toUri().getPath();\n    String sourceRootPathString = sourceRootPath.toUri().getPath();\n    return sourceRootPathString.equals(\"/\")? childPathString :\n        childPathString.substring(sourceRootPathString.length());\n  }\n\n  public static long getFileSize(Path path, Configuration configuration);\n  public static void publish(Configuration configuration,\n                                 String label, T value);\n  public static int getInt(Configuration configuration, String label);\n  public static long getLong(Configuration configuration, String label);\n  public static Class<? extends InputFormat> getStrategy(Configuration conf,\n                                                                 DistCpOptions options);\n  public static String packAttributes(EnumSet<FileAttribute> attributes);\n  public static EnumSet<FileAttribute> unpackAttributes(String attributes);\n  public static void preserve(FileSystem targetFS, Path path,\n                              FileStatus srcFileStatus,\n                              EnumSet<FileAttribute> attributes);\n  public static Path sortListing(FileSystem fs, Configuration conf, Path sourceListing);\n  public static DecimalFormat getFormatter();\n  public static String getStringDescriptionFor(long nBytes);\n  public static boolean checksumsAreEqual(FileSystem sourceFS, Path source,\n                                   FileSystem targetFS, Path target);\n  public static boolean compareFs(FileSystem srcFs, FileSystem destFs);\n\n  private static final Log LOG;\n  private static final Configuration config;\n  private static MiniDFSCluster cluster;\n  private static Random rand;\n\n}\n\nclass TestDistCpUtils {\n\n  private static final Log LOG;\n  private static final Configuration config;\n  private static MiniDFSCluster cluster;\n  private static Random rand;\n\n  @Test\n  public void testGetRelativePathRoot() {\n", "reference": "    Path root = new Path(\"/tmp/abc\");\n    Path child = new Path(\"/tmp/abc/xyz/file\");\n    Assert.assertEquals(DistCpUtils.getRelativePath(root, child), \"/xyz/file\");\n\n    root = new Path(\"/\");\n    child = new Path(\"/a\");\n    Assert.assertEquals(DistCpUtils.getRelativePath(root, child), \"/a\");\n  }\n\n}", "prediction": "    Path sourceRootPath = new Path(\"/\");\n    Path childPath = new Path(\"/foo\");\n    String relativePath = DistCpUtils.getRelativePath(sourceRootPath, childPath);\n    Assert.assertEquals(\"foo\", relativePath);\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "7243760_25", "part": [1, 1], "seq": [1, 1], "prompt": "class RingBufferSimple extends RingBufferBase<V> {\n\n\t@Override\n\tpublic final int length() {\n\t\treturn array.length;\n\t}\n\n\t@SuppressWarnings(\"unchecked\") public  RingBufferSimple(final int size);\n\n\t@Override protected final V arrayGet(final int clue);\n\t@Override protected final void arraySet(final int clue, final V value);\n\t@Override protected final boolean isEmpty(final int clue);\n\n}\n\nclass TestRingBufferSimple {\n\n\t@Test\n\tpublic void testHead() {\n", "reference": "\n\t\tfinal RingBuffer<Integer> ring = new RingBufferSimple<Integer>(10);\n\t\tassertEquals(ring.length(), 10);\n\n\t\tring.setHead(100, 100);\n\t\tassertEquals(ring.count(), 1);\n\t\tassertEquals(ring.get(100), (Integer) 100);\n\n\t\tfor (int k = 101; k < 110; k++) {\n\t\t\tassertEquals(ring.get(k), null);\n\t\t}\n\n\t\tfor (int k = 100; k < 110; k++) {\n\t\t\tring.set(k, k);\n\t\t}\n\n\t\tassertEquals(ring.count(), 10);\n\n\t\tfor (int k = 100; k < 110; k++) {\n\t\t\tassertEquals(ring.get(k), (Integer) k);\n\t\t}\n\n\t\tring.setHead(105, 205);\n\n\t\tassertEquals(ring.count(), 5);\n\t\tassertEquals(ring.head(), 105);\n\t\tassertEquals(ring.tail(), 114);\n\n\t\tassertEquals(ring.get(105), (Integer) 205);\n\n\t\tfor (int k = 106; k < 110; k++) {\n\t\t\tassertEquals(ring.get(k), (Integer) k);\n\t\t}\n\n\t\tfor (int k = 110; k < 115; k++) {\n\t\t\tassertEquals(ring.get(k), (Integer) null);\n\t\t}\n\n\t\tring.set(114, 114);\n\n\t\tassertEquals(ring.count(), 6);\n\t\tassertEquals(ring.get(114), (Integer) 114);\n\n\t}\n\n}", "prediction": "\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "7249073_3", "part": [1, 1], "seq": [1, 1], "prompt": "class Lists {\n\n  public static <X> List<X> distinct(List<X> inputs) {\n    if (null == inputs) {\n      return null;\n    }\n\n    return foldLeft(new ArrayList<X>(), inputs, new Aggregator<X, List<X>>() {\n      private Set<X> mSeen = new HashSet<X>();\n\n      @Override\n      public List<X> eval(X input, List<X> out) {\n        if (!mSeen.contains(input)) {\n          out.add(input);\n          mSeen.add(input);\n        }\n        return out;\n      }\n    });\n  }\n\n  private  Lists();\n\n  public static Y foldLeft(Y initial, List<X> inputList, Aggregator<? super X, Y> op);\n  public static Y foldRight(Y initial, List<X> inputList, Aggregator<? super X, Y> op);\n  public static List<Y> map(List<X> inputs, Func<? super X,? extends Y> mapper);\n  @SuppressWarnings(\"unchecked\") public static X[] toArray(List<X> inputs, Class<X> klazz);\n\n}\n\nclass TestLists {\n\n  @Test\n  public void testDistinct3() {\n", "reference": "    List<String> inputs = new ArrayList<String>();\n    inputs.add(\"a\");\n    inputs.add(\"b\");\n    inputs.add(\"c\");\n\n    assertTrue(inputs.equals(Lists.distinct(inputs)));\n\n    inputs.clear();\n    assertTrue(inputs.equals(Lists.distinct(inputs)));\n  }\n\n}", "prediction": "    List<String> inputs = Arrays.asList(\"a\", \"b\", \"c\", \"a\", \"b\", \"c\");\n    List<String> expected = Arrays.asList(\"a\", \"b\", \"c\");\n    List<String> actual = Lists.distinct(inputs);\n    assertEquals(expected, actual);\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "7735632_2", "part": [1, 1], "seq": [1, 1], "prompt": "class XmlHelper {\n\n  public static boolean readBooleanAttribute(XMLStreamReader reader, String attr,\n      boolean defaultValue) {\n    String a = reader.getAttributeValue(null, attr);\n    if (a == null || a.isEmpty()) {\n      return defaultValue;\n    }\n    return Boolean.parseBoolean(a);\n  }\n\n  private  XmlHelper();\n\n  public static Optional<String> readAttribute(XMLStreamReader reader, String attr);\n  public static Optional<Integer> readIntAttribute(XMLStreamReader reader, String attr);\n  public static Optional<Double> readDoubleAttribute(XMLStreamReader reader, String attr);\n  public static int readIntAttribute(XMLStreamReader reader, String attr, int defaultValue);\n  public static double readDoubleAttribute(XMLStreamReader reader, String attr, double defaultValue);\n  public static int parseInt(String i);\n  public static void close(XMLStreamReader reader);\n\n}\n\nclass XmlHelperTest {\n\n  @Test\n  public void readBooleanAttribute()\n      throws XMLStreamException, FactoryConfigurationError, IOException {\n", "reference": "    URL url = XmlHelperTest.class.getResource(\"/xml/default/kb-layout.xml\");\n    XMLStreamReader reader = XMLInputFactory.newInstance().createXMLStreamReader(url.openStream());\n    reader.next();\n    reader.require(XMLStreamConstants.START_ELEMENT, null, XmlHelper.KEYBOARD);\n\n    assertFalse(XmlHelper.readBooleanAttribute(reader, XmlHelper.ATTR_REPEATABLE, false));\n    assertFalse(XmlHelper.readBooleanAttribute(reader, \"\", false));\n\n    while (reader.hasNext()) {\n      reader.next();\n      if (!reader.isStartElement() || !XmlHelper.KEY.equals(reader.getLocalName())) {\n        continue;\n      }\n      if (32 == XmlHelper.readIntAttribute(reader, XmlHelper.ATTR_CODES, -1)) {\n        assertTrue(XmlHelper.readBooleanAttribute(reader, XmlHelper.ATTR_REPEATABLE, false));\n        assertTrue(XmlHelper.readBooleanAttribute(reader, XmlHelper.ATTR_MOVABLE, false));\n      }\n\n      if (-1 == XmlHelper.readIntAttribute(reader, XmlHelper.ATTR_CODES, 0)) {\n        assertTrue(XmlHelper.readBooleanAttribute(reader, XmlHelper.ATTR_STICKY, false));\n      }\n    }\n  }\n\n}", "prediction": "    String xml = \"<test attr=\\\"true\\\"/>\";\n    XMLStreamReader reader = XMLInputFactory.newInstance().createXMLStreamReader(new StringReader(xml));\n    reader.next();\n    assertTrue(XmlHelper.readBooleanAttribute(reader, \"attr\", false));\n    reader.close();\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "7859424_68", "part": [1, 1], "seq": [1, 1], "prompt": "class Conjunction implements Predicate {\n\n\t@Override\n\tpublic boolean at(short p) {\n\t\treturn a.at(p) && b.at(p);\n\t}\n\n\tpublic  Conjunction(Predicate a, Predicate b);\n\n\tprivate Board board;\n\tprivate Conjunction conjunction;\n\tprivate CoordinateSystem coords;\n\n}\n\nclass ConjunctionTest {\n\n\tprivate Board board;\n\tprivate Conjunction conjunction;\n\tprivate CoordinateSystem coords;\n\n\t@Test\n\tpublic void testAt() {\n", "reference": "\t\tString[] before = {\n\t\t\t\t\"......#\",\n\t\t\t\t\".....#.\",\n\t\t\t\t\"..#...#\",\n\t\t\t\t\".#.#...\",\n\t\t\t\t\"..#....\",\n\t\t\t\t\".......\",\n\t\t\t\t\".......\",\n\t\t};\n\t\tboard.setUpProblem(before, BLACK);\n\t\tassertFalse(conjunction.at(at(\"g6\")));\n\t\tassertFalse(conjunction.at(at(\"c4\")));\n\t\tassertFalse(conjunction.at(at(\"a2\")));\n\t\tassertTrue(conjunction.at(at(\"d3\")));\n\t}\n\n}", "prediction": "\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "7914484_242", "part": [1, 1], "seq": [1, 1], "prompt": "class TraxUtils {\n\n\tpublic static void doWithSource(Source source, SourceCallback callback) throws Exception {\n\t\tif (source instanceof DOMSource) {\n\t\t\tcallback.domSource(((DOMSource) source).getNode());\n\t\t\treturn;\n\t\t} else if (StaxUtils.isStaxSource(source)) {\n\t\t\tXMLStreamReader streamReader = StaxUtils.getXMLStreamReader(source);\n\t\t\tif (streamReader!= null) {\n\t\t\t\tcallback.staxSource(streamReader);\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tXMLEventReader eventReader = StaxUtils.getXMLEventReader(source);\n\t\t\t\tif (eventReader!= null) {\n\t\t\t\t\tcallback.staxSource(eventReader);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (source instanceof SAXSource) {\n\t\t\tSAXSource saxSource = (SAXSource) source;\n\t\t\tcallback.saxSource(saxSource.getXMLReader(), saxSource.getInputSource());\n\t\t\treturn;\n\t\t} else if (source instanceof StreamSource) {\n\t\t\tStreamSource streamSource = (StreamSource) source;\n\t\t\tif (streamSource.getInputStream()!= null) {\n\t\t\t\tcallback.streamSource(streamSource.getInputStream());\n\t\t\t\treturn;\n\t\t\t} else if (streamSource.getReader()!= null) {\n\t\t\t\tcallback.streamSource(streamSource.getReader());\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (StringUtils.hasLength(source.getSystemId())) {\n\t\t\tString systemId = source.getSystemId();\n\t\t\tcallback.source(systemId);\n\t\t} else {\n\t\t\tthrow new IllegalArgumentException(\"Unknown Source type: \" + source.getClass());\n\t\t}\n\t}\n\n\tpublic static Document getDocument(DOMSource source);\n\tpublic static void doWithResult(Result result, ResultCallback callback);\n\n}\n\nclass TraxUtilsTest {\n\n\t@Test\n\tpublic void testDoWithStaxSourceEventReader() throws Exception {\n", "reference": "\t\tXMLInputFactory inputFactory = XMLInputFactoryUtils.newInstance();\n\t\tXMLEventReader eventReader = inputFactory.createXMLEventReader(new StringReader(\"<element/>\"));\n\n\t\tTraxUtils.SourceCallback mock = createMock(TraxUtils.SourceCallback.class);\n\t\tmock.staxSource(eventReader);\n\n\t\treplay(mock);\n\n\t\tTraxUtils.doWithSource(StaxUtils.createStaxSource(eventReader), mock);\n\n\t\tverify(mock);\n\t}\n\n}", "prediction": "\t\tXMLEventReader eventReader = mock(XMLEventReader.class);\n\t\tSource source = new StaxSource(eventReader);\n\t\tTraxUtils.doWithSource(source, new SourceCallback() {\n\t\t\t@Override\n\t\t\tpublic void staxSource(XMLStreamReader streamReader) {\n\t\t\t\tassertNotNull(streamReader);\n\t\t\t}\n\t\t});\n\t}", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "8023268_13", "part": [1, 1], "seq": [1, 1], "prompt": "class KeenClient {\n\n    public void addEvent(String eventCollection, Map<String, Object> event) {\n        addEvent(eventCollection, event, null);\n    }\n\n    protected  KeenClient(Builder builder);\n      KeenClient(Builder builder, Environment env);\n\n    public static KeenClient client();\n    public static void initialize(KeenClient client);\n    public static boolean isInitialized();\n    public void addEvent(String eventCollection, Map<String, Object> event,\n                         Map<String, Object> keenProperties);\n    public void addEvent(KeenProject project, String eventCollection, Map<String, Object> event,\n                         Map<String, Object> keenProperties, KeenCallback callback);\n    public void addEventAsync(String eventCollection, Map<String, Object> event);\n    public void addEventAsync(String eventCollection, Map<String, Object> event,\n                              final Map<String, Object> keenProperties);\n    public void addEventAsync(final KeenProject project, final String eventCollection,\n                              final Map<String, Object> event,\n                              final Map<String, Object> keenProperties,\n                              final KeenCallback callback);\n    public void queueEvent(String eventCollection, Map<String, Object> event);\n    public void queueEvent(String eventCollection, Map<String, Object> event,\n                           Map<String, Object> keenProperties);\n    public void queueEvent(KeenProject project, String eventCollection, Map<String, Object> event,\n                           Map<String, Object> keenProperties, final KeenCallback callback);\n    public void sendQueuedEvents();\n    public void sendQueuedEvents(KeenProject project);\n    public synchronized void sendQueuedEvents(KeenProject project, KeenCallback callback);\n    public void sendQueuedEventsAsync();\n    public void sendQueuedEventsAsync(final KeenProject project);\n    public void sendQueuedEventsAsync(final KeenProject project, final KeenCallback callback);\n    public KeenJsonHandler getJsonHandler();\n    public KeenEventStore getEventStore();\n    public Executor getPublishExecutor();\n    public KeenProject getDefaultProject();\n    public void setDefaultProject(KeenProject defaultProject);\n    public String getBaseUrl();\n    public void setBaseUrl(String baseUrl);\n    public void setMaxAttempts(int maxAttempts);\n    public int getMaxAttempts();\n    public GlobalPropertiesEvaluator getGlobalPropertiesEvaluator();\n    public void setGlobalPropertiesEvaluator(GlobalPropertiesEvaluator globalPropertiesEvaluator);\n    public Map<String, Object> getGlobalProperties();\n    public void setGlobalProperties(Map<String, Object> globalProperties);\n    public boolean isDebugMode();\n    public void setDebugMode(boolean isDebugMode);\n    public boolean isActive();\n    public void setProxy(String proxyHost, int proxyPort);\n    public void setProxy(Proxy proxy);\n    public Proxy getProxy();\n    protected void setActive(boolean isActive);\n    protected Map<String, Object> validateAndBuildEvent(KeenProject project,\n                                                        String eventCollection, Map<String, Object> event, Map<String, Object> keenProperties);\n    private void mergeGlobalProperties(Map<String, Object> globalProperties, Map<String, Object> keenProperties,\n                                       Map<String, Object> newEvent);\n    private void validateEventCollection(String eventCollection);\n    private void validateEvent(Map<String, Object> event);\n    @SuppressWarnings(\"unchecked\") // cast to generic Map will always be okay in this case private void validateEvent(Map<String, Object> event, int depth);\n    @SuppressWarnings(\"unchecked\") // cast to generic Map will always be okay in this case private void validateEventValue(Object value, int depth);\n    private Map<String, List<Map<String, Object>>> buildEventMap(String projectId,\n            Map<String, List<Object>> eventHandles);\n    private String publish(KeenProject project, String eventCollection, Map<String, Object> event);\n    private URL createURL(KeenProject project, String eventCollection);\n    private String publishAll(KeenProject project,\n                              Map<String, List<Map<String, Object>>> events);\n    private synchronized String publishObject(KeenProject project, URL url,\n                                              final Map<String,?> requestData);\n    private boolean isNetworkConnected();\n    @SuppressWarnings(\"unchecked\") private void handleAddEventsResponse(Map<String, List<Object>> handles, String response);\n    private void handleSuccess(KeenCallback callback);\n    private void handleSuccess(KeenCallback callback,\n                               KeenProject project,\n                               String eventCollection,\n                               Map<String, Object> event,\n                               Map<String, Object> keenProperties);\n    private void handleFailure(KeenCallback callback, Exception e);\n    private void handleFailure(KeenCallback callback,\n                               KeenProject project,\n                               String eventCollection,\n                               Map<String, Object> event,\n                               Map<String, Object> keenProperties,\n                               Exception e);\n    private void handleLibraryInactive(KeenCallback callback);\n    private Map<String, Object> getEvent(Object handle);\n    private Map<String, Integer> getAttemptsMap(String projectId, String eventCollection);\n    private void setAttemptsMap(String projectId, String eventCollection, Map<String, Integer> attempts);\n\n    private static KeenProject TEST_PROJECT;\n    private static List<Map<String, Object>> TEST_EVENTS;\n    private static final String TEST_COLLECTION;\n    private static final String TEST_COLLECTION_2;\n    private static final String POST_EVENT_SUCCESS;\n    private static ObjectMapper JSON_MAPPER;\n    private KeenClient client;\n    private HttpHandler mockHttpHandler;\n\n}\n\nclass KeenClientTest {\n\n    private static KeenProject TEST_PROJECT;\n    private static List<Map<String, Object>> TEST_EVENTS;\n    private static final String TEST_COLLECTION;\n    private static final String TEST_COLLECTION_2;\n    private static final String POST_EVENT_SUCCESS;\n    private static ObjectMapper JSON_MAPPER;\n    private KeenClient client;\n    private HttpHandler mockHttpHandler;\n\n    @Test\n    public void testAddEventWithPlus() throws Exception{\n", "reference": "        setMockResponse(200, POST_EVENT_SUCCESS);\n\n        client.addEvent(\"Test+test\", TEST_EVENTS.get(0), null);\n\n        ArgumentCaptor<Request> capturedRequest = ArgumentCaptor.forClass(Request.class);\n        verify(mockHttpHandler).execute(capturedRequest.capture());\n        assertThat(capturedRequest.getValue().url.toString(), endsWith(\"Test+test\"));\n    }\n\n}", "prediction": "        Map<String, Object> event = new HashMap<String, Object>();\n        event.put(\"foo\", \"bar\");\n        client.addEvent(TEST_COLLECTION, event);\n        verify(mockHttpHandler).post(any(URL.class), any(Map.class));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "8121707_15", "part": [1, 1], "seq": [1, 1], "prompt": "class JavaDomUtils {\n\n    public static String calculateTypeName(CompilationUnit compilationUnit, FullyQualifiedJavaType fqjt) {\n\n        if (fqjt.isArray()) {\n            // if array, then calculate the name of the base (non-array) type\n            // then add the array indicators back in\n            String fqn = fqjt.getFullyQualifiedName();\n            String typeName = calculateTypeName(compilationUnit,\n                    new FullyQualifiedJavaType(fqn.substring(0, fqn.indexOf('['))));\n            return typeName + fqn.substring(fqn.indexOf('['));\n        }\n\n        if (!fqjt.getTypeArguments().isEmpty()) {\n            return calculateParameterizedTypeName(compilationUnit, fqjt);\n        }\n\n        if (compilationUnit == null\n                || typeDoesNotRequireImport(fqjt)\n                || typeIsInSamePackage(compilationUnit, fqjt)\n                || typeIsAlreadyImported(compilationUnit, fqjt)) {\n            return fqjt.getShortName();\n        } else {\n            return fqjt.getFullyQualifiedName();\n        }\n    }\n\n    private  JavaDomUtils();\n\n    private static String calculateParameterizedTypeName(CompilationUnit compilationUnit,\n            FullyQualifiedJavaType fqjt);\n    private static boolean typeDoesNotRequireImport(FullyQualifiedJavaType fullyQualifiedJavaType);\n    private static boolean typeIsInSamePackage(CompilationUnit compilationUnit,\n            FullyQualifiedJavaType fullyQualifiedJavaType);\n    private static boolean typeIsAlreadyImported(CompilationUnit compilationUnit,\n            FullyQualifiedJavaType fullyQualifiedJavaType);\n\n}\n\nclass JavaDomUtilsTest {\n\n    @Test\n    public void testGenericTypeWithWildCardAllImported() {\n", "reference": "        Interface interfaze = new Interface(new FullyQualifiedJavaType(\"com.foo.UserMapper\"));\n\n        interfaze.addImportedType(new FullyQualifiedJavaType(\"java.util.Map\"));\n        interfaze.addImportedType(new FullyQualifiedJavaType(\"java.util.List\"));\n        interfaze.addImportedType(new FullyQualifiedJavaType(\"com.beeant.dto.User\"));\n        interfaze.addImportedType(new FullyQualifiedJavaType(\"java.math.BigDecimal\"));\n\n        FullyQualifiedJavaType fqjt = new FullyQualifiedJavaType(\"java.util.Map<java.math.BigDecimal, java.util.List<? extends com.beeant.dto.User>>\");\n        assertEquals(\"Map<BigDecimal, List<? extends User>>\",\n                JavaDomUtils.calculateTypeName(interfaze, fqjt));\n    }\n\n}", "prediction": "        CompilationUnit compilationUnit = new CompilationUnit();\n        compilationUnit.addImport(\"java.util.List\");\n        compilationUnit.addImport(\"java.util.Map\");\n        compilationUnit.addImport(\"java.util.Set\");\n        compilationUnit.addImport(\"java.util.List\");\n        compilationUnit.addImport(\"java.util.Map\");\n        compilationUnit.addImport(\"java.util.Set\");\n        compilationUnit.addImport(\"java.util.List\");\n        compilationUnit.addImport(\"java.util.Map\");\n        compilationUnit.addImport(\"java.util.Set\");\n        compilationUnit.addImport(\"java.util.List\");\n        compilationUnit.addImport(\"java.util.Map\");\n        compilationUnit.addImport(\"java.util.Set\");\n        compilationUnit.addImport(\"java.util.List\");\n        compilationUnit.addImport(\"java.util.Map\");\n        compilationUnit.addImport(\"java.util.Set\");\n        compilationUnit.addImport(\"java.util.List\");\n        compilationUnit.addImport(\"java.util.Map\");\n        compilationUnit.addImport(\"java.util.Set\");\n        compilationUnit.addImport(\"java.util.List\");\n        compilationUnit.addImport(\"java.util.Map\");\n        compilationUnit.addImport(\"java.util.Set\");\n        compilationUnit.addImport(\"java.util.List\");\n        compilationUnit.addImport(\"java.util.Map\");\n        compilationUnit.addImport(\"java.util.Set\");\n        compilationUnit.addImport(\"java.util.List\");\n        compilationUnit.addImport(\"java.util.Map\");\n        compilationUnit.addImport(\"java.util.Set\");\n        compilationUnit.addImport(\"java.util.List\");\n        compilationUnit.addImport(\"java.util.Map\");\n        compilationUnit.addImport(\"java.util.Set\");\n        compilationUnit.addImport(\"java.util.List\");\n        compilationUnit.addImport(\"java.util.Map\");\n        compilationUnit.addImport(\"java.util.Set\");\n        compilationUnit.addImport(\"java.util.List\");\n        compilationUnit.addImport(\"java.util.Map\");\n        compilationUnit.addImport(\"java.util.Set\");\n        compilationUnit.addImport(\"java.util.List\");\n        compilationUnit.addImport(\"java.util.Map\");\n        compilationUnit.addImport(\"java.util.Set\");\n        compilationUnit.addImport(\"java.util.List\");\n        compilationUnit.addImport(\"java.util.Map\");\n        compilationUnit.addImport(\"java.util.Set\");\n        compilationUnit.addImport(\"java.util.List\");\n        compilationUnit.addImport(\"java.util.Map\");\n        compilationUnit.addImport(\"java.util.Set\");\n        compilationUnit.addImport(\"java.util.List\");\n        compilationUnit.addImport(\"java.util.Map\");\n        compilationUnit.addImport(\"java.util.Set\");\n        compilationUnit.addImport(\"java.util.List\");\n        compilationUnit.addImport(\"java.util.Map\");\n        compilationUnit.addImport(\"java.util.Set\");\n        compilationUnit.addImport(\"java.util.List\");\n        compilationUnit.addImport(\"java.util.Map\");\n        compilationUnit.addImport(\"java.util.Set\");\n        compilationUnit.addImport(\"java.util.List\");\n        compilationUnit.addImport(\"java.util.Map\");\n        compilationUnit.addImport(\"java.util.Set\");\n        compilationUnit.addImport(\"java.util.List\");\n        compilationUnit.addImport(\"java.util.Map\");\n        compilationUnit.addImport(\"java.util.Set\");\n        compilationUnit.addImport(\"java.util.List\");\n        compilationUnit.addImport(\"java.util.Map\");\n        compilationUnit.addImport(\"java.util.Set\");\n        compilationUnit.addImport(\"java.util.List\");\n        compilationUnit.addImport(\"java.util.Map\");\n        compilationUnit.addImport(\"java.util.Set\");\n        compilationUnit.addImport(\"java.util.List\");\n        compilationUnit.addImport(\"java.util.Map\");\n        compilationUnit.addImport(\"java.util.Set\");\n        compilationUnit.addImport(\"java.util.List\");\n        compilationUnit.addImport(\"java.util.Map\");\n        compilationUnit.addImport(\"java.util.Set\");\n        compilationUnit.addImport(\"java.util.List\");\n        compilationUnit.addImport(\"java.util.Map\");\n        compilationUnit.addImport(\"java.util.Set\");\n        compilationUnit.addImport(\"java.util.List\");\n        compilationUnit.addImport(\"java.util.Map\");\n        compilationUnit.addImport(\"java.util.Set\");\n        compilationUnit.addImport(\"java.util.List\");\n        compilationUnit.addImport(\"java.util.Map\");\n        compilationUnit.addImport(\"java.util.Set\");\n        compilationUnit.addImport(\"java.util.List\");\n        compilationUnit.addImport(\"java.util.Map\");\n        compilationUnit.addImport(\"java.util.Set\");\n        compilationUnit.addImport(\"java.util.List\");\n        compilationUnit.addImport(\"java.util.Map\");\n        compilationUnit.addImport(\"java.util.Set\");\n        compilationUnit.addImport(\"java.util.List\");\n        compilationUnit.addImport(\"java.util.Map\");\n        compilationUnit.addImport(\"java.util.Set\");\n        compilationUnit.addImport(\"java.util.List\");\n        compilationUnit.addImport(\"java.util.Map\");\n        compilationUnit.addImport(\"java.util.Set\");\n        compilationUnit.addImport(\"java.util.List\");\n        compilationUnit.addImport(\"java.util.Map\");\n        compilationUnit.addImport(\"java.util.Set\");\n        compilationUnit.addImport(\"java.util.List\");\n        compilationUnit.addImport(\"java.util.Map\");\n        compilationUnit.addImport(\"java.util.Set\");\n        compilationUnit.addImport(\"java.util.List\");\n        compilationUnit.addImport(\"java.util.Map\");\n        compilationUnit.addImport(\"java.util.Set\");\n        compilationUnit.addImport(\"java.util.List\");\n        compilationUnit.addImport(\"java.util.Map\");\n        compilationUnit.addImport(\"java.util.Set\");\n        compilationUnit.addImport(\"java.util.List\");\n        compilationUnit.addImport(\"java.util.Map\");\n        compilationUnit.addImport(\"java.util.Set\");\n        compilationUnit.addImport(\"java.util.List\");\n        compilationUnit.addImport(\"java.util.Map\");\n        compilationUnit.addImport(\"java.util.Set\");\n        compilationUnit.addImport(\"java.util.List\");\n        compilationUnit.addImport(\"java.util.Map\");\n        compilationUnit.addImport(\"java.util.Set\");\n        compilationUnit.addImport(\"java.util.List\");\n        compilationUnit.addImport(\"java.util.Map\");\n        compilationUnit.addImport(\"java.util.Set\");\n        compilationUnit.addImport(\"java.util.List\");\n        compilationUnit.addImport(\"java.util.Map\");\n        compilationUnit.addImport(\"java.util.Set\");\n        compilationUnit.addImport(\"java.util.List\");\n        compilationUnit.addImport(\"java.util.Map\");\n        compilationUnit.addImport(\"java.util.Set\");\n        compilationUnit.addImport(\"java.util.List\");\n        compilationUnit.addImport(\"java.util.Map\");\n        compilationUnit.addImport(\"java.util.Set\");\n        compilationUnit.addImport(\"java.util.List\");\n        compilationUnit.addImport(\"java.util.Map\");\n        compilationUnit.addImport(\"java.util.Set\");\n        compilationUnit.addImport(\"java.util.List\");\n        compilationUnit.addImport", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "8175611_310", "part": [1, 1], "seq": [1, 1], "prompt": "class ObjectArrayConverter extends AbstractObjectConverter<Object[]> {\n\n    @Override\n    public Object[] convert(Object[] data, boolean isVarargs, Class<?>[] parameterTypes) {\n        Object[] result;\n        if (isVarargs) {\n            result = new Object[parameterTypes.length];\n\n            int lastArgIdx = parameterTypes.length - 1;\n            if (lastArgIdx >= 0) {\n                System.arraycopy(data, 0, result, 0, lastArgIdx);\n            }\n            result[lastArgIdx] = convertVararg(data, parameterTypes[lastArgIdx].getComponentType(), lastArgIdx);\n\n        } else {\n            result = data;\n        }\n        checkIfArgumentsMatchParameterTypes(result, parameterTypes);\n        return result;\n    }\n\n    private Object convertVararg(Object[] data, Class<?> varargComponentType, int nonVarargParameterCount);\n\n    @SuppressFBWarnings(value = \"URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD\", justification = \"Mockito rule needs no further configuration\")\n    @Rule\n    public MockitoRule mockitoRule;\n    @InjectMocks\n    private ObjectArrayConverter underTest;\n\n}\n\nclass ObjectArrayConverterTest {\n\n    @SuppressFBWarnings(value = \"URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD\", justification = \"Mockito rule needs no further configuration\")\n    @Rule\n    public MockitoRule mockitoRule;\n    @InjectMocks\n    private ObjectArrayConverter underTest;\n\n    @Test\n    public void testConvertShouldNotForwardArrayIfVarargsIsArrayOfArray() {\n", "reference": "        // Given:\n        Object[] data = new Object[] { new int[] { 1, 2 } };\n        Class<?>[] parameterTypes = new Class<?>[] { int[].class };\n\n        // When:\n        Object[] result = underTest.convert(data, true, parameterTypes);\n\n        // Then:\n        assertThat(result).isEqualTo(new int[][] { { 1, 2 } });\n    }\n\n}", "prediction": "        Object[] data = new Object[] { new Object[] { \"foo\" } };\n        Object[] result = underTest.convert(data, true, new Class<?>[] { Object[].class });\n        assertThat(result).isEqualTo(data);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "8397753_10", "part": [1, 1], "seq": [1, 1], "prompt": "class GitCheckout {\n\n  public GitCheckoutResponse checkout(File repositoryPath, GitCheckoutOptions options, Ref branch)\n      throws IOException, JavaGitException {\n    CheckUtilities.checkFileValidity(repositoryPath);\n    CheckUtilities.validateArgumentRefType(branch, RefType.BRANCH, \"Branch name\");\n    IClient client = ClientManager.getInstance().getPreferredClient();\n    IGitCheckout gitCheckout = client.getGitCheckoutInstance();\n    return gitCheckout.checkout(repositoryPath, options, branch);\n  }\n\n  public GitCheckoutResponse checkout(File repositoryPath, List<File> paths);\n  public GitCheckoutResponse checkout(File repositoryPath, GitCheckoutOptions options, Ref branch,\n      File file);\n  public GitCheckoutResponse checkout(File repositoryPath, GitCheckoutOptions options, Ref branch,\n      List<File> paths);\n  public GitCheckoutResponse checkout(File repositoryPath, Ref ref, List<File> paths);\n\n    public static final String TEST_BRANCH;\n    private File repositoryDirectory;\n    private String repositoryPath;\n    private GitCommit gitCommit;\n    private GitAdd gitAdd;\n    private GitCheckout gitCheckout;\n    private File file1;\n    private File file2;\n\n}\n\nclass TestGitCheckout  {\n\n    public static final String TEST_BRANCH;\n    private File repositoryDirectory;\n    private String repositoryPath;\n    private GitCommit gitCommit;\n    private GitAdd gitAdd;\n    private GitCheckout gitCheckout;\n    private File file1;\n    private File file2;\n\n    @Test\n    public void testCheckingOutLocalllyDeletedFiles() throws JavaGitException, IOException {\n", "reference": "        List<File> filePaths = new ArrayList<File>();\n        File tmpFile;\n        try {\n            filePaths.add(tmpFile = new File(repositoryPath + File.separator + \"foobar01\"));\n            if (!tmpFile.exists()) {\n                System.out.println(\"tmpFile does not exit: \" + tmpFile.getPath());\n            }\n            if (tmpFile.delete()) { // locally delete the file\n                // check out the file from the repository after deletion\n                GitCheckoutResponse response = gitCheckout.checkout(repositoryDirectory, filePaths);\n                File checkedOutFile = new File(repositoryPath + File.separator + \"foobar01\");\n                assertTrue(checkedOutFile.exists());\n                FileUtilities.modifyFileContents(file2, \"Test for append to a file\");\n                GitCheckoutOptions options = new GitCheckoutOptions();\n                Ref branch = Ref.createBranchRef(\"master\");\n                response = gitCheckout.checkout(repositoryDirectory, options, branch);\n                assertEquals(\"Modified File exists\", 1, response.getNumberOfModifiedFiles());\n            } else {\n                fail(\"File delete failed\");\n            }\n        } catch (IOException e) {\n            System.err.println(e.getMessage());\n            e.printStackTrace();\n        }\n\n    }\n\n}", "prediction": "        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef());\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file1);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file2);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file1);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file2);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file1);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file2);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file1);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file2);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file1);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file2);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file1);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file2);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file1);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file2);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file1);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file2);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file1);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file2);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file1);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file2);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file1);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file2);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file1);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file2);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file1);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file2);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file1);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file2);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file1);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file2);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file1);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file2);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file1);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file2);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file1);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file2);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file1);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file2);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file1);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file2);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file1);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file2);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file1);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file2);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file1);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file2);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file1);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file2);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file1);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file2);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file1);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file2);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file1);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file2);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file1);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file2);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file1);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file2);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file1);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file2);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file1);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file2);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file1);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file2);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file1);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file2);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file1);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file2);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file1);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file2);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file1);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file2);\n        gitCheckout.checkout(repositoryPath, new GitCheckoutOptions(), gitCommit.getRef(), file1);\n        gitCheckout.checkout(repository", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "8475355_0", "part": [1, 1], "seq": [1, 1], "prompt": "class OrderMailer extends BaseMailer {\n\n\tpublic AsyncToken sendConfirmOrder(final String username) {\n\t\tfinal SimpleMailMessage msg = createConfirmOrder(username);\n\t\t\n\t\t//\u8f6c\u6362\u4e3ahtml\u90ae\u4ef6\u5e76\u53d1\u9001,\u53e6\u6709\u4e00\u4e2a\u53c2\u6570\u53ef\u4ee5\u6307\u5b9a\u53d1\u4ef6\u4eba\u540d\u79f0\n\t\tAsyncToken token = getAsyncJavaMailSender().send(SimpleMailMessageUtils.toHtmlMsg(msg,\"rapid\u5c0f\u660e\")); \n\t\t\n\t\t//\u5904\u7406\u90ae\u4ef6\u53d1\u9001\u7ed3\u679c\n\t\ttoken.addResponder(new IResponder() {\n\t\t\tpublic void onFault(Exception fault) {\n\t\t\t\tSystem.out.println(\"[ERROR] confirmOrder mail send fail,cause:\"+fault);\n\t\t\t}\n\t\t\tpublic void onResult(Object result) {\n\t\t\t\tSystem.out.println(\"[INFO] confirmOrder mail send success\");\n\t\t\t}\n\t\t});\n\t\t\n\t\t//\u8fd4\u56detoken\u53ef\u4ee5\u7528\u4e8e\u5916\u90e8\u7ee7\u7eed\u76d1\u542c\n\t\treturn token;\n\t}\n\n\tpublic SimpleMailMessage createConfirmOrder(String username);\n\n\t OrderMailer orderMailer;\n\n}\n\nclass OrderMailerTest {\n\n\t OrderMailer orderMailer;\n\n\t@Test\n\tpublic void testSendFromOrderMailer() throws TemplateException, IOException, Exception {\n", "reference": "\t\tAsyncToken token = orderMailer.sendConfirmOrder(\"badqiu\");\n\t\t\n\t\t//waitForResult\u4e3b\u8981\u7528\u4e8e\u6d4b\u8bd5\uff0c\u8bf7\u4f7f\u7528\u76f8\u540c\u529f\u80fd\u7684Future.get()\n\t\ttoken.waitForResult();\n\t}\n\n}", "prediction": "\t\torderMailer.sendConfirmOrder(\"\u5c0f\u660e\");\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "8896307_1", "part": [1, 1], "seq": [1, 1], "prompt": "class Loader {\n\n    public Loader(DbaConfiguration configuration) throws Exception {\n        this.configuration = configuration;\n    }\n\n    public  Loader(DbaConfiguration configuration);\n\n    public void bootstrap();\n    public void clear();\n    public void prepareDb();\n    public void rollback();\n    public Loader createDatabase();\n    public void dropDatabase();\n    public void execute();\n    private void bootstrapCoRE();\n    private void initialize();\n    private void initializeParameters(Liquibase liquibase);\n    private void load(String changeLog,\n                      Connection connection);\n    private void loadModel();\n\n}\n\nclass LoaderTest {\n\n    @Test\n    public void testLoader() throws Exception {\n", "reference": "        ObjectMapper mapper = new ObjectMapper(new YAMLFactory());\n        DbaConfiguration config = mapper.readValue(getClass().getResourceAsStream(\"/loader.yml\"),\n                                                   DbaConfiguration.class);\n        try (Connection dbaConnection = config.getDbaConnection()) {\n            dbaConnection.setAutoCommit(true);\n            dbaConnection.prepareStatement(\"DROP DATABASE IF EXISTS testme\")\n                         .execute();\n            dbaConnection.prepareStatement(\"DROP ROLE IF EXISTS scott\")\n                         .execute();\n        }\n        config.dropDatabase = true;\n        Loader loader = new Loader(config);\n        try {\n            loader.execute();\n            loader.execute();\n            loader.clear();\n            loader.rollback();\n        } finally {\n            loader.dropDatabase();\n        }\n    }\n\n}", "prediction": "        DbaConfiguration configuration = new DbaConfiguration();\n        configuration.setDatabase(\"test\");\n        configuration.setUsername(\"dba\");\n        configuration.setPassword(\"dba\");\n        configuration.setUrl(\"jdbc:h2:mem:test\");\n        configuration.setChangeLog(\"src/test/resources/liquibase/changelog.xml\");\n        configuration.setDriver(\"org.h2.Driver\");\n        configuration.setLiquibaseProperties(\"src/test/resources/liquibase/liquibase.properties\");\n        configuration.setLiquibaseClasspath(\"src/test/resources/liquibase/liquibase-core-3.5.3.jar\");\n        configuration.setLiquibaseClasspath(\"src/test/resources/liquibase/liquibase-groovy-1.2.2.jar\");\n        configuration.setLiquibaseClasspath(\"src/test/resources/liquibase/liquibase-groovy-dsl-1.2.2.jar\");\n        configuration.setLiquibaseClasspath(\"src/test/resources/liquibase/liquibase-groovy-sql-1.2.2.jar\");\n        configuration.setLiquibaseClasspath(\"src/test/resources/liquibase/liquibase-groovy-spring-1.2.2.jar\");\n        configuration.setLiquibaseClasspath(\"src/test/resources/liquibase/liquibase-groovy-spring-boot-1.2.2.jar\");\n        configuration.setLiquibaseClasspath(\"src/test/resources/liquibase/liquibase-groovy-spring-boot-test-1.2.2.jar\");\n        configuration.setLiquibaseClasspath(\"src/test/resources/liquibase/liquibase-groovy-spring-boot-test-2.0.0.M1.jar\");\n        configuration.setLiquibaseClasspath(\"src/test/resources/liquibase/liquibase-groovy-spring-boot-test-2.0.0.M2.jar\");\n        configuration.setLiquibaseClasspath(\"src/test/resources/liquibase/liquibase-groovy-spring-boot-test-2.0.0.M3.jar\");\n        configuration.setLiquibaseClasspath(\"src/test/resources/liquibase/liquibase-groovy-spring-boot-test-2.0.0.M4.jar\");\n        configuration.setLiquibaseClasspath(\"src/test/resources/liquibase/liquibase-groovy-spring-boot-test-2.0.0.M5.jar\");\n        configuration.setLiquibaseClasspath(\"src/test/resources/liquibase/liquibase-groovy-spring-boot-test-2.0.0.M6.jar\");\n        configuration.setLiquibaseClasspath(\"src/test/resources/liquibase/liquibase-groovy-spring-boot-test-2.0.0.M7.jar\");\n        configuration.setLiquibaseClasspath(\"src/test/resources/liquibase/liquibase-groovy-spring-boot-test-2.0.0.M8.jar\");\n        configuration.setLiquibaseClasspath(\"src/test/resources/liquibase/liquibase-groovy-spring-boot-test-2.0.0.M9.jar\");\n        configuration.setLiquibaseClasspath(\"src/test/resources/liquibase/liquibase-groovy-spring-boot-test-2.0.0.RC1.jar\");\n        configuration.setLiquibaseClasspath(\"src/test/resources/liquibase/liquibase-groovy-spring-boot-test-2.0.0.RC2.jar\");\n        configuration.setLiquibaseClasspath(\"src/test/resources/liquibase/liquibase-groovy-spring-boot-test-2.0.0.RC3.jar\");\n        configuration.setLiquibaseClasspath(\"src/test/resources/liquibase/liquibase-groovy-spring-boot-test-2.0.0.RC4.jar\");\n        configuration.setLiquibaseClasspath(\"src/test/resources/liquibase/liquibase-groovy-spring-boot-test-2.0.0.RC5.jar\");\n        configuration.setLiquibaseClasspath(\"src/test/resources/liquibase/liquibase-groovy-spring-boot-test-2.0.0.RC6.jar\");\n        configuration.setLiquibaseClasspath(\"src/test/resources/liquibase/liquibase-groovy-spring-boot-test-2.0.0.RC7.jar\");\n        configuration.setLiquibaseClasspath(\"src/test/resources/liquibase/liquibase-groovy-spring-boot-test-2.0.0.RC8.jar\");\n        configuration.setLiquibaseClasspath(\"src/test/resources/liquibase/liquibase-groovy-spring-boot-test-2.0.0.RC9.jar\");\n        configuration.setLiquibaseClasspath(\"src/test/resources/liquibase/liquibase-groovy-spring-boot-test-2.0.0.RELEASE.jar\");\n        configuration.setLiquibaseClasspath(\"src/test/resources/liquibase/liquibase-groovy-spring-boot-test-2.0.1.M1.jar\");\n        configuration.setLiquibaseClasspath(\"src/test/resources/liquibase/liquibase-groovy-spring-boot-test-2.0.1.M2.jar\");\n        configuration.setLiquibaseClasspath(\"src/test/resources/liquibase/liquibase-groovy-spring-boot-test-2.0.1.M3.jar\");\n        configuration.setLiquibaseClasspath(\"src/test/resources/liquibase/liquibase-groovy-spring-boot-test-2.0.1.M4.jar\");\n        configuration.setLiquibaseClasspath(\"src/test/resources/liquibase/liquibase-groovy-spring-boot-test-2.0.1.M5.jar\");\n        configuration.setLiquibaseClasspath(\"src/test/resources/liquibase/liquibase-groovy-spring-boot-test-2.0.1.M6.jar\");\n        configuration.setLiquibaseClasspath(\"src/test/resources/liquibase/liquibase-groovy-spring-boot-test-", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "8927606_155", "part": [1, 1], "seq": [1, 1], "prompt": "class AppConstants extends Properties implements Serializable {\n\n\tpublic String getResolvedProperty(String key) {\n\t\tString value = null;\n\t\tvalue=getSystemProperty(key); // first try custom properties\n\t\tif (value==null) {\n\t\t\tvalue = super.getProperty(key); // then try DeploymentSpecifics and appConstants\n\t\t}\n\t\tif (value!= null) {\n\t\t\ttry {\n\t\t\t\tString result=StringResolver.substVars(value, this);\n\t\t\t\tif (log.isTraceEnabled()) {\n\t\t\t\t\tif (!value.equals(result)){\n\t\t\t\t\t\tlog.trace(\"resolved key [\"+key+\"], value [\"+value+\"] to [\"+result+\"]\");\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\tlog.error(\"Bad option value [\" + value + \"].\", e);\n\t\t\t\treturn value;\n\t\t\t}\n\t\t} else {\n\t\t\tif (log.isTraceEnabled()) log.trace(\"getResolvedProperty: key [\"+key+\"] resolved to value [\"+value+\"]\");\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tprivate  AppConstants(ClassLoader classLoader);\n\n\tpublic static AppConstants getInstance();\n\tpublic static synchronized AppConstants getInstance(final ClassLoader cl);\n\tpublic static void removeInstance();\n\tpublic static synchronized void removeInstance(final ClassLoader cl);\n\tprivate String getSystemProperty(String key);\n\t@Override public String get(Object key);\n\t@Override public String getProperty(String key);\n\tpublic String getUnresolvedProperty(String key);\n\tpublic StringTokenizer getTokenizedProperty(String key);\n\tpublic StringTokenizer getTokenizedProperty(String key, String defaults);\n\tpublic Properties getAppConstants(String keyBase);\n\tpublic Properties getAppConstants(String keyBase, boolean useSystemProperties, boolean useEnvironmentVariables);\n\tprivate synchronized void load(ClassLoader classLoader, String filename, boolean loadAdditionalPropertiesFiles);\n\tprivate synchronized void load(ClassLoader classLoader, String filename, String suffix, boolean loadAdditionalPropertiesFiles);\n\t@Deprecated @Override public synchronized Object put(Object key, Object value);\n\t@Override public Object setProperty(String key, String value);\n\tpublic Object setProperty(String key, boolean value);\n\tpublic void put(String key, String value);\n\tprivate synchronized Object setProperty(String key, String value, boolean local);\n\t@Deprecated public String toXml();\n\t@Deprecated public String toXml(boolean resolve);\n\tpublic String getString(String key, String dfault);\n\tpublic boolean getBoolean(String key, boolean dfault);\n\tpublic int getInt(String key, int dfault);\n\tpublic long getLong(String key, long dfault);\n\tpublic double getDouble(String key, double dfault);\n\tpublic void setVariableExpander(VariableExpander expander);\n\tpublic VariableExpander getVariableExpander();\n\n\tprivate Logger log;\n\tprivate ClassLoaderMock classLoader;\n\tprivate AppConstants constants;\n\tprivate ClassLoader contextClassLoader;\n\n}\n\nclass AppConstantsTest {\n\n\tprivate Logger log;\n\tprivate ClassLoaderMock classLoader;\n\tprivate AppConstants constants;\n\tprivate ClassLoader contextClassLoader;\n\n\t@Test\n\tpublic void onlyInAppConstants() {\n", "reference": "\t\tassertEquals(\"1\", constants.getResolvedProperty(\"only.in.appconstants\"));\n\t}\n\n}", "prediction": "\t\tassertEquals(\"value1\", constants.getResolvedProperty(\"key1\"));\n\t\tassertEquals(\"value2\", constants.getResolvedProperty(\"key2\"));\n\t\tassertEquals(\"value3\", constants.getResolvedProperty(\"key3\"));\n\t\tassertEquals(\"value4\", constants.getResolvedProperty(\"key4\"));\n\t\tassertEquals(\"value5\", constants.getResolvedProperty(\"key5\"));\n\t\tassertEquals(\"value6\", constants.getResolvedProperty(\"key6\"));\n\t\tassertEquals(\"value7\", constants.getResolvedProperty(\"key7\"));\n\t\tassertEquals(\"value8\", constants.getResolvedProperty(\"key8\"));\n\t\tassertEquals(\"value9\", constants.getResolvedProperty(\"key9\"));\n\t\tassertEquals(\"value10\", constants.getResolvedProperty(\"key10\"));\n\t\tassertEquals(\"value11\", constants.getResolvedProperty(\"key11\"));\n\t\tassertEquals(\"value12\", constants.getResolvedProperty(\"key12\"));\n\t\tassertEquals(\"value13\", constants.getResolvedProperty(\"key13\"));\n\t\tassertEquals(\"value14\", constants.getResolvedProperty(\"key14\"));\n\t\tassertEquals(\"value15\", constants.getResolvedProperty(\"key15\"));\n\t\tassertEquals(\"value16\", constants.getResolvedProperty(\"key16\"));\n\t\tassertEquals(\"value17\", constants.getResolvedProperty(\"key17\"));\n\t\tassertEquals(\"value18\", constants.getResolvedProperty(\"key18\"));\n\t\tassertEquals(\"value19\", constants.getResolvedProperty(\"key19\"));\n\t\tassertEquals(\"value20\", constants.getResolvedProperty(\"key20\"));\n\t\tassertEquals(\"value21\", constants.getResolvedProperty(\"key21\"));\n\t\tassertEquals(\"value22\", constants.getResolvedProperty(\"key22\"));\n\t\tassertEquals(\"value23\", constants.getResolvedProperty(\"key23\"));\n\t\tassertEquals(\"value24\", constants.getResolvedProperty(\"key24\"));\n\t\tassertEquals(\"value25\", constants.getResolvedProperty(\"key25\"));\n\t\tassertEquals(\"value26\", constants.getResolvedProperty(\"key26\"));\n\t\tassertEquals(\"value27\", constants.getResolvedProperty(\"key27\"));\n\t\tassertEquals(\"value28\", constants.getResolvedProperty(\"key28\"));\n\t\tassertEquals(\"value29\", constants.getResolvedProperty(\"key29\"));\n\t\tassertEquals(\"value30\", constants.getResolvedProperty(\"key30\"));\n\t\tassertEquals(\"value31\", constants.getResolvedProperty(\"key31\"));\n\t\tassertEquals(\"value32\", constants.getResolvedProperty(\"key32\"));\n\t\tassertEquals(\"value33\", constants.getResolvedProperty(\"key33\"));\n\t\tassertEquals(\"value34\", constants.getResolvedProperty(\"key34\"));\n\t\tassertEquals(\"value35\", constants.getResolvedProperty(\"key35\"));\n\t\tassertEquals(\"value36\", constants.getResolvedProperty(\"key36\"));\n\t\tassertEquals(\"value37\", constants.getResolvedProperty(\"key37\"));\n\t\tassertEquals(\"value38\", constants.getResolvedProperty(\"key38\"));\n\t\tassertEquals(\"value39\", constants.getResolvedProperty(\"key39\"));\n\t\tassertEquals(\"value40\", constants.getResolvedProperty(\"key40\"));\n\t\tassertEquals(\"value41\", constants.getResolvedProperty(\"key41\"));\n\t\tassertEquals(\"value42\", constants.getResolvedProperty(\"key42\"));\n\t\tassertEquals(\"value43\", constants.getResolvedProperty(\"key43\"));\n\t\tassertEquals(\"value44\", constants.getResolvedProperty(\"key44\"));\n\t\tassertEquals(\"value45\", constants.getResolvedProperty(\"key45\"));\n\t\tassertEquals(\"value46\", constants.getResolvedProperty(\"key46\"));\n\t\tassertEquals(\"value47\", constants.getResolvedProperty(\"key47\"));\n\t\tassertEquals(\"value48\", constants.getResolvedProperty(\"key48\"));\n\t\tassertEquals(\"value49\", constants.getResolvedProperty(\"key49\"));\n\t\tassertEquals(\"value50\", constants.getResolvedProperty(\"key50\"));\n\t\tassertEquals(\"value51\", constants.getResolvedProperty(\"key51\"));\n\t\tassertEquals(\"value52\", constants.getResolvedProperty(\"key52\"));\n\t\tassertEquals(\"value53\", constants.getResolvedProperty(\"key53\"));\n\t\tassertEquals(\"value54\", constants.getResolvedProperty(\"key54\"));\n\t\tassertEquals(\"value55\", constants.getResolvedProperty(\"key55\"));\n\t\tassertEquals(\"value56\", constants.getResolvedProperty(\"key56\"));\n\t\tassertEquals(\"value57\", constants.getResolvedProperty(\"key57\"));\n\t\tassertEquals(\"value58\", constants.getResolvedProperty(\"key58\"));\n\t\tassertEquals(\"value59\", constants.getResolvedProperty(\"key59\"));\n\t\tassertEquals(\"value60\", constants.getResolvedProperty(\"key60\"));\n\t\tassertEquals(\"value61\", constants.getResolvedProperty(\"key61\"));\n\t\tassertEquals(\"value62\", constants.getResolvedProperty(\"key62\"));\n\t\tassertEquals(\"value63\", constants.getResolvedProperty(\"key63\"));\n\t\tassertEquals(\"value64\", constants.getResolvedProperty(\"key64\"));\n\t\tassertEquals(\"value65\", constants.getResolvedProperty(\"key65\"));\n\t\tassertEquals(\"value66\", constants.getResolvedProperty(\"key66\"));\n\t\tassertEquals(\"value67\", constants.getResolvedProperty(\"key67\"));\n\t\tassertEquals(\"value68\", constants.getResolvedProperty(\"key68\"));\n\t\tassertEquals(\"value69\", constants.getResolvedProperty(\"key69\"));\n\t\tassertEquals(\"value70\", constants.getResolvedProperty(\"key70\"));\n\t\tassertEquals(\"value71\", constants.getResolvedProperty(\"key71\"));\n\t\tassertEquals(\"value72\", constants.getResolvedProperty(\"key72\"));\n\t\tassertEquals(\"value73\", constants.getResolvedProperty(\"key73\"));\n\t\tassertEquals(\"value74\", constants.getResolvedProperty(\"key74\"));\n\t\tassertEquals(\"value75\", constants.getResolvedProperty(\"key75\"));\n\t", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "9132656_1", "part": [1, 1], "seq": [1, 1], "prompt": "class MavenColorRenderer extends PatternRenderer {\n\n    @Override\n    protected void renderMessage(Event event, StringBuilder buff) {\n        if (!isActivated) {\n            super.renderMessage(event, buff);\n            return;\n        }\n\n        if (event.getLevel() == WARN) {\n            buff.append(colorize(event, YELLOW));\n        } else if (event.getLevel() == INFO) {\n            buff.append(colorizer.colorize(event.getMessage()));\n        } else {\n            super.renderMessage(event, buff);\n        }\n    }\n\n    public  MavenColorRenderer();\n    public  MavenColorRenderer(boolean isActivated);\n    public  MavenColorRenderer(String pattern);\n    public  MavenColorRenderer(String pattern, boolean isActivated);\n\n    @Override protected void renderLevel(Event event, StringBuilder buff);\n    private static String colorize(Event event, Ansi.Color color);\n\n    @Rule\n    public ClearSystemProperties myPropertyIsCleared;\n    private static final Logger LOGGER;\n\n}\n\nclass MavenColorRendererTest {\n\n    @Rule\n    public ClearSystemProperties myPropertyIsCleared;\n    private static final Logger LOGGER;\n\n    @Test\n    public void do_not_colorize_when_colorization_is_deactivated() {\n", "reference": "        StringBuilder result = new StringBuilder();\n\n        new MavenColorRenderer(false).renderMessage(event(WARN, \"warning message\"), result);\n\n        assertThat(result.toString()).isEqualTo(\"warning message\");\n    }\n\n}", "prediction": "        MavenColorRenderer renderer = new MavenColorRenderer(false);\n        Event event = new Event(Level.INFO, \"test\");\n        StringBuilder buff = new StringBuilder();\n        renderer.render(event, buff);\n        assertEquals(\"test\", buff.toString());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "9149127_10", "part": [1, 1], "seq": [1, 1], "prompt": "class JsonHandler implements Serializable {\n\n\tpublic Object parse(String str) {\n\t\tObject ret = deserializer.deserialize(str);\n\t\treturn ret;\n\t}\n\n\tpublic  JsonHandler();\n\n\tpublic static JsonHandler instance();\n\tpublic JSONDeserializer<Object> getDeserializer();\n\tpublic JSONSerializer getSerializer();\n\tpublic String format(Object obj);\n\tpublic void format(Object obj, Writer writer);\n\t@SuppressWarnings(\"unchecked\") public T parse(String str, Class<T> clazz);\n\tpublic void setPrettyPrint(boolean prettyPrint);\n\n\tprivate static final Logger LOG;\n\tprivate JsonHandler handler;\n\n}\n\nclass JsonHandlerTest {\n\n\tprivate static final Logger LOG;\n\tprivate JsonHandler handler;\n\n\t@Test\n\tpublic void testParseBasics() {\n", "reference": "\t\tassertEquals(null, handler.parse(\"null\"));\n\n\t\tassertEquals(true, handler.parse(\"true\"));\n\t\tassertEquals(false, handler.parse(\"false\"));\n\n\t\tassertEquals(\"my string\", handler.parse(\"'my string'\"));\n\t\tassertEquals(\"null\", handler.parse(\"'null'\"));\n\t\tassertEquals(\"true\", handler.parse(\"'true'\"));\n\t\tassertEquals(2, handler.parse(\"2\"));\n\t\tassertEquals(2.4, handler.parse(\"2.4\"));\n\n\t\tassertEquals(\"\", handler.parse(\"''\"));\n\t}\n\n}", "prediction": "\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "9580168_2", "part": [1, 1], "seq": [1, 1], "prompt": "class PmdValidator implements ResourceValidator {\n\n    @Override\n    @SuppressWarnings(\"PMD.AvoidInstantiatingObjectsInLoops\")\n    public Collection<Violation> validate(final Collection<File> files) {\n        final SourceValidator validator = new SourceValidator(this.env);\n        final Collection<DataSource> sources = new LinkedList<>();\n        for (final File file : files) {\n            sources.add(new FileDataSource(file));\n        }\n        final Collection<RuleViolation> breaches = validator.validate(\n            sources, this.env.basedir().getPath()\n        );\n        final Collection<Violation> violations = new LinkedList<>();\n        for (final RuleViolation breach : breaches) {\n            violations.add(\n                new Violation.Default(\n                    this.name(),\n                    breach.getRule().getName(),\n                    breach.getFilename(),\n                    String.format(\n                        \"%d-%d\",\n                        breach.getBeginLine(), breach.getEndLine()\n                    ),\n                    breach.getDescription()\n                )\n            );\n        }\n        return violations;\n    }\n\n    public  PmdValidator(final Environment env);\n\n    @Override public String name();\n\n    private static final String STATIC_ACCESS;\n    private static final String CODE_IN_CON;\n    private static final String NO_CON_INIT;\n    private static final String MULT_CON_INIT;\n    private static final String BRACKETS;\n    private static final String PLAIN_ASSERTIONS;\n    private static final String STATIC_METHODS;\n    private static final String FILES_CREATE_ERR;\n\n}\n\nclass PmdValidatorTest {\n\n    private static final String STATIC_ACCESS;\n    private static final String CODE_IN_CON;\n    private static final String NO_CON_INIT;\n    private static final String MULT_CON_INIT;\n    private static final String BRACKETS;\n    private static final String PLAIN_ASSERTIONS;\n    private static final String STATIC_METHODS;\n    private static final String FILES_CREATE_ERR;\n\n    @Test\n    @SuppressWarnings(\"PMD.AvoidDuplicateLiterals\")\n    public void doesNotComplainAboutConstantsInInnerClasses() throws Exception {\n", "reference": "        final String file = \"src/main/java/foo/Foo.java\";\n        final Environment env = new Environment.Mock().withFile(\n            file,\n            Joiner.on('\\n').join(\n                \"package foo;\",\n                \"interface Foo {\",\n                \"  final class Bar implements Foo {\",\n                \"    private static final Pattern TEST =\",\n                \"      Pattern.compile(\\\"hey\\\");\",\n                \"    public String doSomething() {\",\n                \"      return Foo.Bar.TEST.toString();\",\n                \"    }\",\n                \"  }\",\n                \"}\"\n            )\n        );\n        MatcherAssert.assertThat(\n            new PmdValidator(env).validate(\n                Collections.singletonList(new File(env.basedir(), file))\n            ),\n            Matchers.<Violation>empty()\n        );\n    }\n\n}", "prediction": "        final File file = new File(this.getClass().getResource(\"PmdValidatorTest.java\").toURI());\n        final Collection<Violation> violations = new PmdValidator(this.env).validate(Collections.singleton(file));\n        assertThat(violations).isEmpty();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "9623064_30", "part": [1, 1], "seq": [1, 1], "prompt": "class RequestUtils {\n\n    public static List<Request> from(String exp){\n        Matcher matcher = p4Range.matcher(exp);\n        if (!matcher.find()) {\n            return Collections.singletonList(new Request(exp));\n        }\n        int rangeFrom = Integer.parseInt(matcher.group(1));\n        int rangeTo = Integer.parseInt(matcher.group(2));\n        if (rangeFrom > rangeTo) {\n            return Collections.emptyList();\n        }\n        List<Request> requests = new ArrayList<Request>(rangeTo - rangeFrom + 1);\n        for (int i = rangeFrom; i <= rangeTo; i++) {\n            requests.add(new Request(matcher.replaceAll(String.valueOf(i))));\n        }\n        return requests;\n    }\n\n}\n\nclass RequestUtilsTest {\n\n    @Test\n    public void test_generate_range_when_invalid_number() throws Exception {\n", "reference": "        List<Request> requests = RequestUtils.from(\"http://angularjs.cn/api/article/latest?p=[10-3]&s=20\");\n        assertThat(requests).isEmpty();\n    }\n\n}", "prediction": "        List<Request> requests = RequestUtils.from(\"1-100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "9836604_9", "part": [1, 1], "seq": [1, 1], "prompt": "class LogoutAction {\n\n\t@RequestMapping(\"/getAppList\")\n\tpublic void getAppList(HttpServletRequest request,\n\t\t\tHttpServletResponse response){\n\t\t//\u89e3\u6790\u7528\u6237\u51ed\u636e\u3002\n\t\tCredential credential = credentialResolver.resolveCredential(request);\n\t\t//\u5b9e\u73b0\u8f93\u51fa\u4e3ajson\u4e32\u3002\n\t\tList<App> list =  this.ki4soService.getAppList(credential);\n\t\tString json = JSON.toJSONString(list);\n\t\tStringBuffer sb = new StringBuffer();\n\t\tsb.append(getCallbackName(\"fetchAppList\", request))\n\t\t.append(\"(\")\n\t\t.append(json)\n\t\t.append(\");\");\n\t\ttry {\n\t\t\tresponse.setContentType(\"application/x-javascript\");\n\t\t\tresponse.setCharacterEncoding(\"UTF-8\");\n\t\t\tresponse.getWriter().println(sb.toString());\n\t\t} catch (IOException e) {\n\t\t}\n\t}\n\n\tpublic void setKi4soService(Ki4soService ki4soService);\n\tpublic void setCredentialResolver(CredentialResolver credentialResolver);\n\tprivate String getCallbackName(String defalutCallbackName, HttpServletRequest request);\n\t@RequestMapping(\"/logout\") public void logout(HttpServletRequest request,\n\t\t\tHttpServletResponse response);\n\n\t@Autowired\n\tprivate LogoutAction logoutAction;\n\n}\n\nclass LogoutActionTest {\n\n\t@Autowired\n\tprivate LogoutAction logoutAction;\n\n\t@Test\n\tpublic void testGetAppList() throws UnsupportedEncodingException {\n", "reference": "\t\t//\u6d4b\u8bd5\u51c6\u5907\u3002\n\t\tMockHttpServletRequest request = new MockHttpServletRequest();\n\t\tMockHttpServletResponse response = new MockHttpServletResponse();\n\t\tCredentialResolver credentialResolver = Mockito.mock(CredentialResolver.class);\n\t\tlogoutAction.setCredentialResolver(credentialResolver);\n\t\t\n\t\tKi4soService ki4soService = Mockito.mock(Ki4soService.class);\n\t\tlogoutAction.setKi4soService(ki4soService);\n\t\t\n\t\tCredential credential = Mockito.mock(Credential.class);\n\t\t\n\t\t//\u8bbe\u7f6e\u9884\u671f\u7ed3\u679c\u3002\n\t\tMockito.when(credentialResolver.resolveCredential(request)).thenReturn(credential);\n\t\tList<App> list = new ArrayList<App>();\n\t\tApp app = new App();\n\t\tapp.setAppId(\"1000\");\n\t\tapp.setAppName(\"\u6d4b\u8bd5\u5e94\u7528\u7a0b\u5e8f1\");\n\t\tapp.setHost(\"app.com\");\n\t\tapp.setLogoutUrl(\"http://app.com/logout.do\");\n\t\tlist.add(app);\n\t\tMockito.when(ki4soService.getAppList(credential)).thenReturn(list);\n\t\t\n\t\t//\u6267\u884c\u67e5\u8be2\u3002\n\t\tlogoutAction.getAppList(request, response);\n\t\t\n\t\t//\u68c0\u67e5\u7ed3\u679c\u3002\n\t\tAssert.assertEquals(\"application/x-javascript\", response.getContentType());\n\t\tAssert.assertEquals(\"UTF-8\", response.getCharacterEncoding());\n\t\t//\u68c0\u67e5\u8f93\u51fa\u7684jsonp\u4e32\u662f\u5426\u6b63\u786e\u3002\n\t\tString content = response.getContentAsString();\n\t\tcontent = content.trim();\n\t\tAssert.assertTrue(content.startsWith(\"fetchAppList(\"));\n\t\tAssert.assertTrue(content.endsWith(\");\"));\n\t\tString json = content.replaceFirst(\"fetchAppList\\\\(\", \"\");\n\t\tjson = json.replaceFirst(\"\\\\);\", \"\");\n\t\tJSONArray data = (JSONArray)JSON.parse(json);\n\t\tAssert.assertEquals(1, data.size());\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tMap<String, Object> map = (Map<String, Object>)data.get(0);\n\t\tAssert.assertEquals(\"1000\", map.get(\"appId\"));\n\t\t\n\t}\n\n}", "prediction": "\t\tHttpServletRequest request = mock(HttpServletRequest.class);\n\t\tHttpServletResponse response = mock(HttpServletResponse.class);\n\t\tlogoutAction.getAppList(request, response);\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "9836833_41", "part": [1, 1], "seq": [1, 1], "prompt": "class MoreClasses {\n\n\tpublic static Set<Class> getInheritedClasses(Class clazz) {\n\t\tSet<Class> inheritedClasses = Sets.newHashSet();\n\n\t\t// add super class, and add recursively their inherited classes\n\t\tClass superClass = clazz.getSuperclass();\n\t\tif (superClass!= null) {\n\t\t\tinheritedClasses.add(superClass);\n\t\t\tinheritedClasses.addAll(getInheritedClasses(superClass));\n\t\t}\n\n\t\t// add all interfaces, and recursively add their inherited classes\n\t\tClass[] interfaces = clazz.getInterfaces();\n\t\tfor (Class anInterface : interfaces) {\n\t\t\tinheritedClasses.add(anInterface);\n\t\t\tinheritedClasses.addAll(getInheritedClasses(anInterface));\n\t\t}\n\n\t\treturn inheritedClasses;\n\t}\n\n\tprivate  MoreClasses();\n\n}\n\nclass MoreClassesTest {\n\n\t@Test\n\tpublic void should_find_inherited_super_classes() {\n", "reference": "\t\tassertThat(getInheritedClasses(B.class)).containsOnly(A.class, Object.class);\n\t\tassertThat(getInheritedClasses(C.class)).containsOnly(B.class, A.class, Object.class);\n\t}\n\n}", "prediction": "\t\tSet<Class> inheritedClasses = MoreClasses.getInheritedClasses(MoreClasses.class);\n\t\tassertThat(inheritedClasses).contains(Object.class);\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "10585052_3", "part": [1, 1], "seq": [1, 1], "prompt": "class Stamp implements Serializable {\n\n    public Stamp join(Stamp other) {\n        ID idSum = id.sum(other.id);\n        Event eventJoin = event.join(other.event);\n        return new Stamp(idSum, eventJoin);\n    }\n\n    public  Stamp();\n      Stamp(ID id, Event event);\n\n     ID getId();\n     Event getEvent();\n    public Stamp[] fork();\n    public Stamp[] peek();\n    public Stamp event();\n    @Override public String toString();\n    @Override public boolean equals(Object o);\n    @Override public int hashCode();\n    public Stamp[] send();\n    public Stamp receive(Stamp other);\n    public Stamp[] sync(Stamp other);\n    public boolean leq(Stamp other);\n\n    private Stamp seedStamp;\n    private Stamp forkedStamp1;\n    private Stamp forkedStamp2;\n    private Stamp joinedStamp;\n    private List<Stamp> stamps;\n\n}\n\nclass StampTest {\n\n    private Stamp seedStamp;\n    private Stamp forkedStamp1;\n    private Stamp forkedStamp2;\n    private Stamp joinedStamp;\n    private List<Stamp> stamps;\n\n    @Test\n    public void testJoin() {\n", "reference": "        Stamp expected = new Stamp(IDs.one(),\n                Events.with(1, Events.zero(), Events.with(1)));\n\n        assertEquals(expected, forkedStamp1.join(forkedStamp2));\n        assertEquals(expected, forkedStamp2.join(forkedStamp1));\n        assertNormalizedStamp(forkedStamp1.join(forkedStamp2));\n    }\n\n}", "prediction": "        Stamp joined = seedStamp.join(forkedStamp1);\n        assertEquals(joined.getId(), seedStamp.getId().sum(forkedStamp1.getId()));\n        assertEquals(joined.getEvent(), seedStamp.getEvent().join(forkedStamp1.getEvent()));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "10981994_42", "part": [1, 1], "seq": [1, 1], "prompt": "class Slf4jLogger extends feign.Logger {\n\n  @Override\n  protected void log(String configKey, String format, Object... args) {\n    // Not using SLF4J's support for parameterized messages (even though it would be more efficient)\n    // because it would\n    // require the incoming message formats to be SLF4J-specific.\n    if (logger.isDebugEnabled()) {\n      logger.debug(String.format(methodTag(configKey) + format, args));\n    }\n  }\n\n  public  Slf4jLogger();\n  public  Slf4jLogger(Class<?> clazz);\n  public  Slf4jLogger(String name);\n    Slf4jLogger(Logger logger);\n\n  @Override protected void logRequest(String configKey, Level logLevel, Request request);\n  @Override protected Response logAndRebufferResponse(String configKey,\n                                            Level logLevel,\n                                            Response response,\n                                            long elapsedTime);\n\n  private static final String CONFIG_KEY;\n  private static final Request REQUEST;\n  private static final Response RESPONSE;\n  @Rule\n  public final RecordingSimpleLogger slf4j;\n  private Slf4jLogger logger;\n\n}\n\nclass Slf4jLoggerTest {\n\n  private static final String CONFIG_KEY;\n  private static final Request REQUEST;\n  private static final Response RESPONSE;\n  @Rule\n  public final RecordingSimpleLogger slf4j;\n  private Slf4jLogger logger;\n\n  @Test\n  public void useLoggerByNameIfRequested() throws Exception {\n", "reference": "    slf4j.logLevel(\"debug\");\n    slf4j.expectMessages(\n        \"DEBUG named.logger - [someMethod] This is my message\" + System.lineSeparator());\n\n    logger = new Slf4jLogger(\"named.logger\");\n    logger.log(CONFIG_KEY, \"This is my message\");\n  }\n\n}", "prediction": "    logger = new Slf4jLogger(\"test\");\n    logger.log(CONFIG_KEY, \"test\");\n    assertThat(slf4j.getMessages()).containsExactly(\"test\");\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "10984947_0", "part": [1, 1], "seq": [1, 1], "prompt": "class OAuthDialogFragment extends DialogFragmentCompat {\n\n    static boolean isRedirectUriFound(String uri, String redirectUri) {\n        Uri u = null;\n        Uri r = null;\n        try {\n            u = Uri.parse(uri);\n            r = Uri.parse(redirectUri);\n        } catch (NullPointerException e) {\n            return false;\n        }\n        if (u == null || r == null) {\n            return false;\n        }\n        boolean rOpaque = r.isOpaque();\n        boolean uOpaque = u.isOpaque();\n        if (rOpaque!= uOpaque) {\n            return false;\n        }\n        if (rOpaque) {\n            return TextUtils.equals(uri, redirectUri);\n        }\n        if (!TextUtils.equals(r.getScheme(), u.getScheme())) {\n            return false;\n        }\n        if (!TextUtils.equals(r.getAuthority(), u.getAuthority())) {\n            return false;\n        }\n        if (r.getPort()!= u.getPort()) {\n            return false;\n        }\n        if (!TextUtils.isEmpty(r.getPath()) &&!TextUtils.equals(r.getPath(), u.getPath())) {\n            return false;\n        }\n        Set<String> paramKeys = CompatUri.getQueryParameterNames(r);\n        for (String key : paramKeys) {\n            if (!TextUtils.equals(r.getQueryParameter(key), u.getQueryParameter(key))) {\n                return false;\n            }\n        }\n        String frag = r.getFragment();\n        if (!TextUtils.isEmpty(frag)\n                &&!TextUtils.equals(frag, u.getFragment())) {\n            return false;\n        }\n        return true;\n    }\n\n    private  OAuthDialogFragment(android.app.DialogFragment fragment, boolean fullScreen,\n        boolean horizontalProgress, boolean hideFullScreenTitle);\n    private  OAuthDialogFragment(android.support.v4.app.DialogFragment fragment,\n        boolean fullScreen, boolean horizontalProgress, boolean hideFullScreenTitle);\n\n    final void setController(AuthorizationDialogController controller);\n    @TargetApi(HONEYCOMB) public static final OAuthDialogFragment newInstance(\n            GenericUrl authorizationRequestUrl,\n            DialogFragmentController controller);\n    @Override Dialog onCreateDialog(Bundle savedInstanceState);\n    @Override View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState);\n    @SuppressLint(\"SetJavaScriptEnabled\") @Override void onViewCreated(View view, Bundle savedInstanceState);\n    @Override void onActivityCreated(Bundle savedInstanceState);\n    @Override void onDestroy();\n    @Override void onCancel(DialogInterface dialog);\n    private void onError(String errorMessage);\n    private void setProgressShown(String url, View view, int newProgress);\n\n}\n\nclass OAuthDialogFragmentTest extends DialogFragmentCompat {\n\n    @Test\n    public void testRedirectUriDetection() {\n", "reference": "        String r1 = \"http://localhost\";\n        String r2 = \"http://localhost:8080\";\n        String r3 = \"http://localhost:8080/path\";\n        String r4 = \"http://localhost:8080/path?a=1&b=2\";\n        String r5 = \"http://localhost:8080/path#frag\";\n\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(r1, r1));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(r2, r2));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(r3, r2));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(r4, r2));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(r5, r2));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(r4, r3));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(r5, r3));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(r4, r4));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(r5, r5));\n\n        assertFalse(OAuthDialogFragment.isRedirectUriFound(r1, r2));\n        assertFalse(OAuthDialogFragment.isRedirectUriFound(r1, r3));\n        assertFalse(OAuthDialogFragment.isRedirectUriFound(r1, r4));\n        assertFalse(OAuthDialogFragment.isRedirectUriFound(r1, r5));\n        assertFalse(OAuthDialogFragment.isRedirectUriFound(r2, r1));\n        assertFalse(OAuthDialogFragment.isRedirectUriFound(r2, r3));\n        assertFalse(OAuthDialogFragment.isRedirectUriFound(r2, r4));\n        assertFalse(OAuthDialogFragment.isRedirectUriFound(r2, r5));\n        assertFalse(OAuthDialogFragment.isRedirectUriFound(r3, r1));\n        assertFalse(OAuthDialogFragment.isRedirectUriFound(r3, r4));\n        assertFalse(OAuthDialogFragment.isRedirectUriFound(r3, r5));\n        assertFalse(OAuthDialogFragment.isRedirectUriFound(r4, r1));\n        assertFalse(OAuthDialogFragment.isRedirectUriFound(r4, r5));\n        assertFalse(OAuthDialogFragment.isRedirectUriFound(r5, r1));\n        assertFalse(OAuthDialogFragment.isRedirectUriFound(r5, r4));\n\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(r4 + \"&c=3\", r4));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(\"http://localhost:8080/path?b=2&a=1\", r4));\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(\"http://localhost:8080/path?c=3&b=2&a=1\", r4));\n    }\n\n}", "prediction": "        String uri = \"http://example.com/oauth2callback?code=1234567890\";\n        String redirectUri = \"http://example.com/oauth2callback\";\n        assertTrue(OAuthDialogFragment.isRedirectUriFound(uri, redirectUri));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "11136641_144", "part": [1, 1], "seq": [1, 1], "prompt": "class LdapRdn implements Serializable, Comparable {\n\n\tpublic int hashCode() {\n\t\treturn this.getClass().hashCode() ^ new HashSet(getComponents()).hashCode();\n\t}\n\n\tpublic  LdapRdn();\n\tpublic  LdapRdn(String string);\n\tpublic  LdapRdn(String key, String value);\n\n\tpublic void addComponent(LdapRdnComponent rdnComponent);\n\tpublic List getComponents();\n\tpublic LdapRdnComponent getComponent();\n\tpublic LdapRdnComponent getComponent(int idx);\n\tpublic String getLdapEncoded();\n\tpublic String encodeUrl();\n\tpublic int compareTo(Object obj);\n\tpublic boolean equals(Object obj);\n\tpublic String toString();\n\tpublic String getValue();\n\tpublic String getKey();\n\tpublic String getValue(String key);\n\tpublic LdapRdn immutableLdapRdn();\n\n}\n\nclass LdapRdnTest {\n\n    @Test\n    public void verifyThatHashcodeDisregardsOrder_Ldap260() throws Exception {\n", "reference": "        LdapRdn rdn1 = new LdapRdn(\"cn=john doe+sn=doe\");\n        LdapRdn rdn2 = new LdapRdn(\"sn=doe+cn=john doe\");\n\n        assertThat(rdn2.hashCode()).as(\"Should be equal\").isEqualTo(rdn1.hashCode());\n    }\n\n}", "prediction": "\tLdapRdn rdn1 = new LdapRdn(\"cn=test1,ou=test,dc=example,dc=com\");\n\tLdapRdn rdn2 = new LdapRdn(\"ou=test,dc=example,dc=com,cn=test1\");\n\tassertEquals(rdn1.hashCode(), rdn2.hashCode());\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "11556529_9", "part": [1, 1], "seq": [1, 1], "prompt": "class PauselessHashMap extends java.util.AbstractMap<K, V> implements Map<K, V>,\n        Cloneable, Serializable {\n\n    @Override\n    public V put(K key, V value) {\n        return putImpl(key, value);\n    }\n\n    public  PauselessHashMap();\n    public  PauselessHashMap(int capacity);\n    public  PauselessHashMap(int capacity, float loadFactor);\n    public  PauselessHashMap(Map<? extends K,? extends V> map);\n\n    @SuppressWarnings(\"unchecked\") Entry<K, V>[] newElementArray(int s);\n    private static final int calculateCapacity(int x);\n    @Override public void clear();\n    private void clearImpl();\n    @Override public Object clone();\n    @SuppressWarnings(\"unchecked\") private Object cloneImpl();\n    private void computeThreshold();\n    @Override public boolean containsKey(Object key);\n    @Override @SuppressWarnings(\"unchecked\") public boolean containsValue(Object value);\n    @Override public Set<Map.Entry<K, V>> entrySet();\n    @Override public V get(Object key);\n    final Entry<K, V> getEntry(Object key);\n    final Entry<K,V> findNonNullKeyEntry(Object key, int index, int keyHash);\n    @SuppressWarnings(\"unchecked\") final Entry<K,V> findNonNullKeyEntryInElementData(Object key, int index, int keyHash);\n    @SuppressWarnings(\"unchecked\") final Entry<K,V> findNonNullKeyEntryInResizingIntoElementData(Object key, int index, int keyHash);\n    final Entry<K,V> findNonNullKeyEntryInChain(Object key, Entry<K,V> chainHead, int keyHash);\n    final Entry<K,V> findNullKeyEntry();\n    @SuppressWarnings(\"unchecked\") final Entry<K,V> findNullKeyEntryInElementData();\n    @SuppressWarnings(\"unchecked\") final Entry<K,V> findNullKeyEntryInResizingIntoElementData();\n    final Entry<K,V> findNullKeyEntryInChain(Entry<K,V> chainHead);\n    @Override public boolean isEmpty();\n    @Override public Set<K> keySet();\n    private V putImpl(K key, V value);\n     void forceFinishResizing();\n     void finishResizing();\n    @SuppressWarnings(\"unchecked\") Entry<K, V> createEntry(K key, int index, V value);\n    @SuppressWarnings(\"unchecked\") Entry<K,V> createHashedEntry(K key, int index, int hash);\n    @Override public void putAll(Map<? extends K,? extends V> map);\n    private void putAllImpl(Map<? extends K,? extends V> map);\n     void rehash(int capacity);\n     void rehash();\n    @Override public V remove(Object key);\n    private V removeImpl(Object key);\n    @SuppressWarnings(\"unchecked\") final void removeEntry(Entry<K, V> entry);\n    @SuppressWarnings(\"unchecked\") final Entry<K, V> removeEntry(Object key);\n    @Override public int size();\n    @Override public Collection<V> values();\n    private void writeObject(ObjectOutputStream stream);\n    @SuppressWarnings(\"unchecked\") private void readObject(ObjectInputStream stream);\n    static int computeHashCode(Object key);\n    static boolean areEqualKeys(Object key1, Object key2);\n    static boolean areEqualValues(Object value1, Object value2);\n    final void kickBackgroundResize(int capacity);\n    final void doResize(int capacity);\n\n     PauselessHashMap hm;\n    final static int hmSize;\n    static Object[] objArray;\n    static Object[] objArray2;\n\n}\n\nclass PauselessHashMapTest extends java.util.AbstractMap<K, V> {\n\n     PauselessHashMap hm;\n    final static int hmSize;\n    static Object[] objArray;\n    static Object[] objArray2;\n\n    @Test\n    public void testSerializationSelf() throws Exception {\n", "reference": "        PauselessHashMap<String, String> hm = new PauselessHashMap<String, String>();\n        hm.put(\"key\", \"value\");\n\n//        SerializationTest.verifySelf(hm);\n\n        //  regression for HARMONY-1583\n        hm.put(null, \"null\");\n//        SerializationTest.verifySelf(hm);\n    }\n\n}", "prediction": "        hm.put(\"a\", \"b\");\n        hm.put(\"c\", \"d\");\n        hm.put(\"e\", \"f\");\n        hm.put(\"g\", \"h\");\n        hm.put(\"i\", \"j\");\n        hm.put(\"k\", \"l\");\n        hm.put(\"m\", \"n\");\n        hm.put(\"o\", \"p\");\n        hm.put(\"q\", \"r\");\n        hm.put(\"s\", \"t\");\n        hm.put(\"u\", \"v\");\n        hm.put(\"w\", \"x\");\n        hm.put(\"y\", \"z\");\n        hm.put(\"aa\", \"bb\");\n        hm.put(\"cc\", \"dd\");\n        hm.put(\"ee\", \"ff\");\n        hm.put(\"gg\", \"hh\");\n        hm.put(\"ii\", \"jj\");\n        hm.put(\"kk\", \"ll\");\n        hm.put(\"mm\", \"nn\");\n        hm.put(\"oo\", \"pp\");\n        hm.put(\"qq\", \"rr\");\n        hm.put(\"ss\", \"tt\");\n        hm.put(\"uu\", \"vv\");\n        hm.put(\"ww\", \"xx\");\n        hm.put(\"yy\", \"zz\");\n        hm.put(\"aaa\", \"bbb\");\n        hm.put(\"ccc\", \"ddd\");\n        hm.put(\"eee\", \"fff\");\n        hm.put(\"ggg\", \"hhh\");\n        hm.put(\"iii\", \"jjj\");\n        hm.put(\"kkk\", \"lll\");\n        hm.put(\"mmm\", \"nnn\");\n        hm.put(\"ooo\", \"ppp\");\n        hm.put(\"qqq\", \"rrr\");\n        hm.put(\"sss\", \"ttt\");\n        hm.put(\"uuu\", \"vvv\");\n        hm.put(\"www\", \"xxx\");\n        hm.put(\"yyy\", \"zzz\");\n        hm.put(\"aaaa\", \"bbbb\");\n        hm.put(\"cccc\", \"dddd\");\n        hm.put(\"eeee\", \"ffff\");\n        hm.put(\"gggg\", \"hhhh\");\n        hm.put(\"iiii\", \"jjjj\");\n        hm.put(\"kkkk\", \"llll\");\n        hm.put(\"mmmm\", \"nnnn\");\n        hm.put(\"oooo\", \"pppp\");\n        hm.put(\"qqqq\", \"rrrr\");\n        hm.put(\"ssss\", \"tttt\");\n        hm.put(\"uuuu\", \"vvvv\");\n        hm.put(\"wwww\", \"xxxx\");\n        hm.put(\"yyyy\", \"zzzz\");\n        hm.put(\"aaaaa\", \"bbbbb\");\n        hm.put(\"ccccc\", \"ddddd\");\n        hm.put(\"eeeee\", \"fffff\");\n        hm.put(\"ggggg\", \"hhhhh\");\n        hm.put(\"iiiii\", \"jjjjj\");\n        hm.put(\"kkkkk\", \"lllll\");\n        hm.put(\"mmmmm\", \"nnnnn\");\n        hm.put(\"ooooo\", \"ppppp\");\n        hm.put(\"qqqqq\", \"rrrrr\");\n        hm.put(\"sssss\", \"ttttt\");\n        hm.put(\"uuuuu\", \"vvvvv\");\n        hm.put(\"wwwww\", \"xxxxx\");\n        hm.put(\"yyyyy\", \"zzzzz\");\n        hm.put(\"aaaaaa\", \"bbbbbb\");\n        hm.put(\"cccccc\", \"dddddd\");\n        hm.put(\"eeeeee\", \"ffffff\");\n        hm.put(\"gggggg\", \"hhhhhh\");\n        hm.put(\"iiiiii\", \"jjjjjj\");\n        hm.put(\"kkkkkk\", \"llllll\");\n        hm.put(\"mmmmmm\", \"nnnnnn\");\n        hm.put(\"oooooo\", \"pppppp\");\n        hm.put(\"qqqqqq\", \"rrrrrr\");\n        hm.put(\"ssssss\", \"tttttt\");\n        hm.put(\"uuuuuu\", \"vvvvvv\");\n        hm.put(\"wwwwww\", \"xxxxxx\");\n        hm.put(\"yyyyyy\", \"zzzzzz\");\n        hm.put(\"aaaaaaa\", \"bbbbbbb\");\n        hm.put(\"ccccccc\", \"ddddddd\");\n        hm.put(\"eeeeeee\", \"ffffff\");\n        hm.put(\"ggggggg\", \"hhhhhhh\");\n        hm.put(\"iiiiiii\", \"jjjjjjj\");\n        hm.put(\"kkkkkkk\", \"lllllll\");\n        hm.put(\"mmmmmmm\", \"nnnnnnn\");\n        hm.put(\"ooooooo\", \"ppppppp\");\n        hm.put(\"qqqqqqq\", \"rrrrrrr\");\n        hm.put(\"sssssss\", \"ttttttt\");\n        hm.put(\"uuuuuuu\", \"vvvvvvv\");\n        hm.put(\"wwwwwww\", \"xxxxxxx\");\n        hm.put(\"yyyyyyy\", \"zzzzzzz\");\n        hm.put(\"aaaaaaaa\", \"bbbbbbbb\");\n        hm.put(\"cccccccc\", \"dddddddd\");\n        hm.put(\"eeeeeeee\", \"ffffffff\");\n        hm.put(\"gggggggg\", \"hhhhhhhh\");\n        hm.put(\"iiiiiiii\", \"jjjjjjjj\");\n        hm.put(\"kkkkkkkk\", \"llllllll\");\n        hm.put(\"mmmmmmmm\", \"nnnnnnnn\");\n        hm.put(\"oooooooo\", \"pppppppp\");\n        hm.put(\"qqqqqqqq\", \"rrrrrrrr\");\n        hm.put(\"ssssssss\", \"tttttttt\");\n       ", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "11585818_8", "part": [1, 1], "seq": [1, 1], "prompt": "class LogJobFactory implements AsynchronousSpanSink.JobFactory {\n\n    public static LogJobFactory withWriter(final Writer writer) {\n        if (writer == null) throw new NullPointerException(\"Writer must not be null\");\n        return withWriterProvider(new WriterProvider() {\n            @Override\n            public Writer getWriter() throws IOException {\n                return writer;\n            }\n        });\n    }\n\n    private  LogJobFactory(WriterProvider writerProvider);\n\n    public static LogJobFactory withFile(final String file);\n    @Override public Runnable createJob(SpanData data);\n    private static LogJobFactory withWriterProvider(WriterProvider writerProvider);\n\n}\n\nclass LogJobFactoryTest {\n\n    @Test\n    public void testCreateWithWriter() throws Exception {\n", "reference": "        LogJobFactory.withWriter(new StringWriter());\n    }\n\n}", "prediction": "        Writer writer = mock(Writer.class);\n        LogJobFactory factory = LogJobFactory.withWriter(writer);\n        factory.createJob(new SpanData());\n        verify(writer).write(anyString());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "11614244_58", "part": [1, 1], "seq": [1, 1], "prompt": "class EqualQa implements Qa<Boolean, Boolean> {\n\n    @Override\n    public TransientOperation<Boolean, Boolean> evaluate(final BufferedImage left, final BufferedImage right) {\n        // Check size\n        CheckEqualSizePreprocessor equalSize = new CheckEqualSizePreprocessor(left, right);\n        equalSize.process();\n        equalSize = null;\n\n        ConvenientBufferedImageWrapper leftWrapped = new ConvenientBufferedImageWrapper(left);\n        ConvenientBufferedImageWrapper rightWrapped = new ConvenientBufferedImageWrapper(right);\n        AutoColorConverter convLeft = new AutoColorConverter(leftWrapped, rightWrapped,\n                                                             AutoColorConverter.AlternativeColorConverter.CIEXYZ);\n        AutoColorConverter convRight = new AutoColorConverter(rightWrapped, leftWrapped,\n                                                              AutoColorConverter.AlternativeColorConverter.CIEXYZ);\n\n        // Evaluate\n        EqualMetric metric = new EqualMetric(convLeft, convRight, new Point(0, 0),\n                                             new Point(left.getWidth(), left.getHeight()));\n\n        // Evaluate\n        return metric.execute();\n    }\n\n}\n\nclass EqualQaTest  {\n\n    @Test\n    public void evaluateTest_half000000_111111_half000000_111111() {\n", "reference": "        BufferedImage left = BufferedImageHelper.createSolidHalfImage(new Color(0, 0, 0), new Color(255, 255, 255));\n        BufferedImage right = BufferedImageHelper.createSolidHalfImage(new Color(0, 0, 0), new Color(255, 255, 255));\n\n        EqualQa equalQa = new EqualQa();\n        TransientOperation<Boolean, Boolean> op = equalQa.evaluate(left, right);\n        Assert.assertEquals(true, op.getAggregatedResult());\n        Assert.assertEquals(true, op.getResult());\n    }\n\n}", "prediction": "        BufferedImage left = new BufferedImage(2, 2, BufferedImage.TYPE_INT_RGB);\n        left.setRGB(0, 0, 0);\n        left.setRGB(1, 0, 0);\n        left.setRGB(0, 1, 0);\n        left.setRGB(1, 1, 0);\n\n        BufferedImage right = new BufferedImage(2, 2, BufferedImage.TYPE_INT_RGB);\n        right.setRGB(0, 0, 0);\n        right.setRGB(1, 0, 0);\n        right.setRGB(0, 1, 0);\n        right.setRGB(1, 1, 0);\n\n        EqualQa qa = new EqualQa();\n        TransientOperation<Boolean, Boolean> result = qa.evaluate(left, right);\n        assertTrue(result.getResult());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "11799031_108", "part": [1, 1], "seq": [1, 1], "prompt": "class EmailHandler {\n\n\tpublic static void sendMessage(EmailMessage message) throws AddressException, MessagingException {\n\t\tProperties properties = System.getProperties();\n\n                properties.put(\"mail.smtp.host\", AppConstant.EMAIL_HOST.getValue());\n                properties.put(\"mail.smtp.port\", AppConstant.EMAIL_PORT.getValue());\n\n\t\tSession session = Session.getInstance(properties, null);\n\t\tsession.setDebug(true);\n\n\t\tMessage msg = new MimeMessage(session);\n                \n\t\tInternetAddress[] bccList = new InternetAddress[message.getBcc().size()];\n\t\tfor (int counter = 0;counter < message.getBcc().size();counter++)  {\n\t\t\tInternetAddress email = new InternetAddress();\n\t\t\temail.setAddress(message.getBcc().get(counter));\n\t\t\tbccList[counter] = email;\n\t\t}\n\n\t\tInternetAddress[] ccList = new InternetAddress[message.getCc().size()];\n\t\tfor (int counter = 0;counter < message.getCc().size();counter++)  {\n\t\t\tInternetAddress email = new InternetAddress();\n\t\t\temail.setAddress(message.getCc().get(counter));\n\t\t\tccList[counter] = email;\n\t\t}\n\n\t\tmsg.setRecipient(Message.RecipientType.TO, new InternetAddress(message.getTo()));\n\t\tif (bccList.length > 0) {\n\t\t\tmsg.setRecipients(Message.RecipientType.BCC, bccList);\n\t\t}\n\t\tif (ccList.length > 0) {\n\t\t\tmsg.setRecipients(Message.RecipientType.CC, ccList);\n\t\t}\n\t\tmsg.setFrom(new InternetAddress(message.getFrom()));\n\t\tmsg.setSubject(message.getSubject());\n\t\tmsg.setContent(message.getContent(), \"text/plain\");\n                msg.setReplyTo(message.getReplyTo());\n\t\t\n                Transport.send(msg);\n\t\tlog.info(new StringBuilder(\"Sent E-Mail From: \")\n                       .append(message.getFrom())\n                       .append(\" To: \")\n                       .append(message.getTo())\n                       .append(\" Content: \" )\n                       .append(message.getContent()).toString()\n                        );\n\t}\n\n    private static org.slf4j.Logger log;\n\n}\n\nclass EmailHandlerTest {\n\n    private static org.slf4j.Logger log;\n\n    @Test\n    @Ignore\n    public void testSendMessageWithBcc() throws Exception {\n", "reference": "        List<String> bcc = new ArrayList<String>();\n        bcc.add(\"test@test.ing.gov\");\n        bcc.add(\"test@test.ing.gov\");\n        EmailMessage message = new EmailMessage(\"test@test.doesnt.exist.gov\", \"test@testing.purposes.on.ly.gov\", bcc, bcc, \"Test\", \"Test\");\n\n        try {\n            EmailHandler.sendMessage(message);\n        } catch (Exception e) {\n            assert(false);\n        }\n\n        assert(true);\n    }\n\n}", "prediction": "\tEmailMessage message = new EmailMessage();\n\tmessage.setFrom(\"\");\n\tmessage.setTo(\"\");\n\tmessage.setSubject(\"Test Email\");\n\tmessage.setContent(\"This is a test email\");\n\tmessage.setCc(Arrays.asList(\"\"));\n\tmessage.setBcc(Arrays.asList(\"\"));\n\n\tEmailHandler.sendMessage(message);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "12061606_111", "part": [1, 1], "seq": [1, 1], "prompt": "class Parser {\n\n    static Graph strict(String str) throws InvalidSmilesException {\n        return new Parser(CharBuffer.fromString(str), true).molecule();\n    }\n\n      Parser(CharBuffer buffer, boolean strict);\n      Parser(String str);\n\n    static Graph losse(String str);\n     Graph molecule();\n    private void createTopologies(CharBuffer buffer);\n    public List<Edge> getEdges(LocalArrangement localArrangement, int u);\n    private int getOtherDb(int u, int v);\n    private int[] findExtendedTetrahedralEnds(int focus);\n    private List<Edge> getLocalEdges(int end);\n    public int[] getAlleneCarriers(int focus);\n    private void addTopology(int u, Configuration c);\n    private int[] insertThImplicitRef(int u, int[] vs);\n    private int[] insertDbImplicitRef(int u, int[] vs);\n    private void addAtom(Atom a, CharBuffer buffer);\n    private void readSmiles(final CharBuffer buffer);\n     Atom readBracketAtom(final CharBuffer buffer);\n    static int readHydrogens(final CharBuffer buffer);\n    static int readCharge(final CharBuffer buffer);\n    private static int readCharge(int acc, final CharBuffer buffer);\n    static int readClass(CharBuffer buffer);\n    private void ring(int rnum, CharBuffer buffer);\n    private void openRing(int rnum, CharBuffer buf);\n    private LocalArrangement createArrangement(int u);\n    private void closeRing(int rnum, CharBuffer buffer);\n     Bond decideBond(final Bond a, final Bond b, int pos, CharBuffer buffer);\n    static Graph parse(String str);\n    public Collection<? extends String> getWarnings();\n\n}\n\nclass ParserTest {\n\n    @Test\n    public void hydrogen_strict_okay() throws IOException {\n", "reference": "        Graph g = Parser.strict(\"[H][H]\");\n    }\n\n}", "prediction": "        Graph g = Parser.strict(\"C\");\n        assertEquals(1, g.getVertices());\n        assertEquals(0, g.getEdges());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "12481904_3", "part": [1, 1], "seq": [1, 1], "prompt": "class Organization extends Party {\n\n    public List<Department> listChildDepartments() {\n        String jpql = \"select c from OrgLineMgmt o join o.responsible c \" +\n                \"where o.commissioner = :commissioner and TYPE(c) = Department\";\n        return getRepository().createJpqlQuery(jpql).addParameter(\"commissioner\", this).list();\n    }\n\n    public  Organization();\n    public  Organization(String name);\n\n    public Organization getParent(Date date);\n    public List<Organization> getChildren(Date date);\n    public List<Company> listChildCompanies();\n    public Set<Post> getPosts(Date date);\n    @Override public void terminate(Date date);\n    private boolean hasEmployees(Date date);\n    @Override public String toString();\n\n}\n\nclass OrganizationTest extends Party {\n\n    @Test\n    public final void listChildDepartments() {\n", "reference": "        OrganisationUtils organisationUtils = new OrganisationUtils();\n        Date date = DateUtils.date(2012, 1, 3);\n        Company headquarter = organisationUtils.createCompany(\"\u603b\u516c\u53f8\", date);\n        headquarter.save();\n        Department financial = organisationUtils.createDepartment(\"\u8d22\u52a1\u90e8\", headquarter, date);\n        Company company1 = organisationUtils.createCompany(\"\u5206\u516c\u53f81\", headquarter, date);\n        Department dept1 = organisationUtils.createDepartment(\"\u6838\u7b97\u79d1\", financial, date);\n        Department dept2 = organisationUtils.createDepartment(\"\u8d22\u52a1\u90e82\", company1, date);\n\n        List<Department> departments = headquarter.listChildDepartments();\n\n        assertTrue(departments.contains(financial));\n        assertFalse(departments.contains(company1));\n        assertFalse(departments.contains(dept1));\n        assertFalse(departments.contains(dept2));\n    }\n\n}", "prediction": "        Organization org = new Organization(\"Test Organization\");\n        Department dep1 = new Department(\"Test Department 1\");\n        Department dep2 = new Department(\"Test Department 2\");\n        org.addResponsible(dep1);\n        org.addResponsible(dep2);\n        List<Department> deps = org.listChildDepartments();\n        assertEquals(2, deps.size());\n        assertTrue(deps.contains(dep1));\n        assertTrue(deps.contains(dep2));\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "12483976_0", "part": [1, 1], "seq": [1, 1], "prompt": "class AsyncRunner {\n\n    public static <RESULT> RESULT run(Callable<RESULT> task) throws ExecutionException, InterruptedException {\n        return submit(null, task).get().unwrap();\n    }\n\n    private  AsyncRunner();\n\n    public static Future<AsyncResult<RESULT>> submit(Callback<RESULT> callback, Callable<RESULT> task);\n    public static RESULT run(Callable<RESULT> task, long timeout, TimeUnit unit);\n    public static void setExecutor(AsyncExecutor executor);\n\n    @Rule\n    public ExpectedException exception;\n\n}\n\nclass AsyncRunnerTest {\n\n    @Rule\n    public ExpectedException exception;\n\n    @Test\n    public void runIsSynchronous() throws Exception {\n", "reference": "        final long timeout = 5000;\n\n        Callable<Boolean> task = new Callable<Boolean>() {\n            @Override\n            public Boolean call() throws Exception {\n                Thread.sleep(timeout);\n                return false;\n            }\n        };\n\n        long startTime = System.currentTimeMillis();\n\n        Boolean result = AsyncRunner.run(task);\n\n        long endTime = System.currentTimeMillis();\n\n        assertThat(result, is(false));\n        assertThat(endTime - startTime, greaterThanOrEqualTo(timeout));\n    }\n\n}", "prediction": "        AsyncRunner.run(new Callable<String>() {\n            @Override\n            public String call() throws Exception {\n                return \"foo\";\n            }\n        });\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "12504536_4", "part": [1, 1], "seq": [1, 1], "prompt": "class BallExecutorDelivery implements BallResponseDelivery {\n\n    @Override\n    public void postEmptyIntermediateResponse(BallRequest request, BallResponse.ResponseSource responseSource) {\n        request.addMarker(MARKER_POST_EMPTY_INTERMEDIATE_RESPONSE);\n        mResponsePoster.execute(new EmptyIntermediateDeliveryRunnable(request, responseSource, mNetworkQueue));\n    }\n\n    public  BallExecutorDelivery(final Handler handler, PriorityBlockingQueue<BallRequest> networkQueue);\n    public  BallExecutorDelivery(Executor executor);\n\n    @Override public void postResponse(BallRequest<?> request, BallResponse<?> response);\n    @Override public void postResponseAndForwardToNetwork(BallRequest<?> request, BallResponse<?> response);\n    @Override public void postError(BallRequest<?> request, VolleyError error);\n\n    private BallResponseDelivery mResponseDelivery;\n    private BallRequest mRequest;\n    private BallResponse mResponse;\n\n}\n\nclass BallExecutorDeliveryTest {\n\n    private BallResponseDelivery mResponseDelivery;\n    private BallRequest mRequest;\n    private BallResponse mResponse;\n\n    @Test\n    public void shouldIgnoreEmptyIntermediateResponseWhenFinalIsNotDelivered() {\n", "reference": "        when(mRequest.isFinished()).thenReturn(false);\n        when(mRequest.isIntermediateResponseDelivered()).thenReturn(false);\n        when(mRequest.isFinalResponseDelivered()).thenReturn(false);\n\n        mResponseDelivery.postEmptyIntermediateResponse(mRequest, BallResponse.ResponseSource.LOCAL);\n\n        verify(mRequest).setIntermediateResponseDelivered(true);\n        verify(mRequest, never()).deliverError(any(VolleyError.class));\n        verify(mRequest, never()).finish(anyString());\n    }\n\n}", "prediction": "        mResponseDelivery.postEmptyIntermediateResponse(mRequest, BallResponse.ResponseSource.NETWORK);\n        verify(mRequest, never()).addMarker(BallRequest.MARKER_POST_EMPTY_INTERMEDIATE_RESPONSE);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "13040953_38", "part": [1, 1], "seq": [1, 1], "prompt": "class Strings {\n\n    public static String toLowerCase(final String s) {\n        if (s == null) {\n            return null;\n        } else {\n            return s.toLowerCase(Locale.ENGLISH);\n        }\n    }\n\n    private  Strings();\n\n    public static boolean isNull(final String s);\n    public static boolean isEmpty(final String s);\n    public static boolean isNotEmpty(final String s);\n    public static boolean isBlank(final String s);\n    public static String trim(final String s);\n    public static String trimToNull(final String s);\n    public static String trimToEmpty(final String s);\n\n}\n\nclass StringsTest {\n\n    @Test\n    public void testToLowerCase() {\n", "reference": "\n        final String nullString = null;\n        final String emptyString = \"\";\n        final String blankString = \" \";\n        final String string = \"A\";\n\n        assertThat(Strings.toLowerCase(nullString), is(nullValue()));\n        assertThat(Strings.toLowerCase(emptyString), is(\"\"));\n        assertThat(Strings.toLowerCase(blankString), is(\" \"));\n        assertThat(Strings.toLowerCase(string), is(\"a\"));\n    }\n\n}", "prediction": "        assertEquals(\"abc\", Strings.toLowerCase(\"ABC\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"abc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"AbC\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"abc\", Strings.toLowerCase(\"aBc\"));\n        assertEquals(\"", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "13146848_37", "part": [1, 1], "seq": [1, 1], "prompt": "class CoordinatesValidator implements ConstraintValidator<ValidCoordinates, RectangularBox> {\n\n    @Override\n    public boolean isValid(RectangularBox value, ConstraintValidatorContext context) {\n        if (value!= null) {\n            return value.getTop() > value.getBottom() && value.getRight() > value.getLeft();\n        }\n        return true;\n    }\n\n    @Override public void initialize(ValidCoordinates constraintAnnotation);\n\n    private CoordinatesValidator victim;\n    private RectangularBox box;\n\n}\n\nclass CoordinatesValidatorTest {\n\n    private CoordinatesValidator victim;\n    private RectangularBox box;\n\n    @Test\n    public void testNull() {\n", "reference": "        assertTrue(victim.isValid(null, null));\n    }\n\n}", "prediction": "        assertTrue(victim.isValid(null, null));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "13185812_4", "part": [1, 1], "seq": [1, 1], "prompt": "class DexcomAdapterService implements AdapterService<DexcomSyncData> {\n\n  @Override\n  public SyncData convertData(DexcomSyncData source) {\n    List<GlucoseRead> glucoseReads = newArrayList(Collections2.filter(Collections2.transform(source.getGlucoseReads(),\n        DEXCOM_GLUCOSE_RECORD_TO_GLUCOSE_READ), VALID_READS_FILTER));\n\n    DeviceInfo deviceInfo = DEXCOM_MANUFACTURING_PARAMS_TO_DEVICE_INFO.apply(source.getManufacturingParameters());\n\n    Collection<UserEventRecord> insulinEvents = Collections2.filter(source.getUserEvents(), INSULIN_EVENT_FILTER);\n    Collection<UserEventRecord> exerciseEvents = Collections2.filter(source.getUserEvents(), EXERCISE_EVENT_FILTER);\n    Collection<UserEventRecord> carbEvents = Collections2.filter(source.getUserEvents(), CARB_EVENT_FILTER);\n\n    List<InsulinInjection> injections =\n        newArrayList(Collections2.transform(insulinEvents, USER_EVENT_RECORD_TO_INSULIN_INJECTION));\n    List<ExerciseSession> exerciseSessions =\n        newArrayList(Collections2.transform(exerciseEvents, USER_EVENT_RECORD_TO_EXERCISE_SESSION));\n    List<FoodEvent> foodEvents =\n        newArrayList(Collections2.transform(carbEvents, USER_EVENT_RECORD_TO_FOOD_EVENT));\n\n    return new SyncData(glucoseReads, injections, foodEvents, exerciseSessions, deviceInfo, source.getUpdateTime());\n  }\n\n  private static final String SERIAL_NUMBER;\n  private static final String HARDWARE_REVISION;\n  private static final String HARDWARE_ID;\n  private static final Integer NORMAL_READ_TEST_VALUE;\n  private static final List<GlucoseRead> EMPTY_GLUCOSE_READS;\n  private static final List<GlucoseReadRecord> EMPTY_GLUCOSE_READ_RECORDS;\n  private static final List<InsulinInjection> EMPTY_INSULIN_INJECTIONS;\n  private static final List<UserEventRecord> EMPTY_USER_EVENT_RECORDS;\n  private static final List<FoodEvent> EMPTY_FOOD_EVENTS;\n  private static final List<ExerciseSession> EMPTY_EXERCISE_SESSIONS;\n  private static final Instant TEST_TIME;\n\n}\n\nclass TestDexcomAdapterService {\n\n  private static final String SERIAL_NUMBER;\n  private static final String HARDWARE_REVISION;\n  private static final String HARDWARE_ID;\n  private static final Integer NORMAL_READ_TEST_VALUE;\n  private static final List<GlucoseRead> EMPTY_GLUCOSE_READS;\n  private static final List<GlucoseReadRecord> EMPTY_GLUCOSE_READ_RECORDS;\n  private static final List<InsulinInjection> EMPTY_INSULIN_INJECTIONS;\n  private static final List<UserEventRecord> EMPTY_USER_EVENT_RECORDS;\n  private static final List<FoodEvent> EMPTY_FOOD_EVENTS;\n  private static final List<ExerciseSession> EMPTY_EXERCISE_SESSIONS;\n  private static final Instant TEST_TIME;\n\n  @Test\n  public void multipleReadsShouldAllBeConverted() throws Exception {\n", "reference": "    DexcomAdapterService dexcomAdapterService = new DexcomAdapterService();\n    List<GlucoseReadRecord> glucoseRecords = Arrays.asList(new GlucoseReadRecord(1000, 1000, NORMAL_READ_TEST_VALUE, (byte) 0, 1L, 1L),\n        new GlucoseReadRecord(2000, 2000, NORMAL_READ_TEST_VALUE, (byte) 0, 1L, 1L));\n    SyncData syncData = dexcomAdapterService.convertData(new DexcomSyncData(glucoseRecords, EMPTY_USER_EVENT_RECORDS,\n        new ManufacturingParameters(SERIAL_NUMBER, \"partNumber\", HARDWARE_REVISION, \"2013-10-18 10:10\", HARDWARE_ID),\n            TEST_TIME));\n\n    GlucoseRead expectedRead1 = new GlucoseRead(\n        internalTimeFromSeconds(1000L),\n        localDateTimeFromSeconds(1000L),\n        NORMAL_READ_TEST_VALUE.floatValue(),\n        GlucoseRead.Unit.MG_PER_DL);\n\n    GlucoseRead expectedRead2 = new GlucoseRead(\n        internalTimeFromSeconds(2000L),\n        localDateTimeFromSeconds(2000L),\n        NORMAL_READ_TEST_VALUE.floatValue(),\n        GlucoseRead.Unit.MG_PER_DL);\n    SyncData expectedSyncData = new SyncData(Arrays.asList(expectedRead1, expectedRead2), EMPTY_INSULIN_INJECTIONS,\n        EMPTY_FOOD_EVENTS, EMPTY_EXERCISE_SESSIONS, new DeviceInfo(SERIAL_NUMBER, HARDWARE_ID, HARDWARE_REVISION),\n            TEST_TIME);\n\n    assertThat(syncData, is(equalTo(expectedSyncData)));\n  }\n\n}", "prediction": "    DexcomSyncData source = new DexcomSyncData(SERIAL_NUMBER, HARDWARE_REVISION, HARDWARE_ID,\n        EMPTY_GLUCOSE_READ_RECORDS, EMPTY_USER_EVENT_RECORDS, TEST_TIME);\n\n    SyncData result = new DexcomAdapterService().convertData(source);\n\n    assertThat(result.getGlucoseReads()).hasSize(1);\n    assertThat(result.getInsulinInjections()).isEmpty();\n    assertThat(result.getFoodEvents()).isEmpty();\n    assertThat(result.getExerciseSessions()).isEmpty();\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "13218559_6", "part": [1, 1], "seq": [1, 1], "prompt": "class SpaceBattleSimulation {\n\n\tpublic static void engagement(Ship enemy, Ship friend){\n\t\twhile(!enemy.isDestroyed && friend.isDestroyed == false){\n\t\t\t//Friendly attacks enemy\n\t\t\tint friendAtkVal = friend.attack((Class<Ship>) enemy.getClass());\n\t\t\tenemy.attacked(friendAtkVal);\n\t\t\t\n\t\t\t//Enemy attacks Friendly\n\t\t\tint enemyAttackVal = enemy.attack((Class<Ship>) friend.getClass());\n\t\t\tfriend.attacked(enemyAttackVal);\n\t\t\t\n\t\t}\n\t}\n\n\tpublic static void main(String[] args);\n\tprotected static List<Ship> convertInputToList(String commaDelem);\n\tprotected static Ship mapAbbreviationToShip(String shipAbbreviation);\n\tprotected static boolean battle(List<Ship> friendly, List<Ship> enemy);\n\n}\n\nclass SpaceBattleSimulationTest {\n\n\t@Test\n\tpublic void fighterAttacksCruiser(){\n", "reference": "\t\tSpaceBattleSimulation sim = new SpaceBattleSimulation();\n\t\t//One fighter should do 200 dmg per round.\n\t\t//A Cruiser will do 1,000 dmg against a fighter.\n\t\t//A Cruiser with full health will destroy a fighter in 3 rounds\n\t\t\n\t\tFighter fighter = sim.new Fighter();\n\t\tCruiser cruiser = sim.new Cruiser();\n\t\t\n\t\tint startingHealth = cruiser.getHp();\n\t\t\n\t\tSpaceBattleSimulation.engagement(fighter, cruiser);\n\t\t\n\t\tint endingHealth = cruiser.getHp();\n\t\tAssert.assertEquals(600, (startingHealth - endingHealth));\n\t\t\n\t}\n\n}", "prediction": "\t\tShip fighter = new Fighter();\n\t\tShip cruiser = new Cruiser();\n\t\tSpaceBattleSimulation.engagement(cruiser, fighter);\n\t\tassertTrue(fighter.isDestroyed);\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "13933675_15", "part": [1, 1], "seq": [1, 1], "prompt": "class PhysicalDataValueEq implements IValueEq<PhysicalData> {\n\n    @Override\n    public boolean equal(PhysicalData a, PhysicalData b) {\n        return same(a.getAltitude(), b.getAltitude())\n                && same(a.getDepth(), b.getDepth())\n                && same(a.getLatitude(), b.getLatitude())\n                && same(a.getLight(), b.getLight())\n                && same(a.getLongitude(), b.getLongitude())\n                && same (a.getOxygen(), b.getOxygen())\n                && same(a.getSalinity(), b.getSalinity())\n                && same(a.getTemperature(), b.getTemperature());\n    }\n\n    public  PhysicalDataValueEq(double eps);\n    public  PhysicalDataValueEq();\n\n    private boolean same(Number a, Number b);\n\n}\n\nclass PhysicalDataValueEqTest {\n\n    @Test\n    public void toleranceTest3() {\n", "reference": "        IValueEq<PhysicalData> eq = new PhysicalDataValueEq(0.001);\n        PhysicalData a = new ImmutablePhysicalData(null, 10F, 10F, 10D, 10F, null, 10D, 10F, 10F, 10F);\n        PhysicalData b = new ImmutablePhysicalData(null, 10F, 10F, 10.002, 10F, null, 10D, 10F, 10F, 10F);\n        assertFalse(eq.equal(a, b));\n    }\n\n}", "prediction": "        PhysicalDataValueEq eq = new PhysicalDataValueEq(0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "14029306_32", "part": [1, 1], "seq": [1, 1], "prompt": "class WadlGeneratorResourceDocSupport implements WadlGenerator {\n\n    public Resource createResource( AbstractResource r, String path ) {\n        final Resource result = _delegate.createResource( r, path );\n        final ClassDocType classDoc = resourceDoc.getClassDoc( r.getResourceClass() );\n        if ( classDoc!= null &&!isEmpty( classDoc.getCommentText() ) ) {\n            final Doc doc = new Doc();\n            doc.getContent().add( classDoc.getCommentText() );\n            result.getDoc().add( doc );\n        }\n        return result;\n    }\n\n    public  WadlGeneratorResourceDocSupport();\n    public  WadlGeneratorResourceDocSupport( WadlGenerator wadlGenerator, ResourceDocType resourceDoc );\n\n    public void setWadlGeneratorDelegate( WadlGenerator delegate );\n    @Override public void setEnvironment(Environment env);\n    public void setResourceDocFile( File resourceDocFile );\n    public void setResourceDocStream( InputStream resourceDocStream );\n    public void init();\n    public String getRequiredJaxbContextPath();\n    public Application createApplication(UriInfo requestInfo);\n    public Method createMethod( AbstractResource r, AbstractResourceMethod m );\n    public Representation createRequestRepresentation( AbstractResource r,\n                                                       AbstractResourceMethod m, MediaType mediaType );\n    public Request createRequest( AbstractResource r, AbstractResourceMethod m );\n    public List<Response> createResponses( AbstractResource r, AbstractResourceMethod m );\n    private void addDocForExample( final List<Doc> docs, final String example );\n    private void addDoc( final List<Doc> docs, final String text );\n    public Param createParam(AbstractResource r,\n                             AbstractMethod m, Parameter p);\n    public Resources createResources();\n    private boolean isEmpty( String text );\n    @Override public ExternalGrammarDefinition createExternalGrammar();\n    @Override public void attachTypes(ApplicationDescription egd);\n\n}\n\nclass WadlGeneratorResourceDocSupportTest {\n\n    @Test\n    public void wadlIsGeneratedWithUnknownCustomParameterAnnotation() throws JAXBException, PrivilegedActionException\n    {\n", "reference": "        /* Set up a ClassDocType that has something for a custom-annotated parameter */\n        ClassDocType cdt = new ClassDocType();\n        cdt.setClassName(TestResource.class.getName());\n\n        MethodDocType mdt = new MethodDocType();\n        mdt.setMethodName(\"method\");\n        cdt.getMethodDocs().add(mdt);\n\n        ParamDocType pdt = new ParamDocType(\"x\", \"comment about x\");\n        mdt.getParamDocs().add(pdt);\n\n        AnnotationDocType adt = new AnnotationDocType();\n        adt.setAnnotationTypeName(CustomParam.class.getName());\n        adt.getAttributeDocs().add(new NamedValueType(\"value\", \"x\"));\n\n        pdt.getAnnotationDocs().add(adt);\n\n        ResourceDocType rdt = new ResourceDocType();\n        rdt.getDocs().add(cdt);\n\n\n        /* Generate WADL for that class */\n        WadlGenerator wg = new WadlGeneratorResourceDocSupport(new WadlGeneratorImpl(), rdt);\n\n        WadlBuilder wb = new WadlBuilder(wg);\n        AbstractResource resource = IntrospectionModeller.createResource(TestResource.class);\n        ApplicationDescription app = wb.generate(null,null,null, Collections.singleton(resource));\n\n\n        /* Confirm that it can be marshalled without error */\n        StringWriter sw = new StringWriter();\n\n        JAXBContext context =\n                AccessController.doPrivileged(new PrivilegedExceptionAction<JAXBContext>(){\n\n                    @Override\n                    public JAXBContext run() throws JAXBException {\n                        return JAXBContext.newInstance(Application.class);\n                    }\n                });\n\n        Marshaller m = context.createMarshaller();\n        m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);\n\n        m.marshal(app.getApplication(), sw);\n    }\n\n}", "prediction": "        final WadlGeneratorResourceDocSupport wadlGenerator = new WadlGeneratorResourceDocSupport();\n        wadlGenerator.setResourceDocFile( new File( \"src/test/resources/wadl/resourceDoc.xml\" ) );\n        wadlGenerator.init();\n\n        final ApplicationDescription egd = wadlGenerator.createApplication( null );\n        final Resource resource = egd.getResources().get( 0 );\n        final Method method = resource.getMethods().get( 0 );\n        final Param param = method.getParameters().get( 0 );\n\n        final StringWriter writer = new StringWriter();\n        wadlGenerator.createApplication( null ).write( writer );\n        final String wadl = writer.toString();\n\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );\n        assertThat( wadl, containsString( \"unknownCustomParameterAnnotation\" ) );", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "14043412_1", "part": [1, 1], "seq": [1, 1], "prompt": "class PropertyBinding implements Binding<T> {\n\n\t@Override\n\tpublic void setValue(T value) {\n\t\ttry {\n\t\t\tPropertyUtils.setSimpleProperty(boundObject, property, value);\n\t\t} catch (Exception e) {\n\t\t\tthrow new IllegalStateException(String.format(\n\t\t\t\t\t\"Binding error! Setting property '%s' on bound object of class %s failed!\", property,\n\t\t\t\t\tboundObject.getClass()), e);\n\t\t}\n\t}\n\n\tpublic  PropertyBinding(Object boundObject, String property);\n\n\t@Override @SuppressWarnings(\"unchecked\") public T getValue();\n\n}\n\nclass PropertyBindingTest {\n\n\t@Test(expected = IllegalStateException.class)\n\tpublic void testWrongType() {\n", "reference": "\t\tPerson person = new Person();\n\t\tBinding<String> nameBinding = new PropertyBinding<String>(person, \"age\");\n\t\tnameBinding.setValue(\"Tom\");\n\t}\n\n}", "prediction": "\t\tPropertyBinding<String> binding = new PropertyBinding<String>(new Object(), \"foo\");\n\t\tbinding.setValue(new Object());\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "14109623_1", "part": [1, 1], "seq": [1, 1], "prompt": "class ConverterUtil {\n\n\tpublic static float convertCelsiusToFahrenheit(float celsius) {\n\t\treturn ((celsius * 9) / 5) + 32;\n\t}\n\n\tpublic static float convertFahrenheitToCelsius(float fahrenheit);\n\n}\n\nclass ConverterUtilTest {\n\n    @Test\n    public void testConvertCelsiusToFahrenheit() {\n", "reference": "        float actual = ConverterUtil.convertFahrenheitToCelsius(212);\n// expected value is 100\n        float expected = 100;\n// use this method because float is not precise\n        assertEquals(\"Conversion from celsius to fahrenheit failed\", expected,\n                actual, 0.001);\n    }\n\n}", "prediction": "\tassertEquals(32, ConverterUtil.convertCelsiusToFahrenheit(0), 0.001);\n\tassertEquals(212, ConverterUtil.convertCelsiusToFahrenheit(100), 0.001);\n\tassertEquals(32, ConverterUtil.convertCelsiusToFahrenheit(-273.15f), 0.001);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "14509169_17", "part": [1, 1], "seq": [1, 1], "prompt": "class Sort {\n\n    @SuppressWarnings(\"WeakerAccess\")\n    public static void sort(int[] order, double[] values) {\n        sort(order, values, 0, values.length);\n    }\n\n    @SuppressWarnings(\"WeakerAccess\") public static void sort(int[] order, double[] values, int n);\n    @SuppressWarnings(\"WeakerAccess\") public static void sort(int[] order, double[] values, int start, int n);\n    private static void quickSort(int[] order, double[] values, int start, int end, int limit);\n    @SuppressWarnings(\"WeakerAccess\") public static void sort(double[] key, double[]... values);\n    @SuppressWarnings(\"WeakerAccess\") public static void sort(double[] key, int start, int n, double[]... values);\n    private static void quickSort(double[] key, double[][] values, int start, int end, int limit);\n    @SuppressWarnings(\"SameParameterValue\") private static void insertionSort(double[] key, double[][] values, int start, int end, int limit);\n    private static void swap(int[] order, int i, int j);\n    private static void swap(int i, int j, double[] key, double[]...values);\n    @SuppressWarnings(\"UnusedDeclaration\") public static void checkPartition(int[] order, double[] values, double pivotValue, int start, int low, int high, int end);\n    @SuppressWarnings(\"SameParameterValue\") private static void insertionSort(int[] order, double[] values, int start, int n, int limit);\n    @SuppressWarnings(\"WeakerAccess\") public static void reverse(int[] order);\n    @SuppressWarnings(\"WeakerAccess\") public static void reverse(int[] order, int offset, int length);\n    @SuppressWarnings({\"WeakerAccess\", \"SameParameterValue\"}) public static void reverse(double[] order, int offset, int length);\n\n}\n\nclass SortTest {\n\n    @Test\n    public void testLonger() {\n", "reference": "        int[] order = new int[20];\n        double[] values = new double[20];\n        for (int i = 0; i < 20; i++) {\n            values[i] = (i * 13) % 20;\n        }\n        Sort.sort(order, values);\n        checkOrder(order, values);\n    }\n\n}", "prediction": "        int[] order = new int[1000000];\n        double[] values = new double[1000000];\n        for (int i = 0; i < order.length; i++) {\n            order[i] = i;\n            values[i] = Math.random();\n        }\n        Sort.sort(order, values);\n        for (int i = 0; i < order.length; i++) {\n            if (order[i]!= i) {\n                System.out.println(\"Error at \" + i);\n            }\n        }\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "14550159_467", "part": [1, 1], "seq": [1, 1], "prompt": "class EntityTagHeaderDelegate implements RuntimeDelegate.HeaderDelegate<EntityTag> {\n\n    @Override\n    public EntityTag fromString(String header) {\n        if (header == null) {\n            throw new IllegalArgumentException();\n        }\n\n        boolean isWeak = header.startsWith(\"W/\");\n\n        String value;\n        if (isWeak) {\n            value = cutWeakPrefix(header);\n        } else {\n            value = header;\n        }\n        value = value.substring(1, value.length() - 1);\n        value = HeaderHelper.removeQuoteEscapes(value);\n\n        return new EntityTag(value, isWeak);\n    }\n\n    private String cutWeakPrefix(String header);\n    @Override public String toString(EntityTag entityTag);\n\n    private EntityTagHeaderDelegate entityTagHeaderDelegate;\n\n}\n\nclass EntityTagHeaderDelegateTest {\n\n    private EntityTagHeaderDelegate entityTagHeaderDelegate;\n\n    @Test\n    public void parsesString() {\n", "reference": "        EntityTag entityTag = entityTagHeaderDelegate.fromString(\"\\\"test\\\"\");\n\n        assertFalse(entityTag.isWeak());\n        assertEquals(\"test\", entityTag.getValue());\n    }\n\n}", "prediction": "        EntityTag entityTag = entityTagHeaderDelegate.fromString(\"\\\"1234567890\\\"\");\n        assertEquals(\"1234567890\", entityTag.getValue());\n        assertFalse(entityTag.isWeak());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "14611005_43", "part": [1, 1], "seq": [1, 1], "prompt": "class VdmSymbolTable implements ISymbolTable {\n\n\t@Override\n\tpublic String getFLOOR()\n\t{\n\t\treturn \"floor\";\n\t}\n\n\tprotected  VdmSymbolTable();\n\n\tpublic static VdmSymbolTable getInstance();\n\t@Override public String getTAIL();\n\t@Override public String getAND();\n\t@Override public String getOR();\n\t@Override public String getPLUS();\n\t@Override public String getMINUS();\n\t@Override public String getDIVIDE();\n\t@Override public String getTIMES();\n\t@Override public String getLT();\n\t@Override public String getLE();\n\t@Override public String getGT();\n\t@Override public String getGE();\n\t@Override public String getNE();\n\t@Override public String getEQUALS();\n\t@Override public String getEQUIV();\n\t@Override public String getIMPLIES();\n\t@Override public String getSETDIFF();\n\t@Override public String getPLUSPLUS();\n\t@Override public String getSTARSTAR();\n\t@Override public String getCONCATENATE();\n\t@Override public String getMAPLET();\n\t@Override public String getRANGE();\n\t@Override public String getDOMRESTO();\n\t@Override public String getDOMRESBY();\n\t@Override public String getRANGERESTO();\n\t@Override public String getRANGERESBY();\n\t@Override public String getLAMBDA();\n\t@Override public String getIOTA();\n\t@Override public String getEXISTS1();\n\t@Override public String getEXISTS();\n\t@Override public String getPOINT();\n\t@Override public String getHEAD();\n\t@Override public String getFORALL();\n\t@Override public String getCOMPOSITION();\n\t@Override public String getINDS();\n\t@Override public String getDISTCONC();\n\t@Override public String getDUNION();\n\t@Override public String getMERGE();\n\t@Override public String getDINTER();\n\t@Override public String getABSOLUTE();\n\t@Override public String getELEMS();\n\t@Override public String getRNG();\n\t@Override public String getPOWER();\n\t@Override public String getLEN();\n\t@Override public String getDOM();\n\t@Override public String getCARD();\n\t@Override public String getINVERSE();\n\t@Override public String getINTER();\n\t@Override public String getUNION();\n\t@Override public String getMUNION();\n\t@Override public String getREM();\n\t@Override public String getMOD();\n\t@Override public String getDIV();\n\t@Override public String getSUBSET();\n\t@Override public String getPSUBSET();\n\t@Override public String getINSET();\n\t@Override public String getNOTINSET();\n\t@Override public String getPRED();\n\t@Override public String getSEP();\n\t@Override public String getDEF();\n\t@Override public String getOPENQUOTE();\n\t@Override public String getCLOSEQUOTE();\n\t@Override public String getCHARDELIM();\n\t@Override public String getSTRINGDELIM();\n\n\t VdmSymbolTable table;\n\n}\n\nclass VdmSymbolTableTest {\n\n\t VdmSymbolTable table;\n\n\t@Test\n\tpublic void testGetFLOOR()\n\t{\n", "reference": "\t\tString actual = table.getFLOOR();\n\t\tString expected = \"floor\";\n\n\t\tassertEquals(expected, actual);\n\t}\n\n}", "prediction": "\tassertEquals(\"floor\", table.getFLOOR());\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "14714017_30", "part": [1, 1], "seq": [1, 1], "prompt": "class DATypeImportComputer {\n\n  public static Collection<DAImport> computeImports(DAType daType) {\n    List<DAImport> qualifiedName = hasQualifiedNameToImport(daType)\n       ? Collections.<DAImport>emptyList() : Collections.singletonList(DAImportImpl.from(daType.getQualifiedName()));\n\n    Set<DAImport> res = new HashSet<DAImport>();\n    addAll(res, qualifiedName);\n    List<Collection<DAImport>> argsImportLists = from(daType.getTypeArgs()).transform(COMPUTE_IMPORTS).toList();\n    for (Collection<DAImport> importList : argsImportLists) {\n      addAll(res, importList);\n    }\n    addAll(res,\n        daType.getSuperBound() == null? Collections.<DAImport>emptyList() : computeImports(daType.getSuperBound())\n    );\n    addAll(res, daType.getExtendsBound() == null? Collections.<DAImport>emptyList() : computeImports(daType.getExtendsBound()));\n    return res;\n  }\n\n  private static void addAll(Set<DAImport> res, Iterable<DAImport> daImports);\n  private static boolean hasQualifiedNameToImport(DAType daType);\n  private static boolean hasNoName(DATypeKind kind);\n\n}\n\nclass DATypeImportComputerTest {\n\n  @Test\n  public void getImports_does_not_import_classes_from_java_lang() throws Exception {\n", "reference": "    DAType daType = DATypeFactory.from(String.class);\n    Assertions.assertThat(DATypeImportComputer.computeImports(daType)).isEmpty();\n\n    daType = daType(\"test.Toto\", ImmutableList.of(DATypeFactory.from(Integer.class)));\n    Assertions.assertThat(DATypeImportComputer.computeImports(daType)).extracting(\"qualifiedName.name\").containsOnly(\"test.Toto\");\n  }\n\n}", "prediction": "    DAType type = DATypeImpl.from(String.class);\n    Collection<DAImport> imports = DATypeImportComputer.computeImports(type);\n    assertThat(imports).isEmpty();\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "15008570_2", "part": [1, 1], "seq": [1, 1], "prompt": "class TimeoutProcessor {\n\n    public static final Timestamp processTimout(Long internalProcessingTimout, long defaultStaleResponseRemovalTimeout) {\n        final long ts = System.currentTimeMillis() + (internalProcessingTimout!= null? internalProcessingTimout : defaultStaleResponseRemovalTimeout);\n        if (ts <= 0) {\n            return new Timestamp(Long.MAX_VALUE);\n        }\n        return new Timestamp(ts);\n    }\n\n}\n\nclass TimeoutProcessorTest {\n\n    @Test\n    public void test() {\n", "reference": "        final long now = System.currentTimeMillis();\n        Assert.assertEquals(new Timestamp(Long.MAX_VALUE), TimeoutProcessor.processTimout(Long.MAX_VALUE, 3000L));\n        Assert.assertEquals(new Timestamp(Long.MAX_VALUE), TimeoutProcessor.processTimout(null, Long.MAX_VALUE));\n        Assert.assertTrue(TimeoutProcessor.processTimout(3000L, 4000L).getTime() - (now + 3000L) < 10L);\n        Assert.assertTrue(TimeoutProcessor.processTimout(null, 4000L).getTime() - (now + 4000L) < 10L);\n    }\n\n}", "prediction": "        final Timestamp ts = TimeoutProcessor.processTimout(null, 1000);\n        System.out.println(ts);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "15012247_2", "part": [1, 1], "seq": [1, 1], "prompt": "class Btree {\n\n    public Database getDb() {\n        return db;\n    }\n\n    public  Btree(Database db, boolean uniqueKeys);\n\n    public WriteTransaction beginReadWrite();\n    public ReadOnlyTransaction beginReadOnly();\n    public boolean isUniqueKeys();\n    public String writeSnapshot(ReadOnlyTransaction txn, SnapshotStorage snapshotDest);\n\n    @Rule\n    public TemporaryFolder folder;\n    static final Random random;\n\n}\n\nclass TestBtree {\n\n    @Rule\n    public TemporaryFolder folder;\n    static final Random random;\n\n    @Test\n    public void testHugeValues() throws Exception {\n", "reference": "        byte[] keyBytes = randomBytes(16);\n        Btree btree = buildBtree(keyBytes);\n\n        int n = 30;\n\n        for (int i = 1; i <= n; i++) {\n            byte[] key = Integer.toString(i).getBytes();\n            byte[] value = buildBytes(i * 10000);\n            put(btree, key, value);\n        }\n\n        for (int i = 1; i <= n; i++) {\n            byte[] key = Integer.toString(i).getBytes();\n            byte[] actual = get(btree, key);\n            byte[] expected = buildBytes(i * 10000);\n            Assert.assertArrayEquals(expected, actual);\n        }\n\n        System.out.println(btree.getDb().getPageStore().debugDump());\n        Assert.assertTrue(btree.getDb().getPageStore().debugIsIdle().or(true));\n    }\n\n}", "prediction": "        Database db = new Database(folder.newFile().getAbsolutePath());\n        Btree btree = new Btree(db, false);\n        WriteTransaction txn = btree.beginReadWrite();\n        for (int i = 0; i < 1000000; i++) {\n            byte[] key = new byte[1000];\n            random.nextBytes(key);\n            byte[] value = new byte[1000];\n            random.nextBytes(value);\n            txn.put(key, value);\n        }\n        txn.commit();\n        txn.close();\n        db.close();\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "15026183_1", "part": [1, 1], "seq": [1, 1], "prompt": "class XmlApplicationConfigParser implements ApplicationConfigParser {\n\n\t@Override\n\tpublic ApplicationConfig parse(InputStream inputStream) {\n\t\tDigester digester = new Digester();\n\t\tdigester.addObjectCreate(\"Application\", ApplicationConfig.class);\n        for (String filed : fiedlds) {\n            digester.addBeanPropertySetter(\"Application/\"+filed);\n        }\n        try {\n\t\t\treturn (ApplicationConfig) digester.parse(inputStream);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (SAXException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn null;\n\t}\n\n    private XmlApplicationConfigParser xmlApplicationConfigParser;\n\n}\n\nclass XmlApplicationConfigParserTest {\n\n    private XmlApplicationConfigParser xmlApplicationConfigParser;\n\n    @Test\n    public void testParser(){\n", "reference": "        InputStream resourceAsStream = getClass().getClassLoader().getResourceAsStream(\"app.xml\");\n        ApplicationConfig config = xmlApplicationConfigParser.parse(resourceAsStream);\n        assertEquals(\"tavern\", config.getName());\n        assertEquals(\"classpath*:spring/appcontext-*.xml\", config.getContextPath());\n        assertEquals(\"com.dianping.tavern\", config.getPackageBase());\n        assertNull(config.getParent());\n    }\n\n}", "prediction": "        ApplicationConfig applicationConfig = xmlApplicationConfigParser.parse(this.getClass().getResourceAsStream(\"/application.xml\"));\n        Assert.assertEquals(applicationConfig.getAppName(), \"test\");\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "15057951_111", "part": [1, 1], "seq": [1, 1], "prompt": "class SimpleMatcherType implements MatcherType<Object> {\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public String encode(Object object, Type type, Matcher matcher) {\n        if (object instanceof Star) {\n            return \"*\";\n        }\n\n        String value;\n        if (type!= null) {\n            value = type.encode(type.convert(object));\n        } else {\n            value = object == null? \"\" : object.toString();\n        }\n\n        return value == null? \"*\" : value;\n    }\n\n    @Override public Object decode(String value, Type<?> type, Matcher matcher);\n\n    private final SimpleMatcherType type;\n\n}\n\nclass SimpleMatcherTypeTest {\n\n    private final SimpleMatcherType type;\n\n    @Test\n    public void shouldEncodeStarObjectAsStar() {\n", "reference": "        // when\n        String encoded = type.encode(Star.star(), null, null);\n\n        // then\n        assertThat(encoded).isEqualTo(\"*\");\n    }\n\n}", "prediction": "        assertThat(type.encode(new Star(), null, null), is(\"*\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "15870646_7", "part": [1, 1], "seq": [1, 1], "prompt": "class OsmNogoPolygon extends OsmNodeNamed {\n\n  public boolean intersects(int lon0, int lat0, int lon1, int lat1)\n  {\n    final Point p0 = new Point (lon0,lat0);\n    final Point p1 = new Point (lon1,lat1);\n    int i_last = points.size()-1;\n    Point p2 = points.get(isClosed? i_last : 0 );\n    for (int i = isClosed? 0 : 1 ; i <= i_last; i++)\n    {\n      Point p3 = points.get(i);\n      // does it intersect with at least one of the polygon's segments?\n      if (intersect2D_2Segments(p0,p1,p2,p3) > 0)\n      {\n        return true;\n      }\n      p2 = p3;\n    }\n    return false;\n  }\n\n  public  OsmNogoPolygon(boolean closed);\n\n  public final void addVertex(int lon, int lat);\n  public void calcBoundingCircle();\n  public boolean isOnPolyline( long px, long py );\n  public static boolean isOnLine( long px, long py, long p0x, long p0y, long p1x, long p1y );\n  public boolean isWithin(final long px, final long py);\n  public double distanceWithinPolygon(int lon1, int lat1, int lon2, int lat2);\n  private static boolean inSegment( final Point p, final Point seg_p0, final Point seg_p1);\n  private static int intersect2D_2Segments( final Point s1p0, final Point s1p1, final Point s2p0, final Point s2p1 );\n\n  static final int OFFSET_X;\n  static final int OFFSET_Y;\n  static OsmNogoPolygon polygon;\n  static OsmNogoPolygon polyline;\n  static final double[] lons;\n  static final double[] lats;\n\n}\n\nclass OsmNogoPolygonTest {\n\n  static final int OFFSET_X;\n  static final int OFFSET_Y;\n  static OsmNogoPolygon polygon;\n  static OsmNogoPolygon polyline;\n  static final double[] lons;\n  static final double[] lats;\n\n  @Test\n  public void testIntersectsPolyline() {\n", "reference": "    double[] p0lons  = {   0.0,   1.0,  -0.5,  0.5,  0.7,  0.7,  0.7,  -1.5, -1.5,   0.0 };\n    double[] p0lats  = {   0.0,   0.0,   0.5,  0.5,  0.5,  0.05, 0.05, -1.5,  0.2,   0.0 };\n    double[] p1lons  = {   0.0,   1.0,   0.5,  1.0,  0.7,  0.7,  0.7,  -0.5, -0.2,   0.5 };\n    double[] p1lats  = {   0.0,   0.0,   0.5,  0.5, -0.5, -0.5, -0.05, -0.5,  1.5,  -1.5 };\n    boolean[] within = { false, false, false, true, true, true, false, true, true, false };\n\n    for (int i=0; i<p0lons.length; i++) {\n      assertEquals(\"(\"+p0lons[i]+\",\"+p0lats[i]+\")-(\"+p1lons[i]+\",\"+p1lats[i]+\")\",within[i],polyline.intersects(toOsmLon(p0lons[i], OFFSET_X), toOsmLat(p0lats[i], OFFSET_Y), toOsmLon(p1lons[i], OFFSET_X), toOsmLat(p1lats[i], OFFSET_Y)));\n    }\n  }\n\n}", "prediction": "    assertTrue(polyline.intersects(lons[0],lats[0],lons[1],lats[1]));\n    assertTrue(polyline.intersects(lons[1],lats[1],lons[2],lats[2]));\n    assertTrue(polyline.intersects(lons[2],lats[2],lons[3],lats[3]));\n    assertTrue(polyline.intersects(lons[3],lats[3],lons[4],lats[4]));\n    assertTrue(polyline.intersects(lons[4],lats[4],lons[5],lats[5]));\n    assertTrue(polyline.intersects(lons[5],lats[5],lons[6],lats[6]));\n    assertTrue(polyline.intersects(lons[6],lats[6],lons[7],lats[7]));\n    assertTrue(polyline.intersects(lons[7],lats[7],lons[8],lats[8]));\n    assertTrue(polyline.intersects(lons[8],lats[8],lons[9],lats[9]));\n    assertTrue(polyline.intersects(lons[9],lats[9],lons[10],lats[10]));\n    assertTrue(polyline.intersects(lons[10],lats[10],lons[11],lats[11]));\n    assertTrue(polyline.intersects(lons[11],lats[11],lons[12],lats[12]));\n    assertTrue(polyline.intersects(lons[12],lats[12],lons[13],lats[13]));\n    assertTrue(polyline.intersects(lons[13],lats[13],lons[14],lats[14]));\n    assertTrue(polyline.intersects(lons[14],lats[14],lons[15],lats[15]));\n    assertTrue(polyline.intersects(lons[15],lats[15],lons[16],lats[16]));\n    assertTrue(polyline.intersects(lons[16],lats[16],lons[17],lats[17]));\n    assertTrue(polyline.intersects(lons[17],lats[17],lons[18],lats[18]));\n    assertTrue(polyline.intersects(lons[18],lats[18],lons[19],lats[19]));\n    assertTrue(polyline.intersects(lons[19],lats[19],lons[20],lats[20]));\n    assertTrue(polyline.intersects(lons[20],lats[20],lons[21],lats[21]));\n    assertTrue(polyline.intersects(lons[21],lats[21],lons[22],lats[22]));\n    assertTrue(polyline.intersects(lons[22],lats[22],lons[23],lats[23]));\n    assertTrue(polyline.intersects(lons[23],lats[23],lons[24],lats[24]));\n    assertTrue(polyline.intersects(lons[24],lats[24],lons[25],lats[25]));\n    assertTrue(polyline.intersects(lons[25],lats[25],lons[26],lats[26]));\n    assertTrue(polyline.intersects(lons[26],lats[26],lons[27],lats[27]));\n    assertTrue(polyline.intersects(lons[27],lats[27],lons[28],lats[28]));\n    assertTrue(polyline.intersects(lons[28],lats[28],lons[29],lats[29]));\n    assertTrue(polyline.intersects(lons[29],lats[29],lons[30],lats[30]));\n    assertTrue(polyline.intersects(lons[30],lats[30],lons[31],lats[31]));\n    assertTrue(polyline.intersects(lons[31],lats[31],lons[32],lats[32]));\n    assertTrue(polyline.intersects(lons[32],lats[32],lons[33],lats[33]));\n    assertTrue(polyline.intersects(lons[33],lats[33],lons[34],lats[34]));\n    assertTrue(polyline.intersects(lons[34],lats[34],lons[35],lats[35]));\n    assertTrue(polyline.intersects(lons[35],lats[35],lons[36],lats[36]));\n    assertTrue(polyline.intersects(lons[36],lats[36],lons[37],lats[37]));\n    assertTrue(polyline.intersects(lons[37],lats[37],lons[38],lats[38]));\n    assertTrue(polyline.intersects(lons[38],lats[38],lons[39],lats[39]));\n    assertTrue(polyline.intersects(lons[39],lats[39],lons[40],lats[40]));\n    assertTrue(polyline.intersects(lons[40],lats[40],lons[41],lats[41]));\n    assertTrue(polyline.intersects(lons[41],lats[41],lons[42],lats[42]));\n    assertTrue(polyline.intersects(lons[42],lats[42],lons[43],lats[43]));\n    assertTrue(polyline.intersects(lons[43],lats[43],lons[44],lats[44]));\n    assertTrue(polyline.intersects(lons[44],lats[44],lons[45],lats[45]));\n    assertTrue(polyline.intersects(lons[45],lats[45],lons[46],lats[46]));\n    assertTrue(poly", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "15939233_1", "part": [1, 1], "seq": [1, 1], "prompt": "class PlaintextKeysProvider implements CardKeysProvider {\n\n    @Override\n    public Optional<GPCardKeys> getCardKeys(String spec) {\n        if (spec == null)\n            return Optional.empty();\n        \n        // Default key, with shorthand\n        if (\"default\".startsWith(spec.toLowerCase()))\n            return Optional.of(PlaintextKeys.defaultKey());\n\n        try {\n            // emv:<hex>\n            for (PlaintextKeys.Diversification d : PlaintextKeys.Diversification.values()) {\n                if (spec.toLowerCase().startsWith(d.name().toLowerCase())) {\n                    byte[] k = HexUtils.stringToBin(spec.substring(d.name().length() + 1));\n                    return Optional.of(PlaintextKeys.derivedFromMasterKey(k, null, d));\n                }\n            }\n\n            // hex\n            byte[] k = HexUtils.stringToBin(spec);\n            return Optional.of(PlaintextKeys.fromMasterKey(k));\n        } catch (IllegalArgumentException e) {\n            // log\n        }\n        return Optional.empty();\n    }\n\n    public  PlaintextKeysProvider();\n\n}\n\nclass TestPlaintextKeysProvider {\n\n    @Test\n    public void testMasterKey() {\n", "reference": "        CardKeysProvider p = new PlaintextKeysProvider();\n        Assert.assertTrue(p.getCardKeys(\"404142434445464748494a4b4c4d4e4f\").isPresent());\n    }\n\n}", "prediction": "        Optional<GPCardKeys> keys = new PlaintextKeysProvider().getCardKeys(\"\");\n        assertTrue(keys.isPresent());\n        assertEquals(keys.get().getMasterKey(), HexUtils.stringToBin(\"\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "15950995_0", "part": [1, 1], "seq": [1, 1], "prompt": "class UpdateInventoryRequest extends AbstractPutRequest<UpdateInventoryResponse> {\n\n    @Override\n    public String getBody() throws Exception {\n        Set<String> properties = new HashSet<String>();\n        for (String field : fields) {\n            properties.add(field);\n        }\n        SimpleBeanPropertyFilter filter = new SimpleBeanPropertyFilter.FilterExceptFilter(properties);\n        SimpleFilterProvider provider = new SimpleFilterProvider();\n        provider.addFilter(\"update inventory request filter\", filter);\n        return mapper.writer(provider).writeValueAsString(inventory);\n    }\n\n    public  UpdateInventoryRequest(Inventory inventory, String... fields);\n\n    @Override public String getPath();\n    @Override public Parameter[] getParameters();\n    @Override public UpdateInventoryParser getParser();\n\n}\n\nclass UpdateInventoryRequestTest {\n\n    @Test\n    public void testGetBody() throws Exception {\n", "reference": "        Inventory update = new Inventory();\n        update.setIdentifier(123);\n        update.setPrice(new BigDecimal(\"1.00\"));\n        String body = new UpdateInventoryRequest(update, \"inventory_id\", \"unit_price\").getBody();\n        assertEquals(\"{\\\"inventory_id\\\":123,\\\"unit_price\\\":1.00}\", body);\n    }\n\n}", "prediction": "        Inventory inventory = new Inventory();\n        inventory.setId(1);\n        inventory.setQuantity(10);\n        inventory.setPrice(100);\n        inventory.setSku(\"sku\");\n        inventory.setVersion(1);\n\n        UpdateInventoryRequest request = new UpdateInventoryRequest(inventory, \"id\", \"quantity\", \"price\", \"sku\");\n        String body = request.getBody();\n        System.out.println(body);\n        Assert.assertEquals(\"{\\\"id\\\":1,\\\"quantity\\\":10,\\\"price\\\":100,\\\"sku\\\":\\\"sku\\\"}\", body);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "16021499_69", "part": [1, 1], "seq": [1, 1], "prompt": "class AdvancedFilterValidator implements GenericMetaInfDataValidator, FilterValidator, DocumentViewXmlValidator, JcrPathValidator {\n\n    @Override\n    public @Nullable Collection<ValidationMessage> validateJcrPath(@NotNull NodeContext nodeContext,\n            boolean isFolder) {\n        if (!isFolder) {\n            return validateFileNodePath(nodeContext.getNodePath());\n        } else {\n            return null;\n        }\n    }\n\n    public  AdvancedFilterValidator(@NotNull DocumentBuilderFactory factory, @NotNull ValidationMessageSeverity defaultSeverity, @NotNull ValidationMessageSeverity severityForUncoveredAncestorNodes, @NotNull ValidationMessageSeverity severityForUncoveredFilterRootAncestors, @NotNull ValidationMessageSeverity severityForOrphanedFilterEntries, boolean isSubPackage, @NotNull Collection<PackageInfo> dependenciesMetaInfo, @NotNull WorkspaceFilter filter, @NotNull Collection<String> validRoots);\n\n    public void setFilterValidators(Map<String, FilterValidator> filterValidators);\n    @Override public Collection<ValidationMessage> done();\n    @Override public Collection<ValidationMessage> validate(@NotNull WorkspaceFilter filter);\n    private Collection<ValidationMessage> validatePathFilterSets(Collection<PathFilterSet> pathFilterSets, boolean checkRoots);\n    private Collection<ValidationMessage> validateFileNodePath(@NotNull String nodePath);\n    @Override public @Nullable Collection<ValidationMessage> validate(@NotNull DocViewNode node, @NotNull NodeContext nodeContext,\n            boolean isRoot);\n    static boolean isRegexValidForRootPath(String regex, String rootPath);\n    @Override public Collection<ValidationMessage> validateMetaInfData(@NotNull InputStream input, @NotNull Path filePath, @NotNull Path basePath);\n    @Override public boolean shouldValidateMetaInfData(@NotNull Path filePath);\n    private void removeFromOrphanedFilterEntries(@NotNull String nodePath);\n    @Nullable String getDanglingAncestorNodePath(String nodePath, WorkspaceFilter filter);\n\n    private AdvancedFilterValidator validator;\n    @Mock\n    private FilterValidator filterValidator1;\n    @Mock\n    private FilterValidator filterValidator2;\n    @Mock\n    private PackageProperties properties;\n    @Mock\n    private WorkspaceFilter filter;\n    private Collection<PackageInfo> dependenciesMetaInfo;\n    private Collection<String> validRoots;\n    private DocumentBuilderFactory factory;\n\n}\n\nclass AdvancedFilterValidatorTest {\n\n    private AdvancedFilterValidator validator;\n    @Mock\n    private FilterValidator filterValidator1;\n    @Mock\n    private FilterValidator filterValidator2;\n    @Mock\n    private PackageProperties properties;\n    @Mock\n    private WorkspaceFilter filter;\n    private Collection<PackageInfo> dependenciesMetaInfo;\n    private Collection<String> validRoots;\n    private DocumentBuilderFactory factory;\n\n    @Test\n    public void testUncoveredAncestorNodesFailure() throws IOException, ConfigurationException {\n", "reference": "        DefaultWorkspaceFilter filter = new DefaultWorkspaceFilter();\n        try (InputStream input = this.getClass().getResourceAsStream(\"/filter.xml\")) {\n            filter.load(input);\n        }\n        validator = new AdvancedFilterValidator(\n                factory,\n                ValidationMessageSeverity.ERROR,\n                AdvancedFilterValidatorFactory.DEFAULT_SEVERITY_FOR_UNCOVERED_ANCESTOR_NODES,\n                ValidationMessageSeverity.ERROR,\n                ValidationMessageSeverity.ERROR,\n                false,\n                dependenciesMetaInfo,\n                filter, // this is per test\n                validRoots);\n\n        // default severity INFO\n        ValidationExecutorTest.assertViolation(validator.validateJcrPath(getStandardNodeContext(\"/apps\"), false), ValidationMessageSeverity.INFO,\n                new ValidationMessage(ValidationMessageSeverity.INFO,\n                        String.format(AdvancedFilterValidator.MESSAGE_ANCESTOR_NODE_NOT_COVERED_BUT_VALID_ROOT, \"/apps\")));\n        ValidationExecutorTest.assertViolation(validator.validateJcrPath(getStandardNodeContext(\"/apps/test4\"), false), ValidationMessageSeverity.INFO,\n                new ValidationMessage(ValidationMessageSeverity.INFO,\n                        String.format(AdvancedFilterValidator.MESSAGE_ANCESTOR_NODE_NOT_COVERED, \"/apps/test4\")));\n\n        // default severity ERROR\n        validator = new AdvancedFilterValidator(\n                factory,\n                ValidationMessageSeverity.ERROR,\n                ValidationMessageSeverity.ERROR,\n                ValidationMessageSeverity.ERROR,\n                ValidationMessageSeverity.ERROR,\n                false,\n                dependenciesMetaInfo,\n                filter, // this is per test\n                validRoots);\n\n        ValidationExecutorTest.assertViolation(validator.validateJcrPath(getStandardNodeContext(\"/apps/test4\"), false), ValidationMessageSeverity.INFO,\n                new ValidationMessage(ValidationMessageSeverity.ERROR,\n                        String.format(AdvancedFilterValidator.MESSAGE_ANCESTOR_NODE_NOT_COVERED, \"/apps/test4\")));\n\n        // set valid roots\n        validRoots.add(\"/someroot\");\n        // default severity ERROR\n        validator = new AdvancedFilterValidator(\n                factory,\n                ValidationMessageSeverity.ERROR,\n                ValidationMessageSeverity.WARN,\n                ValidationMessageSeverity.ERROR,\n                ValidationMessageSeverity.ERROR,\n                false,\n                dependenciesMetaInfo,\n                filter, // this is per test\n                Collections.emptyList());\n        ValidationExecutorTest.assertViolation(validator.validateJcrPath(getStandardNodeContext(\"/apps\"), false), ValidationMessageSeverity.WARN,\n                new ValidationMessage(ValidationMessageSeverity.WARN,\n                        String.format(AdvancedFilterValidator.MESSAGE_ANCESTOR_NODE_NOT_COVERED, \"/apps\")));\n    }\n\n}", "prediction": "        Collection<ValidationMessage> messages = validator.validate(filter);\n        assertEquals(1, messages.size());\n        assertEquals(ValidationMessageSeverity.ERROR, messages.iterator().next().getSeverity());\n        assertEquals(\"Uncovered ancestor nodes: /a/b/c\", messages.iterator().next().getMessage());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "16362479_546", "part": [1, 1], "seq": [1, 1], "prompt": "class TransactionChainProxy extends AbstractTransactionContextFactory<LocalTransactionChain> implements DOMStoreTransactionChain {\n\n    @Override\n    public DOMStoreWriteTransaction newWriteOnlyTransaction() {\n        getActorUtils().acquireTxCreationPermit();\n        return allocateWriteTransaction(TransactionType.WRITE_ONLY);\n    }\n\n      TransactionChainProxy(final TransactionContextFactory parent, final LocalHistoryIdentifier historyId);\n\n    @Override public DOMStoreReadTransaction newReadOnlyTransaction();\n    @Override public DOMStoreReadWriteTransaction newReadWriteTransaction();\n    @Override public void close();\n    private TransactionProxy allocateWriteTransaction(final TransactionType type);\n    @Override protected LocalTransactionChain factoryForShard(final String shardName, final ActorSelection shardLeader,\n            final ReadOnlyDataTree dataTree);\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) @Override protected Future<PrimaryShardInfo> findPrimaryShard(final String shardName, final TransactionIdentifier txId);\n    private Future<T> combineFutureWithPossiblePriorReadOnlyTxFutures(final Future<T> future,\n            final TransactionIdentifier txId);\n    private Future<T> combineWithPriorReadOnlyTxFutures(final Future<T> future, final TransactionIdentifier txId);\n    @Override protected void onTransactionReady(final TransactionIdentifier transaction,\n            final Collection<Future<T>> cohortFutures);\n    @Override protected void onTransactionContextCreated(final TransactionIdentifier transactionId);\n\n    private LocalHistoryIdentifier historyId;\n\n}\n\nclass TransactionChainProxyTest extends AbstractTransactionContextFactory<LocalTransactionChain> {\n\n    private LocalHistoryIdentifier historyId;\n\n    @SuppressWarnings(\"resource\")\n    @Test\n    public void testNewWriteOnlyTransaction() {\n", "reference": "        DOMStoreTransaction dst = new TransactionChainProxy(mockComponentFactory, historyId).newWriteOnlyTransaction();\n        Assert.assertTrue(dst instanceof DOMStoreWriteTransaction);\n\n    }\n\n}", "prediction": "        final TransactionChainProxy proxy = new TransactionChainProxy(this, historyId);\n        final DOMStoreWriteTransaction tx = proxy.newWriteOnlyTransaction();\n        assertNotNull(tx);\n        assertTrue(tx.isWriteOnly());\n        assertFalse(tx.isReadOnly());\n        assertTrue(tx.isReadWrite());\n        assertFalse(tx.isReadOnlyOrWriteOnly());\n        assertFalse(tx.isReadWriteOrWriteOnly());\n        assertTrue(tx.isReadWriteOrReadOnly());\n        assertFalse(tx.isWriteOnlyOrReadOnly());\n        assertFalse(tx.isWriteOnlyOrWriteOnly());\n        assertFalse(tx.isReadOnlyOrReadOnly());\n        assertFalse(tx.isReadWriteOrReadOnlyOrWriteOnly());\n        assertFalse(tx.isWriteOnlyOrReadOnlyOrWriteOnly());\n        assertFalse(tx.isReadOnlyOrWriteOnlyOrWriteOnly());\n        assertFalse(tx.isWriteOnlyOrWriteOnlyOrWriteOnly());\n        assertFalse(tx.isWriteOnlyOrReadOnlyOrReadOnly());\n        assertFalse(tx.isReadOnlyOrWriteOnlyOrReadOnly());\n        assertFalse(tx.isReadOnlyOrReadOnlyOrReadOnly());\n        assertFalse(tx.isWriteOnlyOrWriteOnlyOrReadOnly());\n        assertFalse(tx.isWriteOnlyOrWriteOnlyOrReadOnly());\n        assertFalse(tx.isReadOnlyOrWriteOnlyOrWriteOnly());\n        assertFalse(tx.isWriteOnlyOrReadOnlyOrWriteOnly());\n        assertFalse(tx.isReadOnlyOrReadOnlyOrWriteOnly());\n        assertFalse(tx.isWriteOnlyOrWriteOnlyOrWriteOnly());\n        assertFalse(tx.isWriteOnlyOrReadOnlyOrWriteOnly());\n        assertFalse(tx.isReadOnlyOrWriteOnlyOrWriteOnly());\n        assertFalse(tx.isWriteOnlyOrReadOnlyOrWriteOnly());\n        assertFalse(tx.isReadOnlyOrReadOnlyOrWriteOnly());\n        assertFalse(tx.isWriteOnlyOrWriteOnlyOrWriteOnly());\n        assertFalse(tx.isWriteOnlyOrReadOnlyOrWriteOnly());\n        assertFalse(tx.isReadOnlyOrWriteOnlyOrWriteOnly());\n        assertFalse(tx.isWriteOnlyOrReadOnlyOrWriteOnly());\n        assertFalse(tx.isReadOnlyOrReadOnlyOrWriteOnly());\n        assertFalse(tx.isWriteOnlyOrWriteOnlyOrWriteOnly());\n        assertFalse(tx.isWriteOnlyOrReadOnlyOrWriteOnly());\n        assertFalse(tx.isReadOnlyOrWriteOnlyOrWriteOnly());\n        assertFalse(tx.isWriteOnlyOrReadOnlyOrWriteOnly());\n        assertFalse(tx.isReadOnlyOrReadOnlyOrWriteOnly());\n        assertFalse(tx.isWriteOnlyOrWriteOnlyOrWriteOnly());\n        assertFalse(tx.isWriteOnlyOrReadOnlyOrWriteOnly());\n        assertFalse(tx.isReadOnlyOrWriteOnlyOrWriteOnly());\n        assertFalse(tx.isWriteOnlyOrReadOnlyOrWriteOnly());\n        assertFalse(tx.isReadOnlyOrReadOnlyOrWriteOnly());\n        assertFalse(tx.isWriteOnlyOrWriteOnlyOrWriteOnly());\n        assertFalse(tx.isWriteOnlyOrReadOnlyOrWriteOnly());\n        assertFalse(tx.isReadOnlyOrWriteOnlyOrWriteOnly());\n        assertFalse(tx.isWriteOnlyOrReadOnlyOrWriteOnly());\n        assertFalse(tx.isReadOnlyOrReadOnlyOrWriteOnly());\n        assertFalse(tx.isWriteOnlyOrWriteOnlyOrWriteOnly());\n        assertFalse(tx.isWriteOnlyOrReadOnlyOrWriteOnly());\n        assertFalse(tx.isReadOnlyOrWriteOnlyOrWriteOnly());\n        assertFalse(tx.isWriteOnlyOrReadOnlyOrWriteOnly());\n        assertFalse(tx.isReadOnlyOrReadOnlyOrWriteOnly());\n        assertFalse(tx.isWriteOnlyOrWriteOnlyOrWriteOnly());\n        assertFalse(tx.isWriteOnlyOrReadOnlyOrWriteOnly());\n        assertFalse(tx.isReadOnlyOrWriteOnlyOrWriteOnly());\n        assertFalse(tx.isWriteOnlyOrReadOnlyOrWriteOnly());\n        assertFalse(tx.isReadOnlyOrReadOnlyOrWriteOnly());\n        assertFalse(tx.isWriteOnlyOrWriteOnlyOrWriteOnly());\n        assertFalse(tx.isWriteOnlyOrReadOnlyOrWriteOnly());\n        assertFalse(tx.isReadOnlyOrWriteOnlyOrWriteOnly());\n        assertFalse(tx.isWriteOnlyOrReadOnlyOrWriteOnly());\n        assertFalse(tx.isReadOnlyOrReadOnlyOrWriteOnly", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "16362494_0", "part": [1, 1], "seq": [1, 1], "prompt": "class FlowEntryMgr {\n\n\tpublic void addOpenFlowEntry(String nodeId, String flowEntryLabel, Object flowEntry) throws Exception {\n\n\t\ttry {\n\t\t\tassertConnectorNotNull();\n\t\t\tStringBuilder urlPrefix = constructFlowUrlPrefix(nodeId, flowEntryLabel);\n\t\t\tconnector.putToController(urlPrefix.toString(), flowEntry);\n\t\t} catch (Throwable e) {\n\t\t\tString msg = \"Excepted trying to addOpenFlowEntry for \" + nodeId + \" \" + flowEntryLabel + \" \" + flowEntry;\n\t\t\tlog.error(msg, e);\n\t\t\tthrow new Exception(msg, e);\n\t\t}\n\t}\n\n\tpublic  FlowEntryMgr();\n\n\tpublic void setOdl(Odl odl);\n\tprotected void assertConnectorNotNull();\n\tpublic ReceivedFlowConfig getOpenFlowEntry(String nodeId, String flowEntryLabel);\n\tpublic void toggleOpenFlowEntry(String nodeId, String flowEntryLabel);\n\tpublic void deleteOpenFlowEntry(String nodeId, String flowEntryLabel);\n\tpublic FlowStatistics getOpenFlowStats(String nodeId);\n\tpublic Nodes getNodes();\n\tprotected StringBuilder constructFlowUrlPrefix(String nodeId, String flowEntryLabel);\n\tprotected StringBuilder constructAllFlowsUrlPrefix();\n\tprotected StringBuilder constructFlowStatsUrlPrefix(String nodeId);\n\tprotected StringBuilder constructFlowSwitchUrlPrefix();\n\tpublic void reset();\n\n    private FlowEntryMgr flowEntryMgr;\n    private Connector connector;\n    private String testNodeId;\n\n}\n\nclass FlowEntryMgrTest {\n\n    private FlowEntryMgr flowEntryMgr;\n    private Connector connector;\n    private String testNodeId;\n\n    @Test\n    public void testAddOpenFlowEntry() throws Exception {\n", "reference": "//        flowEntryMgr.addOpenFlowEntry(testNodeId, getFlow2());\n    }\n\n}", "prediction": "\tflowEntryMgr.addOpenFlowEntry(testNodeId, \"test\", new Object());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "16368712_4", "part": [1, 1], "seq": [1, 1], "prompt": "class Task {\n\n  public Task<Void> continueWhile(Callable<Boolean> predicate,\n      Continuation<Void, Task<Void>> continuation) {\n    return continueWhile(predicate, continuation, IMMEDIATE_EXECUTOR, null);\n  }\n\n    Task();\n  private  Task(TResult result);\n  private  Task(boolean cancelled);\n\n  public static UnobservedExceptionHandler getUnobservedExceptionHandler();\n  public static void setUnobservedExceptionHandler(UnobservedExceptionHandler eh);\n  public static Task<TResult>.TaskCompletionSource create();\n  public boolean isCompleted();\n  public boolean isCancelled();\n  public boolean isFaulted();\n  public TResult getResult();\n  public Exception getError();\n  public void waitForCompletion();\n  public boolean waitForCompletion(long duration, TimeUnit timeUnit);\n  @SuppressWarnings(\"unchecked\") public static Task<TResult> forResult(TResult value);\n  public static Task<TResult> forError(Exception error);\n  @SuppressWarnings(\"unchecked\") public static Task<TResult> cancelled();\n  public static Task<Void> delay(long delay);\n  public static Task<Void> delay(long delay, CancellationToken cancellationToken);\n  static Task<Void> delay(long delay, ScheduledExecutorService executor, final CancellationToken cancellationToken);\n  public Task<TOut> cast();\n  public Task<Void> makeVoid();\n  public static Task<TResult> callInBackground(Callable<TResult> callable);\n  public static Task<TResult> callInBackground(Callable<TResult> callable, CancellationToken ct);\n  public static Task<TResult> call(final Callable<TResult> callable, Executor executor);\n  public static Task<TResult> call(final Callable<TResult> callable, Executor executor,\n      final CancellationToken ct);\n  public static Task<TResult> call(final Callable<TResult> callable);\n  public static Task<TResult> call(final Callable<TResult> callable, CancellationToken ct);\n  public static Task<Task<TResult>> whenAnyResult(Collection<? extends Task<TResult>> tasks);\n  @SuppressWarnings(\"unchecked\") public static Task<Task<?>> whenAny(Collection<? extends Task<?>> tasks);\n  public static Task<List<TResult>> whenAllResult(final Collection<? extends Task<TResult>> tasks);\n  public static Task<Void> whenAll(Collection<? extends Task<?>> tasks);\n  public Task<Void> continueWhile(Callable<Boolean> predicate,\n      Continuation<Void, Task<Void>> continuation, CancellationToken ct);\n  public Task<Void> continueWhile(final Callable<Boolean> predicate,\n      final Continuation<Void, Task<Void>> continuation, final Executor executor);\n  public Task<Void> continueWhile(final Callable<Boolean> predicate,\n      final Continuation<Void, Task<Void>> continuation, final Executor executor,\n      final CancellationToken ct);\n  public Task<TContinuationResult> continueWith(\n      final Continuation<TResult, TContinuationResult> continuation, final Executor executor);\n  public Task<TContinuationResult> continueWith(\n      final Continuation<TResult, TContinuationResult> continuation, final Executor executor,\n      final CancellationToken ct);\n  public Task<TContinuationResult> continueWith(\n      Continuation<TResult, TContinuationResult> continuation);\n  public Task<TContinuationResult> continueWith(\n      Continuation<TResult, TContinuationResult> continuation, CancellationToken ct);\n  public Task<TContinuationResult> continueWithTask(\n      final Continuation<TResult, Task<TContinuationResult>> continuation, final Executor executor);\n  public Task<TContinuationResult> continueWithTask(\n      final Continuation<TResult, Task<TContinuationResult>> continuation, final Executor executor,\n      final CancellationToken ct);\n  public Task<TContinuationResult> continueWithTask(\n      Continuation<TResult, Task<TContinuationResult>> continuation);\n  public Task<TContinuationResult> continueWithTask(\n      Continuation<TResult, Task<TContinuationResult>> continuation, CancellationToken ct);\n  public Task<TContinuationResult> onSuccess(\n      final Continuation<TResult, TContinuationResult> continuation, Executor executor);\n  public Task<TContinuationResult> onSuccess(\n      final Continuation<TResult, TContinuationResult> continuation, Executor executor,\n      final CancellationToken ct);\n  public Task<TContinuationResult> onSuccess(\n      final Continuation<TResult, TContinuationResult> continuation);\n  public Task<TContinuationResult> onSuccess(\n      final Continuation<TResult, TContinuationResult> continuation, CancellationToken ct);\n  public Task<TContinuationResult> onSuccessTask(\n      final Continuation<TResult, Task<TContinuationResult>> continuation, Executor executor);\n  public Task<TContinuationResult> onSuccessTask(\n      final Continuation<TResult, Task<TContinuationResult>> continuation, Executor executor,\n      final CancellationToken ct);\n  public Task<TContinuationResult> onSuccessTask(\n      final Continuation<TResult, Task<TContinuationResult>> continuation);\n  public Task<TContinuationResult> onSuccessTask(\n      final Continuation<TResult, Task<TContinuationResult>> continuation,\n      CancellationToken ct);\n  private static void completeImmediately(\n      final bolts.TaskCompletionSource<TContinuationResult> tcs,\n      final Continuation<TResult, TContinuationResult> continuation, final Task<TResult> task,\n      Executor executor, final CancellationToken ct);\n  private static void completeAfterTask(\n      final bolts.TaskCompletionSource<TContinuationResult> tcs,\n      final Continuation<TResult, Task<TContinuationResult>> continuation,\n      final Task<TResult> task, final Executor executor,\n      final CancellationToken ct);\n  private void runContinuations();\n   boolean trySetCancelled();\n   boolean trySetResult(TResult result);\n   boolean trySetError(Exception error);\n\n  @Rule\n  public ExpectedException thrown;\n\n}\n\nclass TaskTest {\n\n  @Rule\n  public ExpectedException thrown;\n\n  @Test\n  public void testContinueWhile() {\n", "reference": "    final AtomicInteger count = new AtomicInteger(0);\n    runTaskTest(new Callable<Task<?>>() {\n      public Task<?> call() throws Exception {\n        return Task.forResult(null).continueWhile(new Callable<Boolean>() {\n          public Boolean call() throws Exception {\n            return count.get() < 10;\n          }\n        }, new Continuation<Void, Task<Void>>() {\n          public Task<Void> then(Task<Void> task) throws Exception {\n            count.incrementAndGet();\n            return null;\n          }\n        }).continueWith(new Continuation<Void, Void>() {\n          public Void then(Task<Void> task) throws Exception {\n            assertEquals(10, count.get());\n            return null;\n          }\n        });\n      }\n    });\n  }\n\n}", "prediction": "    final Task<Void> task = Task.delay(1000).continueWhile(new Callable<Boolean>() {\n      @Override\n      public Boolean call() throws Exception {\n        return true;\n      }\n    }, new Continuation<Void, Task<Void>>() {\n      @Override\n      public Task<Void> then(Task<Void> task) throws Exception {\n        return Task.delay(1000);\n      }\n    });\n    task.waitForCompletion();\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "16462032_69", "part": [1, 1], "seq": [1, 1], "prompt": "class StringUtils {\n\n    public static boolean equals(String s1, String s2, Locale locale) {\n        return Collator.getInstance(locale).equals(s1, s2);\n    }\n\n    private  StringUtils();\n\n    public static boolean endsWithIgnoreCase(String a, String b);\n    public static boolean matchesIgnoreCase(String a, String b, int posA);\n    public static boolean endsWithIgnoreCase(String a, char[] b);\n    public static boolean matchesIgnoreCase(String a, char[] b, int posA);\n    public static boolean endsWith(String a, char[] b);\n    public static boolean matches(String a, char[] b, int posA);\n    public static boolean startsWithIgnoreCase(String a, String b);\n    public static boolean equals(String s1, String s2, boolean caseSensitive);\n    public static int parseIntDef(String s, int def);\n    public static String capitalize(String s);\n    public static String flatten(String s[]);\n    public static String flatten(String s[], String separator);\n    public static boolean isNullOrEmpty(String string);\n\n}\n\nclass StringUtilsTest {\n\n    @Test(dataProvider = \"caseInsensitiveEquals\")\n    public void testCaseInsensitiveEquals(String a, String b, boolean expected) {\n", "reference": "        assert StringUtils.equals(a, b, false) == expected;\n    }\n\n}", "prediction": "        assertEquals(StringUtils.equals(a, b, Locale.ENGLISH), expected);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "16896558_1", "part": [1, 1], "seq": [1, 1], "prompt": "class CompletableFutureFlow {\n\n    static CompletableFuture<Integer> flowWithId(int id, ExecutorService pool) {\n        return firstOperation(id, pool)\n               .thenCompose(__ -> secondOperation(id, pool))\n               .thenCompose(__ -> thirdOperation(id, pool));\n    }\n\n    private static CompletableFuture<Integer> firstOperation(int id, ExecutorService pool);\n    private static CompletableFuture<Integer> slowOperationAsync(int flow, int step, ExecutorService pool);\n    private static int slowOperation(int flow, int step);\n    private static CompletableFuture<Integer> secondOperation(int id, ExecutorService pool);\n    private static CompletableFuture<Integer> thirdOperation(int id, ExecutorService pool);\n    static void getFuture(CompletableFuture<Integer> future);\n\n    public static final int POOL_SIZE;\n    private ExecutorService pool;\n\n}\n\nclass CompletableFutureFlowTest {\n\n    public static final int POOL_SIZE;\n    private ExecutorService pool;\n\n    @Test\n    public void testFlowWithFixedThreadPool() throws Exception {\n", "reference": "        pool = Executors.newFixedThreadPool(POOL_SIZE);\n\n        List<CompletableFuture<Integer>> futures = new ArrayList<>();\n\n        for (int i = 0; i < 20; i++) {\n            futures.add(\n                    CompletableFutureFlow.flowWithId(i, pool));\n        }\n\n        futures.forEach(CompletableFutureFlow::getFuture);\n    }\n\n}", "prediction": "        CompletableFuture<Integer> future = CompletableFutureFlow.flowWithId(1, pool);\n        CompletableFutureFlow.getFuture(future);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "16945217_19", "part": [1, 1], "seq": [1, 1], "prompt": "class TStringUtil extends StringUtils {\n\n    public static List<String> recursiveSplit(String str, String splitor) {\n        List<String> re = new ArrayList<String>();\n        String[] strs = twoPartSplit(str, splitor);\n        if (strs.length == 2) {\n            re.add(strs[0]);\n            re.addAll(recursiveSplit(strs[1], splitor));\n        } else {\n            re.add(strs[0]);\n        }\n        return re;\n    }\n\n    public static String getBetween(String sql, String start, String end);\n    public static String removeBetween(String sql, String start, String end);\n    public static String[] twoPartSplit(String str, String splitor);\n    public static String fillTabWithSpace(String str);\n    public static boolean startsWithIgnoreCaseAndWs(String searchIn, String searchFor);\n    public static boolean startsWithIgnoreCaseAndWs(String searchIn, String searchFor, int beginPos);\n    public static boolean startsWithIgnoreCase(String searchIn, int startAt, String searchFor);\n    public static String stripComments(String src, String stringOpens, String stringCloses, boolean slashStarComments,\n                                       boolean slashSlashComments, boolean hashComments, boolean dashDashComments);\n    public static String removeBetweenWithSplitor(String sql, String start, String end);\n    public static String removeBetweenWithSplitorNotExistNull(String sql, String start, String end);\n    public static boolean isTableFatherAndSon(String fatherTable, String sonTable);\n\n}\n\nclass TStringUtilTest {\n\n    @Test\n    public void testRecursiveSplit() {\n", "reference": "        Assert.assertEquals(TStringUtil.recursiveSplit(\"abc:bc:bc\", \":\"), Arrays.asList(\"abc\", \"bc\", \"bc\"));\n        Assert.assertEquals(TStringUtil.recursiveSplit(\"abc:bc\", \"d\"), Arrays.asList(\"abc:bc\"));\n        Assert.assertEquals(TStringUtil.recursiveSplit(\"abc:bc\", \";\"), Arrays.asList(\"abc:bc\"));\n    }\n\n}", "prediction": "        List<String> re = TStringUtil.recursiveSplit(\"a.b.c.d.e.f.g.h.i.j.k.l.m.n.o.p.q.r.s.t.u.v.w.x.y.z\", \".\");\n        System.out.println(re);\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "17146973_1", "part": [1, 1], "seq": [1, 1], "prompt": "class Speakerbox implements TextToSpeech.OnInitListener {\n\n    public void play(CharSequence text) {\n        play(text.toString(), null, null, null);\n    }\n\n    public  Speakerbox(final Application application);\n\n    @Override public void onInit(int status);\n    public void setActivity(Activity activity);\n    public Application.ActivityLifecycleCallbacks getCallbacks();\n    public void playAndOnStart(String text, Runnable onStart);\n    public void playAndOnDone(String text, Runnable onDone);\n    public void playAndOnError(String text, Runnable onError);\n    public void play(String text, Runnable onStart, Runnable onDone, Runnable onError);\n    public void stop();\n    private String applyRemixes(String text);\n    private void playInternal(String text, String utteranceId);\n    public void dontPlayIfContains(String text);\n    private boolean doesNotContainUnwantedPhrase(String text);\n    public void mute();\n    public void unmute();\n    public boolean isMuted();\n    public void remix(String original, String remix);\n    public TextToSpeech getTextToSpeech();\n    public void requestAudioFocus();\n    public void abandonAudioFocus();\n    public void enableVolumeControl(Activity activity);\n    public void disableVolumeControl(Activity activity);\n    public void setQueueMode(int queueMode);\n    @TargetApi(Build.VERSION_CODES.LOLLIPOP) public Set<Locale> getAvailableLanguages();\n    public void setLanguage(Locale locale);\n    public void shutdown();\n    private boolean detectAndRun(String utteranceId, HashMap<String, Runnable> hashMap);\n\n    private Activity activity;\n    private Speakerbox speakerbox;\n    private com.mapzen.speakerbox.ShadowTextToSpeech shadowTextToSpeech;\n\n}\n\nclass SpeakerboxTest {\n\n    private Activity activity;\n    private Speakerbox speakerbox;\n    private com.mapzen.speakerbox.ShadowTextToSpeech shadowTextToSpeech;\n\n    @Test\n    public void shouldPlayCharacterSequence() throws Exception {\n", "reference": "        CharSequence expected = \"Hello\";\n        speakerbox.play(expected);\n        assertThat(shadowTextToSpeech.getLastSpokenText()).isEqualTo(expected.toString());\n    }\n\n}", "prediction": "        speakerbox.play(\"Hello World\");\n        verify(shadowTextToSpeech).speak(\"Hello World\", TextToSpeech.QUEUE_FLUSH, null);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "17203543_4", "part": [1, 1], "seq": [1, 1], "prompt": "class POIBean {\n\n\tpublic String getDescription() {\n\t\treturn description;\n\t}\n\n\tpublic  POIBean(String _id, String _name, String _desc, int _type, double lat, double lon);\n\n\tpublic String getId();\n\tpublic void setId(String id);\n\tpublic String getName();\n\tpublic void setName(String name);\n\tpublic void setDescription(String description);\n\tpublic int getType();\n\tpublic void setType(int type);\n\tpublic JSONObject toJSONObject();\n\n\tprivate POIBean poiBean;\n\n}\n\nclass POIBeanTest {\n\n\tprivate POIBean poiBean;\n\n\t@Test\n\tpublic void testGetDescription() {\n", "reference": "\t\tassertEquals(poiBean.getDescription(), \"haha\");\n\t}\n\n}", "prediction": "\t\tassertEquals(\"test\", poiBean.getDescription());\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "17537838_1", "part": [1, 1], "seq": [1, 1], "prompt": "class DefaultRoleToGroupMapper implements RoleToGroupMapper {\n\n    @Override\n    public List<String> groupsFromRoles(List<String> roles) {\n        if (template == null || roles == null) {\n            return roles;\n        } else {\n            List<String> renamedRoles = new ArrayList<>();\n            for (String role : roles) {\n                String renamedRole = template.replace(ROLE_MAPPING_PLACEHOLDER, role);\n                renamedRoles.add(renamedRole);\n                LOG.debug(\"Mapped role {} to {}\", role, renamedRole);\n            }\n            return renamedRoles;\n        }\n    }\n\n    @Override public void cleanup();\n    @Override public void initialize(Properties properties);\n\n}\n\nclass DefaultRoleToGroupMapperTest {\n\n    @Test\n    public void testNullMapping() {\n", "reference": "        DefaultRoleToGroupMapper mapper = new DefaultRoleToGroupMapper();\n\n        List<String> result = mapper.groupsFromRoles(null);\n        assertNull(result);\n    }\n\n}", "prediction": "        DefaultRoleToGroupMapper mapper = new DefaultRoleToGroupMapper();\n        mapper.initialize(null);\n        List<String> roles = Arrays.asList(\"role1\", \"role2\");\n        List<String> groups = mapper.groupsFromRoles(roles);\n        assertEquals(roles, groups);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "17586846_36", "part": [1, 1], "seq": [1, 1], "prompt": "class AHashSet extends MapAsSetWrapper<T, AHashSet<T>> {\n\n    public static <T> AHashSet<T> empty () {\n        return empty (AEquality.EQUALS);\n    }\n\n    private  AHashSet(AMap<T,?> inner);\n\n    @SuppressWarnings (\"unchecked\") public static AHashSet<T> empty(AEquality equality);\n    @SuppressWarnings (\"unchecked\") public static AHashSet<T> create(T... elements);\n    public static AHashSet<T> create(Iterable<T> elements);\n    @SuppressWarnings (\"unchecked\") public static AHashSet<T> create(AEquality equality, T... elements);\n    public static AHashSet<T> create(AEquality equality, Iterable<T> elements);\n    public static AHashSet<T> fromMap(AHashMap<T,?> inner);\n    private Object readResolve();\n    @Override protected AHashSet<T> wrapAsSet(AMap<T,?> inner);\n\n}\n\nclass AHashSetTest extends MapAsSetWrapper<T, AHashSet<T>> {\n\n    @Test\n    public void testEquals2() {\n", "reference": "        assertEquals(AHashSet.empty (),\n                     AHashSet.empty ());\n        assertEquals(AHashSet.empty ().with(\"a\"),\n                     AHashSet.empty ().with(\"a\"));\n        assertEquals(AHashSet.empty ().with(\"a\").with(\"b\"),\n                     AHashSet.empty ().with(\"b\").with(\"a\"));\n\n        assertNotEquals(AHashSet.empty (),\n                        AHashSet.empty ().with(\"a\"));\n        assertNotEquals(AHashSet.empty ().with(\"a\"),\n                        AHashSet.empty ());\n        assertNotEquals(AHashSet.empty ().with(\"a\").with(\"b\"),\n                        AHashSet.empty ().with(\"a\").with(\"b\").with(\"c\"));\n        assertNotEquals(AHashSet.empty ().with(\"a\").with(\"b\").with(\"c\"),\n                        AHashSet.empty ().with(\"a\").with(\"b\"));\n        assertNotEquals(AHashSet.empty ().with(\"a\").with(\"b\").with(\"c\"),\n                        AHashSet.empty ().with(\"b\").with(\"c\"));\n\n        assertNotEquals(AHashSet.empty (), null);\n    }\n\n}", "prediction": "        AHashSet<String> set1 = AHashSet.create(\"a\", \"b\");\n        AHashSet<String> set2 = AHashSet.create(\"a\", \"b\");\n        assertEquals(set1, set2);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "17627031_46", "part": [1, 1], "seq": [1, 1], "prompt": "class JsonHandler extends HandlerBase {\n\n\tprotected JsonArrayBuilder showArray(int[] iarray) {\n\t\tJsonArrayBuilder aBuilder = Json.createArrayBuilder();\n\t\tfor (int i : iarray) {\n\t\t\taBuilder.add(i);\n\t\t}\n\t\treturn aBuilder;\n\t}\n\n\tpublic  JsonHandler();\n\tpublic  JsonHandler(String name, String release, int[] date, String note, String rights);\n\n\t@Override public void show();\n\t@Override public void show(App app);\n\t@Override public void show(OutputHandler handler);\n\t@Override public void show(Module module);\n\t@Override public void show(RepInfo info);\n\tprotected JsonObjectBuilder showAgent(Agent agent, String label);\n\tprotected JsonObjectBuilder showChecksum(Checksum checksum);\n\tprotected JsonObjectBuilder showDocument(Document document);\n\t@Override public void showFooter();\n\t@Override public void showHeader();\n\tprotected JsonObjectBuilder showIdentifier(Identifier identifier);\n\tprotected JsonObjectBuilder showMessage(Message message);\n\tprotected JsonObjectBuilder showSignature(Signature signature);\n\tprotected String valueToString(Object obj);\n\tprotected JsonObjectBuilder showProperty(Property property);\n\tprotected JsonObjectBuilder showScalarProperty(Property property);\n\tprotected JsonObjectBuilder showListProperty(Property property);\n\tprotected JsonObjectBuilder showSetProperty(Property property);\n\tprotected JsonObjectBuilder showMapProperty(Property property);\n\tprotected int propertyLength(Property property);\n\tprotected JsonObjectBuilder showArrayProperty(Property property);\n\tprotected JsonObjectBuilder showTextMDMetadata(TextMDMetadata textMD);\n\tprotected JsonObjectBuilder showNisoImageMetadata(NisoImageMetadata niso);\n\tprotected JsonObjectBuilder showNisoImageMetadata(NisoImageMetadata niso, boolean bMix10);\n\tprotected JsonObjectBuilder showNisoBasicDigitalObjectInformation(NisoImageMetadata niso, boolean bMix10);\n\tprotected JsonObjectBuilder showNisoBasicImageInformation(NisoImageMetadata niso, boolean bMix10);\n\tprotected JsonObjectBuilder showNisoImageCaptureMetadata(NisoImageMetadata niso, boolean bMix10);\n\tprotected JsonObjectBuilder showNisoImageAssessmentMetadata(NisoImageMetadata niso, boolean bMix10);\n\tprotected JsonObjectBuilder showChangeHistory(NisoImageMetadata niso, boolean bMix10);\n\tprivate String meteringModeToString(int n);\n\tprivate String photometricInterpretationToString(int n);\n\tprivate String compressionSchemeToString(int n);\n\tprotected JsonObjectBuilder showAESAudioMetadata(AESAudioMetadata aes);\n\tprivate JsonObjectBuilder writeAESTimeRange(AESAudioMetadata.TimeDesc start, AESAudioMetadata.TimeDesc duration);\n\tprotected JsonArrayBuilder showArray(double[] darray);\n\tprotected JsonArrayBuilder showArray(String[] sarray);\n\tprotected JsonArrayBuilder showArray(Rational[] rarray);\n\tprotected JsonArrayBuilder showRational(Rational r);\n\n\tprivate static final Logger LOGGER;\n\tprivate static final String TIME_PATTERN;\n\tprivate static final String DATE_PATTERN;\n\tprivate static final String DATE_REPLACEMENT;\n\tprivate static final String RELEASE_PATTERN;\n\tprivate static final String RELEASE_REPLACEMENT;\n\tprivate static final String DIR_PATTERN;\n\tprivate static final String DIR_REPLACEMENT;\n\tprivate static final String CONF_PATTERN;\n\tprivate static final String CONF_REPLACEMENT;\n\tprivate static final String RIGHTS_PATTERN;\n\tprivate static final String RIGHTS_REPLACEMENT;\n\tprivate static final String VENDOR_PATTERN;\n\tprivate static final String VENDOR_REPLACEMENT;\n\tprivate static final String DUMMY;\n\tprivate static final String DUMMY_CK;\n\tprivate static final String APP_JSON;\n\tprivate static final String API_JSON;\n\tprivate static final String HANDLER_JSON;\n\tprivate static final String MODULE_JSON;\n\tprivate static final String INFO_JSON;\n\tprivate static final String FIND;\n\tprivate static App mockApp;\n\tprivate static JhoveBase je;\n\tprivate File outputFile;\n\tprivate StringWriter outString;\n\tprivate PrintWriter writer;\n\tprivate JsonHandler handler;\n\n}\n\nclass JsonHandlerTest {\n\n\tprivate static final Logger LOGGER;\n\tprivate static final String TIME_PATTERN;\n\tprivate static final String DATE_PATTERN;\n\tprivate static final String DATE_REPLACEMENT;\n\tprivate static final String RELEASE_PATTERN;\n\tprivate static final String RELEASE_REPLACEMENT;\n\tprivate static final String DIR_PATTERN;\n\tprivate static final String DIR_REPLACEMENT;\n\tprivate static final String CONF_PATTERN;\n\tprivate static final String CONF_REPLACEMENT;\n\tprivate static final String RIGHTS_PATTERN;\n\tprivate static final String RIGHTS_REPLACEMENT;\n\tprivate static final String VENDOR_PATTERN;\n\tprivate static final String VENDOR_REPLACEMENT;\n\tprivate static final String DUMMY;\n\tprivate static final String DUMMY_CK;\n\tprivate static final String APP_JSON;\n\tprivate static final String API_JSON;\n\tprivate static final String HANDLER_JSON;\n\tprivate static final String MODULE_JSON;\n\tprivate static final String INFO_JSON;\n\tprivate static final String FIND;\n\tprivate static App mockApp;\n\tprivate static JhoveBase je;\n\tprivate File outputFile;\n\tprivate StringWriter outString;\n\tprivate PrintWriter writer;\n\tprivate JsonHandler handler;\n\n\t@Test\n\tpublic void testShowArrayString() throws IOException {\n", "reference": "\t\tfinal String[] sArrayTest = { null, \"\", \"DUMMY\" };\n\t\tJsonArrayBuilder b = this.handler.showArray(sArrayTest);\n\n\t\tbuildJson(b);\n        handler.close();\n        \n\t\tString result = outString.toString();\n\t\tLOGGER.info(FIND + result);\n\t\tfinal String expected = \"{\\\"ARRAY\\\":[null,\\\"\\\",\\\"DUMMY\\\"]}\";\n\t\t\n\t    assertEquals(expected, result);\n\t}\n\n}", "prediction": "\t\tString[] sarray = { \"a\", \"b\", \"c\" };\n\t\tJsonArrayBuilder aBuilder = handler.showArray(sarray);\n\t\tJsonArray array = aBuilder.build();\n\t\tassertEquals(3, array.size());\n\t\tassertEquals(\"a\", array.get(0).getAsString());\n\t\tassertEquals(\"b\", array.get(1).getAsString());\n\t\tassertEquals(\"c\", array.get(2).getAsString());\n\t}", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "17898911_105", "part": [1, 1], "seq": [1, 1], "prompt": "class ColumnTypeEditor implements IsWidget,\n                                         org.dashbuilder.dataset.client.editor.ColumnTypeEditor {\n\n    @Override\n    public DropDownImageListEditor<ColumnType> columnType() {\n        return columnType;\n    }\n\n    @Inject public  ColumnTypeEditor(final DropDownImageListEditor<ColumnType> columnType);\n\n    @PostConstruct public void init();\n    @Override public Widget asWidget();\n    public void addHelpContent(final String title,\n                               final String content,\n                               final Placement placement);\n    @Override public void setOriginalColumnType(final ColumnType columnType);\n    @Override public void flush();\n    @Override public void onPropertyChange(final String... paths);\n    @Override public void setValue(final DataColumnDef value);\n    @Override public void setDelegate(final EditorDelegate<DataColumnDef> delegate);\n    private Collection<ImageListEditor<ColumnType>.Entry> getAcceptableEntries(final ColumnType type);\n    protected Collection<ImageListEditor<ColumnType>.Entry> getDefaultEntries();\n    private ImageListEditor<ColumnType>.Entry buildEntry(final ColumnType type);\n     SafeUri getImageUri(final ColumnType type);\n     String getColumnTypeDescription(final ColumnType type);\n    @Override public void isEditMode(final boolean isEdit);\n     void onColumnTypeChanged(@Observes ValueChangeEvent<ColumnType> event);\n\n    @Mock DropDownImageListEditor<ColumnType> columnType;\n    @Mock Widget columnTypeWidget;\n    private ColumnTypeEditor presenter;\n\n}\n\nclass ColumnTypeEditorTest {\n\n    @Mock DropDownImageListEditor<ColumnType> columnType;\n    @Mock Widget columnTypeWidget;\n    private ColumnTypeEditor presenter;\n\n    @Test\n    public void testColumnType() {\n", "reference": "        assertEquals(columnType, presenter.columnType());\n    }\n\n}", "prediction": "        presenter.columnType();\n        verify(columnType).asWidget();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "18311299_15", "part": [1, 1], "seq": [1, 1], "prompt": "class TableMetadata {\n\n    List<String> getColumnNames(String tableName) throws SQLException {\n        List<String> result = Lists.newArrayList();\n        try (\n                Connection connection = connectionProvider.getConnection();\n                PreparedStatement stmt = connection.prepareStatement(GET_COLUMN_NAMES_QUERY)) {\n            stmt.setString(1, tableName);\n            ResultSet rs = stmt.executeQuery();\n\n            while (rs.next()) {\n                result.add(rs.getString(1));\n            }\n\n            return result;\n        } catch (SQLException sqle) {\n            throw new DataAccessException(COLUMN_NAMES_ERROR + tableName, sqle);\n        }\n    }\n\n      TableMetadata(ConnectionProvider connectionProvider);\n\n    @Mock AbstractConnectionProvider mockedConnectionProvider;\n    @Mock Connection mockedConnection;\n    @Mock PreparedStatement mockedStmt;\n    @Mock ResultSet mockedResultSet;\n     TableMetadata tableMetadata;\n\n}\n\nclass TableMetadataTest {\n\n    @Mock AbstractConnectionProvider mockedConnectionProvider;\n    @Mock Connection mockedConnection;\n    @Mock PreparedStatement mockedStmt;\n    @Mock ResultSet mockedResultSet;\n     TableMetadata tableMetadata;\n\n    @Test(groups = INTEGRATION)\n    public void testGetColumnNamesForExistingTable() throws SQLException {\n", "reference": "        tableMetadata = new TableMetadata(new MysqlConnectionProvider(URL, USERNAME, PASSWORD));\n        List<String> columnNames = tableMetadata.getColumnNames(TEST_TABLE_NAME);\n\n        assertEquals(columnNames.size(), 2);\n        assertTrue(columnNames.contains(\"ID\"));\n        assertTrue(columnNames.contains(\"TXT\"));\n    }\n\n}", "prediction": "        List<String> expected = Lists.newArrayList(\"id\", \"name\");\n        when(mockedConnectionProvider.getConnection()).thenReturn(mockedConnection);\n        when(mockedConnection.prepareStatement(TableMetadata.GET_COLUMN_NAMES_QUERY)).thenReturn(mockedStmt);\n        when(mockedStmt.executeQuery()).thenReturn(mockedResultSet);\n        when(mockedResultSet.next()).thenReturn(true, true, false);\n        when(mockedResultSet.getString(1)).thenReturn(\"id\", \"name\");\n\n        List<String> actual = tableMetadata.getColumnNames(\"test\");\n\n        assertEquals(actual, expected);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "18467626_23", "part": [1, 1], "seq": [1, 1], "prompt": "class CPLCUtils {\n\n\tpublic static CPLC parse(byte[] raw) {\n\t\tCPLC ret = null;\n\t\tif (raw!= null) {\n\t\t\tbyte[] cplc = null;\n\t\t\t// try to interpret as raw data (not TLV)\n\t\t\tif (raw.length == CPLC.SIZE + 2) {\n\t\t\t\tcplc = raw;\n\t\t\t}\n\t\t\t// or maybe it's prepended with CPLC tag:\n\t\t\telse if (raw.length == CPLC.SIZE + 5) {\n\t\t\t\tcplc = TlvUtil.getValue(raw, CPLC_TAG);\n\t\t\t} else {\n\t\t\t\tLOGGER.error(\"CPLC data not valid\");\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tret = new CPLC();\n\t\t\tret.parse(cplc,null);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tprivate  CPLCUtils();\n\n}\n\nclass CPLCUtilsTest {\n\n\t@Test\n\tpublic void testPrependedCPLC(){\n", "reference": "\t\t// prepended with CPLC tag\n\t\tCPLC cplc = CPLCUtils.parse(BytesUtils.fromString(\"9F 7F 2A 47 90 50 40 47 91 81 02 31 00 83 58 00 11 68 91 45 81 48 12 83 65 00 00 00 00 01 2F 31 30 31 31 36 38 00 00 00 00 00 00 00 00 90 00\"));\t\t\n\t\tAssertions.assertThat(cplc).isNotNull();\n\t\tAssertions.assertThat(cplc.getIcFabricator()).isEqualTo(0x4790);\n\t\tAssertions.assertThat(cplc.getIcType()).isEqualTo(0x5040);\n\t\tAssertions.assertThat(cplc.getOs()).isEqualTo(0x4791);\n\t\tAssertions.assertThat(cplc.getOsReleaseLevel()).isEqualTo(0x3100);\n\t\tAssertions.assertThat(cplc.getIcSerialNumber()).isEqualTo(0x00116891);\n\t\tAssertions.assertThat(cplc.getIcBatchId()).isEqualTo(0x4581);\n\t\tAssertions.assertThat(cplc.getIcModuleFabricator()).isEqualTo(0x4812);\n\t\tAssertions.assertThat(cplc.getIccManufacturer()).isEqualTo(0x0000);\n\t\tAssertions.assertThat(cplc.getIcEmbeddingDate()).isNull();\n\t\tAssertions.assertThat(cplc.getPrepersoId()).isEqualTo(0x012F);\n\t\tAssertions.assertThat(cplc.getPrepersoEquipment()).isEqualTo(0x31313638);\n\t\tAssertions.assertThat(cplc.getPersoId()).isEqualTo(0x0000);\n\t\tAssertions.assertThat(cplc.getPersoEquipment()).isEqualTo(0x0000);\n\t}\n\n}", "prediction": "\t\tbyte[] raw = new byte[CPLC.SIZE + 5];\n\t\traw[0] = (byte) 0x00;\n\t\traw[1] = (byte) 0x00;\n\t\traw[2] = (byte) 0x00;\n\t\traw[3] = (byte) 0x00;\n\t\traw[4] = (byte) 0x00;\n\t\traw[5] = (byte) 0x00;\n\t\traw[6] = (byte) 0x00;\n\t\traw[7] = (byte) 0x00;\n\t\traw[8] = (byte) 0x00;\n\t\traw[9] = (byte) 0x00;\n\t\traw[10] = (byte) 0x00;\n\t\traw[11] = (byte) 0x00;\n\t\traw[12] = (byte) 0x00;\n\t\traw[13] = (byte) 0x00;\n\t\traw[14] = (byte) 0x00;\n\t\traw[15] = (byte) 0x00;\n\t\traw[16] = (byte) 0x00;\n\t\traw[17] = (byte) 0x00;\n\t\traw[18] = (byte) 0x00;\n\t\traw[19] = (byte) 0x00;\n\t\traw[20] = (byte) 0x00;\n\t\traw[21] = (byte) 0x00;\n\t\traw[22] = (byte) 0x00;\n\t\traw[23] = (byte) 0x00;\n\t\traw[24] = (byte) 0x00;\n\t\traw[25] = (byte) 0x00;\n\t\traw[26] = (byte) 0x00;\n\t\traw[27] = (byte) 0x00;\n\t\traw[28] = (byte) 0x00;\n\t\traw[29] = (byte) 0x00;\n\t\traw[30] = (byte) 0x00;\n\t\traw[31] = (byte) 0x00;\n\t\traw[32] = (byte) 0x00;\n\t\traw[33] = (byte) 0x00;\n\t\traw[34] = (byte) 0x00;\n\t\traw[35] = (byte) 0x00;\n\t\traw[36] = (byte) 0x00;\n\t\traw[37] = (byte) 0x00;\n\t\traw[38] = (byte) 0x00;\n\t\traw[39] = (byte) 0x00;\n\t\traw[40] = (byte) 0x00;\n\t\traw[41] = (byte) 0x00;\n\t\traw[42] = (byte) 0x00;\n\t\traw[43] = (byte) 0x00;\n\t\traw[44] = (byte) 0x00;\n\t\traw[45] = (byte) 0x00;\n\t\traw[46] = (byte) 0x00;\n\t\traw[47] = (byte) 0x00;\n\t\traw[48] = (byte) 0x00;\n\t\traw[49] = (byte) 0x00;\n\t\traw[50] = (byte) 0x00;\n\t\traw[51] = (byte) 0x00;\n\t\traw[52] = (byte) 0x00;\n\t\traw[53] = (byte) 0x00;\n\t\traw[54] = (byte) 0x00;\n\t\traw[55] = (byte) 0x00;\n\t\traw[56] = (byte) 0x00;\n\t\traw[57] = (byte) 0x00;\n\t\traw[58] = (byte) 0x00;\n\t\traw[59] = (byte) 0x00;\n\t\traw[60] = (byte) 0x00;\n\t\traw[61] = (byte) 0x00;\n\t\traw[62] = (byte) 0x00;\n\t\traw[63] = (byte) 0x00;\n\t\traw[64] = (byte) 0x00;\n\t\traw[65] = (byte) 0x00;\n\t\traw[66] = (byte) 0x00;\n\t\traw[67] = (byte) 0x00;\n\t\traw[68] = (byte) 0x00;\n\t\traw[69] = (byte) 0x00;\n\t\traw[70] = (byte) 0x00;\n\t\traw[71] = (byte) 0x00;\n\t\traw[72] = (byte) 0x00;\n\t\traw[73] = (byte) 0x00;\n\t\traw[74] = (byte) 0x00;\n\t\traw[75] = (byte) 0x00;\n\t\traw[76] = (byte) 0x00;\n\t\traw[77] = (byte) 0x00;\n\t\traw[78] = (byte) 0x00;\n\t\traw[79] = (byte) 0x00;\n\t\traw[80] = (byte) 0x00;\n\t\traw[81] = (byte) 0x00;\n\t\traw[82] = (byte) 0x00;\n\t\traw[83] = (byte) 0x00;\n\t\traw[84] = (byte) 0x00;\n\t\traw[85] = (byte) 0x00;\n\t\traw[86] = (byte) 0x00;\n\t\traw[87] = (byte) 0x00;\n\t\traw[88] = (byte) 0x00;\n\t\traw[89] = (byte) 0x00;\n\t\traw[90] = (byte) 0x00;\n\t\traw[91] = (byte) 0x00;\n\t\traw[92] = (byte) 0x00;\n\t\traw[93] = (byte) 0x00;\n\t\traw[94] = (byte) 0x00;\n\t\traw[95] = (byte) 0x00;\n\t\traw[96] = (byte) 0x00;\n\t\traw[97] = (byte) 0x00;\n\t\traw[98] = (byte) 0x00;\n\t\traw[99] = (byte) 0x00;\n\t\traw[100] = (byte) 0x00;\n\t\traw[101] = (byte) 0x00;\n\t\traw[102] = (byte) 0x00;\n\t\traw[103] = (byte) 0x00;\n\t\t", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "18749200_0", "part": [1, 1], "seq": [1, 1], "prompt": "class PID implements Serializable {\n\n  public static PID fromString(String pid) throws IllegalArgumentException {\n    List<String> components = Splitter.on(\"@\").omitEmptyStrings().splitToList(pid);\n    if (components.size()!= 2) {\n      throw new IllegalArgumentException(\n          \"Illegal libprocess pid: \" + pid + \". Format is id@host:port.\");\n    }\n    String id = components.get(0);\n    if (CharMatcher.WHITESPACE.matchesAnyOf(id)) {\n      throw new IllegalArgumentException(\"No whitespace allowed in process id.\");\n    }\n    HostAndPort hostAndPort = HostAndPort.fromString(components.get(1))\n       .requireBracketsForIPv6();\n    if (!hostAndPort.hasPort()) {\n      throw new IllegalArgumentException(\"No port specified.\");\n    }\n    return new PID(id, hostAndPort);\n  }\n\n  public  PID(String id, HostAndPort hostAndPort);\n\n  public String getId();\n  public HostAndPort getHostAndPort();\n  public URL getBaseUrl();\n  @Override public String toString();\n  @Override public boolean equals(Object o);\n  @Override public int hashCode();\n\n}\n\nclass PIDTest {\n\n  @Test\n  public void testFromString() throws Exception {\n", "reference": "    PID pid = PID.fromString(\"scheduler@192.168.1.1:8081\");\n    assertEquals(\"scheduler@192.168.1.1:8081\", pid.toString());\n    assertEquals(\"http://192.168.1.1:8081/scheduler\", pid.getBaseUrl().toString());\n  }\n\n}", "prediction": "    PID pid = PID.fromString(\"1234@localhost:1234\");\n    assertThat(pid.getId()).isEqualTo(\"1234\");\n    assertThat(pid.getHostAndPort().getHost()).isEqualTo(\"localhost\");\n    assertThat(pid.getHostAndPort().getPort()).isEqualTo(1234);\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "18788616_0", "part": [1, 1], "seq": [1, 1], "prompt": "class Select {\n\n    public Select(Findr findr) {\n        this.findr = findr;\n    }\n\n    public  Select(Findr findr);\n\n    public Findr getFindr();\n    public Select selectByVisibleText(String text);\n    public Select assertSelectedText(String expected);\n    public static Function<WebElement,?> makeSelectByVisibleText(final String text);\n    public static Predicate<WebElement> selectedText(final String expectedText);\n    @Deprecated public static void selectByVisibleText(Findr selectFindr, final String text);\n\n}\n\nclass SelectTest  {\n\n    @Ignore(\"shaky : the page uses iframes and it doesn't seem to be ok\")\n    @Test\n    public void testSelect() {\n", "reference": "        getWebDriver().get(\"http://www.w3schools.com/tags/tryit.asp?filename=tryhtml_select\");\n        getWebDriver().switchTo().frame(\"view\");\n        Findr fSelect = findr().elem(By.tagName(\"select\"));\n        Select select = new Select(fSelect);\n\n        // assert value\n        fSelect.where(Select.selectedText(\"Volvo\")).eval();\n        // change value\n        fSelect.eval(Select.makeSelectByVisibleText(\"Audi\"));\n        // assert value again\n        fSelect.where(Select.selectedText(\"Audi\")).eval();\n\n        // same with instance methods\n        select.assertSelectedText(\"Audi\")\n            .selectByVisibleText(\"Volvo\")\n            .assertSelectedText(\"Volvo\");\n    }\n\n}", "prediction": "//        Findr findr = new Findr(new WebDriverWait(new FirefoxDriver(), 10));\n//        findr.get(\"http://www.google.com/xhtml\");\n//        Select select = new Select(findr);\n//        select.selectByVisibleText(\"Gmail\");\n//        select.assertSelectedText(\"Gmail\");\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "19730456_168", "part": [1, 1], "seq": [1, 1], "prompt": "class BloomFilter implements Serializable {\n\n    public synchronized boolean getBit(int bit) {\n        return bitset.get(bit);\n    }\n\n    public  BloomFilter(double c, int n, int k);\n    public  BloomFilter(int bitSetSize, int expectedNumberOElements);\n    public  BloomFilter(double falsePositiveProbability, int expectedNumberOfElements);\n    public  BloomFilter(int bitSetSize, int expectedNumberOfFilterElements, int actualNumberOfFilterElements, BitSet filterData);\n\n    @Override public boolean equals(Object obj);\n    @Override public int hashCode();\n    public double expectedFalsePositiveProbability();\n    public double getFalsePositiveProbability(double numberOfElements);\n    public double getFalsePositiveProbability();\n    public int getK();\n    public synchronized void clear();\n    public synchronized void add(byte[] bytes);\n    private int[] createHashes(byte[] bytes, int k);\n    public synchronized boolean contains(byte[] bytes);\n    public synchronized void setBit(int bit, boolean value);\n    public synchronized BitSet getBitSet();\n    public synchronized int size();\n    public synchronized int count();\n    public int getExpectedNumberOfElements();\n    public double getExpectedBitsPerElement();\n    public double getBitsPerElement();\n\n    static Random r;\n\n}\n\nclass BloomFilterTest {\n\n    static Random r;\n\n    @Test\n    public void testGetBit() {\n", "reference": "        System.out.println(\"getBit\");\n        BloomFilter instance = new BloomFilter(1000, 100);\n        Random r = new Random();\n\n        for (int i = 0; i < 100; i++) {\n            boolean b = r.nextBoolean();\n            instance.setBit(i, b);\n            assertSame(instance.getBit(i), b);\n        }\n    }\n\n}", "prediction": "        BloomFilter bf = new BloomFilter(10000, 1000, 10);\n        bf.add(new byte[]{1});\n        bf.add(new byte[]{2});\n        bf.add(new byte[]{3});\n        bf.add(new byte[]{4});\n        bf.add(new byte[]{5});\n        bf.add(new byte[]{6});\n        bf.add(new byte[]{7});\n        bf.add(new byte[]{8});\n        bf.add(new byte[]{9});\n        bf.add(new byte[]{10});\n        bf.add(new byte[]{11});\n        bf.add(new byte[]{12});\n        bf.add(new byte[]{13});\n        bf.add(new byte[]{14});\n        bf.add(new byte[]{15});\n        bf.add(new byte[]{16});\n        bf.add(new byte[]{17});\n        bf.add(new byte[]{18});\n        bf.add(new byte[]{19});\n        bf.add(new byte[]{20});\n        bf.add(new byte[]{21});\n        bf.add(new byte[]{22});\n        bf.add(new byte[]{23});\n        bf.add(new byte[]{24});\n        bf.add(new byte[]{25});\n        bf.add(new byte[]{26});\n        bf.add(new byte[]{27});\n        bf.add(new byte[]{28});\n        bf.add(new byte[]{29});\n        bf.add(new byte[]{30});\n        bf.add(new byte[]{31});\n        bf.add(new byte[]{32});\n        bf.add(new byte[]{33});\n        bf.add(new byte[]{34});\n        bf.add(new byte[]{35});\n        bf.add(new byte[]{36});\n        bf.add(new byte[]{37});\n        bf.add(new byte[]{38});\n        bf.add(new byte[]{39});\n        bf.add(new byte[]{40});\n        bf.add(new byte[]{41});\n        bf.add(new byte[]{42});\n        bf.add(new byte[]{43});\n        bf.add(new byte[]{44});\n        bf.add(new byte[]{45});\n        bf.add(new byte[]{46});\n        bf.add(new byte[]{47});\n        bf.add(new byte[]{48});\n        bf.add(new byte[]{49});\n        bf.add(new byte[]{50});\n        bf.add(new byte[]{51});\n        bf.add(new byte[]{52});\n        bf.add(new byte[]{53});\n        bf.add(new byte[]{54});\n        bf.add(new byte[]{55});\n        bf.add(new byte[]{56});\n        bf.add(new byte[]{57});\n        bf.add(new byte[]{58});\n        bf.add(new byte[]{59});\n        bf.add(new byte[]{60});\n        bf.add(new byte[]{61});\n        bf.add(new byte[]{62});\n        bf.add(new byte[]{63});\n        bf.add(new byte[]{64});\n        bf.add(new byte[]{65});\n        bf.add(new byte[]{66});\n        bf.add(new byte[]{67});\n        bf.add(new byte[]{68});\n        bf.add(new byte[]{69});\n        bf.add(new byte[]{70});\n        bf.add(new byte[]{71});\n        bf.add(new byte[]{72});\n        bf.add(new byte[]{73});\n        bf.add(new byte[]{74});\n        bf.add(new byte[]{75});\n        bf.add(new byte[]{76});\n        bf.add(new byte[]{77});\n        bf.add(new byte[]{78});\n        bf.add(new byte[]{79});\n        bf.add(new byte[]{80});\n        bf.add(new byte[]{81});\n        bf.add(new byte[]{82});\n        bf.add(new byte[]{83});\n        bf.add(new byte[]{84});\n        bf.add(new byte[]{85});\n        bf.add(new byte[]{86});\n        bf.add(new byte[]{87});\n        bf.add(new byte[]{88});\n        bf.add(new byte[]{89});\n        bf.add(new byte[]{90});\n        bf.add(new byte[]{91});\n        bf.add(new byte[]{92});\n        bf.add(new byte[]{93});\n        bf.add(new byte[]{94});\n        bf.add(new byte[]{95});\n        bf.add(new byte[]{96});\n        bf.add(new byte[]{97});\n        bf.add(new byte[]{98});\n        bf.add(new byte[]{99});\n        bf.add(new byte[]{100});\n        bf.add(new byte[]{101});\n        bf.add(new byte[]{102});\n        bf.add(new byte[]{103});\n        bf.add(new byte[]{104});\n        bf.add(new byte[]{105});\n        bf.add(new byte[]{106});\n        bf.add(new byte[]{107});\n        bf.add(new byte[]{108});\n        bf.add(new byte[]{109});\n        bf.add(new byte[]{110});\n        bf.add(new byte[]{111});\n        bf.add(new byte[]{112});\n        bf.add(new byte[]{113});\n        bf.add(new byte[]{114});\n        bf.add(new byte[]{115});\n        bf.add(new byte[]{116});\n        bf.add(new byte[]{117});\n        bf.add(new byte[]{118});\n        bf.add(new byte[]{119});\n        bf.add(new byte[]{120});\n        bf.add(new byte[]{121});\n        bf.add(new byte[]{122});\n        bf.add(new byte[]{123});\n        bf.add(new byte[]{124});\n        bf.add(new byte[]{125});\n        bf.add(new byte[]{126});\n        bf.add(new byte[]{127});\n        bf.add(new byte[]{128});\n        bf.add(new byte[]{129});\n        bf.add(new byte[]{130});\n        bf.add(new byte[]{131});\n        bf.add(new byte[]{132});\n        bf.add(new byte[]{133});\n        bf.add(new byte[]{134});\n        bf.add(new byte[]{135});\n        bf.add(new byte[]{136});\n        bf.add(new byte[]{137});\n        bf.add(new byte[]{138});\n        bf.add(new byte[]{139});\n        bf.add(new byte[]{140});\n        bf.add(new byte[]{141});\n        bf.add(new byte[]{142});\n        bf.add(new byte[]{143});\n        bf.add(new byte[]{144});\n        bf.add(new byte[]{145});\n        bf.add(new byte[]{146});\n        bf.add(new byte[]{147});\n        bf.add(new byte[]{148});\n        bf.add(new byte[]{149});\n        bf.add(new byte[]{150});\n        bf.add(new byte[]{1", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "19980663_4", "part": [1, 1], "seq": [1, 1], "prompt": "class TableManagerResource {\n\n    @GET\n    @Timed\n    @Path(\"/{name}\")\n    @ApiOperation(\"Get Table\")\n    public Response get(@PathParam(\"name\") String name) {\n        name = ElasticsearchUtils.getValidTableName(name);\n        Table table = tableManager.get(name);\n        return Response.ok()\n               .entity(table)\n               .build();\n    }\n\n    @Inject public  TableManagerResource(TableManager tableManager);\n\n    @POST @Timed @ApiOperation(\"Save Table\") public Response save(@Valid final Table table, @QueryParam(\"forceCreate\") @DefaultValue(\"false\") boolean forceCreate);\n    @PUT @Timed @Path(\"/{name}\") @ApiOperation(\"Update Table\") public Response get(@PathParam(\"name\") final String name, @Valid final Table table);\n    @DELETE @Timed @Path(\"/{name}/delete\") @ApiOperation(\"Delete Table\") public Response delete(@PathParam(\"name\") String name);\n    @GET @Timed @ApiOperation(\"Get all Tables\") public Response getAll();\n\n    @Rule\n    public ResourceTestRule resources;\n    private TableManager tableManager;\n\n}\n\nclass TableManagerResourceTest  {\n\n    @Rule\n    public ResourceTestRule resources;\n    private TableManager tableManager;\n\n    @Test\n    public void testGet() throws Exception {\n", "reference": "        doNothing().when(getDataStore())\n                .initializeTable(any(Table.class), anyBoolean());\n        doNothing().when(getQueryStore())\n                .initializeTable(any(String.class));\n\n\n        Table response = resources.client()\n                .target(String.format(\"/v1/tables/%s\", TEST_TABLE_NAME))\n                .request()\n                .get(Table.class);\n        assertNotNull(response);\n        assertEquals(TEST_TABLE_NAME, response.getName());\n        assertEquals(7, response.getTtl());\n    }\n\n}", "prediction": "        Table table = new Table();\n        table.setName(\"test\");\n        table.setColumns(Arrays.asList(new Column(\"id\", \"integer\")));\n        tableManager.save(table);\n\n        Response response = resources.target(\"/tables/test\").request().get();\n        assertEquals(200, response.getStatus());\n        Table tableResponse = response.readEntity(Table.class);\n        assertEquals(\"test\", tableResponse.getName());\n        assertEquals(1, tableResponse.getColumns().size());\n        assertEquals(\"id\", tableResponse.getColumns().get(0).getName());\n        assertEquals(\"integer\", tableResponse.getColumns().get(0).getType());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "20043683_8", "part": [1, 1], "seq": [1, 1], "prompt": "class JaxbLoader {\n\n    public static MMOs loadXml(final File xmlFile)\n            throws JAXBException, SAXException, ParserConfigurationException, FileNotFoundException {\n        final JAXBContext jaxbContext = JAXBContext.newInstance(MMOs.class);\n        final Unmarshaller jaxbUnmarshaller = jaxbContext.createUnmarshaller();\n\n        // avoid getting the DTD (was mainly for when demoing without a network, but should maybe be kept?)\n        final SAXParserFactory spf = SAXParserFactory.newInstance();\n        spf.setFeature(\"http://apache.org/xml/features/validation/schema\", false);\n        spf.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n        final XMLReader xmlReader = spf.newSAXParser().getXMLReader();\n        final InputSource inputSource = new InputSource(new FileReader(xmlFile));\n        final SAXSource source = new SAXSource(xmlReader, inputSource);\n\n        return (MMOs) jaxbUnmarshaller.unmarshal(source);\n    }\n\n    private static final File TEST_XML;\n\n}\n\nclass JaxbLoaderTest {\n\n    private static final File TEST_XML;\n\n    @Test\n    public void failToLoad() {\n", "reference": "        //noinspection OverlyBroadCatchBlock\n        try {\n            JaxbLoader.loadXml(new File(\"noSuchFile\"));\n            fail(\"We should have had an exception before now.\");\n        }\n        catch (final FileNotFoundException ignored) {\n            // do nothing\n        }\n        catch (final Throwable t) {\n            //noinspection CallToPrintStackTrace\n            t.printStackTrace();\n            fail(\"There should be no other throwables.\");\n        }\n    }\n\n}", "prediction": "        assertThrows(JAXBException.class, () -> JaxbLoader.loadXml(TEST_XML));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "20126854_34", "part": [1, 1], "seq": [1, 1], "prompt": "class BsPatch {\n\n  public static void applyPatch(\n      RandomAccessFile oldData, OutputStream newData, InputStream patchData)\n      throws PatchFormatException, IOException {\n    patchData = new BufferedInputStream(patchData, PATCH_STREAM_BUFFER_SIZE);\n    newData = new BufferedOutputStream(newData, OUTPUT_STREAM_BUFFER_SIZE);\n    try {\n      applyPatchInternal(oldData, newData, patchData);\n    } finally {\n      newData.flush();\n    }\n  }\n\n  private static void applyPatchInternal(\n      final RandomAccessFile oldData,\n      final OutputStream newData,\n      final InputStream patchData);\n  static void transformBytes(\n      final int diffLength,\n      final InputStream patchData,\n      final RandomAccessFile oldData,\n      final OutputStream newData,\n      final byte[] buffer1,\n      final byte[] buffer2);\n  static final long readBsdiffLong(InputStream in);\n  static void readFully(\n      final InputStream in, final byte[] destination, final int startAt, final int numBytes);\n  static void pipe(\n      final InputStream in, final OutputStream out, final byte[] buffer, int copyLength);\n\n  private static final String SIGNATURE;\n  private byte[] buffer1;\n  private byte[] buffer2;\n  private File oldFile;\n\n}\n\nclass BsPatchTest {\n\n  private static final String SIGNATURE;\n  private byte[] buffer1;\n  private byte[] buffer2;\n  private File oldFile;\n\n  @Test\n  public void testApplyPatch_NewLengthTooLarge() throws Exception {\n", "reference": "    createEmptyOldFile(10);\n    InputStream patchIn =\n        makePatch(\n            SIGNATURE,\n            Integer.MAX_VALUE + 1, // newLength (max supported is Integer.MAX_VALUE)\n            10, // diffSegmentLength\n            0, // copySegmentLength\n            0, // offsetToNextInput\n            new byte[10] // addends\n            );\n    ByteArrayOutputStream newData = new ByteArrayOutputStream();\n    try {\n      BsPatch.applyPatch(\n          new RandomAccessFile(oldFile, \"r\"), newData, patchIn);\n      Assert.fail(\"Read patch with excessive newLength\");\n    } catch (PatchFormatException expected) {\n      // No way to mock the internal logic, so resort to testing exception string for coverage\n      String actual = expected.getMessage();\n      Assert.assertEquals(\"bad newSize\", actual);\n    }\n  }\n\n}", "prediction": "    final File patchFile = createPatchFile(1000000000);\n    try {\n      BsPatch.applyPatch(oldFile, new ByteArrayOutputStream(), patchFile);\n      fail(\"Expected PatchFormatException\");\n    } catch (PatchFormatException e) {\n      // Expected\n    }\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "20498194_7", "part": [1, 1], "seq": [1, 1], "prompt": "class PigResource {\n\n\t@GET\n\t@Path(\"request/{requestId}/status\")\n\t@Produces( {MediaType.TEXT_PLAIN} )\n\tpublic Response getRequestStatus(@PathParam(\"requestId\") String requestId) throws IOException {\n\t\tlogger.info(\"Request for retrieving status for \" + requestId);\n\t\treturn Response.ok()\n\t\t   .entity(\n\t\t        PigJobServerImpl.getPigJobServer().getRequestStatus(requestId)\n\t\t    ).build();\n\t}\n\n\t@POST @Path(\"/jar/{jarName}\") @Consumes ( {MediaType.APPLICATION_OCTET_STREAM} ) @Produces ({MediaType.APPLICATION_JSON, MediaType.TEXT_PLAIN}) public Response registerJar(@PathParam(\"jarName\") String jarName, InputStream uploadedJar);\n\t@DELETE @Path(\"/jar/{jarName}\") @Produces ( {MediaType.TEXT_PLAIN} ) public Response unregisterJar(@PathParam(\"jarName\") String jarName);\n\t@GET @Path(\"/jar/{jarName}\") @Produces ( {MediaType.APPLICATION_OCTET_STREAM} ) public Response getRegisteredJar(@PathParam(\"jarName\") String jarName);\n\t@POST @Path(\"/script/{scriptName}\") @Consumes ( {MediaType.APPLICATION_OCTET_STREAM} ) @Produces ({MediaType.APPLICATION_JSON, MediaType.TEXT_PLAIN}) public Response registerScript(@PathParam(\"scriptName\") String scriptName, InputStream uploadedScript);\n\t@DELETE @Path(\"/script/{scriptName}\") @Produces ( {MediaType.TEXT_PLAIN} ) public Response unregisterScript(@PathParam(\"scriptName\") String scriptName);\n\t@GET @Path(\"/script/{scriptName}\") @Produces ( {MediaType.APPLICATION_OCTET_STREAM} ) public Response getRegisteredScript(@PathParam(\"scriptName\") String scriptName);\n\t@POST @Path(\"/request/{scriptName}\") @Consumes( {MediaType.APPLICATION_JSON} ) @Produces( {MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML, MediaType.TEXT_PLAIN} ) public Response submitPigJob(@PathParam(\"scriptName\") String scriptName, String data);\n\t@GET @Path(\"/request/{requestId}\") @Produces( {MediaType.APPLICATION_JSON} ) public Response getInput(@PathParam(\"requestId\") String requestId);\n\t@GET @Path(\"/request/{requestId}/stats\") @Produces( {MediaType.APPLICATION_JSON} ) public Response getRequestStats(@PathParam(\"requestId\") String requestId);\n\t@GET @Path(\"/request/{requestId}/output\") @Produces( {MediaType.TEXT_PLAIN} ) public Response getOutput(@PathParam(\"requestId\") String requestId);\n\t@GET @Path(\"request/{requestId}/cancel\") @Produces( {MediaType.TEXT_PLAIN} ) public Response cancelRequest(@PathParam(\"requestId\") String requestId);\n\n    private static final String HADOOP_TMP_PATH;\n    private Configuration conf;\n    private FileSystem fileSystem;\n\n}\n\nclass TestPigResource {\n\n    private static final String HADOOP_TMP_PATH;\n    private Configuration conf;\n    private FileSystem fileSystem;\n\n    @Test \n    public void testGetStatus() throws Exception {\n", "reference": "    \tPigResource resource= new PigResource();\n    \tPigRequestStats stats= new PigRequestStats(15, 14, null, 5);\n    \tstats.setStatus(\"STATUS\");\n    \t\n    \tString requestId= UUID.randomUUID().toString();\n    \tString path= PropertyLoader.getInstance().getProperty(\"requests.basepath\") + requestId \n    \t\t\t+ \"/stats\";\n    \t\n    \tPigUtils.writeStatsFile(new Path(path), stats);\n    \tResponse resp=  resource.getRequestStatus(requestId);\n    \tAssert.assertEquals(resp.getStatus(), 200);\n    \t\n    \trequestId= \"abc\";\n    \ttry {\n    \t\tresp=  resource.getRequestStatus(requestId);\n    \t} catch (Exception e) {\n    \t\tAssert.assertNotNull(resp);\n    \t}\n    \t\n    \trequestId= UUID.randomUUID().toString();\n    \tfileSystem.mkdirs(new Path(PropertyLoader.getInstance().getProperty(\"requests.basepath\") + requestId));\n    \ttry {\n    \t\tresp=  resource.getRequestStatus(requestId);\n    \t} catch (Exception e) {\n    \t\tAssert.assertNotNull(e);\n    \t}\n    }\n\n}", "prediction": "\tPigResource resource = new PigResource();\n\tResponse response = resource.getRequestStatus(\"12345\");\n\tassertEquals(200, response.getStatus());\n\tassertEquals(\"OK\", response.getEntity());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "20521495_26", "part": [1, 1], "seq": [1, 1], "prompt": "class SolrOperationsService {\n\n    public void createCore(StratioStreamingMessage message) throws IOException, URISyntaxException, SolrServerException, ParserConfigurationException, SAXException, TransformerException, InterruptedException {\n        String core = message.getStreamName();\n        String dataPath = this.dataDir + '/' + core + \"/data\";\n        String confPath = this.dataDir + '/' + core + \"/conf\";\n        createDirs(dataPath, confPath);\n        createSolrConfig(confPath);\n        createSolrSchema(message.getColumns(), confPath);\n        SolrClient solrClient = getSolrclient(core);\n        CoreAdminRequest.Create createCore = new CoreAdminRequest.Create();\n        createCore.setDataDir(dataPath);\n        createCore.setInstanceDir(dataDir + '/' + core);\n        createCore.setCoreName(core);\n        createCore.setSchemaName(\"schema.xml\");\n        createCore.setConfigName(\"solrconfig.xml\");\n        if (solrClient instanceof CloudSolrClient) {\n            ((CloudSolrClient)solrClient).uploadConfig(Paths.get(confPath), core);\n        }\n        solrClient.request(createCore);\n    }\n\n    public  SolrOperationsService(String solrHosts, String zkHosts, String dataDir, Boolean isCloud);\n\n    public void createDirs(String dataPath, String confPath);\n    public void createSolrConfig(String confPath);\n    public void createSolrSchema(List<ColumnNameTypeValue> columns, String confpath);\n    private String streamingToSolr(ColumnType column);\n    public List<String> getCoreList();\n    private SolrClient getSolrclient(String core);\n\n    private static final Logger LOGGER;\n    private SolrOperationsService service;\n    private static final String HOSTS;\n    private static final Boolean IS_CLOUD;\n    @Rule\n    public TemporaryFolder DATA_FOLDER;\n    @Rule\n    public TemporaryFolder CONF_FOLDER;\n\n}\n\nclass SolrOperationsServiceTest {\n\n    private static final Logger LOGGER;\n    private SolrOperationsService service;\n    private static final String HOSTS;\n    private static final Boolean IS_CLOUD;\n    @Rule\n    public TemporaryFolder DATA_FOLDER;\n    @Rule\n    public TemporaryFolder CONF_FOLDER;\n\n    @Test\n    @Ignore\n    public void testCreateCore() throws Exception {\n", "reference": "\n        StratioStreamingMessage message= new StratioStreamingMessage(\n                    StreamsHelper.STREAM_NAME, Long.parseLong(\"1234567890\"), StreamsHelper.COLUMNS);\n            service.createCore(message);\n    }\n\n}", "prediction": "        StratioStreamingMessage message = new StratioStreamingMessage();\n        message.setStreamName(\"test\");\n        message.setColumns(Arrays.asList(new ColumnNameTypeValue(\"id\", \"string\"), new ColumnNameTypeValue(\"name\", \"string\")));\n        service.createCore(message);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "20551894_10", "part": [1, 1], "seq": [1, 1], "prompt": "class CDAHelper {\n\n\tpublic static   II buildTemplateID(String root, String extension,String assigningAuthorityName)\n\t{\n\n\t\t\tII templateID = DatatypesFactory.eINSTANCE.createII();\n\t\t\tif(root!=null)\n\t\t\t{\n\t\t\ttemplateID.setRoot(root);\n\t\t\t}\n\t\t\tif(extension!=null)\n\t\t\t{\n\t\t\ttemplateID.setExtension(extension);\n\t\t\t}\n\t\t\tif(assigningAuthorityName!=null)\n\t\t\t{\n\t\t\ttemplateID.setAssigningAuthorityName(assigningAuthorityName);\n\t\t\t}\n\t\t\t\n\t\t\treturn templateID;\n\n\t}\n\n\tpublic static SimpleDateFormat getDateFormat();\n\tpublic static IVL_TS buildEffectiveTimeinIVL(Date d, Date d1);\n\tpublic static IVL_TS buildEffectiveTimeinIVL(Date d);\n\tpublic static ST buildTitle(String title);\n\tpublic static II buildID(String root, String extension);\n\tpublic static CE buildCodeCE(String code, String codeSystem, String displayString, String codeSystemName);\n\tpublic static CD buildCodeCD(String code, String codeSystem, String displayString, String codeSystemName);\n\tpublic static TS buildEffectiveTime(Date d);\n\tpublic static ED buildEDText(String value);\n\tpublic static String getDatatypesValue(Integer datatypeId,Obs obs);\n\tpublic static Obs getLatestObs(List<Obs> observationList);\n\tpublic static CS getStatusCode(String statusCode);\n\tpublic static IVL_TS buildDateTime(Date date);\n\tpublic static String getCodeSystemByName(String codeSystemName);\n\tpublic static String removeDirtyValue(String input);\n\tpublic static String getUnitsaccordingto_Tf_PCC(String unit);\n\tpublic static String getConceptIdasString(int conceptId);\n\n}\n\nclass CDAHelperTest  {\n\n\t@Test\n\tpublic void shouldCreateTemplateIDIfParametersareNull()\n\t{\n", "reference": "\t\tII templateid=CDAHelper.buildTemplateID(null, null, null);\n\t\t\n\t\tString root=templateid.getRoot();\n\t\tString extension=templateid.getExtension();\n\t\tString authority=templateid.getAssigningAuthorityName();\n\t\t\n\t\tAssert.assertEquals(root, null);\n\t\tAssert.assertEquals(extension, null);\n\t\tAssert.assertEquals(authority, null);\n\t}\n\n}", "prediction": "\tII templateID = CDAHelper.buildTemplateID(null, null, null);\n\tAssert.assertNotNull(templateID);\n\tAssert.assertNull(templateID.getRoot());\n\tAssert.assertNull(templateID.getExtension());\n\tAssert.assertNull(templateID.getAssigningAuthorityName());\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "20570214_46", "part": [1, 1], "seq": [1, 1], "prompt": "class JwtValidator {\n\n  Jwt validate(String algorithm, ToBeSignedJwt target)\n      throws InvalidAlgorithmParameterException, JwtExpiredException, JwtNotBeforeException,\n          JwtInvalidException {\n    validateTimestampClaims(target);\n\n    if (!target.getAlgorithm().equals(algorithm)) {\n      throw new InvalidAlgorithmParameterException(\n          String.format(\n              \"invalid algorithm; expected %s, got %s\", algorithm, target.getAlgorithm()));\n    }\n\n    @SuppressWarnings(\"unchecked\") // keys() returns Iterator, not Iterator<String>\n    Iterator<String> headerIterator = this.header.keys();\n    while (headerIterator.hasNext()) {\n      String name = headerIterator.next();\n      if (name.equals(JwtNames.HEADER_ALGORITHM)) {\n        continue;\n      }\n      String value = target.getHeader(name);\n      if (value == null ||!value.equals(this.getHeader(name))) {\n        throw new JwtInvalidException(\n            String.format(\n                \"invalid JWT; expected header '%s' with value %s, but got %s\",\n                name, value, this.getHeader(name)));\n      }\n    }\n\n    @SuppressWarnings(\"unchecked\") // keys() returns Iterator, not Iterator<String>\n    Iterator<String> payloadIterator = this.payload.keys();\n    while (payloadIterator.hasNext()) {\n      String name = payloadIterator.next();\n      if (name.equals(JwtNames.CLAIM_AUDIENCE)) {\n        // This is checked below.\n        continue;\n      }\n      Object value = target.getClaim(name);\n      if (value == null ||!value.equals(this.getClaim(name))) {\n        throw new JwtInvalidException(\n            String.format(\n                \"invalid JWT; expected claim '%s' with value %s, but got %s\",\n                name, value, this.getClaim(name)));\n      }\n    }\n\n    // Check that the validator's audience is in the list of claimed audiences.\n    List<String> audiences = target.getAudiences();\n    String audience = (String) this.getClaim(JwtNames.CLAIM_AUDIENCE);\n    if ((audiences == null && audience!= null)\n        || (audiences!= null &&!audiences.contains(audience))) {\n      throw new JwtInvalidException(\n          String.format(\n              \"invalid JWT; cannot find the expected audience %s in claimed audiences %s\",\n              audience, audiences));\n    }\n\n    return new Jwt(target.getHeader(), target.getPayload(), this.clock, this.clockSkew);\n  }\n\n  private  JwtValidator(Builder builder);\n\n  private String getHeader(String name);\n  private Object getClaim(String name);\n   Clock getClock();\n   Duration getClockSkew();\n  private void validateTimestampClaims(ToBeSignedJwt target);\n\n}\n\nclass JwtValidatorTest {\n\n  @Test\n  public void validate_notExpired_success() throws Exception {\n", "reference": "    String algo = \"HS256\";\n    Clock clock = Clock.systemUTC();\n    // This token expires in 1 minute in the future.\n    Instant expiration = clock.instant().plus(Duration.ofMinutes(1));\n    ToBeSignedJwt unverified =\n        new ToBeSignedJwt.Builder().setAlgorithm(algo).setExpiration(expiration).build();\n    JwtValidator validator = new JwtValidator.Builder().build();\n    Jwt token = validator.validate(algo, unverified);\n\n    assertThat(token.getExpiration().getEpochSecond()).isEqualTo(expiration.getEpochSecond());\n  }\n\n}", "prediction": "    Jwt jwt =\n        new Jwt(\n            new JwtHeader(),\n            new JwtPayload(\n                new Date(),\n                new Date(System.currentTimeMillis() + 1000),\n                new Date(System.currentTimeMillis() + 10000),\n                new Date(System.currentTimeMillis() + 100000),\n                \"test\"),\n            Clock.fixed(new Date(System.currentTimeMillis() + 100000), ZoneOffset.UTC),\n            Duration.ofSeconds(10));\n    JwtValidator validator = new JwtValidator(new JwtValidator.Builder());\n    validator.validate(\"HS256\", jwt);\n  }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "21187043_1", "part": [1, 1], "seq": [1, 1], "prompt": "class Helper {\n\n    public void validate(List<VersionModule> modules) {\n        if (modules == null || modules.isEmpty()) {\n            throw new IllegalArgumentException(\"No modules found.\");\n        }\n        for (VersionModule module : modules) {\n            if (!Utils.hasAnnotatedMethods(module.getClass(), VersionCode.class)) {\n                throw new IllegalArgumentException(\"No annotated method found.\");\n            }\n        }\n    }\n\n      Helper(Application application);\n\n    public void execute(int baseVersion, List<VersionModule> modules);\n     void execute(int baseVersion, VersionModule module, List<Method> methods);\n\n    private Helper mHelper;\n\n}\n\nclass HelperTest {\n\n    private Helper mHelper;\n\n    @Test(expected = IllegalArgumentException.class)\n    public void validationFailure_null() throws Exception {\n", "reference": "        mHelper.validate(null);\n    }\n\n}", "prediction": "        mHelper.validate(null);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "21267129_1", "part": [1, 1], "seq": [1, 1], "prompt": "class RandomStringUtils {\n\n    public static String random(int length) {\n        return new RandomStringGenerator.Builder()\n               .filteredBy(NUMBERS, LETTERS)\n               .build().generate(length);\n    }\n\n    private  RandomStringUtils();\n\n    public static String randomLetters(int length);\n    public static String randomNumeric(int length);\n\n    @SuppressWarnings(\"unused\")\n    private final static Logger LOGGER;\n\n}\n\nclass RandomStringUtilsTest {\n\n    @SuppressWarnings(\"unused\")\n    private final static Logger LOGGER;\n\n    @Test\n    public void testRandom() {\n", "reference": "        for (int length = 1; length < 10; length++) {\n            String value = RandomStringUtils.random(length);\n            //LOGGER.debug( \"random alphanumeric string: \" + value );\n\n            Assert.assertEquals(\n                    \"random string has a length of \" + length,\n                    length, value.length());\n\n            Assert.assertTrue(\n                    \"random string is alphanumeric\",\n                    isAsciiAlphanumeric(value));\n        }\n    }\n\n}", "prediction": "        for (int i = 0; i < 100; i++) {\n            String random = RandomStringUtils.random(10);\n            Assert.assertEquals(10, random.length());\n        }\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "21427154_1", "part": [1, 1], "seq": [1, 1], "prompt": "class ManagementClient implements Closeable {\n\n    static String formatIP(String ip) {\n        //it appears some system can return a binding with the zone specifier on the end\n        if (ip.contains(\":\") && ip.contains(\"%\")) {\n            ip = ip.split(\"%\")[0];\n        }\n        if (ip.equals(\"0.0.0.0\")) {\n            logger.debug(\"WildFly is bound to 0.0.0.0 which is correct, setting client to 127.0.0.1\");\n            ip = \"127.0.0.1\";\n        }\n        return ip;\n    }\n\n    public  ManagementClient(ModelControllerClient client, final String mgmtAddress, final int managementPort, final String protocol);\n    public  ManagementClient(ModelControllerClient client, final CommonContainerConfiguration config);\n\n    public ModelControllerClient getControllerClient();\n     void reset();\n    private void init();\n    public URI getWebUri();\n    public ProtocolMetaData getProtocolMetaData(String deploymentName);\n    public boolean isServerInRunningState();\n    public boolean isClosed();\n    @Override public void close();\n    private static ModelNode defined(final ModelNode node, final String message);\n    private URI getBinding(final String protocol, final String socketBinding);\n    private boolean isEnterpriseArchive(String deploymentName);\n    private boolean isWebArchive(String deploymentName);\n    private void extractEnterpriseArchiveContexts(HTTPContext context, ModelNode deploymentNode);\n    private void extractWebArchiveContexts(HTTPContext context, ModelNode deploymentNode);\n    private String toContextName(String deploymentName);\n    private ModelNode executeForResult(final ModelNode operation);\n    private ModelNode readDeploymentNode(final String deploymentName);\n    private void checkSuccessful(final ModelNode result,\n                                 final ModelNode operation);\n    private MBeanServerConnection getConnection();\n    public JMXServiceURL getRemoteJMXURL();\n    public int getMgmtPort();\n    public String getMgmtAddress();\n    public String getMgmtProtocol();\n    public URI getRemoteEjbURL();\n    private void checkState();\n\n}\n\nclass ManagementClientTest {\n\n    @Test\n    public void shouldParseLocalIPAsNormalIP() {\n", "reference": "        String sourceIp = \"10.1.2.3\";\n        String formattedIp = ManagementClient.formatIP(sourceIp);\n        Assert.assertEquals(sourceIp, formattedIp);\n    }\n\n}", "prediction": "        String ip = ManagementClient.formatIP(\"127.0.0.1%eth0\");\n        assertEquals(\"127.0.0.1\", ip);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "21859706_0", "part": [1, 1], "seq": [1, 1], "prompt": "class MemcachedResponseStore extends ResponseStore {\n\n    @Override\n    public void invalidate(String key) {\n        checkNotNull(key);\n        checkArgument(key.length() > 0, \"key can not be empty\");\n\n        if (!_readOnly) {\n            _client.delete(buildKey(key));\n        }\n    }\n\n    public  MemcachedResponseStore(MemcachedClient client, String keyPrefix, boolean readOnly);\n\n    @Override public Optional<CachedResponse> get(String key);\n    @Override public void put(String key, CachedResponse response);\n    private String buildKey(String key);\n\n}\n\nclass MemcachedResponseStoreTest {\n\n    @Test(dataProvider = \"invalidateData\")\n    public void invalidate(String prefix, boolean readOnly, String key, String memcacheKey) {\n", "reference": "        MemcachedClient client = mock(MemcachedClient.class);\n        MemcachedResponseStore store = new MemcachedResponseStore(client, prefix, readOnly);\n        store.invalidate(key);\n\n        if (!readOnly) {\n            verify(client).delete(memcacheKey);\n        }\n\n        verifyNoMoreInteractions(client);\n    }\n\n}", "prediction": "        MemcachedClient client = mock(MemcachedClient.class);\n        MemcachedResponseStore store = new MemcachedResponseStore(client, prefix, readOnly);\n\n        store.invalidate(key);\n\n        verify(client).delete(memcacheKey);\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "22256861_268", "part": [1, 1], "seq": [1, 1], "prompt": "class LandsatTypeInfo {\n\n    static boolean isLandsat5Legacy(String fileName) {\n        return LandsatType.LANDSAT5_LEGACY.matchesFileNamepattern(fileName);\n    }\n\n    private  LandsatTypeInfo();\n\n    public static boolean isLandsat(String fileName);\n    public static boolean isLandsatL2(String fileName);\n    static boolean isLandsatCollection(String fileName);\n    static boolean isESALandsatCollection(String fileName);\n    static boolean isMss(String fileName);\n    static boolean isLandsat4(String fileName);\n    static boolean isLandsat5(String fileName);\n    static boolean isLandsat7Legacy(String fileName);\n    static boolean isLandsat7(String fileName);\n    static boolean isLandsat8(String fileName);\n    public static boolean isLandsatLevel2(String fileName);\n    private static String getCompressionExtension();\n    private static String getTxtExtension();\n    private static String getXmlExtension();\n\n}\n\nclass LandsatTypeInfoTest {\n\n    @Test\n    public void testIsLandsat5LegacyFilename() throws Exception {\n", "reference": "        assertTrue(LandsatTypeInfo.isLandsat5Legacy(\"LT51960300302003GSI01_MTL.txt\")); //according to specification\n        assertTrue(LandsatTypeInfo.isLandsat5Legacy(\"LT51960300302003GSI01_MTL.TXT\"));\n\n        assertTrue(LandsatTypeInfo.isLandsat5Legacy(\"L5196030_03020031023_MTL.txt\")); //according to real-world data\n        assertTrue(LandsatTypeInfo.isLandsat5Legacy(\"L5196030_03020031023_MTL.TXT\"));\n\n        assertTrue(LandsatTypeInfo.isLandsat5Legacy(\"LT51960302003296MTI01.tar.gz\"));\n\n        assertFalse(LandsatTypeInfo.isLandsat5Legacy(\"L51950302003257MTI01.tar.gz\"));  // Sensor type missing\n        assertFalse(LandsatTypeInfo.isLandsat5Legacy(\"LT72160332013191LGN00.tar.gz\")); // '5' expected after 'LT'\n        assertFalse(LandsatTypeInfo.isLandsat5Legacy(\"LT82160332013191LGN00.tgz\")); // 'tar.gz' or 'txt' expected as extension\n        assertFalse(LandsatTypeInfo.isLandsat5Legacy(\"LT82160332013191LGN00.dat\")); // 'tar.gz' or 'txt' expected as extension\n    }\n\n}", "prediction": "        assertTrue(LandsatTypeInfo.isLandsat5Legacy(\"LT50120122552248ACSM00.tar\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "22430702_6", "part": [1, 1], "seq": [1, 1], "prompt": "class VertexListStreamWriter implements AutoCloseable {\n\n\tpublic void writeAll() throws IOException {\n\t\twhile (inputStream.hasNextVertex()) {\n\t\t\twriteNextVertex();\n\t\t}\n\t\toutputWriter.flush();\n\t}\n\n\tpublic  VertexListStreamWriter(VertexListStream inputStream, OutputStream outputStream);\n\n\tprivate void writeNextVertex();\n\t@Override public void close();\n\n\tprivate static final VertexListStream.VertexData[] vertices;\n\tprivate static final String expectedOutput;\n\n}\n\nclass VertexListStreamWriterTest {\n\n\tprivate static final VertexListStream.VertexData[] vertices;\n\tprivate static final String expectedOutput;\n\n\t@Test\n\tpublic void testWriteAllOnMockVertexListStream() throws IOException {\n", "reference": "\t\tVertexListStream vertexListStream = new MockVertexListStream(vertices);\n\t\tByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n\n\t\ttry (VertexListStreamWriter writer = new VertexListStreamWriter(vertexListStream, outputStream)) {\n\t\t\twriter.writeAll();\n\t\t\tassertEquals(\"Output of VertexListStreamWriter is correct\", expectedOutput, outputStream.toString());\n\t\t}\n\t}\n\n}", "prediction": "\t\tVertexListStream mockVertexListStream = mock(VertexListStream.class);\n\t\twhen(mockVertexListStream.hasNextVertex()).thenReturn(true, true, true, false);\n\t\twhen(mockVertexListStream.nextVertex()).thenReturn(vertices[0], vertices[1], vertices[2]);\n\n\t\tByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n\t\tVertexListStreamWriter vertexListStreamWriter = new VertexListStreamWriter(mockVertexListStream, outputStream);\n\t\tvertexListStreamWriter.writeAll();\n\n\t\tassertEquals(expectedOutput, outputStream.toString());\n\t}", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "22441114_3", "part": [1, 1], "seq": [1, 1], "prompt": "class Aether {\n\n    protected AetherResult resolveWithTransitives(Artifact artifact) throws AetherException {\n        try {\n            CollectRequest collectRequest = new CollectRequest(\n                    new Dependency(artifact, scope),\n                    repositories()\n            );\n\n            DependencyRequest request = new DependencyRequest(collectRequest, null);\n            return new AetherResult(system.resolveDependencies(session, request).getArtifactResults());\n        } catch (DependencyResolutionException e) {\n            throw new AetherException(\"Can't resolve given artifact \" + artifact, e);\n        }\n    }\n\n      Aether(File localRepoDir, Settings settings);\n      Aether(RepositorySystem system, RepositorySystemSession session, List<RemoteRepository> repositories);\n\n    public static Aether aether(File localRepoDir);\n    public static Aether aether(File localRepoDir, Settings settings);\n    public static Aether aether(Settings settings);\n    public static Aether aether(RepositorySystem system, RepositorySystemSession session, List<RemoteRepository> repositories);\n    public Aether scope(String scope);\n    public AetherResult resolve(String artifactCoordinates);\n    public AetherResult resolve(Artifact artifact);\n    public AetherResult resolve(String artifactCoordinates, boolean withTransitives);\n    public AetherResult resolve(Artifact artifact, boolean withTransitives);\n    public AetherResult resolveAll(String... artifactsCoordinates);\n    public AetherResult resolveAll(Artifact... artifacts);\n    protected AetherResult resolveWithoutTransitives(Artifact... artifacts);\n    protected List<ArtifactRequest> buildArtifactRequests(Artifact... artifacts);\n    public List<Artifact> collect(String artifactCoordinates);\n    public List<Artifact> collect(Artifact artifact);\n    public void install(File jar, String groupId, String artifactId, String version);\n    public void install(File jar, String groupId, String artifactId, String extension, String version);\n    public void install(File jar, String groupId, String artifactId, String classifier, String extension, String version);\n    public void install(File jar, File pom, String groupId, String artifactId, String classifier, String extension, String version);\n    public void install(Artifact... artifacts);\n    public void deploy(DistributionManagement distribution, File jar, String groupId, String artifactId, String version);\n    public void deploy(DistributionManagement distribution, File jar, String groupId, String artifactId,\n                       String extension, String version);\n    public void deploy(DistributionManagement distribution, File jar, String groupId, String artifactId,\n                       String classifier, String extension, String version);\n    public void deploy(DistributionManagement distribution, File jar, File pom, String groupId, String artifactId,\n                       String classifier, String extension, String version);\n    public void deploy(DistributionManagement distribution, Artifact... artifacts);\n    protected File createPomFile(String groupId, String artifactId, String version);\n    protected List<RemoteRepository> repositories();\n\n}\n\nclass AetherTest  {\n\n    @Test\n    public void resolveWithTransitivesTest() throws Exception {\n", "reference": "        List<ArtifactResult> results = aether(localRepo, mavenSettings)\n                .resolve(ALLURE_MODEL).get();\n\n        assertThat(results.size(), is(5));\n    }\n\n}", "prediction": "        Aether aether = Aether.aether(new File(\"target/test-repo\"));\n        AetherResult result = aether.resolve(\"org.apache.maven:maven-core:3.0.4\");\n        assertThat(result.getArtifacts().size(), is(1));\n        assertThat(result.getArtifacts().get(0).getArtifactId(), is(\"maven-core\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "22460817_0", "part": [1, 1], "seq": [1, 1], "prompt": "class Str {\n\n    public static String trim(String s) {\n        if (s == null)\n            return null;\n        s = s.trim();\n        return s.length() > 0? s : null;\n    }\n\n    public static String group(String text, String regexp);\n    public static String group(String text, String regexp, int group);\n    public static Pair<String, String> groups(String text, String regexp, int group1, int group2);\n    public static boolean containsSpaces(String... strings);\n    public static String lower(String s);\n    public static String upper(String s);\n\n}\n\nclass StrTest {\n\n    @Test\n    public void trim() {\n", "reference": "        assertNull(Str.trim(null));\n        assertNull(Str.trim(\"\"));\n        assertNull(Str.trim(\" \"));\n        assertNull(Str.trim(\" \\t\\n \"));\n        assertNotNull(Str.trim(\".\"));\n        assertNotNull(Str.trim(\" . \"));\n    }\n\n}", "prediction": "        assertEquals(\"abc\", Str.trim(\" abc \"));\n        assertEquals(\"abc\", Str.trim(\"abc\"));\n        assertEquals(null, Str.trim(null));\n        assertEquals(\"\", Str.trim(\"\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "23086156_28", "part": [1, 1], "seq": [1, 1], "prompt": "class InMemoryFactory {\n\n\tpublic URL createInMemoryResource(String resource) throws MalformedURLException\n\t{\n\t\tString content = resource.replace('\\\\', '/');\n\t\treturn url(content);\n\t}\n\n\tpublic  InMemoryFactory();\n\n\tpublic URL createInMemoryClass(Class<?> claSs);\n\tprivate URL url(String content);\n\tprotected void assertElementName(String name);\n\n     InMemoryFactory underTest;\n\n}\n\nclass InMemoryFactoryTest {\n\n     InMemoryFactory underTest;\n\n    @Test(/*expected=IllegalArgumentException.class*/)\n    public void testCreateInMemoryResourceError()\n    {\n", "reference": "        try\n        {\n            String resource = \"data\\\\stuf\\\\content.properties\";\n\n            URL createInMemoryResource = underTest.createInMemoryResource(resource);\n            createInMemoryResource.toExternalForm();\n        } catch (MalformedURLException e)\n        {\n            fail(\"No exception should occu\");\n        }\n    }\n\n}", "prediction": "        underTest.createInMemoryResource(\"test.txt\");\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "23237318_30", "part": [1, 1], "seq": [1, 1], "prompt": "class ErrorHandler {\n\n    public boolean hasTooManyErrors(BaseTask.StreamMetrics metrics) {\n        long msgsDone = metrics.processed.getCount() + metrics.dropped.getCount();\n        if (msgsDone > 100L) {\n            double dropRate = metrics.dropped.getOneMinuteRate();\n            double successRate = metrics.processed.getOneMinuteRate();\n            if (dropRate > 0.0) {\n                double totalRate = dropRate + successRate;\n                double dropRatio = dropRate/totalRate;\n                if (logger.isTraceEnabled()) {\n                    logger.trace(String.format(\"Drop rate: %f msg/s, success rate %f msg/s, total rate %f msg/s, drop ratio %f, max drop ratio %f\",\n                            dropRate, successRate, totalRate, dropRatio, dropMaxRatio));\n                }\n                if (dropRatio > dropMaxRatio) {\n                    logger.error(String.format(\"Error ratio (1min avg) %2f has exceeded threshold %f.\", dropRatio, dropMaxRatio));\n                    return true;\n                }\n            }\n            else {\n                logger.trace(\"Drop rate is still 0.0\");\n            }\n        }\n        return false;\n    }\n\n    public  ErrorHandler(Config config, TaskInfo taskInfo);\n\n    public void start();\n    public boolean dropOnError();\n    public double getDropMaxRatio();\n    private void logDroppedMsgConfig();\n    private SystemProducer getSystemProducer(Config config);\n    public void handleException(IncomingMessageEnvelope envelope, Exception e, BaseTask.StreamMetrics metrics);\n    public void handleExpectedError(IncomingMessageEnvelope envelope, Exception e, BaseTask.StreamMetrics metrics);\n    private void handleDroppedMessage(IncomingMessageEnvelope envelope, Exception e, Meter dropped);\n    private byte[] serializeDroppedMessage(IncomingMessageEnvelope envelope, Exception e);\n    public void stop();\n\n    private final Clock clock;\n\n}\n\nclass ErrorHandlerTest {\n\n    private final Clock clock;\n\n    @Test\n    public void testNotTooManyErrors() throws Exception {\n", "reference": "        ErrorHandler errHandler = getErrorHandler();\n        BaseTask.StreamMetrics metrics = new BaseTask.StreamMetrics(new Meter(clock), new Meter(clock));\n\n        when(clock.getTick()).thenReturn(0L);\n        metrics.processed.mark(910L);\n        metrics.dropped.mark(90L);\n\n        when(clock.getTick()).thenReturn(TimeUnit.SECONDS.toNanos(10));\n        assertTrue(metrics.processed.getOneMinuteRate() > 0);\n        assertTrue(metrics.dropped.getOneMinuteRate() > 0);\n        assertFalse(errHandler.hasTooManyErrors(metrics));\n    }\n\n}", "prediction": "        Config config = new Config();\n        config.put(Config.TASK_ERROR_MAX_RATIO, 0.0);\n        ErrorHandler errorHandler = new ErrorHandler(config, null);\n        BaseTask.StreamMetrics metrics = new BaseTask.StreamMetrics(clock);\n        metrics.processed.mark();\n        assertFalse(errorHandler.hasTooManyErrors(metrics));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "23310687_6", "part": [1, 1], "seq": [1, 1], "prompt": "class UBL22DocumentTypes {\n\n  @Nonnull\n  @ReturnsMutableCopy\n  public static ICommonsSet <String> getAllNamespaces ()\n  {\n    return s_aNamespace2DocType.copyOfKeySet ();\n  }\n\n  private  UBL22DocumentTypes();\n\n  @Nullable public static EUBL22DocumentType getDocumentTypeOfNamespace(@Nullable final String sNamespace);\n  @Nullable public static Class <?> getImplementationClassOfNamespace(@Nullable final String sNamespace);\n  @Nullable public static EUBL22DocumentType getDocumentTypeOfImplementationClass(@Nullable final Class <?> aImplClass);\n  @Nullable public static Schema getSchemaOfNamespace(@Nullable final String sNamespace);\n  @Nonnull @ReturnsMutableCopy public static ICommonsSet <String> getAllLocalNames();\n  @Nullable public static EUBL22DocumentType getDocumentTypeOfLocalName(@Nullable final String sLocalName);\n  @Nullable public static Class <?> getImplementationClassOfLocalName(@Nullable final String sLocalName);\n  @Nullable public static Schema getSchemaOfLocalName(@Nullable final String sLocalName);\n  @Nullable public static Schema getSchemaOfImplementationClass(@Nullable final Class <?> aImplClass);\n\n}\n\nclass UBL22DocumentTypesTest {\n\n  @Test\n  public void testGetAllNamespaces ()\n  {\n", "reference": "    assertNotNull (UBL22DocumentTypes.getAllNamespaces ());\n    assertNotNull (UBL22DocumentTypes.getAllLocalNames ());\n    assertEquals (UBL22DocumentTypes.getAllNamespaces ().size (), UBL22DocumentTypes.getAllLocalNames ().size ());\n\n    for (final String sNamespace : UBL22DocumentTypes.getAllNamespaces ())\n    {\n      assertNotNull (UBL22DocumentTypes.getDocumentTypeOfNamespace (sNamespace));\n      assertNotNull (UBL22DocumentTypes.getImplementationClassOfNamespace (sNamespace));\n      assertNotNull (UBL22DocumentTypes.getSchemaOfNamespace (sNamespace));\n    }\n    assertNull (UBL22DocumentTypes.getDocumentTypeOfNamespace (\"any\"));\n    assertNull (UBL22DocumentTypes.getImplementationClassOfNamespace (\"any\"));\n    assertNull (UBL22DocumentTypes.getSchemaOfNamespace (\"any\"));\n    assertNull (UBL22DocumentTypes.getDocumentTypeOfNamespace (null));\n    assertNull (UBL22DocumentTypes.getImplementationClassOfNamespace (null));\n    assertNull (UBL22DocumentTypes.getSchemaOfNamespace (null));\n\n    for (final String sNamespace : UBL22DocumentTypes.getAllLocalNames ())\n    {\n      assertNotNull (UBL22DocumentTypes.getDocumentTypeOfLocalName (sNamespace));\n      assertNotNull (UBL22DocumentTypes.getImplementationClassOfLocalName (sNamespace));\n      assertNotNull (UBL22DocumentTypes.getSchemaOfLocalName (sNamespace));\n    }\n    assertNull (UBL22DocumentTypes.getDocumentTypeOfLocalName (\"any\"));\n    assertNull (UBL22DocumentTypes.getImplementationClassOfLocalName (\"any\"));\n    assertNull (UBL22DocumentTypes.getSchemaOfLocalName (\"any\"));\n    assertNull (UBL22DocumentTypes.getDocumentTypeOfLocalName (null));\n    assertNull (UBL22DocumentTypes.getImplementationClassOfLocalName (null));\n    assertNull (UBL22DocumentTypes.getSchemaOfLocalName (null));\n  }\n\n}", "prediction": "    final ICommonsSet <String> aAllNamespaces = UBL22DocumentTypes.getAllNamespaces ();\n    Assert.assertNotNull (aAllNamespaces);\n    Assert.assertEquals (10, aAllNamespaces.size ());\n    Assert.assertTrue (aAllNamespaces.contains (\"urn:oasis:names:specification:ubl:schema:xsd:CommonAggregateComponents-2\"));\n    Assert.assertTrue (aAllNamespaces.contains (\"urn:oasis:names:specification:ubl:schema:xsd:CommonBasicComponents-2\"));\n    Assert.assertTrue (aAllNamespaces.contains (\"urn:oasis:names:specification:ubl:schema:xsd:CommonExtensionComponents-2\"));\n    Assert.assertTrue (aAllNamespaces.contains (\"urn:oasis:names:specification:ubl:schema:xsd:CommonExtensionComponents-2\"));\n    Assert.assertTrue (aAllNamespaces.contains (\"urn:oasis:names:specification:ubl:schema:xsd:CommonExtensionComponents-2\"));\n    Assert.assertTrue (aAllNamespaces.contains (\"urn:oasis:names:specification:ubl:schema:xsd:CommonExtensionComponents-2\"));\n    Assert.assertTrue (aAllNamespaces.contains (\"urn:oasis:names:specification:ubl:schema:xsd:CommonExtensionComponents-2\"));\n    Assert.assertTrue (aAllNamespaces.contains (\"urn:oasis:names:specification:ubl:schema:xsd:CommonExtensionComponents-2\"));\n    Assert.assertTrue (aAllNamespaces.contains (\"urn:oasis:names:specification:ubl:schema:xsd:CommonExtensionComponents-2\"));\n    Assert.assertTrue (aAllNamespaces.contains (\"urn:oasis:names:specification:ubl:schema:xsd:CommonExtensionComponents-2\"));\n  }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "23330642_0", "part": [1, 1], "seq": [1, 1], "prompt": "class Main extends MainSupport {\n\n    @Override\n    protected Map<String, CamelContext> getCamelContextMap() {\n        BeanManager manager = container.getBeanManager();\n        return manager.getBeans(CamelContext.class, Any.Literal.INSTANCE).stream()\n           .map(bean -> getReference(manager, CamelContext.class, bean))\n           .collect(toMap(CamelContext::getName, identity()));\n    }\n\n    public static void main(String... args);\n    public static Main getInstance();\n    @Override protected ProducerTemplate findOrCreateCamelTemplate();\n    @Override protected void doStart();\n    private void warnIfNoCamelFound();\n    @Override protected void doStop();\n\n}\n\nclass MainTest {\n\n    @Test\n    public void testMainSupport() throws Exception {\n", "reference": "        Main main = new Main();\n        main.start();\n\n        assertThat(\"Camel contexts are not deployed!\", main.getCamelContextMap(), allOf(hasKey(\"default\"), hasKey(\"foo\")));\n\n        CamelContext context = main.getCamelContextMap().get(\"default\");\n        assertThat(\"Default Camel context is not started\", context.getStatus(), is(equalTo(ServiceStatus.Started)));\n        assertThat(\"Foo Camel context is not started\", main.getCamelContextMap().get(\"foo\").getStatus(), is(equalTo(ServiceStatus.Started)));\n\n        MockEndpoint outbound = context.getEndpoint(\"mock:outbound\", MockEndpoint.class);\n        outbound.expectedMessageCount(1);\n        outbound.expectedBodiesReceived(\"message\");\n\n        ProducerTemplate producer = main.getCamelTemplate();\n        producer.sendBody(\"direct:inbound\", \"message\");\n\n        MockEndpoint.assertIsSatisfied(2L, TimeUnit.SECONDS, outbound);\n\n        main.stop();\n    }\n\n}", "prediction": "        MainSupport mainSupport = new MainSupport() {\n            @Override\n            protected Map<String, CamelContext> getCamelContextMap() {\n                return new HashMap<>();\n            }\n        };\n        mainSupport.start();\n        mainSupport.stop();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "24048150_4", "part": [1, 1], "seq": [1, 1], "prompt": "class Tail {\n\n    public static String getParametricCustomSimpleTail() {\n        String tail = PrefsUtil.readString(Consts.Keys.Key_Custom_Tail, \"\");\n        if (TextUtils.isEmpty(tail)) {\n            return \"\";\n        } else {\n            return \"\\n\\n[blockquote]\" + tail + \"[/blockquote]\";\n        }\n    }\n\n    public static String getComplexReplyTail();\n    public static String getDefaultComplexTail();\n    private static String getPhoneComplexTail();\n    public static String getParametricCustomComplexTail();\n    public static String getSimpleReplyTail();\n    private static String getPhoneSimpleTail();\n    private static String getDefaultSimpleTail();\n    public static String getDefaultPlainTail();\n    public static String getPhonePlainTail();\n    public static String getUrl();\n\n}\n\nclass TailTest {\n\n    @Test\n    public void getParametricCustomSimpleTail() throws Exception {\n", "reference": "\n    }\n\n    public static String getComplexReplyTail();\n    public static String getDefaultComplexTail();\n    private static String getPhoneComplexTail();\n    public static String getParametricCustomComplexTail();\n    public static String getSimpleReplyTail();\n    private static String getPhoneSimpleTail();\n    private static String getDefaultSimpleTail();\n    public static String getDefaultPlainTail();\n    public static String getPhonePlainTail();\n    public static String getUrl();\n\n}\n\nclass TailTest {\n\n    @Test\n    public void getParametricCustomSimpleTail() throws Exception {\n\n    }\n\n}", "prediction": "        PrefsUtil.writeString(Consts.Keys.Key_Custom_Tail, \"test\");\n        assertEquals(\"test\", Tail.getParametricCustomSimpleTail());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "24095382_0", "part": [1, 1], "seq": [1, 1], "prompt": "class StringValidator extends FXAbstractValidator<TextInputControl, FXString> {\n\n  @Override\n  public void validate(TextInputControl control, FXString annotation) throws ValidationException {\n    // shortcut: do not check if disabled.\n    if (control.isDisabled()) {\n      this.isValid.set(true);\n      return;\n    }\n    if (!control.isVisible()) {\n      this.isValid.set(true);\n      return;\n    }\n\n    boolean valid = true;\n\n    // 1. minLength?\n    if (annotation.minLength() > 0) {\n      valid = valid && control.getText().length() >= annotation.minLength();\n      \n      this.isValid.set(valid);\n      if (!valid) {\n        String msg = annotation.messageMinLength();\n        if (annotation.messageMinLength().contains(\"%d\")) {\n          msg = String.format(annotation.messageMinLength(), annotation.minLength());\n        }\n        throw new ValidationException(msg);\n      }\n    }\n\n    // 2. maxLength?\n    if (annotation.maxLength() > 0) {\n      valid = valid && control.getText().length() <= annotation.maxLength();\n      this.isValid.set(valid);\n      if (!valid) {\n        String msg = annotation.messageMaxLength();\n        if (annotation.messageMaxLength().contains(\"%d\")) {\n          msg = String.format(annotation.messageMaxLength(), annotation.maxLength());\n        }\n        throw new ValidationException(msg);\n      }\n    }\n\n    // 3. pattern?\n    if (annotation.pattern().length() > 0) {\n      // check for necessary lazy initialization: \n      if (this.pattern == null) {\n        this.createRegex(annotation);\n      }\n      \n      valid = valid && this.pattern.matcher(control.getText()).matches();\n      this.isValid.set(valid);\n      if (!valid) {\n        String msg = annotation.messagePattern();\n        throw new ValidationException(msg);\n      }\n    }\n  }\n\n  public  StringValidator();\n  public  StringValidator(TextInputControl control, FXString annotation);\n\n  private void createRegex(FXString annotation);\n\n}\n\nclass StringValidatorTest {\n\n  @Test\n  @Disabled(\"TODO\")\n  public void testValidate() throws Exception {\n", "reference": "    System.out.println(\"validate\");\n    TextInputControl control = null;\n    FXString annotation = null;\n    StringValidator instance = new StringValidator();\n    instance.validate(control, annotation);\n    // TODO review the generated test code and remove the default call to fail.\n    fail(\"The test case is a prototype.\");\n  }\n\n}", "prediction": "    fail(\"Not yet implemented\");\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "24363680_21", "part": [1, 1], "seq": [1, 1], "prompt": "class WalletProtobufSerializer {\n\n    public Protos.Wallet walletToProto(Wallet wallet) {\n        Protos.Wallet.Builder walletBuilder = Protos.Wallet.newBuilder();\n        walletBuilder.setNetworkIdentifier(wallet.getNetworkParameters().getId());\n        if (wallet.getDescription()!= null) {\n            walletBuilder.setDescription(wallet.getDescription());\n        }\n\n        for (WalletTransaction wtx : wallet.getWalletTransactions()) {\n            Protos.Transaction txProto = makeTxProto(wtx);\n            walletBuilder.addTransaction(txProto);\n        }\n\n        for (ECKey key : wallet.getKeys()) {\n            Protos.Key.Builder keyBuilder = Protos.Key.newBuilder().setCreationTimestamp(key.getCreationTimeSeconds() * 1000)\n                                                         //.setLabel() TODO\n                                                           .setType(Protos.Key.Type.ORIGINAL);\n            if (key.getPrivKeyBytes()!= null)\n                keyBuilder.setPrivateKey(ByteString.copyFrom(key.getPrivKeyBytes()));\n\n            EncryptedPrivateKey encryptedPrivateKey = key.getEncryptedPrivateKey();\n            if (encryptedPrivateKey!= null) {\n                // Key is encrypted.\n                Protos.EncryptedPrivateKey.Builder encryptedKeyBuilder = Protos.EncryptedPrivateKey.newBuilder()\n                   .setEncryptedPrivateKey(ByteString.copyFrom(encryptedPrivateKey.getEncryptedBytes()))\n                   .setInitialisationVector(ByteString.copyFrom(encryptedPrivateKey.getInitialisationVector()));\n\n                if (key.getKeyCrypter() == null) {\n                    throw new IllegalStateException(\"The encrypted key \" + key.toString() + \" has no KeyCrypter.\");\n                } else {\n                    // If it is a Scrypt + AES encrypted key, set the persisted key type.\n                    if (key.getKeyCrypter().getUnderstoodEncryptionType() == Protos.Wallet.EncryptionType.ENCRYPTED_SCRYPT_AES) {\n                        keyBuilder.setType(Protos.Key.Type.ENCRYPTED_SCRYPT_AES);\n                    } else {\n                        throw new IllegalArgumentException(\"The key \" + key.toString() + \" is encrypted with a KeyCrypter of type \" + key.getKeyCrypter().getUnderstoodEncryptionType() +\n                                \". This WalletProtobufSerialiser does not understand that type of encryption.\");\n                    }\n                }\n                keyBuilder.setEncryptedPrivateKey(encryptedKeyBuilder);\n            }\n\n            // We serialize the public key even if the private key is present for speed reasons: we don't want to do\n            // lots of slow EC math to load the wallet, we prefer to store the redundant data instead. It matters more\n            // on mobile platforms.\n            keyBuilder.setPublicKey(ByteString.copyFrom(key.getPubKey()));\n            walletBuilder.addKey(keyBuilder);\n        }\n\n        for (Script script : wallet.getWatchedScripts()) {\n            Protos.Script protoScript =\n                    Protos.Script.newBuilder()\n                           .setProgram(ByteString.copyFrom(script.getProgram()))\n                           .setCreationTimestamp(script.getCreationTimeSeconds() * 1000)\n                           .build();\n\n            walletBuilder.addWatchedScript(protoScript);\n        }\n\n        // Populate the lastSeenBlockHash field.\n        Sha256Hash lastSeenBlockHash = wallet.getLastBlockSeenHash();\n        if (lastSeenBlockHash!= null) {\n            walletBuilder.setLastSeenBlockHash(hashToByteString(lastSeenBlockHash));\n            walletBuilder.setLastSeenBlockHeight(wallet.getLastBlockSeenHeight());\n        }\n        if (wallet.getLastBlockSeenTimeSecs() > 0)\n            walletBuilder.setLastSeenBlockTimeSecs(wallet.getLastBlockSeenTimeSecs());\n\n        // Populate the scrypt parameters.\n        KeyCrypter keyCrypter = wallet.getKeyCrypter();\n        if (keyCrypter == null) {\n            // The wallet is unencrypted.\n            walletBuilder.setEncryptionType(EncryptionType.UNENCRYPTED);\n        } else {\n            // The wallet is encrypted.\n            walletBuilder.setEncryptionType(keyCrypter.getUnderstoodEncryptionType());\n            if (keyCrypter instanceof KeyCrypterScrypt) {\n                KeyCrypterScrypt keyCrypterScrypt = (KeyCrypterScrypt) keyCrypter;\n                walletBuilder.setEncryptionParameters(keyCrypterScrypt.getScryptParameters());\n            } else {\n                // Some other form of encryption has been specified that we do not know how to persist.\n                throw new RuntimeException(\"The wallet has encryption of type '\" + keyCrypter.getUnderstoodEncryptionType() + \"' but this WalletProtobufSerializer does not know how to persist this.\");\n            }\n        }\n\n        if (wallet.getKeyRotationTime()!= null) {\n            long timeSecs = wallet.getKeyRotationTime().getTime() / 1000;\n            walletBuilder.setKeyRotationTime(timeSecs);\n        }\n\n        populateExtensions(wallet, walletBuilder);\n\n        // Populate the wallet version.\n        walletBuilder.setVersion(wallet.getVersion());\n\n        return walletBuilder.build();\n    }\n\n    public  WalletProtobufSerializer();\n\n    public void setRequireMandatoryExtensions(boolean value);\n    public void writeWallet(Wallet wallet, OutputStream output);\n    public String walletToText(Wallet wallet);\n    private static void populateExtensions(Wallet wallet, Protos.Wallet.Builder walletBuilder);\n    private static Protos.Transaction makeTxProto(WalletTransaction wtx);\n    private static Protos.Transaction.Pool getProtoPool(WalletTransaction wtx);\n    private static void writeConfidence(Protos.Transaction.Builder txBuilder,\n                                        TransactionConfidence confidence,\n                                        Protos.TransactionConfidence.Builder confidenceBuilder);\n    public static ByteString hashToByteString(Sha256Hash hash);\n    public static Sha256Hash byteStringToHash(ByteString bs);\n    public Wallet readWallet(InputStream input);\n    public void readWallet(Protos.Wallet walletProto, Wallet wallet);\n    private void loadExtensions(Wallet wallet, Protos.Wallet walletProto);\n    public static Protos.Wallet parseToProto(InputStream input);\n    private void readTransaction(Protos.Transaction txProto, NetworkParameters params);\n    private WalletTransaction connectTransactionOutputs(org.bitcoinj.wallet.Protos.Transaction txProto);\n    private void readConfidence(Transaction tx, Protos.TransactionConfidence confidenceProto,\n                                TransactionConfidence confidence);\n\n    static final NetworkParameters params;\n    private ECKey myKey;\n    private ECKey myWatchedKey;\n    private Address myAddress;\n    private Wallet myWallet;\n    public static String WALLET_DESCRIPTION;\n    private long mScriptCreationTime;\n\n}\n\nclass WalletProtobufSerializerTest {\n\n    static final NetworkParameters params;\n    private ECKey myKey;\n    private ECKey myWatchedKey;\n    private Address myAddress;\n    private Wallet myWallet;\n    public static String WALLET_DESCRIPTION;\n    private long mScriptCreationTime;\n\n    @Test\n    public void testLastBlockSeenHash() throws Exception {\n", "reference": "        // Test the lastBlockSeenHash field works.\n\n        // LastBlockSeenHash should be empty if never set.\n        Wallet wallet = new Wallet(params);\n        Protos.Wallet walletProto = new WalletProtobufSerializer().walletToProto(wallet);\n        ByteString lastSeenBlockHash = walletProto.getLastSeenBlockHash();\n        assertTrue(lastSeenBlockHash.isEmpty());\n\n        // Create a block.\n        Block block = new Block(params, BlockTest.blockBytes);\n        Sha256Hash blockHash = block.getHash();\n        wallet.setLastBlockSeenHash(blockHash);\n        wallet.setLastBlockSeenHeight(1);\n\n        // Roundtrip the wallet and check it has stored the blockHash.\n        Wallet wallet1 = roundTrip(wallet);\n        assertEquals(blockHash, wallet1.getLastBlockSeenHash());\n        assertEquals(1, wallet1.getLastBlockSeenHeight());\n\n        // Test the Satoshi genesis block (hash of all zeroes) is roundtripped ok.\n        Block genesisBlock = MainNetParams.get().getGenesisBlock();\n        wallet.setLastBlockSeenHash(genesisBlock.getHash());\n        Wallet wallet2 = roundTrip(wallet);\n        assertEquals(genesisBlock.getHash(), wallet2.getLastBlockSeenHash());\n    }\n\n}", "prediction": "        WalletProtobufSerializer serializer = new WalletProtobufSerializer();\n        Wallet wallet = new Wallet(params);\n        wallet.setLastBlockSeenHash(Sha256Hash.wrap(\"0000000000000000000000000000000000000000000000000000000000000000\"));\n        wallet.setLastBlockSeenHeight(1000);\n        wallet.setLastBlockSeenTimeSecs(1000000000L);\n\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        serializer.writeWallet(wallet, baos);\n\n        Wallet wallet2 = serializer.readWallet(new ByteArrayInputStream(baos.toByteArray()));\n        assertEquals(wallet.getLastBlockSeenHash(), wallet2.getLastBlockSeenHash());\n        assertEquals(wallet.getLastBlockSeenHeight(), wallet2.getLastBlockSeenHeight());\n        assertEquals(wallet.getLastBlockSeenTimeSecs(), wallet2.getLastBlockSeenTimeSecs());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "24459625_5", "part": [1, 1], "seq": [1, 1], "prompt": "class AwsApaRequesterImpl implements AwsApaRequester {\n\n    @Override\n    public Response<ItemLookupResponse> itemLookupAsync(\n            ItemLookupRequest request) throws ExecutionException,\n            InterruptedException {\n        AWSECommerceServicePortType port = preparePort();\n        ItemLookup itemLookup = prepareItemLookup(request);\n        Response<ItemLookupResponse> response = port\n               .itemLookupAsync(itemLookup);\n        return response;\n    }\n\n    public  AwsApaRequesterImpl();\n    public  AwsApaRequesterImpl(String endpoint, String accessKeyId,\n                               String secretAccessKey, String associateTag);\n\n    private static void checkArgs(String endpoint, String accessKeyId,\n                                  String secretAccessKey, String associateTag);\n    private static void checkIfNullOrEmpty(String str, String name);\n    protected AWSECommerceServicePortType preparePort();\n    protected ItemSearch prepareItemSearch(ItemSearchRequest request);\n    protected ItemLookup prepareItemLookup(ItemLookupRequest request);\n    @Override public ItemSearchResponse itemSearch(ItemSearchRequest request);\n    @Override public Response<ItemSearchResponse> itemSearchAsync(\n            ItemSearchRequest request);\n    public T invokeWithRetry(WebServiceInvoker<T> invoker);\n    @Override public ItemLookupResponse itemLookup(ItemLookupRequest request);\n    public T getResponseWithRetry(final Response<T> res);\n    public int getRetryCount();\n    public void setRetryCount(int retryCount);\n    public long getRetryInterval();\n    public void setRetryInterval(long retryInterval);\n\n    protected AwsApaRequester requester;\n\n}\n\nclass AwsApaRequesterImplTest {\n\n    protected AwsApaRequester requester;\n\n    @Test\n    public void testItemLookupAsync02() throws Exception {\n", "reference": "        Response<ItemLookupResponse> res = null;\n        {\n            ItemLookupRequest request = new ItemLookupRequest();\n            request.getItemId().add(\"489471499X\");\n            request.getResponseGroup().add(\"Small\");\n            res = requester.itemLookupAsync(request);\n        }\n        Response<ItemLookupResponse> res1 = res;\n\n        {\n            ItemLookupRequest request = new ItemLookupRequest();\n            request.getItemId().add(\"4798024031\");\n            request.getResponseGroup().add(\"Small\");\n            res = requester.itemLookupAsync(request);\n        }\n        Response<ItemLookupResponse> res2 = res;\n\n        {\n            ItemLookupRequest request = new ItemLookupRequest();\n            request.getItemId().add(\"4797339535\");\n            request.getResponseGroup().add(\"Small\");\n            res = requester.itemLookupAsync(request);\n        }\n        Response<ItemLookupResponse> res3 = res;\n\n        {\n            ItemLookupResponse response = res1.get();\n            assertNotNull(response);\n            assertNotNull(response.getItems());\n            assertTrue(response.getItems().size() == 1);\n            assertNotNull(response.getItems().get(0).getItem());\n            assertTrue(response.getItems().get(0).getItem().size() == 1);\n            Item item = response.getItems().get(0).getItem().get(0);\n            assertEquals(\"489471499X\", item.getASIN());\n            assertNotNull(item.getItemAttributes());\n        }\n\n        {\n            ItemLookupResponse response = res2.get();\n            assertNotNull(response);\n            assertNotNull(response.getItems());\n            assertTrue(response.getItems().size() == 1);\n            assertNotNull(response.getItems().get(0).getItem());\n            assertTrue(response.getItems().get(0).getItem().size() == 1);\n            Item item = response.getItems().get(0).getItem().get(0);\n            assertEquals(\"4798024031\", item.getASIN());\n            assertNotNull(item.getItemAttributes());\n        }\n\n        {\n            ItemLookupResponse response = res3.get();\n            assertNotNull(response);\n            assertNotNull(response.getItems());\n            assertTrue(response.getItems().size() == 1);\n            assertNotNull(response.getItems().get(0).getItem());\n            assertTrue(response.getItems().get(0).getItem().size() == 1);\n            Item item = response.getItems().get(0).getItem().get(0);\n            assertEquals(\"4797339535\", item.getASIN());\n            assertNotNull(item.getItemAttributes());\n        }\n    }\n\n}", "prediction": "        ItemLookupRequest request = new ItemLookupRequest();\n        request.setItemId(\"B000050V9K\");\n        request.setResponseGroup(\"Large\");\n        request.setMerchantId(\"All\");\n        request.setCondition(\"New\");\n        request.setAssociateTag(\"test-tag\");\n        Response<ItemLookupResponse> response = requester.itemLookupAsync(request);\n        ItemLookupResponse itemLookupResponse = response.get();\n        assertNotNull(itemLookupResponse);\n        assertNotNull(itemLookupResponse.getItems());\n        assertEquals(1, itemLookupResponse.getItems().size());\n        ItemLookupItem item = itemLookupResponse.getItems().get(0);\n        assertNotNull(item);\n        assertNotNull(item.getASIN());\n        assertEquals(\"B000050V9K\", item.getASIN());\n        assertNotNull(item.getDetailPageURL());\n        assertEquals(\"http://www.amazon.com/gp/product/B000050V9K\",\n                item.getDetailPageURL());\n        assertNotNull(item.getLargeImage());\n        assertNotNull(item.getLargeImage().getURL());\n        assertEquals(\"http://ecx.images-amazon.com/images/I/51796980PL._SL160_.jpg\",\n                item.getLargeImage().getURL());\n        assertNotNull(item.getMediumImage());\n        assertNotNull(item.getMediumImage().getURL());\n        assertEquals(\"http://ecx.images-amazon.com/images/I/51796980PL._SL110_.jpg\",\n                item.getMediumImage().getURL());\n        assertNotNull(item.getSmallImage());\n        assertNotNull(item.getSmallImage().getURL());\n        assertEquals(\"http://ecx.images-amazon.com/images/I/51796980PL._SL75_.jpg\",\n                item.getSmallImage().getURL());\n        assertNotNull(item.getMediumImage());\n        assertNotNull(item.getMediumImage().getURL());\n        assertEquals(\"http://ecx.images-amazon.com/images/I/51796980PL._SL110_.jpg\",\n                item.getMediumImage().getURL());\n        assertNotNull(item.getMediumImage());\n        assertNotNull(item.getMediumImage().getURL());\n        assertEquals(\"http://ecx.images-amazon.com/images/I/51796980PL._SL110_.jpg\",\n                item.getMediumImage().getURL());\n        assertNotNull(item.getMediumImage());\n        assertNotNull(item.getMediumImage().getURL());\n        assertEquals(\"http://ecx.images-amazon.com/images/I/51796980PL._SL110_.jpg\",\n               ", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "25040346_0", "part": [1, 1], "seq": [1, 1], "prompt": "class Encoder extends MediaCodecPlugin implements ITransform, ISurfaceCreator {\n\n    @Override\n    public void pull(Frame frame) {\n        throw new UnsupportedOperationException(\"Unexpected call of pull() in Encoder.\");\n    }\n\n    public  Encoder(IMediaCodec mediaCodec);\n\n    @Override public ISurface getSurface();\n    @Override public ISurface getSimpleSurface(IEglContext eglContext);\n    @Override public void checkIfOutputQueueHasData();\n    @Override public void push(Frame frame);\n    @Override public void configure();\n    @Override public void onSurfaceAvailable(IOnSurfaceReady listener);\n    @Override public void releaseOutputBuffer(int outputBufferIndex);\n    @Override public void setTrackId(int trackId);\n    @Override public void close();\n\n}\n\nclass EncoderTest extends MediaCodecPlugin {\n\n    @Test(expected = UnsupportedOperationException.class)\n    public void pull_shouldThrowUnsupportedOperationException() {\n", "reference": "        VideoEncoder videoEncoder = create.videoEncoder().construct();\n        videoEncoder.pull(create.frame().construct());\n    }\n\n}", "prediction": "        Encoder encoder = new Encoder(null);\n        encoder.pull(null);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "25259107_33", "part": [1, 1], "seq": [1, 1], "prompt": "class U2fPrimitives {\n\n    public DeviceRegistration finishRegistration(RegisterRequest registerRequest, RegisterResponse response) throws U2fRegistrationException {\n        return finishRegistration(registerRequest, response, null);\n    }\n\n    public  U2fPrimitives(Crypto crypto, ChallengeGenerator challengeGenerator);\n    public  U2fPrimitives();\n\n    public RegisterRequest startRegistration(String appId);\n    public RegisterRequest startRegistration(String appId, byte[] challenge);\n    public DeviceRegistration finishRegistration(RegisterRequest registerRequest,\n                                                 RegisterResponse response,\n                                                 Set<String> facets);\n    public SignRequest startSignature(String appId, DeviceRegistration deviceRegistration);\n    public SignRequest startSignature(String appId, DeviceRegistration deviceRegistration, byte[] challenge);\n    public void finishSignature(SignRequest signRequest,\n                                SignResponse response,\n                                DeviceRegistration deviceRegistration);\n    public void finishSignature(SignRequest signRequest,\n                                SignResponse response,\n                                DeviceRegistration deviceRegistration,\n                                Set<String> facets);\n\n    final HashSet<String> allowedOrigins;\n     U2fPrimitives u2f;\n    @Rule\n    public ExpectedException expectedException;\n\n}\n\nclass U2fPrimitivesTest {\n\n    final HashSet<String> allowedOrigins;\n     U2fPrimitives u2f;\n    @Rule\n    public ExpectedException expectedException;\n\n    @Test\n    public void finishRegistrationShouldDetectIncorrectClientDataOrigin() throws Exception {\n", "reference": "        expectedException.expectCause(isA(U2fBadInputException.class));\n\n        RegisterRequest registerRequest = new RegisterRequest(SERVER_CHALLENGE_REGISTER_BASE64, APP_ID_ENROLL);\n\n        String clientDataBase64 = U2fB64Encoding.encode(\"{\\\"typ\\\":\\\"navigator.id.finishEnrollment\\\",\\\"challenge\\\":\\\"vqrS6WXDe1JUs5_c3i4-LkKIHRr-3XVb3azuA5TifHo\\\",\\\"origin\\\":\\\"http://evil.com\\\"}\".getBytes(\"UTF-8\"));\n\n        u2f.finishRegistration(\n            registerRequest,\n            new RegisterResponse(\n                TestVectors.REGISTRATION_DATA_BASE64,\n                clientDataBase64\n            )\n        );\n\n        fail(\"finishRegistration did not detect incorrect origin in client data\");\n    }\n\n}", "prediction": "        RegisterRequest registerRequest = u2f.startRegistration(\"http://localhost:8080\");\n        RegisterResponse response = new RegisterResponse();\n        response.clientData = \"clientData\";\n        response.signatureData = \"signatureData\";\n        response.keyHandle = \"keyHandle\";\n\n        expectedException.expect(U2fRegistrationException.class);\n        expectedException.expectMessage(\"Invalid clientData origin\");\n\n        u2f.finishRegistration(registerRequest, response);\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "25359676_335", "part": [1, 1], "seq": [1, 1], "prompt": "class LegacyDataAdapterImpl implements LegacyDataAdapter {\n\n    @Override\n    public boolean isPersistable(Class<?> dataObjectClass) {\n        return selectAdapter(dataObjectClass).isPersistable(dataObjectClass);\n    }\n\n    @Override public T save(T dataObject);\n    @Override public T linkAndSave(T dataObject);\n    @Override public T saveDocument(T document);\n    @Override public T findByPrimaryKey(Class<T> clazz, Map<String,?> primaryKeys);\n    @Override public T findBySinglePrimaryKey(Class<T> clazz, Object primaryKey);\n    @Override public void delete(Object dataObject);\n    @Override public void deleteMatching(Class<?> type, Map<String,?> fieldValues);\n    @Override public T retrieve(T dataObject);\n    @Override public Collection<T> findAll(Class<T> clazz);\n    @Override public Collection<T> findMatching(Class<T> clazz, Map<String,?> fieldValues);\n    @Override public Collection<T> findMatchingOrderBy(Class<T> clazz, Map<String,?> fieldValues, String sortField,\n            boolean sortAscending);\n    @Override public Map<String,?> getPrimaryKeyFieldValues(Object dataObject);\n    @Override public void retrieveNonKeyFields(Object persistableObject);\n    @Override public void retrieveReferenceObject(Object persistableObject, String referenceObjectName);\n    @Override public void refreshAllNonUpdatingReferences(Object persistableObject);\n    @Override public boolean isProxied(Object object);\n    @Override public Object resolveProxy(Object object);\n    @Override public Collection<T> findCollectionBySearchHelper(Class<T> dataObjectClass, Map<String, String> formProperties,\n            boolean unbounded, boolean allPrimaryKeyValuesPresentAndNotWildcard, Integer searchResultsLimit);\n    @Override public Collection<T> findCollectionBySearchHelper(Class<T> dataObjectClass, Map<String, String> formProperties,\n            List<String> wildcardAsLiteralPropertyNames, boolean unbounded,\n            boolean allPrimaryKeyValuesPresentAndNotWildcard, Integer searchResultsLimit);\n    @Override public T findObjectBySearch(Class<T> type, Map<String, String> formProps);\n    @Override public boolean allPrimaryKeyValuesPresentAndNotWildcard(Class<?> boClass, Map<String, String> formProps);\n    @Override public List<String> listPrimaryKeyFieldNames(Class<?> type);\n    @Override public Class<?> determineCollectionObjectType(Class<?> containingType, String collectionPropertyName);\n    @Override public boolean hasReference(Class<?> boClass, String referenceName);\n    @Override public boolean hasCollection(Class<?> boClass, String collectionName);\n    @Override public boolean isExtensionAttribute(Class<?> boClass, String attributePropertyName, Class<?> propertyType);\n    @Override public Class<?> getExtensionAttributeClass(Class<?> boClass, String attributePropertyName);\n    @Override public Map<String,?> getPrimaryKeyFieldValuesDOMDS(Object dataObject);\n    @Override public boolean equalsByPrimaryKeys(Object do1, Object do2);\n    @Override public void materializeAllSubObjects(Object object);\n    @Override public Class<?> getPropertyType(Object object, String propertyName);\n    @Override public Object getExtension(\n            Class<?> businessObjectClass);\n    @Override public void refreshReferenceObject(Object businessObject, String referenceObjectName);\n    @Override public boolean isLockable(Object object);\n    @Override public void verifyVersionNumber(Object dataObject);\n    @Override public RemotableQuickFinder.Builder createQuickFinder(Class<?> containingClass, String attributeName);\n    @Override public boolean isReferenceUpdatable(Class<?> type, String referenceName);\n    @Override @SuppressWarnings(\"rawtypes\") public Map<String, Class> listReferenceObjectFields(Class<?> type);\n    @Override public boolean isCollectionUpdatable(Class<?> type, String collectionName);\n    @Override @SuppressWarnings(\"rawtypes\") public Map<String, Class> listCollectionObjectTypes(Class<?> type);\n    @Override public Object getReferenceIfExists(Object bo, String referenceName);\n    @Override public boolean allForeignKeyValuesPopulatedForReference(Object bo, String referenceName);\n    @Override public RelationshipDefinition getDictionaryRelationship(Class<?> c, String attributeName);\n    @Override public String getTitleAttribute(Class<?> dataObjectClass);\n    @Override public boolean areNotesSupported(Class<?> dataObjectClass);\n    @Override public String getDataObjectIdentifierString(Object dataObject);\n    @Override public Class<?> getInquiryObjectClassIfNotTitle(Object dataObject, String propertyName);\n    @Override public Map<String, String> getInquiryParameters(Object dataObject, List<String> keys, String propertyName);\n    @Override public boolean hasLocalLookup(Class<?> dataObjectClass);\n    @Override public boolean hasLocalInquiry(Class<?> dataObjectClass);\n    @Override public org.kuali.rice.krad.bo.DataObjectRelationship getDataObjectRelationship(Object dataObject,\n            Class<?> dataObjectClass, String attributeName, String attributePrefix, boolean keysOnly,\n            boolean supportsLookup, boolean supportsInquiry);\n    @Override public ForeignKeyFieldsPopulationState getForeignKeyFieldsPopulationState(Object dataObject, String referenceName);\n    @Override public Map<String, String> getForeignKeysForReference(Class<?> clazz, String attributeName);\n    @Override public boolean hasPrimaryKeyFieldValues(Object dataObject);\n    @Override public void setObjectPropertyDeep(Object bo, String propertyName, Class type,\n            Object propertyValue);\n    @Override @SuppressWarnings(\"rawtypes\") public Class materializeClassForProxiedObject(Object object);\n    @Override public Object getNestedValue(Object bo, String fieldName);\n    @Override @SuppressWarnings(\"rawtypes\") public Object createNewObjectFromClass(Class clazz);\n    @Override public boolean isNull(Object object);\n    @Override public void setObjectProperty(Object bo, String propertyName, Class propertyType,\n            Object propertyValue);\n    @Override public T findByDocumentHeaderId(Class<T> documentClass, String id);\n    @Override public List<T> findByDocumentHeaderIds(Class<T> documentClass, List<String> ids);\n    protected LegacyDataAdapter selectAdapter(Object dataObject);\n    public LegacyDataAdapter getKradLegacyDataAdapter();\n    public void setKradLegacyDataAdapter(LegacyDataAdapter kradLegacyDataAdapter);\n    public LegacyDataAdapter getKnsLegacyDataAdapter();\n    public void setKnsLegacyDataAdapter(LegacyDataAdapter knsLegacyDataAdapter);\n\n    @Mock private LegacyDataAdapter knsLegacyDataAdapter;\n    @Mock private LegacyDataAdapter kradLegacyDataAdapter;\n    @Mock private DataDictionaryService dataDictionaryService;\n    @Mock private MetadataRepository metadataRepository;\n    @InjectMocks private LegacyDataAdapterImpl lda;\n\n}\n\nclass LegacyDataAdapterImplTest {\n\n    @Mock private LegacyDataAdapter knsLegacyDataAdapter;\n    @Mock private LegacyDataAdapter kradLegacyDataAdapter;\n    @Mock private DataDictionaryService dataDictionaryService;\n    @Mock private MetadataRepository metadataRepository;\n    @InjectMocks private LegacyDataAdapterImpl lda;\n\n    @Test\n    public void testIsPersistable() throws Exception {\n", "reference": "        lda.isPersistable(NonLegacy.class);\n        verify(kradLegacyDataAdapter).isPersistable(eq(NonLegacy.class));\n        verifyZeroInteractions(knsLegacyDataAdapter);\n    }\n\n}", "prediction": "        lda.isPersistable(LegacyDataAdapterImplTest.class);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "25434304_1", "part": [1, 1], "seq": [1, 1], "prompt": "class Naming {\n\n    static String normalize(CharSequence name) {\n        return capitalize(name.toString().replaceFirst(\"^_\", \"\"))\n               .replaceFirst(\"^Class$\", \"Class_\");\n    }\n\n    private  Naming();\n\n    static String withGeneratedSuffix(CharSequence what);\n    private static String capitalize(String name);\n\n}\n\nclass NamingTest {\n\n    @Test\n    public void shouldIgnoreUnderscoresInBeginning() throws Exception {\n", "reference": "        assertThat(Naming.normalize(\"_public\"), equalTo(\"Public\"));\n    }\n\n}", "prediction": "        assertEquals(\"Class\", Naming.normalize(\"_Class\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "25927306_42", "part": [1, 1], "seq": [1, 1], "prompt": "class IntegerType extends AbstractDERType implements DEREncoder {\n\n  public static int decodeUnsignedPrimitive(final DERBuffer encoded)\n  {\n    // CheckStyle:MagicNumber OFF\n    final byte[] bytes = encoded.getRemainingBytes();\n    if (bytes.length > 4) {\n      throw new IllegalArgumentException(\"Buffer length must be <= 4 bytes\");\n    }\n    int i = 0;\n    for (byte b : bytes) {\n      i <<= 8;\n      i |= b & 0xFF;\n    }\n    return i;\n    // CheckStyle:MagicNumber ON\n  }\n\n  public  IntegerType(final BigInteger item);\n  public  IntegerType(final int item);\n  public  IntegerType(final DERTag tag, final BigInteger item);\n  public  IntegerType(final DERTag tag, final int item);\n\n  @Override public byte[] encode();\n  public static BigInteger decode(final DERBuffer encoded);\n  public static BigInteger decodeUnsigned(final DERBuffer encoded);\n  public static byte[] toBytes(final BigInteger i);\n\n}\n\nclass IntegerTypeTest {\n\n  @Test(groups = \"asn1\", dataProvider = \"ints\")\n  public void decodeUnsignedPrimitive(\n    final byte[] bytes, final BigInteger expected, final BigInteger unsigned, final int unsignedPrim)\n    throws Exception\n  {\n", "reference": "    Assert.assertEquals(IntegerType.decodeUnsignedPrimitive(new DefaultDERBuffer(bytes)), unsignedPrim);\n  }\n\n}", "prediction": "    final DERBuffer encoded = new DERBuffer(bytes);\n    assertEquals(expected, IntegerType.decode(encoded));\n    assertEquals(unsigned, IntegerType.decodeUnsigned(encoded));\n    assertEquals(unsignedPrim, IntegerType.decodeUnsignedPrimitive(encoded));\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "26170170_3", "part": [1, 1], "seq": [1, 1], "prompt": "class GuestService {\n\n    public List<Guest> getAllGuests() {\n        CriteriaQuery<Guest> cq = this.em.getCriteriaBuilder().createQuery(Guest.class);\n        cq.select(cq.from(Guest.class));\n        return this.em.createQuery(cq).getResultList();\n    }\n\n    public  GuestService();\n    @Inject public  GuestService(@Background Event<Guest> guestEvents);\n\n    public void setEntityManager(EntityManager em);\n    public void saveGuest(Guest guest);\n    public Guest findSingleGuestById(@PathParam(\"guestId\") Long guestId);\n    public Optional<Guest> findById(@PathParam(\"guestId\") Long guestId);\n    public Optional<Guest> updateGuestDetails(Guest guest);\n    public Optional<Guest> findByPublicId(String publicId);\n    public boolean deleteGuest(@NotNull String publicId);\n\n    private GuestService guestService;\n    private static final Long WELL_KNOWN_ID;\n\n}\n\nclass GuestServiceTest  {\n\n    private GuestService guestService;\n    private static final Long WELL_KNOWN_ID;\n\n    @Test\n    public void finding_all_guests_does_not_return_null() {\n", "reference": "        assertThat(guestService.getAllGuests()).isNotNull();\n    }\n\n}", "prediction": "        List<Guest> guests = guestService.getAllGuests();\n        assertNotNull(guests);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "26593878_1", "part": [1, 1], "seq": [1, 1], "prompt": "class MMTypeTools {\n\n    public static String bestMatch(Collection<String> supported, String header) {\n        List<ParseResults> parseResults = new LinkedList<ParseResults>();\n\n        List<FitnessAndQuality> weightedMatches = new LinkedList<FitnessAndQuality>();\n        for (String r : header.split(\",\")) {\n            parseResults.add(parseMediaRange(r));\n        }\n\n        for (String s : supported) {\n            FitnessAndQuality fitnessAndQuality = fitnessAndQualityParsed(s,\n                    parseResults);\n            fitnessAndQuality.mimeType = s;\n            weightedMatches.add(fitnessAndQuality);\n        }\n        Collections.sort(weightedMatches);\n\n        FitnessAndQuality lastOne = weightedMatches.get(weightedMatches.size() - 1);\n//        debug(\"Get back: \" + lastOne.quality + \", \" + lastOne.mimeType);\n\n        if (lastOne.quality!= 0) {\n            return lastOne.mimeType;\n        }\n\n        return \"\";\n    }\n\n    private static FitnessAndQuality fitnessAndQualityParsed(String mimeType,\n            Collection<ParseResults> parsedRanges);\n    private static ParseResults parseMediaRange(String range);\n    private static ParseResults parseMimeType(String mimeType);\n\n}\n\nclass MMTypeToolsTest {\n\n    @Test\n    public void testBestMatch() {\n", "reference": "        System.out.println(\"bestMatch\");\n        \n        Collection<String> acceps = new ArrayList<String>();\n        acceps.add(\"text/html\");\n        acceps.add(\"text/*;q=0.9\");\n        acceps.add(\"image/jpeg;q=0.9\");\n        acceps.add(\"image/png;q=0.9\");\n        acceps.add(\"image/*;q=0.9\");\n        acceps.add(\"*/*;q=0.8\");\n       \n        String fileContentType = \"text/plain\";\n        String expResult = \"text/*;q=0.9\";\n        String result = MMTypeTools.bestMatch(acceps, fileContentType);\n        assertEquals(expResult, result);\n    }\n\n}", "prediction": "//        String[] supported = new String[] { \"application/vnd.ms-excel\",\n//                \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\",\n//                \"application/vnd.ms-powerpoint\",\n//                \"application/vnd.openxmlformats-officedocument.presentationml.presentation\",\n//                \"application/vnd.ms-word\",\n//                \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\",\n//                \"application/pdf\", \"application/x-pdf\", \"application/acrobat\",\n//                \"application/octet-stream\", \"application/x-msdownload\",\n//                \"application/x-zip-compressed\", \"multipart/x-zip\", \"application/zip\",\n//                \"application/x-rar-compressed\", \"application/rar\", \"application/x-rar\",\n//                \"application/x-tar\", \"application/tar\", \"application/x-gzip\",\n//                \"application/gzip\", \"application/x-compress\", \"application/x-compressed\",\n//                \"application/x-7z-compressed\", \"application/x-7z\", \"application/x-stuffit\",\n//                \"application/x-stuffitx\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x-stuffit\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x-stuffit\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x-stuffit\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x-stuffit\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x-stuffit\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x-stuffit\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x-stuffit\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x-stuffit\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x-stuffit\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x-stuffit\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x-stuffit\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x-stuffit\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x-stuffit\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x-stuffit\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x-stuffit\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x-stuffit\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x-stuffit\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x-stuffit\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x-stuffit\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x-stuffit\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x-stuffit\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x-stuffit\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x-stuffit\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x-stuffit\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x-stuffit\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x-stuffit\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x-stuffit\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x-stuffit\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x-stuffit\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x-stuffit\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x-stuffit\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x-stuffit\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x-stuffit\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x-stuffit\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x-stuffit\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x-stuffit\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x-stuffit\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x-stuffit\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x-stuffit\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x-stuffit\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x-stuffit\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x-stuffit\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x-stuffit\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x-stuffit\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x-stuffit\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x-stuffit\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x-stuffit\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x-stuffit\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x-stuffit\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x-stuffit\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x-stuffit\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x-stuffit\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x-stuffit\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x-stuffit\", \"application/x-stuffit\", \"application/x-stuffit\",\n//                \"application/x", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "26644682_425", "part": [1, 1], "seq": [1, 1], "prompt": "class XlsDetector extends POIFSContainerDetector implements Detector {\n\n    @Override\n    public Format detect(Metadata metadata, TikaInputStream inputStream) throws IOException {\n\n        Format result = null;\n\n        MediaType mediaType = super.detect(inputStream, metadata);\n        if (mediaType == null || StringUtils.equals(mediaType.toString(), FormatUtils.UNKNOWN_MEDIA_TYPE)) {\n            mediaType = zipContainerDetector.detect(inputStream, new Metadata());\n        }\n\n        if (mediaType!= null) {\n            String mediaTypeName = mediaType.toString();\n            if (StringUtils.startsWith(mediaTypeName, XlsFormatFamily.MEDIA_TYPE)\n                    || StringUtils.equals(mediaTypeName, OLD_XLS_MEDIA_TYPE)) {\n                result = new Format(xlsFormatFamily, FormatUtils.DEFAULT_ENCODING);\n            }\n        }\n\n        return result;\n    }\n\n    @Autowired XlsDetector xlsDetector;\n\n}\n\nclass XlsDetectorTest extends POIFSContainerDetector {\n\n    @Autowired XlsDetector xlsDetector;\n\n    @Test\n    public void read_xls_that_can_be_parsed_as_csv_TDP_375() throws Exception {\n", "reference": "\n        String fileName = \"TDP-375_xsl_read_as_csv.xls\";\n\n        try (InputStream inputStream = this.getClass().getResourceAsStream(fileName)) {\n            Format actual = xlsDetector.detect(inputStream);\n            Assert.assertNotNull(actual);\n            assertTrue(actual.getFormatFamily() instanceof XlsFormatFamily);\n            assertEquals(XlsFormatFamily.MEDIA_TYPE, actual.getFormatFamily().getMediaType());\n            assertTrue(StringUtils.equals(\"UTF-8\", actual.getEncoding()));\n        }\n\n    }\n\n}", "prediction": "        TikaInputStream inputStream = new TikaInputStream(getClass().getResourceAsStream(\"/TDP-375.xls\"));\n        Format format = xlsDetector.detect(inputStream, new Metadata());\n        Assert.assertEquals(Format.XLS, format.getMediaType());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "27064201_0", "part": [1, 1], "seq": [1, 1], "prompt": "class RemoteFileDescriptor extends RemoteFileDescriptorBase<Void> {\n\n  @Override\n  public synchronized void close() throws IOException {\n    FileDescriptor fd = getFileDescriptor();\n    if (fd!= null && fd.valid()) {\n      new FileInputStream(fd).close();\n    }\n  }\n\n  public  RemoteFileDescriptor();\n  public  RemoteFileDescriptor(AFUNIXRMISocketFactory socketFactory, FileDescriptor fd);\n\n  private static final String TEST_SERVICE_NAME;\n  private static final byte[] HELLO_WORLD;\n  private static final byte[] SMILEY;\n  private static AFUNIXNaming namingInstance;\n  private static RemoteFileDescriptorTestServiceImpl testService;\n\n}\n\nclass RemoteFileDescriptorTest {\n\n  private static final String TEST_SERVICE_NAME;\n  private static final byte[] HELLO_WORLD;\n  private static final byte[] SMILEY;\n  private static AFUNIXNaming namingInstance;\n  private static RemoteFileDescriptorTestServiceImpl testService;\n\n  @Test\n  public void testWriteAndReadHello() throws Exception {\n", "reference": "    RemoteFileDescriptorTestService svc = (RemoteFileDescriptorTestService) namingInstance\n        .getRegistry().lookup(TEST_SERVICE_NAME);\n\n    try (FileOutputStream fos = svc.output().asFileOutputStream()) {\n      fos.write(HELLO_WORLD);\n    }\n    svc.verifyContents(HELLO_WORLD);\n\n    try (FileInputStream fin = svc.input(12).asFileInputStream()) {\n      byte[] data = TestUtils.readAllBytes(fin);\n      assertArrayEquals(SMILEY, data);\n    }\n\n    try (NaiveFileInputStreamRemote rfis = svc.naiveInputStreamRemote();\n        FileInputStream fin = rfis.getRemoteFileDescriptor().asFileInputStream()) {\n      assertEquals('H', rfis.read());\n      assertEquals('e', fin.read());\n      assertEquals('l', fin.read());\n      assertEquals('l', fin.read());\n      fin.close(); // it's OK to close the remote file descriptor we received via RMI\n      assertEquals('o', rfis.read());\n    }\n  }\n\n}", "prediction": "    RemoteFileDescriptor fd = new RemoteFileDescriptor(namingInstance, testService.getHelloFileDescriptor());\n    fd.write(HELLO_WORLD);\n    fd.close();\n    fd = new RemoteFileDescriptor(namingInstance, testService.getHelloFileDescriptor());\n    byte[] buf = new byte[HELLO_WORLD.length];\n    fd.read(buf);\n    assertEquals(HELLO_WORLD, buf);\n    fd.close();\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "27147147_24", "part": [1, 1], "seq": [1, 1], "prompt": "class Settings implements Serializable {\n\n    Object put(String key, @Nullable Object value) {\n        Preconditions.checkNotNull(key);\n        return put(\"<direct call>\", key, value);\n    }\n\n      Settings();\n\n    public synchronized void loadFromClassPath(String location);\n    public synchronized void loadFromProperties(Properties p);\n    public synchronized void loadFromFile(String location);\n    synchronized void loadOverrides();\n     void substituteVariables(Properties p);\n    private void putAll(String source, Properties p);\n     Object remove(String source, String key);\n     Object remove(String key);\n    private Object put(String source, String key, @Nullable Object value);\n    private void broadcastSettingChanged(\n            String key, Object oldValue, Object newValue);\n    public Object set(String source, String setting, @Nullable String value);\n    public Object set(String setting, @Nullable String value);\n    public static KeyIteratorFilter startsWith(String prefix);\n    public static KeyIteratorFilter endsWith(String prefix);\n    public static KeyIteratorFilter contains(String string);\n    public static KeyIteratorFilter notContains(String string);\n    public static KeyIteratorFilter matches(String regex);\n    public static KeyIteratorFilter[] join(KeyIteratorFilter filter,\n                                           KeyIteratorFilter... filters);\n    public Keys keys();\n    public Keys keys(@Nullable KeyIteratorFilter... filter);\n    public MappedSettings<T> map(@Nullable String prefix, Class<T> type);\n    public MappedSettings<T> map(@Nullable String prefix,\n                                     Class<T> type,\n                                     KeyIteratorFilter... filters);\n    public boolean isDefined(String key);\n    @Nullable public String getString(String key);\n    @Nullable public Integer getInteger(String key);\n    @Nullable public Long getLong(String key);\n    @Nullable public Double getDouble(String key);\n    public Boolean getBoolean(String key);\n    @Nullable public BigDecimal getBigDecimal(String key);\n    public String getString(String key, String defaultValue);\n    public Long getLong(String key, @Nullable Long defaultValue);\n    public Integer getInteger(String key, @Nullable Integer defaultValue);\n    public Double getDouble(String key, @Nullable Double defaultValue);\n    @Nullable public BigDecimal getBigDecimal(String key, @Nullable BigDecimal defaultValue);\n    public Boolean getBoolean(String key, @Nullable Boolean defaultValue);\n    public Properties asProperties();\n    public Properties asProperties(@Nullable String prefixForCutoff);\n    public Map<String, String> asMap();\n    public Map<String, String> asMap(@Nullable String prefixForCutoff);\n    public synchronized List<String> getLocationsLoaded();\n    public void addListener(SettingsListener l);\n    public void removeListener(SettingsListener l);\n    @Override public String toString();\n    public static SettingsBuilder builder();\n\n}\n\nclass SettingsTest {\n\n    @Test\n    public void testSettingsModule() {\n", "reference": "        Settings settings = new Settings();\n        settings.put(\"foo\", \"bar\");\n        Bootstrap bootstrap = new Bootstrap(settings);\n        WhatsYourFoo instance = bootstrap.getInjector().getInstance(WhatsYourFoo.class);\n        Assert.assertEquals(\"bar\", instance.foo);\n    }\n\n}", "prediction": "        Settings settings = Settings.builder().build();\n        settings.loadFromClassPath(\"test.properties\");\n        settings.loadFromProperties(new Properties());\n        settings.loadFromFile(\"test.properties\");\n        settings.loadOverrides();\n        settings.substituteVariables(new Properties());\n        settings.put(\"test\", \"test\", \"test\");\n        settings.remove(\"test\", \"test\");\n        settings.remove(\"test\");\n        settings.set(\"test\", \"test\", \"test\");\n        settings.setString(\"test\", \"test\");\n        settings.setInteger(\"test\", 1);\n        settings.setLong(\"test\", 1L);\n        settings.setDouble(\"test\", 1.0);\n        settings.setBoolean(\"test\", true);\n        settings.setBigDecimal(\"test\", new BigDecimal(\"1.0\"));\n        settings.getString(\"test\", \"test\");\n        settings.getLong(\"test\", 1L);\n        settings.getInteger(\"test\", 1);\n        settings.getDouble(\"test\", 1.0);\n        settings.getBoolean(\"test\", true);\n        settings.getBigDecimal(\"test\", new BigDecimal(\"1.0\"));\n        settings.isDefined(\"test\");\n        settings.getString(\"test\");\n        settings.getInteger(\"test\");\n        settings.getLong(\"test\");\n        settings.getDouble(\"test\");\n        settings.getBoolean(\"test\");\n        settings.getBigDecimal(\"test\");\n        settings.asProperties();\n        settings.asProperties(\"test\");\n        settings.asMap();\n        settings.asMap(\"test\");\n        settings.getLocationsLoaded();\n        settings.addListener(new SettingsListener() {\n            @Override\n            public void settingChanged(String key, Object oldValue, Object newValue) {\n\n            }\n        });\n        settings.removeListener(new SettingsListener() {\n            @Override\n            public void settingChanged(String key, Object oldValue, Object newValue) {\n\n            }\n        });\n        settings.toString();\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "27187107_4", "part": [1, 1], "seq": [1, 1], "prompt": "class ZkBasedTreeNodeResource implements Closeable {\n\n    @Override\n    public void close() {\n        synchronized (lock) {\n            if (resource!= null && cleanup!= null) {\n                cleanup.test(resource);\n            }\n            if (treeCache!= null) {\n                treeCache.close();\n            }\n            closed = true;\n        }\n    }\n\n    private  ZkBasedTreeNodeResource(Builder<T> builder);\n\n    public static Builder<T> newBuilder();\n    private void ensureTreeCacheReady();\n    public T get();\n    private void checkClosed();\n    private void cleanup(T currentResource, T oldResource);\n    public boolean isClosed();\n    private T doFactory();\n    private void generateFullTree(Map<String, ChildData> map, TreeCache cache, String rootPath);\n\n    private static final Logger logger;\n\n}\n\nclass ZkBasedTreeNodeResourceTest  {\n\n    private static final Logger logger;\n\n    @Test\n    void testClose() {\n", "reference": "        ZkBasedTreeNodeResource<Map<String, String>> tree = ZkBasedTreeNodeResource\n                .<Map<String, String>> newBuilder()\n                .curator(curatorFramework)\n                .path(\"/test\")\n                .factory(p -> p.entrySet().stream()\n                        .collect(toMap(Entry::getKey, e -> new String(e.getValue().getData()))))\n                .build();\n        System.out.println(tree.get());\n        tree.close();\n        assertThrows(IllegalStateException.class, tree::get);\n    }\n\n}", "prediction": "        ZkBasedTreeNodeResource<String> resource = ZkBasedTreeNodeResource.newBuilder().build();\n        resource.close();\n        resource.close();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "27244573_56", "part": [1, 1], "seq": [1, 1], "prompt": "class TherionImporter extends Importer {\n\n    public static List<String> getContentsOfBeginEndBlock(List<String> lines, String tag)\n            throws Exception {\n\n        boolean foundStartBlock = false;\n        boolean foundEndBlock = false;\n        String endTag = \"end\" + tag;\n\n        List<String> contents = new ArrayList<>();\n\n        for (String line : lines) {\n            line = line.trim();\n\n            if (line.equals(tag)) {\n                if (foundStartBlock) {\n                    throw new Exception(\"Opening block tag \" + tag + \" encountered twice\");\n                } else {\n                    foundStartBlock = true;\n                    continue;\n                }\n\n            } else if (line.equals(endTag)) {\n                if (foundStartBlock) {\n                    foundEndBlock = true;\n                    break;\n                } else {\n                    throw new Exception(\"End block tag \" + endTag + \" encountered before block start\");\n                }\n\n            } else if (!foundStartBlock) {\n                continue;\n            }\n\n            contents.add(line);\n        }\n\n        if (!foundStartBlock) {\n            throw new Exception(\"Failed to find opening block tag \" + tag);\n        } else if (!foundEndBlock) {\n            throw new Exception(\"Failed to find end block tag \" + endTag);\n        }\n\n        return contents;\n    }\n\n    public Survey toSurvey(File directory);\n    private static Survey parseTh(File file);\n    public static String getSurveyName(File file);\n    public boolean canHandleFile(File directory);\n    public static void updateCentreline(List<String> lines, Survey survey);\n    private static void handleElevationDirectionData(List<String> lines, Survey survey);\n\n    private static final String FAKE_POCKETTOPO_TEXT;\n    private static String FAKE_TEXT;\n    private static final List<String> LINES;\n\n}\n\nclass TherionImporterTest {\n\n    private static final String FAKE_POCKETTOPO_TEXT;\n    private static String FAKE_TEXT;\n    private static final List<String> LINES;\n\n    @Test(expected=Exception.class)\n    public void testBlockExtractionFailsIfTwoOpeningTags() throws Exception {\n", "reference": "        List<String> LINES = Arrays.asList(\"block\", \"blah\", \"block\", \"blah\", \"endblock\");\n        TherionImporter.getContentsOfBeginEndBlock(LINES, \"block\");\n    }\n\n}", "prediction": "        TherionImporter.getContentsOfBeginEndBlock(LINES, \"POCKETTOPO\");\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "28505345_59", "part": [1, 1], "seq": [1, 1], "prompt": "class HttpHeaderParser {\n\n    public static Cache.Entry parseCacheHeaders(NetworkResponse response) {\n        long now = System.currentTimeMillis();\n\n        Headers headers = response.headers;\n\n        long serverDate = 0;\n        long lastModified = 0;\n        long serverExpires = 0;\n        long softExpire = 0;\n        long finalExpire = 0;\n        long maxAge = 0;\n        long staleWhileRevalidate = 0;\n        boolean hasCacheControl = false;\n        boolean mustRevalidate = false;\n\n        String serverEtag = null;\n        String headerValue;\n        List<String> headerValues;\n\n        headerValue = headers.get(\"Date\");\n        if (headerValue!= null) {\n            serverDate = parseDateAsEpoch(headerValue);\n        }\n\n        //TODO check multiple cache and make stale if more than 1 value for given directive\n        headerValues = headers.values(\"Cache-Control\");\n        if (headerValues!= null && headerValues.size() > 0) {\n            hasCacheControl = true;\n            for (int i = 0; i < headerValues.size(); i++) {\n                String[] tokens = headerValues.get(i).trim().split(\",\");\n                for (int j = 0; j < tokens.length; j++) {\n                    String token = tokens[j].trim();\n                    if (token.equals(\"no-cache\") || token.equals(\"no-store\")) {\n                        return null;\n                    } else if (token.startsWith(\"max-age=\")) {\n                        try {\n                            maxAge = Long.parseLong(token.substring(8));\n                        } catch (Exception e) {\n                        }\n                    } else if (token.startsWith(\"stale-while-revalidate=\")) {\n                        try {\n                            staleWhileRevalidate = Long.parseLong(token.substring(23));\n                        } catch (Exception e) {\n                        }\n                    } else if (token.equals(\"must-revalidate\") || token.equals(\"proxy-revalidate\")) {\n\n                        mustRevalidate = true;\n                    }\n                }\n            }\n        }\n\n        headerValue = headers.get(\"Expires\");\n        if (headerValue!= null) {\n            serverExpires = parseDateAsEpoch(headerValue);\n        }\n\n        headerValue = headers.get(\"Last-Modified\");\n        if (headerValue!= null) {\n            lastModified = parseDateAsEpoch(headerValue);\n        }\n\n        serverEtag = headers.get(\"ETag\");\n\n        // Cache-Control takes precedence over an Expires header, even if both exist and Expires\n        // is more restrictive.\n        if (hasCacheControl) {\n            softExpire = now + maxAge * 1000;\n            finalExpire = mustRevalidate\n                   ? softExpire\n                    : softExpire + staleWhileRevalidate * 1000;\n        } else if (serverDate > 0 && serverExpires >= serverDate) {\n            // Default semantic for Expire header in HTTP specification is softExpire.\n            softExpire = now + (serverExpires - serverDate);\n            finalExpire = softExpire;\n        }\n\n        Cache.Entry entry = new Cache.Entry();\n        entry.data = response.data;\n        entry.etag = serverEtag;\n        entry.softTtl = softExpire;\n        entry.ttl = finalExpire;\n        entry.serverDate = serverDate;\n        entry.lastModified = lastModified;\n        entry.responseHeaders = headers;\n\n        return entry;\n    }\n\n    public static long parseDateAsEpoch(String dateStr);\n    public static String parseCharset(Map<String, String> headers, String defaultCharset);\n    public static String parseCharset(Map<String, String> headers);\n\n    private static long ONE_MINUTE_MILLIS;\n    private static long ONE_HOUR_MILLIS;\n    private static long ONE_DAY_MILLIS;\n    private static long ONE_WEEK_MILLIS;\n    private Map<String, String> headers;\n\n}\n\nclass HttpHeaderParserTest {\n\n    private static long ONE_MINUTE_MILLIS;\n    private static long ONE_HOUR_MILLIS;\n    private static long ONE_DAY_MILLIS;\n    private static long ONE_WEEK_MILLIS;\n    private Map<String, String> headers;\n\n    @Test public void parseCacheHeaders_headersSet() {\n", "reference": "        headers.put(\"MyCustomHeader\", \"42\");\n        NetworkResponse response = new NetworkResponse(0, new byte[0], Headers.of(headers), 0);\n        Cache.Entry entry = HttpHeaderParser.parseCacheHeaders(response);\n        assertNotNull(entry);\n        assertNotNull(entry.responseHeaders);\n        assertEquals(1, entry.responseHeaders.size());\n        assertEquals(\"42\", entry.responseHeaders.get(\"MyCustomHeader\"));\n    }\n\n}", "prediction": "        headers = new HashMap<String, String>();\n        headers.put(\"Date\", \"Wed, 21 Oct 2015 07:28:00 GMT\");\n        headers.put(\"Expires\", \"Wed, 21 Oct 2015 08:28:00 GMT\");\n        headers.put(\"Cache-Control\", \"max-age=600\");\n        headers.put(\"ETag\", \"W/\\\"123456789\\\"\");\n\n        Cache.Entry entry = HttpHeaderParser.parseCacheHeaders(new NetworkResponse(200, new byte[0], headers));\n\n        assertEquals(1445411680000L, entry.serverDate);\n        assertEquals(1445415280000L, entry.softTtl);\n        assertEquals(1445415280000L, entry.ttl);\n        assertEquals(\"W/\\\"123456789\\\"\", entry.etag);\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "28649714_28", "part": [1, 1], "seq": [1, 1], "prompt": "class CompetitionGroupSetMapper {\n\npublic abstract CompetitionGroupSetAddPayload toDomainAddPayload(AddCompetitionGroupSetRequest apiAddRequest)public abstract CompetitionGroupSetAddPayload toDomainAddPayload(AddCompetitionGroupSetRequest apiAddRequest);\n\npublic abstract CompetitionGroupSetAddPayload toDomainAddPayload(AddCompetitionGroupSetRequest apiAddRequest)public abstract CompetitionGroupSetApiEntity toApiEntity(CompetitionGroupSet domainEntity);\npublic abstract CompetitionGroupSetAddPayload toDomainAddPayload(AddCompetitionGroupSetRequest apiAddRequest)public Set<CompetitionGroupApiEntity> toInnerApiEntitySet(Set<CompetitionGroup> innerDomainEntitySet);\npublic abstract CompetitionGroupSetAddPayload toDomainAddPayload(AddCompetitionGroupSetRequest apiAddRequest)public abstract List<CompetitionGroupSetApiEntity> toApiEntityList(List<CompetitionGroupSet> domainEntityList);\npublic abstract CompetitionGroupSetAddPayload toDomainAddPayload(AddCompetitionGroupSetRequest apiAddRequest)public abstract CompetitionGroupSetHibernateEntity toHibernateEntity(\n            CompetitionGroupSetAddPayload domainAddPayload\n    );\npublic abstract CompetitionGroupSetAddPayload toDomainAddPayload(AddCompetitionGroupSetRequest apiAddRequest)public CompetitionGroupSetHibernateEntity toHibernateEntity(CompetitionGroupSet domainEntity);\npublic abstract CompetitionGroupSetAddPayload toDomainAddPayload(AddCompetitionGroupSetRequest apiAddRequest)public Set<CompetitionGroupHibernateEntity> toInnerHibernateEntitySet(Set<CompetitionGroup> innerDomainEntitySet);\npublic abstract CompetitionGroupSetAddPayload toDomainAddPayload(AddCompetitionGroupSetRequest apiAddRequest)public abstract void updateHibernateEntity(\n            CompetitionGroupSet domainEntity,\n            @MappingTarget CompetitionGroupSetHibernateEntity hibernateEntity\n    );\npublic abstract CompetitionGroupSetAddPayload toDomainAddPayload(AddCompetitionGroupSetRequest apiAddRequest)public abstract CompetitionGroupSet toDomainEntity(CompetitionGroupSetHibernateEntity hibernateEntity);\npublic abstract CompetitionGroupSetAddPayload toDomainAddPayload(AddCompetitionGroupSetRequest apiAddRequest)public Set<CompetitionGroup> toInnerDomainEntitySet(Set<CompetitionGroupHibernateEntity> innerHibernateEntitySet);\npublic abstract CompetitionGroupSetAddPayload toDomainAddPayload(AddCompetitionGroupSetRequest apiAddRequest)public abstract List<CompetitionGroupSet> toDomainEntityList(\n            List<CompetitionGroupSetHibernateEntity> hibernateEntityList\n    );\npublic abstract CompetitionGroupSetAddPayload toDomainAddPayload(AddCompetitionGroupSetRequest apiAddRequest)public void setDao(CompetitionGroupSetDao dao);\npublic abstract CompetitionGroupSetAddPayload toDomainAddPayload(AddCompetitionGroupSetRequest apiAddRequest)public void setCompetitionGroupMapper(CompetitionGroupMapper competitionGroupMapper);\n\n    private CompetitionGroupSetMapper mapper;\n    @Mock CompetitionGroupSetDao dao;\n    @Mock CompetitionGroupDao competitionGroupDao;\n\n}\n\nclass CompetitionGroupSetMapperTest {\n\n    private CompetitionGroupSetMapper mapper;\n    @Mock CompetitionGroupSetDao dao;\n    @Mock CompetitionGroupDao competitionGroupDao;\n\n    @Test\n    public void whenToDomainAddPayloadFromApiAddRequest() {\n", "reference": "        AddCompetitionGroupSetRequest apiAddRequest = ApiRequestTestUtils.fullAddCompetitionGroupSet();\n        CompetitionGroupSetAddPayload expected = DomainPayloadTestUtils.fullCompetitionGroupSetAdd();\n        expected.setCompetitionGroups(null);\n\n        CompetitionGroupSetAddPayload actual = mapper.toDomainAddPayload(apiAddRequest);\n\n        assertThat(actual).isEqualTo(expected);\n    }\n\n}", "prediction": "        // given\n        AddCompetitionGroupSetRequest apiAddRequest = new AddCompetitionGroupSetRequest();\n        apiAddRequest.setName(\"name\");\n        apiAddRequest.setCompetitionGroups(Collections.singleton(new CompetitionGroupApiEntity()));\n\n        // when\n        CompetitionGroupSetAddPayload domainAddPayload = mapper.toDomainAddPayload(apiAddRequest);\n\n        // then\n        assertThat(domainAddPayload.getName()).isEqualTo(\"name\");\n        assertThat(domainAddPayload.getCompetitionGroups()).hasSize(1);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "28752850_14", "part": [1, 1], "seq": [1, 1], "prompt": "class Timepoint implements Parcelable, Comparable<Timepoint> {\n\n    public boolean isAM() {\n        return hour < 12;\n    }\n\n    public  Timepoint(Timepoint time);\n    public  Timepoint(@IntRange(from=0, to=23) int hour,\n                     @IntRange(from=0, to=59) int minute,\n                     @IntRange(from=0, to=59) int second);\n    public  Timepoint(@IntRange(from=0, to=23) int hour,\n                     @IntRange(from=0, to=59) int minute);\n    public  Timepoint(@IntRange(from=0, to=23) int hour);\n    public  Timepoint(Parcel in);\n\n    @IntRange(from=0, to=23) public int getHour();\n    @IntRange(from=0, to=59) public int getMinute();\n    @IntRange(from=0, to=59) public int getSecond();\n    public boolean isPM();\n    public void setAM();\n    public void setPM();\n    public void add(TYPE type, int value);\n    public int get(@NonNull TYPE type);\n    public int toSeconds();\n    @Override public int hashCode();\n    @Override public boolean equals(Object o);\n    public boolean equals(@Nullable Timepoint time, @NonNull TYPE resolution);\n    @Override public int compareTo(@NonNull Timepoint t);\n    @Override public void writeToParcel(Parcel out, int flags);\n    @Override public int describeContents();\n    @Override public String toString();\n\n}\n\nclass TimepointTest {\n\n    @Test\n    public void isAMShouldReturnFalseIfTimepointIsAfterMidday() {\n", "reference": "        Timepoint timepoint = new Timepoint(13);\n        Assert.assertFalse(timepoint.isAM());\n    }\n\n}", "prediction": "        Timepoint timepoint = new Timepoint(13, 0, 0);\n        assertFalse(timepoint.isAM());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "28835543_0", "part": [1, 1], "seq": [1, 1], "prompt": "class Chatroom extends AbstractActor {\n\n    public List<Messages.PostToChatroom> joinChatroom(Messages.JoinChatroom msg) {\n        joinedUsers.add(msg.userRef);\n        return chatHistory;\n    }\n\n    @Override public PartialFunction<Object, BoxedUnit> receive();\n\n    static ActorSystem system;\n\n}\n\nclass ChatroomTest extends AbstractActor {\n\n    static ActorSystem system;\n\n    @Test\n    public void testShouldAddUserToJoinedUsersWhenJoiningUnitTest() {\n", "reference": "        Props props = Props.create(Chatroom.class);\n        TestActorRef<Chatroom> ref = TestActorRef.create(system, props);\n        Chatroom chatroom = ref.underlyingActor();\n\n        UserRef userRef = new UserRef(system.deadLetters(), \"user\");\n        Messages.JoinChatroom request = new Messages.JoinChatroom(userRef);\n        chatroom.joinChatroom(request);\n\n        assertEquals(chatroom.joinedUsers.get(0), userRef);\n    }\n\n}", "prediction": "        Messages.JoinChatroom msg = new Messages.JoinChatroom(\"testUser\");\n        Chatroom chatroom = new Chatroom();\n        chatroom.receive().apply(msg);\n\n        assertTrue(chatroom.joinedUsers.contains(msg.userRef));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "29406271_0", "part": [1, 1], "seq": [1, 1], "prompt": "class SampleResource {\n\n\t@GET\n\t@Path(\"/{id}\")\n\t@Produces(\"application/json\")\n\tpublic Response get(@PathParam(\"id\") String id) {\n\t\tResource resource;\n\t\ttry {\n\t\t\tresource = store.get(id);\n\t\t} catch (IOException e) {\n\t\t\treturn Response.status(Response.Status.NOT_FOUND).build();\n\t\t}\n\n\t\treturn Response.ok(resource).build();\n\t}\n\n\t@POST @Consumes(\"application/json\") public Response post(JsonNode node);\n\t@PUT @Path(\"/{id}\") @Produces(\"application/json\") @Consumes(\"application/json\") public Response put(@PathParam(\"id\") String id, JsonNode node);\n\t@DELETE @Path(\"/{id}\") public Response delete(@PathParam(\"id\") String id);\n\n\tprivate HttpServer server;\n\tprivate Client client;\n\n}\n\nclass SampleResourceTest {\n\n\tprivate HttpServer server;\n\tprivate Client client;\n\n\t@Test\n\tpublic void testGet() throws Exception {\n", "reference": "\t\tWebTarget target = client.target(Main.uri + \"u1\");\n\n\t\tResource resource = target.request(MediaType.APPLICATION_JSON).get(Resource.class);\n\t\tassertEquals(1, resource.getContents().size());\n\n\t\tEObject u1 = resource.getContents().get(0);\n\t\tassertEquals(\"User\", u1.eClass().getName());\n\t\tassertEquals(\"u1\", u1.eGet(u1.eClass().getEStructuralFeature(\"name\")));\n\t}\n\n}", "prediction": "\t\tserver.start();\n\n\t\tResponse response = client.target(\"http://localhost:8080/sample/1\").request().get();\n\t\tassertEquals(200, response.getStatus());\n\t\tassertEquals(\"application/json\", response.getHeaderString(\"Content-Type\"));\n\t\tassertEquals(\"{\\\"id\\\":\\\"1\\\",\\\"name\\\":\\\"foo\\\"}\", response.readEntity(String.class));\n\n\t\tserver.stop();\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "29479059_81", "part": [1, 1], "seq": [1, 1], "prompt": "class DefaultJobService implements JobService {\n\n    @Override\n    public JobParameters getLastJobParameters(final String jobName) {\n        final List<JobExecution> executions = this.lightminJobExecutionDao.getJobExecutions(jobName, 0, 1);\n        JobExecution lastExecution = null;\n        if (!CollectionUtils.isEmpty(executions)) {\n            lastExecution = executions.iterator().next();\n        }\n        JobParameters oldParameters = new JobParameters();\n        if (lastExecution!= null) {\n            oldParameters = lastExecution.getJobParameters();\n        }\n        return oldParameters;\n    }\n\n    public  DefaultJobService(final JobOperator jobOperator,\n                             final JobRegistry jobRegistry,\n                             final JobExplorer jobExplorer,\n                             final LightminJobExecutionDao lightminJobExecutionDao);\n\n    @Override public int getJobInstanceCount(final String jobName);\n    @Override public int getJobExecutionCount(final JobInstance jobInstance);\n    @Override public Set<String> getJobNames();\n    @Override public Job getJobByName(final String jobName);\n    @Override public Collection<JobInstance> getJobInstances(final String jobName, final int startIndex, final int pageSize);\n    @Override public Collection<JobExecution> getJobExecutions(final JobInstance jobInstance);\n    @Override public Collection<JobExecution> getJobExecutions(final JobInstance jobInstance, final int start, final int count);\n    @Override public JobExecution getJobExecution(final Long jobExecutionId);\n    @Override public JobInstance getJobInstance(final Long jobInstanceId);\n    @Override public void attachJobInstance(final JobExecution jobExecution);\n    @Override public void restartJobExecution(final Long jobExecutionId);\n    @Override public void stopJobExecution(final Long jobExecutionId);\n    @Override public void afterPropertiesSet();\n\n    private static final String JOB_NAME;\n    private static final String JOB_NAME_2;\n    private static final String JOB_NAME_3;\n    private static final String[] JOB_NAMES;\n    @InjectMocks\n    private DefaultJobService jobService;\n    @Mock\n    private JobOperator jobOperator;\n    @Mock\n    private JobRegistry jobRegistry;\n    @Mock\n    private JobExplorer jobExplorer;\n    @Mock\n    private LightminJobExecutionDao lightminJobExecutionDao;\n\n}\n\nclass DefaultJobServiceTest {\n\n    private static final String JOB_NAME;\n    private static final String JOB_NAME_2;\n    private static final String JOB_NAME_3;\n    private static final String[] JOB_NAMES;\n    @InjectMocks\n    private DefaultJobService jobService;\n    @Mock\n    private JobOperator jobOperator;\n    @Mock\n    private JobRegistry jobRegistry;\n    @Mock\n    private JobExplorer jobExplorer;\n    @Mock\n    private LightminJobExecutionDao lightminJobExecutionDao;\n\n    @Test\n    public void getLastJobParametersTest() {\n", "reference": "        final List<JobExecution> jobExecutions = new LinkedList<>();\n        final JobParameters jobParameters = new JobParametersBuilder().addLong(\"long\", 1L).addString(\"String\",\n                \"someString\").toJobParameters();\n        final JobExecution jobExecution = new JobExecution(1L, jobParameters, \"test\");\n        jobExecutions.add(jobExecution);\n        when(this.lightminJobExecutionDao.getJobExecutions(anyString(), anyInt(), anyInt())).thenReturn(jobExecutions);\n        final JobParameters result = this.jobService.getLastJobParameters(\"test\");\n        assertThat(result).isEqualTo(jobParameters);\n    }\n\n}", "prediction": "        final JobParameters jobParameters = new JobParameters();\n        when(lightminJobExecutionDao.getJobExecutions(JOB_NAME, 0, 1)).thenReturn(Collections.singletonList(new JobExecution()));\n        when(lightminJobExecutionDao.getJobExecutions(JOB_NAME_2, 0, 1)).thenReturn(Collections.singletonList(new JobExecution()));\n        when(lightminJobExecutionDao.getJobExecutions(JOB_NAME_3, 0, 1)).thenReturn(Collections.singletonList(new JobExecution()));\n        when(lightminJobExecutionDao.getJobExecutions(JOB_NAME_3, 0, 1)).thenReturn(Collections.singletonList(new JobExecution()));\n        when(lightminJobExecutionDao.getJobExecutions(JOB_NAME_3, 0, 1)).thenReturn(Collections.singletonList(new JobExecution()));\n        when(lightminJobExecutionDao.getJobExecutions(JOB_NAME_3, 0, 1)).thenReturn(Collections.singletonList(new JobExecution()));\n        when(lightminJobExecutionDao.getJobExecutions(JOB_NAME_3, 0, 1)).thenReturn(Collections.singletonList(new JobExecution()));\n        when(lightminJobExecutionDao.getJobExecutions(JOB_NAME_3, 0, 1)).thenReturn(Collections.singletonList(new JobExecution()));\n        when(lightminJobExecutionDao.getJobExecutions(JOB_NAME_3, 0, 1)).thenReturn(Collections.singletonList(new JobExecution()));\n        when(lightminJobExecutionDao.getJobExecutions(JOB_NAME_3, 0, 1)).thenReturn(Collections.singletonList(new JobExecution()));\n        when(lightminJobExecutionDao.getJobExecutions(JOB_NAME_3, 0, 1)).thenReturn(Collections.singletonList(new JobExecution()));\n        when(lightminJobExecutionDao.getJobExecutions(JOB_NAME_3, 0, 1)).thenReturn(Collections.singletonList(new JobExecution()));\n        when(lightminJobExecutionDao.getJobExecutions(JOB_NAME_3, 0, 1)).thenReturn(Collections.singletonList(new JobExecution()));\n        when(lightminJobExecutionDao.getJobExecutions(JOB_NAME_3, 0, 1)).thenReturn(Collections.singletonList(new JobExecution()));\n        when(lightminJobExecutionDao.getJobExecutions(JOB_NAME_3, 0, 1)).thenReturn(Collections.singletonList(new JobExecution()));\n        when(lightminJobExecutionDao.getJobExecutions(JOB_NAME_3, 0, 1)).thenReturn(Collections.singletonList(new JobExecution()));\n        when(lightminJobExecutionDao.getJobExecutions(JOB_NAME_3, 0, 1)).thenReturn(Collections.singletonList(new JobExecution()));\n        when(lightminJobExecutionDao.getJobExecutions(JOB_NAME_3, 0, 1)).thenReturn(Collections.singletonList(new JobExecution()));\n        when(lightminJobExecutionDao.getJobExecutions(JOB_NAME_3, 0, 1)).thenReturn(Collections.singletonList(new JobExecution()));\n        when(lightminJobExecutionDao.getJobExecutions(JOB_NAME_3, 0, 1)).thenReturn(Collections.singletonList(new JobExecution()));\n        when(lightminJobExecutionDao.getJobExecutions(JOB_NAME_3, 0, 1)).thenReturn(Collections.singletonList(new JobExecution()));\n        when(lightminJobExecutionDao.getJobExecutions(JOB_NAME_3, 0, 1)).thenReturn(Collections.singletonList(new JobExecution()));\n        when(lightminJobExecutionDao.getJobExecutions(JOB_NAME_3, 0, 1)).thenReturn(Collections.singletonList(new JobExecution()));\n        when(lightminJobExecutionDao.getJobExecutions(JOB_NAME_3, 0, 1)).thenReturn(Collections.singletonList(new JobExecution()));\n        when(lightminJobExecutionDao.getJobExecutions(JOB_NAME_3, 0, 1)).thenReturn(Collections.singletonList(new JobExecution()));\n        when(lightminJobExecutionDao.getJobExecutions(JOB_NAME_3, 0, 1)).thenReturn(Collections.singletonList(new JobExecution()));\n        when(lightminJobExecutionDao.getJobExecutions(JOB_NAME_3, 0, 1)).thenReturn(Collections.singletonList(new JobExecution()));\n        when(lightminJobExecutionDao.getJobExecutions(JOB_NAME_3, 0, 1)).thenReturn(Collections.singletonList(new JobExecution()));\n        when(lightminJobExecutionDao.getJobExecutions(JOB_NAME_3, 0, 1)).thenReturn(Collections.singletonList(new JobExecution()));\n        when(lightminJobExecutionDao.getJobExecutions(JOB_NAME_3, 0, 1)).thenReturn(Collections.singletonList(new JobExecution()));\n        when(lightminJobExecutionDao.getJobExecutions(JOB_NAME_3, 0, 1)).thenReturn(Collections.singletonList(new JobExecution()));\n        when(lightminJobExecutionDao.getJobExecutions(JOB_NAME_3, 0, 1)).thenReturn(Collections.singletonList(new JobExecution()));\n        when(lightminJobExecutionDao.getJobExecutions(JOB_NAME_3, 0, 1)).thenReturn(Collections.singletonList(new JobExecution()));\n        when(lightminJobExecutionDao.getJobExecutions(JOB_NAME_3, 0, 1)).thenReturn(Collections.singletonList(new JobExecution()));\n        when(lightminJobExecutionDao.getJobExecutions(JOB_NAME_3, 0, 1)).thenReturn(Collections.singletonList(new JobExecution()));\n        when(lightminJobExecutionDao.getJobExecutions(JOB_NAME_3, 0, 1)).thenReturn(Collections.singletonList(new JobExecution()));\n        when(lightminJobExecutionDao.getJobExecutions(JOB_NAME_3, 0, 1)).thenReturn(Collections.singletonList(new JobExecution()));\n        when(lightminJobExecutionDao.getJobExecutions(JOB_NAME_3, 0, 1)).thenReturn(Collections.singletonList(new JobExecution()));\n        when(lightminJobExecutionDao.getJobExecutions(JOB_NAME_3, 0, 1)).thenReturn(Collections.singletonList(new JobExecution()));\n        when(lightminJobExecutionDao.getJobExecutions(JOB_NAME_3, 0, 1)).thenReturn(Collections.singletonList(new Job", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "29603649_809", "part": [1, 1], "seq": [1, 1], "prompt": "class ChangeStatusCommand implements StubDescriptorModificationCommand {\n\n    @Override\n    public Map<String, StubDescriptor> modify(Map<String, StubDescriptor> stubDescriptors) {\n        Map<String, StubDescriptor> updated = new LinkedHashMap<>(stubDescriptors);\n        StubDescriptor selected = updated.get(groupName);\n        if (selected!= null) {\n            StubDescriptorAttributes attributes = selected.getAttributes();\n            attributes.setActive(nextStatus);\n            if (nextStatus) {\n                logger.info(urlAccessLogMessageAssembler.assembleMessage(request, groupName + \" stub configuration: Enabled\"));\n            } else {\n                logger.info(urlAccessLogMessageAssembler.assembleMessage(request, groupName + \" stub configuration: Disabled\"));\n            }\n        }\n        return updated;\n    }\n\n    public  ChangeStatusCommand(final boolean nextStatus, final String groupName, final HttpServletRequest request,\n            final UrlAccessLogMessageAssembler urlAccessLogMessageAssembler);\n\n    public String getGroupName();\n    public HttpServletRequest getRequest();\n    public boolean isNextStatus();\n\n    private static final String GROUPNAME_FIRST;\n    private Map<String, StubDescriptor> normalStubDescriptors;\n    private StubDescriptorAttributes attributes;\n    private StubDescriptor stubDescriptor;\n    @Mock\n    private HttpServletRequest request;\n    @Mock\n    private UrlAccessLogMessageAssembler urlAccessLogMessageAssembler;\n    private ChangeStatusCommand underTest;\n\n}\n\nclass ChangeStatusCommandTest {\n\n    private static final String GROUPNAME_FIRST;\n    private Map<String, StubDescriptor> normalStubDescriptors;\n    private StubDescriptorAttributes attributes;\n    private StubDescriptor stubDescriptor;\n    @Mock\n    private HttpServletRequest request;\n    @Mock\n    private UrlAccessLogMessageAssembler urlAccessLogMessageAssembler;\n    private ChangeStatusCommand underTest;\n\n    @Test\n    public void testSetStatusShouldDisableTheSelectedStubDescriptor() {\n", "reference": "        //GIVEN in setUp\n        normalStubDescriptors = new LinkedHashMap<>();\n        attributes = new StubDescriptorAttributes(GROUPNAME_FIRST, true);\n        stubDescriptor = new StubDescriptor(attributes, new ArrayList<DialogDescriptor>(), new ArrayList<InterceptorDescriptor>(), null);\n        normalStubDescriptors.put(GROUPNAME_FIRST, stubDescriptor);\n        //WHEN\n        underTest = new ChangeStatusCommand(false, GROUPNAME_FIRST, request, urlAccessLogMessageAssembler);\n        Map<String, StubDescriptor> result = underTest.modify(normalStubDescriptors);\n        //THEN\n        StubDescriptor resultDescriptor = result.get(GROUPNAME_FIRST);\n        Assert.assertNotNull(resultDescriptor);\n        boolean resultAttribute = resultDescriptor.getAttributes().isActive();\n        Assert.assertFalse(resultAttribute);\n    }\n\n}", "prediction": "        underTest.modify(normalStubDescriptors);\n        verify(attributes).setActive(false);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "29774200_74", "part": [1, 1], "seq": [1, 1], "prompt": "class TeamCityConnection implements BuildCapability, TestCapability, ViewCapability {\n\n    @Override\n    public String getMavenId(SoftwareProjectId softwareProjectId) throws ProjectNotFoundException,\n            MavenIdNotFoundException {\n        checkConnected();\n        checkSoftwareProjectId(softwareProjectId);\n        String projectId = softwareProjectId.getProjectId();\n        try {\n            return teamCity.findMavenId(projectId);\n        } catch (fr.norad.visuwall.providers.common.MavenIdNotFoundException e) {\n            throw new MavenIdNotFoundException(\"Cannot find maven id for \" + softwareProjectId, e);\n        }\n    }\n\n    @Override public void connect(String url, String login, String password);\n    @Override public void close();\n    @Override public String getDescription(SoftwareProjectId softwareProjectId);\n    @Override public SoftwareProjectId identify(ProjectKey projectKey);\n    @Override public List<String> getBuildIds(SoftwareProjectId softwareProjectId);\n    @Override public Map<SoftwareProjectId, String> listSoftwareProjectIds();\n    @Override public BuildState getBuildState(SoftwareProjectId softwareProjectId, String buildId);\n    @Override public Date getEstimatedFinishTime(SoftwareProjectId softwareProjectId, String buildId);\n    @Override public boolean isBuilding(SoftwareProjectId softwareProjectId, String buildId);\n    @Override public String getLastBuildId(SoftwareProjectId softwareProjectId);\n    @Override public String getName(SoftwareProjectId softwareProjectId);\n    @Override public boolean isClosed();\n    @Override public BuildTime getBuildTime(SoftwareProjectId softwareProjectId, String buildId);\n    @Override public boolean isProjectDisabled(SoftwareProjectId softwareProjectId);\n    @Override public List<Commiter> getBuildCommiters(SoftwareProjectId softwareProjectId, String buildId);\n    @Override public TestResult analyzeUnitTests(SoftwareProjectId softwareProjectId);\n    @Override public TestResult analyzeIntegrationTests(SoftwareProjectId softwareProjectId);\n    private void addBuildIds(Set<String> numbers, TeamCityBuildType buildType);\n    private void checkBuildId(String buildId);\n    private void checkConnected();\n    private void checkSoftwareProjectId(SoftwareProjectId softwareProjectId);\n    @Override public List<SoftwareProjectId> findSoftwareProjectIdsByViews(List<String> views);\n    @Override public List<String> findViews();\n    @Override public List<String> findProjectNamesByView(String viewName);\n    private void checkViewName(String viewName);\n\n     TeamCityConnection teamCityConnection;\n    @Mock TeamCity teamCity;\n\n}\n\nclass TeamCityConnectionTest {\n\n     TeamCityConnection teamCityConnection;\n    @Mock TeamCity teamCity;\n\n    @Test\n    public void should_throw_exception_when_getting_maven_id() throws Exception {\n", "reference": "        SoftwareProjectId softwareProjectId = softwareProjectId();\n        String projectId = softwareProjectId.getProjectId();\n        when(teamCity.findMavenId(projectId)).thenReturn(\"groupId:artifactId\");\n\n        String mavenId = teamCityConnection.getMavenId(softwareProjectId);\n\n        assertEquals(\"groupId:artifactId\", mavenId);\n    }\n\n}", "prediction": "        SoftwareProjectId softwareProjectId = new SoftwareProjectId(\"project\", \"1\");\n        when(teamCity.findMavenId(softwareProjectId.getProjectId())).thenThrow(new fr.norad.visuwall.providers.common.MavenIdNotFoundException(\"\"));\n        try {\n            teamCityConnection.getMavenId(softwareProjectId);\n            fail(\"Should throw exception\");\n        } catch (MavenIdNotFoundException e) {\n            assertEquals(\"Cannot find maven id for \" + softwareProjectId, e.getMessage());\n        }\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "30562287_2", "part": [1, 1], "seq": [1, 1], "prompt": "class CalendarWeekDayFormatter implements WeekDayFormatter {\n\n  @Override public CharSequence format(final DayOfWeek dayOfWeek) {\n    return dayOfWeek.getDisplayName(TextStyle.SHORT, Locale.getDefault());\n  }\n\n  public CalendarWeekDayFormatter formatter;\n  public Locale defaultLocaleOriginal;\n\n}\n\nclass CalendarWeekDayFormatterTest {\n\n  public CalendarWeekDayFormatter formatter;\n  public Locale defaultLocaleOriginal;\n\n  @Test public void testFormattedDayOfWeek_Tuesday() {\n", "reference": "    assertThat(formatter.format(DayOfWeek.TUESDAY).toString(), is(\"Tue\"));\n  }\n\n}", "prediction": "    assertThat(formatter.format(DayOfWeek.TUESDAY)).isEqualTo(\"Tu\");\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "30593072_11", "part": [1, 1], "seq": [1, 1], "prompt": "class ByteUtil {\n\n    public static boolean isInteger(final byte[] asciiBuffer, final int offset, final int length)\n    {\n        for (int i = 0; i < length; i++)\n        {\n            if (!isAsciiDigit(asciiBuffer[offset + i]))\n            {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    public static void writeLongAsAscii(final byte[] outputBuffer, final int offset, final long valueParam);\n    public static boolean isAsciiDigit(final byte asciiCharacter);\n    public static String formatIntAsIpAddress(final int address);\n    public static void formatIntAsIpAddress(final StringBuilder buffer, final int address);\n    public static long packLongWithUnsignedShortInts(final int int1, final int int2, final int int3, final int int4);\n    public static boolean isEqual(final byte[] lhs, final int lhsOffset, final byte[] rhs, final int rhsOffset, final int length);\n    public static int readIntFromAscii(final byte[] asciiBuffer, final int offset, final int length);\n    public static long readLongFromAscii(final byte[] asciiBuffer, final int offset, final int length);\n    public static void replace(final byte[] buffer, final int offset, final int length,\n                               final byte target, final byte replacement);\n    public static void asciiEncode(final CharSequence chars, final int charOffset,\n                                   final byte[] buffer, final int bufferOffset, final int length);\n    private static void checkUnsignedShort(final int value);\n\n}\n\nclass ByteUtilTest {\n\n        @Test\n        public void shouldConfirmIsNotIntegerValue() throws UnsupportedEncodingException\n        {\n", "reference": "            final byte[] bytes = \"1;3\".getBytes(StandardCharsets.US_ASCII);\n            assertFalse(ByteUtil.isInteger(bytes, 0, bytes.length));\n        }\n\n}", "prediction": "            final byte[] buffer = \"1234567890\".getBytes(\"UTF-8\");\n            assertFalse(ByteUtil.isInteger(buffer, 0, buffer.length));\n        }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "30616178_2", "part": [1, 1], "seq": [1, 1], "prompt": "class RadixTrie {\n\n  static <T> Builder<T> builder() {\n    return new Builder<T>();\n  }\n\n    RadixTrie(final Node<T> root);\n\n   T lookup(final CharSequence path);\n   T lookup(final CharSequence path, final Captor captor);\n   int captures();\n   Captor captor();\n  static Captor captor(final int captures);\n  @SuppressWarnings(\"UnusedParameters\") static Builder<T> builder(Class<T> clazz);\n  private static String prefixes(Node<T> node);\n  @Override public String toString();\n\n  @Rule public ExpectedException exception;\n\n}\n\nclass RadixTrieTest {\n\n  @Rule public ExpectedException exception;\n\n  @Test(expected = IllegalArgumentException.class)\n  public void verifyNonAsciiInsertThrows() {\n", "reference": "    RadixTrie.builder(String.class).insert(\"\" + (char) 128, \"foo\");\n  }\n\n}", "prediction": "    RadixTrie.builder().insert(\"a\", \"a\");\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "30619741_23", "part": [1, 1], "seq": [1, 1], "prompt": "class ClusterMicroserviceProvider implements MicroserviceProvider, ClusterSilverService {\n\n   @Override\n   public Set<Object> lookupMicroservice(final MicroserviceMetaData metaData) {\n      try {\n         Set<Address> addressesForMetadata = alreadyQueriedAddresses.getOrDefault(metaData, new HashSet<>());\n         this.sender.sendToClusterAsync(metaData, addressesForMetadata,\n               new FutureListenerHelper<MicroserviceSearchResponse>(rspList -> {\n                  try {\n                     RspList<MicroserviceSearchResponse> responseRspList = rspList.get(10, TimeUnit.SECONDS);\n                     log.info(\"Response retrieved!  {}\", responseRspList);\n                     Collection<Rsp<MicroserviceSearchResponse>> result = responseRspList.values();\n                     if (log.isTraceEnabled()) {\n                        log.trace(\"Size of a responses is : {} \", responseRspList.getResults().size());\n                     }\n                     result.stream().filter(Rsp::hasException).forEach(rsp -> log.error(\"Exception was thrown during lookup on node: \" + rsp.getSender(), rsp.getException()));\n\n                     Set<ServiceHandle> remoteServiceHandles = result.stream()\n                                                                    .filter(rsp -> rsp.wasReceived() &&!rsp.hasException() && rsp.getValue().getResult().canBeUsed())\n                                                                    .map((rsp) -> new RemoteServiceHandle(rsp.getSender(), rsp.getValue().getHandle(), sender, metaData))\n                                                                    .collect(Collectors.toSet());\n                     // this is to save jgroups traffic for a given metadata\n                     addressesForMetadata.addAll(responseRspList.values().stream().map(Rsp::getSender).collect(Collectors.toSet()));\n                     alreadyQueriedAddresses.put(metaData, addressesForMetadata);\n                     this.remoteServiceHandlesStore.addHandles(metaData, remoteServiceHandles);\n                  } catch (Throwable e) {\n                     log.error(\"Error while looking up microservices.\", e);\n                  }\n\n               }));\n         // If this is first query for the metadata we should wait for a response\n         if (addressesForMetadata.isEmpty() &&!sender.isEmptyCluster()) {\n            Thread.sleep(timeout);\n         }\n\n         return this.remoteServiceHandlesStore.getServices(metaData);\n      } catch (Throwable e) {\n         log.error(\"Error while looking up microservices.\", e);\n         return emptySet();\n      }\n   }\n\n   @Override public void initialize(final Context context);\n   @Override public Context getContext();\n   @Override public void run();\n   @Override public Set<Object> lookupLocalMicroservice(final MicroserviceMetaData metaData);\n\n   public static final RemoteServiceHandlesStore REMOTE_SERVICE_HANDLES_STORE;\n   @Tested\n   private ClusterMicroserviceProvider clusterMicroserviceProvider;\n   @Injectable\n   private RemoteServiceHandlesStore store;\n   @Injectable\n   private JgroupsMessageSender sender;\n\n}\n\nclass ClusterMicroserviceProviderTest {\n\n   public static final RemoteServiceHandlesStore REMOTE_SERVICE_HANDLES_STORE;\n   @Tested\n   private ClusterMicroserviceProvider clusterMicroserviceProvider;\n   @Injectable\n   private RemoteServiceHandlesStore store;\n   @Injectable\n   private JgroupsMessageSender sender;\n\n   @Test\n   public void testLookupMicroservice() throws Exception {\n", "reference": "      Set<ServiceHandle> mockHandles = Util.createSetFrom(Util.createHandle(1), Util.createHandle(2));\n      Set<Object> services = Util.createSetFrom(new Object(), new Object());\n\n      new Expectations() {{\n         sender.sendToClusterAsync(META_DATA, (Set<Address>) any, (FutureListener<RspList<MicroserviceSearchResponse>>) any);\n         times = 1;\n         result = mockHandles;\n         store.getServices(META_DATA);\n         result = services;\n         times = 1;\n\n      }};\n      Set<Object> objects = clusterMicroserviceProvider.lookupMicroservice(META_DATA);\n      assertThat(objects).isNotEmpty().isEqualTo(services);\n   }\n\n}", "prediction": "      MicroserviceMetaData metaData = new MicroserviceMetaData(\"test\", \"1.0.0\");\n      Set<Object> handles = clusterMicroserviceProvider.lookupMicroservice(metaData);\n      assertThat(handles).isNotEmpty();\n   }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "31208159_0", "part": [1, 1], "seq": [1, 1], "prompt": "class CommentsPresenter implements ReplyView.Listener, CommentsAdapter.Listener, LoaderManager.LoaderCallbacks<Cursor> {\n\n    public boolean onOptionsItemSelected(MenuItem item) {\n\n        switch (item.getItemId()) {\n            case R.id.action_bookmark:\n                if (item.isChecked()) {\n                    onBookmarkUnselected(item);\n                } else {\n                    onBookmarkSelected(item);\n                }\n                return true;\n            case android.R.id.home:\n                activity.finish();\n                return true;\n            default:\n                return false;\n        }\n\n    }\n\n    public  CommentsPresenter(HNewsActivity activity, SwipeRefreshLayout.OnRefreshListener refreshListener);\n\n    private Story getStory();\n    public void onCreate();\n    public void onPostCreate(boolean online);\n    public void onCreateOptionsMenu(Menu menu);\n    public void onBookmarkUnselected(MenuItem item);\n    public void onBookmarkSelected(MenuItem item);\n    private void setupHeaderView();\n    private void setupSnackbar();\n    private void setupCommentsView();\n    private void setupReplyListener();\n    private void loadComments();\n    private void showReplyViewForStory();\n    public void showReplyViewForComment(Long commentId);\n    private void showReplyView();\n    private void hideReplyView();\n    private void checkBookmarkMenuItem(MenuItem bookmarks);\n    private void uncheckBookmarkMenuItem(MenuItem bookmarks);\n    private void showAddedBookmarkSnackbar(final CommentsOperator commentsOperator, final Story story);\n    private void showRemovedBookmarkSnackbar(final CommentsOperator commentsOperator, final Story story);\n    public void showNotImplemented();\n    public void showLoginExpired();\n    public void showContentUpdating();\n    @Override public void onReplyCancelled();\n    @Override public void onReplySuccessful();\n    @Override public void onLoginExpired();\n    @Override public void onCommentReplyAction(Long id);\n    @Override public void onCommentVoteAction(Long id);\n    @Override public Loader<Cursor> onCreateLoader(int id, Bundle args);\n    @Override public void onLoadFinished(Loader<Cursor> loader, Cursor data);\n    @Override public void onLoaderReset(Loader<Cursor> loader);\n    public void hideRefreshAnimation();\n    public void onRefresh(boolean isOnline);\n    public void onBackPressed();\n    public boolean inReplyMode();\n\n    @Mock CommentsActivity activity;\n    @Mock SwipeRefreshLayout.OnRefreshListener refreshListener;\n    @Mock MenuItem menuItem;\n    @Mock CommentsView commentsView;\n     CommentsPresenter commentsPresenter;\n\n}\n\nclass CommentsPresenterTest {\n\n    @Mock CommentsActivity activity;\n    @Mock SwipeRefreshLayout.OnRefreshListener refreshListener;\n    @Mock MenuItem menuItem;\n    @Mock CommentsView commentsView;\n     CommentsPresenter commentsPresenter;\n\n    @Test\n    public void removesBookmarkWhenBookmarkItemWasSelected() {\n", "reference": "        when(menuItem.getItemId()).thenReturn(R.id.action_bookmark);\n        when(menuItem.isChecked()).thenReturn(true);\n\n        commentsPresenter.onOptionsItemSelected(menuItem);\n\n        verify(menuItem).setIcon(R.drawable.ic_bookmark_outline_white);\n        verify(menuItem).setChecked(false);\n    }\n\n}", "prediction": "        commentsPresenter.onBookmarkSelected(menuItem);\n\n        verify(menuItem).setChecked(true);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "31234709_18", "part": [1, 1], "seq": [1, 1], "prompt": "class BaseServerListResponse extends ArrayList<BaseServerResponse> {\n\n    public List<Exception> listExceptions() {\n        return\n            this\n               .stream()\n               .filter(this::isJobNotQueued)\n               .map(this::errorMessage)\n               .map(ClcClientException::new)\n               .collect(toList());\n    }\n\n    public  BaseServerListResponse(int initialCapacity);\n    public  BaseServerListResponse();\n    public  BaseServerListResponse(Collection<? extends BaseServerResponse> collection);\n\n    private boolean isJobNotQueued(BaseServerResponse r);\n    private String errorMessage(BaseServerResponse response);\n    public ClcException summaryException();\n    public boolean hasErrors();\n\n     BaseServerListResponse response;\n\n}\n\nclass BaseServerListResponseTest {\n\n     BaseServerListResponse response;\n\n    @Test\n    public void testListExceptions_onlyNotQueued() throws Exception {\n", "reference": "        response = prepareResponseList(basicServerResponse(\"VA1ALTDSRV101\").queued(false));\n\n        List<Exception> errors = response.listExceptions();\n\n        assertEquals(errors.size(), 1);\n        assertContains(firstErrorMessage(errors), \"VA1ALTDSRV101\", \"not queued\");\n    }\n\n}", "prediction": "        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false, \"error\"));\n        response.add(new BaseServerResponse(false,", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "31634402_0", "part": [1, 1], "seq": [1, 1], "prompt": "class FluxBuilder {\n\n    public static boolean isPrimitiveNumber(Class clazz){\n        return clazz.isPrimitive() &&!clazz.equals(boolean.class);\n    }\n\n    public static Config buildConfig(TopologyDef topologyDef);\n    static StormTopology buildTopology(ExecutionContext context);\n    private static Method findGetTopologyMethod(Object topologySource, String methodName);\n    private static void buildStreamDefinitions(ExecutionContext context, TopologyBuilder builder);\n    private static void applyProperties(ObjectDef bean, Object instance, ExecutionContext context);\n    private static Field findPublicField(Class clazz, String property, Object arg);\n    private static Method findSetter(Class clazz, String property, Object arg);\n    private static String toSetterName(String name);\n    private static List<Object> resolveReferences(List<Object> args, ExecutionContext context);\n    private static Object buildObject(ObjectDef def, ExecutionContext context);\n    private static StormTopology buildExternalTopology(ObjectDef def, ExecutionContext context);\n    private static CustomStreamGrouping buildCustomStreamGrouping(ObjectDef def, ExecutionContext context);\n    private static void buildComponents(ExecutionContext context);\n    private static void buildSpouts(ExecutionContext context, TopologyBuilder builder);\n    private static IRichSpout buildSpout(SpoutDef def, ExecutionContext context);\n    private static void buildBolts(ExecutionContext context);\n    private static Constructor findCompatibleConstructor(List<Object> args, Class target);\n    public static void invokeConfigMethods(ObjectDef bean, Object instance, ExecutionContext context);\n    private static Method findCompatibleMethod(List<Object> args, Class target, String methodName);\n    private static Object[] getArgsWithListCoercian(List<Object> args, Class[] parameterTypes);\n    private static boolean canInvokeWithArgs(List<Object> args, Class[] parameterTypes);\n\n}\n\nclass FluxBuilderTest {\n\n    @Test\n    public void testIsPrimitiveNumber() throws Exception {\n", "reference": "        assertTrue(FluxBuilder.isPrimitiveNumber(int.class));\n        assertFalse(FluxBuilder.isPrimitiveNumber(boolean.class));\n        assertFalse(FluxBuilder.isPrimitiveNumber(String.class));\n    }\n\n}", "prediction": "        assertTrue(FluxBuilder.isPrimitiveNumber(int.class));\n        assertTrue(FluxBuilder.isPrimitiveNumber(Integer.class));\n        assertTrue(FluxBuilder.isPrimitiveNumber(long.class));\n        assertTrue(FluxBuilder.isPrimitiveNumber(Long.class));\n        assertTrue(FluxBuilder.isPrimitiveNumber(float.class));\n        assertTrue(FluxBuilder.isPrimitiveNumber(Float.class));\n        assertTrue(FluxBuilder.isPrimitiveNumber(double.class));\n        assertTrue(FluxBuilder.isPrimitiveNumber(Double.class));\n        assertTrue(FluxBuilder.isPrimitiveNumber(short.class));\n        assertTrue(FluxBuilder.isPrimitiveNumber(Short.class));\n        assertTrue(FluxBuilder.isPrimitiveNumber(byte.class));\n        assertTrue(FluxBuilder.isPrimitiveNumber(Byte.class));\n        assertTrue(FluxBuilder.isPrimitiveNumber(char.class));\n        assertTrue(FluxBuilder.isPrimitiveNumber(Character.class));\n        assertFalse(FluxBuilder.isPrimitiveNumber(String.class));\n        assertFalse(FluxBuilder.isPrimitiveNumber(Object.class));\n        assertFalse(FluxBuilder.isPrimitiveNumber(Void.class));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "31758882_0", "part": [1, 1], "seq": [1, 1], "prompt": "class ChannelInput {\n\n    public void read(byte[] dst, int offset, int length) throws IOException {\n        for (; length > 0; ) {\n            int remaining = buffer.remaining();\n            if (length <= remaining) {\n                buffer.get(dst, offset, length);\n                break;\n            }\n            buffer.get(dst, offset, remaining);\n            offset += remaining;\n            length -= remaining;\n            fill();\n        }\n    }\n\n      ChannelInput(FileChannel channel, int position, int bufferSize);\n\n    private void fill();\n    public int position();\n    public void position(int newPosition);\n    public byte readByte();\n    public short readShort();\n    public int readInt();\n    public long readLong();\n    public void skip(int bytes);\n\n   private static File dir;\n\n}\n\nclass ChannelInputTest {\n\n   private static File dir;\n\n   @Test\n    public void testRead() throws IOException {\n", "reference": "        File file = new File(dir, \"read.dat\");\n        file.delete();\n\n        DataOutputStream out = new DataOutputStream(new FileOutputStream(file));\n        out.writeByte(0x23);\n        out.writeShort(0x1234);\n        out.writeInt(0x12345678);\n        out.writeLong(0x1234567898765432L);\n        // total 1 + 2 + 4 + 8 = 15 bytes\n\n        // put a short across a buffer boundary\n        for (int i = 0; i < 8192 - 15 - 1; i++) out.write(0);\n        out.writeShort(0x4321);\n\n        // put an int across the next buffer boundary\n        for (int i = 0; i < 8192 - 1 - 3; i++) out.write(0);\n        out.writeInt(0x1a2b3c4d);\n\n        // put a long across the next buffer boundary\n        for (int i = 0; i < 8192 - 1 - 7; i++) out.write(0);\n        out.writeLong(0x1122334455667788L);\n\n        // now write several buffers worth of data\n        for (int i = 0; i < 8192 * 3; i++) out.writeByte(i);\n\n        out.close();\n\n        FileInputStream ins = new FileInputStream(file);\n        ChannelInput in = new ChannelInput(ins.getChannel(), 0, 8192);\n\n        assertEquals((byte)0x23, in.readByte());\n        assertEquals((short)0x1234, in.readShort());\n        assertEquals(0x12345678, in.readInt());\n        assertEquals(0x1234567898765432L, in.readLong());\n\n        in.skip(8192 - 15 - 1);\n        assertEquals((short)0x4321, in.readShort());\n\n        in.skip(8192 - 1 - 3);\n        assertEquals(0x1a2b3c4d, in.readInt());\n\n        in.skip(8192 - 1 - 7);\n        assertEquals(0x1122334455667788L, in.readLong());\n\n        byte[] data = new byte[8192 * 3];\n        in.read(data, 0, data.length);\n        for (int i = 0; i < data.length; i++) {\n            assertEquals((byte)i, data[i]);\n        }\n\n        ins.close();\n   }\n\n}", "prediction": "        File file = new File(dir, \"test.txt\");\n        FileChannel channel = new RandomAccessFile(file, \"rw\").getChannel();\n        ChannelInput input = new ChannelInput(channel, 0, 1024);\n        byte[] dst = new byte[1024];\n        input.read(dst, 0, 1024);\n        channel.close();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "32135981_10", "part": [1, 1], "seq": [1, 1], "prompt": "class MavenEchoOutput implements EchoOutput {\n\n    @Override\n    public void error(String content) {\n        wrappedLog.error(content);\n    }\n\n    public  MavenEchoOutput(Log wrappedLog);\n\n    @Override public void fail(String content);\n    @Override public void warning(String content);\n    @Override public void info(String content);\n    @Override public void debug(String content);\n    @SuppressWarnings(\"unchecked\") private void throwAsUnchecked(Exception e);\n\n    private final Log logMock;\n    private MavenEchoOutput mavenEchoOutput;\n    @Rule\n    public final ExpectedException expectedException;\n\n}\n\nclass MavenEchoOutputTest {\n\n    private final Log logMock;\n    private MavenEchoOutput mavenEchoOutput;\n    @Rule\n    public final ExpectedException expectedException;\n\n    @Test\n    public void errorShouldOutputErrorLevel() {\n", "reference": "        mavenEchoOutput.error(\"Gurka\");\n\n        verify(logMock).error(\"Gurka\");\n        verifyNoMoreInteractions(logMock);\n    }\n\n}", "prediction": "        mavenEchoOutput.error(\"error\");\n        verify(logMock).error(\"error\");\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "32139352_2", "part": [1, 1], "seq": [1, 1], "prompt": "class OpenTipBotService {\n\n    public void processNewOpenTipBotCommands() throws OpenTipBotServiceException {\n        logger.debug(\"Start command processing\");\n\n        processTips(opentipbotCommandRepository.findByOpenTipBotCommandStatusAndOpenTipBotCommandEnumOrderByCreationTimeAsc(OpenTipBotCommandStatus.NEW, OpenTipBotCommandEnum.TIP));\n\n        processTips(opentipbotCommandRepository.findByOpenTipBotCommandStatusAndOpenTipBotCommandEnumOrderByCreationTimeAsc(OpenTipBotCommandStatus.NEW, OpenTipBotCommandEnum.TIP_RAIN));\n\n        processTips(opentipbotCommandRepository.findByOpenTipBotCommandStatusAndOpenTipBotCommandEnumOrderByCreationTimeAsc(OpenTipBotCommandStatus.NEW, OpenTipBotCommandEnum.TIP_RANDOM));\n\n        processWithdrawals(opentipbotCommandRepository.findByOpenTipBotCommandStatusAndOpenTipBotCommandEnumOrderByCreationTimeAsc(OpenTipBotCommandStatus.NEW, OpenTipBotCommandEnum.WITHDRAW));\n\n        processReceiverNotifications(opentipbotCommandRepository.findByOpenTipBotCommandStatusAndOpenTipBotCommandEnumOrderByCreationTimeAsc(OpenTipBotCommandStatus.NEW, OpenTipBotCommandEnum.NOTIFY_RECEIVER));\n\n        processErrorNotifications(opentipbotCommandRepository.findByOpenTipBotCommandStatusAndOpenTipBotCommandEnumOrderByCreationTimeAsc(OpenTipBotCommandStatus.NEW, OpenTipBotCommandEnum.NOTIFY_ERROR));\n\n        processFavs(opentipbotCommandRepository.findByOpenTipBotCommandStatusAndOpenTipBotCommandEnumOrderByCreationTimeAsc(OpenTipBotCommandStatus.NEW, OpenTipBotCommandEnum.FAV));\n\n        logger.debug(\"Operation Complete\");\n\n    }\n\n    public TwitterTemplate getTwitterTemplate();\n    @PostConstruct public void init();\n    public void handleNewTweets();\n    public void handleNewTweet(Tweet tweet);\n    private void processFavs(List<OpenTipBotCommand> commands);\n    private void processErrorNotifications(List<OpenTipBotCommand> commands);\n    private void processReceiverNotifications(List<OpenTipBotCommand> commands);\n    private void processWithdrawals(List<OpenTipBotCommand> commands);\n    private void processTips(List<OpenTipBotCommand> commands);\n    private void notifyReceiver(OpenTipBotCommand opentipbotCommand);\n    private void favOriginalMessage(OpenTipBotCommand opentipbotCommand);\n     boolean validateWithdrawalCommand(OpenTipBotCommand opentipbotCommand);\n    private void notifyValidationError(OpenTipBotCommand opentipbotCommand, String errorMessage);\n     String getRandomTipNotificationMessage(String fromUserName, String toUserName, double amount);\n     boolean validateTipCommand(OpenTipBotCommand opentipbotCommand);\n    private String validateUserExists(String toUserName);\n     boolean validateMinimumAmount(double amount);\n     boolean validateUserRegistration(String userName);\n     boolean validateSufficientBalance(double amount, String userName);\n     boolean validateSufficientBalanceToWIthdraw(String userName);\n     void persistOpenTipBotCommands(List<Tweet> incomingTweets);\n     String findRandomFollower(long fromUser);\n     List<String> getRainUsernames(String userNames);\n     List<Tweet> filterTweets(List<Tweet> incomingTweets);\n     List<Tweet> filterNotProcessedTweets(List<Tweet> incomingTweets);\n     Double getCoinAmout(String amount);\n     List<Tweet> filterValidTweets(List<Tweet> incomingTweets);\n    private String removeLineSeparators(String str);\n    public List<OpenTipBotCommand> getLastTips();\n    private static String formatDouble(double d);\n\n    @Autowired\n    protected OpenTipBotService opentipbotService;\n\n}\n\nclass OpenTipBotServiceTest  {\n\n    @Autowired\n    protected OpenTipBotService opentipbotService;\n\n    @Test\n    public void processNewOpenTipBotCommandsTest()\n    {\n", "reference": "        try {\n            opentipbotService.processNewOpenTipBotCommands();\n        } catch (OpenTipBotServiceException e) {\n            e.printStackTrace();\n        }\n    }\n\n}", "prediction": "        opentipbotService.processNewOpenTipBotCommands();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "32143635_14", "part": [1, 1], "seq": [1, 1], "prompt": "class NSSpeechSynthesizer extends NSObject {\n\n    public NSSpeechStatus getStatus() {\n        return new NSSpeechStatus(Rococoa.cast(getProperty(SpeechProperty.StatusProperty), NSMutableDictionary.class));\n    }\n\n    public static NSSpeechSynthesizer synthesizerWithVoiceIdentifier(String voiceIdentifer);\n    public static NSSpeechSynthesizer synthesizerWithVoice(NSVoice voice);\n    public static NSVoice defaultVoice();\n    public static List<NSVoice> availableVoices();\n    public static boolean isAnyApplicationSpeaking();\n    public synchronized void setDelegate(final NSSpeechSynthesizerDelegate delegate);\n    public synchronized NSSpeechSynthesizerDelegate getDelegate();\n    public String opcodeToPhoneme(short opcode);\n    public static String createSyncPoint(int marker);\n    public NSObject getProperty(SpeechProperty property);\n    public void setProperty(SpeechProperty property, NSObject value);\n    public void addSpeechDictionary(NSSpeechDictionary dictionary);\n    public NSSpeechError getError();\n    public NSSpeechMode getInputMode();\n    public void setInputMode(NSSpeechMode mode);\n    public NSSpeechMode getCharacterMode();\n    public void setCharacterMode(NSSpeechMode mode);\n    public NSSpeechMode getNumberMode();\n    public void setNumberMode(NSSpeechMode mode);\n    public NSSpeechSynthesizerInfo getSynthesizerInfo();\n    public float getPitchBase();\n    public void setPitchBase(float baselinePitch);\n    public float getPitchMod();\n    public void setPitchMod(float modulation);\n    public List<NSSpeechPhonemeInfo> getPhonemeInfo();\n    public int getRecentSync();\n    public boolean setVoice(NSVoice voice);\n    public NSVoice getVoice();\n    public void setCommandDelimiter(NSSpeechCommand delimiters);\n    public void reset();\n    public void setOutputToFileURL(URI uri);\n    public boolean startSpeakingStringToURL(String text, URI uri);\n    abstract void addSpeechDictionary(NSDictionary speechDictionary);\n    public abstract void continueSpeaking();\n    abstract ID delegate();\n    abstract NSSpeechSynthesizer initWithVoice(String voiceIdentifier);\n    public abstract boolean isSpeaking();\n    abstract NSObject objectForProperty_error(NSString speechProperty, ObjCObjectByReference out_error);\n    abstract boolean setObject_forProperty_error(NSObject object, NSString speechProperty, ObjCObjectByReference out_error);\n    public abstract void pauseSpeakingAtBoundary(NSSpeechBoundary boundary);\n    public abstract String phonemesFromText(String text);\n    public abstract float rate();\n    abstract void setDelegate(ID delegate);\n    public abstract void setRate(float rate);\n    public abstract void setUsesFeedbackWindow(boolean useFeedbackWindow);\n    public abstract boolean setVoice(String voiceIdentifier);\n    public abstract void setVolume(float volume);\n    public abstract boolean startSpeakingString(String text);\n    abstract boolean startSpeakingString_toURL(NSString text, NSURL url);\n    public abstract void stopSpeaking();\n    public abstract void stopSpeakingAtBoundary(NSSpeechBoundary boundary);\n    public abstract boolean usesFeedbackWindow();\n    abstract String voice();\n    public String getVoiceIdentifier();\n    abstract float volume();\n    public float getVolume();\n\n    private static final int TIME_TO_WAIT;\n    private NSAutoreleasePool pool;\n\n}\n\nclass NSSpeechSynthesizerTest {\n\n    private static final int TIME_TO_WAIT;\n    private NSAutoreleasePool pool;\n\n    @Test\n    public void testGetStatus() {\n", "reference": "        NSSpeechSynthesizer ss = NSSpeechSynthesizer.synthesizerWithVoice(null);\n        SynthesizerDelegate sd = new SynthesizerDelegate(ss);        \n        NSSpeechStatus status = ss.getStatus();\n        assertEquals(status.isOutputBusy(), ss.isSpeaking());\n        assertFalse(status.isOutputPaused());\n        assertEquals(\"Should have no characters left\", 0, status.getNumberOfCharactersLeft());\n        assertEquals(0, status.getPhonemeCode());\n        \n        ss.startSpeakingString(\"Status check\");\n        status = ss.getStatus();\n        assertEquals(status.isOutputBusy(), ss.isSpeaking());\n        assertFalse(status.isOutputPaused());\n        assertTrue(\"Should have characters left\", status.getNumberOfCharactersLeft() > 0);\n        //assertTrue(\"Opcode should not be zero\", status.getPhonemeCode() != 0); always zero... seems to have word granularity\n        sd.waitForSpeechDone(TIME_TO_WAIT, true);\n    }\n\n}", "prediction": "        NSSpeechSynthesizer synthesizer = NSSpeechSynthesizer.synthesizerWithVoiceIdentifier(\"com.apple.speech.synthesis.voice.Alex\");\n        NSSpeechStatus status = synthesizer.getStatus();\n        Assert.assertNotNull(status);\n        Assert.assertEquals(NSSpeechStatus.Ready, status.getStatus());\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "32177955_0", "part": [1, 1], "seq": [1, 1], "prompt": "class Snapshot {\n\n    public static Builder builder(Instant time, Snapshot other) {\n        return new Builder(time, other);\n    }\n\n    @SuppressWarnings(\"unused\") private  Snapshot();\n    public  Snapshot(Instant time);\n\n    public Optional<Long> getId();\n    public Optional<Long> getEventId();\n    public Instant getSnapshotTime();\n    public TeamTagMap getTeamTagMap();\n    public Instant getStartTime();\n    public Instant getEndTime();\n    public TeamStates getTeamStates();\n    public TeamStates getPublicTeamStates();\n    public String getStatusMessage();\n    public Status getStatus();\n    public int getUpdateFrequency();\n    public static Optional<Snapshot> loadForEvent(Connection connection, Event event);\n    public static Optional<Snapshot> loadLatest(Connection connection);\n    public static Optional<Snapshot> loadBefore(Connection connection, Instant time);\n    public void save(Connection connection);\n    public static void deleteAfter(Connection connection, Snapshot snapshot);\n\n    private ObjectMapper objectMapper;\n\n}\n\nclass TestSnapshot {\n\n    private ObjectMapper objectMapper;\n\n    @Test\n    public void testSerializeToJson_DefaultObject() throws Exception {\n", "reference": "        Snapshot snapshot = Snapshot.builder(Instant.EPOCH, null)\n                .withStartTime(Instant.EPOCH)\n                .withEndTime(Instant.EPOCH)\n                .build();\n        MatcherAssert.assertThat(objectMapper.writeValueAsString(snapshot),\n                SameJSONAs.sameJSONAs(\"{snapshotTime:0,startTime:0,endTime:0,teamTagMap:{},\" +\n                        \"teamStates:{},publicTeamStates:{},statusMessage:\\\"\\\",status:NoResults,updateFrequency:3}\"));\n    }\n\n}", "prediction": "        Snapshot snapshot = new Snapshot(Instant.now());\n        String json = objectMapper.writeValueAsString(snapshot);\n        assertThat(json, is(\"{\\\"snapshotTime\\\":\\\"\" + snapshot.getSnapshotTime().toString() + \"\\\"}\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "32796510_13", "part": [1, 1], "seq": [1, 1], "prompt": "class Token {\n\n    public int getCapturingGroupCount() {\n        return capturingGroupCount;\n    }\n\n    public  Token(String regex);\n    public  Token(String name, String regex);\n    public  Token(String name, String regex, String replacement);\n    public  Token(String name, String regex, MatchProcessor matchProcessor);\n\n    public String getName();\n    public String getRegex();\n    public MatchProcessor getMatchProcessor();\n    @Override public String toString();\n\n}\n\nclass TokenTest {\n\n    @Test\n    public void testGetCapturingGroupCount() throws Exception {\n", "reference": "        assertEquals(0, new Token(\"\").getCapturingGroupCount());\n        assertEquals(1, new Token(\"a(b)c\").getCapturingGroupCount());\n        assertEquals(0, new Token(\"a(?:b)c\").getCapturingGroupCount());\n    }\n\n}", "prediction": "        Token token = new Token(\"test\", \"test\");\n        assertEquals(0, token.getCapturingGroupCount());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "32866430_13", "part": [1, 1], "seq": [1, 1], "prompt": "class ModifyClientRequestV2 {\n\n  @JsonCreator public static ModifyClientRequestV2 forName(@JsonProperty(\"name\") String name) {\n    return new AutoValue_ModifyClientRequestV2(name);\n  }\n\n  @JsonProperty(\"name\") public abstract String name();\n\n}\n\nclass ModifyClientRequestV2Test {\n\n  @Test public void deserializesCorrectly() throws Exception {\n", "reference": "    ModifyClientRequestV2 modifyClientRequest = ModifyClientRequestV2.forName(\"client-name\");\n\n    assertThat(\n        fromJson(jsonFixture(\"fixtures/v2/modifyClientRequest.json\"), ModifyClientRequestV2.class))\n        .isEqualTo(modifyClientRequest);\n  }\n\n}", "prediction": "    ModifyClientRequestV2 request = ModifyClientRequestV2.forName(\"foo\");\n    assertThat(request.name()).isEqualTo(\"foo\");\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "32884360_98", "part": [1, 1], "seq": [1, 1], "prompt": "class TableDDL {\n\n    public static void createTable(DDLFunctions ddlFunctions,\n                                   Session session,\n                                   String defaultSchemaName,\n                                   CreateTableNode createTable,\n                                   QueryContext context) {\n        if (createTable.getQueryExpression()!= null)\n            throw new UnsupportedCreateSelectException();\n\n        TableName fullName = convertName(defaultSchemaName, createTable.getObjectName());\n        String schemaName = fullName.getSchemaName();\n        String tableName = fullName.getTableName();\n        AkibanInformationSchema ais = ddlFunctions.getAIS(session);\n\n        Table curTable = ais.getTable(fullName);\n        if((curTable!= null) &&\n           skipOrThrow(context, createTable.getExistenceCheck(), curTable, new DuplicateTableNameException(fullName))) {\n            return;\n        }\n\n        TypesTranslator typesTranslator = ddlFunctions.getTypesTranslator();\n        AISBuilder builder = new AISBuilder();\n        builder.getNameGenerator().mergeAIS(ais);\n        builder.table(schemaName, tableName);\n        Table table = builder.akibanInformationSchema().getTable(schemaName, tableName);\n        IndexNameGenerator namer = DefaultIndexNameGenerator.forTable(table);\n\n        cloneReferencedTables(defaultSchemaName,\n                              ddlFunctions.getAISCloner(),\n                              ais,\n                              builder.akibanInformationSchema(),\n                              createTable.getTableElementList());\n\n        // First pass: Columns.\n        int colpos = 0;\n        for (TableElementNode tableElement : createTable.getTableElementList()) {\n            if (tableElement instanceof ColumnDefinitionNode) {\n                addColumn (builder, typesTranslator,\n                           (ColumnDefinitionNode)tableElement, schemaName, tableName, colpos++);\n            }\n        }\n\n        // Second pass: GROUPING, PRIMARY, UNIQUE and INDEX.\n        // Requires the columns to have already been created.\n        for (TableElementNode tableElement : createTable.getTableElementList()) {\n            if (tableElement instanceof FKConstraintDefinitionNode) {\n                FKConstraintDefinitionNode fkdn = (FKConstraintDefinitionNode)tableElement;\n                if (fkdn.isGrouping()) {\n                    addJoin (builder, fkdn, defaultSchemaName, schemaName, tableName);\n                }\n                // else: regular FK, done in third pass below\n            }\n            else if (tableElement instanceof ConstraintDefinitionNode) {\n                addIndex (namer, builder, (ConstraintDefinitionNode)tableElement, schemaName, tableName, context);\n            } else if (tableElement instanceof IndexDefinitionNode) {\n                addIndex (namer, builder, (IndexDefinitionNode)tableElement, schemaName, tableName, context, ddlFunctions);\n            } else if (!(tableElement instanceof ColumnDefinitionNode)) {\n                throw new UnsupportedSQLException(\"Unexpected TableElement\", tableElement);\n            }\n        }\n\n        // Third pass: FOREIGN KEY.\n        // Separate pass as to not create extraneous indexes, if possible.\n        for (TableElementNode tableElement : createTable.getTableElementList()) {\n            if (tableElement instanceof FKConstraintDefinitionNode) {\n                FKConstraintDefinitionNode fkdn = (FKConstraintDefinitionNode)tableElement;\n                if (!fkdn.isGrouping()) {\n                    addForeignKey(builder, ddlFunctions.getAIS(session), fkdn, defaultSchemaName, schemaName, tableName);\n                }\n            }\n        }\n\n        setTableStorage(ddlFunctions, createTable, builder, tableName, table, schemaName);\n        builder.basicSchemaIsComplete();\n        builder.groupingIsComplete();\n        ddlFunctions.createTable(session, table);\n    }\n\n    private  TableDDL();\n\n    public static void dropTable(DDLFunctions ddlFunctions,\n                                  Session session, \n                                  String defaultSchemaName,\n                                  DropTableNode dropTable,\n                                  QueryContext context);\n    public static void dropGroup(DDLFunctions ddlFunctions,\n                                    Session session,\n                                    String defaultSchemaName,\n                                    DropGroupNode dropGroup,\n                                    QueryContext context);\n    private static void checkForeignKeyDropTable(Table table);\n    public static void renameTable(DDLFunctions ddlFunctions,\n                                    Session session,\n                                    String defaultSchemaName,\n                                    RenameNode renameTable);\n    public static void createTable(DDLFunctions ddlFunctions,\n                                   Session session,\n                                   String defaultSchemaName,\n                                   CreateTableNode createTable,\n                                   QueryContext context,\n                                   List<DataTypeDescriptor>  descriptors,\n                                   List<String> columnNames,\n                                   ServerSession server);\n    static void cloneReferencedTables(String defaultSchema,\n                                      AISCloner cloner,\n                                      AkibanInformationSchema curAIS,\n                                      final AkibanInformationSchema targetAIS,\n                                      TableElementList nodes);\n    private static void setTableStorage(DDLFunctions ddlFunctions, CreateTableNode createTable,\n                                        AISBuilder builder, String tableName, Table table, String schemaName);\n    static void setGroup(Table table, AISBuilder builder, String tableName, String schemaName);\n    public static void setStorage(DDLFunctions ddlFunctions,\n                                  HasStorage object, \n                                  StorageFormatNode storage);\n    static void addColumn(final AISBuilder builder, final TypesTranslator typesTranslator, final ColumnDefinitionNode cdn,\n                           final String schemaName, final String tableName, int colpos);\n    static void addColumn(final AISBuilder builder, final String schemaName,\n                           final String tableName, int colpos, final String columnName,\n                           final TypesTranslator typesTranslator, final DataTypeDescriptor d);\n    public static void setAutoIncrement(AISBuilder builder, String schema, String table, ColumnDefinitionNode cdn);\n    public static void setAutoIncrement(AISBuilder builder, String schemaName, String tableName, String columnName,\n                                        boolean defaultIdentity, long start, long increment);\n    static String[] getColumnDefault(ColumnDefinitionNode cdn, \n                                     String schemaName, String tableName);\n    static void addColumn(final AISBuilder builder, final TypesTranslator typesTranslator,\n                          final String schemaName, final String tableName, final String columnName,\n                          int colpos, DataTypeDescriptor sqlType,\n                          final String defaultValue, final String defaultFunction);\n    public static String addIndex(IndexNameGenerator namer, AISBuilder builder, ConstraintDefinitionNode cdn,\n                                  String schemaName, String tableName, QueryContext context);\n    public static String addIndex(IndexNameGenerator namer,\n                                  AISBuilder builder,\n                                  IndexDefinitionNode idn,\n                                  String schemaName,\n                                  String tableName,\n                                  QueryContext context,\n                                  DDLFunctions ddl);\n    public static TableName getReferencedName(String schemaName, FKConstraintDefinitionNode fkdn);\n    public static void addJoin(final AISBuilder builder, final FKConstraintDefinitionNode fkdn,\n                               final String defaultSchemaName, final String schemaName, final String tableName);\n    private static String[] columnNamesFromListOrPK(ResultColumnList list, PrimaryKey pk);\n    private static String generateTableIndex(IndexNameGenerator namer,\n            AISBuilder builder,\n            IndexDefinition id,\n            String indexName,\n            Table table,\n            QueryContext context,\n            DDLFunctions ddl\n            );\n    protected static void addForeignKey(AISBuilder builder,\n                                        AkibanInformationSchema sourceAIS,\n                                        FKConstraintDefinitionNode fkdn,\n                                        String defaultSchemaName,\n                                        String referencingSchemaName,\n                                        String referencingTableName);\n    private static ForeignKey.Action convertReferentialAction(int action);\n\n    private static TableName dropTable;\n    private static final String DEFAULT_SCHEMA;\n    private static final String DEFAULT_TABLE;\n    private static final String JOIN_TABLE;\n    private static final String JOIN_NAME;\n    protected SQLParser parser;\n    private DDLFunctionsMock ddlFunctions;\n    private TypesRegistry typesRegistry;\n    private TestAISBuilder builder;\n\n}\n\nclass TableDDLTest {\n\n    private static TableName dropTable;\n    private static final String DEFAULT_SCHEMA;\n    private static final String DEFAULT_TABLE;\n    private static final String JOIN_TABLE;\n    private static final String JOIN_NAME;\n    protected SQLParser parser;\n    private DDLFunctionsMock ddlFunctions;\n    private TypesRegistry typesRegistry;\n    private TestAISBuilder builder;\n\n    @Test\n    public void createTableAs5() throws Exception {\n", "reference": "        makeSeparateAIS();\n        String sql = \"CREATE TABLE t1 (c1, c2) AS (SELECT column1, column2, column3 FROM t2) WITH NO DATA\";\n        createTableAsMixGenerateAIS();\n        StatementNode stmt = parser.parseStatement(sql);\n        assertTrue (stmt instanceof CreateTableNode);\n        List<String> columnNames = Arrays.asList(\"column1\", \"column2\", \"column3\");\n        DataTypeDescriptor d = new DataTypeDescriptor(TypeId.INTEGER_ID, false);\n        List<DataTypeDescriptor> descriptors = Arrays.asList(d,d,d);\n        TableDDL.createTable(ddlFunctions, null, DEFAULT_SCHEMA, (CreateTableNode)stmt, null, descriptors ,columnNames, null);\n    }\n\n}", "prediction": "        String sql = \"CREATE TABLE t1 (c1 int, c2 int, c3 int, c4 int, c5 int, c6 int, c7 int, c8 int, c9 int, c10 int, c11 int, c12 int, c13 int, c14 int, c15 int, c16 int, c17 int, c18 int, c19 int, c20 int, c21 int, c22 int, c23 int, c24 int, c25 int, c26 int, c27 int, c28 int, c29 int, c30 int, c31 int, c32 int, c33 int, c34 int, c35 int, c36 int, c37 int, c38 int, c39 int, c40 int, c41 int, c42 int, c43 int, c44 int, c45 int, c46 int, c47 int, c48 int, c49 int, c50 int, c51 int, c52 int, c53 int, c54 int, c55 int, c56 int, c57 int, c58 int, c59 int, c60 int, c61 int, c62 int, c63 int, c64 int, c65 int, c66 int, c67 int, c6", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "32913234_8", "part": [1, 1], "seq": [1, 1], "prompt": "class UsersTemplate extends AbstractGithubTemplate implements UsersOperations {\n\n\t@Override\n\tpublic List<Email> listEmails() {\n\t\treturn Arrays\n\t\t\t\t.asList(getRestOperations().getForEntity(buildUriString(USER_EMAILS_PATH), Email[].class).getBody());\n\t}\n\n\tpublic  UsersTemplate(RestOperations restOperations);\n\n\t@Override public List<Email> addEmails(String... emails);\n\t@Override public List<Email> addEmails(List<String> emails);\n\t@Override public void deleteEmails(String... emails);\n\t@Override public void deleteEmails(List<String> emails);\n\t@Override public List<PubKey> listPublicKeys(String username);\n\t@Override public List<ExtPubKey> listPublicKeys();\n\t@Override public ExtPubKey getPublicKey(long id);\n\t@Override public ExtPubKey createPublicKey(PubKeyInput pubKey);\n\t@Override public void deletePublicKey(long id);\n\n\tprotected UsersTemplate usersTemplate;\n\n}\n\nclass UsersTemplateTest extends AbstractGithubTemplate {\n\n\tprotected UsersTemplate usersTemplate;\n\n\t@Test\n\tpublic void getEmails() throws Exception {\n", "reference": "\t\tmockServer.expect(requestTo(\"https://api.github.com/user/emails\")).andExpect(method(HttpMethod.GET))\n\t\t\t\t// .andExpect(header(\"Authorization\", \"Bearer ACCESS_TOKEN\"))\n\t\t\t\t.andRespond(\n\t\t\t\t\t\twithSuccess(new ClassPathResource(\"listEmails.json\", getClass()), MediaType.APPLICATION_JSON));\n\n\t\tList<Email> emailList = usersTemplate.listEmails();\n\n\t\tAssertions.assertThat(emailList).isNotNull();\n\t\tAssertions.assertThat(emailList.size()).isEqualTo(1);\n\t}\n\n}", "prediction": "\t\tList<Email> emails = usersTemplate.listEmails();\n\t\tassertNotNull(emails);\n\t\tassertTrue(emails.size() > 0);\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "33499067_5", "part": [1, 1], "seq": [1, 1], "prompt": "class FirmwareImage implements Chunk.Chunkable {\n\n    public int blockCount() {\n        return (int) Math.ceil((double) data().length / FW_BLOCK_SIZE);\n    }\n\n    public  FirmwareImage(byte[] rawData, String filename);\n\n    private int uint16FromData(int offset);\n    private byte[] uint8_4FromData(int offset);\n    public byte[] data();\n    public String name();\n    public int sizeBytes();\n    public long version();\n    @Override public byte[] getChunkableData();\n    public int crc();\n    public int crcShadow();\n    public int intVersion();\n    public int length();\n    public byte[] uniqueID();\n    public byte[] reserved();\n    public byte[] metadata();\n    public byte[] block(int index);\n\n     byte[] rawImageData_valid;\n     byte[] rawImageData_tooShort;\n     byte[] rawImageData_invalid;\n\n}\n\nclass FirmwareImageTest {\n\n     byte[] rawImageData_valid;\n     byte[] rawImageData_tooShort;\n     byte[] rawImageData_invalid;\n\n    @Test\n    public void testBlockCount() throws ImageParsingException {\n", "reference": "        FirmwareImage image1 = new FirmwareImage(rawImageData_valid, \"\");\n        FirmwareImage image2 = new FirmwareImage(rawImageData_invalid, \"\");\n        assertThat(image1.blockCount()).isEqualTo(1);\n        assertThat(image2.blockCount()).isEqualTo(3);\n    }\n\n}", "prediction": "        FirmwareImage image = new FirmwareImage(rawImageData_valid, \"test.fw\");\n        assertEquals(1, image.blockCount());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "33645537_540", "part": [1, 1], "seq": [1, 1], "prompt": "class Artists {\n\n    public String getArtistName(int index) {\n        try {\n            Artist artist = getArtist(index);\n            return artist.getName();\n        } catch (IllegalArgumentException e) {\n            return \"unknown\";\n        }\n    }\n\n    public  Artists(List<Artist> artists);\n\n    public Artist getArtist(int index);\n    private void indexException(int index);\n\n    private final Artists optionalExamples;\n\n}\n\nclass ArtistsTest {\n\n    private final Artists optionalExamples;\n\n    @Test\n    public void nameIndexOutsideRange() {\n", "reference": "        String artist = optionalExamples.getArtistName(4);\n        assertEquals(\"unknown\", artist);\n    }\n\n}", "prediction": "        assertThat(optionalExamples.getArtistName(100), is(\"unknown\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "33683869_3", "part": [1, 1], "seq": [1, 1], "prompt": "class DateUtil {\n\n    static public boolean isPublicHoliday(Date date) {\n        final Calendar calendar = GregorianCalendar.getInstance();\n        calendar.setTime(date);\n        final int day = calendar.get(Calendar.DAY_OF_MONTH);\n        final int month = calendar.get(Calendar.MONTH) + 1;\n        final int year = calendar.get(Calendar.YEAR);\n\n        String dateStr = String.valueOf(day) + \".\" + String.valueOf(month);\n        String dateStrWithYear = dateStr + \".\" + String.valueOf(year);\n        return FIXED_HOLIDAYS.contains(dateStr) || DYNAMIC_HOLIDAYS.contains(dateStrWithYear);\n    }\n\n    static public int getDayOfWeek(Date date);\n    public static int inMinutes(int hours, int minutes);\n    public static Date addMinutesToDate(Date date, int minutes);\n    static public String formatTimeFromMinutes(int minutes);\n\n}\n\nclass DateUtilTest {\n\n    @Test\n    public void testIsPublicHoliday() throws Exception {\n", "reference": "        final Calendar calendar = GregorianCalendar.getInstance();\n        calendar.set(2015, 0, 1);\n        assertTrue(DateUtil.isPublicHoliday(calendar.getTime()));\n\n        calendar.set(2016, 2, 28); //28 March is \"Ostermontag\"\n        assertTrue(DateUtil.isPublicHoliday(calendar.getTime()));\n\n        calendar.set(2015, 5, 5); // 5 June\n        assertFalse(DateUtil.isPublicHoliday(calendar.getTime()));\n\n    }\n\n}", "prediction": "        final Date date = new SimpleDateFormat(\"dd.MM.yyyy\").parse(\"01.01.2016\");\n        assertTrue(DateUtil.isPublicHoliday(date));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "33718145_7", "part": [1, 1], "seq": [1, 1], "prompt": "class LotComparator implements Comparator<Map<String, Object>> {\n\n\tpublic int compare(Map<String, Object> o1, Map<String, Object> o2) {\n\t\t\n\t\tint compareValue = 0;\n\t\t\n\t\t// Get dnulot information\n\t\tString dnulot1 = (String)o1.get(CadastrappConstants.PB_LOT_ID);\n\t\tString dnulot2 = (String)o2.get(CadastrappConstants.PB_LOT_ID);\n\t\t\n\t\t// If contains only number\t\t\n\t\tif(dnulot1.matches(numberRegex) && dnulot2.matches(numberRegex)){\n\t\t\tcompareValue = Integer.valueOf(dnulot1).compareTo(Integer.valueOf(dnulot2));\n\t\t}\n\t\t// If both start by number, but finish with char\n\t\telse if(dnulot1.matches(numberStartRegex) && dnulot2.matches(numberStartRegex)){\t\n\t\t\tcompareValue = Integer.valueOf(dnulot1.replaceAll(\"[^\\\\d]\", \"\")).compareTo(Integer.valueOf(dnulot2.replaceAll(\"[^\\\\d]\", \"\")));\n\t\t\t// If same number compare end string value\n\t\t\tif(compareValue == 0){\n\t\t\t\tcompareValue = dnulot1.replaceAll(\"[0-9]\", \"\").compareTo(dnulot2.replaceAll(\"[0-9]\", \"\"));\n\t\t\t}\n\t\t}\n\t\t// If one start with number and the other is char\n\t\telse if(dnulot1.matches(numberStartRegex)){\t\n\t\t\tcompareValue = -1;\n\t\t}\n\t\t// If one is char and the other start by number\n\t\telse if(dnulot2.matches(numberStartRegex)){\t\n\t\t\tcompareValue = 1;\n\t\t}\n\t\t// All other case\n\t\telse{\n\t\t\tcompareValue = dnulot1.compareTo(dnulot2);\n\t\t}\n\t\t\n\t\treturn compareValue;\n\t}\n\n\tstatic final Logger logger;\n\tpublic LotComparator lotComparator;\n\n}\n\nclass LotComparatorTest {\n\n\tstatic final Logger logger;\n\tpublic LotComparator lotComparator;\n\n\t@Test\n\tpublic void testBiggerNumberStringCompare() {\n", "reference": "\t\t\n\t\tMap<String, Object> lotsInformation1 = new HashMap<String, Object>();\n\t\tlotsInformation1.put(CadastrappConstants.PB_LOT_ID, \"01\");\n\t\t\n\t\tMap<String, Object> lotsInformation2 = new HashMap<String, Object>();\n\t\tlotsInformation2.put(CadastrappConstants.PB_LOT_ID, \"A\");\n\t\t\n\t\tint result = lotComparator.compare(lotsInformation1, lotsInformation2);\n\t\tassertTrue(result < 0);\t\n\t}\n\n}", "prediction": "\t\tString dnulot1 = \"123456789\";\n\t\tString dnulot2 = \"1234567890\";\n\t\tint compareValue = lotComparator.compare(dnulot1, dnulot2);\n\t\tAssert.assertTrue(compareValue < 0);\n\t}", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "34599551_7", "part": [1, 1], "seq": [1, 1], "prompt": "class HelloWorldEndpointImpl implements HelloWorldPortType {\n\n    @Override\n    public Greeting sayHello(Person person) {\n\n        String firstName = person.getFirstName();\n        LOGGER.debug(\"firstName={}\", firstName);\n        String lasttName = person.getLastName();\n        LOGGER.debug(\"lastName={}\", lasttName);\n\n        ObjectFactory factory = new ObjectFactory();\n        Greeting response = factory.createGreeting();\n\n        String greeting = \"Hello \" + firstName + \" \" + lasttName + \"!\";\n        LOGGER.info(\"greeting={}\", greeting);\n\n        response.setText(greeting);\n        return response;\n    }\n\n    private static String ENDPOINT_ADDRESS;\n\n}\n\nclass HelloWorldEndpointImplTest {\n\n    private static String ENDPOINT_ADDRESS;\n\n    @Test\n    public void testSayHelloProxy() {\n", "reference": "        Person person = new Person();\n        person.setFirstName(\"John\");\n        person.setLastName(\"Watson\");\n\n        assertEquals(\"Hello John Watson!\", new HelloWorldClientImplMock(\n                ENDPOINT_ADDRESS).sayHello(person));\n    }\n\n}", "prediction": "        HelloWorldPortType helloWorldPortType = new HelloWorldEndpointImpl();\n        Person person = new Person();\n        person.setFirstName(\"John\");\n        person.setLastName(\"Doe\");\n\n        Greeting greeting = helloWorldPortType.sayHello(person);\n        assertEquals(\"Hello!\", greeting.getText());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "34706545_4", "part": [1, 1], "seq": [1, 1], "prompt": "class Convert {\n\n    public static boolean getNthBit(byte[] arr, int offset){\n        int arrayOffset = offset / 8;\n        int bitOfByte = offset % 8;\n        int maskedBit = arr[arrayOffset] & (1 << (7 - bitOfByte));\n        return (maskedBit!= 0);\n    }\n\n    public static String bytesToHex(byte[] bytes);\n    public static byte[] strToBytes(String str);\n    public static byte[] longToBytes(long val);\n    public static byte[] getPrefixBytes(byte[] arr);\n\n}\n\nclass ConvertTest {\n\n    @Test\n    public void testBitsBytesConvert() {\n", "reference": "\n        Random r = new Random();\n\n        boolean[] bits = new boolean[32];\n        for (int i = 0; i < bits.length; i++) {\n            bits[i] = r.nextBoolean();\n        }\n\n        // convert bits to byte array\n        byte[] bytes = new byte[4];\n        for (int i = 0;i < bits.length; i++) {\n            if (bits[i]) {\n                bytes[i/8] |= (1 << 7) >> (i%8);\n            }\n        }\n\n        for (int i = 0; i < bits.length; i++) {\n            if (Convert.getNthBit(bytes, i) != bits[i]) {\n                fail(\"Conversion of bytes to bits failed at bit \"+i);\n            }\n        }\n\n    }\n\n}", "prediction": "        byte[] arr = new byte[]{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "34861263_54", "part": [1, 1], "seq": [1, 1], "prompt": "class JXPanel extends JPanel implements AlphaPaintable, BackgroundPaintable, Scrollable {\n\n    @Override\n    public void setAlpha(float alpha) {\n        if (isPatch()) {\n            setAlphaPatch(alpha);\n            return;\n        }\n        if (alpha < 0f || alpha > 1f) {\n            throw new IllegalArgumentException(\"invalid alpha value \" + alpha);\n        }\n        \n        float oldValue = getAlpha();\n        this.alpha = alpha;\n        \n        if (getAlpha() < 1f) {\n            if (oldValue == 1) {\n                //it used to be 1, but now is not. Save the oldOpaque\n                oldOpaque = isOpaque();\n                super.setOpaque(false);\n            }\n            \n            installRepaintManager();\n        } else {\n            uninstallRepaintManager();\n            \n            //restore the oldOpaque if it was true (since opaque is false now)\n            if (oldOpaque) {\n                super.setOpaque(true);\n            }\n        }\n        \n        firePropertyChange(\"alpha\", oldValue, getAlpha());\n        repaint();\n    }\n\n    public  JXPanel();\n    public  JXPanel(boolean isDoubleBuffered);\n    public  JXPanel(LayoutManager layout);\n    public  JXPanel(LayoutManager layout, boolean isDoubleBuffered);\n\n    @Override public void setOpaque(boolean opaque);\n    @Override public boolean isOpaque();\n    @Override public float getAlpha();\n    private void setAlphaPatch(float alpha);\n     void installRepaintManager();\n     void uninstallRepaintManager();\n    @Override public float getEffectiveAlpha();\n    @Override public boolean isInheritAlpha();\n    @Override public void setInheritAlpha(boolean val);\n    public final void setScrollableWidthHint(ScrollableSizeHint hint);\n    public final void setScrollableHeightHint(ScrollableSizeHint hint);\n    protected ScrollableSizeHint getScrollableWidthHint();\n    protected ScrollableSizeHint getScrollableHeightHint();\n    @Override public boolean getScrollableTracksViewportHeight();\n    @Override public boolean getScrollableTracksViewportWidth();\n    @Override public Dimension getPreferredScrollableViewportSize();\n    @Override public int getScrollableBlockIncrement(Rectangle visibleRect, int orientation, int direction);\n    @Override public int getScrollableUnitIncrement(Rectangle visibleRect, int orientation, int direction);\n    public void setScrollableTracksViewportHeight(boolean scrollableTracksViewportHeight);\n    public void setScrollableTracksViewportWidth(boolean scrollableTracksViewportWidth);\n    @Override public void setBackgroundPainter(Painter p);\n    protected PropertyChangeListener getPainterChangeListener();\n    @Override public Painter getBackgroundPainter();\n    @Override public boolean isPaintBorderInsets();\n    @Override public void setPaintBorderInsets(boolean paintBorderInsets);\n    protected boolean isPaintingOrigin();\n    @Override public void paint(Graphics g);\n    @Override @SuppressWarnings(\"unchecked\") protected void paintComponent(Graphics g);\n    protected boolean isPatch();\n    protected void paintComponentPatch(Graphics g);\n    protected boolean isOpaquePatch();\n    protected void setOpaquePatch(boolean opaque);\n    protected boolean isAlpha();\n    protected boolean isTransparentBackground();\n    protected boolean isPaintingBackground();\n\n    @SuppressWarnings(\"unused\")\n    private static final Logger LOG;\n\n}\n\nclass JXPanelTest extends JPanel {\n\n    @SuppressWarnings(\"unused\")\n    private static final Logger LOG;\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testSetAlphaWithLessThanZero() {\n", "reference": "        new JXPanel().setAlpha(Math.nextAfter(0f, Float.NEGATIVE_INFINITY));\n    }\n\n}", "prediction": "        new JXPanel().setAlpha(-1f);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "35126599_96", "part": [1, 1], "seq": [1, 1], "prompt": "class IntoImpl extends BaseSqlPart implements Into {\n\n  @Override\n  public void prependTo(@NotNull final RawSqlBuilder builder) {\n    builder.prepend(mTableName);\n\n    if (mDatabaseName!= null) {\n      builder.prepend('.').prepend(mDatabaseName);\n    }\n\n    builder.prepend(\"INTO \");\n  }\n\n    IntoImpl(@Nullable final String databaseName, @NotNull final String tableName, @NotNull final SqlPart previous);\n\n  @NotNull @Override public InsertColumns columns(@NotNull final String... columnNames);\n  @NotNull @Override public Values values(@NotNull final Object... expressions);\n  @Nullable @Override public SqlPart previous();\n\n}\n\nclass IntoImplTest {\n\n  @Test\n  public void prependTo_table_prependsProperSql() {\n", "reference": "    /* Given */\n    IntoImpl into = new IntoImpl(null, \"table\", mock(SqlPart.class));\n    RawSqlBuilder builder = new RawSqlBuilderImpl();\n\n    /* When */\n    into.prependTo(builder);\n\n    /* Then */\n    assertThat(builder.toString(), is(\"INTO table\"));\n  }\n\n}", "prediction": "    final Into into = new IntoImpl(null, \"table\", null);\n    final RawSqlBuilder builder = new RawSqlBuilder();\n    into.prependTo(builder);\n\n    assertEquals(\"INTO table\", builder.toString());\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "35689778_3", "part": [1, 1], "seq": [1, 1], "prompt": "class HtpasswdRealm extends MemoryRealm {\n\n    @Override\n    public Account authenticate(AuthenticationToken authenticationToken) {\n        readCredentialsFile();\n        return super.authenticate(authenticationToken);\n    }\n\n    public  HtpasswdRealm();\n\n    @Override public boolean canAuthenticate(AuthenticationToken authenticationToken);\n    @Override public void setup(Config config);\n    @Override public void start();\n    @Override public void stop();\n    public boolean isAllowClearTextPasswords();\n    public void setAllowClearTextPasswords(boolean value);\n    public synchronized void setFile(File realmFile);\n    @Override public boolean hasAccount(String username);\n    @Override public Account getAccount(String username);\n    @Override protected boolean validatePassword(StandardCredentials requestCredentials, StandardCredentials storedCredentials);\n    protected synchronized void readCredentialsFile();\n    protected Map<String, String> readCredentialsURL(URL url);\n\n     HtpasswdRealm htpasswd;\n\n}\n\nclass HtpasswdRealmTest extends MemoryRealm {\n\n     HtpasswdRealm htpasswd;\n\n    @Test\n    public void testAuthenticate() {\n", "reference": "\n        htpasswd.setAllowClearTextPasswords(true);\n\n        Account account = htpasswd.authenticate(\"user1\", \"pass1\");\n        assertNotNull(account);\n        assertEquals(\"user1\", account.getUsername());\n\n        account = htpasswd.authenticate(\"user2\", \"pass2\");\n        assertNotNull(account);\n        assertEquals(\"user2\", account.getUsername());\n\n        // Test different encryptions\n        account = htpasswd.authenticate(\"plain\", \"passWord\");\n        assertNotNull(account);\n        assertEquals(\"plain\", account.getUsername());\n\n        htpasswd.setAllowClearTextPasswords(false);\n        account = htpasswd.authenticate(\"crypt\", \"password\");\n        assertNotNull(account);\n        assertEquals(\"crypt\", account.getUsername());\n\n        account = htpasswd.authenticate(\"md5\", \"password\");\n        assertNotNull(account);\n        assertEquals(\"md5\", account.getUsername());\n\n        account = htpasswd.authenticate(\"sha\", \"password\");\n        assertNotNull(account);\n        assertEquals(\"sha\", account.getUsername());\n\n\n        // Test leading and trailing whitespace\n        account = htpasswd.authenticate(\"trailing\", \"whitespace\");\n        assertNotNull(account);\n        assertEquals(\"trailing\", account.getUsername());\n\n        account = htpasswd.authenticate(\"tabbed\", \"frontAndBack\");\n        assertNotNull(account);\n        assertEquals(\"tabbed\", account.getUsername());\n\n        account = htpasswd.authenticate(\"leading\", \"whitespace\");\n        assertNotNull(account);\n        assertEquals(\"leading\", account.getUsername());\n    }\n\n}", "prediction": "        htpasswd.setFile(new File(\"src/test/resources/htpasswd\"));\n        htpasswd.setAllowClearTextPasswords(true);\n        htpasswd.start();\n        UsernamePasswordToken token = new UsernamePasswordToken(\"test\", \"test\");\n        Account account = htpasswd.authenticate(token);\n        Assert.assertNotNull(account);\n        Assert.assertEquals(\"test\", account.getUsername());\n        Assert.assertEquals(\"test\", account.getPassword());\n        Assert.assertEquals(1, htpasswd.getAccounts().size());\n        htpasswd.stop();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "35844242_14", "part": [1, 1], "seq": [1, 1], "prompt": "class DynamodbAttributeValueTransformer {\n\n    public static AttributeValue toAttributeValueV2(final com.amazonaws.services.lambda.runtime.events.models.dynamodb.AttributeValue value) {\n        if (Objects.nonNull(value.getS())) {\n            return AttributeValue.builder()\n                   .s(value.getS())\n                   .build();\n\n        } else if (Objects.nonNull(value.getSS())) {\n            return AttributeValue.builder()\n                   .ss(value.getSS())\n                   .build();\n\n        } else if (Objects.nonNull(value.getN())) {\n            return AttributeValue.builder()\n                   .n(value.getN())\n                   .build();\n\n        } else if (Objects.nonNull(value.getNS())) {\n            return AttributeValue.builder()\n                   .ns(value.getNS())\n                   .build();\n\n        } else if (Objects.nonNull(value.getB())) {\n            return AttributeValue.builder()\n                   .b(SdkBytes.fromByteBuffer(value.getB()))\n                   .build();\n\n        } else if (Objects.nonNull(value.getBS())) {\n            return AttributeValue.builder()\n                   .bs(value.getBS().stream()\n                           .map(SdkBytes::fromByteBuffer)\n                           .collect(Collectors.toList()))\n                   .build();\n\n        } else if (Objects.nonNull(value.getBOOL())) {\n            return AttributeValue.builder()\n                   .bool(value.getBOOL())\n                   .build();\n\n        } else if (Objects.nonNull(value.getL())) {\n            return AttributeValue.builder()\n                   .l(value.getL().stream()\n                           .map(DynamodbAttributeValueTransformer::toAttributeValueV2)\n                           .collect(Collectors.toList()))\n                   .build();\n\n        } else if (Objects.nonNull(value.getM())) {\n            return AttributeValue.builder()\n                   .m(toAttributeValueMapV2(value.getM()))\n                   .build();\n\n        } else if (Objects.nonNull(value.getNULL())) {\n            return AttributeValue.builder()\n                   .nul(value.getNULL())\n                   .build();\n\n        } else {\n            throw new IllegalArgumentException(\n                    String.format(\"Unsupported attributeValue type: %s\", value));\n        }\n    }\n\n    static Map<String, AttributeValue> toAttributeValueMapV2(\n            final Map<String, com.amazonaws.services.lambda.runtime.events.models.dynamodb.AttributeValue> attributeValueMap\n    );\n\n    private static final String valueN;\n    private static final List<String> valueNS;\n    private static final String valueS;\n    private static final List<String> valueSS;\n    private static final ByteBuffer valueB;\n    private static final List<ByteBuffer> valueBS;\n    private static final boolean valueBOOL;\n    private static final boolean valueNUL;\n    private static final String keyM1;\n    private static final String keyM2;\n    public static final AttributeValue attributeValueN_event;\n    public static final AttributeValue attributeValueNS_event;\n    public static final AttributeValue attributeValueS_event;\n    public static final AttributeValue attributeValueSS_event;\n    public static final AttributeValue attributeValueB_event;\n    public static final AttributeValue attributeValueBS_event;\n    public static final AttributeValue attributeValueBOOL_event;\n    public static final AttributeValue attributeValueNUL_event;\n    public static final AttributeValue attributeValueM_event;\n    public static final AttributeValue attributeValueL_event;\n    public static final software.amazon.awssdk.services.dynamodb.model.AttributeValue attributeValueN_v2;\n    public static final software.amazon.awssdk.services.dynamodb.model.AttributeValue attributeValueNS_v2;\n    public static final software.amazon.awssdk.services.dynamodb.model.AttributeValue attributeValueS_v2;\n    public static final software.amazon.awssdk.services.dynamodb.model.AttributeValue attributeValueSS_v2;\n    public static final software.amazon.awssdk.services.dynamodb.model.AttributeValue attributeValueB_v2;\n    public static final software.amazon.awssdk.services.dynamodb.model.AttributeValue attributeValueBS_v2;\n    public static final software.amazon.awssdk.services.dynamodb.model.AttributeValue attributeValueBOOL_v2;\n    public static final software.amazon.awssdk.services.dynamodb.model.AttributeValue attributeValueNUL_v2;\n    public static final software.amazon.awssdk.services.dynamodb.model.AttributeValue attributeValueM_v2;\n    public static final software.amazon.awssdk.services.dynamodb.model.AttributeValue attributeValueL_v2;\n\n}\n\nclass DynamodbAttributeValueTransformerTest {\n\n    private static final String valueN;\n    private static final List<String> valueNS;\n    private static final String valueS;\n    private static final List<String> valueSS;\n    private static final ByteBuffer valueB;\n    private static final List<ByteBuffer> valueBS;\n    private static final boolean valueBOOL;\n    private static final boolean valueNUL;\n    private static final String keyM1;\n    private static final String keyM2;\n    public static final AttributeValue attributeValueN_event;\n    public static final AttributeValue attributeValueNS_event;\n    public static final AttributeValue attributeValueS_event;\n    public static final AttributeValue attributeValueSS_event;\n    public static final AttributeValue attributeValueB_event;\n    public static final AttributeValue attributeValueBS_event;\n    public static final AttributeValue attributeValueBOOL_event;\n    public static final AttributeValue attributeValueNUL_event;\n    public static final AttributeValue attributeValueM_event;\n    public static final AttributeValue attributeValueL_event;\n    public static final software.amazon.awssdk.services.dynamodb.model.AttributeValue attributeValueN_v2;\n    public static final software.amazon.awssdk.services.dynamodb.model.AttributeValue attributeValueNS_v2;\n    public static final software.amazon.awssdk.services.dynamodb.model.AttributeValue attributeValueS_v2;\n    public static final software.amazon.awssdk.services.dynamodb.model.AttributeValue attributeValueSS_v2;\n    public static final software.amazon.awssdk.services.dynamodb.model.AttributeValue attributeValueB_v2;\n    public static final software.amazon.awssdk.services.dynamodb.model.AttributeValue attributeValueBS_v2;\n    public static final software.amazon.awssdk.services.dynamodb.model.AttributeValue attributeValueBOOL_v2;\n    public static final software.amazon.awssdk.services.dynamodb.model.AttributeValue attributeValueNUL_v2;\n    public static final software.amazon.awssdk.services.dynamodb.model.AttributeValue attributeValueM_v2;\n    public static final software.amazon.awssdk.services.dynamodb.model.AttributeValue attributeValueL_v2;\n\n    @Test\n    public void testToAttributeValueV2_IllegalArgumentWhenNull_BOOL() {\n", "reference": "        Assertions.assertThrows(IllegalArgumentException.class, () ->\n                DynamodbAttributeValueTransformer.toAttributeValueV2(new AttributeValue().withBOOL(null))\n        );\n    }\n\n}", "prediction": "        assertThrows(IllegalArgumentException.class, () -> DynamodbAttributeValueTransformer.toAttributeValueV2(null));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "35957836_1", "part": [1, 1], "seq": [1, 1], "prompt": "class LanguageStats {\n\n    public static List<LanguageStats> buildStats(List<Project> projectList) {\n        List<Project> projects = filterUniqueSnapshots(projectList);\n\n        // For each date, we have a map of all the counts. Later we piece the\n        // results together from these pieces of information.\n        Map<Date, Map<String,Integer>> counts = new HashMap<>();\n        TreeSet<Date> dates = new TreeSet<>();\n        Set<String> languages = new HashSet<>();\n\n        for (Project p: projects) {\n            String language = p.getPrimaryLanguage();\n            Date date = p.getSnapshotDate();\n\n            if (language == null)\n                language = \"unknown\";\n\n            dates.add(date);\n            languages.add(language);\n\n            Map<String,Integer> hist = counts.get(date);\n            if (hist == null) {\n                hist = new HashMap<>();\n                counts.put(date, hist);\n            }\n\n            if (hist.containsKey(language)) {\n                hist.put(language, hist.get(language) + 1);\n            } else {\n                hist.put(language, 1);\n            }\n        }\n\n        List<LanguageStats> result = new ArrayList<>();\n        for (String l: languages) {\n            List<Integer> projectCounts = new ArrayList<>();\n            List<Date> snapshotDates = new ArrayList<>(dates);\n\n            for(Date d: snapshotDates) {\n                Integer i = counts.get(d).get(l);\n                if (i == null) {\n                    projectCounts.add(0);\n                } else {\n                    projectCounts.add(i);\n                }\n            }\n            result.add(new LanguageStats(l, projectCounts, snapshotDates));\n        }\n        return result;\n    }\n\n    public  LanguageStats(String languageName, List<Integer> projectCounts, List<Date> snapshotDates);\n\n    public static List<Project> filterUniqueSnapshots(List<Project> projects);\n    @JsonProperty(value=\"name\") public String getLanguageName();\n    @JsonProperty(value=\"project_counts\") public List<Integer> getProjectCounts();\n    @JsonProperty(value=\"snapshot_dates\") @JsonSerialize(using = JsonDateListSerializer.class) public List<Date> getSnapshotDates();\n\n    private static final String JAVA;\n    private static final String PYTHON;\n\n}\n\nclass LanguageStatsTest {\n\n    private static final String JAVA;\n    private static final String PYTHON;\n\n    @Test\n    public void thatStatsAreBuiltForEmptyProjects() {\n", "reference": "        assertThat(LanguageStats.buildStats(Lists.newArrayList()), empty());\n    }\n\n}", "prediction": "        List<Project> projects = new ArrayList<>();\n        List<LanguageStats> stats = LanguageStats.buildStats(projects);\n        assertEquals(0, stats.size());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "36185854_15", "part": [1, 1], "seq": [1, 1], "prompt": "class BasenameBuilder {\n\n    static String build(Resource resource) throws IOException{\n        Validate.notNull(resource, \"resource can't be null!\");\n\n        //---------------------------------------------------------------\n\n        URL url = resource.getURL();\n        String fileName = url.getFile();\n\n        String afterParseUrl = parseUrl(url, fileName);\n\n        String baseName = parseBasename(afterParseUrl);\n        LOGGER.debug(\"file:[{}],baseName is:[{}]\", fileName, baseName);\n        return baseName;\n    }\n\n    private  BasenameBuilder();\n\n    private static String parseUrl(URL url,String fileName);\n    private static String parseBasename(String replaceFirst);\n\n}\n\nclass BasenameBuilderTest  {\n\n    @Test\n    public void test() throws IOException{\n", "reference": "        String urlOrPath = \"classpath:i18n/help_message_zh_HK.properties\";\n        Resource resource = ResourceUtil.getResource(urlOrPath);\n        String build = BasenameBuilder.build(resource);\n\n        LOGGER.debug(build);\n    }\n\n}", "prediction": "//        String fileName = \"http://www.baidu.com/a.html\";\n//        String fileName = \"http://www.baidu.com/a.html?a=1&b=2\";\n//        String fileName = \"http://www.baidu.com/a.html?a=1&b=2#a=1&b=2\";\n//        String fileName = \"http://www.baidu.com/a.html?a=1&b=2#a=1&b=2?a=1&b=2\";\n//        String fileName = \"http://www.baidu.com/a.html?a=1&b=2#a=1&b=2?a=1&b=2?a=1&b=2\";\n//        String fileName = \"http://www.baidu.com/a.html?a=1&b=2#a=1&b=2?a=1&b=2?a=1&b=2?a=1&b=2\";\n//        String fileName = \"http://www.baidu.com/a.html?a=1&b=2#a=1&b=2?a=1&b=2?a=1&b=2?a=1&b=2?a=1&b=2\";\n//        String fileName = \"http://www.baidu.com/a.html?a=1&b=2#a=1&b=2?a=1&b=2?a=1&b=2?a=1&b=2?a=1&b=2?a=1&b=2\";\n//        String fileName = \"http://www.baidu.com/a.html?a=1&b=2#a=1&b=2?a=1&b=2?a=1&b=2?a=1&b=2?a=1&b=2?a=1&b=2?a=1&b=2\";\n//        String fileName = \"http://www.baidu.com/a.html?a=1&b=2#a=1&b=2?a=1&b=2?a=1&b=2?a=1&b=2?a=1&b=2?a=1&b=2?a=1&b=2?a=1&b=2\";\n//        String fileName = \"http://www.baidu.com/a.html?a=1&", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "37813245_0", "part": [1, 1], "seq": [1, 1], "prompt": "class ReservationClient {\n\n    public Flux<Reservation> getAllReservations() {\n        return this.webClient\n               .get()\n               .uri(\"http://localhost:8081/reservations\")\n               .retrieve()\n               .bodyToFlux(Reservation.class);\n    }\n\n    @Autowired\n    private ReservationClient client;\n\n}\n\nclass ReservationClientTest {\n\n    @Autowired\n    private ReservationClient client;\n\n    @Test\n    public void getAll() {\n", "reference": "\n      /*  WireMock\n                .stubFor(WireMock\n                        .get(\"/reservations\")\n                        .willReturn(\n                                WireMock\n                                        .aResponse()\n                                        .withHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)\n                                        .withBody(\"[ { \\\"id\\\":\\\"1\\\", \\\"reservationName\\\":\\\"Jane\\\" } ]\")\n                        ));\n*/\n\n        Flux<Reservation> allReservations = this.client.getAllReservations();\n        StepVerifier\n                .create(allReservations)\n                .expectNextMatches(r -> r.getName().equalsIgnoreCase(\"Jane\") && r.getId() != null)\n                .verifyComplete();\n\n    }\n\n}", "prediction": "        client.getAllReservations().subscribe(System.out::println);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "37814227_6", "part": [1, 1], "seq": [1, 1], "prompt": "class TravisRestService {\n\n  public void finish(long buildId) throws Exception {\n    jandyWorker.put(buildId, JandyTask.FINISH, Long.valueOf(buildId));\n  }\n\n  @Transactional public void begin(BuildInfo bi);\n  @Transactional public Map<String,?> createProf(ProfilingInfo profParams);\n  public void saveProf(ProfilingContext profilingContext);\n  public void updateTreeNodes(List<TreeNode> treeNodes);\n\n  @Autowired\n  private TravisRestService travisRestService;\n  @MockBean\n  private ProfContextDumpRepository profContextDumpRepository;\n  @MockBean\n  private ProjectRepository projectRepository;\n  @MockBean\n  private BranchRepository branchRepository;\n  @MockBean\n  private BuildRepository buildRepository;\n  @MockBean\n  private JandyWorker jandyWorker;\n  @MockBean\n  private SampleRepository sampleRepository;\n  private BuildInfo bi;\n  private Project project;\n  private Branch branch;\n\n}\n\nclass TravisRestServiceTest {\n\n  @Autowired\n  private TravisRestService travisRestService;\n  @MockBean\n  private ProfContextDumpRepository profContextDumpRepository;\n  @MockBean\n  private ProjectRepository projectRepository;\n  @MockBean\n  private BranchRepository branchRepository;\n  @MockBean\n  private BuildRepository buildRepository;\n  @MockBean\n  private JandyWorker jandyWorker;\n  @MockBean\n  private SampleRepository sampleRepository;\n  private BuildInfo bi;\n  private Project project;\n  private Branch branch;\n\n  @Test\n  public void testFinish() throws Exception {\n", "reference": "    travisRestService.finish(1L);\n\n    verify(jandyWorker, times(1)).put(eq(1L), eq(JandyTask.FINISH), eq(Long.valueOf(1L)));\n  }\n\n}", "prediction": "    travisRestService.finish(123L);\n    verify(jandyWorker).put(123L, JandyTask.FINISH, Long.valueOf(123L));\n  }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "37817790_8", "part": [1, 1], "seq": [1, 1], "prompt": "class SetterAdapter implements Setter {\n\n    @Override\n    public void setTransientColour(@ColorInt int colour) {\n        colorSetter.setTransientColor(colour);\n    }\n\n    public  SetterAdapter(ColorSetter colorSetter);\n\n    @Override public void setColour(@ColorInt int colour);\n\n    @Mock\n    private ColorSetter colorSetter;\n    private Setter setter;\n\n}\n\nclass SetterAdapterTest {\n\n    @Mock\n    private ColorSetter colorSetter;\n    private Setter setter;\n\n    @Test\n    public void givenAColourSetterWrappedInASetterAdapterThenTransientSetColorIsCalled() {\n", "reference": "        setter.setTransientColour(1);\n        verify(colorSetter, atLeastOnce()).setTransientColor(anyInt());\n    }\n\n}", "prediction": "        setter.setTransientColour(Color.RED);\n\n        verify(colorSetter).setTransientColor(Color.RED);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "38092182_93", "part": [1, 1], "seq": [1, 1], "prompt": "class VastVideoViewController extends BaseVideoViewController implements DownloadTask.DownloadTaskListener {\n\n    @Deprecated\n    int getShowCloseButtonDelay() {\n        return mShowCloseButtonDelay;\n    }\n\n      VastVideoViewController(final Context context,\n            final Bundle bundle,\n            final long broadcastIdentifier,\n            final BaseVideoViewControllerListener baseVideoViewControllerListener);\n\n    @Override protected VideoView getVideoView();\n    @Override protected void onCreate();\n    @Override protected void onResume();\n    @Override protected void onPause();\n    @Override protected void onDestroy();\n    @Override public boolean backButtonEnabled();\n    @Override void onActivityResult(final int requestCode, final int resultCode, final Intent data);\n    @Override public void onComplete(String url, DownloadResponse downloadResponse);\n    private void downloadCompanionAd();\n    private Runnable createVideoProgressCheckerRunnable();\n    private void createVideoBackground(final Context context);\n    private VastVideoToolbar createVastVideoToolBar(final Context context);\n    private VideoView createVideoView(final Context context);\n     boolean retryMediaPlayer(final MediaPlayer mediaPlayer, final int what, final int extra);\n    private ImageView createCompanionAdImageView(final Context context);\n    private void handleClick(final List<String> clickThroughTrackers, final String clickThroughUrl);\n    private boolean isLongVideo(final int duration);\n    private void makeVideoInteractable();\n    private boolean shouldBeInteractable();\n    private boolean shouldAllowClickThrough();\n    private void startProgressChecker();\n    private void stopProgressChecker();\n    @Deprecated boolean getIsVideoProgressShouldBeChecked();\n    @Deprecated int getVideoRetries();\n    @Deprecated boolean isShowCloseButtonEventFired();\n    @Deprecated void setCloseButtonVisible(boolean visible);\n    @Deprecated boolean isVideoFinishedPlaying();\n    @Deprecated ImageView getCompanionAdImageView();\n\n    public static final int NETWORK_DELAY;\n    private MediaPlayer mediaPlayer;\n    private Context context;\n    private Bundle bundle;\n    private long testBroadcastIdentifier;\n    private VastVideoViewController subject;\n    private BaseVideoViewControllerListener baseVideoViewControllerListener;\n    private EventForwardingBroadcastReceiver broadcastReceiver;\n    private int expectedBrowserRequestCode;\n    private String expectedUserAgent;\n\n}\n\nclass VastVideoViewControllerTest {\n\n    public static final int NETWORK_DELAY;\n    private MediaPlayer mediaPlayer;\n    private Context context;\n    private Bundle bundle;\n    private long testBroadcastIdentifier;\n    private VastVideoViewController subject;\n    private BaseVideoViewControllerListener baseVideoViewControllerListener;\n    private EventForwardingBroadcastReceiver broadcastReceiver;\n    private int expectedBrowserRequestCode;\n    private String expectedUserAgent;\n\n    @Test\n    public void constructor_shouldNotChangeCloseButtonDelay() throws Exception {\n", "reference": "        initializeSubject();\n\n        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(DEFAULT_VIDEO_DURATION_FOR_CLOSE_BUTTON);\n    }\n\n}", "prediction": "        assertThat(subject.getShowCloseButtonDelay()).isEqualTo(VastVideoViewController.DEFAULT_SHOW_CLOSE_BUTTON_DELAY);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "38943889_27", "part": [1, 1], "seq": [1, 1], "prompt": "class ByteArray implements Serializable, Cloneable {\n\n    public ByteArray clearBit(int displacement, byte mask) {\n        byte b = value.get(displacement);\n        b &= (255 - (mask & 0xff));\n        value.put(displacement, b);\n        return this;\n    }\n\n    public  ByteArray(int size);\n    public  ByteArray(int size, String encoding);\n    public  ByteArray(int size, ByteOrder order);\n    public  ByteArray(int size, String encoding, ByteOrder order);\n    public  ByteArray(byte[] array);\n    public  ByteArray(byte[] array, ByteOrder order);\n    public  ByteArray(byte[] array, String encoding);\n    public  ByteArray(byte[] array, String encoding, ByteOrder order);\n    public  ByteArray(ByteArray byteArray);\n    public  ByteArray(ByteBuffer buffer);\n    public  ByteArray(ByteBuffer buffer, String encoding);\n\n    public Object clone();\n    public ByteArray slice(int displacement, int length);\n    public ByteArray duplicate();\n    public boolean testBit(int displacement, byte mask);\n    public ByteArray setBit(int displacement, byte mask);\n    public ByteArray setBit(int displacement, byte mask, boolean b);\n    public byte[] read(int displacement, int length);\n    public int read(int displacement, byte[] bytes);\n    public int read(int displacement, byte[] bytes, int offset, int length);\n    public byte readAsByte(int displacement);\n    public ByteArray readAsByteArray(int displacement, int length);\n    public char readAsChar(int displacement);\n    public char[] readAsCharArray(int displacement, int length);\n    public int read(int displacement, char[] chars);\n    public int read(int displacement, char[] chars, int offset, int length);\n    public String readAsString();\n    public String readAsString(int displacement);\n    public String readAsString(int displacement, int length);\n    public String readAsString(int displacement, int length, boolean nts);\n    public float readAsFloat(int displacement);\n    public double readAsDouble(int displacement);\n    public short readAsShort(int displacement);\n    public int readAsInt(int displacement);\n    public long readAsLong(int displacement);\n    public String readPns(int displacement, int length);\n    public String readPns(int displacement, int length, boolean convertAtoF);\n    private char convertAtoF(byte nybble);\n    public ByteArray fill();\n    public ByteArray fill(byte filler);\n    public ByteArray fill(byte filler, int displacement, int length);\n    public ByteArray write(char[] chars, int displacement);\n    public ByteArray write(char[] chars, int offset, int length, int displacement);\n    public ByteArray write(ByteArray byteArray, int displacement, int length);\n    public ByteArray write(ByteArray byteArray, int displacement);\n    public ByteArray write(byte[] bytes, int displacement);\n    public ByteArray write(byte[] bytes, int offset, int length, int displacement);\n    public ByteArray write(String s, int displacement);\n    public ByteArray write(String s, int displacement, int length);\n    public ByteArray write(String s, int displacement, int length, boolean nts);\n    public ByteArray write(short s, int displacement);\n    public ByteArray write(char c, int displacement);\n    public ByteArray write(byte b, int displacement);\n    public ByteArray write(int i, int displacement);\n    public ByteArray write(long i, int displacement);\n    public ByteArray write(float f, int displacement);\n    public ByteArray write(double d, int displacement);\n    public ByteArray writeAsPs(String s, int displacement, int length);\n    public ByteArray writeAsPns(String s, int displacement, int length);\n    public ByteArray writeAsPns(String s, int displacement, int length,\n                                char filler);\n    private static byte convertCharToNybble(char fromChar);\n    public static byte getSpaceFiller(String encoding);\n    public static ByteArray valueOf(String string);\n    @Override public boolean equals(Object anObject);\n    public static boolean equalTo(ByteArray a, ByteArray b);\n    public boolean equalSame(byte b);\n    public boolean equalSame(byte b, int displacement, int length);\n    public int getLength();\n    public boolean hasArray();\n    public UnderlyingArray getArray();\n    public byte[] getBytes();\n    @Deprecated public byte[] getByteArray();\n    public ByteArray setEncoding(String encoding);\n    public String getEncoding();\n    public ByteArray setOrder(ByteOrder order);\n    public ByteOrder getOrder();\n    public ByteBuffer getBuffer();\n\n     ByteArray byteArray;\n\n}\n\nclass ByteArrayTest {\n\n     ByteArray byteArray;\n\n    @Test\n    public void testClearBit() {\n", "reference": "        byte[] ba = new byte[2];\n        byteArray = new ByteArray(ba);\n        byteArray.setBit(0, (byte) 0x41);\n        byteArray.setBit(1, (byte) 0x01);\n        assertTrue(byteArray.testBit(0, (byte) 0x01));\n        assertTrue(byteArray.testBit(0, (byte) 0x40));\n        assertTrue(byteArray.testBit(0, (byte) 0x41));\n        assertFalse(byteArray.testBit(0, (byte) 0x02));\n        byteArray.clearBit(0, (byte) 0x40);\n        assertTrue(byteArray.testBit(0, (byte) 0x01));\n        assertFalse(byteArray.testBit(0, (byte) 0x40));\n        System.out.println(\"CLR : \" + byteArray.readPns(0, 2));\n        byteArray.clearBit(0, (byte) 0x80);\n        System.out.println(\"CLR : \" + byteArray.readPns(0, 2));\n        byteArray.clearBit(0, (byte) 0x01);\n        byteArray.setBit(0, (byte) 0x42);\n        System.out.println(\"CLR : \" + byteArray.readPns(0, 2));\n    }\n\n}", "prediction": "        byteArray.clearBit(0, (byte) 0x01);\n        assertEquals(0, byteArray.readAsByte(0));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "39038703_232", "part": [1, 1], "seq": [1, 1], "prompt": "class WorkspaceItem implements InProgressSubmission, Serializable, ReloadableEntity<Integer> {\n\n    @Override\n    public boolean hasMultipleFiles()\n    {\n        return multipleFiles;\n    }\n\n    protected  WorkspaceItem();\n\n    @Override public Integer getID();\n    public int getStageReached();\n    public void setStageReached(int v);\n    public int getPageReached();\n    public void setPageReached(int v);\n    @Override public boolean equals(Object o);\n    @Override public int hashCode();\n    @Override public Item getItem();\n     void setItem(Item item);\n    @Override public Collection getCollection();\n     void setCollection(Collection collection);\n    @Override public EPerson getSubmitter();\n    @Override public void setMultipleFiles(boolean b);\n    @Override public boolean hasMultipleTitles();\n    @Override public void setMultipleTitles(boolean b);\n    @Override public boolean isPublishedBefore();\n    @Override public void setPublishedBefore(boolean b);\n    public List<Group> getSupervisorGroups();\n     void removeSupervisorGroup(Group group);\n     void addSupervisorGroup(Group group);\n\n    private static final Logger log;\n    private WorkspaceItem wi;\n    private Community owningCommunity;\n    private Collection collection;\n    protected CommunityService communityService;\n    protected CollectionService collectionService;\n    protected EPersonService ePersonService;\n    protected ItemService itemService;\n    protected WorkspaceItemService workspaceItemService;\n\n}\n\nclass WorkspaceItemTest  {\n\n    private static final Logger log;\n    private WorkspaceItem wi;\n    private Community owningCommunity;\n    private Collection collection;\n    protected CommunityService communityService;\n    protected CollectionService collectionService;\n    protected EPersonService ePersonService;\n    protected ItemService itemService;\n    protected WorkspaceItemService workspaceItemService;\n\n    @Test\n    public void testHasMultipleFiles()\n    {\n", "reference": "        assertFalse(\"testHasMultipleFiles 0\", wi.hasMultipleFiles());\n    }\n\n}", "prediction": "        assertFalse(wi.hasMultipleFiles());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "39215543_3", "part": [1, 1], "seq": [1, 1], "prompt": "class InstrumentedOkHttpClients {\n\n  public static OkHttpClient create(MetricRegistry registry) {\n    return new InstrumentedOkHttpClient(registry, new OkHttpClient(), null);\n  }\n\n  private  InstrumentedOkHttpClients();\n\n  public static OkHttpClient create(MetricRegistry registry, OkHttpClient client);\n  public static OkHttpClient create(MetricRegistry registry, String name);\n  public static OkHttpClient create(MetricRegistry registry, OkHttpClient client, String name);\n\n  private MetricRegistry registry;\n\n}\n\nclass InstrumentedOkHttpClientsTest {\n\n  private MetricRegistry registry;\n\n  @Test public void instrumentProvidedClient() {\n", "reference": "    OkHttpClient rawClient = new OkHttpClient();\n    OkHttpClient client = InstrumentedOkHttpClients.create(registry, rawClient);\n    assertThatClientsAreEqual(client, rawClient);\n  }\n\n}", "prediction": "    OkHttpClient client = InstrumentedOkHttpClients.create(registry, new OkHttpClient());\n    assertThat(client.interceptors()).hasSize(1);\n    assertThat(client.interceptors().get(0)).isInstanceOf(OkHttpClientMetricsInterceptor.class);\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "39228827_1", "part": [1, 1], "seq": [1, 1], "prompt": "class Analyser {\n\n    @NotNull\n    public static Table createCulpritMatrix(List<FinishedBuildWithChanges> buildsWithContainingChanges) {\n        if (buildsWithContainingChanges.size() == 0) {\n            // there are no builds and thus no outstanding failuresInMostRecentBuild\n            return new Table(\n                    new ArrayList<TestName>(),\n                    new ArrayList<FinishedBuildWithChanges>(),\n                    new HashMap<TestName, FinishedBuildWithChanges>(),\n                    new HashMap<TestName, Set<FinishedBuildWithChanges>>());\n        }\n\n        // the outstanding test failures that the overview tab will help diagnose; get them from the last build\n        List<TestName> failuresInMostRecentBuild = new ArrayList<TestName>();\n        for (TestName testFailure : SinCityUtils.getNamesOfFailingTests(buildsWithContainingChanges.get(0).getBuild())) {\n            failuresInMostRecentBuild.add(testFailure);\n        }\n\n        // the build(s) suspected of causing each test failure\n        Map<TestName, Set<FinishedBuildWithChanges>> buildsSuspectedOfCausingFailure = new HashMap<TestName, Set<FinishedBuildWithChanges>>();\n\n        // the build in which the test failure first occurred\n        Map<TestName, FinishedBuildWithChanges> buildInWhichFailureFirstOccurred = new HashMap<TestName, FinishedBuildWithChanges>();\n\n        // the test failures which the build is suspected of causing\n        Map<FinishedBuildWithChanges, Set<TestName>> failuresSuspectedToBeCausedByBuild = new LinkedHashMap<FinishedBuildWithChanges, Set<TestName>>();\n\n        HashSet<TestName> issuesNotYetClarified = new HashSet<TestName>(failuresInMostRecentBuild);\n        int consecutiveBuildsWithoutNewInfo = 0;   // how many builds have we gone without seeing any new info?\n\n        for (FinishedBuildWithChanges build : buildsWithContainingChanges) {\n            FinishedBuildTestInfo buildTestInfo = new FinishedBuildTestInfo(build.getBuild());\n\n            consecutiveBuildsWithoutNewInfo++;\n\n            // use an explicit iterator so I can remove from the set while iterating it\n            Iterator<TestName> issuesNotYetClarifiedIterator = issuesNotYetClarified.iterator();\n            while (issuesNotYetClarifiedIterator.hasNext()) {\n                TestName testFailure = issuesNotYetClarifiedIterator.next();\n\n                if (buildTestInfo.testFailed(testFailure)) {\n                    // the test failure occurred in this build (the build problem occurred/the test failed)\n\n                    // absolve the previous suspects\n                    if (buildsSuspectedOfCausingFailure.containsKey(testFailure)) {\n                        for (FinishedBuildWithChanges previousSuspectBuild : buildsSuspectedOfCausingFailure.get(testFailure)) {\n                            failuresSuspectedToBeCausedByBuild.get(previousSuspectBuild).remove(testFailure);\n                            if (failuresSuspectedToBeCausedByBuild.get(previousSuspectBuild).isEmpty()) {\n                                // this build has been absolved of all blame\n                                failuresSuspectedToBeCausedByBuild.remove(previousSuspectBuild);\n                            }\n                        }\n                    }\n\n                    // take note of this build where the test failure occurred\n                    buildInWhichFailureFirstOccurred.put(testFailure, build);\n\n                    // add this test failure to the blame list for this build\n                    if (!failuresSuspectedToBeCausedByBuild.containsKey(build)) {\n                        failuresSuspectedToBeCausedByBuild.put(build, new HashSet<TestName>());\n                    }\n                    failuresSuspectedToBeCausedByBuild.get(build).add(testFailure);\n                    buildsSuspectedOfCausingFailure.put(testFailure, new HashSet<FinishedBuildWithChanges>(Collections.singletonList(build)));\n\n                    consecutiveBuildsWithoutNewInfo = 0;\n                }\n                else if (buildTestInfo.testSucceeded(testFailure)) {\n                    // the test failure didn't occur in this build (the test passed); the investigation is now complete;\n                    // the list of suspects is final\n                    issuesNotYetClarifiedIterator.remove();\n\n                    consecutiveBuildsWithoutNewInfo = 0;\n                }\n                else {\n                    // the test failure didn't exhibit itself but it seems the test never ran either; this may be due to\n                    // several reasons:\n                    // i)   the test is new and it's been failing from the start; we're now going down the history of\n                    //      builds where the test didn't even exist yet; we could go all the way to the Big Bang and\n                    //      find nothing\n                    // ii)  the build may have failed before running the test; again, in this case we should find the\n                    //      test (passing or failing) further back in the history and decide based on that\n                    // iii) the test existed as of this version but we didn't run it, possibly because someone had\n                    //      somehow skipped it (we actually suggest running only a subset of tests in README.md when\n                    //      explaining the meaning of the %sincity.test.failure.json% parameter; if this is implemented\n                    //      and the culprit-finding builds only rerun the new failures, the old failures won't make an\n                    //      appearance in the culprit-finding builds at all - and yet they predate these builds); in\n                    //      this case we should find the test (passing or failing) further back in the history and\n                    //      decide based on that\n                    // at any rate, this build's changes must be treated as suspect\n\n                    // add this testFailure to the blame list for this build\n                    if (!failuresSuspectedToBeCausedByBuild.containsKey(build)) {\n                        failuresSuspectedToBeCausedByBuild.put(build, new HashSet<TestName>());\n                    }\n                    failuresSuspectedToBeCausedByBuild.get(build).add(testFailure);\n                    buildsSuspectedOfCausingFailure.get(testFailure).add(build);\n                }\n            }\n\n            if (consecutiveBuildsWithoutNewInfo >= getMaxNumberOfConsecutiveBuildsWithoutNewInfo())\n                break;\n        }\n\n        return new Table(\n                failuresInMostRecentBuild,\n                new ArrayList<FinishedBuildWithChanges>(failuresSuspectedToBeCausedByBuild.keySet()),\n                buildInWhichFailureFirstOccurred,\n                buildsSuspectedOfCausingFailure\n        );\n    }\n\n    static int getMaxNumberOfConsecutiveBuildsWithoutNewInfo();\n\n    public static final int NUMBER_OF_NO_RUN_BUILDS_IN_SEQUENCE;\n    private TestName test1TestName;\n    private TestName test2TestName;\n    private STestRun test1STestRun;\n    private STest test1STest;\n    private TestInfo test1FailureTestInfo;\n    private STestRun test2STestRun;\n    private STest test2STest;\n    private TestInfo test2FailureTestInfo;\n    private BuildStatistics buildStatisticsGood;\n    private BuildStatistics buildStatisticsNoRun;\n    private SVcsModification change0;\n    private SVcsModification change1;\n    private SVcsModification change2;\n    private SFinishedBuild buildGood;\n    private SFinishedBuild buildBad1;\n    private SFinishedBuild buildBad2;\n    private SFinishedBuild buildNoRun;\n    private List<SFinishedBuild> buildNoRunSequence;\n    private Mockery mockery;\n\n}\n\nclass AnalyserTest {\n\n    public static final int NUMBER_OF_NO_RUN_BUILDS_IN_SEQUENCE;\n    private TestName test1TestName;\n    private TestName test2TestName;\n    private STestRun test1STestRun;\n    private STest test1STest;\n    private TestInfo test1FailureTestInfo;\n    private STestRun test2STestRun;\n    private STest test2STest;\n    private TestInfo test2FailureTestInfo;\n    private BuildStatistics buildStatisticsGood;\n    private BuildStatistics buildStatisticsNoRun;\n    private SVcsModification change0;\n    private SVcsModification change1;\n    private SVcsModification change2;\n    private SFinishedBuild buildGood;\n    private SFinishedBuild buildBad1;\n    private SFinishedBuild buildBad2;\n    private SFinishedBuild buildNoRun;\n    private List<SFinishedBuild> buildNoRunSequence;\n    private Mockery mockery;\n\n    @Test\n    public void test01NoOutstandingFailures() {\n", "reference": "        /* No failures in the last build, no table. */\n\n        // arrange\n        mockery.checking(new Expectations() {{\n            allowing(buildGood).getTestMessages(0, -1); will(returnValue(Collections.emptyList()));\n        }});\n\n        // act\n        Table culpritTable = Analyser.createCulpritMatrix(Collections.singletonList(\n                new FinishedBuildWithChanges(buildGood, change0, Collections.<SVcsModification>emptyList())));\n\n        // assert\n        assertThat(culpritTable.getNumberOfColumns(), is(0));\n        assertThat(culpritTable.getNumberOfRows(), is(0));\n    }\n\n}", "prediction": "        List<FinishedBuildWithChanges> buildsWithContainingChanges = new ArrayList<FinishedBuildWithChanges>();\n        buildsWithContainingChanges.add(new FinishedBuildWithChanges(buildGood, new ArrayList<SVcsModification>()));\n\n        Table culpritMatrix = Analyser.createCulpritMatrix(buildsWithContainingChanges);\n\n        assertEquals(0, culpritMatrix.getFailuresInMostRecentBuild().size());\n        assertEquals(0, culpritMatrix.getBuildsSuspectedOfCausingFailure().size());\n        assertEquals(0, culpritMatrix.getBuildInWhichFailureFirstOccurred().size());\n        assertEquals(0, culpritMatrix.getFailuresSuspectedToBeCausedByBuild().size());\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "40101342_3", "part": [1, 1], "seq": [1, 1], "prompt": "class HbaseQueryImpl implements HbaseQuery {\n\n    @Override\n    public List<DynaBean> select(String sql) throws SQLSyntaxErrorException, IOException {\n        return select(sql, null, null);\n    }\n\n    @Override public List<DynaBean> select(String sql, String startRow,\n            String stopRow);\n    private SelectSqlVisitor parseSql(String sql);\n\n     HbaseQuery hbaseQuery;\n\n}\n\nclass HbaseQueryImplTest {\n\n     HbaseQuery hbaseQuery;\n\n    @Test\n    public void testLimit() throws SQLSyntaxErrorException, IOException {\n", "reference": "        String sql = \"SELECT TIME_ID, AREA_NAME FROM report1 limit 3 offset 2\";\n        HbaseQuery hbaseQuery = new HbaseQueryImpl();\n        List<DynaBean> rows = hbaseQuery.select(sql);\n        printBean(rows);\n        Assert.assertEquals(3, rows.size());\n    }\n\n}", "prediction": "        List<DynaBean> list = hbaseQuery.select(\"select * from test limit 10\");\n        Assert.assertEquals(10, list.size());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "40141672_1", "part": [1, 1], "seq": [1, 1], "prompt": "class StateListColourDrawableBuilder {\n\n    public StateListColourDrawableBuilder addStateColour(int[] states, int colour) {\n\n        for(int state: states) {\n            if(!ResourceUtils.isValidState(state)) {\n                throw new IllegalArgumentException(\"Invalid state passed to StateListColourDrawableBuilder: \" + state);\n            }\n        }\n\n        stateColoursList.add(new StateColour(states, colour));\n        return this;\n    }\n\n    public  StateListColourDrawableBuilder(int defaultColour);\n\n    public Drawable getDrawable();\n\n}\n\nclass StateListColourDrawableBuilderTest {\n\n    @Test\n    public void adding_invalid_state_should_fail() {\n", "reference": "        try {\n            StateListColourDrawableBuilder builder = new StateListColourDrawableBuilder(Color.BLACK);\n            builder.addStateColour(new int[]{1}, Color.RED);\n            fail(\"Adding invalid state should fail in StateListColourDrawableBuilder\");\n        } catch (IllegalArgumentException e) {}\n    }\n\n}", "prediction": "        StateListColourDrawableBuilder builder = new StateListColourDrawableBuilder(Color.RED);\n\n        try {\n            builder.addStateColour(new int[] { 0 }, Color.BLUE);\n            fail(\"Should have thrown IllegalArgumentException\");\n        } catch (IllegalArgumentException e) {\n            // expected\n        }\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "40162365_29", "part": [1, 1], "seq": [1, 1], "prompt": "class PauseResumeAudioRecorder {\n\n    public void setSampleRate(final int sampleRateInHertz){\n        if (sampleRateInHertz!=DEFAULT_AUDIO_SAMPLE_RATE_HERTZ && sampleRateInHertz!=22050\n                && sampleRateInHertz!= 16000 && sampleRateInHertz!=11025){\n            throw new IllegalArgumentException(\"Invalid sample rate given\");\n        }\n        else if (currentAudioState.get()!=PREPARED_STATE && currentAudioState.get()!=INITIALIZED_STATE ){\n            throw new IllegalStateException(\"Recorder cannot have its sample rate changed when it is not in an initialized or prepared state\");\n        }\n        this.sampleRateInHertz=sampleRateInHertz;\n    }\n\n    public  PauseResumeAudioRecorder();\n\n    public void setOnFileSizeReachedListener(final OnFileSizeReachedListener onFileSizeReachedListener);\n    public void setMaxFileSizeInBytes(final long maxFileSizeInBytes);\n    public void setOnTimeCompletionListener(final OnTimeCompletionListener onTimeCompletionListener);\n    public void setMaxTimeInMillis(final long maxTimeInMillis);\n    public void setAudioEncoding(final int audioEncoding);\n    public void setAudioFile(final String audioFilePath);\n    public void setChannel(final int channelConfig);\n    public int getCurrentState();\n    public void startRecording();\n    public void pauseRecording();\n    public void resumeRecording();\n    public void stopRecording();\n\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private PauseResumeAudioRecorder pauseResumeAudioRecorder;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private boolean failTest;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field sampleRateInHertzField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field channelConfigField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field audioEncodingField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field audioFileField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field currentAudioStateField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field currentAudioRecordingThreadField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field recordingStartTimeMillisField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field remainingMaxTimeInMillisField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field onTimeCompletedTimerField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field onTimeCompletionTimerTaskField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field onTimeCompletionListenerField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field maxTimeInMillisField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field onFileSizeReachedListenerField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field maxFileSizeInBytesField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field audioRecordThreadField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);@Mock\n    private Timer mockTimer;\n\n}\n\nclass PauseResumeAudioRecorderTest {\n\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private PauseResumeAudioRecorder pauseResumeAudioRecorder;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private boolean failTest;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field sampleRateInHertzField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field channelConfigField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field audioEncodingField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field audioFileField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field currentAudioStateField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field currentAudioRecordingThreadField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field recordingStartTimeMillisField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field remainingMaxTimeInMillisField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field onTimeCompletedTimerField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field onTimeCompletionTimerTaskField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field onTimeCompletionListenerField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field maxTimeInMillisField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field onFileSizeReachedListenerField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field maxFileSizeInBytesField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);private Field audioRecordThreadField;\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);@Mock\n    private Timer mockTimer;\n\n    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);@Test(expected = IllegalArgumentException.class)\n", "reference": "    public void testSetSampleRateBadInput(){pauseResumeAudioRecorder.setSampleRate(0);}\n\n}", "prediction": "\n}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "40492118_30", "part": [1, 1], "seq": [1, 1], "prompt": "class PreLollipopNetworkObservingStrategy implements NetworkObservingStrategy {\n\n  @Override public void onError(final String message, final Exception exception) {\n    Log.e(LOG_TAG, message, exception);\n  }\n\n  @Override public Observable<Connectivity> observeNetworkConnectivity(final Context context);\n  protected void tryToUnregisterReceiver(final Context context, final BroadcastReceiver receiver);\n  private Disposable disposeInUiThread(final Action action);\n\n  @Rule public MockitoRule rule;\n  @Spy private PreLollipopNetworkObservingStrategy strategy;\n  @Mock private BroadcastReceiver broadcastReceiver;\n\n}\n\nclass PreLollipopNetworkObservingStrategyTest {\n\n  @Rule public MockitoRule rule;\n  @Spy private PreLollipopNetworkObservingStrategy strategy;\n  @Mock private BroadcastReceiver broadcastReceiver;\n\n  @Test public void shouldCallOnError() {\n", "reference": "    // given\n    final String message = \"error message\";\n    final Exception exception = new Exception();\n\n    // when\n    strategy.onError(message, exception);\n\n    // then\n    verify(strategy, times(1)).onError(message, exception);\n  }\n\n}", "prediction": "    strategy.onError(\"message\", new Exception());\n\n    verify(strategy).onError(\"message\", any(Exception.class));\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "41307987_12", "part": [1, 1], "seq": [1, 1], "prompt": "class BasicLoop {\n\n\tpublic String doSomethingWithInput(String input) {\n\t\ttry {\n\t\t\tString[] articles = input.split(\",\");\n\t\t\tfor (String article : articles) {\n\t\t\t\tswitch (Articles.valueOf(article.trim().toLowerCase())) {\n\t\t\t\tcase pommes:\n\t\t\t\t\ttotal += 100;\n\t\t\t\t\ttotal += remisePommesGlobale();\n\t\t\t\t\tbreak;\n\t\t\t\tcase apples:\n\t\t\t\t\ttotal += 100;\n\t\t\t\t\ttotal += remiseApples();\n\t\t\t\t\ttotal += remisePommesGlobale();\n\t\t\t\t\tbreak;\n\t\t\t\tcase mele:\n\t\t\t\t\ttotal += 100;\n\t\t\t\t\ttotal += remiseMele();\n\t\t\t\t\ttotal += remisePommesGlobale();\n\t\t\t\t\tbreak;\n\t\t\t\tcase cerises:\n\t\t\t\t\ttotal += 75;\n\t\t\t\t\ttotal += remiseCerises();\n\t\t\t\t\tbreak;\n\t\t\t\tcase bananes:\n\t\t\t\t\ttotal += 150;\n\t\t\t\t\ttotal += remiseBananes();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttotal += remiseFruitGlobale();\n\t\t\t}\n\t\t\treturn \"< \" + String.valueOf(total);\n\t\t} catch (IllegalArgumentException|NullPointerException e) {\n\t\t\treturn \"< \" + input;\n\t\t}\n\t}\n\n\tpublic void loop();\n\tprivate int remiseBananes();\n\tprivate int remiseCerises();\n\tprivate int remiseApples();\n\tprivate int remiseMele();\n\tprivate int remisePommesGlobale();\n\tprivate int remiseFruitGlobale();\n\tpublic static void main(String[] args);\n\n}\n\nclass BasicLoopTest {\n\n    @Test\n    @Ignore\n    public void doit_supporter_la_remise_par_article() {\n", "reference": "    \tBasicLoop basicLoop = new BasicLoop();\n    \tString out = basicLoop.doSomethingWithInput(\"mele\");\n\t\tassertThat(out ).isEqualTo(\"< 100\");\n    \tout = basicLoop.doSomethingWithInput(\"Apples\");\n\t\tassertThat(out ).isEqualTo(\"< 200\");\n    \tout = basicLoop.doSomethingWithInput(\"apples\");\n\t\tassertThat(out ).isEqualTo(\"< 300\");\n\t\tout = basicLoop.doSomethingWithInput(\"Pommes\");\n\t\tassertThat(out ).isEqualTo(\"< 400\");\n\t\tout = basicLoop.doSomethingWithInput(\"apples\");\n\t\tassertThat(out ).isEqualTo(\"< 400\");\n\t\tout = basicLoop.doSomethingWithInput(\"mele\");\n\t\tassertThat(out ).isEqualTo(\"< 450\");\n    \tout = basicLoop.doSomethingWithInput(\"cerises\");\n\t\tassertThat(out ).isEqualTo(\"< 525\");\n    \tout = basicLoop.doSomethingWithInput(\"cerises\");\n\t\tassertThat(out ).isEqualTo(\"< 580\");\n    }\n\n}", "prediction": "\tBasicLoop loop = new BasicLoop();\n\tassertEquals(\"< 100\", loop.doSomethingWithInput(\"pommes\"));\n\tassertEquals(\"< 100\", loop.doSomethingWithInput(\"apples\"));\n\tassertEquals(\"< 100\", loop.doSomethingWithInput(\"mele\"));\n\tassertEquals(\"< 75\", loop.doSomethingWithInput(\"cerises\"));\n\tassertEquals(\"< 150\", loop.doSomethingWithInput(\"bananes\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "41633567_2", "part": [1, 1], "seq": [1, 1], "prompt": "class SpreadsheetMetadata implements ConnectorMetadata {\n\n  @Override\n  public ConnectorTableHandle getTableHandle(ConnectorSession session, SchemaTableName tableName) {\n    Path spreadsheetPath = getSpreadsheetBasePath(session.getUser());\n    Path filePath = getSpreadsheetFilePath(session, spreadsheetPath, tableName.getSchemaName());\n    return new SpreadsheetTableHandle(session.getUser(), tableName, filePath.toString());\n  }\n\n  public  SpreadsheetMetadata(UserGroupInformation ugi, Configuration configuration, Path basePath,\n      String spreadsheetSubDir, boolean useFileCache, boolean proxyUser);\n\n  @Override public List<ConnectorTableLayoutResult> getTableLayouts(ConnectorSession session, ConnectorTableHandle table,\n      Constraint<ColumnHandle> constraint, Optional<Set<ColumnHandle>> desiredColumns);\n  @Override public ConnectorTableLayout getTableLayout(ConnectorSession session, ConnectorTableLayoutHandle handle);\n  @Override public ColumnMetadata getColumnMetadata(ConnectorSession session, ConnectorTableHandle tableHandle,\n      ColumnHandle columnHandle);\n  @Override public ConnectorTableMetadata getTableMetadata(ConnectorSession session, ConnectorTableHandle table);\n  @Override public Map<SchemaTableName, List<ColumnMetadata>> listTableColumns(ConnectorSession session,\n      SchemaTablePrefix prefix);\n  private SpreadsheetTableLayoutHandle createTableLayoutHandle(SpreadsheetTableHandle tableHandle);\n  @Override public List<String> listSchemaNames(ConnectorSession session);\n  @Override public List<SchemaTableName> listTables(ConnectorSession session, String schemaNameOrNull);\n  @Override public Map<String, ColumnHandle> getColumnHandles(ConnectorSession session, ConnectorTableHandle tableHandle);\n  private Path getSpreadsheetFilePath(ConnectorSession session, Path spreadsheetPath, String schema);\n  private Path getSpreadsheetBasePath(String user);\n  private Type getType(TableType columnType);\n  public static SpreadsheetReader getSpreadSheetHelper(UserGroupInformation ugi, ConnectorSession session,\n      SpreadsheetTableHandle spreadsheetTableHandle, Configuration configuration, boolean useFileCache);\n  private UserGroupInformation getUgi(ConnectorSession session);\n  public static UserGroupInformation getUgi(ConnectorSession session, boolean proxyUser, UserGroupInformation ugi);\n  public static UserGroupInformation getProxyUserGroupInformation(ConnectorSession session, UserGroupInformation ugi);\n\n  private static UserGroupInformation ugi;\n  private static final String SCHEMA_NAME;\n  public static final ConnectorSession SESSION;\n  private boolean useFileCache;\n  private Configuration conf;\n\n}\n\nclass SpreadsheetMetadataTest {\n\n  private static UserGroupInformation ugi;\n  private static final String SCHEMA_NAME;\n  public static final ConnectorSession SESSION;\n  private boolean useFileCache;\n  private Configuration conf;\n\n  @Test\n  public void testGetTableHandle() throws IOException {\n", "reference": "    Path basePath = setupTest(conf, SESSION.getUser(), SpreadsheetMetadataTest.class);\n    SpreadsheetMetadata spreadsheetMetadata = new SpreadsheetMetadata(ugi, conf, basePath, SPREADSHEETS, useFileCache,\n        true);\n    List<SchemaTableName> listTables = spreadsheetMetadata.listTables(SESSION, SCHEMA_NAME);\n    for (SchemaTableName name : listTables) {\n      ConnectorTableHandle tableHandle = spreadsheetMetadata.getTableHandle(SESSION, name);\n      assertTrue(tableHandle instanceof SpreadsheetTableHandle);\n      SpreadsheetTableHandle spreadsheetTableHandle = (SpreadsheetTableHandle) tableHandle;\n      String filePath = new Path(new Path(new Path(basePath, SESSION.getUser()), SPREADSHEETS),\n          PRESTO_EXAMPLE_XLSX).toString();\n      assertEquals(filePath, spreadsheetTableHandle.getSpreadsheetPath());\n      SchemaTableName tableName = spreadsheetTableHandle.getTableName();\n      assertEquals(name, tableName);\n      assertEquals(SESSION.getUser(), spreadsheetTableHandle.getUser());\n    }\n  }\n\n}", "prediction": "    SpreadsheetMetadata metadata = new SpreadsheetMetadata(ugi, conf, null, null, useFileCache, false);\n    SchemaTableName tableName = new SchemaTableName(SCHEMA_NAME, \"test\");\n    ConnectorTableHandle tableHandle = metadata.getTableHandle(SESSION, tableName);\n    Assert.assertEquals(tableHandle.getConnectorId(), \"spreadsheet\");\n    Assert.assertEquals(tableHandle.getTableName(), tableName);\n    Assert.assertEquals(tableHandle.getFilePath(), \"test.xlsx\");\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "42032884_56", "part": [1, 1], "seq": [1, 1], "prompt": "class MwMobileViewPageLead extends MwResponse implements PageLead {\n\n    @VisibleForTesting\n    public Mobileview getMobileview() {\n        return mobileview;\n    }\n\n    @Override public Page toPage(@NonNull PageTitle title);\n    private PageTitle adjustPageTitle(@NonNull PageTitle title, @NonNull String originalPrefixedText);\n    @Override @NonNull public String getLeadSectionContent();\n    @Nullable @Override public String getTitlePronunciationUrl();\n    @Nullable @Override public String getLeadImageUrl(int leadImageWidth);\n    @Nullable @Override public String getThumbUrl();\n    @Nullable @Override public String getDescription();\n    @Nullable @Override public Location getGeo();\n\n    private PageClient subject;\n\n}\n\nclass MwMobileViewPageLeadTest extends MwResponse {\n\n    private PageClient subject;\n\n    @Test public void testUnprotectedDisambiguationPage() {\n", "reference": "        MwMobileViewPageLead pageLead = unmarshal(MwMobileViewPageLead.class,\n                wrapInMobileview(getUnprotectedDisambiguationPageJson()));\n        MwMobileViewPageLead.Mobileview props = pageLead.getMobileview();\n        verifyUnprotectedDisambiguationPage(props);\n    }\n\n}", "prediction": "        subject = new MwMobileViewPageLead(\n                new Mobileview(\n                        new MobileviewPage(\n                                new MobileviewPageLead(\n                                        new MobileviewPageLead(\n                                                new MobileviewPageLead(\n                                                        new MobileviewPageLead(\n                                                                new MobileviewPageLead(\n                                                                        new MobileviewPageLead(\n                                                                                new MobileviewPageLead(\n                                                                                        new MobileviewPageLead(\n                                                                                                new MobileviewPageLead(\n                                                                                                        new MobileviewPageLead(\n                                                                                                                new MobileviewPageLead(\n                                                                                                                        new MobileviewPageLead(\n                                                                                                                                new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                                new MobileviewPageLead(\n                                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(\n                                                                                                                                        new MobileviewPageLead(", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "42112681_1", "part": [1, 1], "seq": [1, 1], "prompt": "class Symbol {\n\n  public static String java2Elisp(String javaName) {\n\n    StringBuffer lispName        = new StringBuffer();\n    boolean      lastCharWasDash = false;\n    char         prev            ='';\n\n    for (int i = 0; i < javaName.length(); i++) {\n\n      char c = javaName.charAt(i);\n\n      if (!Character.isLetterOrDigit(c)) {\n        lispName.append('-');\n        lastCharWasDash = true;\n      } else {\n        // add in a dash only if the last character was not a dash and we\n        // didn't undergo a case change from lower to upper case\n        if (i > 0 &&!lastCharWasDash\n            && Character.isLetter(prev)\n            && Character.isLetter(c)\n            && Character.isLowerCase(prev)\n            && Character.isUpperCase(c)) {\n          lispName.append('-');\n        }\n\n        lispName.append(Character.toLowerCase(c));\n        lastCharWasDash = false;\n      }\n      prev = c;\n    }\n\n    return lispName.toString();\n  }\n\n  public  Symbol(String name);\n\n  public String getName();\n  public String toString();\n\n}\n\nclass SymbolTest {\n\n    @Test\n    public void testJava2Elisp2() {\n", "reference": "        assertEquals(\"jdee-foo-call-left-right\", Symbol.java2Elisp(\"jdee.foo.Call.leftRight\"));\n    }\n\n}", "prediction": "\tassertEquals(\"foo-bar\", Symbol.java2Elisp(\"FooBar\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "42949039_256", "part": [1, 1], "seq": [1, 1], "prompt": "class BusinessObjectDataKeyComparator implements Comparator<BusinessObjectDataKey>, Serializable {\n\n    @Override\n    public int compare(final BusinessObjectDataKey data1, final BusinessObjectDataKey data2)\n    {\n        if (data1 == null || data2 == null)\n        {\n            return data1 == null && data2 == null? 0 : (data1 == null? -1 : 1);\n        }\n        int result = ObjectUtils.compare(data1.getBusinessObjectDefinitionName(), data2.getBusinessObjectDefinitionName());\n        if (result!= 0)\n        {\n            return result;\n        }\n        result = ObjectUtils.compare(data1.getBusinessObjectFormatUsage(), data2.getBusinessObjectFormatUsage());\n        if (result!= 0)\n        {\n            return result;\n        }\n        result = ObjectUtils.compare(data1.getBusinessObjectFormatFileType(), data2.getBusinessObjectFormatFileType());\n        if (result!= 0)\n        {\n            return result;\n        }\n        result = ObjectUtils.compare(data1.getBusinessObjectFormatVersion(), data2.getBusinessObjectFormatVersion());\n        if (result!= 0)\n        {\n            return result;\n        }\n        result = ObjectUtils.compare(data1.getPartitionValue(), data2.getPartitionValue());\n        if (result!= 0)\n        {\n            return result;\n        }\n        return ObjectUtils.compare(data1.getBusinessObjectDataVersion(), data2.getBusinessObjectDataVersion());\n    }\n\n    private BusinessObjectDataKeyComparator comparator;\n\n}\n\nclass BusinessObjectDataKeyComparatorTest {\n\n    private BusinessObjectDataKeyComparator comparator;\n\n    @Test\n    public void testCompareBusinessObjectDataVersion() throws Exception\n    {\n", "reference": "        BusinessObjectDataKey businessObjectDataKey1 = new BusinessObjectDataKey();\n        BusinessObjectDataKey businessObjectDataKey2 = new BusinessObjectDataKey();\n\n        // \"a\" = \"b\"\n        businessObjectDataKey1.setBusinessObjectDataVersion(0);\n        businessObjectDataKey2.setBusinessObjectDataVersion(0);\n        assertEquals(0, comparator.compare(businessObjectDataKey1, businessObjectDataKey2));\n\n        // \"a\" < \"b\"\n        businessObjectDataKey1.setBusinessObjectDataVersion(0);\n        businessObjectDataKey2.setBusinessObjectDataVersion(1);\n        assertEquals(-1, comparator.compare(businessObjectDataKey1, businessObjectDataKey2));\n\n        // \"b\" > \"a\"\n        assertEquals(1, comparator.compare(businessObjectDataKey2, businessObjectDataKey1));\n    }\n\n}", "prediction": "        BusinessObjectDataKey data1 = new BusinessObjectDataKey(\"BO1\", \"USAGE1\", \"FILETYPE1\", \"VERSION1\", \"PARTITION1\", \"VERSION1\");\n        BusinessObjectDataKey data2 = new BusinessObjectDataKey(\"BO1\", \"USAGE1\", \"FILETYPE1\", \"VERSION1\", \"PARTITION1\", \"VERSION2\");\n        assertEquals(0, comparator.compare(data1, data2));\n        assertEquals(0, comparator.compare(data2, data1));\n\n        data1 = new BusinessObjectDataKey(\"BO1\", \"USAGE1\", \"FILETYPE1\", \"VERSION1\", \"PARTITION1\", \"VERSION1\");\n        data2 = new BusinessObjectDataKey(\"BO1\", \"USAGE1\", \"FILETYPE1\", \"VERSION1\", \"PARTITION1\", \"VERSION2\");\n        assertEquals(0, comparator.compare(data1, data2));\n        assertEquals(0, comparator.compare(data2, data1));\n\n        data1 = new BusinessObjectDataKey(\"BO1\", \"USAGE1\", \"FILETYPE1\", \"VERSION1\", \"PARTITION1\", \"VERSION1\");\n        data2 = new BusinessObjectDataKey(\"BO1\", \"USAGE1\", \"FILETYPE1\", \"VERSION1\", \"PARTITION1\", \"VERSION2\");\n        assertEquals(0, comparator.compare(data1, data2));\n        assertEquals(0, comparator.compare(data2, data1));\n\n        data1 = new BusinessObjectDataKey(\"BO1\", \"USAGE1\", \"FILETYPE1\", \"VERSION1\", \"PARTITION1\", \"VERSION1\");\n        data2 = new BusinessObjectDataKey(\"BO1\", \"USAGE1\", \"FILETYPE1\", \"VERSION1\", \"PARTITION1\", \"VERSION2\");\n        assertEquals(0, comparator.compare(data1, data2));\n        assertEquals(0, comparator.compare(data2, data1));\n\n        data1 = new BusinessObjectDataKey(\"BO1\", \"USAGE1\", \"FILETYPE1\", \"VERSION1\", \"PARTITION1\", \"VERSION1\");\n        data2 = new BusinessObjectDataKey(\"BO1\", \"USAGE1\", \"FILETYPE1\", \"VERSION1\", \"PARTITION1\", \"VERSION2\");\n        assertEquals(0, comparator.compare(data1, data2));\n        assertEquals(0, comparator.compare(data2, data1));\n\n        data1 = new BusinessObjectDataKey(\"BO1\", \"USAGE1\", \"FILETYPE1\", \"VERSION1\", \"PARTITION1\", \"VERSION1\");\n        data2 = new BusinessObjectDataKey(\"BO1\", \"USAGE1\", \"FILETYPE1\", \"VERSION1\", \"PARTITION1\", \"VERSION2\");\n        assertEquals(0, comparator.compare(data1, data2));\n        assertEquals(0, comparator.compare(data2, data1));\n\n        data1 = new BusinessObjectDataKey(\"BO1\", \"USAGE1\", \"FILETYPE1\", \"VERSION1\", \"PARTITION1\", \"VERSION1\");\n        data2 = new BusinessObjectDataKey(\"BO1\", \"USAGE1\", \"FILETYPE1\", \"VERSION1\", \"PARTITION1\", \"VERSION2\");\n        assertEquals(0, comparator.compare(data1, data2));\n        assertEquals(0, comparator.compare(data2, data1));\n\n        data1 = new BusinessObjectDataKey(\"BO1\", \"USAGE1\", \"FILETYPE1\", \"VERSION1\", \"PARTITION1\", \"VERSION1\");\n        data2 = new BusinessObjectDataKey(\"BO1\", \"USAGE1\", \"FILETYPE1\", \"VERSION1\", \"PARTITION1\", \"VERSION2\");\n        assertEquals(0, comparator.compare(data1, data2));\n        assertEquals(0, comparator.compare(data2, data1));\n\n        data1 = new BusinessObjectDataKey(\"BO1\", \"USAGE1\", \"FILETYPE1\", \"VERSION1\", \"PARTITION1\", \"VERSION1\");\n        data2 = new BusinessObjectDataKey(\"BO1\", \"USAGE1\", \"FILETYPE1\", \"VERSION1\", \"PARTITION1\", \"VERSION2\");\n        assertEquals(0, comparator.compare(data1, data2));\n        assertEquals(0, comparator.compare(data2, data1));\n\n        data1 = new BusinessObjectDataKey(\"BO1\", \"USAGE1\", \"FILETYPE1\", \"VERSION1\", \"PARTITION1\", \"VERSION1\");\n        data2 = new BusinessObjectDataKey(\"BO1\", \"USAGE1\", \"FILETYPE1\", \"VERSION1\", \"PARTITION1\", \"VERSION2\");\n        assertEquals(0, comparator.compare(data1, data2));\n        assertEquals(0, comparator.compare(data2, data1));\n\n        data1 = new BusinessObjectDataKey(\"BO1\", \"USAGE1\", \"FILETYPE1\", \"VERSION1\", \"PARTITION1\", \"VERSION1\");\n        data2 = new BusinessObjectDataKey(\"BO1\", \"USAGE1\", \"FILETYPE1\", \"VERSION1\", \"PARTITION1\", \"VERSION2\");\n        assertEquals(0, comparator.compare(data1, data2));\n        assertEquals(0, comparator.compare(data2, data1));\n\n        data1 = new BusinessObjectDataKey(\"BO1\", \"USAGE1\", \"FILETYPE1\", \"VERSION1\", \"PARTITION1\", \"VERSION1\");\n        data2 = new BusinessObjectDataKey(\"BO1\", \"USAGE1\", \"FILETYPE1\", \"VERSION1\", \"PARTITION1\", \"VERSION2\");\n        assertEquals(0, comparator.compare(data1, data2));\n        assertEquals(0, comparator.compare(data2, data1));\n\n        data1 = new BusinessObjectDataKey(\"BO1\", \"USAGE1\", \"FILETYPE1\", \"VERSION1\", \"PARTITION1\", \"VERSION1\");\n        data2 = new BusinessObjectDataKey(\"BO1\", \"USAGE1\", \"FILETYPE1\", \"VERSION1\", \"PARTITION1\", \"VERSION2\");\n        assertEquals(0, comparator.compare(data1, data2));\n        assertEquals(0, comparator.compare(data2, data1));\n\n        data1 = new BusinessObjectDataKey(\"BO1\", \"USAGE1\", \"FILETYPE1\", \"VERSION1\", \"PARTITION1\", \"VERSION1\");\n        data2 = new BusinessObjectDataKey(\"BO1\", \"USAGE1\", \"FILETYPE1\", \"VERSION1\", \"PARTITION1\", \"VERSION2\");\n        assertEquals(0, comparator.compare(data1, data2));\n        assertEquals(0, comparator.compare(data2, data1));\n\n        data1 = new BusinessObjectDataKey(\"BO1\", \"USAGE1\", \"FILETYPE1\", \"VERSION1\", \"PARTITION1\", \"VERSION1\");\n        data2 = new BusinessObjectDataKey(\"BO1\", \"USAGE1\", \"FILETYPE1\", \"VERSION1\", \"PARTITION1\", \"VERSION2\");\n        assertEquals(0, comparator.compare(data1, data2));\n        assertEquals(0, comparator.compare(data2, data1));\n\n        data1 = new BusinessObjectDataKey(\"BO1\", \"USAGE1\", \"FILETYPE1\", \"VERSION1\", \"PARTITION1\", \"VERSION1\");\n        data2 = new BusinessObjectDataKey(\"BO1\", \"USAGE1\", \"FILETYPE1\", \"VERSION1\", \"PARTITION1\", \"VERSION2\");\n        assertEquals(0, comparator.compare(data1, data2));\n        assertEquals(0, comparator.compare(data2, data1));\n\n        data1 = new BusinessObjectDataKey(\"BO1\", \"USAGE1\", \"FILETYPE1\", \"VERSION1\", \"PARTITION1\", \"VERSION1\");\n        data2 = new BusinessObjectDataKey(\"BO1\", \"USAGE1\", \"FILETYPE1\", \"VERSION1\", \"PARTITION1\", \"VERSION2\");\n        assertEquals(0, comparator.compare(data1, data2));\n        assertEquals(0, comparator.compare(data2, data1));\n\n        data1 = new", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "43156715_2", "part": [1, 1], "seq": [1, 1], "prompt": "class Filter {\n\n    public static Function<Beacon, Boolean> proximityIsEqualTo(final Proximity... proximities) {\n        return new Function<Beacon, Boolean>() {\n            @Override\n            public Boolean apply(Beacon beacon) {\n                for (Proximity proximity : proximities) {\n                    if (beacon.getProximity() == proximity) {\n                        return true;\n                    }\n                }\n\n                return false;\n            }\n        };\n    }\n\n    public static Function<Beacon, Boolean> proximityIsNotEqualTo(final Proximity... proximities);\n    public static Function<Beacon, Boolean> distanceIsEqualTo(final double distance);\n    public static Function<Beacon, Boolean> distanceIsGreaterThan(final double distance);\n    public static Function<Beacon, Boolean> distanceIsLowerThan(final double distance);\n    public static Function<Beacon, Boolean> hasName(final String... names);\n    public static Function<Beacon, Boolean> exceptName(final String... names);\n    public static Function<Beacon, Boolean> hasMacAddress(final String... macs);\n    public static Function<Beacon, Boolean> exceptMacAddress(final String... macs);\n    public static Function<Beacon, Boolean> hasMacAddress(final MacAddress... macs);\n    public static Function<Beacon, Boolean> exceptMacAddress(final MacAddress... macs);\n\n}\n\nclass FilterTest {\n\n  @Test\n  public void proximityShouldBeEqualToImmediateAndNear() {\n", "reference": "    // given\n    Beacon beacon = Mockito.mock(Beacon.class);\n\n    // when\n    when(beacon.getProximity()).then(new Answer<Proximity>() {\n      @Override\n      public Proximity answer(InvocationOnMock invocationOnMock) throws Throwable {\n        return Proximity.NEAR;\n      }\n    });\n\n    Function<Beacon, Boolean> filter =\n        Filter.proximityIsEqualTo(Proximity.IMMEDIATE, Proximity.NEAR);\n    Boolean call = apply(filter, beacon);\n\n    // then\n    assertThat(call).isTrue();\n  }\n\n}", "prediction": "    Function<Beacon, Boolean> filter = Filter.proximityIsEqualTo(Proximity.IMMEDIATE, Proximity.NEAR);\n    Beacon beacon = new Beacon(\"1234567890\", 100, 100, Proximity.FAR);\n\n    assertThat(filter.apply(beacon)).isFalse();\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "43258821_3", "part": [1, 1], "seq": [1, 1], "prompt": "class Streams {\n\n    @NotNull\n    public static <S, T> Stream<ResultWrapper<T>> parallelize(\n            @NotNull Collection<S> source,\n            @NotNull Function<S, Supplier<T>> mapper\n    ) {\n        // operations will be executed in parallel\n        List<CompletableFuture<ResultWrapper<T>>> results = source.stream()\n               .map(s -> CompletableFuture.supplyAsync(new ResultSupplier<>(mapper.apply(s)), parallelExecutor))\n               .collect(ImmutableList.toImmutableList());\n\n        return collect(results);\n    }\n\n    private  Streams();\n\n    @NotNull public static Stream<ResultWrapper<T>> parallelize(int n, @NotNull Supplier<T> supplier);\n    private static Stream<ResultWrapper<T>> collect(List<CompletableFuture<ResultWrapper<T>>> results);\n\n}\n\nclass StreamsTest {\n\n    @Test\n    public void parallelizeSupplier() {\n", "reference": "        assertEquals((long) Streams.parallelize(3, () -> 42L)\n                .filter(r -> !r.hasError())\n                .map(ResultWrapper::getResult)\n                .reduce(0L, (a, b) -> a + b), 126L);\n    }\n\n}", "prediction": "        List<String> source = Arrays.asList(\"a\", \"b\", \"c\");\n        List<String> expected = Arrays.asList(\"a\", \"b\", \"c\");\n\n        List<String> actual = Streams.parallelize(source, s -> () -> s).map(ResultWrapper::get).collect(Collectors.toList());\n\n        assertEquals(expected, actual);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "43306906_7", "part": [1, 1], "seq": [1, 1], "prompt": "class SparseIntArrayBuilder {\n\n  @NonNull @CheckResult public SparseIntArray build() {\n    return sparseIntArray;\n  }\n\n  public  SparseIntArrayBuilder();\n  public  SparseIntArrayBuilder(final int capacity);\n  public  SparseIntArrayBuilder(@NonNull final SparseIntArray sparseIntArray);\n\n  @CheckResult public SparseIntArrayBuilder put(final int key, final int value);\n  @CheckResult public SparseIntArrayBuilder add(final int key, final int value);\n  @CheckResult public SparseIntArrayBuilder add(@Nullable final SparseIntArray array);\n  @CheckResult public SparseIntArrayBuilder clear();\n\n}\n\nclass SparseIntArrayBuilderTest {\n\n  @Test public void constructor0CapacityBuildShouldReturnEmpty() {\n", "reference": "    final SparseIntArray actual = new SparseIntArrayBuilder(0).build();\n    final SparseIntArray expected = new SparseIntArray();\n\n    assertSparseIntArrayEquals(expected, actual);\n  }\n\n}", "prediction": "    final SparseIntArray sparseIntArray = new SparseIntArrayBuilder().build();\n    assertThat(sparseIntArray.size()).isEqualTo(0);\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "44322761_17", "part": [1, 1], "seq": [1, 1], "prompt": "class District implements AddressEntity, Comparable<District> {\n\n    public String getProvinceCode() {\n        return code.substring(0, 2);\n    }\n\n    public  District(String code, String name);\n\n    @Override public String getCode();\n    @Override public String getName();\n    @Override public int hashCode();\n    @Override public boolean equals(Object other);\n    @Override public String toString();\n    @Override public int compareTo(District that);\n\n    private District bangkok;\n\n}\n\nclass DistrictTest {\n\n    private District bangkok;\n\n    @Test\n    public void getProvinceCode() {\n", "reference": "        assertEquals(\"10\", bangkok.getProvinceCode());\n    }\n\n}", "prediction": "        assertEquals(\"10\", bangkok.getProvinceCode());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "44442208_5", "part": [1, 1], "seq": [1, 1], "prompt": "class VaultSecurityManager implements SecurityManager {\n\n    @Override\n    public Object authenticate(Properties properties) throws AuthenticationFailedException {\n        String username = properties.getProperty(\"security-username\");\n        Assert.hasText(username, \"Missing username\");\n        LOG.info(\"authenticate: username={}\", username);\n\n        String password = properties.getProperty(\"security-password\");\n        Assert.hasText(password, \"Missing password\");\n        LOG.trace(\"authenticate: username={}, password={}\", username, password);\n\n        VaultResponse vaultResponse = vaultTemplate.read(readPath + username);\n\n        if (vaultResponse == null) {\n            throw new AuthenticationFailedException(username);\n        }\n\n        String actualPassword = (String) vaultResponse.getData().get(\"password\");\n        LOG.trace(\"authenticate: username={}, password={}, actualPassword={}\", username, password, actualPassword);\n\n        if (!password.equals(actualPassword)) {\n            throw new AuthenticationFailedException(username);\n        }\n\n        return new UsernamePrincipal(username);\n    }\n\n    public  VaultSecurityManager();\n    public  VaultSecurityManager(VaultTemplate vaultTemplate, String readPath);\n\n    @Override public void init(Properties securityProps);\n    @Override public boolean authorize(Object principal, ResourcePermission permission);\n    @Override public void close();\n\n    private VaultSecurityManager vaultSecurityManager;\n    @Mock\n    private VaultTemplate vaultTemplate;\n\n}\n\nclass VaultSecurityManagerTest {\n\n    private VaultSecurityManager vaultSecurityManager;\n    @Mock\n    private VaultTemplate vaultTemplate;\n\n    @Test\n    void authenticate_success() {\n", "reference": "        String username = \"some-user\";\n        String password = \"some-password\";\n\n        VaultResponse vaultResponse = mock(VaultResponse.class);\n        Map<String, Object> data = new HashMap<>();\n        data.put(\"password\", password);\n        when(vaultResponse.getData()).thenReturn(data);\n        when(vaultTemplate.read(anyString())).thenReturn(vaultResponse);\n\n        Properties props = new Properties();\n        props.setProperty(\"security-username\",username);\n        props.setProperty(\"security-password\",password);\n        vaultSecurityManager.authenticate(props);\n    }\n\n}", "prediction": "        Properties properties = new Properties();\n        properties.setProperty(\"security-username\", \"user1\");\n        properties.setProperty(\"security-password\", \"\");\n\n        when(vaultTemplate.read(anyString())).thenReturn(new VaultResponse(new HashMap<>()));\n\n        vaultSecurityManager.authenticate(properties);\n\n        verify(vaultTemplate, times(1)).read(anyString());\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "44512524_217", "part": [1, 1], "seq": [1, 1], "prompt": "class FilterAction extends Action<Query> {\n\n    @Override\n    public QueryResponse execute(Query parameter) throws QueryStoreException {\n        parameter.setTable(ElasticsearchUtils.getValidTableName(parameter.getTable()));\n        if (null == parameter.getFilters() || parameter.getFilters().isEmpty()) {\n            parameter.setFilters(Lists.<Filter>newArrayList(new AnyFilter(parameter.getTable())));\n        }\n        if (null == parameter.getSort()) {\n            ResultSort resultSort = new ResultSort();\n            resultSort.setField(\"_timestamp\");\n            resultSort.setOrder(ResultSort.Order.desc);\n            parameter.setSort(resultSort);\n        }\n        SearchRequestBuilder search = null;\n        SearchResponse response;\n        try {\n            /*if(!tableManager.exists(query.getTable())) {\n                throw new QueryStoreException(QueryStoreException.ErrorCode.NO_SUCH_TABLE,\n                        \"There is no table called: \" + query.getTable());\n            }*/\n            search = getConnection().getClient().prepareSearch(ElasticsearchUtils.getIndices(parameter.getTable(), parameter))\n                   .setTypes(ElasticsearchUtils.TYPE_NAME)\n                   .setQuery(new ElasticSearchQueryGenerator(FilterCombinerType.and).genFilter(parameter.getFilters()))\n                   .setSearchType(SearchType.QUERY_THEN_FETCH)\n                   .setFrom(parameter.getFrom())\n                   .setSize(parameter.getLimit());\n            search.addSort(parameter.getSort().getField(),\n                    ResultSort.Order.desc == parameter.getSort().getOrder()? SortOrder.DESC : SortOrder.ASC);\n            response = search.execute().actionGet();\n            Vector<String> ids = new Vector<String>();\n            for (SearchHit searchHit : response.getHits()) {\n                ids.add(searchHit.getId());\n            }\n            if (ids.isEmpty()) {\n                return new QueryResponse(Collections.<Document>emptyList());\n            }\n            return new QueryResponse(getQueryStore().get(parameter.getTable(), ids));\n        } catch (Exception e) {\n            if (null!= search) {\n                logger.error(\"Error running generated query: \" + search, e);\n            } else {\n                logger.error(\"Query generation error: \", e);\n            }\n            throw new QueryStoreException(QueryStoreException.ErrorCode.QUERY_EXECUTION_ERROR,\n                    \"Error running query: \" + parameter.toString());\n        }\n    }\n\n    public  FilterAction(Query parameter,\n                        TableMetadataManager tableMetadataManager,\n                        DataStore dataStore,\n                        QueryStore queryStore,\n                        ElasticsearchConnection connection,\n                        String cacheToken);\n\n    @Override protected String getRequestCacheKey();\n\n    private QueryExecutor queryExecutor;\n    private ObjectMapper mapper;\n    private MockElasticsearchServer elasticsearchServer;\n    private HazelcastInstance hazelcastInstance;\n\n}\n\nclass FilterActionTest {\n\n    private QueryExecutor queryExecutor;\n    private ObjectMapper mapper;\n    private MockElasticsearchServer elasticsearchServer;\n    private HazelcastInstance hazelcastInstance;\n\n    @Test\n    public void testQueryEmptyResult() throws QueryStoreException, JsonProcessingException {\n", "reference": "        Query query = new Query();\n        query.setTable(TestUtils.TEST_TABLE_NAME);\n\n        EqualsFilter equalsFilter = new EqualsFilter();\n        equalsFilter.setField(\"os\");\n        equalsFilter.setValue(\"wp8\");\n        query.setFilters(Lists.<Filter>newArrayList(equalsFilter));\n\n        List<Document> documents = new ArrayList<Document>();\n        QueryResponse actualResponse = QueryResponse.class.cast(queryExecutor.execute(query));\n        compare(documents, actualResponse.getDocuments());\n    }\n\n}", "prediction": "        Query query = new Query();\n        query.setTable(\"test\");\n        query.setFilters(Lists.<Filter>newArrayList(new AnyFilter(\"test\")));\n        QueryResponse response = queryExecutor.execute(query);\n        Assert.assertEquals(0, response.getDocuments().size());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "44579325_0", "part": [1, 1], "seq": [1, 1], "prompt": "class MoshasEngine {\n\n    public Template describe(String templateName, ViewLogicDescriber describer) {\n        if (describer == null) {\n            throw new IllegalArgumentException(\"describer is required\");\n        }\n\n        Template template = manager.loadTemplate(templateName);\n\n        describeSnippet(template, describer);\n        // Mark selected elements\n        Element root = template.getRootElement();\n        root.children().forEach(Element::selected);\n\n        manager.cacheTemplate(templateName, template);\n        describerCache.put(templateName, describer);\n        return template;\n    }\n\n    public  MoshasEngine(TemplateManager manager);\n    public  MoshasEngine();\n\n    public TemplateManager getTemplateManager();\n    private Snippet describeSnippet(Snippet snippet, ViewLogicDescriber describer);\n    public Snippet describe(String templateName, String selector, ViewLogicDescriber describer);\n    public String process(String templateName, IContext context);\n    public void process(String templateName, IContext context, Writer writer);\n\n    @Parameterized.Parameter(0)\n    public MoshasEngine engine;\n\n}\n\nclass MoshasEngineTest {\n\n    @Parameterized.Parameter(0)\n    public MoshasEngine engine;\n\n    @Test(expected = TemplateNotFoundException.class)\n    public void test() {\n", "reference": "        engine.describe(\"notfound\", t -> {});\n    }\n\n}", "prediction": "        engine.describe(\"test\", null);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "45926632_2", "part": [1, 1], "seq": [1, 1], "prompt": "class CollectorFactory {\n\n  public CollectorType getType() {\n    return type;\n  }\n\n  public  CollectorFactory(\n      CollectorType type,\n      TimeUtils time,\n      KafkaServer server,\n      Properties serverConfiguration,\n      Runtime serverRuntime\n  );\n\n  public Collector getCollector();\n\n}\n\nclass CollectorFactoryTest {\n\n    @Test\n    public void testBasicType() {\n", "reference": "        // Given\n        TimeUtils time = new TimeUtils();\n        CollectorFactory factory = new CollectorFactory(CollectorType.BASIC, time, null, null, null);\n\n        // when\n        CollectorType type = factory.getType();\n\n        // Then\n        assertThat(type).isEqualTo(CollectorType.BASIC);\n    }\n\n}", "prediction": "        CollectorFactory factory = new CollectorFactory(CollectorType.BASIC, null, null, null, null);\n        Collector collector = factory.getCollector();\n        assertTrue(collector instanceof BasicCollector);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "45991588_0", "part": [1, 1], "seq": [1, 1], "prompt": "class NumberProvider {\n\n  public int provideNumber() {\n    return 42;\n  }\n\n}\n\nclass NumberProviderTest {\n\n  @Test public void shouldProvideProperNumber() {\n", "reference": "    // given\n    NumberProvider numberProvider = new NumberProvider();\n\n    // when\n    int number = numberProvider.provideNumber();\n\n    // then\n    assertThat(number).isEqualTo(42);\n  }\n\n}", "prediction": "    NumberProvider numberProvider = new NumberProvider();\n    assertThat(numberProvider.provideNumber()).isEqualTo(42);\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "46134098_14", "part": [1, 1], "seq": [1, 1], "prompt": "class JavaPropertiesResource extends ResourceFilter {\n\n    @Override\n    public void write(OutputStream outStream, LanguageBundle languageBundle,\n            FilterOptions options) throws IOException, ResourceFilterException {\n\n        List<ResourceString> resStrings = languageBundle.getSortedResourceStrings();\n        BreakIterator brkItr = Utils.getWordBreakIterator(options);\n\n        PrintWriter pw = new PrintWriter(new OutputStreamWriter(outStream, getCharset()));\n        for (String note : languageBundle.getNotes()) {\n            if (enc == Encoding.UTF_8) {\n                // No needs to escape raw Unicode charters\n                pw.println(\"#\" + note);\n            } else {\n                // Needs to escape Unicode characters\n                pw.println(\"#\" + escapeOnlyUnicode(note));\n            }\n        }\n        if (!languageBundle.getNotes().isEmpty()) {\n            pw.println();\n        }\n        pw.println(\"#\"+new Date().toString());\n        for (ResourceString res : resStrings) {\n            String value = res.getValue();  \n            value = escapeMessagePattern(value, msgPatEsc);\n            PropDef pd = new PropDef(res.getKey(),value,PropDef.PropSeparator.EQUAL,res.getNotes());\n            pd.print(pw, brkItr, (enc == Encoding.UTF_8));\n        }\n        pw.close();\n    }\n\n    public  JavaPropertiesResource(Encoding enc, MessagePatternEscape msgPatEsc);\n    public  JavaPropertiesResource();\n\n    @Override public LanguageBundle parse(InputStream inStream, FilterOptions options);\n    private boolean isContinuationLine(String s);\n    private Charset getCharset();\n    private static String escape(String str, EscapeSpace escSpace, boolean isUTF8);\n    static String escapePropKey(String str);\n    static String escapePropKey(String str, boolean isUTF8);\n    static String escapePropValue(String str);\n    static String escapePropValue(String str, boolean isUTF8);\n    static void appendUnicodeEscape(StringBuilder buf, char codeUnit);\n    static String unescapePropKey(String str);\n    static String unescapePropValue(String str);\n    private static String unescape(String str);\n    private static String escapeOnlyUnicode(String str);\n    private static String unescapeOnlyUnicode(String str);\n    static String unescapeMessagePattern(String inputStr, MessagePatternEscape msgPatEsc);\n    static String escapeMessagePattern(String inputStr, MessagePatternEscape msgPatEsc);\n    static boolean hasArgs(MessagePattern msgPat);\n    @Override public void merge(InputStream baseStream, OutputStream outStream, LanguageBundle languageBundle,\n            FilterOptions options);\n    private static int getLeadingSpacesLength(String s);\n    private static String stripLeadingSpaces(String s);\n    private static boolean isPropsWhiteSpaceChar(char c);\n\n    private static final File INPUT_FILE;\n    private static final File EXPECTED_WRITE_FILE;\n    private static final File EXPECTED_WRITE_FILE_ALL;\n    private static final File EXPECTED_MERGE_FILE;\n    private static final File PARSE_TEST_INPUT_FILE;\n    private static final Collection<ResourceString> EXPECTED_INPUT_RES_LIST;\n    private static LanguageBundle WRITE_BUNDLE;\n    private static LanguageBundle WRITE_BUNDLE_ALL;\n    private static LinkedList<PropDef> EXPECTED_PROP_DEF_LIST;\n    private static final JavaPropertiesResource res;\n    private static final String[][] UNESC_TEST_CASES;\n    private static final String[][] MESSAGE_PATTERN_TEST_CASES;\n\n}\n\nclass JavaPropertiesResourceTest {\n\n    private static final File INPUT_FILE;\n    private static final File EXPECTED_WRITE_FILE;\n    private static final File EXPECTED_WRITE_FILE_ALL;\n    private static final File EXPECTED_MERGE_FILE;\n    private static final File PARSE_TEST_INPUT_FILE;\n    private static final Collection<ResourceString> EXPECTED_INPUT_RES_LIST;\n    private static LanguageBundle WRITE_BUNDLE;\n    private static LanguageBundle WRITE_BUNDLE_ALL;\n    private static LinkedList<PropDef> EXPECTED_PROP_DEF_LIST;\n    private static final JavaPropertiesResource res;\n    private static final String[][] UNESC_TEST_CASES;\n    private static final String[][] MESSAGE_PATTERN_TEST_CASES;\n\n    @Test\n    public void testWriteAllQuotes() throws IOException, ResourceFilterException {\n", "reference": "        File tempFile = File.createTempFile(this.getClass().getSimpleName(), \".properties\");\n        JavaPropertiesResource res = new JavaPropertiesResource(Encoding.ISO_8859_1, MessagePatternEscape.ALL);\n        tempFile.deleteOnExit();\n        try (OutputStream os = new FileOutputStream(tempFile)) {\n            res.write(os, WRITE_BUNDLE_ALL, null);\n            os.flush();\n            // Ignore first line in both the files (first line empty in expected, first line contains timestamp in actual) \n            assertTrue(ResourceTestUtil.compareFiles(EXPECTED_WRITE_FILE_ALL, tempFile, 1));\n        }\n    }\n\n}", "prediction": "        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        res.write(baos, WRITE_BUNDLE_ALL, new FilterOptions());\n        String actual = baos.toString(res.getCharset().name());\n        String expected = IOUtils.toString(EXPECTED_WRITE_FILE_ALL, res.getCharset().name());\n        assertEquals(expected, actual);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "46396068_28", "part": [1, 1], "seq": [1, 1], "prompt": "class Assign implements Command {\n\n    @Override\n    public void run() throws Exception {\n        String actionStr = ((String) args.getOptionSet().nonOptionArguments().get(1)).toUpperCase();\n        AssignAction assignAction = AssignAction.valueOf(actionStr);\n        assignAction.run(admin, args);\n    }\n\n    public  Assign(HBaseAdmin admin, Args args);\n\n    @SuppressWarnings(\"unused\") public static String usage();\n\n}\n\nclass AssignTest  {\n\n    @Test\n    public void testExportImportWithBalancerOffOption() throws Exception {\n", "reference": "        String expFileName = \"export_test.exp\";\n        boolean balancerRunning = false;\n\n        // invalid export\n        try {\n            balancerRunning = false;\n            String[] argsParam = {\"zookeeper\", \"export\", expFileName};\n            Args args = new ManagerArgs(argsParam);\n            Assign command = new Assign(admin, args);\n\n            balancerRunning = admin.setBalancerRunning(true, true);\n            command.run();\n            fail();\n        } catch (IllegalStateException e) {\n            if (!e.getMessage().contains(AssignAction.MESSAGE_TURN_BALANCER_OFF))\n                throw e;\n        } finally {\n            if (balancerRunning)\n                admin.setBalancerRunning(true, true);\n        }\n\n        // valid export\n        try {\n            balancerRunning = false;\n            String[] argsParam = {\"zookeeper\", \"export\", expFileName, \"--\" + Args.OPTION_TURN_BALANCER_OFF,\n                \"--skip-export\", \"--force-proceed\"};\n            Args args = new ManagerArgs(argsParam);\n            Assign command = new Assign(admin, args);\n\n            balancerRunning = admin.setBalancerRunning(true, true);\n            command.run();\n        } finally {\n            if (balancerRunning)\n                admin.setBalancerRunning(true, true);\n        }\n\n        // invalid import\n        try {\n            balancerRunning = false;\n            String[] argsParam = {\"zookeeper\", \"import\", expFileName};\n            Args args = new ManagerArgs(argsParam);\n            Assign command = new Assign(admin, args);\n\n            balancerRunning = admin.setBalancerRunning(true, true);\n            command.run();\n            fail();\n        } catch (IllegalStateException e) {\n            if (!e.getMessage().contains(AssignAction.MESSAGE_TURN_BALANCER_OFF))\n                throw e;\n        } finally {\n            if (balancerRunning)\n                admin.setBalancerRunning(true, true);\n        }\n\n        // valid import\n        try {\n            balancerRunning = false;\n            String[] argsParam = {\"zookeeper\", \"import\", expFileName, \"--\" + Args.OPTION_TURN_BALANCER_OFF,\n                \"--skip-export\", \"--force-proceed\"};\n            Args args = new ManagerArgs(argsParam);\n            Assign command = new Assign(admin, args);\n\n            balancerRunning = admin.setBalancerRunning(true, true);\n            command.run();\n        } finally {\n            if (balancerRunning)\n                admin.setBalancerRunning(true, true);\n        }\n    }\n\n}", "prediction": "        Args args = new Args();\n        args.addOption(\"balancer\", \"off\");\n        args.addOption(\"import\", \"true\");\n        args.addOption(\"export\", \"true\");\n        args.addOption(\"table\", \"test\");\n        args.addOption(\"region\", \"test\");\n        args.addOption(\"startKey\", \"test\");\n        args.addOption(\"endKey\", \"test\");\n        args.addOption(\"family\", \"test\");\n        args.addOption(\"qualifier\", \"test\");\n        args.addOption(\"column\", \"test\");\n        args.addOption(\"value\", \"test\");\n        args.addOption(\"timestamp\", \"test\");\n        args.addOption(\"batch\", \"test\");\n        args.addOption(\"batchSize\", \"test\");\n        args.addOption(\"batchInterval\", \"test\");\n        args.addOption(\"maxVersions\", \"test\");\n        args.addOption(\"maxFileSize\", \"test\");\n        args.addOption(\"maxFileSizePerRegion\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInMB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInKB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInGB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInTB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInPB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInEB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInZB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInYB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInBB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInNB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInDB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInCB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInQB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInKB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInMB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInGB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInTB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInPB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInEB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInZB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInYB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInBB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInNB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInDB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInCB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInQB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInKB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInMB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInGB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInTB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInPB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInEB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInZB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInYB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInBB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInNB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInDB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInCB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInQB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInKB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInMB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInGB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInTB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInPB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInEB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInZB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInYB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInBB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInNB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInDB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInCB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInQB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInKB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInMB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInGB\", \"test\");\n        args.addOption(\"maxFileSizePerRegionInTB\", \"test\");\n        args.addOption(\"maxFileSizePerRegion", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "47182929_1", "part": [1, 1], "seq": [1, 1], "prompt": "class CalendarService {\n\n\tpublic Date getNextLaboralDay(final Date date, final int days, final HolidayCalendar calendar) {\n\t\tDateTime tmp = new DateTime(date);\n\t\t// Note: in the case of previous dates we want to have an offset\n\t\tint check = days < 0? Math.abs(days) - 1 : days;\n\t\tint count = 0;\n\t\tint increment = days < 0? -1 : 1;\n\t\tdo {\n\t\t\tif (!isLaboralDay(tmp.toDate(), calendar)) {\n\t\t\t\ttmp = tmp.plusDays(increment);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttmp = tmp.plusDays(increment);\n\t\t\tcount++;\n\t\t}\n\t\twhile (count < check);\n\t\treturn tmp.toDate();\n\t}\n\n\tpublic boolean isLaboralDay(Date date, HolidayCalendar calendar);\n\n}\n\nclass CalendarServiceTest {\n\n\t@Test\n\tpublic void test02() {\n", "reference": "\t\tCalendarService service = new CalendarService();\n\t\tDateTime dt = new DateTime(2017, 10, 1, 0, 0, 0);\n\t\tDate result = service.getNextLaboralDay(dt.toDate(), 0, null);\n\t\tDateTime dtResult = new DateTime(result);\n\n\t\tAssert.assertEquals(2017, dtResult.getYear());\n\t\tAssert.assertEquals(10, dtResult.getMonthOfYear());\n\t\tAssert.assertEquals(2, dtResult.getDayOfMonth());\n\t}\n\n}", "prediction": "\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "47529369_6", "part": [1, 1], "seq": [1, 1], "prompt": "class OtpKeyRequestProcessor extends AbstractGameBootProcessor<OtpKeyRequest> {\n\n  private Response newKey(OtpKeyRequest message) throws Exception {\n    Integer size = message.getKeySize() == null? defaultKeySize : message.getKeySize();\n    SystemIdKey systemId = new SystemIdKey(message.getOtpSystemId());\n\n    log.debug(\"Creating new OTP key of size {} for {}\", size, systemId);\n\n    byte[] newKey = pad.generateKey(size);\n\n    newKeyRegistry.put(systemId, newKey);\n\n    return new Response(message, ResponseCode.SUCCESS, newKey);\n  }\n\n  @Override public String getType();\n  @Override protected void validate(OtpKeyRequest message);\n  @Override protected Response processImpl(OtpKeyRequest message);\n  private Response deleteKey(OtpMessage message);\n\n  static final Long CLEAR_CHANNEL_ID;\n  static final Integer KEY_SIZE;\n  @Autowired\n  private OtpKeyRequestProcessor processor;\n  @Value(\"${otp.maximum.key.size}\")\n  private Integer maxKeySize;\n\n}\n\nclass OtpKeyRequestProcessorTest {\n\n  static final Long CLEAR_CHANNEL_ID;\n  static final Integer KEY_SIZE;\n  @Autowired\n  private OtpKeyRequestProcessor processor;\n  @Value(\"${otp.maximum.key.size}\")\n  private Integer maxKeySize;\n\n  @Test\n  public void testNewKey() throws Exception {\n", "reference": "    failExpected(null, \"Null message\");\n\n    OtpKeyRequest r = new OtpKeyRequest();\n    failExpected(r, \"mt message\");\n\n    r.setOtpSystemId(CLEAR_CHANNEL_ID);\n    r.setKeyFunction(KeyFunction.NEW);\n\n    r.setKeySize(-32);\n    failExpected(r, \"negative size\");\n\n    r.setKeySize(KEY_SIZE);\n    r.setKeyFunction(null);\n    failExpected(r, \"No key function\");\n\n    r.setKeyFunction(KeyFunction.NEW);\n    r.setKeySize(maxKeySize + 1);\n    failExpected(r, \"> max key size\");\n\n    r.setKeySize(KEY_SIZE);\n\n    Response rep = processor.process(r);\n\n    assertEquals(ResponseCode.SUCCESS, rep.getResponseCode());\n    assertNotNull(rep.getPayload());\n    assertEquals(1, rep.getPayload().length);\n    assertTrue(rep.getPayload()[0] instanceof byte[]);\n\n    byte[] b = (byte[]) rep.getPayload()[0];\n\n    assertEquals(KEY_SIZE.intValue(), b.length);\n  }\n\n}", "prediction": "    OtpKeyRequest request = new OtpKeyRequest(CLEAR_CHANNEL_ID, KEY_SIZE);\n    Response response = processor.process(request);\n\n    assertThat(response.getCode(), is(ResponseCode.SUCCESS));\n    assertThat(response.getData(), is(notNullValue()));\n    assertThat(response.getData().length, is(KEY_SIZE));\n  }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "47577389_15", "part": [1, 1], "seq": [1, 1], "prompt": "class FillTheFormDialogModel {\n\n    public int getNormalDialogHeight() {\n        return normalDialogHeight;\n    }\n\n    public  FillTheFormDialogModel(FillTheFormDialogModelHelper helper);\n\n    public void setActionCallbacks(ActionCallbacks actionCallbacks);\n    public void onConfigurationItemClicked(int position);\n    public void onConfigurationItemLongClicked(int position);\n    public void onRemoveItemButtonClicked(int position);\n    @VisibleForTesting String getSelectedConfigItemValue();\n    private void rememberLastEntry(ConfigurationItem preparedConfigurationItem);\n    private void setSelectedConfigItem(int position);\n    private void setSelectedConfigItem(ConfigurationItem selectedConfigItem);\n    private void selectItemWithNextProfile();\n    public void setProfiles(List<String> profiles);\n    public void selectNextProfile();\n    private void setSortedConfigurationItems(List<ConfigurationItem> selectedConfigurationItems);\n    private void addLastEntryIfAvailable(List<ConfigurationItem> sortedConfigurationItems);\n    private List<ConfigurationItem> sortConfigurationItems(List<ConfigurationItem> selectedConfigurationItems);\n    public List<ConfigurationItem> getSortedConfigurationItems();\n    public int getItemsCount();\n    @ViewType public int getSortedConfigItemType(int position);\n    public ConfigurationItem getConfigurationItem(int position);\n    private ConfigurationItem prepareConfigurationItemForDialogList(ConfigurationItem configurationItem);\n    private ConfigurationItem prepareSelectedConfigurationItemForInput();\n    private String replaceVariableKeysWithValues(String text);\n     void init(String configurationVariablePattern);\n     void clearData();\n    private void setConfigurationVariablePattern(String configurationVariablePattern);\n    public void setDialogPosition(int x, int y);\n    public int getDialogPositionX();\n    public int getDialogPositionY();\n    public void onActionMove(float x, float y);\n    public void onActionUp();\n    public void setInitialTouchEvent(float x, float y);\n    public void setInitialDialogPosition(int x, int y);\n    public void setScreenDimensions(int screenWidth, int screenHeight);\n    public void setStatusBarHeight(int statusBarHeight);\n    public void setExpandedDialogDimensions(int expandedDialogWidth, int expandedDialogHeight);\n    public int getExpandedDialogWidth();\n    public int getExpandedDialogHeight();\n    public void setNormalDialogDimensions(int normalDialogWidth, int normalDialogHeight);\n    public int getNormalDialogWidth();\n    public void showDialog(@EventType int modelEventType, List<ConfigurationItem> selectedConfigurationItems);\n    public boolean isDialogVisible();\n    private void setDialogVisible(boolean dialogVisible);\n    public void hideDialog();\n    public boolean isDialogExpanded();\n    private void setDialogExpanded(boolean dialogExpanded);\n    public void onCloseButtonClicked();\n    public void onMinimizeButtonClicked();\n    public void onOpenFillTheFormAppButtonClicked();\n    public boolean isExpandIconVisible();\n    private void setExpandIconVisible(boolean expandIconVisible);\n    public void toggleFastMode();\n    public void setFastModeEnabled(boolean enabled);\n    public boolean isFastModeEnabled();\n    public void setPropertyChangedListener(PropertyChangedListener propertyChangedListener);\n    private void notifyPropertyChanged(String property);\n\n    private static final int SCREEN_WIDTH_PX;\n    private static final int SCREEN_HEIGHT_PX;\n    private static final int STATUS_BAR_HEIGHT_PX;\n    private static final int NORMAL_DIALOG_WIDTH_PX;\n    private static final int NORMAL_DIALOG_HEIGHT_PX;\n    private static final int EXPANDED_DIALOG_WIDTH_PX;\n    private static final int EXPANDED_DIALOG_HEIGHT_PX;\n    private PropertyChangedListener propertyChangedListener;\n    private FillTheFormDialogModel.ActionCallbacks actionCallbacks;\n    private FillTheFormDialogModel.FillTheFormDialogModelHelper helper;\n    private FillTheFormDialogModel model;\n\n}\n\nclass FillTheFormDialogModelTest {\n\n    private static final int SCREEN_WIDTH_PX;\n    private static final int SCREEN_HEIGHT_PX;\n    private static final int STATUS_BAR_HEIGHT_PX;\n    private static final int NORMAL_DIALOG_WIDTH_PX;\n    private static final int NORMAL_DIALOG_HEIGHT_PX;\n    private static final int EXPANDED_DIALOG_WIDTH_PX;\n    private static final int EXPANDED_DIALOG_HEIGHT_PX;\n    private PropertyChangedListener propertyChangedListener;\n    private FillTheFormDialogModel.ActionCallbacks actionCallbacks;\n    private FillTheFormDialogModel.FillTheFormDialogModelHelper helper;\n    private FillTheFormDialogModel model;\n\n    @Test\n    public void testGetNormalDialogHeight() throws Exception {\n", "reference": "        // verify\n        assertEquals(NORMAL_DIALOG_HEIGHT_PX, model.getNormalDialogHeight());\n    }\n\n}", "prediction": "        assertEquals(NORMAL_DIALOG_HEIGHT_PX, model.getNormalDialogHeight());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "47752557_5", "part": [1, 1], "seq": [1, 1], "prompt": "class UserGoodsOrderService implements IUserGoodsOrderService {\n\n\t@Override\n\tpublic  void batchInsert(Set<UserGoodsOrderPo> set) throws Exception{\n\t\t/**\n\t\t * \u7531\u4e8e\u591a\u7ebf\u7a0b\u539f\u56e0\uff0c\u4fdd\u5b58\u4e4b\u524d\u5fc5\u987b\u68c0\u6d4b\u8be5\u5bf9\u8c61\u662f\u5426\u5b58\u5728\uff0c\u6570\u636e\u5b58\u5728\u4e0d\u5728\u4fdd\u5b58\uff0c\u505a\u66f4\u65b0\u64cd\u4f5c\n\t\t */\n\t\tSet<UserGoodsOrderPo> updateSet = new LinkedHashSet<UserGoodsOrderPo>();\n\t\tfor(UserGoodsOrderPo vpo: set){\n\t\t\tif(StringUtils.isNotBlank(vpo.getShopCartGoodsCookieId())){\n\t\t\t\tUserGoodsOrderPo po = userGoodsOrderDao.findBy(vpo.getShopCartGoodsCookieId());\n\t\t\t\tif(null!= po ) {\n\t\t\t\t\tupdateSet.add(vpo);\n\t\t\t\t\tset.remove(vpo);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tconvertUpdateUserGoodsOrder(vpo, vpo);\n\t\t\t\t\tlogger.info(\"Insert UserGoodsOrderPo \" + vpo);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\tuserGoodsOrderDao.save(set);\t\t\n\t\t} catch (IllegalArgumentException e) {\n\t\t\tlogger.error(\"\u6279\u91cf\u4fdd\u5b58\u5931\u8d25\uff0c\u5931\u8d25\u539f\u56e0:\"+e.getMessage(),e);\n\t\t}\n\t\tif(updateSet.size() > 0){\n\t\t    logger.info(\"\u6709 \"+updateSet.size()+\" \u4e2a\u8fdb\u5165\u8d2d\u7269\u8f66\u52a8\u4f5c\u5ef6\u8fdf\uff01\");\n\t\t\tbatchUpdate(updateSet);//\u5047\u5982\u8fdb\u5165\u8d2d\u7269\u8f66\u7684\u52a8\u4f5c\u540e\u5230\uff0c\u66f4\u65b0\u8fdb\u5165\u8d2d\u7269\u8f66\u7684\u64cd\u4f5c\n\t\t}\t\t\n\t}\n\n\t@Override public synchronized void batchUpdate(Set<UserGoodsOrderPo> set);\n\tprivate synchronized void convertUpdateUserGoodsOrder(UserGoodsOrderPo userGoodsOrder, UserGoodsOrderPo userGoodsOrderPo);\n\t@Override public synchronized void processingData(Set<UserGoodsOrderDetailVo> userGoodsOrderDetailVos);\n\tprivate Map<String,LinkedHashSet<UserGoodsOrderPo>> getUserGoodsOrderPoMap(Set<UserGoodsOrderDetailVo> userGoodsOrderDetailVos );\n\tprivate UserGoodsOrderPo convertUserGoodsOrderDetailVoTo(UserGoodsOrderDetailVo userGoodsOrderDetailVo);\n\n\t@Autowired\n\tprivate UserGoodsOrderService userGoodsOrderService;\n\tprivate Set<UserGoodsOrderPo> userGoodsOrders;\n\n}\n\nclass UserGoodsOrderServiceTest  {\n\n\t@Autowired\n\tprivate UserGoodsOrderService userGoodsOrderService;\n\tprivate Set<UserGoodsOrderPo> userGoodsOrders;\n\n\t@Test\n\tpublic void testBatchInsert() throws Exception{\n", "reference": "\t\tuserGoodsOrderService.batchInsert(userGoodsOrders);\n\t}\n\n}", "prediction": "//\t\tuserGoodsOrderService.batchInsert(userGoodsOrders);\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "48122737_0", "part": [1, 1], "seq": [1, 1], "prompt": "class Context implements IContext<TEntity> {\n\n    public void OnEntityCreated(ContextEntityChanged listener) {\n        if (OnEntityCreated!= null) {\n            OnEntityCreated = EntitasCollections.createSet(ContextEntityChanged.class);\n        }\n        OnEntityCreated.add(listener);\n    }\n\n    public  Context(int totalComponents, int startCreationIndex, ContextInfo contexInfo,\n                   EntityBaseFactory<TEntity> factoryMethod, Function<TEntity, IAERC> aercFactory);\n\n     ContextInfo createDefaultContextInfo();\n    @Override public TEntity createEntity();\n    @Override public void destroyAllEntities();\n    @Override public boolean hasEntity(TEntity entity);\n    @Override public TEntity[] getEntities();\n    @Override public int getTotalComponents();\n    @Override public Group<TEntity> getGroup(IMatcher matcher);\n    @Override public void addEntityIndex(IEntityIndex entityIndex);\n    @Override public IEntityIndex getEntityIndex(String name);\n    @Override public void resetCreationIndex();\n    @Override public void clearComponentPool(int index);\n    @Override public void clearComponentPools();\n    @Override public void reset();\n    public void updateGroupsComponentAddedOrRemoved(TEntity entity, int index, IComponent component, List<Group<TEntity>>[] groupsForIndex);\n    protected void updateGroupsComponentReplaced(TEntity entity, int index, IComponent previousComponent,\n                                                 IComponent newComponent, List<Group<TEntity>>[] groupsForIndex);\n    protected void onEntityReleased(TEntity entity);\n     void onDestroyEntity(TEntity entity);\n    @Override public Stack<IComponent>[] getComponentPools();\n    @Override public ContextInfo getContextInfo();\n    @Override public int getCount();\n    @Override public int getReusableEntitiesCount();\n    @Override public int getRetainedEntitiesCount();\n    public IEntity[] getEntities(IMatcher matcher);\n    @Override public Collector createCollector(IMatcher matcher);\n    @Override public Collector createCollector(IMatcher matcher, GroupEvent groupEvent);\n    public Collector<TEntity> createCollector(Context context, TriggerOnEvent<TEntity>[] triggers);\n    public void clearEventsListener();\n    public void OnEntityWillBeDestroyed(ContextEntityChanged listener);\n    public void OnEntityDestroyed(ContextEntityChanged listener);\n    public void OnGroupCreated(ContextGroupChanged listener);\n    public void notifyEntityCreated(IEntity entity);\n    public void notifyEntityWillBeDestroyed(IEntity entity);\n    public void notifyEntityDestroyed(IEntity entity);\n    public void notifyGroupCreated(IGroup group);\n    @Override public String toString();\n\n    @Rule\n    public ExpectedException exception;\n    private TestContext context;\n    private TestEntity entity;\n\n}\n\nclass ContextTest {\n\n    @Rule\n    public ExpectedException exception;\n    private TestContext context;\n    private TestEntity entity;\n\n    @Test\n    public void OnEntityCreatedTest() {\n", "reference": "        context.OnEntityCreated((context, e) -> assertTrue(e.isEnabled()));\n        entity = context.createEntity();\n    }\n\n}", "prediction": "        context.OnEntityCreated(new ContextEntityChanged() {\n            @Override\n            public void onEntityCreated(Context context, IEntity entity) {\n                Assert.assertEquals(entity, context.getEntity());\n            }\n        });\n        context.notifyEntityCreated(entity);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "48161197_0", "part": [1, 1], "seq": [1, 1], "prompt": "class QuarkCube {\n\n  public static Set<Set<Dimension>> getDimensionSets(Set<Dimension> dimensions) {\n    Set<Set<Dimension>> result = Sets.newHashSet();\n    result.add(new HashSet<>());\n    for (Dimension d : dimensions) {\n      // traverse only the top level dimension i.e., with no parents\n      if (d.parentDimension == null) {\n        result = cartesian(ImmutableList.of(result,\n            getHierarichalSet(d, new AtomicBoolean(false))));\n      }\n    }\n    return result;\n  }\n\n  public  QuarkCube(String name, Object sql, List<Measure> measures,\n                   List<Dimension> dimensionList,\n                   List<String> tableName, String groupingColumn);\n  public  QuarkCube(String name, Object sql, List<Measure> measures,\n                   List<Dimension> dimensionList,\n                   List<Group> groupList,\n                   List<String> tableName, String groupingColumn);\n  public  QuarkCube(String name, Object sql, List<Measure> measures,\n                   List<Dimension> dimensionList,\n                   List<Group> groupList,\n                   List<String> tableName, String groupingColumn,\n                   List<String> alias);\n\n  private void buildGroups(List<Dimension> dimensions,\n                           List<Group> groupList,\n                           Map<String, Set<Dimension>> groupToDimensionMap,\n                           Map<String, Dimension> idToDimensionMap);\n  private void addDimension(Map<String, Set<QuarkCube.Dimension>> groupToDimensionMap,\n                            List<Group> groupList,\n                            Map<String, QuarkCube.Dimension> idToDimensionMap,\n                            Dimension dimension);\n  public Lattice build(CalciteSchema calciteSchema, QuarkTable quarkTable);\n  private void validateCubeLatticeFilter(Lattice.Builder latticeBuilder);\n  private static Set<Set<Dimension>> getHierarichalSet(Dimension d,\n      AtomicBoolean isChildMandatory);\n  private ImmutableList<String> toUpperCase(List<String> stringList);\n  static String toString(Object o);\n  private static String concatenate(List list);\n  public static Set<Set<E>> cartesian(List<Set<T>> list);\n\n  public Fixture fixture;\n\n}\n\nclass QuarkCubeTest {\n\n  public Fixture fixture;\n\n  @Test\n  public void computeDimensionSet() {\n", "reference": "    Set<Set<QuarkCube.Dimension>> dimSet = QuarkCube.getDimensionSets(\n        fixture.getAllDim());\n    assertEquals(dimSet.size(), 8);\n  }\n\n}", "prediction": "    Set<Set<Dimension>> dimensionSets = QuarkCube.getDimensionSets(fixture.dimensions);\n    assertThat(dimensionSets).hasSize(1);\n    assertThat(dimensionSets.iterator().next()).isEmpty();\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "48175620_5", "part": [1, 1], "seq": [1, 1], "prompt": "class RepositoryAdapter extends RecyclerView.Adapter<ViewHolder> implements Updatable {\n\n  @Override\n  public final long getItemId(final int position) {\n    resolveIndices(position);\n    return parts[resolvedPartIndex].getItemId(resolvedItemIndex, staticItemCount);\n  }\n\n  public  RepositoryAdapter(@NonNull final Builder builder);\n\n  @NonNull public static Builder repositoryAdapter();\n  public final void startObserving();\n  public final void stopObserving();\n  @Override public final void update();\n  @Override public final int getItemCount();\n  private void reloadAllData();\n  @Override public final int getItemViewType(final int position);\n  @Override public ViewHolder onCreateViewHolder(final ViewGroup parent,\n      final int layoutResourceId);\n  @Override public final void onBindViewHolder(final ViewHolder holder, final int position);\n  @Override public boolean onFailedToRecycleView(final ViewHolder holder);\n  @Override public void onViewRecycled(final ViewHolder holder);\n  private void recycle(@NonNull final ViewHolder holder);\n  private void resolveIndices(final int position);\n  private void updateAllParts();\n  private void updateOnePart(@NonNull final RepositoryPart part, final int partIndex);\n  private void offsetEndPositionsFrom(final int partIndex, final int offset);\n\n  private static final int MULTI_ITEM_COUNT;\n  private static final int STATIC_ITEM_COUNT;\n  private static final List<String> REPOSITORY_LIST;\n  private static final String REPOSITORY_ITEM;\n  private static final String ALTERNATIVE_REPOSITORY_ITEM;\n  private static final String ITEM;\n  @LayoutRes\n  private static final int LAYOUT_ID;\n  @Mock\n  private RepositoryPresenter repositoryPresenter;\n  @Mock\n  private RepositoryPresenter secondRepositoryPresenter;\n  @Mock\n  private RepositoryPresenter singleItemRepositoryPresenter;\n  @Mock\n  private RepositoryPresenter multiItemRepositoryPresenter;\n  @Mock\n  private RepositoryPresenter zeroItemRepositoryPresenter;\n  @Mock\n  private LayoutPresenter layoutPresenter;\n  @Mock\n  private LayoutPresenter secondLayoutPresenter;\n  @Mock\n  private ViewHolder viewHolder;\n  @Mock\n  private ViewGroup viewGroup;\n  @Mock\n  private Context context;\n  @Mock\n  private LayoutInflater layoutInflater;\n  @Mock\n  private View view;\n  @Mock\n  private Activity activity;\n  @Mock\n  private Application application;\n  @Mock\n  private AdapterDataObserver observer;\n  private UpdateDispatcher updateDispatcher;\n  private MutableRepository repository;\n  private Repository secondRepository;\n  private RepositoryAdapter repositoryAdapter;\n  private RepositoryAdapter repositoryAdapterWithoutStatic;\n  private Adapter repositoryAdapterWhileResumed;\n  private Adapter repositoryAdapterWhileStarted;\n\n}\n\nclass RepositoryAdapterTest {\n\n  private static final int MULTI_ITEM_COUNT;\n  private static final int STATIC_ITEM_COUNT;\n  private static final List<String> REPOSITORY_LIST;\n  private static final String REPOSITORY_ITEM;\n  private static final String ALTERNATIVE_REPOSITORY_ITEM;\n  private static final String ITEM;\n  @LayoutRes\n  private static final int LAYOUT_ID;\n  @Mock\n  private RepositoryPresenter repositoryPresenter;\n  @Mock\n  private RepositoryPresenter secondRepositoryPresenter;\n  @Mock\n  private RepositoryPresenter singleItemRepositoryPresenter;\n  @Mock\n  private RepositoryPresenter multiItemRepositoryPresenter;\n  @Mock\n  private RepositoryPresenter zeroItemRepositoryPresenter;\n  @Mock\n  private LayoutPresenter layoutPresenter;\n  @Mock\n  private LayoutPresenter secondLayoutPresenter;\n  @Mock\n  private ViewHolder viewHolder;\n  @Mock\n  private ViewGroup viewGroup;\n  @Mock\n  private Context context;\n  @Mock\n  private LayoutInflater layoutInflater;\n  @Mock\n  private View view;\n  @Mock\n  private Activity activity;\n  @Mock\n  private Application application;\n  @Mock\n  private AdapterDataObserver observer;\n  private UpdateDispatcher updateDispatcher;\n  private MutableRepository repository;\n  private Repository secondRepository;\n  private RepositoryAdapter repositoryAdapter;\n  private RepositoryAdapter repositoryAdapterWithoutStatic;\n  private Adapter repositoryAdapterWhileResumed;\n  private Adapter repositoryAdapterWhileStarted;\n\n  @Test\n  public void shouldReturnItemIdFromFirstPresenter() {\n", "reference": "    when(repositoryPresenter.getItemId(REPOSITORY_ITEM, 0)).thenReturn(10L);\n    assertThat(repositoryAdapter.getItemId(0), is(10L + STATIC_ITEM_COUNT));\n\n    verify(secondRepositoryPresenter, never()).getItemId(any(), anyInt());\n  }\n\n}", "prediction": "    // given\n    final int position = 0;\n    final long expectedItemId = 1L;\n    when(repositoryPresenter.getItemId(position)).thenReturn(expectedItemId);\n\n    // when\n    final long actualItemId = repositoryAdapter.getItemId(position);\n\n    // then\n    assertThat(actualItemId).isEqualTo(expectedItemId);\n  }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "48196746_35", "part": [1, 1], "seq": [1, 1], "prompt": "class AnalyzerConfig {\n\n    public static Maven maven(Language... languages) {\n        return maven(null, languages);\n    }\n\n    public  AnalyzerConfig();\n    public  AnalyzerConfig(AnalyzerConfig config);\n    protected  AnalyzerConfig(EnumSet<Language> languages, List<Path> sources, List<Path> classes);\n\n    public AnalyzerConfig and(AnalyzerConfig config);\n    public static Maven maven(String module, Language... languages);\n    public static Gradle gradle(Language... languages);\n    public static Gradle gradle(String module, Language... languages);\n    public AnalyzerConfig withSources(File basedir, String... packages);\n    public AnalyzerConfig withClasses(File basedir, String... packages);\n    public List<Path> getSourcePaths(Language... languages);\n    public List<Path> getClassPaths(Language... languages);\n    public List<File> getSources(Language... languages);\n    public List<File> getClasses(Language... languages);\n    private List<Path> getPaths(List<Path> paths, Language... languages);\n    private List<File> getFiles(List<Path> paths, String suffix, Language... languages);\n    private EnumSet<Language> calcLanguages(Language... languages);\n    private void crawlDir(File base, List<String> suffices, List<File> res);\n    private boolean hasAnySuffix(String s, List<String> suffices);\n\n}\n\nclass AnalyzerConfigTest {\n\n    @Test\n    void mavenModuleRedefinition() {\n", "reference": "        assertThrows(IllegalStateException.class, () -> AnalyzerConfig.maven(\"code-assert-core\").modules(\"\").mainAndTest());\n    }\n\n}", "prediction": "        Maven maven = AnalyzerConfig.maven(\"module1\", Language.JAVA);\n        Maven maven2 = AnalyzerConfig.maven(\"module2\", Language.JAVA);\n        assertThat(maven.getModule()).isEqualTo(\"module1\");\n        assertThat(maven2.getModule()).isEqualTo(\"module2\");\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "48366700_12", "part": [1, 1], "seq": [1, 1], "prompt": "class AndroidMocks {\n\n    public static TextView mockTextView() {\n        return mock(TextView.class);\n    }\n\n    public static Context mockContext();\n    public static MenuItem mockMenuItem();\n    public static MenuItem mockMenuItem(int itemId);\n    public static LayoutInflater mockLayoutInflater();\n    public static Intent mockIntent();\n    public static Bundle mockBundle();\n    public static View mockView(ViewPropertyAnimator animator);\n    public static View mockView();\n    public static View mockView(Resources resources);\n    @SuppressLint(\"NewApi\") public static ViewPropertyAnimator mockViewPropertyAnimator();\n    public static TextView mockTextView(Resources resources);\n    public static Button mockButton();\n    public static ImageButton mockImageButton();\n    public static Fragment mockFragment();\n    public static Activity mockActivity(Application application);\n    public static Activity mockActivity();\n    public static Application mockApplication();\n    public static FragmentManager mockFragmentManager();\n    @TargetApi(Build.VERSION_CODES.HONEYCOMB) @SuppressLint({ \"CommitTransaction\", \"NewApi\" }) public static FragmentManager mockFragmentManager(FragmentTransaction transaction);\n    public static Editable mockEditable(String s);\n    public static EditText mockEditText(Editable editable);\n    @Deprecated public static EditText mockEditField(Editable editable);\n    public static EditText mockEditText(String s);\n    @Deprecated public static EditText mockEditField(String s);\n    public static Resources mockResources();\n    public static EditText prepare(String s, EditText field);\n    public static TextView mockTextView(String s);\n    public static AutoCompleteTextView mockAutoCompleteEditField(String s);\n    public static SharedPreferences.Editor mockEditor();\n    public static AlertDialog.Builder mockDialogBuilder();\n    public static AlertDialog.Builder mockDialogBuilder(ArgumentCaptor<DialogInterface.OnClickListener> positive, ArgumentCaptor<DialogInterface.OnClickListener> negative);\n    public static CheckBox mockCheckBox();\n    public static WebView mockWebView();\n    public static ProgressBar mockProgressBar();\n    public static LinearLayout mockLinearLayout();\n    public static RelativeLayout mockRelativeLayout();\n    public static FrameLayout mockFrameLayout();\n    public static RecyclerView mockRecyclerView();\n    public static CardView mockCardView();\n\n}\n\nclass AndroidMocksTest {\n\n    @Test\n    public void mockTextView() {\n", "reference": "        TextView textView = AndroidMocks.mockTextView();\n        assertThat(textView).isNotNull();\n    }\n\n}", "prediction": "        TextView textView = AndroidMocks.mockTextView();\n        assertNotNull(textView);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "48544726_7", "part": [1, 1], "seq": [1, 1], "prompt": "class RepoInfoPresenter extends BasePresenter {\n\n    public void onCreateView(Bundle savedInstanceState) {\n\n        if (savedInstanceState!= null) {\n            contributorList = (List<Contributor>) savedInstanceState.getSerializable(BUNDLE_CONTRIBUTORS_KEY);\n            branchList = (List<Branch>) savedInstanceState.getSerializable(BUNDLE_BRANCHES_KEY);\n        }\n\n        if (contributorList == null || branchList == null) {\n            loadData();\n        } else {\n            view.showBranches(branchList);\n            view.showContributors(contributorList);\n        }\n\n    }\n\n    private void loadData();\n    public void onCreate(RepoInfoView view, Repository repository);\n    protected void hideInfoLoadingState();\n    public void onSaveInstanceState(Bundle outState);\n    @Override protected View getView();\n\n    @Inject\n    protected List<ContributorDTO> contributorDTOs;\n    @Inject\n    protected List<BranchDTO> branchDTOs;\n    @Inject\n    protected List<Contributor> contributorList;\n    @Inject\n    protected List<Branch> branchList;\n    @Inject\n    protected RepoBranchesMapper branchesMapper;\n    @Inject\n    protected RepoContributorsMapper contributorsMapper;\n    @Inject\n    protected Model model;\n    @Inject\n    protected Repository repository;\n    private RepoInfoView mockView;\n    private RepoInfoPresenter repoInfoPresenter;\n\n}\n\nclass RepoInfoPresenterTest extends BasePresenter {\n\n    @Inject\n    protected List<ContributorDTO> contributorDTOs;\n    @Inject\n    protected List<BranchDTO> branchDTOs;\n    @Inject\n    protected List<Contributor> contributorList;\n    @Inject\n    protected List<Branch> branchList;\n    @Inject\n    protected RepoBranchesMapper branchesMapper;\n    @Inject\n    protected RepoContributorsMapper contributorsMapper;\n    @Inject\n    protected Model model;\n    @Inject\n    protected Repository repository;\n    private RepoInfoView mockView;\n    private RepoInfoPresenter repoInfoPresenter;\n\n    @Test\n    public void testShowLoadingOnError() {\n", "reference": "        doAnswer(invocation -> Observable.error(new Throwable(TestConst.TEST_ERROR)))\n                .when(model)\n                .getRepoContributors(TestConst.TEST_OWNER, TestConst.TEST_REPO);\n        doAnswer(invocation -> Observable.error(new Throwable(TestConst.TEST_ERROR)))\n                .when(model)\n                .getRepoBranches(TestConst.TEST_OWNER, TestConst.TEST_REPO);\n\n        repoInfoPresenter.onCreateView(null);\n\n        verify(mockView).showLoading();\n    }\n\n}", "prediction": "        repoInfoPresenter.onCreateView(null);\n        verify(mockView).showLoading();\n        verify(mockView).showError();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "48562236_28", "part": [1, 1], "seq": [1, 1], "prompt": "class YAML {\n\n    public static YamlValue parse(String string) throws YamlException {\n        return YamlValue.of(decode(string));\n    }\n\n    protected  YAML();\n\n    public static YamlValue parse(Reader reader);\n    public static T decode(String string);\n    public static T decode(Reader reader);\n    public static T decodeYamlOrJson(Resource resource);\n\n}\n\nclass YamlTest  {\n\n\t@Test\n\tpublic void testParseSimpleMap() {\n", "reference": "\t\tString yaml = \"p: value\";\n\t\tYamlObject o = YAML.parse(yaml).asYamlObject();\n\t\tassertEquals(\"value\",o.get(\"p\"));\n\t}\n\n}", "prediction": "\t\tYamlValue yaml = YAML.parse(\"a: 1\\nb: 2\");\n\t\tassertEquals(2, yaml.get(\"b\").asInt());\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "48609929_0", "part": [1, 1], "seq": [1, 1], "prompt": "class Sequencer {\n\n    public static int next() {\n        int tick = counter.getAndIncrement();\n        return tick & 0xff;\n    }\n\n    private  Sequencer();\n\n}\n\nclass sequencerTest {\n\n    @Test\n    public void sequencerShouldReturnIntegerIncrementallyFrom0To255(){\n", "reference": "        int pre = Sequencer.next();\n        int cur;\n        for (int i = 0; i < 10000; ++i){\n            cur = Sequencer.next();\n            Assert.assertTrue(cur >= 0);\n            Assert.assertTrue(cur <= 255);\n            if(pre == 255){\n                pre = 0;\n                Assert.assertEquals(0, cur);\n            }else {\n                Assert.assertEquals(1, cur - pre);\n                pre = cur;\n            }\n        }\n    }\n\n}", "prediction": "        int tick = Sequencer.next();\n        assertEquals(tick, 0);\n        tick = Sequencer.next();\n        assertEquals(tick, 1);\n        tick = Sequencer.next();\n        assertEquals(tick, 2);\n        tick = Sequencer.next();\n        assertEquals(tick, 3);\n        tick = Sequencer.next();\n        assertEquals(tick, 4);\n        tick = Sequencer.next();\n        assertEquals(tick, 5);\n        tick = Sequencer.next();\n        assertEquals(tick, 6);\n        tick = Sequencer.next();\n        assertEquals(tick, 7);\n        tick = Sequencer.next();\n        assertEquals(tick, 8);\n        tick = Sequencer.next();\n        assertEquals(tick, 9);\n        tick = Sequencer.next();\n        assertEquals(tick, 10);\n        tick = Sequencer.next();\n        assertEquals(tick, 11);\n        tick = Sequencer.next();\n        assertEquals(tick, 12);\n        tick = Sequencer.next();\n        assertEquals(tick, 13);\n        tick = Sequencer.next();\n        assertEquals(tick, 14);\n        tick = Sequencer.next();\n        assertEquals(tick, 15);\n        tick = Sequencer.next();\n        assertEquals(tick, 16);\n        tick = Sequencer.next();\n        assertEquals(tick, 17);\n        tick = Sequencer.next();\n        assertEquals(tick, 18);\n        tick = Sequencer.next();\n        assertEquals(tick, 19);\n        tick = Sequencer.next();\n        assertEquals(tick, 20);\n        tick = Sequencer.next();\n        assertEquals(tick, 21);\n        tick = Sequencer.next();\n        assertEquals(tick, 22);\n        tick = Sequencer.next();\n        assertEquals(tick, 23);\n        tick = Sequencer.next();\n        assertEquals(tick, 24);\n        tick = Sequencer.next();\n        assertEquals(tick, 25);\n        tick = Sequencer.next();\n        assertEquals(tick, 26);\n        tick = Sequencer.next();\n        assertEquals(tick, 27);\n        tick = Sequencer.next();\n        assertEquals(tick, 28);\n        tick = Sequencer.next();\n        assertEquals(tick, 29);\n        tick = Sequencer.next();\n        assertEquals(tick, 30);\n        tick = Sequencer.next();\n        assertEquals(tick, 31);\n        tick = Sequencer.next();\n        assertEquals(tick, 32);\n        tick = Sequencer.next();\n        assertEquals(tick, 33);\n        tick = Sequencer.next();\n        assertEquals(tick, 34);\n        tick = Sequencer.next();\n        assertEquals(tick, 35);\n        tick = Sequencer.next();\n        assertEquals(tick, 36);\n        tick = Sequencer.next();\n        assertEquals(tick, 37);\n        tick = Sequencer.next();\n        assertEquals(tick, 38);\n        tick = Sequencer.next();\n        assertEquals(tick, 39);\n        tick = Sequencer.next();\n        assertEquals(tick, 40);\n        tick = Sequencer.next();\n        assertEquals(tick, 41);\n        tick = Sequencer.next();\n        assertEquals(tick, 42);\n        tick = Sequencer.next();\n        assertEquals(tick, 43);\n        tick = Sequencer.next();\n        assertEquals(tick, 44);\n        tick = Sequencer.next();\n        assertEquals(tick, 45);\n        tick = Sequencer.next();\n        assertEquals(tick, 46);\n        tick = Sequencer.next();\n        assertEquals(tick, 47);\n        tick = Sequencer.next();\n        assertEquals(tick, 48);\n        tick = Sequencer.next();\n        assertEquals(tick, 49);\n        tick = Sequencer.next();\n        assertEquals(tick, 50);\n        tick = Sequencer.next();\n        assertEquals(tick, 51);\n        tick = Sequencer.next();\n        assertEquals(tick, 52);\n        tick = Sequencer.next();\n        assertEquals(tick, 53);\n        tick = Sequencer.next();\n        assertEquals(tick, 54);\n        tick = Sequencer.next();\n        assertEquals(tick, 55);\n        tick = Sequencer.next();\n        assertEquals(tick, 56);\n        tick = Sequencer.next();\n        assertEquals(tick, 57);\n        tick = Sequencer.next();\n        assertEquals(tick, 58);\n        tick = Sequencer.next();\n        assertEquals(tick, 59);\n        tick = Sequencer.next();\n        assertEquals(tick, 60);\n        tick = Sequencer.next();\n        assertEquals(tick, 61);\n        tick = Sequencer.next();\n        assertEquals(tick, 62);\n        tick = Sequencer.next();\n        assertEquals(tick, 63);\n        tick = Sequencer.next();\n        assertEquals(tick, 64);\n        tick = Sequencer.next();\n        assertEquals(tick, 65);\n        tick = Sequencer.next();\n        assertEquals(tick, 66);\n        tick = Sequencer.next();\n        assertEquals(tick, 67);\n        tick = Sequencer.next();\n        assertEquals(tick, 68);\n        tick = Sequencer.next();\n        assertEquals(tick, 69);\n        tick = Sequencer.next();\n        assertEquals(tick, 70);\n        tick = Sequencer.next();\n        assertEquals(tick, 71);\n        tick = Sequencer.next();\n        assertEquals(tick, 72);\n        tick = Sequencer.next();\n        assertEquals(tick, 73);\n        tick = Sequencer.next();\n        assertEquals(tick, 74);\n        tick = Sequencer.next();\n        assertEquals(tick, 75);\n        tick = Sequencer.next();\n        assertEquals(tick, 76);\n        tick = Sequencer.next();\n        assertEquals(tick, 77);\n        tick = Sequencer.next();\n        assertEquals(tick, 78);\n        tick = Sequencer.next();\n        assertEquals(tick, 79);\n        tick = Sequencer.next();\n        assertEquals(tick, 80);\n        tick = Sequencer.next();\n        assertEquals(tick, 81);\n        tick = Sequencer.next();\n        assertEquals(tick, 82);\n        tick = Sequencer.next();\n        assertEquals(tick, 83);\n        tick = Sequencer.next();\n        assertEquals(tick, 84);\n        tick = Sequencer.next();\n        assertEquals(tick, 85);\n        tick = Sequencer.next();\n        assertEquals(tick, 86);\n        tick = Sequencer.next();\n        assertEquals(tick, 87);\n        tick = Sequencer.next();\n        assertEquals(tick, 88);\n        tick =", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "49483698_18", "part": [1, 1], "seq": [1, 1], "prompt": "class Strings {\n\n    public static String repeat(char c, int count) {\n        if (count < 1) return EMPTY_STRING;\n        char[] chars = new char[count];\n        Arrays.fill(chars, c);\n        return new String(chars);\n    }\n\n    private  Strings();\n\n    public static boolean isNullOrEmpty(String str);\n    public static boolean hasText(String s);\n    public static boolean allHasText(String... strings);\n    private static void checkVarargString(String... strings);\n    public static boolean allNullOrEmpty(String... strings);\n    public static String leftTrim(String s);\n    public static String rightTrim(String str);\n    public static boolean containsNone(String str, String invalidCharsStr);\n    public static boolean containsOnly(String str, String allowedChars);\n    public static String repeat(String str, int count);\n    public static String reverse(String str);\n    public static String insertFromLeft(String str, int interval, String stringToInsert);\n    public static String insertFromRight(String str, int interval, String stringToInsert);\n    public static String rightPad(String str, int size);\n    public static String rightPad(String str, int size, char padChar);\n    public static String rightPad(String str, int size, String padStr);\n    public static String leftPad(String str, int size);\n    public static String leftPad(String str, int size, char padChar);\n    public static String subStringUntilFirst(String str, String s);\n    public static String subStringUntilLast(String str, String s);\n    public static String subStringAfterFirst(String str, String s);\n    public static String subStringAfterLast(String str, String s);\n    public static String leftPad(String str, int size, String padStr);\n    public static String whiteSpacesToSingleSpace(String str);\n    public static String eliminateWhiteSpaces(String str);\n    public static String concatWithString(String str, Collection<?> collection);\n    public static String concatWithString(String str, Object... objects);\n    public static String[] separateGrams(String word, int gramSize);\n\n}\n\nclass StringsTest {\n\n    @Test\n    public void repeatTest() {\n", "reference": "        assertEquals(repeat('c', -1), \"\");\n        assertEquals(repeat('c', 3), \"ccc\");\n        assertEquals(repeat('c', 1), \"c\");\n        assertEquals(repeat('c', 0), \"\");\n\n        assertNull(repeat(null, 1));\n        assertEquals(repeat(\"ab\", -1), \"\");\n        assertEquals(repeat(\"ab\", 3), \"ababab\");\n        assertEquals(repeat(\"ab\", 1), \"ab\");\n        assertEquals(repeat(\"ab\", 0), \"\");\n    }\n\n}", "prediction": "        assertEquals(\"abc\", Strings.repeat('a', 3));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "49652464_6", "part": [1, 1], "seq": [1, 1], "prompt": "class Encoder {\n\n    public static String substring(String tail, int startIndex, int endIndex) {\n        if (tail == null) {\n            return \"\";\n        }\n        if (tail.length() <= startIndex) {\n            return \"\";\n        } else {\n            if (endIndex > tail.length() - 1) {\n                return tail.substring(startIndex, tail.length());\n            } else {\n                return tail.substring(startIndex, endIndex);\n            }\n        }\n    }\n\n    private static Set<String> getSet(String value);\n    public static Set<String> operatePhonetic(String acc, Character c, String tail);\n    private static boolean isDoubleConsonnant(Character c, String tail);\n    private static Set<String> replaceTwoLettersSounds(String acc, char c, String tail);\n    private static Set<String> handleJEANSpecialCase(String acc, char c, String tail);\n    private static Set<String> replaceAISounds(String acc, char c, String tail, Character... firstLetters);\n    private static Set<String> replaceThreeLettersINSound(String acc, char c, String tail, Character... firstLetters);\n    private static Set<String> replaceONOrINOrANSound(String acc, char c, String tail, String replaceValue, Character... firstLetters);\n    public static Character charAt(String tail, int position);\n\n}\n\nclass EncoderTest {\n\n    @Test\n    public void testSubstringEndIndexEqualsToStartIndex() throws Exception {\n", "reference": "        Encoder encoder = new Encoder();\n        String result = encoder.substring(\"ERT\", 2, 2);\n        Assertions.assertThat(result).isEqualTo(\"\");\n    }\n\n}", "prediction": "        assertEquals(\"\", Encoder.substring(\"abc\", 0, 0));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "49679586_4", "part": [1, 1], "seq": [1, 1], "prompt": "class SLongByteUtils {\n\n\tstatic byte[] fromLong(final long value, final int numBytes) {\n\t\tlong shiftedValue = value;\n\t\tbyte[] res = new byte[numBytes];\n\t\tfor(int i = 0; i < numBytes; i++) {\n\t\t\tres[i] = (byte) (shiftedValue & BYTE_MASK);\n\t\t\tshiftedValue = shiftedValue >> 8;\n\t\t}\n\t\treturn res;\n\t}\n\n\tprivate  SLongByteUtils();\n\n\tstatic long getLong(final byte[] list);\n\n}\n\nclass SLongByteUtilsTest {\n\n\t@Test\n\t/**\n\t * Test\n\t */\n\tpublic void getSLongSize2WorksFor0() {\n", "reference": "\t\tassertArrayEquals(\"SLong(2) : 0 => 0\",\n\t\t\t\tnew byte[]{0, 0},\n\t\t\t\tSLongByteUtils.fromLong(0, 2));\n\t}\n\n}", "prediction": "\t\tassertEquals(0, SLongByteUtils.getLong(new byte[] { 0, 0 }));\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "49688312_0", "part": [1, 1], "seq": [1, 1], "prompt": "class QueryMatcher implements Serializable {\n\n    public boolean matches(String... queryTerms) {\n        for (String queryTerm : queryTerms) {\n            for (String entityTerm : entityTerms) {\n                if (entityTerm.contains(queryTerm.toUpperCase())) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    public  QueryMatcher(final String... theEntityTerms);\n\n    private List<String> processEntityTerms(String[] terms);\n    private String getNonAccentTerm(String term);\n\n}\n\nclass QueryMatcherTest {\n\n    @Test\n    public void test() {\n", "reference": "        QueryMatcher matcher = new QueryMatcher(\"Jair Bolsonaro\", \"PP\");\n        boolean result = matcher.matches(\"bolsonaro\");\n\n        Assert.assertTrue(result);\n    }\n\n}", "prediction": "        QueryMatcher matcher = new QueryMatcher(\"\");\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"\"));\n        assertTrue(matcher.matches(\"", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "50205233_147", "part": [1, 1], "seq": [1, 1], "prompt": "class TokenStream {\n\n    public String consume() throws ParsingException, IllegalStateException {\n        if (completed) {\n            throwNoMoreContent();\n        }\n        // Get the value from the current token...\n        String result = currentToken().value();\n        moveToNextToken();\n        return result;\n    }\n\n    public  TokenStream(String content,\n                       Tokenizer tokenizer,\n                       boolean caseSensitive);\n\n    public TokenStream start();\n    protected List<Token> initializeTokens(List<Token> tokens);\n    public void rewind();\n    public Marker mark();\n    public boolean rewind(Marker marker);\n    public boolean advance(Marker marker);\n    public Position previousPosition();\n    public Position previousPosition(int count);\n    public Position nextPosition();\n    public int consumeInteger();\n    public long consumeLong();\n    public boolean consumeBoolean();\n    protected void throwNoMoreContent();\n    public String peek();\n    public TokenStream consume(String expected);\n    public TokenStream consume(char expected);\n    public TokenStream consume(int expectedType);\n    public TokenStream consume(String expected,\n                               String... expectedForNextTokens);\n    public TokenStream consume(String[] nextTokens);\n    public TokenStream consume(Iterable<String> nextTokens);\n    public String consumeAnyOf(int... typeOptions);\n    public String consumeAnyOf(String... options);\n    public TokenStream consumeThrough(char expected);\n    public TokenStream consumeThrough(char expected, char skipMatchingTokens);\n    public TokenStream consumeThrough(String expected);\n    public TokenStream consumeThrough(String expected, String skipMatchingTokens);\n    public TokenStream consumeUntil(char expected);\n    public TokenStream consumeUntil(char expected, char skipMatchingTokens);\n    public TokenStream consumeUntil(String expected);\n    public TokenStream consumeUntil(String expected, String... skipMatchingTokens);\n    public TokenStream consumeUntilEndOrOneOf(String... stopTokens);\n    public boolean canConsumeInteger(IntConsumer consumer);\n    public boolean canConsumeBoolean(BooleanConsumer consumer);\n    public boolean canConsumeLong(LongConsumer consumer);\n    public boolean canConsume(String expected);\n    public boolean canConsume(int type, String expected);\n    public boolean canConsumeWord(String expected);\n    public boolean canConsume(char expected);\n    public boolean canConsume(int expectedType);\n    public boolean canConsume(String currentExpected,\n                              String... expectedForNextTokens);\n    public boolean canConsume(int type, String currentExpected, String... expectedForNextTokens);\n    public boolean canConsumeWords(String currentExpected, String... expectedForNextTokens);\n    public boolean canConsume(String[] nextTokens);\n    public boolean canConsume(Iterable<String> nextTokens);\n    public boolean canConsumeAnyOf(String firstOption,\n                                   String... additionalOptions);\n    public boolean canConsumeAnyOf(String[] options);\n    public boolean canConsumeAnyOf(Iterable<String> options);\n    public boolean canConsumeAnyOf(int firstTypeOption,\n                                   int... additionalTypeOptions);\n    public boolean canConsumeAnyOf(int[] typeOptions);\n    public boolean matches(String expected);\n    public boolean matches(int type, String expected);\n    public boolean matchesWord(String expected);\n    public boolean matches(char expected);\n    public boolean matches(int expectedType);\n    public boolean matches(String currentExpected,\n                           String... expectedForNextTokens);\n    public boolean matches(String[] nextTokens);\n    public boolean matches(Iterable<String> nextTokens);\n    public boolean matches(int currentExpectedType,\n                           int... expectedTypeForNextTokens);\n    public boolean matches(int[] typesForNextTokens);\n    public boolean matchesAnyOf(String firstOption,\n                                String... additionalOptions);\n    public boolean matchesAnyOf(int type, String firstOption, String... additionalOptions);\n    public boolean matchesAnyWordOf(String firstOption, String... additionalOptions);\n    public boolean matchesAnyOf(String[] options);\n    public boolean matchesAnyOf(Iterable<String> options);\n    public boolean matchesAnyOf(int firstTypeOption,\n                                int... additionalTypeOptions);\n    public boolean matchesAnyOf(int[] typeOptions);\n    public boolean hasNext();\n    @Override public String toString();\n    private void moveToNextToken(List<Token> newTokens);\n    private void moveToNextToken();\n    final Token currentToken();\n    public String getContentFrom(Marker starting);\n    public String getContentBetween(Marker starting,\n                                    Position end);\n    public String getContentBetween(Position starting,\n                                    Position end);\n    protected String getContentBetween(int startIndex,\n                                       Position end);\n    public final Token previousToken(int count);\n     String generateFragment();\n    static String generateFragment(String content,\n                                   int indexOfProblem,\n                                   int charactersToIncludeBeforeAndAfter,\n                                   String highlightText);\n    public static BasicTokenizer basicTokenizer(boolean includeComments);\n    public String getInputString();\n\n    public static final int WORD;\n    public static final int SYMBOL;\n    public static final int DECIMAL;\n    public static final int SINGLE_QUOTED_STRING;\n    public static final int DOUBLE_QUOTED_STRING;\n    public static final int COMMENT;\n    private Tokenizer tokenizer;\n    private String content;\n    private TokenStream tokens;\n\n}\n\nclass TokenStreamTest {\n\n    public static final int WORD;\n    public static final int SYMBOL;\n    public static final int DECIMAL;\n    public static final int SINGLE_QUOTED_STRING;\n    public static final int DOUBLE_QUOTED_STRING;\n    public static final int COMMENT;\n    private Tokenizer tokenizer;\n    private String content;\n    private TokenStream tokens;\n\n    @Test(expected = ParsingException.class)\n    public void shouldFailToConsumeInCaseSensitiveMannerWithExpectedValuesWhenMatchingIncorrectCase() {\n", "reference": "        makeCaseSensitive();\n        tokens.consume(\"Select\");\n        tokens.consume(\"all\");\n        tokens.consume(\"Columns\");\n    }\n\n}", "prediction": "        tokens.consume(\"foo\", \"FOO\");\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "50250915_64", "part": [1, 1], "seq": [1, 1], "prompt": "class BitbucketServerScm extends AbstractBitbucketScm {\n\n    @Nonnull\n    @Override\n    public String getId() {\n        return ID;\n    }\n\n    public  BitbucketServerScm(Reachable parent);\n\n    @Nonnull @Override public String getUri();\n    @Override public ScmServerEndpointContainer getServers();\n    @Override protected @Nonnull String createCredentialId(@Nonnull String apiUrl);\n    @Nonnull @Override protected String getDomainId();\n\n     String token;\n\n}\n\nclass BitbucketServerScmTest extends AbstractBitbucketScm {\n\n     String token;\n\n    @Test\n    public void getBitbucketScmWithoutApiUrlParam() throws IOException, UnirestException {\n", "reference": "        new RequestBuilder(baseUrl)\n                .status(400)\n                .jwtToken(getJwtToken(j.jenkins, authenticatedUser.getId(), authenticatedUser.getId()))\n                .get(\"/organizations/jenkins/scm/\"+BitbucketServerScm.ID+\"/\")\n                .build(Map.class);\n    }\n\n}", "prediction": "        BitbucketServerScm scm = new BitbucketServerScm(null);\n        scm.token = \"token\";\n        scm.getBitbucketScm();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "50430650_26", "part": [1, 1], "seq": [1, 1], "prompt": "class JunitFeatureRunner extends org.junit.runner.Runner {\n\n    public final void init(final Class<?> reportedClass, final List<Class<?>> stepImplementationClasses,\n                           final String featureFile, final String tags, final String subStepsFile,\n                           final Class<?>[] beforeAndAfterImplementations) {\n        init(reportedClass, stepImplementationClasses, featureFile, tags, subStepsFile, true, null,\n                EclipseDescriptionProvider.class, beforeAndAfterImplementations);\n    }\n\n    public  JunitFeatureRunner();\n    public  JunitFeatureRunner(final Class<?> classContainingTheTests);\n\n    public final void init(final Class<?> reportedClass, final List<Class<?>> stepImplementationClasses,\n                           final String featureFile, final String tags, final String subStepsFileName, final boolean strict,\n                           final String[] nonStrictKeywordPrecedence,\n                           final Class<? extends DescriptionProvider> descriptionProviderClass,\n                           final Class<?>[] beforeAndAfterImplementations);\n    private Config buildConfig(final List<Class<?>> stepImplementationClasses,\n                               final String featureFile, final String tags, final String subStepsFileName, final boolean strict,\n                               final String[] nonStrictKeywordPrecedence,\n                               final Class<?>[] beforeAndAfterImplementations,\n                               String description);\n    @Override public Description getDescription();\n    @Override public void run(final RunNotifier junitNotifier);\n    private static String printDescription(final Description desc, final int depth);\n    public IExecutionNode getRootExecutionNode();\n\n    private File baseResourcesDir;\n\n}\n\nclass JunitFeatureRunnerTest extends org.junit.runner.Runner {\n\n    private File baseResourcesDir;\n\n    @Test(expected = SubstepsConfigurationException.class)\n    public void testMissingSubStepCausesFailure() {\n", "reference": "        final String feature = getResourcePath( \"features/error.feature\");\n        final String tag = \"@bug_missing_sub_step_impl\";\n        final String substeps = getResourcePath( \"substeps/error.substeps\");\n\n        final JunitFeatureRunner runner = new JunitFeatureRunner();\n\n        final List<Class<?>> stepImplsList = new ArrayList<>();\n        stepImplsList.add(TestStepImplementations.class);\n\n        runner.init(this.getClass(), stepImplsList, feature, tag, substeps, null);\n    }\n\n}", "prediction": "        final JunitFeatureRunner runner = new JunitFeatureRunner(getClass());\n        runner.init(getClass(), new ArrayList<Class<?>>(), \"src/test/resources/features/missingSubStep.feature\",\n                null, null, false, null, null, null);\n        runner.run(new RunNotifier());\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "50765065_32", "part": [1, 1], "seq": [1, 1], "prompt": "class TodoListController {\n\n    public void observeItemHeight(View itemView) {\n        itemView.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {\n            @Override\n            public void onGlobalLayout() {\n                emitItemHeightIfNot(itemView);\n                itemView.getViewTreeObserver().removeOnGlobalLayoutListener(this);\n            }\n        });\n    }\n\n    public  TodoListController(@NonNull Context context, @NonNull List<TodoItemViewModel> items,\n                              @NonNull EventBus eventBus);\n\n    public void setItems(List<TodoItemViewModel> items);\n    public void bindFooterAction(TodoFooterViewHolder holder);\n    private Observable<Integer> footerHeight();\n    private int calculateFooterHeight(int listSize, int itemHeight);\n    public void bindItemAction(TodoItemViewHolder viewHolder, TodoItemViewModel viewModel);\n    private void emitItemHeightIfNot(View itemView);\n    public void resetState();\n    private void handleChooseItem(View itemView, TodoItemViewModel decorator);\n    private void updateFooterWhenClickItem(boolean actionShowing);\n    private void updateListWhenClickItem(TodoItemViewModel decorator);\n    private void waitForLayoutCompleteFireEvent(View itemView, TodoItemViewModel decorator);\n    private int indexOf(TodoItemViewModel decorator);\n\n    private static final int CONTENT_HEIGHT;\n    private static final int ITEM_HEIGHT;\n    private TodoListController mTodoListController;\n    private List<TodoItemViewModel> mItemViewModelList;\n    private Context mContext;\n    private TodoItemViewHolder mTodoItemViewHolder;\n    private TodoFooterViewHolder mTodoFooterViewHolder;\n    private View mFooterView;\n    @Rule\n    public PowerMockRule rule;\n    @Mock\n    private EventBus mEventBus;\n\n}\n\nclass TodoListControllerTest {\n\n    private static final int CONTENT_HEIGHT;\n    private static final int ITEM_HEIGHT;\n    private TodoListController mTodoListController;\n    private List<TodoItemViewModel> mItemViewModelList;\n    private Context mContext;\n    private TodoItemViewHolder mTodoItemViewHolder;\n    private TodoFooterViewHolder mTodoFooterViewHolder;\n    private View mFooterView;\n    @Rule\n    public PowerMockRule rule;\n    @Mock\n    private EventBus mEventBus;\n\n    @Test\n    public void testObserveItemHeight() throws Exception {\n", "reference": "        mTodoListController.observeItemHeight(mockFooterView());\n    }\n\n}", "prediction": "        View itemView = mock(View.class);\n        mTodoListController.observeItemHeight(itemView);\n        verify(itemView).getViewTreeObserver();\n        verify(itemView).getViewTreeObserver().addOnGlobalLayoutListener(any(ViewTreeObserver.OnGlobalLayoutListener.class));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "51700398_22", "part": [1, 1], "seq": [1, 1], "prompt": "class SymbolService {\n\n\tpublic void addFavoriteSymbol(String fromSymbolCode, String toSymbolCode, String username) {\n\t\tfavoriteSymbolRepository.save(new FavoriteSymbolEntity(fromSymbolCode, toSymbolCode, username));\n\t\tlog.info(\"Favorite symbol added:{}/{} user:{}\", fromSymbolCode, toSymbolCode, username);\n\t}\n\n\tpublic Symbol addSymbol(String code, String name, String countryFlag, String currencyCode);\n\tpublic Optional<Symbol> getForCode(String code);\n\tpublic Optional<Symbol> getForCodeWithNoCurrency(String code);\n\tpublic void deleteFavoriteSymbol(String fromSymbolCode, String toSymbolCode, String username);\n\n\t@Autowired\n\tprivate SymbolRepository symbolRepo;\n\t@Autowired\n\tprivate SymbolService symbolService;\n\n}\n\nclass SymbolServiceTest {\n\n\t@Autowired\n\tprivate SymbolRepository symbolRepo;\n\t@Autowired\n\tprivate SymbolService symbolService;\n\n\t@Sql(\"/sql/insert_user_symbol_favorite.sql\")\n\t@Test\n\tpublic void testAddFavoriteSymbol() throws Exception {\n", "reference": "\t\tsymbolService.addFavoriteSymbol(USD, EUR, \"user\");\n\t}\n\n}", "prediction": "\t\tsymbolService.addFavoriteSymbol(\"EUR\", \"USD\", \"user1\");\n\t\tassertThat(symbolRepo.count()).isEqualTo(1);\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "51772967_5", "part": [1, 1], "seq": [1, 1], "prompt": "class FileAccessService {\n\n    public boolean isUserCanDelete(String userId, File file) {\n        if (isOwner(userId, file)) return true;\n        if (isUserHasAtLeastGivenPermission(userId, file, Permission.GET_AND_DELETE)) return true;\n        return false;\n    }\n\n    public boolean isUserHasNotAccess(String userId, File file);\n    public boolean isUserCanNotDelete(String userId, File file);\n    public boolean isUserCanNotShare(String userId, File file);\n    public boolean isUserHasAccess(String userId, File file);\n    public boolean isUserCanShare(String userId, File file);\n    public boolean isOwner(String userId, File file);\n    public boolean isUserHasAtLeastGivenPermission(String userId, File file, Permission... permissions);\n\n    private FileAccessService fileAccessService;\n\n}\n\nclass FileAccessServiceTest {\n\n    private FileAccessService fileAccessService;\n\n    @Test\n    public void testIsUserCanDelete() throws Exception {\n", "reference": "\n    }\n\n    public boolean isUserHasNotAccess(String userId, File file);\n    public boolean isUserCanNotDelete(String userId, File file);\n    public boolean isUserCanNotShare(String userId, File file);\n    public boolean isUserHasAccess(String userId, File file);\n    public boolean isUserCanShare(String userId, File file);\n    public boolean isOwner(String userId, File file);\n    public boolean isUserHasAtLeastGivenPermission(String userId, File file, Permission... permissions);\n\n    private FileAccessService fileAccessService;\n\n}\n\nclass FileAccessServiceTest {\n\n    private FileAccessService fileAccessService;\n\n    @Test\n    public void testIsUserCanDelete() throws Exception {\n\n    }\n\n}", "prediction": "        File file = new File(\"test.txt\");\n        file.createNewFile();\n        file.deleteOnExit();\n\n        assertTrue(fileAccessService.isUserCanDelete(\"user1\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user2\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user3\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user4\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user5\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user6\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user7\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user8\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user9\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user10\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user11\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user12\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user13\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user14\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user15\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user16\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user17\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user18\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user19\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user20\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user21\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user22\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user23\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user24\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user25\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user26\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user27\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user28\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user29\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user30\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user31\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user32\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user33\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user34\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user35\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user36\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user37\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user38\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user39\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user40\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user41\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user42\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user43\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user44\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user45\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user46\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user47\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user48\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user49\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user50\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user51\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user52\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user53\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user54\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user55\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user56\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user57\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user58\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user59\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user60\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user61\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user62\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user63\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user64\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user65\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user66\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user67\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user68\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user69\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user70\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user71\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user72\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user73\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user74\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user75\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user76\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user77\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user78\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user79\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user80\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user81\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user82\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user83\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user84\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user85\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user86\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user87\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user88\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user89\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user90\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user91\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user92\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user93\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user94\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user95\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user96\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user97\", file));\n        assertTrue(fileAccessService.isUserCanDelete(\"user98\", file));\n        assertTrue(file", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "51843899_1", "part": [1, 1], "seq": [1, 1], "prompt": "class WARCRecord {\n\n    public static String extractHTTPHeaderContentType(String httpHeaderText)\n            throws IOException\n    {\n        if (httpHeaderText == null) {\n            throw new IOException(\"httpHeaderText parameter is null\");\n        }\n\n        Matcher matcher = CONTENT_TYPE_PATTERN.matcher(httpHeaderText);\n\n        if (matcher.find()) {\n            return matcher.group(1).toLowerCase();\n        }\n\n        return null;\n    }\n\n    public  WARCRecord(DataInput in);\n    public  WARCRecord(WARCRecord other);\n\n    private static Header readHeader(DataInput in);\n    private static String readLine(DataInput in);\n    private static void readSeparator(DataInput in);\n    public boolean isContentApplicationHttpResponse();\n    public String getHTTPHeaders();\n    public Header getHeader();\n    public byte[] getContent();\n    public void write(DataOutput out);\n    @Override public String toString();\n    public void setContent(String newContent);\n    public static String extractHTTPHeaderCharset(String httpHeaderText);\n\n}\n\nclass WARCRecordTest {\n\n    @Test\n    public void testExtractHTTPHeaderContentType()\n            throws Exception\n    {\n", "reference": "        String httpHeaders = \"HTTP/1.1 200 OK\\n\" + \"Date: Sun, 05 Jul 2015 17:30:02 GMT\\n\"\n                + \"Server: Apache/2.2.29 (Unix) FrontPage/5.0.2.2635\\n\"\n                + \"X-Powered-By: PHP/5.3.29-pl0-gentoo\\n\"\n                + \"X-Pingback: http://0351de3.netsolhost.com/WordPress/xmlrpc.php\\n\"\n                + \"Link: <http://0351de3.netsolhost.com/WordPress/?p=8261>; rel=shortlink\\n\"\n                + \"Connection: close\\n\" + \"Content-Type: text/html; charset=UTF-8\\n\";\n\n        assertEquals(\"text/html\", WARCRecord.extractHTTPHeaderContentType(httpHeaders));\n\n        httpHeaders = \"HTTP/1.1 200 OK\\n\" + \"Date: Sun, 05 Jul 2015 17:30:02 GMT\\n\"\n                + \"Content-Type: application/xhtml+xml\\n\"\n                + \"Server: Apache/2.2.29 (Unix) FrontPage/5.0.2.2635\\n\";\n\n        assertEquals(\"application/xhtml+xml\", WARCRecord.extractHTTPHeaderContentType(httpHeaders));\n\n        httpHeaders = \"HTTP/1.1 200 OK\\n\" + \"Date: Sun, 05 Jul 2015 17:30:02 GMT\\n\"\n                + \"Content-Type: application/wordperfect5.1;\\n\"\n                + \"Server: Apache/2.2.29 (Unix) FrontPage/5.0.2.2635\\n\";\n\n        assertEquals(\"application/wordperfect5.1\",\n                WARCRecord.extractHTTPHeaderContentType(httpHeaders));\n\n    }\n\n}", "prediction": "        assertEquals(\"text/html\", WARCRecord.extractHTTPHeaderContentType(\"Content-Type: text/html; charset=utf-8\"));\n        assertEquals(\"text/html\", WARCRecord.extractHTTPHeaderContentType(\"Content-Type: text/html; charset=UTF-8\"));\n        assertEquals(\"text/html\", WARCRecord.extractHTTPHeaderContentType(\"Content-Type: text/html; charset=UTF-8; foo=bar\"));\n        assertEquals(\"text/html\", WARCRecord.extractHTTPHeaderContentType(\"Content-Type: text/html; charset=UTF-8; foo=bar\\r\\n\"));\n        assertEquals(\"text/html\", WARCRecord.extractHTTPHeaderContentType(\"Content-Type: text/html; charset=UTF-8; foo=bar\\r\\n\\r\\n\"));\n        assertEquals(\"text/html\", WARCRecord.extractHTTPHeaderContentType(\"Content-Type: text/html; charset=UTF-8; foo=bar\\r\\n\\r\\n\\r\\n\"));\n        assertEquals(\"text/html\", WARCRecord.extractHTTPHeaderContentType(\"Content-Type: text/html; charset=UTF-8; foo=bar\\r\\n\\r\\n\\r\\n\\r\\n\"));\n        assertEquals(\"text/html\", WARCRecord.extractHTTPHeaderContentType(\"Content-Type: text/html; charset=UTF-8; foo=bar\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\"));\n        assertEquals(\"text/html\", WARCRecord.extractHTTPHeaderContentType(\"Content-Type: text/html; charset=UTF-8; foo=bar\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\"));\n        assertEquals(\"text/html\", WARCRecord.extractHTTPHeaderContentType(\"Content-Type: text/html; charset=UTF-8; foo=bar\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\"));\n        assertEquals(\"text/html\", WARCRecord.extractHTTPHeaderContentType(\"Content-Type: text/html; charset=UTF-8; foo=bar\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\"));\n        assertEquals(\"text/html\", WARCRecord.extractHTTPHeaderContentType(\"Content-Type: text/html; charset=UTF-8; foo=bar\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\"));\n        assertEquals(\"text/html\", WARCRecord.extractHTTPHeaderContentType(\"Content-Type: text/html; charset=UTF-8; foo=bar\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\"));\n        assertEquals(\"text/html\", WARCRecord.extractHTTPHeaderContentType(\"Content-Type: text/html; charset=UTF-8; foo=bar\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\"));\n        assertEquals(\"text/html\", WARCRecord.extractHTTPHeaderContentType(\"Content-Type: text/html; charset=UTF-8; foo=bar\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\"));\n        assertEquals(\"text/html\", WARCRecord.extractHTTPHeaderContentType(\"Content-Type: text/html; charset=UTF-8; foo=bar\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\"));\n        assertEquals(\"text/html\", WARCRecord.extractHTTPHeaderContentType(\"Content-Type: text/html; charset=UTF-8; foo=bar\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\"));\n        assertEquals(\"text/html\", WARCRecord.extractHTTPHeaderContentType(\"Content-Type: text/html; charset=UTF-8; foo=bar\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\"));\n        assertEquals(\"text/html\", WARCRecord.extractHTTPHeaderContentType(\"Content-Type: text/html; charset=UTF-8; foo=bar\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\"));\n        assertEquals(\"text/html\", WARCRecord.extractHTTPHeaderContentType(\"Content-Type: text/html; charset=UTF-8; foo=bar\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\"));\n        assertEquals(\"text/html\", WARCRecord.extractHTTPHeaderContentType(\"Content-Type: text/html; charset=UTF-8; foo=bar\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\"));\n        assertEquals(\"text/html\", WARCRecord.extractHTTPHeaderContentType(\"Content-Type: text/html; charset=UTF-8; foo=bar\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\"));\n        assertEquals(\"text/html\", WARCRecord.extractHTTPHeaderContentType(\"Content-Type: text/html; charset=UTF-8; foo=bar\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\"));\n        assertEquals(\"text/html\", WARCRecord.extractHTTPHeaderContentType(\"Content-Type: text/html; charset=UTF-8; foo=bar\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\"));\n        assertEquals(\"text/html\", WARCRecord.extractHTTPHeaderContentType(\"Content-Type: text/html; charset=UTF-8; foo=bar\\r\\n\\r\\n\\r\\n\\r\\n\\r", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "52316952_26", "part": [1, 1], "seq": [1, 1], "prompt": "class NimbleFrameLayout extends FrameLayout implements NimbleView {\n\n  @Override\n  protected void onDetachedFromWindow() {\n    super.onDetachedFromWindow();\n    presenter().dropView(getMvpView());\n    if (getActivity().isFinishing()) {\n      presenter().onDestroy();\n    }\n  }\n\n  public  NimbleFrameLayout(Context context);\n  public  NimbleFrameLayout(Context context, AttributeSet attrs);\n  public  NimbleFrameLayout(Context context, AttributeSet attrs, int defStyleAttr);\n\n  abstract protected NimblePresenter<V> presenter();\n  public Activity getActivity();\n  @Override protected void onAttachedToWindow();\n  @Override protected Parcelable onSaveInstanceState();\n  @Override protected void onRestoreInstanceState(Parcelable state);\n  private V getMvpView();\n\n  @Mock NimblePresenter<NimbleView> presenter;\n  @Mock Bundle bundle;\n   NimbleFrameLayout<NimbleView> layout;\n  @Mock Context context;\n\n}\n\nclass TestNimbleFrameLayout {\n\n  @Mock NimblePresenter<NimbleView> presenter;\n  @Mock Bundle bundle;\n   NimbleFrameLayout<NimbleView> layout;\n  @Mock Context context;\n\n  @Test\n  public void testOnDetachedFromWindow() throws Exception {\n", "reference": "    prepareForOnDetachedFromWindows(false);\n    layout.onDetachedFromWindow();\n    verify(presenter).dropView(layout);\n  }\n\n}", "prediction": "    layout.onDetachedFromWindow();\n    verify(presenter).dropView(layout.getMvpView());\n    verify(presenter).onDestroy();\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "52972024_314", "part": [1, 1], "seq": [1, 1], "prompt": "class ReceiverGenerator implements IReceiverGenerator {\n\n    @Override\n    public IMessageReceiver generate(\n            final Object objInstance,\n            final IResolveDependencyStrategy wrapperResolutionStrategy,\n            final String methodName\n    ) throws InvalidArgumentException, ReceiverGeneratorException {\n        if (\n                null == objInstance ||\n                null == methodName ||\n                methodName.isEmpty() ||\n                null == wrapperResolutionStrategy\n        ) {\n            throw new InvalidArgumentException(\"One of the arguments null or empty.\");\n        }\n        try {\n            Class<IMessageReceiver> clazz = generateClass(\n                    objInstance,\n                    methodName\n            );\n            return clazz.getConstructor(\n                    new Class[]{objInstance.getClass(), IResolveDependencyStrategy.class}\n            )\n                   .newInstance(new Object[]{objInstance, wrapperResolutionStrategy});\n        } catch (Throwable e) {\n            throw new ReceiverGeneratorException(\n                    \"Could not generate message receiver because of the following error:\",\n                    e\n            );\n        }\n    }\n\n    public  ReceiverGenerator(final ClassLoader classLoader);\n\n    private Class<IMessageReceiver> generateClass(\n            final Object usersObject,\n            final String handlerName\n    );\n    private Class findWrapperInterface(final Object actor, final String handler);\n\n}\n\nclass ReceiverGeneratorTest {\n\n    @Test(expected = ReceiverGeneratorException.class)\n    public void checkReceiverGeneratorExceptionOn()\n            throws Exception {\n", "reference": "        CustomActor a = new CustomActor();\n        IResolveDependencyStrategy strategy = mock(IResolveDependencyStrategy.class);\n\n        IReceiverGenerator rg = new ReceiverGenerator(null);\n        rg.generate(a, strategy, \"a\");\n        fail();\n    }\n\n}", "prediction": "        new ReceiverGenerator(null).generate(\n                new Object(),\n                new ResolveDependencyStrategy(),\n                \"test\"\n        );\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "53297769_0", "part": [1, 1], "seq": [1, 1], "prompt": "class ShouldUseCompactResponses extends AbstractSetting<Boolean> {\n\n    @Override\n    public Boolean getValue() {\n        return AppiumUIA2Driver\n               .getInstance()\n               .getSessionOrThrow()\n               .shouldUseCompactResponses();\n    }\n\n    public  ShouldUseCompactResponses();\n\n    @Override protected void apply(Boolean shouldUseCompactResponses);\n\n    private ShouldUseCompactResponses shouldUseCompactResponses;\n    private Session session;\n\n}\n\nclass ShouldUseCompactResponsesTest {\n\n    private ShouldUseCompactResponses shouldUseCompactResponses;\n    private Session session;\n\n    @Test\n    public void shouldBeAbleToEnableShouldUseCompactResponses() {\n", "reference": "        session.setCapability(SHOULD_USE_COMPACT_RESPONSES.toString(), \"true\");\n        Assert.assertEquals(true, shouldUseCompactResponses.getValue());\n    }\n\n}", "prediction": "        shouldUseCompactResponses.apply(true);\n        assertThat(session.shouldUseCompactResponses()).isTrue();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "53501969_1", "part": [1, 1], "seq": [1, 1], "prompt": "class SentenceWriter extends Processor {\n\n\tprotected void writeSentences(CrawlURI curi, String cleaned_plaintext) {\n\t\tString perplexity_value_as_string = \"null\";\n\t\tif(curi!= null && curi.getData()!= null){\n\t\t\tObject obj = curi.getData().get(SharedConstants.EXTRA_INFO_PERPLEXITY);\n\t\t\tif(obj!= null)\n\t\t\t\tperplexity_value_as_string = (String)obj;\n\t\t}\n\t\tString time = TimeUtils.get_ISO_8601_UTC();\n\t\tint c = 0;\n\t\tsynchronized (_lck) {\n\t\t\tfor(String sentence :  _sentence_maker.getSentences(cleaned_plaintext, _languagecode)){\n\t\t\t\tString s = String.format(\"%s\\t%s\\t%s\\t%d\\t%s%n\", time, sentence, curi, ++c, perplexity_value_as_string);\n\t\t\t\t_current_stream.print(s);\n\t\t\t\t_num_bytes_written.getAndAdd(s.getBytes().length);\n\t\t\t\t_num_bytes_sentences_written.getAndAdd(sentence.getBytes().length);\n\t\t\t}\n\t\t\t_current_stream.flush();\n\t\t}\n\t\t_num_sentences.getAndAdd(c);\n\t\t_num_uris_written.getAndIncrement();\n\t}\n\n\tpublic  SentenceWriter();\n\n\tpublic TextExtractor getTextExtractor();\n\tpublic void setTextExtractor(TextExtractor text_extractor);\n\tpublic SentenceMaker getSentenceMaker();\n\tpublic void setSentenceMaker(SentenceMaker sentence_maker);\n\tpublic ConfigPath getPath();\n\tpublic void setPath(ConfigPath newpath);\n\tpublic String getLanguageCode();\n\tpublic void setLanguageCode(String languagecode);\n\tpublic long getMaxFileSizeBytes();\n\tpublic void setMaxFileSizeBytes(long maxFileSizeBytes);\n\tpublic String getPrefix();\n\tpublic void setPrefix(String prefix);\n\tpublic String getFilenameFormat();\n\tpublic void setFilenameFormat(String filename_format);\n\t@Override public void start();\n\t@Override public void stop();\n\t@Override protected boolean shouldProcess(CrawlURI curi);\n\t@Override protected void innerProcess(CrawlURI curi);\n\tprotected File updateOuputFile();\n\tprotected String getFilename();\n\tprotected PrintStream openPrintToFileStream(File outputfile);\n\t@Override public String report();\n\n}\n\nclass SentenceWriterTest {\n\n\t@Test\n\tpublic void test() {\n", "reference": "\t\tSentenceWriter w = new SentenceWriter(){{_sentence_maker = new SentenceMaker();}};\n\t\tw._current_stream = System.out;\n\t\tw.writeSentences(null, \"This is a test. This is also a test.\");\n\t}\n\n}", "prediction": "\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "53528552_2", "part": [1, 1], "seq": [1, 1], "prompt": "class RegexEvaluator {\n\n    public void update(String regex, int flags, String replacement, String input) {\n        try {\n            //TODO: catch empty/null exceptions\n            if (!this.regex.equals(regex) || this.flags!= flags) {\n                pattern = Pattern.compile(regex, flags);\n                this.regex = regex;\n                this.flags = flags;\n                this.validRegex = true;\n                this.validReplex = true;\n            }\n            if (pattern!= null) {\n                matcher = pattern.matcher(input);\n                matches = matcher.matches();\n                matcher.reset();\n                if (isNotEmpty(replacement)) {\n                    try {\n                        replaceFirst = matcher.replaceFirst(replacement);\n                        replaceAll = matcher.replaceAll(replacement);\n                        validReplex = true;\n                    } catch (IllegalArgumentException iae) {\n                        validReplex = false;\n                        replexReason = iae.getMessage();\n                        replaceAll = \"\";\n                        replaceFirst = \"\";\n                    } catch (IndexOutOfBoundsException ioe) {\n                        validReplex = false;\n                        replexReason = ioe.getMessage();\n                        replaceAll = \"\";\n                        replaceFirst = \"\";\n                    }\n                }\n                lookingAt = matcher.lookingAt();\n                matcher.reset();\n                find = matcher.find();\n                if (find) {\n                    groups = new MatcherGroup[matcher.groupCount() + 1];\n                    for (int i = 0; i < matcher.groupCount() + 1; i++) {\n                        groups[i] = new MatcherGroup(matcher.start(i), matcher.end(i), matcher.group(i));\n                    }\n                } else {\n                    groups = new MatcherGroup[0];\n                }\n            }\n        } catch (PatternSyntaxException pse) {\n            this.validRegex = false;\n            this.regexReason = pse.getMessage();\n        }\n    }\n\n    private boolean isNotEmpty(String toTest);\n\n   RegexEvaluator eval;\n\n}\n\nclass RegexEvaluatorTest {\n\n   RegexEvaluator eval;\n\n  @Test\n  public void testMultipleGroups() {\n", "reference": "    String testInput = \"Foobar Ipsum Lorem\";\n    eval.update(\"Foo(.*) (.*)\", 0, \"\", testInput);\n    assertTrue(eval.matches);\n    assertTrue(eval.lookingAt);\n    assertTrue(eval.find);\n    assertEquals(3, eval.groups.length);\n    assertEquals(testInput, eval.groups[0].group);\n    assertEquals(0, eval.groups[0].start);\n    assertEquals(testInput.length(), eval.groups[0].end);\n    assertEquals(\"bar Ipsum\", eval.groups[1].group);\n    assertEquals(3, eval.groups[1].start);\n    assertEquals(12, eval.groups[1].end);\n    assertEquals(\"Lorem\", eval.groups[2].group);\n    assertEquals(13, eval.groups[2].start);\n    assertEquals(testInput.length(), eval.groups[2].end);\n  }\n\n}", "prediction": "      eval.update(\"([a-z]+)([0-9]+)\", 0, \"$2$1\", \"abc123\");\n      MatcherGroup[] groups = eval.getGroups();\n      assertEquals(2, groups.length);\n      assertEquals(\"abc\", groups[0].getValue());\n      assertEquals(\"123\", groups[1].getValue());\n  }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "54785866_1", "part": [1, 1], "seq": [1, 1], "prompt": "class UIFrame extends UIElement {\n\n\t@Override\n\tpublic Object deepCopy() {\n\t\tfinal int attrSize = attributes!= null? attributes.size() : 0;\n\t\tfinal int childrenSize = children!= null? children.size() : 0;\n\t\tfinal UIFrame clone = new UIFrame(getName(), attrSize, childrenSize);\n\t\tclone.type = type;\n\t\tif (childrenSize > 0) {\n\t\t\tfor (int i = 0; i < childrenSize; i++) {\n\t\t\t\tclone.children.add((UIElement) children.get(i).deepCopy());\n\t\t\t}\n\t\t}\n\t\tif (attrSize > 0) {\n\t\t\tfor (int i = 0; i < attrSize; i++) {\n\t\t\t\tclone.attributes.add((UIAttribute) attributes.get(i).deepCopy());\n\t\t\t}\n\t\t}\n\t\tif (relative!= DFLT_RELATIVE) {\n\t\t\tclone.relative = new String[4];\n\t\t\tSystem.arraycopy(relative, 0, clone.relative, 0, 4);\n\t\t}\n\t\tif (offset!= DFLT_OFFSET) {\n\t\t\tclone.offset = new String[4];\n\t\t\tSystem.arraycopy(offset, 0, clone.offset, 0, 4);\n\t\t}\n\t\tif (pos!= DFLT_POS) {\n\t\t\tclone.pos = new String[4];\n\t\t\tSystem.arraycopy(pos, 0, clone.pos, 0, 4);\n\t\t}\n\t\treturn clone;\n\t}\n\n\tpublic  UIFrame();\n\tpublic  UIFrame(final String name, final String type);\n\tpublic  UIFrame(final String name, final int initialAttributesCapacity, final int initialChildrenCapacity);\n\tpublic  UIFrame(final String name);\n\n\tprivate void init();\n\tpublic String getType();\n\tpublic void setType(final String type);\n\t@Override public List<UIElement> getChildren();\n\tpublic void setChildren(final List<UIElement> children);\n\t@Override public List<UIElement> getChildrenRaw();\n\tpublic void addAttribute(final UIAttribute value);\n\tpublic UIAttribute getValue(final String key);\n\tpublic List<UIAttribute> getAttributes();\n\tpublic String getAnchorRelative(final UIAnchorSide side);\n\tpublic String getAnchorOffset(final UIAnchorSide side);\n\tpublic String getAnchorPos(final UIAnchorSide side);\n\tpublic void setAnchor(final String relative, final String offset);\n\tpublic void setAnchor(final UIAnchorSide side, final String relative, final String pos, final String offset);\n\tpublic void setAnchorRelative(final UIAnchorSide side, final String relative);\n\tpublic void setAnchorPos(final UIAnchorSide side, final String pos);\n\tpublic void setAnchorOffset(final UIAnchorSide side, final String offset);\n\t@Override public UIElement receiveFrameFromPath(final String path);\n\t@Override public String toString();\n\t@Override public boolean equals(final Object obj);\n\tprivate Object[] getSignatureFields();\n\t@Override public int hashCode();\n\n}\n\nclass UIFrameTest {\n\n\t@Test\n\tvoid deepCopy() {\n", "reference": "\t\tfinal UIFrame frame = new UIFrame(\"UIFrameTest_setAnchor\");\n\t\t\n\t\tframe.setAnchor(\"$parent\", \"0\");\n\t\tassertEquals(\"$parent\", frame.getAnchorRelative(UIAnchorSide.TOP));\n\t\tassertEquals(\"$parent\", frame.getAnchorRelative(UIAnchorSide.LEFT));\n\t\tassertEquals(\"$parent\", frame.getAnchorRelative(UIAnchorSide.BOTTOM));\n\t\tassertEquals(\"$parent\", frame.getAnchorRelative(UIAnchorSide.RIGHT));\n\t\tassertEquals(\"MIN\", frame.getAnchorPos(UIAnchorSide.TOP));\n\t\tassertEquals(\"MIN\", frame.getAnchorPos(UIAnchorSide.LEFT));\n\t\tassertEquals(\"MAX\", frame.getAnchorPos(UIAnchorSide.BOTTOM));\n\t\tassertEquals(\"MAX\", frame.getAnchorPos(UIAnchorSide.RIGHT));\n\t\tassertEquals(\"0\", frame.getAnchorOffset(UIAnchorSide.TOP));\n\t\tassertEquals(\"0\", frame.getAnchorOffset(UIAnchorSide.LEFT));\n\t\tassertEquals(\"0\", frame.getAnchorOffset(UIAnchorSide.BOTTOM));\n\t\tassertEquals(\"0\", frame.getAnchorOffset(UIAnchorSide.RIGHT));\n\t\t\n\t\tfinal UIFrame frame2 = (UIFrame) frame.deepCopy();\n\t\tassertEquals(\"$parent\", frame2.getAnchorRelative(UIAnchorSide.TOP));\n\t\tassertEquals(\"$parent\", frame2.getAnchorRelative(UIAnchorSide.LEFT));\n\t\tassertEquals(\"$parent\", frame2.getAnchorRelative(UIAnchorSide.BOTTOM));\n\t\tassertEquals(\"$parent\", frame2.getAnchorRelative(UIAnchorSide.RIGHT));\n\t\tassertEquals(\"MIN\", frame2.getAnchorPos(UIAnchorSide.TOP));\n\t\tassertEquals(\"MIN\", frame2.getAnchorPos(UIAnchorSide.LEFT));\n\t\tassertEquals(\"MAX\", frame2.getAnchorPos(UIAnchorSide.BOTTOM));\n\t\tassertEquals(\"MAX\", frame2.getAnchorPos(UIAnchorSide.RIGHT));\n\t\tassertEquals(\"0\", frame2.getAnchorOffset(UIAnchorSide.TOP));\n\t\tassertEquals(\"0\", frame2.getAnchorOffset(UIAnchorSide.LEFT));\n\t\tassertEquals(\"0\", frame2.getAnchorOffset(UIAnchorSide.BOTTOM));\n\t\tassertEquals(\"0\", frame2.getAnchorOffset(UIAnchorSide.RIGHT));\n\t\t\n\t\tframe2.setAnchor(UIAnchorSide.BOTTOM, \"$Minimap\", \"mid\", \"11\");\n\t\tassertEquals(\"$parent\", frame2.getAnchorRelative(UIAnchorSide.TOP));\n\t\tassertEquals(\"$parent\", frame2.getAnchorRelative(UIAnchorSide.LEFT));\n\t\tassertEquals(\"$Minimap\", frame2.getAnchorRelative(UIAnchorSide.BOTTOM));\n\t\tassertEquals(\"$parent\", frame2.getAnchorRelative(UIAnchorSide.RIGHT));\n\t\tassertEquals(\"MIN\", frame2.getAnchorPos(UIAnchorSide.TOP));\n\t\tassertEquals(\"MIN\", frame2.getAnchorPos(UIAnchorSide.LEFT));\n\t\tassertEquals(\"mid\", frame2.getAnchorPos(UIAnchorSide.BOTTOM));\n\t\tassertEquals(\"MAX\", frame2.getAnchorPos(UIAnchorSide.RIGHT));\n\t\tassertEquals(\"0\", frame2.getAnchorOffset(UIAnchorSide.TOP));\n\t\tassertEquals(\"0\", frame2.getAnchorOffset(UIAnchorSide.LEFT));\n\t\tassertEquals(\"11\", frame2.getAnchorOffset(UIAnchorSide.BOTTOM));\n\t\tassertEquals(\"0\", frame2.getAnchorOffset(UIAnchorSide.RIGHT));\n\t\t\n\t}\n\n}", "prediction": "\t\tfinal UIFrame frame = new UIFrame(\"frame\");\n\t\tframe.setType(\"type\");\n\t\tframe.setAnchor(\"relative\", \"offset\");\n\t\tframe.setAnchor(UIAnchorSide.TOP, \"relative\", \"pos\", \"offset\");\n\t\tframe.addAttribute(new UIAttribute(\"key\", \"value\"));\n\t\tframe.addAttribute(new UIAttribute(\"key2\", \"value2\"));\n\t\tframe.addChild(new UIFrame(\"child\"));\n\t\tframe.addChild(new UIFrame(\"child2\"));\n\t\tfinal UIFrame clone = (UIFrame) frame.deepCopy();\n\t\tAssert.assertEquals(frame, clone);\n\t}", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "54854741_58", "part": [1, 1], "seq": [1, 1], "prompt": "class OfxTransactionReader implements Closeable {\n\n\tString readNextNonBlankLine() throws IOException {\n\t\tskipBlankLines();\n\t\treturn reader.readLine();\n\t}\n\n\tpublic  OfxTransactionReader(InputStream inputStream);\n\n\tpublic List<Transaction> transactions();\n\tprivate Transaction readTransaction(SgmlReader sgmlReader, String tagName, String accountNumber);\n\tprivate Long readTransactionAmount(String value);\n\tprivate Date readTransactionDate(String value);\n\tprivate String readAccountNumber(SgmlReader sgmlReader, String tagName);\n\tprivate boolean isCloseTag(Token token, String tagName);\n\tprivate void readHeader();\n\tprivate void advanceToFirstNonHeaderLine();\n\tprivate void skipBlankLines();\n\tprivate void checkValidFormat(String expected, String line);\n\t@Override public void close();\n\n}\n\nclass OfxTransactionReaderTest {\n\n\t@Test\n\tpublic void readNextNonBlankLine() throws IOException {\n", "reference": "\t\ttry (OfxTransactionReader reader = new OfxTransactionReader(\n\t\t\t\tnew ByteArrayInputStream(\"\\n\\r\\none\\n\\rtwo\".getBytes(StandardCharsets.UTF_8)))) {\n\t\t\tassertEquals(\"one\", reader.readNextNonBlankLine());\n\t\t\tassertEquals(\"two\", reader.readNextNonBlankLine());\n\t\t\tassertEquals(null, reader.readNextNonBlankLine());\n\t\t}\n\t}\n\n}", "prediction": "\t\tString line = \"  \";\n\t\tStringReader reader = new StringReader(line);\n\t\tOfxTransactionReader transactionReader = new OfxTransactionReader(reader);\n\t\tString result = transactionReader.readNextNonBlankLine();\n\t\tassertEquals(line, result);\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "55138951_1", "part": [1, 1], "seq": [1, 1], "prompt": "class CCSManageSvImpl implements ICCSManageSv {\n\n    @Override\n    public void delete(CCSOperationParam param) throws PaasException {\n        param.validate();\n        if (!exists(param))\n            return;\n\n        CcsServiceUserConfig config = getCcsServiceUserConfig(param.getUserId(), param.getServiceId());\n\n        ZKClient client = null;\n        try {\n            client = ZookeeperClientUtil.getZkClientFromPool(config.getZkAddress(), config.getZkUserName(),\n                    CiperUtil.decrypt(ConfigCenterConstants.operators, config.getZkPassword()),config.getServiceId());\n            client.deleteNode(appendCustomUserRootNode(param.getUserId(), param.getServiceId())\n                    + param.getPath());\n        } catch (Exception e) {\n        \tlogger.error(e.getMessage(),e);\n            throw new PaasException(ResourceUtil.getMessage(BundleKeyConstants.CONFIG_ERROR), e);\n        }\n    }\n\n    @Override public void add(CCSOperationParam param, String data);\n    @Override public void add(CCSOperationParam param, byte[] data);\n    @Override public boolean exists(CCSOperationParam param);\n    private CcsServiceUserConfig getCcsServiceUserConfig(String userId, String serviceId);\n    @Override public void modify(CCSOperationParam param, String data);\n    @Override public void modify(CCSOperationParam param, byte[] data);\n    @Override public String get(CCSOperationParam param);\n    @Override public byte[] readBytes(CCSOperationParam param);\n    @Override public List<String> listSubPath(CCSOperationParam param);\n    @Override public Map<String,String> listAllPath(CCSOperationParam param);\n    public List<String> formatPath(List<String> children,CCSOperationParam param);\n    @Override public List<CCSSubListDTO> listSubPathAndData(CCSOperationParam param);\n    @Override public List<String> getServices(CCSOperationParam param);\n    private String appendCustomUserRootNode(String userId, String serviceId);\n    public Map<String, String> getResult();\n    public void setResult(Map<String, String> result);\n\n    private String userId;\n    private String serviceId;\n    @Autowired\n    private ICCSManageSv manageSv;\n    @Autowired\n    private IConfigCenterServiceManageSv iConfigCenterServiceManageSv;\n\n}\n\nclass CCSManageSvImplTest {\n\n    private String userId;\n    private String serviceId;\n    @Autowired\n    private ICCSManageSv manageSv;\n    @Autowired\n    private IConfigCenterServiceManageSv iConfigCenterServiceManageSv;\n\n    @Test\n    public void testDelete() throws Exception {\n", "reference": "        CCSOperationParam ccsOperationParam = new CCSOperationParam();\n        ccsOperationParam.setUserId(userId);\n        ccsOperationParam.setServiceId(serviceId);\n        ccsOperationParam.setPath(\"/test/testPath\");\n        manageSv.delete(ccsOperationParam);\n        assertFalse(manageSv.exists(ccsOperationParam));\n    }\n\n}", "prediction": "//        CCSOperationParam param = new CCSOperationParam();\n//        param.setUserId(userId);\n//        param.setServiceId(serviceId);\n//        param.setPath(\"/test/test\");\n//        manageSv.delete(param);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "55954702_4", "part": [1, 1], "seq": [1, 1], "prompt": "class SaveBmiService extends IntentService {\n\n    @Override\n    protected void onHandleIntent(Intent intent) {\n        if (intent == null) {\n            return;\n        }\n\n        Serializable extra = intent.getSerializableExtra(PARAM_KEY_BMI_VALUE);\n        if (extra == null ||!(extra instanceof BmiValue)) {\n            return;\n        }\n\n        BmiValue bmiValue = (BmiValue)extra;\n        boolean result = saveToRemoteServer(bmiValue);\n        sendLocalBroadcast(result);\n    }\n\n    public  SaveBmiService();\n\n    @Override public void onCreate();\n    @VisibleForTesting boolean saveToRemoteServer(BmiValue bmiValue);\n    @VisibleForTesting void sendLocalBroadcast(boolean result);\n    @VisibleForTesting void setLocalBroadcastManager(LocalBroadcastManager manager);\n    public static void start(Context context, BmiValue bmiValue);\n\n}\n\nclass SaveBmiServiceTest {\n\n    @Test\n    public void onHandleIntent\u306bBmiValue\u578b\u4ee5\u5916\u306e\u30c7\u30fc\u30bf\u304c\u5165\u3063\u305fIntent\u3092\u6e21\u3057\u305f\u3089\u4f55\u3082\u3057\u306a\u3044() {\n", "reference": "        Intent intent = mock(Intent.class);\n        when(intent.getSerializableExtra(SaveBmiService.PARAM_KEY_BMI_VALUE)).thenReturn(\"hoge\");\n\n        SaveBmiService service = spy(new SaveBmiService());\n        service.onHandleIntent(intent);\n        verify(service, never()).sendLocalBroadcast(anyBoolean());\n        verify(service, never()).saveToRemoteServer((BmiValue)any());\n    }\n\n}", "prediction": "        Intent intent = new Intent();\n        intent.putExtra(SaveBmiService.PARAM_KEY_BMI_VALUE, \"hoge\");\n\n        SaveBmiService service = new SaveBmiService();\n        service.onHandleIntent(intent);\n\n        verify(service, never()).saveToRemoteServer(any(BmiValue.class));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "56533838_1", "part": [1, 1], "seq": [1, 1], "prompt": "class BuildFileGenerator {\n\n  void generateBuildFiles(ApisVisitor visitor) throws IOException {\n    System.out.println(\"\\n\\n========== READING INPUT DIRECTORY ==========\");\n    Files.walkFileTree(visitor.getSrcDir(), visitor);\n    visitor.setWriterMode(true);\n    System.out.println(\"\\n\\n========== WRITING GENERATED FILES ==========\");\n    Files.walkFileTree(visitor.getSrcDir(), visitor);\n\n    System.out.println(\"\\nBUILD.bazel file generation completed successfully\\n\");\n  }\n\n  public static void main(String[] args);\n\n  private static final String SRC_DIR;\n  private static final String PATH_PREFIX;\n\n}\n\nclass BuildFileGeneratorTest {\n\n  private static final String SRC_DIR;\n  private static final String PATH_PREFIX;\n\n  @Test\n  public void testRegeneration() throws IOException, InterruptedException {\n", "reference": "    // In this test we run the generator twice, changing the generated\n    // google/example/library/v1/BUILD.bazel\n    // after the first run, and verifying that some changed values are preserved\n    // (and some are not).\n    Path tempDirPath = getTemporaryDirectory();\n\n    // I'm lazy, so let's just \"cp -r\" stuff.\n    Path fixturesPath = Paths.get(PATH_PREFIX, SRC_DIR);\n    new ProcessBuilder(new String[] {\"cp\", \"-r\", fixturesPath.toString(), tempDirPath.toString()})\n        .start()\n        .waitFor();\n\n    String buildozerPath = getBuildozerPath();\n    Path copiedGoogleapis = Paths.get(tempDirPath.toString(), \"googleapis\");\n    ArgsParser args =\n        new ArgsParser(new String[] {\"--buildozer=\" + buildozerPath, \"--src=\" + copiedGoogleapis});\n    new BuildFileGenerator()\n        .generateBuildFiles(args.createApisVisitor(null, tempDirPath.toString()));\n\n    Path fileBodyPathPrefix =\n        Paths.get(copiedGoogleapis.toString(), \"google\", \"example\", \"library\");\n    Path gapicBuildFilePath = Paths.get(fileBodyPathPrefix.toString(), \"v1\", \"BUILD.bazel\");\n    String rawBuildFilePath = Paths.get(fileBodyPathPrefix.toString(), \"BUILD.bazel\").toString();\n\n    Assert.assertEquals(\n        ApisVisitor.readFile(gapicBuildFilePath.toString() + \".baseline\"),\n        ApisVisitor.readFile(gapicBuildFilePath.toString()));\n    Assert.assertEquals(\n        ApisVisitor.readFile(rawBuildFilePath + \".baseline\"),\n        ApisVisitor.readFile(rawBuildFilePath));\n\n    // Now change some values in google/example/library/v1/BUILD.bazel\n    Buildozer.setBinaryPath(buildozerPath);\n    Buildozer buildozer = Buildozer.getInstance();\n    // The following values should be preserved:\n    buildozer.batchSetAttribute(\n        gapicBuildFilePath, \"library_nodejs_gapic\", \"package_name\", \"@google-cloud/library\");\n    buildozer.batchRemoveAttribute(\n        gapicBuildFilePath, \"library_nodejs_gapic\", \"extra_protoc_parameters\");\n    buildozer.batchAddAttribute(\n        gapicBuildFilePath, \"library_nodejs_gapic\", \"extra_protoc_parameters\", \"param1\");\n    buildozer.batchAddAttribute(\n        gapicBuildFilePath, \"library_nodejs_gapic\", \"extra_protoc_parameters\", \"param2\");\n    buildozer.batchSetAttribute(\n        gapicBuildFilePath,\n        \"google-cloud-example-library-v1-csharp\",\n        \"name\",\n        \"renamed_csharp_rule\");\n    buildozer.batchSetAttribute(\n        gapicBuildFilePath, \"google-cloud-example-library-v1-java\", \"name\", \"renamed_java_rule\");\n\n    // The following values should NOT be preserved:\n    buildozer.batchSetAttribute(\n        gapicBuildFilePath,\n        \"library_nodejs_gapic\",\n        \"grpc_service_config\",\n        \"fake_grpc_service_config\");\n\n    buildozer.commit();\n\n    // Run the generator again\n    new BuildFileGenerator()\n        .generateBuildFiles(args.createApisVisitor(null, tempDirPath.toString()));\n\n    // Check that values are preserved\n    Assert.assertEquals(\n        \"@google-cloud/library\",\n        buildozer.getAttribute(gapicBuildFilePath, \"library_nodejs_gapic\", \"package_name\"));\n    Assert.assertEquals(\n        \"[param1 param2]\",\n        buildozer.getAttribute(\n            gapicBuildFilePath, \"library_nodejs_gapic\", \"extra_protoc_parameters\"));\n    Assert.assertEquals(\n        \"renamed_csharp_rule\",\n        buildozer.getAttribute(gapicBuildFilePath, \"%csharp_gapic_assembly_pkg\", \"name\"));\n    Assert.assertEquals(\n        \"renamed_java_rule\",\n        buildozer.getAttribute(gapicBuildFilePath, \"%java_gapic_assembly_gradle_pkg\", \"name\"));\n    // Check that grpc_service_config value is not preserved:\n    Assert.assertEquals(\n        \"library_example_grpc_service_config.json\",\n        buildozer.getAttribute(gapicBuildFilePath, \"library_nodejs_gapic\", \"grpc_service_config\"));\n\n    // Now run with overwrite and verify it actually ignores all the changes\n    ArgsParser argsOverwrite =\n        new ArgsParser(\n            new String[] {\n              \"--overwrite\", \"--buildozer=\" + buildozerPath, \"--src=\" + copiedGoogleapis\n            });\n    new BuildFileGenerator()\n        .generateBuildFiles(argsOverwrite.createApisVisitor(null, tempDirPath.toString()));\n    Assert.assertEquals(\n        ApisVisitor.readFile(gapicBuildFilePath.toString() + \".baseline\"),\n        ApisVisitor.readFile(gapicBuildFilePath.toString()));\n    Assert.assertEquals(\n        ApisVisitor.readFile(rawBuildFilePath + \".baseline\"),\n        ApisVisitor.readFile(rawBuildFilePath));\n  }\n\n}", "prediction": "    BuildFileGenerator generator = new BuildFileGenerator();\n    generator.generateBuildFiles(new ApisVisitor(SRC_DIR, PATH_PREFIX));\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "56582318_18", "part": [1, 1], "seq": [1, 1], "prompt": "class BufferComputing {\n\n  public static ILineString buildHalfOffsetLine(Side side, ILineString line,\n      double distance) {\n    IPolygon offsetBuffer = buildHalfOffsetBuffer(side, line, distance);\n    IDirectPositionList pts = offsetBuffer.coord();\n\n    for (IDirectPosition pt : line.coord())\n      pts.remove(pt);\n    // then remove the last point of the polygon\n    pts.remove(pts.size() - 1);\n\n    return new GM_LineString(pts);\n\n  }\n\n  public static IPolygon buildLineHalfBuffer(ILineString line, double distance,\n      Side side);\n  public static IPolygon buildSegmentHalfBuffer(ILineSegment line,\n      double distance, Side side);\n  public static HashMap<IDirectPosition, Integer> getEndingPtsOfRoundPart(\n      IDirectPosition point, IRing buffer, double distance);\n  public static int getSideEndingPtsOfRoundPart(Side side, boolean start,\n      IDirectPosition point, IRing buffer, double distance);\n  public static IPolygon buildHalfOffsetBuffer(Side side, ILineString line,\n      double distance);\n\n}\n\nclass BufferComputingTest {\n\n  @Test\n  public void testBuildHalfOffsetLine() {\n", "reference": "    IDirectPosition p1 = new DirectPosition(0.0, 0.0);\n    IDirectPosition p2 = new DirectPosition(10.0, 0.0);\n    IDirectPosition p3 = new DirectPosition(20.0, 0.0);\n    IDirectPosition p4 = new DirectPosition(20.0, 10.0);\n    IDirectPosition p6 = new DirectPosition(0.0, 5.0);\n    IDirectPosition p7 = new DirectPosition(10.0, 5.0);\n    IDirectPosition p8 = new DirectPosition(20.0, 5.0);\n    IDirectPosition p9 = new DirectPosition(0.0, 5.0);\n    IDirectPosition p10 = new DirectPosition(10.0, 5.0);\n    IDirectPosition p11 = new DirectPosition(15.0, 5.0);\n    IDirectPosition p12 = new DirectPosition(15.0, 10.0);\n    IDirectPositionList list1 = new DirectPositionList();\n    IDirectPositionList list2 = new DirectPositionList();\n    IDirectPositionList list3 = new DirectPositionList();\n    IDirectPositionList list4 = new DirectPositionList();\n    list1.add(p1);\n    list1.add(p2);\n    list1.add(p3);\n    ILineString line1 = new GM_LineString(list1);\n    list2.add(p6);\n    list2.add(p7);\n    list2.add(p8);\n    ILineString line2 = new GM_LineString(list2);\n    Assert.assertTrue(line2.equals(BufferComputing.buildHalfOffsetLine(\n        Side.LEFT, line1, 5.0)));\n    Assert.assertTrue(line1.equals(BufferComputing.buildHalfOffsetLine(\n        Side.RIGHT, line2, 5.0)));\n    list3.add(p1);\n    list3.add(p2);\n    list3.add(p3);\n    list3.add(p4);\n    ILineString line3 = new GM_LineString(list3);\n    list4.add(p9);\n    list4.add(p10);\n    list4.add(p11);\n    list4.add(p12);\n    ILineString line4 = new GM_LineString(list4);\n    Assert.assertTrue(line4.equals((IGeometry) BufferComputing\n        .buildHalfOffsetLine(Side.LEFT, line3, 5.0)));\n    IDirectPositionList list5 = new DirectPositionList();\n    list5.add(new DirectPosition(0.0, 10.0));\n    list5.add(new DirectPosition(20.0, 10.0));\n    list5.add(new DirectPosition(20.0, 0.0));\n    ILineString line5 = new GM_LineString(list5);\n    IDirectPositionList list6 = new DirectPositionList();\n    list6.add(new DirectPosition(0.0, 5.0));\n    list6.add(new DirectPosition(15.0, 5.0));\n    list6.add(new DirectPosition(15.0, 0.0));\n    ILineString line6 = new GM_LineString(list6);\n    Assert.assertTrue(line6.equals(BufferComputing.buildHalfOffsetLine(\n        Side.RIGHT, line5, 5.0)));\n\n  }\n\n}", "prediction": "//    ILineString line = new GM_LineString(new DirectPositionList(\n//        new DirectPosition[] { new DirectPosition(0, 0), new DirectPosition(1,\n//            0), new DirectPosition(1, 1), new DirectPosition(0, 1) }));\n//    ILineString offsetLine = BufferComputing.buildHalfOffsetLine(Side.LEFT,\n//        line, 0.5);\n//    System.out.println(offsetLine);\n//    assertEquals(4, offsetLine.coord().size());\n//    assertEquals(new DirectPosition(0.5, 0.5), offsetLine.coord().get(0));\n//    assertEquals(new DirectPosition(0.5, 0.5), offsetLine.coord().get(1));\n//    assertEquals(new DirectPosition(0.5, 0.5), offsetLine.coord().get(2));\n//    assertEquals(new DirectPosition(0.5, 0.5), offsetLine.coord().get(3));\n  }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "56585217_5", "part": [1, 1], "seq": [1, 1], "prompt": "class UserServiceImpl implements UserService {\n\n    @Transactional(readOnly = true)\n    @Override\n    public User authenticate(String email, String password) throws UserNotFoundException, PasswordNotMatchedException {\n        User user = findByEmail(email);\n        if (user == null) {\n            throw new UserNotFoundException(\"\u672a\u627e\u5230\u90ae\u7bb1\u4e3a [\" + email + \"] \u7684\u7528\u6237\");\n        }\n\n        String encPassword = DigestUtils.md5Hex(password);\n        if (!encPassword.equalsIgnoreCase(user.getPassword())) {\n            throw new PasswordNotMatchedException(\"\u7528\u6237 [\" + email + \"] \u8f93\u5165\u7684\u5bc6\u7801\u9519\u8bef\");\n        }\n        return user;\n    }\n\n    @Override public void save(User user);\n    @Override public void save(User user, int[] appIds);\n    @Override public void update(User user);\n    @Override public void updatePassword(int id, String oldPassword, String newPassword);\n    @Override public void update(User user, int[] appIds);\n    @Override public void deleteById(int id);\n    @Transactional(readOnly = true) @Override public User findById(int id);\n    @Transactional(readOnly = true) @Override public User findByEmail(String email);\n    @Transactional(readOnly = true) @Override public int[] findUserAppIds(int id);\n    @Override public List<User> findOrdinaryUsers();\n    @Transactional(readOnly = true) @Override public List<User> findAll();\n    private void saveUserApps(int userId, int[] appIds);\n\n    @Autowired\n    private UserService userService;\n\n}\n\nclass UserServiceImplTest  {\n\n    @Autowired\n    private UserService userService;\n\n    @Test(dataProvider = \"dataUser\", expectedExceptions = UserNotFoundException.class)\n    public void testAuthenticate(User user) {\n", "reference": "        userService.save(user);\n\n        userService.authenticate(\"kevinzzzzzzzzzzz999999****@weghst.com\", \"88888888\");\n    }\n\n}", "prediction": "        userService.authenticate(user.getEmail(), user.getPassword());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "56587374_22", "part": [1, 1], "seq": [1, 1], "prompt": "class Output implements Verifiable {\n\n    public void setOutputProperty(final String key, final String value) throws InvalidSyntaxException {\n        outputProperties.defineProperty(key, value);\n    }\n\n    public  Output();\n\n    public void setRelativeTo(String relativeTo);\n    public void setRelativePath(String relativePath);\n    public void setAbsolute(String absolute);\n    public void setPrefix(String prefix);\n    public void setSuffix(String suffix);\n    public void setName(String name);\n    private boolean isAbsolute();\n    public void setNull(final boolean nullOutput);\n    public void setOutputProperties(final Properties props);\n    public void unsetOutputProperty(final String key);\n    public boolean isNullOutput();\n    public Properties getOutputProperties();\n    public String getOutputProperty(final String key);\n    public File getDestinationFile(File sourceFile, HashMap<QName,ParameterValue> parameters);\n    private String getFileName(File sourceFile, HashMap<QName,ParameterValue> parameters);\n    @Override public void verify();\n    @Override public String toString();\n    public String toString(final String prefix);\n    public String getConsole();\n    public void setConsole(String console);\n    public boolean isConsoleOutput();\n    public String getId();\n    public void setId(String id);\n\n    private Output output;\n    private static HashMap<QName,ParameterValue> emptyInputParams;\n    private static SaxonConfigurationFactory configFactory;\n\n}\n\nclass OutputTest {\n\n    private Output output;\n    private static HashMap<QName,ParameterValue> emptyInputParams;\n    private static SaxonConfigurationFactory configFactory;\n\n    @Test\n    public void addValidProperties() throws InvalidSyntaxException {\n", "reference": "        output.setOutputProperty(\"byte-order-mark\", \"yes\");\n        output.setOutputProperty(\"byte-order-mark\", \"no\");\n        output.setOutputProperty(\"cdata-section-elements\", \"{fr:efl:inneo}pNonNum\");\n        output.setOutputProperty(\"doctype-public\", \"about:legacy-compat\");\n        output.setOutputProperty(\"doctype-system\", \"\");\n        output.setOutputProperty(\"encoding\", \"UTF-32\");\n        output.setOutputProperty(\"escape-uri-attributes\", \"yes\");\n        output.setOutputProperty(\"escape-uri-attributes\", \"no\");\n        output.setOutputProperty(\"include-content-type\", \"yes\");\n        output.setOutputProperty(\"include-content-type\", \"no\");\n        output.setOutputProperty(\"indent\", \"yes\");\n        output.setOutputProperty(\"indent\", \"no\");\n        output.setOutputProperty(\"media-type\",\"application/xml\");\n        output.setOutputProperty(\"method\", \"xml\");\n        output.setOutputProperty(\"method\", \"xhtml\");\n        output.setOutputProperty(\"method\", \"html\");\n        output.setOutputProperty(\"method\", \"text\");\n        output.setOutputProperty(\"normalization-form\", \"NFC\");\n        output.setOutputProperty(\"normalization-form\", \"NFD\");\n        output.setOutputProperty(\"normalization-form\", \"NFKC\");\n        output.setOutputProperty(\"normalization-form\", \"NFKD\");\n        output.setOutputProperty(\"normalization-form\", \"none\");\n        output.setOutputProperty(\"omit-xml-declaration\", \"yes\");\n        output.setOutputProperty(\"omit-xml-declaration\", \"no\");\n        output.setOutputProperty(\"saxon-attribute-order\", \"{}id\");\n        output.setOutputProperty(\"saxon-character-representation\", \"decimal\");\n        output.setOutputProperty(\"saxon-double-space\", \"{}docNiv\");\n        output.setOutputProperty(\"saxon-implicit-result-document\", \"ben, Je sais pas quoi mettre\");\n        output.setOutputProperty(\"saxon-indent-spaces\", \"4\");\n        output.setOutputProperty(\"saxon-line-length\", \"140\");\n        output.setOutputProperty(\"saxon-recognize-binary\", \"yes\");\n        output.setOutputProperty(\"saxon-recognize-binary\", \"no\");\n        output.setOutputProperty(\"saxon-suppress-inndentation\", \"{}pNonNum\");\n        output.setOutputProperty(\"standalone\", \"yes\");\n        output.setOutputProperty(\"standalone\", \"no\");\n        output.setOutputProperty(\"undeclare-prefixes\", \"#all\");\n        output.setOutputProperty(\"use-character-maps\", \"myCm,yourCm\");\n        output.setOutputProperty(\"version\",\"1.0\");\n        output.setOutputProperty(\"version\",\"1.1\");\n        // on veut juste pas d'exception\n        assertTrue(true);\n    }\n\n}", "prediction": "        output.setOutputProperty(\"foo\", \"bar\");\n        assertEquals(\"bar\", output.getOutputProperty(\"foo\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "58628767_0", "part": [1, 1], "seq": [1, 1], "prompt": "class ROdps {\n\n  public List<DataFrameItem> getTables(String projectName, String pattern) throws ROdpsException {\n    DataFrameItem<String> owner = new DataFrameItem<String>(\"owner\", \"string\");\n    DataFrameItem<String> tableName = new DataFrameItem<String>(\"table_name\", \"string\");\n    List<DataFrameItem> data = new ArrayList<DataFrameItem>();\n    data.add(owner);\n    data.add(tableName);\n\n    TableFilter filter = new TableFilter();\n    filter.setName(pattern);\n\n    for (Iterator<Table> it = odps.tables().iterator(projectName, filter); it.hasNext();) {\n      Table tb = it.next();\n      owner.getData().add(tb.getOwner());\n      tableName.getData().add(tb.getName());\n    }\n    return data;\n  }\n\n  public  ROdps(String projectName, String accessID, String accessKey, String endPoint,\n      String dtEndpoint, String logviewHost, String log4j_properties);\n\n  public void setBizId(String s);\n  public void set(String key, String value);\n  public void unset(String key);\n  public void writeTableFromDT(String projectName, String tableName, String partition,\n      String dataFilePathName, String columnDelimiter, String rowDelimiter, long recordCount,\n      int threadNumber);\n  public List<List<String>> loadTableFromDT(String projectName, String tableName, String partition,\n      String tempFile, String colDelimiter, String rowDelimiter, int limit, int threadNumber);\n  public boolean useProject(String projectName);\n  private Map<String, Schema> createSchema(String schemaJson, String type);\n  private Project getProjectObject(String projectName);\n  public String getProjectName(String projectName);\n  public long getTableSize(String projectName, String tableName, String partition);\n  public List<DataFrameItem> describeTable(String projectName, String tableName, String partition);\n  private String formatDateTime(Date date);\n  private DataFrameItem createSingleValueFrame(String name, String type, Object obj);\n  public boolean dropTable(String projectName, String tableName);\n  public boolean isTableExist(String projectName, String tableName, String partition);\n  public String getTableSchemaJson(String projectName, String tableName);\n  public int getIndexFromColName(String colName, String tableSchemaJson);\n  public List<String> runSqlTask(String sql);\n  private String getTableName(String projectName, String tableName);\n  public static String formatPartition(String part, String valueDim, String fieldDim);\n  private static LinkedHashMap<String, String> parsePartition(String part);\n  private static String partitionMap2String(Map<String, String> sepc, String valueDim,\n      String fieldDim);\n  public boolean setLogPath(String log_path);\n\n  final static String table;\n  static String file;\n  static ROdps rodps;\n\n}\n\nclass ROdpsTest  {\n\n  final static String table;\n  static String file;\n  static ROdps rodps;\n\n  @Test\n  public void testGetTablesList() throws ROdpsException, OdpsException {\n", "reference": "    List<DataFrameItem> ret = rodps.getTables(null, null);\n\n    for (DataFrameItem d : ret) {\n      List res = d.getData();\n      System.out.println(res);\n    }\n\n    assertNotNull(ret);\n    assertEquals(2, ret.size());\n    System.out.println(\"testN1GetTableList:\" + ret);\n  }\n\n}", "prediction": "    List<DataFrameItem> tables = rodps.getTables(\"test\", \".*\");\n    for (DataFrameItem item : tables) {\n      System.out.println(item.getName() + \" : \" + item.getData());\n    }\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "58892507_4", "part": [1, 1], "seq": [1, 1], "prompt": "class CoffeeHouse extends AbstractLoggingActor {\n\n    public static Props props(int caffeineLimit){\n        return Props.create(CoffeeHouse.class, () -> new CoffeeHouse(caffeineLimit));\n    }\n\n    public  CoffeeHouse(int caffeineLimit);\n\n    @Override public SupervisorStrategy supervisorStrategy();\n    private boolean coffeeApproved(ApproveCoffee approveCoffee);\n    private void addGuestToBookkeeper(ActorRef guest);\n    private void removeGuestFromBookkeeper(ActorRef guest);\n    protected ActorRef createBarista();\n    protected ActorRef createWaiter();\n    protected ActorRef createGuest(Coffee favoriteCoffee, int caffeineLimit);\n\n}\n\nclass CoffeeHouseTest extends AbstractLoggingActor {\n\n  @Test\n  public void shouldCreateChildActorCalledBaristaWhenCreated() {\n", "reference": "    new JavaTestKit(system) {{\n      system.actorOf(CoffeeHouse.props(Integer.MAX_VALUE), \"create-barista\");\n      expectActor(this, \"/user/create-barista/waiter\");\n    }};\n  }\n\n}", "prediction": "    CoffeeHouse coffeeHouse = new CoffeeHouse(100);\n    coffeeHouse.getContext().watch(coffeeHouse.getBarista());\n    coffeeHouse.getContext().watch(coffeeHouse.getWaiter());\n    coffeeHouse.getContext().watch(coffeeHouse.getGuest());\n    coffeeHouse.getContext().watch(coffeeHouse.getBookkeeper());\n    coffeeHouse.getContext().watch(coffeeHouse.getSupervisor());\n    coffeeHouse.getContext().watch(coffeeHouse.getSupervisorStrategy());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().watch(coffeeHouse.getSelf());\n    coffeeHouse.getContext().", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "59021106_12", "part": [1, 1], "seq": [1, 1], "prompt": "class Valor {\n\n    public final String getString() {\n        return string;\n    }\n\n    public  Valor(final String valor);\n    public  Valor(final float valor);\n    public  Valor(final boolean valor);\n    public  Valor(final LocalDate umaData);\n\n    public final boolean getBoolean();\n    public final float getReal();\n    public final LocalDate getData();\n    public static Valor dataFromString(final String data);\n    public byte getTipo();\n    @Override public String toString();\n    @Override public boolean equals(Object o);\n    @Override public int hashCode();\n\n}\n\nclass ValorTest {\n\n    @Test\n    public void umValorString() {\n", "reference": "        final String sequencia = \"sequ\u00eancia de caracteres\";\n        Valor verdadeiro = new Valor(sequencia);\n        assertEquals(sequencia, verdadeiro.getString());\n    }\n\n}", "prediction": "        final Valor valor = new Valor(\"teste\");\n        assertEquals(\"teste\", valor.getString());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "59118773_26", "part": [1, 1], "seq": [1, 1], "prompt": "class ClassFieldsExcelExport implements ClassFields {\n\n    @Override\n    public Iterator<Field> getFields() {\n        final Iterable<Field> originalFields = () -> this.original.getFields();\n\n        // return only classes that are annotated with @ExcelExport\n        final Iterator<Field> fields = StreamSupport.stream(originalFields.spliterator(), false)\n               .filter(field -> field.getAnnotation(ExcelExport.class)!= null)\n               .filter(this::filterByClass)\n               .iterator();\n\n        return fields;\n    }\n\n    public  ClassFieldsExcelExport(final ClassFields classFields);\n\n    private boolean filterByClass(final Field field);\n    @Override public Class getClazz();\n\n}\n\nclass ClassFieldsExcelExportTest {\n\n    @Test\n    public void getFields() throws Exception {\n", "reference": "        final String[] expectedFields = {\"id\", \"label\"};\n\n        final ClassFields classFields = new ClassFieldsExcelExport(\n                new ClassFieldsDefault(TestClass.class)\n        );\n        final Iterator<Field> fields = classFields.getFields();\n\n        final List<String> actualFields = new ArrayList<>();\n        while (fields.hasNext()) {\n            final Field f = fields.next();\n            actualFields.add(f.getName());\n        }\n\n        Assert.assertArrayEquals(\"Check declared @ExcelExport fields\", expectedFields, actualFields.toArray());\n    }\n\n}", "prediction": "        final ClassFieldsExcelExport classFieldsExcelExport = new ClassFieldsExcelExport(new ClassFieldsImpl(TestEntity.class));\n        final Iterator<Field> fields = classFieldsExcelExport.getFields();\n\n        assertThat(fields.hasNext()).isTrue();\n        assertThat(fields.next().getName()).isEqualTo(\"id\");\n        assertThat(fields.hasNext()).isTrue();\n        assertThat(fields.next().getName()).isEqualTo(\"name\");\n        assertThat(fields.hasNext()).isFalse();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "59952554_6", "part": [1, 1], "seq": [1, 1], "prompt": "class CreditCardTransaction {\n\n    public boolean isInWhiteList(String cardBin) {\n        return isWhiteListBinsAvailable() && creditCard.getWhitelistBins().contains(cardBin);\n    }\n\n    public  CreditCardTransaction();\n\n    public void setProperties(CreditCard creditCard, ArrayList<BankBinsResponse> bankBins);\n    private void init();\n    public boolean isWhiteListBinsAvailable();\n    public boolean isBlackListBinsAvailable();\n    public void setBlackListBinsAvailable(boolean blackListBinsAvailable);\n    public boolean isInstallmentAvailable();\n    public boolean isBankBinsAvailable();\n    public void setBankBins(ArrayList<BankBinsResponse> bankBins);\n    public ArrayList<Integer> getInstallmentTerms(String cardBin);\n    public String getBankByBin(String cardBin);\n    public String getBankByCardNumber(String cardNumber);\n    public boolean isMandiriCardDebit(String cardBin);\n    private BankBinsResponse getMandiriDebitResponse();\n    private String findBankByCardBin(BankBinsResponse savedBankBin, String cardBin);\n    private String findBankByCardNumber(BankBinsResponse savedBankBin, String cardNumber);\n    public Integer getInstallmentTerm(int currentPosition);\n    public void setInstallment(int termPosition);\n    public boolean isInstallmentValid();\n    public void setInstallmentAvailableStatus(boolean installmentStatus);\n    public int getInstallmentTermSelected();\n    public String getInstallmentBankSelected();\n    public void setBankPointStatus(boolean bniPointActivated);\n    public void setBankPoint(BanksPointResponse response, String bankType);\n    public String getBankName();\n    public boolean isBankPointEnabled();\n    public boolean isBankPointValid();\n    public float getBankPointRedeemed();\n    public void setBankPointRedeemed(float pointRedeemed);\n    public boolean checkCardBinValidity(String cardNumber);\n    private boolean isCardBinValid(String cardNumber);\n    private boolean isWhitelistBinContainCardNumber(String cardNumber);\n    public boolean isBlacklistContainCardNumber(String cardNumber);\n    public boolean isCardBinBlocked(String cardNumber);\n    public void setSelectedPromo(Promo seletedPromo);\n    public Promo getSelectedPromo();\n    public boolean isSelectedPromoAvailable();\n    public boolean isInstallmentOptionRequired();\n\n    private static final String BIN_VALID;\n    private static final String BIN_INVALID;\n    private static final String BANK_MANDIRI;\n    private static final String MANDIRI_BIN;\n    private static final String BANK_BNI;\n    private static final String BANK_OFFLINE;\n    private CreditCardTransaction cardTransaction;\n    private ArrayList<String> bankBins;\n    private CreditCard card;\n    private CreditCardInstallment cardInstallment;\n    private Installment installment;\n    private Map<String, ArrayList<Integer>> sampleTerms;\n\n}\n\nclass CreditCardTransactionTest {\n\n    private static final String BIN_VALID;\n    private static final String BIN_INVALID;\n    private static final String BANK_MANDIRI;\n    private static final String MANDIRI_BIN;\n    private static final String BANK_BNI;\n    private static final String BANK_OFFLINE;\n    private CreditCardTransaction cardTransaction;\n    private ArrayList<String> bankBins;\n    private CreditCard card;\n    private CreditCardInstallment cardInstallment;\n    private Installment installment;\n    private Map<String, ArrayList<Integer>> sampleTerms;\n\n    @Test\n    public void isInWhitlistbins_whenInvalid() {\n", "reference": "        assertFalse(cardTransaction.isInWhiteList(BIN_INVALID));\n    }\n\n}", "prediction": "        assertFalse(cardTransaction.isInWhiteList(BIN_INVALID));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "59970637_16", "part": [1, 1], "seq": [1, 1], "prompt": "class LocalOntology implements Ontology {\n\n  public Ontology getInstance() {\n    if (ontology == null) {\n      ontology = new LocalOntology();\n    }\n    return ontology;\n  }\n\n  public  LocalOntology();\n\n  @Override public void load();\n  @Override public void load(String[] urls);\n  private void load(Object m, String url);\n  public OntologyParser getParser();\n  public static OntModel getModel();\n  public List<String> getLoadedOntologyResources();\n  @Override public void merge(Ontology o);\n  @Override public Iterator<String> subclasses(String entitySearchTerm);\n  @Override public Iterator synonyms(String queryKeyPhrase);\n  public void addSearchTerm(String label, OntResource resource);\n  public Map<OntResource, String> retrieve(String label);\n  protected static void renderHierarchy(PrintStream out, OntClass cls, List<Object> occurs, int depth);\n  public static void renderClassDescription(PrintStream out, OntClass c, int depth);\n  protected static void renderRestriction(PrintStream out, Restriction r);\n  protected static void renderURI(PrintStream out, PrefixMapping prefixes, String uri);\n  protected static void renderAnonymous(PrintStream out, Resource anon, String name);\n  protected static void indent(PrintStream out, int depth);\n\n  private LocalOntology lOnt;\n\n}\n\nclass TestLocalOntology {\n\n  private LocalOntology lOnt;\n\n  @Test\n  public final void testGetInstance() {\n", "reference": "    assertSame(\"Ontology instance should be of type LocalOntology\", LocalOntology.class, lOnt.getInstance().getClass());\n  }\n\n}", "prediction": "    lOnt = LocalOntology.getInstance();\n    assertNotNull(lOnt);\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "59995075_0", "part": [1, 1], "seq": [1, 1], "prompt": "class Step6GraphTransitivityCleaner {\n\n    public static Set<Set<String>> mergeClusters(Set<Set<String>> equalClusters)\n    {\n        // create a new undirected graph\n        Graph graph = new DefaultGraph(\"CC Test\");\n        graph.setAutoCreate(true);\n        graph.setStrict(false);\n\n        // add all \"edges\"; for each pair from each cluster\n        for (Set<String> cluster : equalClusters) {\n            List<String> clusterList = new ArrayList<>(cluster);\n\n            for (int i = 0; i < clusterList.size(); i++) {\n                for (int j = i + 1; j < clusterList.size(); j++) {\n                    // edge name\n                    String iName = clusterList.get(i);\n                    String jName = clusterList.get(j);\n\n                    List<String> names = Arrays.asList(iName, jName);\n                    Collections.sort(names);\n                    String edgeName = StringUtils.join(names, \"_\");\n\n                    graph.addEdge(edgeName, iName, jName);\n                }\n            }\n        }\n\n        // compute connected components\n        ConnectedComponents cc = new ConnectedComponents();\n        cc.init(graph);\n\n        Set<Set<String>> result = new HashSet<>();\n\n        cc.setCountAttribute(\"cluster\");\n        cc.compute();\n\n        //        System.out.println(cc.getConnectedComponentsCount());\n\n        // re-create clusters from all connected components\n        for (ConnectedComponents.ConnectedComponent component : cc) {\n            Set<String> cluster = new HashSet<>();\n            for (Node n : component) {\n                cluster.add(n.getId());\n            }\n            result.add(cluster);\n        }\n\n        //        System.out.println(result);\n\n        return result;\n    }\n\n    public  Step6GraphTransitivityCleaner(ArgumentPairListSorter argumentPairListSorter,\n            boolean removeEqualEdgesParam);\n\n    public GraphCleaningResults processSingleFile(File file, File outputDir, String prefix,\n            Boolean collectGeneratedArgumentPairs);\n    public static Graph cleanCopyGraph(Graph graph);\n    private static DescriptiveStatistics computeTransitivityScores(Graph graph);\n    private static List<List<Object>> findCyclesInGraph(Graph graph);\n    protected static Set<Set<String>> buildEquivalencyClusters(\n            List<AnnotatedArgumentPair> argumentPairs);\n    public static Graph buildGraphFromArgumentPairs(List<AnnotatedArgumentPair> argumentPairs);\n    public static double computeEdgeWeight(AnnotatedArgumentPair annotatedArgumentPair,\n            double lambda);\n    @SuppressWarnings(\"unchecked\") public static void collectResults(String[] args);\n    @SuppressWarnings(\"unchecked\") public static void printResultStatistics(File xmlFile);\n    public static SortedMap<String, DescriptiveStatistics> collectStatisticsOverGraphCleaningResults(\n            Collection<GraphCleaningResults> results);\n    @SuppressWarnings(\"unchecked\") public static void main(String[] args);\n\n}\n\nclass Step6GraphTransitivityCleanerTest {\n\n    @Test\n    public void testMergeClusters()\n            throws Exception\n    {\n", "reference": "        Set<Set<String>> c1 = new HashSet<>();\n        c1.add(new HashSet<>(Arrays.asList(\"1\", \"2\")));\n        c1.add(new HashSet<>(Arrays.asList(\"3\", \"4\")));\n        Set<Set<String>> merged1 = Step6GraphTransitivityCleaner.mergeClusters(c1);\n        assertEquals(2, merged1.size());\n\n        Set<Set<String>> c2 = new HashSet<>();\n        c2.add(new HashSet<>(Arrays.asList(\"1\", \"2\")));\n        c2.add(new HashSet<>(Arrays.asList(\"3\", \"4\")));\n        c2.add(new HashSet<>(Arrays.asList(\"5\", \"4\")));\n\n        Set<Set<String>> merged2 = Step6GraphTransitivityCleaner.mergeClusters(c2);\n        assertEquals(2, merged2.size());\n\n        Set<Set<String>> c3 = new HashSet<>();\n        c3.add(new HashSet<>(Arrays.asList(\"1\", \"5\")));\n        c3.add(new HashSet<>(Arrays.asList(\"3\", \"4\")));\n        c3.add(new HashSet<>(Arrays.asList(\"5\", \"4\")));\n\n        Set<Set<String>> merged3 = Step6GraphTransitivityCleaner.mergeClusters(c3);\n        assertEquals(1, merged3.size());\n    }\n\n}", "prediction": "        Set<Set<String>> clusters = new HashSet<>();\n        clusters.add(new HashSet<>(Arrays.asList(\"a\", \"b\", \"c\")));\n        clusters.add(new HashSet<>(Arrays.asList(\"d\", \"e\", \"f\")));\n        clusters.add(new HashSet<>(Arrays.asList(\"g\", \"h\", \"i\")));\n\n        Set<Set<String>> result = Step6GraphTransitivityCleaner.mergeClusters(clusters);\n\n        assertEquals(1, result.size());\n        assertEquals(new HashSet<>(Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\")),\n                result.iterator().next());\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "60201162_10", "part": [1, 1], "seq": [1, 1], "prompt": "class KafkaClusterObserver implements Closeable {\n\n  public KafkaClusterObserver(String bootstrapServer) {\n    Properties properties = new Properties();\n    properties.setProperty(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServer);\n    properties.setProperty(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, String.valueOf(false));\n    properties.setProperty(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG,\n        DESERIALIZER_CLASS);\n    properties.setProperty(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG,\n        DESERIALIZER_CLASS);\n    this.kafkaConsumer = new KafkaConsumer(properties);\n  }\n\n  public  KafkaClusterObserver(String bootstrapServer);\n  @VisibleForTesting protected  KafkaClusterObserver(KafkaConsumer kafkaConsumer);\n\n  public Map<TopicPartition, Integer> findLeaderForPartitions(\n      List<TopicPartition> topicPartitions);\n  private Integer findLeaderId(TopicPartition topicPartition,\n      List<PartitionInfo> partitionInfoList);\n  @Override public void close();\n\n  private final KafkaConsumer kafkaConsumer;\n  private final KafkaClusterObserver observer;\n  private String testTopic1;\n  private final List<PartitionInfo> partitionInfo1;\n  private String testTopic2;\n  private final List<PartitionInfo> partitionInfo2;\n  private Map<TopicPartition, Integer> mockPartitionLeaderMap;\n\n}\n\nclass KafkaClusterObserverTest {\n\n  private final KafkaConsumer kafkaConsumer;\n  private final KafkaClusterObserver observer;\n  private String testTopic1;\n  private final List<PartitionInfo> partitionInfo1;\n  private String testTopic2;\n  private final List<PartitionInfo> partitionInfo2;\n  private Map<TopicPartition, Integer> mockPartitionLeaderMap;\n\n  @Test\n  public void testKafkaClusterObserver() {\n", "reference": "    EasyMock.reset(kafkaConsumer);\n\n    TopicPartition tp1 = new TopicPartition(testTopic1, 1);\n    TopicPartition tp2 = new TopicPartition(testTopic2, 1);\n    Map<String, List<PartitionInfo>> partitionInfoMap = new HashMap<>();\n    partitionInfoMap.put(testTopic1, partitionInfo1);\n    partitionInfoMap.put(testTopic2, partitionInfo2);\n\n    EasyMock.expect(kafkaConsumer.listTopics()).andReturn(partitionInfoMap);\n    EasyMock.replay(kafkaConsumer);\n\n    Map<TopicPartition, Integer> result =\n        observer.findLeaderForPartitions(ImmutableList.of(tp1, tp2));\n    Assert.assertEquals(result.get(tp1), Integer.valueOf(1));\n    Assert.assertEquals(result.get(tp2), Integer.valueOf(2));\n\n    EasyMock.verify(kafkaConsumer);\n  }\n\n}", "prediction": "    Map<TopicPartition, Integer> partitionLeaderMap = observer.findLeaderForPartitions(\n        Arrays.asList(new TopicPartition(testTopic1, 0),\n            new TopicPartition(testTopic1, 1),\n            new TopicPartition(testTopic2, 0),\n            new TopicPartition(testTopic2, 1)));\n    assertEquals(mockPartitionLeaderMap, partitionLeaderMap);\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "60940117_7", "part": [1, 1], "seq": [1, 1], "prompt": "class RedisScriptLoader {\n\n    Mono<StoredScript> storedScript() {\n        return Mono.defer(() -> {\n            Flux<String> source = this.storedScript.get();\n            return source.next().map(sha -> new StoredScript(sha, source));\n        });\n    }\n\n    public  RedisScriptLoader(RedisScriptingReactiveCommands<String, String> redisScriptingCommands, String scriptUri);\n    public  RedisScriptLoader(RedisScriptingReactiveCommands<String, String> redisScriptingCommands, String scriptUri, boolean eagerLoad);\n\n    @SuppressWarnings(\"PreferJavaTimeOverload\") private Flux<String> loadScript();\n    private String readScriptFile();\n\n    @RegisterExtension\n    static RedisStandaloneConnectionSetupExtension extension;\n\n}\n\nclass RedisScriptLoaderTest {\n\n    @RegisterExtension\n    static RedisStandaloneConnectionSetupExtension extension;\n\n    @Test\n    @DisplayName(\"should cache loaded sha\")\n    void shouldCache() {\n", "reference": "        RedisScriptLoader scriptLoader = new RedisScriptLoader(extension.getScriptingReactiveCommands(), \"hello-world.lua\");\n\n        assertThat(scriptLoader.storedScript().block(Duration.ofSeconds(5)).getSha()).isNotEmpty();\n\n        scriptFlush();\n\n        assertThat(scriptLoader.storedScript().block(Duration.ofSeconds(5)).getSha()).isNotEmpty();\n    }\n\n}", "prediction": "        RedisScriptLoader loader = new RedisScriptLoader(extension.getRedisScriptingCommands(), \"classpath:test/test.lua\");\n        Mono<StoredScript> script = loader.storedScript();\n        Mono<StoredScript> script2 = loader.storedScript();\n\n        StepVerifier.create(script)\n               .expectNextMatches(s -> s.getSha().equals(\"sha\"))\n               .verifyComplete();\n\n        StepVerifier.create(script2)\n               .expectNextMatches(s -> s.getSha().equals(\"sha\"))\n               .verifyComplete();\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "60958121_4", "part": [1, 1], "seq": [1, 1], "prompt": "class User {\n\n    public void login(final LoginInterface loginInterface) {\n        if (webService.isNetworkOffline()) {\n            loginInterface.onLoginFailed();\n            return;\n        }\n\n        Response response = new Response() {\n            @Override\n            public void onRequestCompleted(boolean isSuccess, String data) {\n                if (isSuccess) {\n                    loginInterface.onLoginSuccess();\n                } else {\n                    loginInterface.onLoginFailed();\n                }\n            }\n        };\n        webService.login(userId, password, response);\n    }\n\n    public  User(WebService webService, int userId, String password);\n\n    public void logout();\n    public void sendMessage(String message);\n    public void getMessages();\n\n    public static final int USER_ID;\n    public static final String PASSWORD;\n    @Rule\n    public MockitoRule mockitoRule;\n    @Mock\n    private WebService mockWebService;\n    @Mock\n    private LoginInterface mockLoginInterface;\n    @Captor\n    private ArgumentCaptor<Response> responseArgumentCaptor;\n\n}\n\nclass UserTest {\n\n    public static final int USER_ID;\n    public static final String PASSWORD;\n    @Rule\n    public MockitoRule mockitoRule;\n    @Mock\n    private WebService mockWebService;\n    @Mock\n    private LoginInterface mockLoginInterface;\n    @Captor\n    private ArgumentCaptor<Response> responseArgumentCaptor;\n\n    @Test\n    public void stubMethodAnswer() throws Exception {\n", "reference": "        User user = new User(mockWebService, USER_ID, PASSWORD);\n        when(mockWebService.isNetworkOffline()).then(new Answer<Boolean>() {\n            int index = 0;\n\n            @Override\n            public Boolean answer(InvocationOnMock invocation) throws Throwable {\n                return index++ % 2 == 0;\n            }\n        });\n\n        user.login(mockLoginInterface);\n        user.login(mockLoginInterface);\n        user.login(mockLoginInterface);\n\n        verify(mockWebService, times(1)).login(anyInt(), anyString(), any(Response.class));\n    }\n\n}", "prediction": "        User user = new User(mockWebService, USER_ID, PASSWORD);\n        user.login(mockLoginInterface);\n\n        verify(mockWebService).isNetworkOffline();\n        verify(mockWebService).login(USER_ID, PASSWORD, responseArgumentCaptor.capture());\n        verify(mockLoginInterface).onLoginSuccess();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "61158193_4", "part": [1, 1], "seq": [1, 1], "prompt": "class GenericDAO {\n\n    public void update(PK id, T model) {\n        try (Connection connection = connectionProvider.get()) {\n            Map<?,?> map = MAPPER.map(model);\n            Map<String,?> result = R.table(tableName).get(id).update(map).run(connection);\n\n            if (((Long) result.get(\"errors\")) > 0) {\n                throw new ReqlClientError(\"Failed to update model. %s\", ((String) result.get(\"first_error\")).split(\"\\n\")[0]);\n            }\n        }\n    }\n\n    public  GenericDAO(Provider<Connection> connection, Class<T> clazz, String tableName, String primaryKey);\n\n    protected void addIndex(boolean geo, String fields);\n    public void initTable();\n    public void create(T model);\n    public Optional<T> read(PK id);\n    public DAOIterator<T> read();\n    public DAOIterator<T> read(Function<Table, ReqlExpr> filter);\n    public void updateNonAtomic(PK id, T model);\n    public void delete(PK id);\n    public Observable<ChangeFeedElement<T>> changes();\n    @SuppressWarnings(\"unchecked\") public Observable<ChangeFeedElement<T>> changes(Function<Table, ReqlExpr> filter);\n    private boolean hasTable(Connection connection, String table);\n    private boolean hasIndex(Connection connection, String indexName);\n    private List indexFieldsToReQL(ReqlExpr row, String[] fields);\n    private ChangeFeedElement<T> mapChangeFeedElement(Map<?, Map<?,?>> map);\n\n    private static RethinkDB r;\n    private GenericDAO<TestModel, String> dao;\n\n}\n\nclass GenericDAOTest {\n\n    private static RethinkDB r;\n    private GenericDAO<TestModel, String> dao;\n\n    @Test\n    public void update() {\n", "reference": "        TestModel model = new TestModel(\"1\");\n        dao.create(model);\n\n        model.sub = new TestModel.SubModel();\n        model.sub.name = \"test\";\n        dao.update(model.id, model);\n\n        assertThat(dao.read(\"1\").get().sub.name).isEqualTo(model.sub.name);\n    }\n\n}", "prediction": "        TestModel model = new TestModel();\n        model.setId(\"1\");\n        model.setFoo(\"bar\");\n        dao.create(model);\n\n        model.setFoo(\"baz\");\n        dao.update(model.getId(), model);\n\n        Optional<TestModel> result = dao.read(model.getId());\n        assertTrue(result.isPresent());\n        assertEquals(\"baz\", result.get().getFoo());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "61247013_20", "part": [1, 1], "seq": [1, 1], "prompt": "class DoubleCondition extends BasicCondition<Double, DoubleCondition> implements FloatingPointChecks<Double, DoubleCondition> {\n\n\t@Override\n\tpublic DoubleCondition isGreaterThanOrEqual(Double number)\n\t{\n\t\trequire(this.subject).isNotNull();\n\t\trequire(number).isNotNull();\n\n\t\tif (!(Double.compare(this.subject, number) >= 0))\n\t\t{\n\t\t\tDbcAssertionError.throwNew(new IllegalArgumentException(\"Expected double <\" + this.subject + \"> to be greater than or equal to <\" + number + \">\"), this.message);\n\t\t}\n\n\t\treturn result();\n\t}\n\n\tpublic  DoubleCondition(Double subject);\n\n\t@Override public DoubleCondition isGreaterThan(Double number);\n\t@Override public DoubleCondition isLessThan(Double number);\n\t@Override public DoubleCondition isLessThanOrEqual(Double number);\n\t@Override public DoubleCondition isNear(Double floatingPointNumber);\n\t@Override public DoubleCondition isNearWithTolerance(Double floatingPointNumber, Double tolerance);\n\t@Override public DoubleCondition isNearZero();\n\t@Override public DoubleCondition isNearZeroWithTolerance(Double tolerance);\n\t@Deprecated @Override public DoubleCondition isEqualTo(Double toCompare);\n\n}\n\nclass DoubleConditionTest {\n\n\t@Test\n\tpublic void isGreaterThanOrEqual() throws Exception\n\t{\n", "reference": "\t\tDoubleCondition condition = new DoubleCondition(2.0D);\n\t\tcondition.isGreaterThanOrEqual(2D);\n\n\t\tassertThatThrownBy(() -> condition.isGreaterThanOrEqual(3D))\n\t\t\t\t.isInstanceOf(DbcAssertionError.class)\n\t\t\t\t.hasCauseInstanceOf(IllegalArgumentException.class);\n\t}\n\n}", "prediction": "\t\tDoubleCondition condition = new DoubleCondition(1.0);\n\t\tcondition.isGreaterThanOrEqual(1.0);\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "62253355_138", "part": [1, 1], "seq": [1, 1], "prompt": "class MergeRequestRest {\n\n    @GET\n    @Produces(MediaType.APPLICATION_JSON)\n    @RolesAllowed(\"user\")\n    @ApiOperation(\"Retrieves all MergeRequests in the application\")\n    public Response getMergeRequests(@QueryParam(\"sort\") String sort,\n                              @DefaultValue(\"false\") @QueryParam(\"ascending\") boolean asc,\n                              @DefaultValue(\"false\") @QueryParam(\"accepted\") boolean accepted) {\n        MergeRequestFilterParams.Builder builder = new MergeRequestFilterParams.Builder();\n        if (!StringUtils.isEmpty(sort)) {\n            builder.setSortBy(createIRI(sort, vf));\n        }\n        builder.setAscending(asc).setAccepted(accepted);\n        try {\n            JSONArray result = JSONArray.fromObject(manager.getMergeRequests(builder.build()).stream()\n                   .map(request -> modelToJsonld(request.getModel(), transformer))\n                   .map(RestUtils::getObjectFromJsonld)\n                   .collect(Collectors.toList()));\n            return Response.ok(result).build();\n        } catch (IllegalStateException | MobiException ex) {\n            throw ErrorUtils.sendError(ex, ex.getMessage(), Response.Status.INTERNAL_SERVER_ERROR);\n        }\n    }\n\n    @Reference void setManager(MergeRequestManager manager);\n    @Reference void setConfigProvider(CatalogConfigProvider configProvider);\n    @Reference void setTransformer(SesameTransformer transformer);\n    @Reference void setEngineManager(EngineManager engineManager);\n    @Reference void setMergeRequestFactory(MergeRequestFactory mergeRequestFactory);\n    @Reference void setCommentFactory(CommentFactory commentFactory);\n    @Reference void setVf(ValueFactory vf);\n    @POST @Produces(MediaType.TEXT_PLAIN) @Consumes(MediaType.MULTIPART_FORM_DATA) @RolesAllowed(\"user\") @ApiOperation(\"Creates a new MergeRequest in the application with the provided information\") public Response createMergeRequests(@Context ContainerRequestContext context,\n                                 @FormDataParam(\"title\") String title,\n                                 @FormDataParam(\"description\") String description,\n                                 @FormDataParam(\"recordId\") String recordId,\n                                 @FormDataParam(\"sourceBranchId\") String sourceBranchId,\n                                 @FormDataParam(\"targetBranchId\") String targetBranchId,\n                                 @FormDataParam(\"assignees\") List<FormDataBodyPart> assignees,\n                                 @FormDataParam(\"removeSource\") @DefaultValue(\"false\") boolean removeSource);\n    @GET @Path(\"{requestId}\") @Produces(MediaType.APPLICATION_JSON) @RolesAllowed(\"user\") @ApiOperation(\"Retrieves a MergeRequest from the application by its ID\") public Response getMergeRequest(@PathParam(\"requestId\") String requestId);\n    @PUT @Path(\"{requestId}\") @Consumes(MediaType.APPLICATION_JSON) @RolesAllowed(\"user\") @ApiOperation(\"Updates a MergeRequest by its ID using the provided JSON-LD\") public Response updateMergeRequest(@PathParam(\"requestId\") String requestId, String newMergeRequest);\n    @POST @Path(\"{requestId}\") @RolesAllowed(\"user\") @ApiOperation(\"Accepts a MergeRequest by performing the merge and changing the type\") @ActionId(Modify.TYPE) @ResourceId(type = ValueType.PROP_PATH, value = \"<\" + MergeRequest.onRecord_IRI + \">\", start = @Value(type = ValueType.PATH, value = \"requestId\")) @ActionAttributes(@AttributeValue(type = ValueType.PROP_PATH, value = \"<\" + MergeRequest.targetBranch_IRI + \">\", id = VersionedRDFRecord.branch_IRI, start = @Value(type = ValueType.PATH, value = \"requestId\"))) public Response acceptMergeRequest(@Context ContainerRequestContext context,\n                                @PathParam(\"requestId\") String requestId);\n    @DELETE @Path(\"{requestId}\") @RolesAllowed(\"user\") @ApiOperation(\"Deletes a MergeRequest that has the provided requestId\") public Response deleteMergeRequest(@PathParam(\"requestId\") String requestId);\n    @GET @Path(\"{requestId}/comments\") @Produces(MediaType.APPLICATION_JSON) @RolesAllowed(\"user\") @ApiOperation(\"Retrieves all Comment threads on a MergeRequest\") public Response getComments(@PathParam(\"requestId\") String requestId);\n    @GET @Path(\"{requestId}/comments/{commentId}\") @Produces(MediaType.APPLICATION_JSON) @RolesAllowed(\"user\") @ApiOperation(\"Retrieves a Comment from the application by its ID\") public Response getComment(@PathParam(\"requestId\") String requestId, @PathParam(\"commentId\") String commentId);\n    @POST @Path(\"{requestId}/comments\") @Consumes(MediaType.TEXT_PLAIN) @Produces(MediaType.TEXT_PLAIN) @RolesAllowed(\"user\") @ApiOperation(\"Creates a new Comment on the MergeRequest in the application with the provided information\") public Response createComment(@Context ContainerRequestContext context,\n                           @PathParam(\"requestId\") String requestId,\n                           @QueryParam(\"commentId\") String commentId,\n                           String commentStr);\n    @PUT @Path(\"{requestId}/comments/{commentId}\") @Consumes(MediaType.TEXT_PLAIN) @RolesAllowed(\"user\") @ApiOperation(\"Updates a Comment by its ID using the provided String\") public Response updateComment(@PathParam(\"commentId\") String commentId, String newCommentStr);\n    @DELETE @Path(\"{requestId}/comments/{commentId}\") @RolesAllowed(\"user\") @ApiOperation(\"Deletes a Comment that has the provided commentId\") public Response deleteComment(@Context ContainerRequestContext context,\n                           @PathParam(\"requestId\") String requestId,\n                           @PathParam(\"commentId\") String commentId);\n    private MergeRequest jsonToMergeRequest(Resource requestId, String jsonMergeRequest);\n    private Comment jsonToComment(Resource commentId, String jsonComment);\n\n    private MergeRequestRest rest;\n    private MergeRequestFactory mergeRequestFactory;\n    private CommentFactory commentFactory;\n    private UserFactory userFactory;\n    private ValueFactory vf;\n    private ModelFactory mf;\n    private ValueConverterRegistry vcr;\n    private MergeRequest request1;\n    private MergeRequest request2;\n    private Comment comment1;\n    private Comment comment2;\n    private Comment comment3;\n    private List<List<Comment>> commentChains;\n    private User user;\n    private final String CATALOG_IRI;\n    private final String RECORD_ID;\n    private final String BRANCH_ID;\n    private final String doesNotExist;\n    private final String invalidIRIString;\n    private final String commentText;\n    private final String updateCommentText;\n    private final String largeComment;\n    @Mock\n    private MergeRequestManager requestManager;\n    @Mock\n    private EngineManager engineManager;\n    @Mock\n    private SesameTransformer transformer;\n    @Mock\n    private CatalogConfigProvider configProvider;\n\n}\n\nclass MergeRequestRestTest  {\n\n    private MergeRequestRest rest;\n    private MergeRequestFactory mergeRequestFactory;\n    private CommentFactory commentFactory;\n    private UserFactory userFactory;\n    private ValueFactory vf;\n    private ModelFactory mf;\n    private ValueConverterRegistry vcr;\n    private MergeRequest request1;\n    private MergeRequest request2;\n    private Comment comment1;\n    private Comment comment2;\n    private Comment comment3;\n    private List<List<Comment>> commentChains;\n    private User user;\n    private final String CATALOG_IRI;\n    private final String RECORD_ID;\n    private final String BRANCH_ID;\n    private final String doesNotExist;\n    private final String invalidIRIString;\n    private final String commentText;\n    private final String updateCommentText;\n    private final String largeComment;\n    @Mock\n    private MergeRequestManager requestManager;\n    @Mock\n    private EngineManager engineManager;\n    @Mock\n    private SesameTransformer transformer;\n    @Mock\n    private CatalogConfigProvider configProvider;\n\n    @Test\n    public void getMergeRequestsWithErrorTest() {\n", "reference": "        // Setup\n        doThrow(new MobiException()).when(requestManager).getMergeRequests(any(MergeRequestFilterParams.class));\n\n        Response response = target().path(\"merge-requests\").request().get();\n        assertEquals(response.getStatus(), 500);\n        verify(requestManager).getMergeRequests(any(MergeRequestFilterParams.class));\n    }\n\n}", "prediction": "        when(requestManager.getMergeRequests(any(MergeRequestFilterParams.class))).thenThrow(new IllegalStateException(\"Test exception\"));\n        Response response = rest.getMergeRequests(null, false, false);\n        assertEquals(Response.Status.INTERNAL_SERVER_ERROR.getStatusCode(), response.getStatus());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "62342369_64", "part": [1, 1], "seq": [1, 1], "prompt": "class CustomExpectedStepParser implements StepParser<ExpectedStep> {\n\n\tprivate ParseContext parse(String expression) {\n\t\tExpectedStepLexer lexer = new ExpectedStepLexer(new ANTLRInputStream(expression));\n\t\tExpectedStepParser parser = new ExpectedStepParser(new CommonTokenStream(lexer));\n\t\tparser.addErrorListener(new BaseErrorListener() {\n\t        @Override\n\t        public void syntaxError(Recognizer<?,?> recognizer, Object offendingSymbol, int line, int charPositionInLine, String msg, RecognitionException e) {\n\t            throw new IllegalStateException(\"failed to parse at line \" + line + \" due to \" + msg, e);\n\t        }\n\t    });\n\t\treturn parser.parse();\n\t\t\n\t}\n\n\t@Override public int getParserScoreForStep(AbstractStep step);\n\t@Override public void parseStep(ParsingContext parsingContext, ExpectedStep step);\n\n}\n\nclass CustomExpectedStepParserTest  {\n\n\t@Test\n\tpublic void testMultipleSet() throws Exception {\n", "reference": "\t\tList<AbstractStep> steps = new ArrayList<>();\n\t\tsteps.add(step(\"Set a=\\\"b\\\"\\t c=\\\"d\\\"\"));\n\t\t\n\t\tList<AbstractArtefact> children = getChildren(parse(steps));\n\t\t\n\t\tSet set = (Set) children.get(0);\n\t\tAssert.assertEquals(\"a\",set.getKey().getValue());\n\t\tAssert.assertEquals(\"\\\"b\\\"\",set.getValue().getExpression());\n\t\t\n\t\tset = (Set) children.get(1);\n\t\tAssert.assertEquals(\"c\",set.getKey().getValue());\n\t\tAssert.assertEquals(\"\\\"d\\\"\",set.getValue().getExpression());\n\t}\n\n}", "prediction": "\t\tExpectedStepParser parser = new CustomExpectedStepParser();\n\t\tExpectedStep step = parser.parse(\"I set the field \\\"name\\\" to \\\"\\\"\");\n\t\tassertEquals(\"\", step.getArgument(\"name\"));\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "62700410_9", "part": [1, 1], "seq": [1, 1], "prompt": "class NativeImageLoader extends BaseImageLoader {\n\n    protected Mat centerCropIfNeeded(Mat img) {\n        int x = 0;\n        int y = 0;\n        int height = img.rows();\n        int width = img.cols();\n        int diff = Math.abs(width - height) / 2;\n\n        if (width > height) {\n            x = diff;\n            width = width - diff;\n        } else if (height > width) {\n            y = diff;\n            height = height - diff;\n        }\n        return img.apply(new Rect(x, y, width, height));\n    }\n\n    public  NativeImageLoader();\n    public  NativeImageLoader(int height, int width);\n    public  NativeImageLoader(int height, int width, int channels);\n    public  NativeImageLoader(int height, int width, int channels, boolean centerCropIfNeeded);\n    public  NativeImageLoader(int height, int width, int channels, ImageTransform imageTransform);\n    public  NativeImageLoader(int height, int width, int channels, MultiPageMode mode);\n    protected  NativeImageLoader(NativeImageLoader other);\n\n    @Override public String[] getAllowedFormats();\n    @Override public INDArray asRowVector(File f);\n    @Override public INDArray asRowVector(InputStream is);\n    public INDArray asRowVector(Object image);\n    public INDArray asRowVector(Frame image);\n    public INDArray asRowVector(Mat image);\n    static Mat convert(PIX pix);\n    @Override public INDArray asMatrix(File f);\n    @Override public INDArray asMatrix(InputStream is);\n    private Mat streamToMat(InputStream is);\n    @Override public Image asImageMatrix(File f);\n    @Override public Image asImageMatrix(InputStream is);\n    public INDArray asMatrix(Object image);\n    protected void fillNDArray(Mat image, INDArray ret);\n    public void asMatrixView(InputStream is, INDArray view);\n    public void asMatrixView(File f, INDArray view);\n    public void asMatrixView(Mat image, INDArray view);\n    public INDArray asMatrix(Frame image);\n    public INDArray asMatrix(Mat image);\n    protected INDArray transformImage(Mat image, INDArray ret);\n    protected Mat scalingIfNeed(Mat image);\n    protected Mat scalingIfNeed(Mat image, int dstHeight, int dstWidth);\n    public ImageWritable asWritable(File f);\n    public INDArray asMatrix(ImageWritable writable);\n    public Frame asFrame(INDArray array);\n    public Frame asFrame(INDArray array, int dataType);\n    public Mat asMat(INDArray array);\n    public Mat asMat(INDArray array, int dataType);\n    private INDArray asMatrix(BytePointer bytes, int length);\n\n    static final long seed;\n    static final Random rng;\n\n}\n\nclass TestNativeImageLoader {\n\n    static final long seed;\n    static final Random rng;\n\n    @Test\n    public void testCenterCropIfNeeded() throws Exception {\n", "reference": "        int w1 = 60, h1 = 110, ch1 = 1;\n        int w2 = 120, h2 = 70, ch2 = 3;\n\n        Mat img1 = makeRandomImage(h1, w1, ch1);\n        Mat img2 = makeRandomImage(h2, w2, ch2);\n\n        NativeImageLoader loader = new NativeImageLoader(h1, w1, ch1, true);\n\n        Mat cropped1 = loader.centerCropIfNeeded(img1);\n        assertEquals(85, cropped1.rows());\n        assertEquals(60, cropped1.cols());\n        assertEquals(img1.channels(), cropped1.channels());\n\n        Mat cropped2 = loader.centerCropIfNeeded(img2);\n        assertEquals(70, cropped2.rows());\n        assertEquals(95, cropped2.cols());\n        assertEquals(img2.channels(), cropped2.channels());\n    }\n\n}", "prediction": "        Mat img = new Mat(100, 100, CvType.CV_8UC3);\n        Mat cropped = NativeImageLoader.centerCropIfNeeded(img);\n        assertEquals(100, cropped.rows());\n        assertEquals(100, cropped.cols());\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "63002081_0", "part": [1, 1], "seq": [1, 1], "prompt": "class Preconditions {\n\n  public static void notNull(Object parameter) {\n    if (parameter == null) {\n      throw new IllegalArgumentException(\"parameter cannot be null\");\n    }\n  }\n\n  private  Preconditions();\n\n}\n\nclass PreconditionsTest {\n\n  @Test\n  public void whenNonNullParameterPassed_thenNothingHappens() {\n", "reference": "    Preconditions.notNull(new Object());\n  }\n\n}", "prediction": "    Preconditions.notNull(\"test\");\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "64247174_4", "part": [1, 1], "seq": [1, 1], "prompt": "class PostMessage extends UseCase<MessageDto, Void, MessageRepository> {\n\n    @Inject\n    public PostMessage(MessageRepository repository,\n                       Messenger messenger,\n                       @Named(\"Thread\") Scheduler threadScheduler,\n                       @Named(\"PostExecution\") Scheduler postExecutionScheduler) {\n        super(repository, messenger, threadScheduler, postExecutionScheduler);\n    }\n\n    @Inject public  PostMessage(MessageRepository repository,\n                       Messenger messenger,\n                       @Named(\"Thread\") Scheduler threadScheduler,\n                       @Named(\"PostExecution\") Scheduler postExecutionScheduler);\n\n    @Override protected Observable<Void> buildObservable(MessageDto messageDto);\n\n    private final MessageDto testMessage;\n\n}\n\nclass PostMessageTest extends UseCase<MessageDto, Void, MessageRepository> {\n\n    private final MessageDto testMessage;\n\n    @Test\n    @Override\n    public void testBuildUseCaseObservable() {\n", "reference": "        testBuildUseCaseObservable(testMessage, new Action0() {\n            @Override\n            public void call() {\n                verify(mockRepository).postMessage(testMessage, mockMessenger);\n            }\n        });\n    }\n\n}", "prediction": "        // Given an initialized PostMessage instance\n        PostMessage postMessage = new PostMessage(repository, messenger, threadScheduler, postExecutionScheduler);\n\n        // When the buildObservable method is called\n        Observable<Void> observable = postMessage.buildObservable(testMessage);\n\n        // Then the observable should be a PublishSubject\n        assertTrue(observable instanceof PublishSubject);\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "64692993_5", "part": [1, 1], "seq": [1, 1], "prompt": "class Calculator {\n\n    public double mul(double firstOperand, double secondOperand) {\n        return firstOperand * secondOperand;\n    }\n\n    public double add(double firstOperand, double secondOperand);\n    public double sub(double firstOperand, double secondOperand);\n    public double div(double firstOperand, double secondOperand);\n    public double pow(double firstOperand, double secondOperand);\n\n    private Calculator mCalculator;\n\n}\n\nclass CalculatorTest {\n\n    private Calculator mCalculator;\n\n    @Test\n  public void mulTwoNumbersZero() {\n", "reference": "    double resultMul = mCalculator.mul(2d, 0d);\n    assertThat(resultMul, is(equalTo(0d)));\n\n    }\n\n}", "prediction": "        double result = mCalculator.mul(0, 0);\n        assertEquals(0, result, 0);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "64733500_0", "part": [1, 1], "seq": [1, 1], "prompt": "class CloseableDriver implements AutoCloseable {\n\n    public Session newSession() {\n        return driver.session();\n    }\n\n    public  CloseableDriver(String uri, String user, String pwd);\n\n    @Override public void close();\n\n     CloseableDriver driver;\n\n}\n\nclass CloseableDriverTest {\n\n     CloseableDriver driver;\n\n    @Test\n    public void queryTest() throws Exception {\n", "reference": "        try (Session session = driver.newSession()) {\n            StatementResult result = session.run(\"MATCH (loan:Loan)-[:APPLY]-(person:Person)-[:OWN]-(appPhone:Phone)-[:CALL]-(callPhones:Phone) \" +\n                    \"where loan.loanId='12345' \" +\n                    \"return distinct loan,person,appPhone,callPhones\");\n\n            while (result.hasNext()) {\n                Record record = result.next();\n                Node loan = record.get(\"loan\").asNode();\n                Node person = record.get(\"person\").asNode();\n                Node appPhone = record.get(\"appPhone\").asNode();\n                Node callPhones = record.get(\"callPhones\").asNode();\n\n                System.out.println(loan.get(\"amount\").asDouble());\n                System.out.println(person.get(\"ssn\").asString());\n                System.out.println(appPhone.get(\"phoneNo\").asString());\n                System.out.println(callPhones.get(\"phoneNo\").asString());\n            }\n        }\n    }\n\n}", "prediction": "        Session session = driver.newSession();\n        session.run(\"MATCH (n) RETURN n LIMIT 10\");\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "64865857_0", "part": [1, 1], "seq": [1, 1], "prompt": "class MacAddress {\n\n\tpublic static MacAddress broadcast() {\n\t\tif (broadcast == null) {\n\t\t\tbyte[] pole = new byte[6];\n\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\tpole[i] = (byte) 255;\n\t\t\t}\n\t\t\tbroadcast = new MacAddress(pole);\n\t\t}\n\t\treturn broadcast;\n\t}\n\n\tpublic  MacAddress(String address);\n\tpublic  MacAddress(String address, char delimiter);\n\tpublic  MacAddress(byte[] representation);\n\n\t@Override public String toString();\n\tpublic String getCiscoRepresentation();\n\tpublic byte [] getByteArray();\n\t@Override public boolean equals(Object obj);\n\t@Override public int hashCode();\n\tpublic boolean isLessOrEqualThan(MacAddress other);\n\tprivate boolean isByteLessThan(MacAddress other, int cisloBytu);\n\tpublic static boolean isBroadcast(MacAddress mac);\n\tpublic static MacAddress getRandomMac();\n\tprivate static byte[] stringToBytes(String adr, char delimiter);\n\tprivate static byte stringToByte(String s);\n\tprivate static String byteToString(byte bajt);\n\n}\n\nclass MacAddressTest {\n\n     @Test\n     public void testBroadcast() {\n", "reference": "         MacAddress mac;\n         String sm;\n\n         sm=\"ff:ff:ff:ff:ff:ff\";\n         mac = new MacAddress(sm);\n         assertTrue(MacAddress.isBroadcast(mac));\n\n         sm=\"1a:4c:05:49:ad:f9\";\n         mac = new MacAddress(sm);\n         assertFalse(MacAddress.isBroadcast(mac));\n     }\n\n}", "prediction": "\tMacAddress mac = MacAddress.broadcast();\n\tassertEquals(\"FF:FF:FF:FF:FF:FF\", mac.toString());\n     }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "66055507_6", "part": [1, 1], "seq": [1, 1], "prompt": "class SimpleFactory {\n\n  @Updater\n  @Recycle\n  Simple simple(String appendix) throws IOException {\n    return new Simple(string, appendix);\n  }\n\n    SimpleFactory(String string);\n\n  private final SimpleFactory factory;\n  private final SimpleUpdaterFactory updaterFactory;\n\n}\n\nclass SimpleFactoryTest {\n\n  private final SimpleFactory factory;\n  private final SimpleUpdaterFactory updaterFactory;\n\n  @Test\n  public void simple() throws Exception {\n", "reference": "    SimpleFactory.Simple simple = factory.simple(\"b\");\n    SimpleFactoryBuilders.SimpleUpdater updater = updaterFactory.updater(simple);\n    SimpleFactory.Simple updatedSimple = updater\n        .appendix(\"c\")\n        .done();\n    assertThat(simple.concat(), is(\"ab\"));\n    assertThat(updatedSimple.concat(), is(\"ac\"));\n    // updater is recycled\n    assertTrue(updater\n        == updaterFactory.updater(factory.simple(\"x\")));\n  }\n\n}", "prediction": "    Simple simple = factory.simple(\"foo\");\n    assertThat(simple.string).isEqualTo(\"foo\");\n    assertThat(simple.appendix).isEqualTo(\"foo\");\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "66060256_0", "part": [1, 1], "seq": [1, 1], "prompt": "class Confetto {\n\n    protected static Long computeMillisToReachTarget(Float targetVelocity, float initialVelocity,\n            float acceleration) {\n        if (targetVelocity!= null) {\n            if (acceleration!= 0f) {\n                final long time = (long) ((targetVelocity - initialVelocity) / acceleration);\n                return time > 0? time : 0;\n            } else {\n                if (targetVelocity < initialVelocity) {\n                    return 0L;\n                } else {\n                    return null;\n                }\n            }\n        } else {\n            return null;\n        }\n    }\n\n    public void prepare(Rect bound);\n    private boolean doesLocationIntercept(float x, float y);\n    public boolean onTouchDown(MotionEvent event);\n    public void onTouchMove(MotionEvent event);\n    public void onTouchUp(MotionEvent event);\n    public abstract int getWidth();\n    public abstract int getHeight();\n    protected static long computeBound(float initialPos, float velocity, float acceleration,\n            Long targetTime, Float targetVelocity, int minBound, int maxBound);\n    public void reset();\n    protected void configurePaint(Paint paint);\n    public boolean applyUpdate(long passedTime);\n    private void computeDistance(float[] pair, long t, float xi, float vi, float ai, Long targetTime,\n                                 Float vTarget);\n    public void draw(Canvas canvas);\n    private void draw(Canvas canvas, float x, float y, float rotation, float percentageAnimated);\n    protected abstract void drawInternal(Canvas canvas, Matrix matrix, Paint paint, float x,\n            float y, float rotation, float percentAnimated);\n    public void setInitialDelay(long val);\n    public void setInitialX(float val);\n    public void setInitialY(float val);\n    public void setInitialVelocityX(float val);\n    public void setInitialVelocityY(float val);\n    public void setAccelerationX(float val);\n    public void setAccelerationY(float val);\n    public void setTargetVelocityX(Float val);\n    public void setTargetVelocityY(Float val);\n    public void setInitialRotation(float val);\n    public void setInitialRotationalVelocity(float val);\n    public void setRotationalAcceleration(float val);\n    public void setTargetRotationalVelocity(Float val);\n    public void setTTL(long val);\n    public void setFadeOut(Interpolator fadeOutInterpolator);\n\n}\n\nclass ConfettoTest {\n\n    @Test\n    public void test_computeMillisToReachTarget() {\n", "reference": "        Long time = Confetto.computeMillisToReachTarget(null, 0f, 0f);\n        assertNull(time);\n        time = Confetto.computeMillisToReachTarget(0f, 10f, 10f);\n        assertEquals(0, time.longValue());\n        time = Confetto.computeMillisToReachTarget(20f, 10f, 10f);\n        assertEquals(1, time.longValue());\n        time = Confetto.computeMillisToReachTarget(30f, 0f, 10f);\n        assertEquals(3, time.longValue());\n        time = Confetto.computeMillisToReachTarget(20f, 10f, 0f);\n        assertNull(time);\n    }\n\n}", "prediction": "        assertEquals(0L, Confetto.computeMillisToReachTarget(10f, 10f, 0f));\n        assertEquals(0L, Confetto.computeMillisToReachTarget(10f, 10f, 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "66076162_4", "part": [1, 1], "seq": [1, 1], "prompt": "class ErrorMessageFactory {\n\n  public static String create(Context context, Exception exception) {\n    String errorMessage = context.getString(R.string.exception_generic);\n\n    if (exception instanceof NoInternetConnectionException) {\n      errorMessage = context.getString(R.string.exception_no_internet_connection);\n    } else if (exception instanceof NoResponseException) {\n      errorMessage = context.getString(R.string.exception_no_response);\n    } else if (exception instanceof InvalidServerException) {\n      errorMessage = context.getString(R.string.exception_invalid_server);\n    } else if (exception.getMessage()!= null &&!exception.getMessage().isEmpty()) {\n      errorMessage = exception.getMessage();\n    }\n\n    return errorMessage;\n  }\n\n  private  ErrorMessageFactory();\n\n  @Mock private Context context;\n\n}\n\nclass ErrorMessageFactoryTest {\n\n  @Mock private Context context;\n\n  @Test\n  public void shouldReturnDefaultErrorMessageForInvalidServerException() throws Exception {\n", "reference": "    when(context.getString(R.string.exception_invalid_server)).thenReturn(\n        \"Invalid Server Default Error Message\");\n    InvalidServerException invalidServerException = new InvalidServerException();\n\n    String errorMessage = ErrorMessageFactory.create(context, invalidServerException);\n\n    verify(context, times(1)).getString(R.string.exception_invalid_server);\n    assertThat(errorMessage, notNullValue());\n    assertThat(errorMessage, is(\"Invalid Server Default Error Message\"));\n  }\n\n}", "prediction": "    String errorMessage = ErrorMessageFactory.create(context, new InvalidServerException());\n\n    assertThat(errorMessage).isEqualTo(\"Invalid server\");\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "66291451_3", "part": [1, 1], "seq": [1, 1], "prompt": "class MarkerBitmap {\n\n    public final Bitmap getBitmap(final boolean hasPhoto, final boolean ownPhoto, final boolean stationActive) {\n        if (ownPhoto) {\n            if (stationActive) {\n                return iconBmpOwnPhoto;\n            }\n            return iconBmpOwnPhotoInactive;\n        } else if (hasPhoto) {\n            if (stationActive) {\n                return iconBmpWithPhoto;\n            }\n            return iconBmpWithPhotoInactive;\n        }\n        if (stationActive) {\n            return iconBmpWithoutPhoto;\n        }\n        return iconBmpWithoutPhotoInactive;\n    }\n\n    public  MarkerBitmap(final Context context, final Bitmap srcWithoutPhoto, final Bitmap srcWithPhoto, final Bitmap srcOwnPhoto,\n                        final Bitmap srcWithoutPhotoInactive, final Bitmap srcWithPhotoInactive, final Bitmap srcOwnPhotoInactive,\n                        final Point grid, final float textSize, final int maxSize, final Paint paint);\n    public  MarkerBitmap(final Context context, final Bitmap bitmap, final Point grid, final float textSize, final int maxSize, final Paint paint);\n\n    public static Bitmap getBitmapFromTitle(final String title, final Paint paint);\n    protected static void clearCaptionBitmap();\n    public final Point getIconOffset();\n    public final float getTextSize();\n    public final int getItemMax();\n    public Paint getPaint();\n    public void decrementRefCounters();\n\n    private Bitmap srcWithoutPhoto;\n    private Bitmap srcWithPhoto;\n    private Bitmap srcOwnPhoto;\n    private Bitmap srcWithoutPhotoInactive;\n    private Bitmap srcWithPhotoInactive;\n    private Bitmap srcOwnPhotoInactive;\n    private MarkerBitmap markerBitmap;\n\n}\n\nclass MarkerBitmapTest {\n\n    private Bitmap srcWithoutPhoto;\n    private Bitmap srcWithPhoto;\n    private Bitmap srcOwnPhoto;\n    private Bitmap srcWithoutPhotoInactive;\n    private Bitmap srcWithPhotoInactive;\n    private Bitmap srcOwnPhotoInactive;\n    private MarkerBitmap markerBitmap;\n\n    @Test\n    public void getBitmap_PhotoInactive() {\n", "reference": "        Bitmap bitmap = markerBitmap.getBitmap(true, false, false);\n        assertEquals(srcWithPhotoInactive, bitmap);\n    }\n\n}", "prediction": "        final boolean hasPhoto = true;\n        final boolean ownPhoto = true;\n        final boolean stationActive = false;\n\n        final Bitmap bitmap = markerBitmap.getBitmap(hasPhoto, ownPhoto, stationActive);\n\n        assertEquals(srcOwnPhotoInactive, bitmap);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "67832483_6", "part": [1, 1], "seq": [1, 1], "prompt": "class Driver {\n\n    public static DriverBuilder builder() {\n        return new DriverBuilder();\n    }\n\n    @Deprecated  Driver();\n    private  Driver(String name, boolean license, int age, String email, List<Car> cars);\n\n    public void add(Car car);\n    @Override public String toString();\n\n    private static Validator validator;\n    private CurrencyUnit usd;\n    private Car ferrari;\n\n}\n\nclass DriverTest {\n\n    private static Validator validator;\n    private CurrencyUnit usd;\n    private Car ferrari;\n\n    @Test\n    public void shouldReturnErrorWhenDriverEmailIsInvalid() {\n", "reference": "\n        Driver driver = Driver.builder().withAge(25)\n                .withCars(Arrays.asList(ferrari))\n                .withEmail(\"emailemail\")\n                .withLicense(true)\n                .withName(\"Speed Racer\").build();\n\n        Set<ConstraintViolation<Driver>> validate = validator.validate(driver);\n        assertFalse(validate.isEmpty());\n        String message = validate.stream().findFirst()\n                .map(ConstraintViolation::getMessageTemplate)\n                .orElse(null);\n        assertEquals(\"Email should be valid\", message);\n    }\n\n}", "prediction": "        Driver driver = Driver.builder()\n               .name(\"\")\n               .license(true)\n               .age(30)\n               .email(\"invalid\")\n               .build();\n\n        assertThat(validator.validate(driver)).hasSize(1);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "67869571_3", "part": [1, 1], "seq": [1, 1], "prompt": "class Preference {\n\n    public Observable<T> asObservable() {\n        return values;\n    }\n\n      Preference(SharedPreferences preferences, final String key, T defValue, Proxy<T> proxy, Observable<String> keyChanges);\n\n    public T asValue();\n    public Action1<? super T> asAction();\n\n    private SharedPreferences preferences;\n    private RxSharedPreferences rxPreferences;\n\n}\n\nclass PreferenceTest {\n\n    private SharedPreferences preferences;\n    private RxSharedPreferences rxPreferences;\n\n    @Test\n    public void asObservable() {\n", "reference": "        Preference<String> preference = rxPreferences.getString(\"key1\", \"defValue\");\n\n        TestSubscriber<String> o = new TestSubscriber<>();\n        Subscription subscription = preference.asObservable().subscribe(o);\n        o.assertValues(\"defValue\");\n\n        rxPreferences.putString(\"key1\", \"value1\");\n        o.assertValues(\"defValue\", \"value1\");\n\n        rxPreferences.remove(\"key1\");\n        o.assertValues(\"defValue\", \"value1\", \"defValue\");\n\n        subscription.unsubscribe();\n        rxPreferences.putString(\"key1\", \"foo\");\n        o.assertValues(\"defValue\", \"value1\", \"defValue\");\n    }\n\n}", "prediction": "        Preference<String> preference = new Preference<>(preferences, \"key\", \"value\", new StringProxy(), Observable.empty());\n        preference.asObservable().subscribe(new Action1<String>() {\n            @Override\n            public void call(String s) {\n                assertEquals(\"value\", s);\n            }\n        });\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "67913797_5", "part": [1, 1], "seq": [1, 1], "prompt": "class StreamSchema implements Serializable {\n\n    public TypeInformation<T> getTypeInfo() {\n        return typeInfo;\n    }\n\n    public  StreamSchema(TypeInformation<T> typeInfo, String... fieldNames);\n    public  StreamSchema(TypeInformation<T> typeInfo, int[] fieldIndexes, String[] fieldNames);\n\n    public boolean isAtomicType();\n    public boolean isTupleType();\n    public boolean isRowType();\n    public boolean isPojoType();\n    public boolean isCaseClassType();\n    public boolean isCompositeType();\n    private int[] getFieldIndexes(TypeInformation<E> typeInfo, String... fieldNames);\n    private TypeInformation[] getFieldTypes(TypeInformation<E> typeInfo, int[] fieldIndexes, String[] fieldNames);\n    public int[] getFieldIndexes();\n    public String[] getFieldNames();\n    public TypeInformation[] getFieldTypes();\n    public StreamSerializer<T> getStreamSerializer();\n    public TypeSerializer<T> getTypeSerializer();\n    public void setTypeSerializer(TypeSerializer<T> typeSerializer);\n\n}\n\nclass StreamSchemaTest {\n\n    @Test\n    public void testStreamTupleSerializerWithPrimitive() {\n", "reference": "        TypeInformation<String> typeInfo = TypeInformation.of(new TypeHint<String>() {});\n        StreamSchema<String> schema = new StreamSchema<>(typeInfo, \"words\");\n        assertEquals(String.class, schema.getTypeInfo().getTypeClass());\n        TypeInformation<Tuple2<String, String>> tuple2TypeInformation = Types.TUPLE(TypeInformation.of(String.class), schema.getTypeInfo());\n        assertEquals(\"Java Tuple2<String, String>\", tuple2TypeInformation.toString());\n    }\n\n}", "prediction": "        StreamSchema<Tuple2<Integer, String>> schema = new StreamSchema<>(\n                TypeInformation.of(Tuple2.class),\n                \"f0\", \"f1\");\n        StreamSerializer<Tuple2<Integer, String>> serializer = schema.getStreamSerializer();\n        Tuple2<Integer, String> tuple = new Tuple2<>(1, \"hello\");\n        byte[] bytes = serializer.serialize(tuple);\n        Tuple2<Integer, String> deserialized = serializer.deserialize(bytes);\n        Assert.assertEquals(tuple, deserialized);\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "67999496_20", "part": [1, 1], "seq": [1, 1], "prompt": "class NodeExamples extends AbstractExamples {\n\n\tpublic NodeResponse getNodeResponseWithAllFields() {\n\t\tNodeResponse nodeResponse = new NodeResponse();\n\t\tnodeResponse.setUuid(NODE_DELOREAN_UUID);\n\t\tNodeReference parentNodeReference = new NodeReference();\n\t\tparentNodeReference.setUuid(NODE_ROOT_UUID);\n\t\tparentNodeReference.setDisplayName(\"parentNodeDisplayName\");\n\t\tnodeResponse.setParentNode(parentNodeReference);\n\t\tnodeResponse.setCreated(createOldTimestamp());\n\t\tnodeResponse.setEdited(createNewTimestamp());\n\t\tnodeResponse.setCreator(createUserReference());\n\t\tnodeResponse.setTags(Arrays.asList(new TagReference().setName(\"red\").setUuid(TAG_RED_UUID).setTagFamily(\"colors\")));\n\t\tnodeResponse.setPath(VersionHandler.CURRENT_API_BASE_PATH + \"/yourProject/webroot/Images\");\n\t\tMap<String, PublishStatusModel> languageInfo = new HashMap<>();\n\n\t\tlanguageInfo.put(\"de\", new PublishStatusModel().setVersion(\"1.0\").setPublished(true).setPublishDate(createOldTimestamp()).setPublisher(\n\t\t\tcreateUserReference()));\n\t\tlanguageInfo.put(\"en\", new PublishStatusModel().setVersion(\"1.1\").setPublished(false).setPublishDate(createOldTimestamp()).setPublisher(\n\t\t\tcreateUserReference()));\n\n\t\tnodeResponse.setAvailableLanguages(languageInfo);\n\t\tHashMap<String, String> languagePaths = new HashMap<>();\n\t\tlanguagePaths.put(\"en\", VersionHandler.CURRENT_API_BASE_PATH + \"/yourProject/webroot/Images\");\n\t\tlanguagePaths.put(\"de\", VersionHandler.CURRENT_API_BASE_PATH + \"/yourProject/webroot/Bilder\");\n\t\tnodeResponse.setLanguagePaths(languagePaths);\n\t\tnodeResponse.setChildrenInfo(new HashMap<>());\n\t\tnodeResponse.getChildrenInfo().put(\"blogpost\", new NodeChildrenInfo().setCount(1).setSchemaUuid(UUID_2));\n\t\tnodeResponse.getChildrenInfo().put(\"folder\", new NodeChildrenInfo().setCount(5).setSchemaUuid(UUID_3));\n\n\t\tFieldMap fields = new FieldMapImpl();\n\t\tfields.put(\"name\", createStringField(\"Name for language tag de-DE\"));\n\t\tfields.put(\"filename\", createStringField(\"dummy-content.de.html\"));\n\t\tfields.put(\"teaser\", createStringField(\"Dummy teaser for de-DE\"));\n\t\tfields.put(\"content\", createHtmlField(\"Content for language tag de-DE\"));\n\t\tfields.put(\"relatedProduct\", createNodeField(UUID_1));\n\t\tfields.put(\"price\", createNumberField(100.1));\n\t\tfields.put(\"enabled\", createBooleanField(true));\n\t\tfields.put(\"branch\", createDateField(createOldTimestamp()));\n\t\tfields.put(\"categories\", createNodeListField(UUID_4, UUID_5, UUID_6));\n\t\tfields.put(\"names\", createStringListField(\"Jack\", \"Joe\", \"Mary\", \"Tom\"));\n\t\tfields.put(\"categoryIds\", createNumberListField(1, 42, 133, 7));\n\t\tfields.put(\"binary\", createBinaryField());\n\t\tfields.put(\"location\", createMicronodeField(\"geolocation\", Tuple.tuple(\"latitude\", createNumberField(48.208330230278)), Tuple.tuple(\n\t\t\t\"longitude\", createNumberField(16.373063840833))));\n\t\tfields.put(\"locations\", createMicronodeListField(createMicronodeField(\"geolocation\", Tuple.tuple(\"latitude\", createNumberField(\n\t\t\t48.208330230278)), Tuple.tuple(\"longitude\", createNumberField(16.373063840833))), createMicronodeField(\"geolocation\", Tuple.tuple(\n\t\t\t\t\"latitude\", createNumberField(48.137222)), Tuple.tuple(\"longitude\", createNumberField(11.575556)))));\n\t\tnodeResponse.setFields(fields);\n\n\t\tnodeResponse.setSchema(getSchemaReference(\"content\"));\n\t\tnodeResponse.setPermissions(READ, UPDATE, DELETE, CREATE);\n\n\t\t// breadcrumb\n\t\tList<NodeReference> breadcrumb = new ArrayList<>();\n\t\t// breadcrumb.add(new NodeReferenceImpl().setDisplayName(\"/\").setPath(\"/\").setUuid(randomUUID()));\n\t\tbreadcrumb.add(new NodeReference().setDisplayName(\"news\").setPath(\"/news\").setUuid(NODE_DELOREAN_UUID));\n\t\tbreadcrumb.add(new NodeReference().setDisplayName(\"2015\").setPath(\"/automobiles/delorean-dmc-12\").setUuid(NODE_AUTOMOBILES_CATEGEORY_UUID));\n\t\tnodeResponse.setBreadcrumb(breadcrumb);\n\n\t\t// tags\n\t\tList<TagReference> tags = new ArrayList<>();\n\t\ttags.add(new TagReference().setName(\"red\").setUuid(TAG_RED_UUID).setTagFamily(\"colors\"));\n\t\ttags.add(new TagReference().setName(\"green\").setUuid(TAG_GREEN_UUID).setTagFamily(\"colors\"));\n\n\t\ttags.add(new TagReference().setName(\"car\").setUuid(UUID_1));\n\t\ttags.add(new TagReference().setName(\"ship\").setUuid(UUID_2));\n\t\tnodeResponse.setTags(tags);\n\n\t\treturn nodeResponse;\n\t}\n\n\tpublic static Field createBinaryField();\n\tpublic NavigationResponse getNavigationResponse();\n\tpublic NodeResponse getNodeResponse2();\n\tpublic NodeCreateRequest getNodeCreateRequest2();\n\tpublic NodeCreateRequest getNodeCreateRequest();\n\tpublic NodeUpdateRequest getNodeUpdateRequest2();\n\tpublic BinaryFieldTransformRequest getBinaryFieldTransformRequest();\n\tpublic NodeUpdateRequest getNodeUpdateRequest();\n\tpublic NodeListResponse getNodeListResponse();\n\tpublic Map<String, List<FormParameter>> getExampleBinaryUploadFormParameters();\n\tpublic NodeVersionsResponse createVersionsList();\n\n}\n\nclass NodeExamplesTest {\n\n\t@Test\n\tpublic void testNodeExample() {\n", "reference": "\t\tNodeResponse response = new NodeExamples().getNodeResponseWithAllFields();\n\t\tassertNotNull(response.getUuid());\n\t\tassertThat(response.getTags()).isNotEmpty();\n\t\tassertThat(response.getBreadcrumb()).isNotEmpty();\n\t\tassertNotNull(response.toJson());\n\t}\n\n}", "prediction": "\t\tNodeExamples nodeExamples = new NodeExamples();\n\t\tNodeResponse nodeResponse = nodeExamples.getNodeResponseWithAllFields();\n\t\tassertNotNull(nodeResponse);\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "69660791_9", "part": [1, 1], "seq": [1, 1], "prompt": "class Main {\n\n    public static boolean booleanExpression(boolean a, boolean b, boolean c, boolean d) {\n        return a & b & c & d;\n    }\n\n}\n\nclass MainTest {\n\n    @Test(timeout = 2000)\n    public void booleanExpression() throws Throwable {\n", "reference": "        Class<?> mainClass = TestUtils.getUserClass(\"Main\");\n        for (int i = 0; i < 16; i++) {\n            boolean a = (i % 2) == 1;\n            boolean b = ((i >> 1) % 2) == 1;\n            boolean c = ((i >> 2) % 2) == 1;\n            boolean d = ((i >> 3) % 2) == 1;\n\n            Class<Boolean> booleanClass = Boolean.TYPE;\n            Method booleanExpression = TestUtils.getMethod(mainClass,\n                    \"booleanExpression\",\n                    new int[]{Modifier.PUBLIC | Modifier.STATIC},\n                    booleanClass,\n                    booleanClass, booleanClass, booleanClass, booleanClass);\n\n            boolean actualValue = (boolean) TestUtils.invokeMethod(mainClass, booleanExpression, a, b, c, d);\n            boolean expectedValue = Integer.bitCount(i) == 2;\n\n            String message = String.format(\"Main.booleanExpression(%b, %b, %b, %b)\", a, b, c, d);\n            assertEquals(message, expectedValue, actualValue);\n        }\n    }\n\n}", "prediction": "        boolean a = true;\n        boolean b = true;\n        boolean c = true;\n        boolean d = true;\n        boolean result = Main.booleanExpression(a, b, c, d);\n        Assert.assertEquals(true, result);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "69711339_2", "part": [1, 1], "seq": [1, 1], "prompt": "class UserRegistration {\n\n    public void registerNewUser(String emailAddress) throws UserAlreadyRegisteredException, EmailFailedException {\n        if (database.hasUser(emailAddress)) {\n            throw new UserAlreadyRegisteredException();\n        }\n\n        if(!emailSender.sendRegistrationEmail(new RegistrationEmail(emailAddress))) {\n            throw new EmailFailedException();\n        }\n        database.addUser(emailAddress);\n    }\n\n    public  UserRegistration(Database database, EmailSender emailSender);\n\n    public void deleteUser(String emailAddress);\n\n    private UserRegistration testee;\n    private Database mockDatabase;\n    private EmailSender mockEmailSender;\n\n}\n\nclass UserRegistrationTest {\n\n    private UserRegistration testee;\n    private Database mockDatabase;\n    private EmailSender mockEmailSender;\n\n    @Test\n    public void shouldAddNewUserToDatabase() throws UserAlreadyRegisteredException, IOException {\n", "reference": "        UserRegistration testee = new UserRegistration(mockDatabase, mockEmailSender);\n\n        String emailAddress = \"foo@example.com\";\n        when(mockDatabase.hasUser(emailAddress)).thenReturn(false);\n\n        when(mockEmailSender\n                .sendRegistrationEmail(any(RegistrationEmail.class)))\n                .thenReturn(true);\n\n        testee.registerNewUser(emailAddress);\n        Mockito.verify(mockDatabase).addUser(emailAddress);\n    }\n\n}", "prediction": "        testee.registerNewUser(\"\");\n\n        verify(mockDatabase).addUser(\"\");\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "69858273_0", "part": [1, 1], "seq": [1, 1], "prompt": "class TimeBasedCache {\n\n    public V get(K key)\n    {\n        // optimistically try to get the key without locking\n        V value = _cache.get(key);\n        if (value == null && mayReload())\n        {\n            reloadCache();\n            value = _cache.get(key);\n        }\n\n        return value;\n    }\n\n    public  TimeBasedCache(Duration minTimeBetweenReloads, Supplier<ImmutableMap<K, V>> valuesSupplier);\n    public  TimeBasedCache(Duration minTimeBetweenReloads,\n                          Supplier<ImmutableMap<K, V>> valuesSupplier,\n                          ImmutableMap<K, V> initialCache,\n                          Clock clock);\n\n    private boolean mayReload();\n    public void clear();\n    private void reloadCache();\n    public Optional<Instant> getLastReloadInstant();\n    public Duration getMinTimeBetweenReloads();\n\n}\n\nclass TimeBasedCacheTest {\n\n    @Test\n    public void doesNotReloadCacheWithinTimeLimit()\n            throws Exception\n    {\n", "reference": "        // fake clock returns current time, then the same thing again,\n        // then 4 seconds later, then 8 seconds later.\n        Clock fakeClock = mock(Clock.class);\n        Instant now = Instant.now();\n        when(fakeClock.millis()).thenCallRealMethod();\n        when(fakeClock.instant()).thenReturn(\n                now, // get(\"0\") - first map loading\n                now, // cache asks when the latest loading happened\n                now.plus(Duration.ofSeconds(4)), // get(\"1\") - no reloading\n                // get(\"0\") - should not even ask about the time as entry was found\n                now.plus(Duration.ofSeconds(4)), // get(\"1\") - no reloading\n                now.plus(Duration.ofSeconds(8))); // get(\"1\") - reload\n\n        @SuppressWarnings(\"unchecked\")\n        Supplier<ImmutableMap> fakeSupplier = mock(Supplier.class);\n        when(fakeSupplier.get()).thenReturn(\n                ImmutableMap.of(\"0\", 0),\n                ImmutableMap.of(\"1\", 1));\n\n        // the map will always contain a single entry with the number of reloads as in\n        // (\"reloads\" -> reloads)\n        AtomicInteger reloads = new AtomicInteger(0);\n\n        TimeBasedCache<String, Integer> cache = new TimeBasedCache<>(Duration.ofSeconds(5),\n                () -> ImmutableMap.copyOf(ImmutableMap.of(Integer.toString(reloads.get()),\n                        reloads.getAndIncrement())),\n                ImmutableMap.of(), fakeClock);\n\n        // should have only (\"0\" -> 0) in the map in the beginning\n        assertNotNull(cache.get(\"0\"));\n        assertNull(cache.get(\"1\"));\n\n        // second time we try, the map should not reload\n        assertNotNull(cache.get(\"0\"));\n        assertNull(cache.get(\"1\"));\n\n        // when the first reload happens, the cache contains (\"1\" -> 1)\n        assertNotNull(cache.get(\"1\"));\n        assertNull(cache.get(\"0\"));\n    }\n\n}", "prediction": "        TimeBasedCache<String, String> cache = new TimeBasedCache<>(Duration.ofSeconds(1), () -> ImmutableMap.of(\"foo\", \"bar\"), ImmutableMap.of(), Clock.systemUTC());\n\n        cache.get(\"foo\");\n        cache.get(\"foo\");\n\n        assertThat(cache.getLastReloadInstant()).isPresent();\n\n        Thread.sleep(1000);\n\n        cache.get(\"foo\");\n\n        assertThat(cache.getLastReloadInstant()).isPresent();\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "69946649_0", "part": [1, 1], "seq": [1, 1], "prompt": "class RegexContainer {\n\n    static <T> Optional<RegexContainer<T>> checkAndCreate(String maybeRegex, T content) {\n        if (maybeRegex.startsWith(\"/\") && maybeRegex.endsWith(\"/\")) {\n            try {\n                Pattern regex = Pattern.compile(maybeRegex.substring(1, maybeRegex.length() - 1));\n                return Optional.of(new RegexContainer<>(regex, content));\n            } catch (PatternSyntaxException e) {\n                return Optional.empty();\n            }\n        }\n        return Optional.empty();\n    }\n\n      RegexContainer(Pattern regex, T content);\n\n     Optional<T> match(String metricName);\n\n}\n\nclass RegexContainerTest {\n\n    @Test\n    public void shouldCheckAndNotCreate() throws Exception {\n", "reference": "        Optional<RegexContainer<Map<String, String>>> result = RegexContainer\n                .checkAndCreate(\"/{}won't compile/\", Collections.singletonMap(\"k\", \"v\"));\n        assertThat(result).isEmpty();\n    }\n\n}", "prediction": "        Optional<RegexContainer<String>> container = RegexContainer.checkAndCreate(\"foo\", \"bar\");\n        assertFalse(container.isPresent());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "70932660_4", "part": [1, 1], "seq": [1, 1], "prompt": "class NvaMonitor implements AutoCloseable {\n\n    public synchronized Future<Void> start() throws NvaMonitorException {\n        //log.debug(\"executorService.isShutdown(): \" + executorService.isShutdown());\n        //Preconditions.checkState(!executorService.isShutdown(), \"Already started\");\n        Preconditions.checkState(!this.isRunning, \"Already started\");\n        // We need to eventually support multiple monitors, but for now, just grab the\n        // first one.\n        MonitorConfiguration monitorConfiguration =\n            this.configuration.getMonitors().get(0);\n        Callable<Void> monitor = createMonitorCallable(monitorConfiguration);\n        isRunning = true;\n        Future<Void> task = executorService.submit(\n            monitor\n        );\n\n        return task;\n    }\n\n    public  NvaMonitor(DaemonConfiguration configuration);\n\n    @SuppressWarnings(\"unchecked\") private Callable<Void> createMonitorCallable(MonitorConfiguration monitorConfiguration);\n    public synchronized void stop();\n    @Override public synchronized void close();\n\n}\n\nclass NvaMonitorTest {\n\n    @Test\n    void testAbstractMonitor() {\n", "reference": "        List<MonitorConfiguration> monitors = new ArrayList<>();\n        monitors.add(\n            new MonitorConfiguration(\n                \"com.microsoft.azure.practices.nvadaemon.NvaMonitorTest$AbstractMonitor\",\n                null));\n        DaemonConfiguration daemonConfiguration = new DaemonConfiguration(monitors, null);\n        NvaMonitor nvaMonitor = new NvaMonitor(daemonConfiguration);\n        Assertions.assertThrows(NvaMonitor.NvaMonitorException.class,\n            () -> nvaMonitor.start());\n    }\n\n}", "prediction": "        MonitorConfiguration monitorConfiguration = new MonitorConfiguration();\n        monitorConfiguration.setMonitorClass(AbstractMonitor.class);\n        monitorConfiguration.setMonitorName(\"test\");\n        monitorConfiguration.setMonitorType(MonitorType.JVM);\n        monitorConfiguration.setMonitorInterval(1000);\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties(new HashMap<>());\n        monitorConfiguration.setMonitorProperties", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "70996010_18", "part": [1, 1], "seq": [1, 1], "prompt": "class RuleDatabaseUpdateTask extends AsyncTask<Void, Void, Void> {\n\n    void releaseGarbagePermissions() {\n        ContentResolver contentResolver = context.getContentResolver();\n        for (UriPermission permission : contentResolver.getPersistedUriPermissions()) {\n            if (isGarbage(permission.getUri())) {\n                Log.i(TAG, \"releaseGarbagePermissions: Releasing permission for \" + permission.getUri());\n                contentResolver.releasePersistableUriPermission(permission.getUri(), Intent.FLAG_GRANT_READ_URI_PERMISSION);\n            } else {\n                Log.v(TAG, \"releaseGarbagePermissions: Keeping permission for \" + permission.getUri());\n            }\n        }\n    }\n\n    public  RuleDatabaseUpdateTask(Context context, Configuration configuration, boolean notifications);\n\n    private void setupNotificationBuilder();\n    @Override protected Void doInBackground(final Void... configurations);\n    private boolean isGarbage(Uri uri);\n    @NonNull RuleDatabaseItemUpdateRunnable getCommand(Configuration.Item item);\n    private synchronized void updateProgressNotification();\n    private synchronized void postExecute();\n    synchronized void addError(Configuration.Item item, String message);\n    synchronized void addDone(Configuration.Item item);\n    synchronized void addBegin(Configuration.Item item);\n    synchronized long pendingCount();\n\n     HashMap<String, Uri> uriLocations;\n\n}\n\nclass RuleDatabaseUpdateTaskTest {\n\n     HashMap<String, Uri> uriLocations;\n\n    @Test\n    public void testReleaseGarbagePermissions() throws Exception {\n", "reference": "        Context mockContext = mock(Context.class);\n        ContentResolver mockResolver = mock(ContentResolver.class);\n        when(mockContext.getContentResolver()).thenReturn(mockResolver);\n\n        final List<UriPermission> persistedPermissions = new LinkedList<>();\n        when(mockResolver.getPersistedUriPermissions()).thenReturn(persistedPermissions);\n\n        UriPermission usedPermission = mock(UriPermission.class);\n        when(usedPermission.getUri()).thenReturn(newUri(\"content://used\"));\n        persistedPermissions.add(usedPermission);\n\n        UriPermission garbagePermission = mock(UriPermission.class);\n        when(garbagePermission.getUri()).thenReturn(newUri(\"content://garbage\"));\n        persistedPermissions.add(garbagePermission);\n\n        doAnswer(new Answer<Void>() {\n            @Override\n            public Void answer(InvocationOnMock invocation) throws Throwable {\n                Iterator<UriPermission> iter = persistedPermissions.iterator();\n                while (iter.hasNext()) {\n                    UriPermission perm = iter.next();\n                    if (perm.getUri() == invocation.getArgumentAt(0, Uri.class))\n                        iter.remove();\n                }\n                return null;\n            }\n        }).when(mockResolver, \"releasePersistableUriPermission\", any(Uri.class), anyInt());\n\n        Configuration configuration = new Configuration();\n        configuration.hosts.items.add(newItemForLocation(\"content://used\"));\n\n        assertTrue(persistedPermissions.contains(usedPermission));\n        assertTrue(persistedPermissions.contains(garbagePermission));\n\n        new RuleDatabaseUpdateTask(mockContext, configuration, false).releaseGarbagePermissions();\n\n        assertTrue(persistedPermissions.contains(usedPermission));\n        assertFalse(persistedPermissions.contains(garbagePermission));\n    }\n\n}", "prediction": "        RuleDatabaseUpdateTask task = new RuleDatabaseUpdateTask(context, configuration, false);\n        task.uriLocations = uriLocations;\n        task.releaseGarbagePermissions();\n        verify(context.getContentResolver()).releasePersistableUriPermission(uriLocations.get(\"garbage\"), Intent.FLAG_GRANT_READ_URI_PERMISSION);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "71089550_3", "part": [1, 1], "seq": [1, 1], "prompt": "class Types {\n\n\tpublic static boolean isSubtype(Type subType, Type superType) {\n\t    if (Types.isEqual(subType, superType)) return true;\n\t    if (subType instanceof IntegerType && superType instanceof FloatType) {\n\t        return true;\n\t    }\n\t    if (superType instanceof TopReferenceType && isRefType(subType)) {\n\t        return true;\n\t    }\n\t    if (subType instanceof BottomReferenceType && isRefType(superType)) {\n\t        return true;\n\t    }\n\t    if (subType instanceof ObjectType && superType instanceof ObjectType) {\n\t        // NOTE: this only handles concrete types and does not reason about MRO/MRW\n\t        ObjectType subObjType = (ObjectType) subType;\n\t        List<Property> superTypeProps = ((ObjectType)superType).properties();\n\t        // each super type property should be present in the subtype with (1) the same\n\t        // type and (2) an equally strong or stronger read-write permission\n\t        for (Property superProp: superTypeProps) {\n\t            if (!subObjType.hasProperty(superProp.getName())) {\n\t                return false;\n\t            }\n\t            Property subProp = subObjType.getProperty(superProp.getName());\n\t            if (!Types.isEqual(superProp.getType(), subProp.getType())) {\n\t                return false;\n\t            }\n\t            if (superProp.isRW() &&!subProp.isRW()) { // permissions weakened\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t    return false;\n\t}\n\n\tpublic static boolean isEqual(Type type1, Type type2);\n\tprivate static boolean isEqualHelper(Type type1, Type type2, Set<Pair<Type, Type>> queried);\n\tprivate static boolean isContainedIn(List<Type> types, Type type);\n\tprivate static boolean isContainedIn(List<Type> types1, List<Type> types2);\n\tpublic static Type mkArray(Type celltype);\n\tpublic static Type mkMap(Type celltype);\n\tpublic static ConstructorType mkCtor(List<Type> paramTypes, List<String> paramNames, Type returnType, Type proto);\n\tpublic static FunctionType mkFunc(Type ret, List<Type> paramty);\n\tpublic static FunctionType mkFunc(Type ret, List<Type> paramty, List<String> params);\n\tpublic static boolean isStringType(Type targetType);\n\tpublic static boolean isArrayType(Type targetType);\n\tpublic static boolean isMapType(Type type);\n\tpublic static Type mkAny();\n\tpublic static Type mkVoid();\n\tpublic static FloatType mkFloat();\n\tpublic static StringType mkString();\n\tpublic static BooleanType mkBool();\n\tpublic static IntegerType mkInt();\n\tpublic static Property mkProperty(final String name, final Type ty);\n\tpublic static AttachedMethodType mkMethod(final Type thistype, final Type ret, List<Type> pty);\n\tpublic static AttachedMethodType mkMethod(final Type thistype, final Type ret, Type... args);\n\tpublic static AttachedMethodType mkMethod(Type thistype, Type ret, List<String> pnames, List<Type> pty);\n\tpublic static ObjectType mkObject(List<Property> props);\n\tpublic static Type mkMapIteratorType(Type t);\n\tpublic static boolean isComponentOf(Type type, IntersectionType iType);\n\tpublic static boolean isRefType(Type t);\n\tpublic static boolean usableAsConstructor(Type t);\n\tpublic static boolean isSubtypeish(Type subType, Type superType);\n\tpublic static Type coarseUpperBound(Type t1, Type t2);\n\tpublic static Type coarseLowerBound(Type t1, Type t2);\n\tpublic static Type lowestSubtype(Type t);\n\n}\n\nclass TypesTest {\n\n    @Test\n    public void testRecursiveSubtype() {\n", "reference": "        ObjectType o1 = new ObjectType();\n        o1.setProperty(\"f\", o1);\n        ObjectType o2 = new ObjectType();\n        o2.setProperty(\"f\", o2);\n        Assert.assertTrue(Types.isSubtype(o1, o2));\n\n        FunctionType f1 = new FunctionType(oneElementArrayList(null), oneElementArrayList(\"1\"), new VoidType());\n        f1.setParamType(f1, 0);\n        FunctionType f2 = new FunctionType(oneElementArrayList(null), oneElementArrayList(\"1\"), new VoidType());\n        f2.setParamType(f2, 0);\n        Assert.assertTrue(Types.isSubtype(f1, f2));\n    }\n\n}", "prediction": "\tType t1 = Types.mkObject(Arrays.asList(Types.mkProperty(\"a\", Types.mkObject(Arrays.asList(Types.mkProperty(\"b\", Types.mkInt()))))));\n\tType t2 = Types.mkObject(Arrays.asList(Types.mkProperty(\"a\", Types.mkObject(Arrays.asList(Types.mkProperty(\"b\", Types.mkInt()))))));\n\tassertTrue(Types.isSubtype(t1, t2));\n\tassertTrue(Types.isSubtype(t2, t1));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "71127071_0", "part": [1, 1], "seq": [1, 1], "prompt": "class ZwitscherController {\n\n    @RequestMapping(method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_UTF8_VALUE)\n    public HttpEntity<Collection<String>> tweets(@RequestParam(value = \"q\", required = false) String q) {\n        Collection<String> tweets = repository.search(ofNullable(q).orElse(query), pageSize);\n        return new ResponseEntity<>(tweets, HttpStatus.OK);\n    }\n\n    @Autowired public  ZwitscherController(ZwitscherRepository repository);\n\n    @Value(\"${tweet.query:cloudnativenerd}\") public void setQuery(String query);\n    @Value(\"${tweet.pageSize:42}\") public void setPageSize(int pageSize);\n\n}\n\nclass ZwitscherControllerTest {\n\n    @Test\n    public void tweets() throws Exception {\n", "reference": "        ZwitscherRepository repository = mock(ZwitscherRepository.class);\n        ZwitscherController controller = new ZwitscherController(repository);\n        controller.setQuery(\"cloudnativenerd\");\n        controller.setPageSize(42);\n\n        when(repository.search(\"cloudnativenerd\", 42)).thenReturn(Collections.singleton(\"Hello Test.\"));\n\n        HttpEntity<Collection<String>> tweets = controller.tweets(null);\n        assertFalse(tweets.getBody().isEmpty());\n    }\n\n}", "prediction": "        ZwitscherController controller = new ZwitscherController(mock(ZwitscherRepository.class));\n        ResponseEntity<Collection<String>> response = controller.tweets(\"cloudnativenerd\");\n        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);\n        assertThat(response.getBody()).hasSize(42);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "71972621_23", "part": [1, 1], "seq": [1, 1], "prompt": "class GlobalPropertyResource {\n\n    @DELETE\n    @Timed\n    @UnitOfWork\n    @Path(\"{id}\")\n    @ApiOperation(value = \"Soft delete\")\n    public Response delete(@PathParam(\"id\") final int id) {\n        service.delete(id);\n        return Response.ok().build();\n    }\n\n    @POST @Consumes(MediaType.APPLICATION_JSON) @Timed @UnitOfWork @ApiOperation(value = \"Save global property\", response = GlobalPropertyDomain.class) public Response save(@NotNull @Valid final GlobalPropertyDomain globalProperty);\n    @GET @Timed @UnitOfWork(transactional = false) @Path(\"{id}\") @ApiOperation(value = \"Get global property by id\", response = GlobalPropertyDomain.class) public Response get(@PathParam(\"id\") final int id);\n    @GET @Timed @UnitOfWork(transactional = false) @ApiOperation(value = \"Search global property based on name, param\", response = Set.class) public Response search(@QueryParam(\"name\") final String name, @QueryParam(\"type\") final String propertyType);\n\n    private static IGlobalPropertyService service;\n    private static GlobalPropertyDomain globalProperty;\n    private static GlobalPropertyResource resource;\n\n}\n\nclass GlobalPropertyResourceTest {\n\n    private static IGlobalPropertyService service;\n    private static GlobalPropertyDomain globalProperty;\n    private static GlobalPropertyResource resource;\n\n    @Test\n    public void testDeleteById() {\n", "reference": "        doNothing().when(service).delete(anyInt());\n\n        final Response response = resource.delete(globalProperty.getId());\n        Assert.assertEquals(response.getStatus(), 200);\n    }\n\n}", "prediction": "        resource.delete(globalProperty.getId());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "72159384_0", "part": [1, 1], "seq": [1, 1], "prompt": "class ConsumerRecordRelay implements Runnable {\n\n    void stop() {\n        logger.info(\"Stopping Kafka message relay\");\n        stopped = true;\n    }\n\n    public  ConsumerRecordRelay(Consumer<K, V> consumer, BlockingQueueConsumer<K, V> blockingQueueConsumer);\n\n    @Override public void run();\n    public void setOffset(ConsumerRecord<K, V> record);\n    public void removePartitionFromOffset(TopicPartition topicPartition);\n    private void commitOffsets();\n    private void callback(Map<TopicPartition, OffsetAndMetadata> offset, Exception ex);\n\n    @Mock\n    private Consumer<Integer, String> consumer;\n    @Mock\n    private BlockingQueueConsumer<Integer, String> blockingQueueConsumer;\n    private ConsumerRecord<Integer, String> record;\n\n}\n\nclass ConsumerRecordRelayTest {\n\n    @Mock\n    private Consumer<Integer, String> consumer;\n    @Mock\n    private BlockingQueueConsumer<Integer, String> blockingQueueConsumer;\n    private ConsumerRecord<Integer, String> record;\n\n    @Test\n    public void relayWithException() throws Exception {\n", "reference": "        when(consumer.poll(anyLong())).thenThrow(RuntimeException.class);\n\n        ConsumerRecordRelay<Integer, String> relay = new ConsumerRecordRelay<>(consumer, blockingQueueConsumer);\n        new Thread(relay).start();\n        verify(blockingQueueConsumer, never()).relay(record);\n        verify(consumer, timeout(1000).only()).poll(anyLong());\n        relay.stop();\n    }\n\n}", "prediction": "        ConsumerRecordRelay consumerRecordRelay = new ConsumerRecordRelay(consumer, blockingQueueConsumer);\n        consumerRecordRelay.setOffset(record);\n        consumerRecordRelay.stop();\n\n        verify(consumer).commitAsync(any(Map.class), any(Consumer.class));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "72189814_155", "part": [1, 1], "seq": [1, 1], "prompt": "class HaloNetClient {\n\n    @Api(2.0)\n    public Response request(@NonNull HaloRequest haloRequest) throws HaloNetException {\n        Request request = haloRequest.buildOkRequest();\n        try {\n            Response response = mClient.newCall(request).execute();\n            if (response.isSuccessful()) {\n                return response;\n            } else {\n                throw new HaloNetworkExceptionResolver().resolve(response);\n            }\n        } catch (HaloNetException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new HaloNetworkExceptionResolver().resolve(e, request, HaloUtils.isNetworkConnected(mContext));\n        }\n    }\n\n    public  HaloNetClient(@NonNull Context context, @NonNull OkHttpClient.Builder clientBuilder, @NonNull HaloEndpointCluster endpoints, boolean disableKitKatCertificate);\n\n    @NonNull @Api(2.0) public OkHttpClient.Builder buildCertificates(@NonNull OkHttpClient.Builder okBuilder);\n    @SuppressWarnings(\"unchecked\") @Api(2.0) public T request(@NonNull HaloRequest haloRequest, @NonNull final TypeReference<T> type);\n    @SuppressWarnings(\"unchecked\") @Api(2.0) public T request(@NonNull HaloRequest haloRequest, @NonNull Class<T> clazz);\n    @Api(2.0) public HaloEndpointCluster endpoints();\n    @NonNull @Api(2.0) public OkHttpClient ok();\n    @Api(2.0) public void overrideOk(@NonNull OkHttpClient.Builder builder);\n    @NonNull @Api(2.0) public Context context();\n    @NonNull @Api(2.4) public void closeCache();\n\n    private CallbackFlag mCallbackFlag;\n    private HaloNetClient mHaloNetClient;\n    private HaloFramework mFramework;\n    private MockServer mMockServer;\n    private String mEndpointURL;\n\n}\n\nclass HaloNetClientTest  {\n\n    private CallbackFlag mCallbackFlag;\n    private HaloNetClient mHaloNetClient;\n    private HaloFramework mFramework;\n    private MockServer mMockServer;\n    private String mEndpointURL;\n\n    @Test\n    public void thatCanPostARequestWithJSONObjectBody() throws IOException, JSONException {\n", "reference": "        enqueueServerFile(mMockServer,GET_TEST_ITEM);\n        HaloNetworkApi networkApi = givenAHaloNetWorkApi(mFramework,mEndpointURL);\n        HaloRequest request = givenAPostRequestWithJSONObjectBody(networkApi);\n        String response = mHaloNetClient.request(request,String.class);\n        assertThat(response).isNotNull();\n        assertThat(response).isEqualTo(\"ExampleResponseTestFromNetWork\");\n    }\n\n}", "prediction": "        mMockServer.enqueue(new MockResponse().setBody(new JSONObject().put(\"foo\", \"bar\").toString()));\n        HaloRequest request = new HaloRequest.Builder(mEndpointURL, HttpMethod.POST)\n               .addHeader(\"Content-Type\", \"application/json\")\n               .addBody(new JSONObject().put(\"foo\", \"bar\").toString())\n               .build();\n        Response response = mHaloNetClient.request(request);\n        assertEquals(200, response.code());\n        assertEquals(\"bar\", new JSONObject(response.body().string()).getString(\"foo\"));\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "72299435_7", "part": [1, 1], "seq": [1, 1], "prompt": "class VolleyX {\n\n    public static <T> Observable<T> from(final Request<T> request) {\n        if (!sInited) throw new IllegalStateException(\"call init first\");\n        if (request == null) throw new NullPointerException(\"request can not be null\");\n        return Observable.defer(new Func0<Observable<T>>() {\n            @Override\n            public Observable<T> call() {\n                try {\n                    return Observable.just(generateData(request));\n                } catch (InterruptedException | ExecutionException e) {\n                    VolleyXLog.e(e.getMessage());\n                    return Observable.error(e);\n                }\n            }\n        });\n    }\n\n    public static void init(Context context);\n    public static Observable<T> from(final Request<T> request, final String listernerField);\n    static T generateData(Request<T> request);\n    static T generateData(Request<T> request, String listernerField);\n    static RequestFuture<T> getRequestFuture(Request<T> request, String listernerField);\n    public static void setRequestQueue(RequestQueue queue);\n\n    @Mock RequestQueue mockReqeustQueue;\n    @Mock Request mockRequest;\n\n}\n\nclass VolleyXTest  {\n\n    @Mock RequestQueue mockReqeustQueue;\n    @Mock Request mockRequest;\n\n    @Test\n    public void testFrom1() throws Exception {\n", "reference": "        VolleyX.sInited = true;\n\n        assertThat(VolleyX.from(mockRequest, \"\"), is(instanceOf(Observable.class)));\n    }\n\n}", "prediction": "        VolleyX.setRequestQueue(mockReqeustQueue);\n        VolleyX.from(mockRequest);\n        verify(mockReqeustQueue).add(mockRequest);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "74042107_5", "part": [1, 1], "seq": [1, 1], "prompt": "class SubtractiveMixingStrategy implements MixingStrategy {\n\n    public Liquid mixLiquids(LinkedList<Liquid> inflow) {\n        if (inflow == null || inflow.isEmpty()) {\n            throw new IllegalArgumentException(\"Must at least mix one liquid\");\n        }\n\n        // Count full amount first...\n        float fullAmount = 0;\n        for (Liquid liquid : inflow) {\n            fullAmount += liquid.getAmount();\n        }\n\n        if (Math.abs(fullAmount) < 0.000001) {\n            return new Liquid(0, inflow.peekFirst().getTemperature(), inflow.peekFirst().getColor());\n        }\n\n        // Real calculations...\n        double c = 0;\n        double m = 0;\n        double y = 0;\n        float temperature = 0;\n\n        for (Liquid liquid : inflow) {\n            c += (liquid.getAmount() / fullAmount) * liquid.getColor().getCyan();\n            m += (liquid.getAmount() / fullAmount) * liquid.getColor().getMagenta();\n            y += (liquid.getAmount() / fullAmount) * liquid.getColor().getYellow();\n\n            temperature += (liquid.getAmount() / fullAmount) * liquid.getTemperature();\n        }\n\n        // Fix floating point inaccuracies\n        c = Math.min(1, c);\n        m = Math.min(1, m);\n        y = Math.min(1, y);\n        temperature = Math.min(SimulationConstants.MAX_TEMPERATURE,\n                Math.max(SimulationConstants.MIN_TEMPERATURE, temperature));\n\n        return new Liquid(fullAmount, temperature, new Color(c, m, y));\n    }\n\n}\n\nclass SubtractiveMixingStrategyTest {\n\n    @Test\n    public void testMixingTwoLiquidsDifferentAmounts() {\n", "reference": "        LinkedList<Liquid> liquids = new LinkedList<>();\n        liquids.add(new Liquid(300, 340, new Color(0x880000)));\n        liquids.add(new Liquid(100, 300, new Color(0x440000)));\n\n        Liquid result = new SubtractiveMixingStrategy().mixLiquids(liquids);\n        assertEquals(new Liquid(400, 330, new Color(0x770000)), result);\n    }\n\n}", "prediction": "        Liquid liquid1 = new Liquid(10, 100, new Color(0.5, 0.5, 0.5));\n        Liquid liquid2 = new Liquid(20, 100, new Color(0.5, 0.5, 0.5));\n\n        Liquid mixedLiquid = new SubtractiveMixingStrategy().mixLiquids(new LinkedList<>(Arrays.asList(liquid1, liquid2)));\n\n        assertEquals(30, mixedLiquid.getAmount(), 0.000001);\n        assertEquals(100, mixedLiquid.getTemperature(), 0.000001);\n        assertEquals(0.5, mixedLiquid.getColor().getCyan(), 0.000001);\n        assertEquals(0.5, mixedLiquid.getColor().getMagenta(), 0.000001);\n        assertEquals(0.5, mixedLiquid.getColor().getYellow(), 0.000001);\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "74059585_25", "part": [1, 1], "seq": [1, 1], "prompt": "class NonRegisteringDriver implements Driver {\n\n  @Override\n  public DriverPropertyInfo[] getPropertyInfo(@Nullable String url, @Nullable Properties info)\n      throws SQLException {\n    checkNotNullUrl(url);\n\n    return DriverManager.getDriver(getRealUrl(url)).getPropertyInfo(getRealUrl(url), info);\n  }\n\n  public  NonRegisteringDriver();\n  @VisibleForTesting  NonRegisteringDriver(TraceService traceService);\n\n  @Override public boolean acceptsURL(@Nullable String url);\n  @Override public Connection connect(@Nullable String url, @Nullable Properties info);\n  @VisibleForTesting Connection connect(String url, Properties info, TraceOptions traceOptions);\n  @Override public int getMajorVersion();\n  @Override public int getMinorVersion();\n  @Override public Logger getParentLogger();\n  @Override public boolean jdbcCompliant();\n  private static String getRealUrl(String url);\n  private static void checkNotNullUrl(String url);\n\n  private final TraceService mockTraceService;\n  private final TraceService.Span mockTraceSpan;\n  private final Driver mockRealDriver;\n  private final Connection mockRealConnection;\n  private NonRegisteringDriver driver;\n\n}\n\nclass NonRegisteringDriverTest {\n\n  private final TraceService mockTraceService;\n  private final TraceService.Span mockTraceSpan;\n  private final Driver mockRealDriver;\n  private final Connection mockRealConnection;\n  private NonRegisteringDriver driver;\n\n  @Test\n  public void getPropertyInfo() throws Exception {\n", "reference": "    DriverPropertyInfo[] driverPropertyInfos = new DriverPropertyInfo[0];\n    when(mockRealDriver.acceptsURL(\"jdbc:mockdriver\")).thenReturn(true);\n    when(mockRealDriver.getPropertyInfo(eq(\"jdbc:mockdriver\"), any(Properties.class)))\n        .thenReturn(driverPropertyInfos);\n\n    Properties info = new Properties();\n    assertThat(driver.getPropertyInfo(\"jdbc:stackdriver:mockdriver\", info))\n        .isSameAs(driverPropertyInfos);\n    verify(mockRealDriver).getPropertyInfo(\"jdbc:mockdriver\", info);\n  }\n\n}", "prediction": "    driver.getPropertyInfo(\"jdbc:mock:url\", null);\n\n    verify(mockRealDriver).getPropertyInfo(\"jdbc:mock:url\", null);\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "74458764_50", "part": [1, 1], "seq": [1, 1], "prompt": "class JedisPoolFacade extends AbstractJedisFacade {\n\n  @Override\n  public Long publish(byte[] channel, byte[] message) {\n    return jedis().publish(channel, message);\n  }\n\n    JedisPoolFacade(Pool<Jedis> jedisPool);\n\n   Jedis jedis();\n  @Override public void requestFinished();\n  @Override public void psubscribe(final RedisPubSub listener, String pattern);\n  @Override public void punsubscribe(final RedisPubSub listener, byte[] pattern);\n  @Override public Long hdel(byte[] key, byte[]... fields);\n  @Override public List<byte[]> hmget(byte[] key, byte[]... fields);\n  @Override public String hmset(byte[] key, Map<byte[], byte[]> hash);\n  @Override public Long hsetnx(final byte[] key, final byte[] field, final byte[] value);\n  @Override public Long hset(final byte[] key, final byte[] field, final byte[] value);\n  @Override public Set<byte[]> hkeys(byte[] key);\n  @Override public String set(byte[] key, byte[] value);\n  @Override public String setex(byte[] key, int expiry, byte[] value);\n  @Override public Long expire(byte[] key, int value);\n  @Override public void srem(byte[] key, byte[]... member);\n  @Override public Long sadd(byte[] key, byte[]... member);\n  @Override public Long del(byte[]... keys);\n  @Override public Boolean exists(byte[] key);\n  @Override public Set<byte[]> smembers(byte[] key);\n  @Override public Set<byte[]> spop(byte[] key, long count);\n  @Override public Long expireAt(byte[] key, long unixTime);\n  @Override public Long zadd(byte[] key, double score, byte[] elem);\n  @Override public Long zrem(byte[] key, byte[]... fields);\n  @Override public Set<byte[]> zrangeByScore(byte[] key, double start, double end);\n  @Override public Set<byte[]> zrange(byte[] key, long start, long end);\n  @Override public Long persist(byte[] key);\n  @Override public String info(String section);\n  @Override public RedisFacade.ResponseFacade<T> transaction(final byte[] key, final TransactionRunner<T> transaction);\n  @Override public void close();\n  @Override public String rename(byte[] oldkey, byte[] newkey);\n  @Override public byte[] get(byte[] key);\n  @Override public void startMonitoring(MetricRegistry metrics);\n\n  private Pool<Jedis> pool;\n  private JedisPoolFacade rf;\n  private Jedis jedis;\n\n}\n\nclass TestJedisPoolFacade {\n\n  private Pool<Jedis> pool;\n  private JedisPoolFacade rf;\n  private Jedis jedis;\n\n  @Test\n  public void testPublish() {\n", "reference": "    byte[] channel = new byte[]{};\n    byte[] message = new byte[]{};\n    rf.publish(channel, message);\n    verify(jedis).publish(channel, message);\n  }\n\n}", "prediction": "    rf.publish(new byte[] {1, 2, 3}, new byte[] {4, 5, 6});\n    verify(jedis).publish(new byte[] {1, 2, 3}, new byte[] {4, 5, 6});\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "74581177_26", "part": [1, 1], "seq": [1, 1], "prompt": "class GlobalAntExecutor {\n\n    public String generateFullTemporaryDir(final String generatorBuilderPath, final String temporaryDir) throws APIRestGeneratorException\n    {\n        final String fullTemporaryDir = generatorBuilderPath + File.separator + ConstantsAnt.BASE_GEN_FOLDERS + temporaryDir ;\n        FilesUtility.createFullDirectoryTree(fullTemporaryDir);\n\n        return fullTemporaryDir;\n    }\n\n    public  GlobalAntExecutor(final String parserType, final String translatorType);\n\n    public void launchAntExecutor(final String generatorBuilderPath,\n                                  final String fileName,\n                                  final String deliverableFileName,\n                                  final String temporaryDir,\n                                  final PrintStream errorStreamWrapper,\n                                  final PrintStream outputStreamWrapper);\n    public String generateTemporaryOutputDirectory(final String generatorBuilderPath);\n    public void removeFullTemporaryDirectory(final String fullTemporaryDir);\n    public void validateFileExtension(final String fileName);\n    public String getDeliverableFileName(final String fileName, final String translatorType);\n\n}\n\nclass GlobalAntExecutorTest {\n\n\t@Test\n\tpublic void generateFullTemporaryDirTest() throws APIRestGeneratorException\n\t{\n", "reference": "\t\tfinal GlobalAntExecutor globalAntExecutor = new GlobalAntExecutor(ConstantsTest.PARSER_TYPE, ConstantsTest.TRANSLATOR_TYPE) ;\n\t\tglobalAntExecutor.generateFullTemporaryDir(ConstantsTest.GENERATOR_BUILDER_PATH, ConstantsTest.TEMPORARY_DIR) ;\n\t}\n\n}", "prediction": "\t\tfinal String generatorBuilderPath = \"C:\\\\Users\\\\j.bouzidi\\\\Documents\\\\workspace\\\\api-rest-generator\\\\api-rest-generator-core\\\\src\\\\test\\\\resources\\\\test-files\\\\generator-builder\";\n\t\tfinal String temporaryDir = \"test-temp-dir\";\n\n\t\tfinal GlobalAntExecutor globalAntExecutor = new GlobalAntExecutor(\"parser\", \"translator\");\n\n\t\tfinal String fullTemporaryDir = globalAntExecutor.generateFullTemporaryDir(generatorBuilderPath, temporaryDir);\n\n\t\tAssert.assertEquals(generatorBuilderPath + File.separator + ConstantsAnt.BASE_GEN_FOLDERS + temporaryDir, fullTemporaryDir);\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "75793136_1", "part": [1, 1], "seq": [1, 1], "prompt": "class GitHubApiController {\n\n    @GetMapping(\"user/{screenName}\")\n    public ResponseEntity<User> discoverUserByScreenName(@PathVariable(\"screenName\")  String screenName) {\n        return Optional.of(ResponseEntity.ok(gitHubService.discoverUserByScreenName(screenName)))\n               .or(new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR));\n    }\n\n    @Autowired public  GitHubApiController(GitHubService gitHubService);\n\n    @LocalServerPort\n    private int port;\n    @Autowired\n    private TestRestTemplate restTemplate;\n\n}\n\nclass GitHubApiControllerTest {\n\n    @LocalServerPort\n    private int port;\n    @Autowired\n    private TestRestTemplate restTemplate;\n\n    @Test\n    public void testDiscoverUserByScreenName() throws Exception {\n", "reference": "        ResponseEntity<User> user1 = restTemplate.getForEntity(\"http://localhost:\" + port + \"/v1/user/bingohuang\", User.class);\n        assertEquals(HttpStatus.OK, user1.getStatusCode());\n\n        ResponseEntity<User> user2 = restTemplate.getForEntity(\"http://localhost:\" + port + \"/v1/user/163yun\", User.class);\n        assertEquals(HttpStatus.OK, user2.getStatusCode());\n\n        ResponseEntity<User> user3 = restTemplate.getForEntity(\"http://localhost:\" + port + \"/v1/user/huangqingbing\", User.class);\n        assertEquals(HttpStatus.OK, user3.getStatusCode());\n    }\n\n}", "prediction": "        ResponseEntity<User> response = restTemplate.getForEntity(\"http://localhost:\" + port + \"/api/user/octocat\", User.class);\n        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);\n        assertThat(response.getBody().getLogin()).isEqualTo(\"octocat\");\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "75865158_0", "part": [1, 1], "seq": [1, 1], "prompt": "class Solver {\n\n    public Puzzle solvePuzzle() {\n        Puzzle workingPuzzle = new Puzzle(originalPuzzle);\n        solve(workingPuzzle);\n        return workingPuzzle;\n    }\n\n    public  Solver(Puzzle puzzle);\n\n    private Boolean solve(Puzzle workingPuzzle);\n\n}\n\nclass SolverTest {\n\n    @Test\n    public void ValidPuzzle_Solve_NoNullValues() {\n", "reference": "\n        //Arrange & Act\n        Puzzle solvedPuzzle = solvePuzzle(getPuzzle());\n\n        //Assert\n        for (int x = 0; x < Puzzle.SIZE; x++) {\n            for (int y = 0; y < Puzzle.SIZE; y++) {\n                Point currentPoint = new Point(x, y);\n                Assert.assertNotNull(solvedPuzzle.getNumber(currentPoint));\n            }\n        }\n    }\n\n}", "prediction": "        Puzzle puzzle = new Puzzle(new int[][] {\n            {1, 2, 3},\n            {4, 5, 6},\n            {7, 8, 0}\n        });\n        Solver solver = new Solver(puzzle);\n        Puzzle solvedPuzzle = solver.solvePuzzle();\n        for (int[] row : solvedPuzzle.getGrid()) {\n            for (int value : row) {\n                Assert.assertNotNull(value);\n            }\n        }\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "75941229_0", "part": [1, 1], "seq": [1, 1], "prompt": "class KafkaSenderExporter {\n\n  @Activate\n  public void activate(Config config, BundleContext context, Map<String, String> properties) {\n    sender = KafkaSender.newBuilder()\n       .bootstrapServers(config.bootstrapServers())\n       .encoding(config.encoding())\n       .messageMaxBytes(config.messageMaxBytes())\n       .overrides(getOverrides(properties))\n       .topic(config.topic())\n       .build();\n    reg = context.registerService(Sender.class, sender, new Hashtable<String, String>(properties));\n  }\n\n  private HashMap<String, String> getOverrides(Map<String, String> properties);\n  @Deactivate public void deactive();\n\n}\n\nclass KafkaSenderExporterTest {\n\n  @Test\n  public void testConfig() {\n", "reference": "    KafkaSenderExporter exporter = new KafkaSenderExporter();\n    Map<String, String> properties = new HashMap<String, String>();\n    properties.put(\"kafka.myprop\", \"myvalue\");\n    BundleContext context = mock(BundleContext.class);\n    Config config = mock(Config.class);\n    when(config.bootstrapServers()).thenReturn(\"server1\");\n    when(config.encoding()).thenReturn(Encoding.JSON);\n    when(config.topic()).thenReturn(\"mytopic\");\n    exporter.activate(config, context, properties);\n  }\n\n}", "prediction": "    Config config = new Config();\n    config.setBootstrapServers(\"localhost:9092\");\n    config.setEncoding(\"UTF-8\");\n    config.setMessageMaxBytes(1024);\n    config.setTopic(\"test\");\n    KafkaSenderExporter exporter = new KafkaSenderExporter();\n    exporter.activate(config, null, null);\n    Sender sender = exporter.sender;\n    Assert.assertEquals(\"localhost:9092\", sender.getBootstrapServers());\n    Assert.assertEquals(\"UTF-8\", sender.getEncoding());\n    Assert.assertEquals(1024, sender.getMessageMaxBytes());\n    Assert.assertEquals(\"test\", sender.getTopic());\n  }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "75955378_35", "part": [1, 1], "seq": [1, 1], "prompt": "class ArraySplitOperation implements MultiplexOperation {\n\n  @Override\n  public List<InternalEvent> perform(InternalEvent ievent) throws OperationException {\n    {\n      if (ievent.getEventObj() == null) {\n        throw new OperationException(\"Deserialized object is null\");\n      }\n\n      Object payload;\n      try {\n        payload = ievent.getEventObj().getField(this.path);\n      } catch (FieldNotFoundException e) {\n        throw new OperationException(e);\n      }\n\n      if (!(payload instanceof JsonArray)) {\n        throw new OperationException(\"Payload data is not a JsonArray\");\n      }\n\n      LinkedHashMap<String, String> partitions = ievent.getPartitions();\n\n      JsonArray arr = (JsonArray) payload;\n\n      ArrayList<InternalEvent> output = new ArrayList<InternalEvent>();\n      for (JsonElement elm : arr) {\n        try {\n          JsonObject newObject = elm.getAsJsonObject();\n          for (String field : this.fieldsToKeep) {\n            JsonObject jsonObject = (JsonObject) ievent.getEventObj().getPayload();\n            newObject.add(field, jsonObject.get(field));\n          }\n\n          InternalEvent newEvent = new InternalEvent(newObject.toString(), ievent.getCtx(), ievent.getArrivalTime());\n          DeserializedEvent newDeserEvent = new GenericJsonEvent(newObject);\n          newEvent.setEventObj(newDeserEvent);\n          newEvent.setEventTime(ievent.getEventTime());\n\n          /*\n           * Deep clone the partitions\n           */\n          if (partitions!= null) {\n            LinkedHashMap<String, String> newPartitions =\n                new LinkedHashMap<String, String>(partitions.size());\n\n            partitions.entrySet().forEach(kv -> {\n              newPartitions.put(new String(kv.getKey()), new String(kv.getValue()));\n            });\n\n            newEvent.setPartitions(newPartitions);\n          }\n\n          output.add(newEvent);\n        } catch (Exception e) {\n          throw new OperationException(e);\n        }\n      }\n\n      return output;\n    }\n  }\n\n  public  ArraySplitOperation(String path);\n  public  ArraySplitOperation(String path,\n                             List<String> fieldsToKeep);\n\n}\n\nclass ArraySplitOperationTest  {\n\n  @Test(expected = OperationException.class)\n  public void testMissingField()\n      throws JsonSyntaxException, UnsupportedEncodingException, IOException {\n", "reference": "    JsonParser parser = new JsonParser();\n    TestContext t = new TestContext();\n    t.setFunctionName(\"foo\");\n    LambdaContext lctx = new LambdaContext(t);\n\n    JsonElement input = parser.parse(getResourceString(\"array_input.json\"));\n\n    GenericJsonEvent devent = new GenericJsonEvent(input.getAsJsonObject());\n    ArraySplitOperation operation = new ArraySplitOperation(\"$.bar]\");\n\n    InternalEvent ievent = new InternalEvent(\"\", lctx, 123);\n    ievent.setEventObj(devent);\n    ievent.setEventTime(124);\n    List<InternalEvent> events = operation.perform(ievent);\n  }\n\n}", "prediction": "    String json = \"{\\\"a\\\": \\\"b\\\"}\";\n    JsonObject obj = new JsonParser().parse(json).getAsJsonObject();\n    InternalEvent ievent = new InternalEvent(obj.toString(), null, null);\n    ievent.setEventObj(new GenericJsonEvent(obj));\n\n    ArraySplitOperation op = new ArraySplitOperation(\"c\");\n    op.perform(ievent);\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "77110232_1", "part": [1, 1], "seq": [1, 1], "prompt": "class Buffer {\n\n    char charAt(int pos) {\n        int seg = pos / segmentLen;\n        int off = pos % segmentLen;\n\n        int index = begins[seg] + off;\n        return buf.charAt(index);\n    }\n\n      Buffer(CharSequence sb, int segmentLen, long seed);\n\n     List<Integer> segments(int from, int end);\n     CharSequence subSequence(int from, int end);\n\n    static String lng;\n\n}\n\nclass BufferTest {\n\n    static String lng;\n\n    @Test public void firstFailure() {\n", "reference": "        long seed = 1394639167285L;\n        \n        Buffer b = new Buffer(lng, 3, seed);\n\n        StringBuilder recover = new StringBuilder();\n        for (int i = 0; i < lng.length(); i++) {\n            recover.append(b.charAt(i));\n        }\n        \n        assertEquals(recover.toString(), lng);\n    }\n\n}", "prediction": "        Buffer buffer = new Buffer(lng, 1000, 0);\n        buffer.charAt(0);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "78464881_4", "part": [1, 1], "seq": [1, 1], "prompt": "class SolaceJmsAutoConfigurationBase implements SpringSolJmsConnectionFactoryCloudFactory, SpringSolJmsJndiTemplateCloudFactory {\n\n    @Bean\n    @Override\n    public SolConnectionFactory getSolConnectionFactory() {\n        return getSolConnectionFactory(findFirstSolaceServiceCredentialsImpl());\n    }\n\n      SolaceJmsAutoConfigurationBase(SolaceJmsProperties properties);\n\n    abstract SolaceServiceCredentials findFirstSolaceServiceCredentialsImpl();\n    @Override public abstract List<SolaceServiceCredentials> getSolaceServiceCredentials();\n    @Bean @Override public SolaceServiceCredentials findFirstSolaceServiceCredentials();\n    @Override public SolConnectionFactory getSolConnectionFactory(String id);\n    @Override public SolConnectionFactory getSolConnectionFactory(SolaceServiceCredentials solaceServiceCredentials);\n    @Override @Deprecated public List<SolaceMessagingInfo> getSolaceMessagingInfos();\n    private SolaceServiceCredentials findSolaceServiceCredentialsById(String id);\n     void setProperties(SolaceJmsProperties properties);\n    @Bean @Override public JndiTemplate getJndiTemplate();\n    @Override public JndiTemplate getJndiTemplate(SolaceServiceCredentials solaceServiceCredentials);\n    @Override public JndiTemplate getJndiTemplate(String id);\n\n    private SolaceJmsProperties solaceJmsProperties;\n    private SolaceJmsAutoConfigurationBase jmsAutoConfBase;\n    private SolaceServiceCredentials solaceServiceCredentials;\n    private ObjectMapper objectMapper;\n\n}\n\nclass SolaceJmsAutoConfigurationBaseTest  {\n\n    private SolaceJmsProperties solaceJmsProperties;\n    private SolaceJmsAutoConfigurationBase jmsAutoConfBase;\n    private SolaceServiceCredentials solaceServiceCredentials;\n    private ObjectMapper objectMapper;\n\n    @Test\n    public void testGetSolConnectionFactory() {\n", "reference": "        validateSolConnectionFactory(jmsAutoConfBase.getSolConnectionFactory(), false);\n        disableSolaceServiceCredentials();\n        validateSolConnectionFactory(jmsAutoConfBase.getSolConnectionFactory(), true);\n    }\n\n}", "prediction": "        SolConnectionFactory solConnectionFactory = jmsAutoConfBase.getSolConnectionFactory();\n        assertNotNull(solConnectionFactory);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "78699707_0", "part": [1, 1], "seq": [1, 1], "prompt": "class ReversedCharSequence extends ReverseIndexMapperBase implements ReverseCharSequence {\n\n    @Override\n    public ReversedCharSequence subSequence(int start, int end) {\n        if (start < 0 || end > length())\n            throw new IndexOutOfBoundsException(\"[\" + start + \", \" + end + \") not in [0,\" + length() + \"]\");\n        final int startIndex = mapBoundary(end);\n        final int endIndex = startIndex + end - start;\n        return startIndex == myStartIndex && endIndex == myEndIndex? this : new ReversedCharSequence(myChars, startIndex, endIndex);\n    }\n\n    @SuppressWarnings(\"WeakerAccess\") private  ReversedCharSequence(CharSequence chars, int start, int end);\n\n    @Override public CharSequence getReversedChars();\n    public int getStartIndex();\n    @Override public IndexMapper getIndexMapper();\n    @Override public int getEndIndex();\n    @Override public int length();\n    @Override public char charAt(int index);\n    @Override public String toString();\n    @Override public boolean equals(Object o);\n    @Override public int hashCode();\n    public static ReversedCharSequence of(final CharSequence chars);\n    public static ReversedCharSequence of(final CharSequence chars, final int start);\n    public static ReversedCharSequence of(final CharSequence chars, final int start, final int end);\n\n}\n\nclass ReversedCharSequenceTest {\n\n    @Test\n    public void subSequence() throws Exception {\n", "reference": "        CharSequence orig = \"abcdef\";\n        CharSequence reved = \"fedcba\";\n        ReversedCharSequence test = (ReversedCharSequence) ReversedCharSequence.of(orig);\n\n        int iMax = orig.length();\n        for (int i = 0; i < iMax; i++) {\n            for (int j = iMax - i - 1; j >= 0 && j >= i; j--) {\n                assertEquals(\"subSequence(\" + i + \",\" + j + \")\", reved.subSequence(i, j), test.subSequence(i, j).toString());\n                assertEquals(\"reverse.of(subSequence(\" + i + \",\" + j + \"))\", orig.subSequence(test.mapIndex(j) + 1, test.mapIndex(j) + 1 + j - i), ReversedCharSequence.of(test.subSequence(i, j)).toString());\n                assertEquals(\"subSequence(\" + i + \",\" + j + \").hashCode()\", reved.subSequence(i, j).hashCode(), test.subSequence(i, j).hashCode());\n                assertEquals(\"subSequence(\" + i + \",\" + j + \").equals()\", true, test.subSequence(i, j).equals(reved.subSequence(i, j)));\n            }\n        }\n    }\n\n}", "prediction": "        final CharSequence chars = \"abcde\";\n        final ReversedCharSequence reversedCharSequence = ReversedCharSequence.of(chars);\n        assertEquals(\"edcba\", reversedCharSequence.subSequence(0, 5).toString());\n        assertEquals(\"cba\", reversedCharSequence.subSequence(1, 4).toString());\n        assertEquals(\"ba\", reversedCharSequence.subSequence(2, 3).toString());\n        assertEquals(\"a\", reversedCharSequence.subSequence(3, 4).toString());\n        assertEquals(\"\", reversedCharSequence.subSequence(4, 4).toString());\n        assertEquals(\"\", reversedCharSequence.subSequence(5, 5).toString());\n        assertEquals(\"\", reversedCharSequence.subSequence(5, 6).toString());\n        assertEquals(\"\", reversedCharSequence.subSequence(6, 6).toString());\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "78797738_0", "part": [1, 1], "seq": [1, 1], "prompt": "class CtxController {\n\n    @RequestMapping(\"/\")\n    @ResponseBody\n    public String index() {\n        StringBuilder sb = new StringBuilder(\"<html><body>\");\n\n        sb.append(INTRO);\n\n        String[] beanNames = ctx.getBeanDefinitionNames();\n        Arrays.sort(beanNames);\n        for (String beanName : beanNames) {\n            sb.append(\"</br>\").append(beanName);\n        }\n        sb.append(\"</body></htm>\");\n        return sb.toString();\n    }\n\n    @RequestMapping(\"/home\") public String home(ModelMap model);\n\n    @Autowired CtxController ctxController;\n    private ModelMap model;\n\n}\n\nclass CtxControllerTest {\n\n    @Autowired CtxController ctxController;\n    private ModelMap model;\n\n    @Test\n    public void textIndex() {\n", "reference": "        String result = ctxController.index();\n        assertNotNull(result);\n        assertTrue(result.contains(CtxController.INTRO));\n    }\n\n}", "prediction": "        String result = ctxController.index();\n        System.out.println(result);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "80398085_0", "part": [1, 1], "seq": [1, 1], "prompt": "class SharedPreferencesHelper {\n\n    public boolean saveSortBy(int sortBy) {\n        SharedPreferences.Editor editor = mSharedPreferences.edit();\n        editor.putInt(STATE_CURRENT_SORT, sortBy);\n        return editor.commit();\n    }\n\n    public  SharedPreferencesHelper(SharedPreferences sharedPreferences);\n\n    public int getSortBy();\n    public boolean imageUploading(String itemId);\n    public void setImageUploading(String itemId);\n    public void removeImageUploading(String itemId);\n\n    private SharedPreferencesHelper mMockSharedPreferencesHelper;\n    private SharedPreferencesHelper mMockBrokenSharedPreferencesHelper;\n    @Mock SharedPreferences mMockSharedPreferences;\n    @Mock SharedPreferences mMockBrokenSharedPreferences;\n    @Mock SharedPreferences.Editor mMockEditor;\n    @Mock SharedPreferences.Editor mMockBrokenEditor;\n\n}\n\nclass SharedPreferencesHelperTest {\n\n    private SharedPreferencesHelper mMockSharedPreferencesHelper;\n    private SharedPreferencesHelper mMockBrokenSharedPreferencesHelper;\n    @Mock SharedPreferences mMockSharedPreferences;\n    @Mock SharedPreferences mMockBrokenSharedPreferences;\n    @Mock SharedPreferences.Editor mMockEditor;\n    @Mock SharedPreferences.Editor mMockBrokenEditor;\n\n    @Test\n    public void saveSortByFailed_ReturnsFalse() {\n", "reference": "        boolean success = mMockBrokenSharedPreferencesHelper.saveSortBy(SORT_BY_EXPIRY);\n        assertThat(\"Makes sure writing to a broken SharedPreferencesHelper returns false\", success,\n                is(false));\n    }\n\n}", "prediction": "        when(mMockBrokenEditor.commit()).thenReturn(false);\n        when(mMockBrokenSharedPreferences.edit()).thenReturn(mMockBrokenEditor);\n\n        boolean result = mMockBrokenSharedPreferencesHelper.saveSortBy(1);\n\n        assertFalse(result);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "80497637_3", "part": [1, 1], "seq": [1, 1], "prompt": "class UCSClient {\n\n\tpublic Element exec(String command, String... args) {\n\t\treturn exec(command, toMap(args));\n\t}\n\n\tprivate Token refresh(Token token);\n\tpublic void logout();\n\tprotected void forceLogout();\n\tpublic Token getToken();\n\tpublic void logDebug(String message, Element element);\n\tpublic void logInfo(String message, Element element);\n\tpublic List<Element> resolveClass(String classId, boolean inHierarchical);\n\tpublic List<Element> resolveClass(String classId);\n\tpublic Element resolveDn(String dn);\n\tpublic Map<String, String> toMap(String... args);\n\tpublic Element exec(String command, Map<String, String> args);\n\tpublic String getUCSManagerId();\n\tpublic List<Element> resolveChildren(String dn, String classId);\n\n\t@Rule\n\tpublic MockWebServer mockServer;\n\t UCSClient ucs;\n\t String cookie;\n\n}\n\nclass UCSClientTest {\n\n\t@Rule\n\tpublic MockWebServer mockServer;\n\t UCSClient ucs;\n\t String cookie;\n\n\t@Test\n\tpublic void testDummyExchange() {\n", "reference": "\t\tmockServer.enqueue(new MockResponse().setBody(\"<foo response=\\\"yes\\\"> </foo>\"));\n\t\tElement element = ucs.exec(\"foo\", \"fizz\",\"buzz\");\n\t\t\n\t\tAssertions.assertThat(element.getName()).isEqualTo(\"foo\");\n\t\tAssertions.assertThat(element.getAttributeValue(\"response\")).isEqualTo(\"yes\");\n\t}\n\n}", "prediction": "\t\tucs.exec(\"dummy\");\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "80868140_26", "part": [1, 1], "seq": [1, 1], "prompt": "class LoessInterpolator {\n\n\tDouble smoothOnePoint(final double x, final int left, final int right) {\n\n\t\t// Ordinarily, one doesn't do linear regression one x-value at a time, but LOESS does since\n\t\t// each x-value will typically have a different window. As a result, the weighted linear regression\n\t\t// is recast as a linear operation on the input data, weighted by this.fWeights.\n\n\t\tState state = computeNeighborhoodWeights(x, left, right);\n\n\t\tif (state == State.WEIGHTS_FAILED)\n\t\t\treturn null;\n\n\t\tif (state == State.LINEAR_OK)\n\t\t\tupdateWeights(x, left, right);\n\n\t\tdouble ys = 0.0;\n\t\tfor (int i = left; i <= right; ++i)\n\t\t\tys += fWeights[i] * fData[i];\n\n\t\treturn ys;\n\t}\n\n\t  LoessInterpolator(int width, double[] data, double[] externalWeights);\n\n\tabstract void updateWeights(double x, int left, int right);\n\tprivate State computeNeighborhoodWeights(double x, int left, int right);\n\n}\n\nclass LoessInterpolatorTest {\n\n\t@Test\n\tpublic void constantDataExtrapolatesConstantValues() {\n", "reference": "\n\t\tdouble[] data = createConstantDataArray();\n\n\t\tfor (int degree = 0; degree < 3; ++degree) {\n\t\t\tLoessInterpolator loess = new LoessInterpolator.Builder().setWidth(7).setDegree(degree).interpolate(data);\n\n\t\t\tDouble y = loess.smoothOnePoint(-100, 0, data.length - 1);\n\t\t\tassertNotNull(y);\n\t\t\tassertEquals(\"Bad value extrapolating left\", data[0], y, 3.0e-9);\n\n\t\t\ty = loess.smoothOnePoint(1000.0, 0, data.length - 1);\n\t\t\tassertNotNull(y);\n\t\t\tassertEquals(\"Bad value extrapolating right\", data[0], y, 3.0e-9);\n\t\t}\n\t}\n\n}", "prediction": "\t\tdouble[] data = new double[100];\n\t\tArrays.fill(data, 1.0);\n\t\tLoessInterpolator interpolator = new LoessInterpolator(10, data, null);\n\t\tfor (int i = 0; i < 100; ++i)\n\t\t\tassertEquals(1.0, interpolator.smoothOnePoint(i, 0, 99), 0.0);\n\t}", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "81092547_0", "part": [1, 1], "seq": [1, 1], "prompt": "class CitySimulation extends AbstractSimulation {\n\n    WorldState getWorldState(){\n        return world;\n    }\n\n    @Override public Map<String, SimStart> init(int steps, JSONObject config, Set<TeamConfig> matchTeams);\n    @Override public Map<String, RequestAction> preStep(int stepNo);\n    private List<DumpData> buildDumpData();\n    private List<WellData> buildWellData();\n    private List<ChargingStationData> buildChargingStationData();\n    private List<WorkshopData> buildWorkshopData();\n    private List<ShopData> buildShopData();\n    private List<ResourceNodeData> buildResourceNodeData();\n    private Map<String,EntityData> buildEntityData();\n    @Override public void step(int stepNo, Map<String, Action> actions);\n    @Override public Map<String, SimEnd> finish();\n    @Override public JSONObject getResult();\n    private Map<TeamState, Integer> getRankings();\n    @Override public String getName();\n    @Override public DynamicWorldData getSnapshot();\n    @Override public StaticWorldData getStaticData();\n    @Override public void handleCommand(String[] command);\n\n    private static CitySimulation sim;\n    private static int seed;\n    private static int agentsPerTeam;\n    private static int steps;\n    private static int step;\n\n}\n\nclass CitySimulationTest {\n\n    private static CitySimulation sim;\n    private static int seed;\n    private static int agentsPerTeam;\n    private static int steps;\n    private static int step;\n\n    @Test\n    public void chargingStationsWork(){\n", "reference": "        //there is at least one charging station in the simulation\n        assert !sim.getWorldState().getChargingStations().isEmpty();\n    }\n\n}", "prediction": "        sim = new CitySimulation();\n        sim.init(steps, new JSONObject(), new HashSet<>());\n        sim.step(step, new HashMap<>());\n        sim.finish();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "82291828_29", "part": [1, 1], "seq": [1, 1], "prompt": "class Weights {\n\n    public static double[] buildRleWeights(List<Number> weightList, int limit) {\n        double[] weights = new double[weightList.size() + (weightList.size() / (limit * 2))];\n\n        double latestValue = Double.POSITIVE_INFINITY;\n        int counter = 0;\n\n        int i = 0;\n        for (Number value : weightList) {\n            if (value.doubleValue() == latestValue || (Double.isNaN(latestValue) && Double.isNaN(value.doubleValue()))) {\n                counter++;\n            } else {\n                if (counter > limit) {\n                    weights[i++] = Double.POSITIVE_INFINITY;\n                    weights[i++] = counter;\n                    weights[i++] = latestValue;\n                    counter = 1;\n                } else {\n                    if (counter > 0) {\n                        for (int j = 0; j < counter; j++) {\n                            weights[i++] = latestValue;\n                        }\n                    }\n                    counter = 1;\n                }\n                latestValue = value.doubleValue();\n            }\n        }\n\n        if (counter > limit) {\n            weights[i++] = Double.POSITIVE_INFINITY;\n            weights[i++] = counter;\n            weights[i++] = latestValue;\n        } else {\n            for (int j = 0; j < counter; j++) {\n                weights[i++] = latestValue;\n            }\n        }\n\n        return Arrays.copyOf(weights, i);\n    }\n\n    public static double[] buildWeights(List<Number> weightList);\n    public static double[] buildRleWeights(double[] weightList, int limit);\n\n}\n\nclass WeightsTest {\n\n    @Test\n    public void rleWithMoreThanOneRepeatedValue() throws Exception {\n", "reference": "        Number[] values = {2.0, 2.0, 4.0, 4.0, 6.0, 6.0};\n        List<Number> weightList = Arrays.asList(values);\n        double[] actuals = Weights.buildRleWeights(weightList, 1);\n        System.out.println(\"actuals = \" + Arrays.toString(actuals));\n        assertArrayEquals(new double[]{\n                Double.POSITIVE_INFINITY, 2.0, 2.0,\n                Double.POSITIVE_INFINITY, 2.0, 4.0,\n                Double.POSITIVE_INFINITY, 2.0, 6.0}, actuals, 0.01);\n    }\n\n}", "prediction": "        List<Number> weightList = Arrays.asList(1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "82448747_0", "part": [1, 1], "seq": [1, 1], "prompt": "class UncommonLetterMap {\n\n    public String getMinifiedWord(String word) {\n        Queue<LetterFreqPair> mostInfreq = new LinkedList<LetterFreqPair>();\n        PriorityQueue<LetterFreqPair> infreqHeap = new PriorityQueue<LetterFreqPair>();\n        for (char letter : word.toCharArray()) {\n            letter = this.sofitMap.containsKey(letter)? this.sofitMap.get(letter) : letter;\n            int ind = letter_freq_list.indexOf(letter);\n            if (ind!= -1) {\n                if (infreqHeap.size() <= this.len_min_word || ind > infreqHeap.peek().freq) {\n                    LetterFreqPair lfp = new LetterFreqPair(letter, ind);\n                    mostInfreq.add(lfp);\n                    infreqHeap.add(lfp);\n                }\n                if (mostInfreq.size() > this.len_min_word) {\n                    mostInfreq.remove(infreqHeap.poll());\n                }\n            }\n        }\n\n        String out = \"\";\n        for (LetterFreqPair lfp : mostInfreq) {\n            out += lfp.getLetter();\n        }\n\n        return out;\n    }\n\n    public  UncommonLetterMap(int len_min_word);\n\n}\n\nclass UncommonLetterMapTest {\n\n    @Test\n    public void TestGetMinifiedWord() throws Exception {\n", "reference": "        UncommonLetterMap ulm = new UncommonLetterMap(3);\n        assertEquals(\"\u05d0\u05d1\u05d2\",ulm.getMinifiedWord(\"\u05d0\u05d1\u05d2\"));\n        assertEquals(\"\u05d1\u05d2\u05d3\",ulm.getMinifiedWord(\"\u05d0\u05d1\u05d2\u05d3\"));\n        assertEquals(\"\u05d3\u05d2\u05d1\",ulm.getMinifiedWord(\"\u05d3\u05d2\u05d1\u05d0\"));\n        assertEquals(\"\u05d3\u05d2\u05d1\",ulm.getMinifiedWord(\"\u05d3\u05d2\u05d0\u05d1\"));\n        assertEquals(\"\u05d2\u05d3\u05d1\",ulm.getMinifiedWord(\"\u05d2\u05d0\u05d3\u05d1\"));\n        assertEquals(\"\u05e6\u05e6\u05e6\",ulm.getMinifiedWord(\"\u05d0\u05e7\u05e8\u05d0\u05dc\u05d7\u05d3\u05d2\u05da\u05db\u05dc\u05d7\u05e6\u05e9\u05db\u05d3\u05d2\u05db\u05e6\u05d3\u05d2\u05db\u05e9\u05d3\u05d2\u05db\u05e9\u05d3\u05d2\u05db\u05e6\u05e6\u05d2\u05db\u05e9\u05d3\u05d2\u05db\u05e6\"));\n        assertEquals(\"\u05d3\u05d2\",ulm.getMinifiedWord(\"\u05d3\u05d2\"));\n        assertEquals(\"\",ulm.getMinifiedWord(\"\"));\n        assertEquals(\"\u05d9\",ulm.getMinifiedWord(\"\u05d9\"));\n    }\n\n}", "prediction": "        UncommonLetterMap um = new UncommonLetterMap(3);\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinifiedWord(\"abc\"));\n        assertEquals(\"abc\", um.getMinified", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "82601803_0", "part": [1, 1], "seq": [1, 1], "prompt": "class SimpleTrial {\n\n    public boolean isTrialPeriodFinished() {\n        return new Date().getTime() >= trialStartTimestamp + trialDurationInMilliseconds;\n    }\n\n    public  SimpleTrial(Context context, Config config);\n\n    public Date getTrialStartDate();\n    private void persistTrialStartTimestamp();\n    public void updateTrialStartDate(Date trialStartDate);\n    private long calculateTrialStartTimestamp();\n\n}\n\nclass SimpleTrialTest {\n\n    @Test\n    public void oldTimestampMustCauseTrialToBeOver() {\n", "reference": "        Context context = mock(Context.class);\n        TrialFactor factor = mock(TrialFactor.class);\n        when(factor.readTimestamp(any(Context.class))).thenReturn(123L);\n\n        SimpleTrial trial = new SimpleTrial(context, new SimpleTrial.Config().factors(factor));\n\n        verify(factor).persistTimestamp(123L, context);\n        assertTrue(trial.isTrialPeriodFinished());\n    }\n\n}", "prediction": "        SimpleTrial trial = new SimpleTrial(context, config);\n        trial.updateTrialStartDate(new Date(System.currentTimeMillis() - 1000000000000L));\n        assertTrue(trial.isTrialPeriodFinished());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "83193705_20", "part": [1, 1], "seq": [1, 1], "prompt": "class BlueTapeDsl {\n\n    public static BindingFunction onClick(@Nullable View.OnClickListener listener) {\n        return view -> view.setOnClickListener(listener);\n    }\n\n    public static BindingFunction composite(@NonNull BindingFunction... functions);\n    public static BindingFunction id(int id, @NonNull BindingFunction... functions);\n    public static BindingFunction text(String text);\n    public static BindingFunction textResource(@StringRes int stringId);\n    public static BindingFunction textColor(@ColorInt int color);\n    public static BindingFunction visible(boolean visible);\n    public static BindingFunction visibility(@Visibility int visibility);\n    public static BindingFunction enabled(boolean enabled);\n    public static BindingFunction checked(boolean checked);\n    public static BindingFunction imageDrawable(@Nullable Drawable drawable);\n    public static BindingFunction imageResource(@DrawableRes int drawableId);\n    public static BindingFunction imageBitmap(@Nullable Bitmap bitmap);\n    @SuppressWarnings(\"deprecation\") public static BindingFunction backgroundDrawable(@Nullable Drawable drawable);\n    public static BindingFunction backgroundResource(@DrawableRes int drawableId);\n    public static BindingFunction onClick(@Nullable ShortenedOnClickListener listener);\n    public static BindingFunction onLongClick(@Nullable View.OnLongClickListener listener);\n    public static BindingFunction onTouch(@Nullable View.OnTouchListener listener);\n    public static BindingFunction onToggle(@Nullable CompoundButton.OnCheckedChangeListener listener);\n    public static BindingFunction onTextChanged(@Nullable OnTextChangedListener listener);\n    public static BindingFunction pass();\n\n    @Mock Context context;\n    @Mock View view;\n    @Mock BindingFunction functionA;\n    @Mock BindingFunction functionB;\n\n}\n\nclass BlueTapeDslTest {\n\n    @Mock Context context;\n    @Mock View view;\n    @Mock BindingFunction functionA;\n    @Mock BindingFunction functionB;\n\n    @Test\n    public void onClick_Shortened() throws Exception {\n", "reference": "        // Given\n        ShortenedOnClickListener listener = mock(ShortenedOnClickListener.class);\n\n        ArgumentCaptor<View.OnClickListener> listenerCaptor = ArgumentCaptor.forClass(View.OnClickListener.class);\n\n        // When\n        BlueTapeDsl\n                .onClick(listener)\n                .bind(view);\n\n        verify(view).setOnClickListener(listenerCaptor.capture());\n        listenerCaptor.getValue().onClick(view);\n\n        // Then\n        verify(listener).onClick();\n    }\n\n}", "prediction": "        ShortenedOnClickListener listener = mock(ShortenedOnClickListener.class);\n        BlueTapeDsl.onClick(listener).apply(view);\n        verify(view).setOnClickListener(listener);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "84286382_23", "part": [1, 1], "seq": [1, 1], "prompt": "class PopUpCoachMarkPresenter {\n\n    protected void setGravityForCoachMarkText(int textAlignmentForPopUpText) {\n        switch (textAlignmentForPopUpText) {\n            case CoachMarkTextGravity.CENTER:\n                mPresentation.setUpGravityForCoachMarkText(CoachMarkTextGravity.CENTER);\n                break;\n            case CoachMarkTextGravity.LEFT:\n                mPresentation.setUpGravityForCoachMarkText(CoachMarkTextGravity.LEFT);\n                break;\n            case CoachMarkTextGravity.RIGHT:\n                mPresentation.setUpGravityForCoachMarkText(CoachMarkTextGravity.RIGHT);\n                break;\n        }\n    }\n\n    public  PopUpCoachMarkPresenter(final IStringResourceProvider stringResourceProvider,\n                                   final IDimensionResourceProvider dimensionResourceProvider,\n                                   final ITypeFaceProvider typeFaceProvider,\n                                   final IScreenInfoProvider screenInfoProvider);\n\n    public void onCreate(CoachMarkBuilder coachMarkBuilder);\n    public void onCreateView(IPopUpCoachMarkPresentation popUpCoachMarkPresentation);\n    public void onViewCreated();\n    public void onDestroyView();\n    public void onDestroy();\n    public void onOkButtonClicked();\n    public void onShimClicked();\n    protected void displayCoachMark();\n    protected void setMessageForCoachMarkText(@StringRes int messageForCoachMarkTextRes);\n    protected void setTypeFaceForDismissButton(@Nullable String fontFileForDismissButton);\n    protected void setTypeFaceForCoachMarkText(@Nullable String fontFileForPopUpText);\n    protected void setNotchDisplayEdge(int position,\n                                     int anchorTopY,\n                                     int anchorBottomY,\n                                     int anchorTopX,\n                                     CoachMarkPixelInfo coachMarkDimenInPixel);\n    protected int getMarginLeftForNotch(double notchPosition, int popUpWidth, int notchDimen);\n    protected int getMarginTopForNotch(double notchPosition, int popUpHeight, int notchDimen);\n    protected void detectAndCreateShimOutViews(@Nullable List<InfoForViewToMask> infoForViewToMaskList);\n    @PopUpPosition protected int findCoachMarkTextPopUpDisplayPosition(Point anchorTop,\n                                                      Point anchorBottom,\n                                                      @PopUpPosition int defaultPopUpPosition,\n                                                      CoachMarkPixelInfo coachMarkDimenInPixel);\n    protected void setImageParamsAndPosition(Point anchorTop, Point anchorBottom,\n                                           int imageWidth, int imageHeight,\n                                           @ColorRes int backGroundTintForImage,\n                                           @DrawableRes int imageDrawableRes);\n    protected void showCoachMark(@DialogDismissButtonPosition int dismissButtonPosition,\n                               @PopUpPosition int popUpPosition);\n    @PopUpPosition protected int getDisplayPosition(Point viewCenterPoint,\n                                   @PopUpPosition int defaultPopUpPosition,\n                                   CoachMarkPixelInfo coachMarkDimenInPixel);\n    protected boolean checkIfLeftPossible(Point viewCenterPoint,\n                                        CoachMarkPixelInfo coachMarkDimenInPixel);\n    protected boolean checkIfRightPossible(Point viewCenterPoint,\n                                         CoachMarkPixelInfo coachMarkDimenInPixel);\n    protected boolean checkIfTopPossible(Point viewCenterPoint,\n                                       CoachMarkPixelInfo coachMarkDimenInPixel);\n    protected boolean checkIfBottomPossible(Point viewCenterPoint,\n                                          CoachMarkPixelInfo coachMarkDimenInPixel);\n    @PopUpPosition protected int getCorrectPositionOfCoachMarkIfDefaultFails(Point viewCenterPoint,\n                                                            CoachMarkPixelInfo coachMarkDimenInPixel);\n    protected CoachMarkPixelInfo createCoachMarkPixelInfo();\n    protected int getActualTopMargin(int centerTopY, CoachMarkPixelInfo coachMarkDimenInPixel);\n    protected int getActualLeftMargin(int anchorTopX, CoachMarkPixelInfo coachMarkDimenInPixel);\n\n    @Mock CoachMarkBuilder mCoachMarkBuilder;\n    @Mock IPopUpCoachMarkPresentation mPopUpCoachMarkPresentation;\n    @Mock IStringResourceProvider mStringResourceProvider;\n    @Mock IDimensionResourceProvider mDimensionResourceProvider;\n    @Mock IScreenInfoProvider mScreenInfoProvider;\n    @Mock ITypeFaceProvider mTypeFaceProvider;\n    @Mock\n    @StringRes int mockedStringRes;\n    @Mock\n    @ColorRes int mockedColorRes;\n    @Mock\n    @DrawableRes int mockedDrawableRes;\n    @Mock CoachMarkLayoutMargin mCoachMarkLayoutMargin;\n    @Mock ImageLayoutInformation mImageLayoutInformation;\n    @Mock\n    @DimenRes int mockedDimenRes;\n    private PopUpCoachMarkPresenter mPopUpCoachMarkPresenter;\n    private CoachMarkPixelInfo mCoachMarkPixelInfo;\n\n}\n\nclass PopUpCoachMarkPresenterTest {\n\n    @Mock CoachMarkBuilder mCoachMarkBuilder;\n    @Mock IPopUpCoachMarkPresentation mPopUpCoachMarkPresentation;\n    @Mock IStringResourceProvider mStringResourceProvider;\n    @Mock IDimensionResourceProvider mDimensionResourceProvider;\n    @Mock IScreenInfoProvider mScreenInfoProvider;\n    @Mock ITypeFaceProvider mTypeFaceProvider;\n    @Mock\n    @StringRes int mockedStringRes;\n    @Mock\n    @ColorRes int mockedColorRes;\n    @Mock\n    @DrawableRes int mockedDrawableRes;\n    @Mock CoachMarkLayoutMargin mCoachMarkLayoutMargin;\n    @Mock ImageLayoutInformation mImageLayoutInformation;\n    @Mock\n    @DimenRes int mockedDimenRes;\n    private PopUpCoachMarkPresenter mPopUpCoachMarkPresenter;\n    private CoachMarkPixelInfo mCoachMarkPixelInfo;\n\n    @Test\n    public void setGravityForCoachMarkTextCenterGravityTest() {\n", "reference": "        mPopUpCoachMarkPresenter.setGravityForCoachMarkText(CoachMarkTextGravity.LEFT);\n\n        Mockito.verify(mPopUpCoachMarkPresentation, Mockito.times(1))\n                .setUpGravityForCoachMarkText(CoachMarkTextGravity.LEFT);\n        Mockito.verifyNoMoreInteractions(mPopUpCoachMarkPresentation);\n    }\n\n}", "prediction": "        mPopUpCoachMarkPresenter.setGravityForCoachMarkText(CoachMarkTextGravity.CENTER);\n        verify(mPopUpCoachMarkPresentation).setUpGravityForCoachMarkText(CoachMarkTextGravity.CENTER);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "84313991_60", "part": [1, 1], "seq": [1, 1], "prompt": "class StandardFunctionFactory {\n\n  public static StandardFunction getByName(String functionName) {\n    StandardFunction standardFunction = ALL.get(functionName.toLowerCase(Locale.ENGLISH));\n    return standardFunction!= null? standardFunction : new UnknownFunction(functionName);\n  }\n\n  private  StandardFunctionFactory();\n\n  public static List<StandardFunction> getAll();\n\n}\n\nclass StandardFunctionFactoryTest {\n\n  @Test\n  public void should_return_a_valid_rotatex_function_object_mix_uppercase_lowercase_test() {\n", "reference": "    StandardFunction function = StandardFunctionFactory.getByName(\"rotateX\");\n    assertEquals(Rotatex.class, function.getClass());\n    assertEquals(function.getName(), \"rotatex\");\n    assertEquals(function.getLinks().size(), 1);\n    assertEquals(function.getLinks().get(0), \"https://drafts.csswg.org/css-transforms/#three-d-transform-functions\");\n    assertEquals(function.isExperimental(), false);\n    assertEquals(function.isObsolete(), false);\n  }\n\n}", "prediction": "    StandardFunction standardFunction = StandardFunctionFactory.getByName(\"ROTATEX\");\n    assertThat(standardFunction).isInstanceOf(RotateXFunction.class);\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "84487370_45", "part": [1, 1], "seq": [1, 1], "prompt": "class ELTComponentPropertyAdapter implements IPropertyAdapter {\n\n\t@Override\n\tpublic void transform() throws ELTComponentPropertyAdapter.EmptyComponentPropertiesException {\n\t\tvalidateRawProperties();\n\t\tfor(hydrograph.ui.common.component.config.Property property : rawProperties){\n\t\t\tProperty tempProperty = transformProperty(property);\n\t\t\tthis.properties.add(tempProperty);\n\t\t} \n\t}\n\n\tpublic  ELTComponentPropertyAdapter(List<hydrograph.ui.common.component.config.Property> rawProperties);\n\n\tprivate void validateRawProperties();\n\tprivate Property transformProperty(\n\t\t\thydrograph.ui.common.component.config.Property property);\n\t@Override public ArrayList<Property> getProperties();\n\n}\n\nclass ELTComponentPropertyAdapterTest {\n\n\t@Test(expected = ELTComponentPropertyAdapter.EmptyComponentPropertiesException.class)\n\tpublic void itShouldThrowEmptyComponentPropertiesExceptionIfRawPropertiesAreEmptyWhileTransformation() {\n", "reference": "\t\t//Given\n\t\t\n\t\t//when\n\t\t\n\t\t\tELTComponentPropertyAdapter eltComponentPropertyAdapter = new ELTComponentPropertyAdapter(null);\n\t\t\teltComponentPropertyAdapter.transform();\t\n\t\t\n\t\t\n\t\t//Then - expect EmptyComponentPropertiesException\n\t}\n\n}", "prediction": "\t\tList<hydrograph.ui.common.component.config.Property> rawProperties = new ArrayList<hydrograph.ui.common.component.config.Property>();\n\t\tELTComponentPropertyAdapter adapter = new ELTComponentPropertyAdapter(rawProperties);\n\t\tadapter.transform();\n\t}", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "84985373_1", "part": [1, 1], "seq": [1, 1], "prompt": "class Particle {\n\n\tpublic Particle() {\n\t\tthis.initParticleWithMass(0.0, 0., 0., 0., 0., 0., 0.);\n\t}\n\n\tpublic  Particle();\n\tpublic  Particle(Particle p);\n\tpublic  Particle(int pid, double px, double py, double pz, double vx, double vy, double vz);\n\tpublic  Particle(int pid, double px, double py, double pz);\n\tpublic  Particle(int pid, double mass, byte charge, double px, double py, double pz, double vx, double vy, double vz);\n\n\tpublic static Particle createWithMassCharge(double mass, int charge,double px, double py, double pz, double vx, double vy, double vz);\n\tpublic static Particle createWithPid(int pid,double px, double py, double pz, double vx, double vy, double vz);\n\tpublic final void initParticleWithMass(double mass, double px, double py, double pz, double vx, double vy, double vz);\n\tpublic final void initParticle(int pid, double px, double py, double pz, double vx, double vy, double vz);\n\tpublic void setP(double mom);\n\tpublic void setTheta(double theta);\n\tpublic void changePid(int pid);\n\tpublic void setParticleWithMass(double mass, byte charge, double px, double py, double pz, double vx, double vy, double vz);\n\tpublic void setVector(int pid, double px, double py, double pz, double vx, double vy, double vz);\n\tpublic double px();\n\tpublic double py();\n\tpublic double pz();\n\tpublic double p();\n\tpublic double theta();\n\tpublic double phi();\n\tpublic double e();\n\tpublic double vx();\n\tpublic double vy();\n\tpublic double vz();\n\tpublic void clearProperties();\n\tpublic void setVector(int pid, Vector3 nvect, Vector3 nvert);\n\tpublic double euclideanDistance(Particle part);\n\tpublic double cosTheta(Particle part);\n\t void initParticleWithMassSquare(double mass2, double px, double py, double pz, double vx, double vy, double vz);\n\tpublic void initParticleWithPidMassSquare(int pid, int charge, double mass2, double px, double py, double pz, double vx, double vy,\n\t        double vz);\n\tpublic void setVector(LorentzVector nvec, Vector3 nvert);\n\tpublic double mass();\n\tpublic double mass2();\n\tpublic int charge();\n\tpublic int pid();\n\tpublic int gid();\n\tpublic LorentzVector vector();\n\tpublic Vector3 vertex();\n\tpublic double getProperty(String pname);\n\tpublic Particle inFrame(Particle parent);\n\tpublic double get(String pname);\n\tpublic boolean hasProperty(String pname);\n\tpublic void setProperty(String pname, double value);\n\tpublic String propertyString();\n\tpublic String toLundString();\n\t@Override public String toString();\n\tpublic void copyParticle(Particle part);\n\tpublic void copy(Particle part);\n\tpublic void combine(Particle cpart, int sign);\n\tpublic Vector3 particleDoca(Particle cpart);\n\n}\n\nclass ParticleTest {\n\n\t@Test\n\tpublic void testParticle() {\n", "reference": "\t\tParticle p = new Particle(11, 0.0, 0.0, 11.0, 0.0, 0.0, 0.0);\n\t\tassertEquals(p.mass(), 0.0005, 1e-4);\n\t\tassertEquals(p.mass2(), 0.0005*0.0005, 1e-4);\n\t\tassertEquals(p.charge(), -1);\n\t\tassertEquals(p.px(), 0.0, 1e-6);\n\t\tassertEquals(p.py(), 0.0, 1e-6);\n\t\tassertEquals(p.pz(), 11.0, 1e-6);\n\t\tassertEquals(p.p(), 11.0, 1e-6);\n\t\tassertEquals(p.theta(), 0.0, 1e-6);\n\t\tassertEquals(p.vertex().x(), 0.0, 1e-6);\n\t\tassertEquals(p.vertex().y(), 0.0, 1e-6);\n\t\tassertEquals(p.vertex().z(), 0.0, 1e-6);\n\t\tassertEquals(p.vx(), 0.0, 1e-6);\n\t\tassertEquals(p.vy(), 0.0, 1e-6);\n\t\tassertEquals(p.vz(), 0.0, 1e-6);\n\n\t\tParticle p2 = new Particle(p);\n\t\tassertEquals(p2.mass(), 0.0005, 1e-4);\n\t\tassertEquals(p2.mass2(), 0.0005*0.0005, 1e-4);\n\t\tassertEquals(p2.charge(), -1);\n\t\tassertEquals(p2.px(), 0.0, 1e-6);\n\t\tassertEquals(p2.py(), 0.0, 1e-6);\n\t\tassertEquals(p2.pz(), 11.0, 1e-6);\n\t\tassertEquals(p2.p(), 11.0, 1e-6);\n\t\tassertEquals(p2.theta(), 0.0, 1e-6);\n\t\tassertEquals(p2.vertex().x(), 0.0, 1e-6);\n\t\tassertEquals(p2.vertex().y(), 0.0, 1e-6);\n\t\tassertEquals(p2.vertex().z(), 0.0, 1e-6);\n\t\tassertEquals(p2.vx(), 0.0, 1e-6);\n\t\tassertEquals(p2.vy(), 0.0, 1e-6);\n\t\tassertEquals(p2.vz(), 0.0, 1e-6);\n\t}\n\n}", "prediction": "\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "87432809_27", "part": [1, 1], "seq": [1, 1], "prompt": "class ForceDriver implements Driver {\n\n    @Override\n    public Connection connect(String url, Properties properties) throws SQLException {\n        if (!acceptsURL(url)) {\n            /*\n             * According to JDBC spec:\n             * > The driver should return \"null\" if it realizes it is the wrong kind of driver to connect to the given URL.\n             * > This will be common, as when the JDBC driver manager is asked to connect to a given URL it passes the URL to each loaded driver in turn.\n             *\n             * Source: https://docs.oracle.com/javase/8/docs/api/java/sql/Driver.html#connect-java.lang.String-java.util.Properties-\n             */\n            return null;\n        }\n        try {\n            Properties connStringProps = getConnStringProperties(url);\n            properties.putAll(connStringProps);\n            ForceConnectionInfo info = new ForceConnectionInfo();\n            info.setUserName(properties.getProperty(\"user\"));\n            info.setPassword(properties.getProperty(\"password\"));\n            info.setSessionId(properties.getProperty(\"sessionId\"));\n            info.setSandbox(resolveSandboxProperty(properties));\n\n            PartnerConnection partnerConnection = ForceService.createPartnerConnection(info);\n            return new ForceConnection(partnerConnection);\n        } catch (ConnectionException | IOException e) {\n            throw new SQLException(e);\n        }\n    }\n\n    private static Boolean resolveSandboxProperty(Properties properties);\n    protected Properties getConnStringProperties(String url);\n    @Override public boolean acceptsURL(String url);\n    @Override public DriverPropertyInfo[] getPropertyInfo(String url, Properties info);\n    @Override public int getMajorVersion();\n    @Override public int getMinorVersion();\n    @Override public boolean jdbcCompliant();\n    @Override public Logger getParentLogger();\n\n    private ForceDriver driver;\n\n}\n\nclass ForceDriverTest {\n\n    private ForceDriver driver;\n\n    @Test\n    public void testConnect_WhenWrongURL() throws  SQLException {\n", "reference": "        Connection connection = driver.connect(\"jdbc:mysql://localhost/test\", new Properties());\n\n        assertNull(connection);\n    }\n\n}", "prediction": "        Connection connection = driver.connect(\"jdbc:force://test.salesforce.com\", new Properties());\n        assertNull(connection);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "87583205_0", "part": [1, 1], "seq": [1, 1], "prompt": "class ServerOption implements Serializable {\n\n\tpublic static Gson getGson() {\n\t\tGson gson = new GsonBuilder().\n\t\t\t\tregisterTypeAdapter(ServerOption.class, new ServerOptionParentDeserializer()).\n\t\t\t\texcludeFieldsWithoutExposeAnnotation().\n\t\t\t\tcreate();\n\t\treturn gson;\n\t}\n\n\tpublic  ServerOption();\n\tpublic  ServerOption(final String title);\n\tpublic  ServerOption(final String title, final String summary);\n\n\tpublic ServerOption getParent();\n\tpublic void setParent(ServerOption parent);\n\tpublic String getTitle();\n\tpublic void setTitle(String title);\n\tpublic String getSummary();\n\tpublic void setSummary(String summary);\n\tpublic List<ServerOption> getEnabledOptionList();\n\tpublic List<ServerOption> getOptionList();\n\tpublic void setOptionList(List<ServerOption> optionList);\n\tpublic void addOption(final ServerOption option);\n\tpublic Map<String, Object> getParameterMap();\n\tpublic void setParameterMap(Map<String, Object> parameterMap);\n\tpublic void addParameter(final String key, final Object value);\n\tpublic List<OptionFunction> getFunctionList();\n\tpublic void setFunctionMap(List<OptionFunction> functionList);\n\tpublic void addFunction(final OptionFunction value);\n\tpublic Map<String, Object> getDependsOnMap();\n\tpublic void setDependsOnMap(Map<String, Object> dependsOnMap);\n\tpublic void addDependsOn(final String key, final Object value);\n\tpublic boolean isEnabled();\n\tpublic void setEnabled(boolean isEnabled);\n\tpublic boolean isChecked();\n\tpublic void setChecked(boolean isChecked);\n\tpublic boolean isDefault();\n\tpublic void setDefault(boolean isDefault);\n\tpublic boolean isInHierarchyBelow(ServerOption option);\n\t@Override public String toString();\n\n}\n\nclass ServerOptionTest  {\n\n\t@Test\n\tpublic void testOptionSelectedParametersWithInheritance() throws Exception {\n", "reference": "\t\tURL url = Thread.currentThread().getContextClassLoader().getResource(\"at/rtr/rmbt/util/model/option/test2.json\");\n\t\tFile file = new File(url.getPath());\n\t\tServerOptionContainer options = new ServerOptionContainer(\n\t\t\t\tnew ArrayList<>(Arrays.asList(ServerOption.getGson().fromJson(new FileReader(file), ServerOption.class))));\n\t\t\n\t\tList<ServerOption> list = options.select(options.getRootOptions().get(0));\n\t\tassertNotNull(\"selected option sublist not null\", list);\n\t\t\n\t\tList<ServerOption> subList = options.select(list.get(0));\n\t\tMap<String, Object> paramMap = options.getSelectedParams();\t\t\n\t\tassertNull(\"selected option 0 sublist is null\", subList);\n\t\tassertEquals(\"selected option 0 param 'option'\", \"a1\", paramMap.get(\"option\"));\n\t\tassertNull(\"selected option 0 dropped param 'title'\", paramMap.get(\"title\"));\n\t\tassertEquals(\"selected option 0 params size\", 2, paramMap.size());\n\t\tassertEquals(\"selected option 0 overriden param 'parent_param'\", true, paramMap.get(\"parent_param\"));\n\n\t\tsubList = options.select(list.get(1));\n\t\tparamMap = options.getSelectedParams();\t\t\n\t\tassertNull(\"selected option 1 sublist is null\", subList);\n\t\tassertEquals(\"selected option 1 param 'option'\", \"a2\", paramMap.get(\"option\"));\n\t\tassertNull(\"selected option 1 dropped param 'title'\", paramMap.get(\"title\"));\n\t\tassertEquals(\"selected option 1 params size\", 2, paramMap.size());\n\t\tassertEquals(\"selected option 1 inherited param 'parent_param'\", false, paramMap.get(\"parent_param\"));\n\n\t\tsubList = options.select(list.get(2));\n\t\tparamMap = options.getSelectedParams();\t\t\n\t\tassertNull(\"selected option 2 sublist is null\", subList);\n\t\tassertEquals(\"selected option 2 param 'option'\", \"a3\", paramMap.get(\"option\"));\n\t\tassertEquals(\"selected option 2 params size\", 4, paramMap.size());\n\t\tassertEquals(\"selected option 2 param 'titles'\", \"a3\", paramMap.get(\"titles\"));\n\t\tassertEquals(\"selected option 2 inherited param 'parent_param'\", false, paramMap.get(\"parent_param\"));\n\t\t\n\t\tsubList = options.select(list.get(3));\n\t\tparamMap = options.getSelectedParams();\t\t\n\t\tassertNull(\"selected option 3 sublist is null\", subList);\n\t\tassertEquals(\"selected option 3 params size\", 1, paramMap.size());\n\t\tassertEquals(\"selected option 3 inherited param 'parent_param'\", false, paramMap.get(\"parent_param\"));\n\t}\n\n}", "prediction": "\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "87590916_4", "part": [1, 1], "seq": [1, 1], "prompt": "class AuthenticationService {\n\n    public static AuthenticationManager getAuthenticationManager() {\n        return authManager;\n    }\n\n    public static String extractDN(X509Certificate clientCert);\n\n}\n\nclass AuthenticationServiceTest {\n\n    @Test\n    public void testX509AuthenticationLogin() {\n", "reference": "        PreAuthenticatedAuthenticationToken token = new PreAuthenticatedAuthenticationToken(\"example.com\",\n                \"doesn't matter what I put here\");\n        Authentication auth = AuthenticationService.getAuthenticationManager().authenticate(token);\n        Collection<? extends GrantedAuthority> authorizations = auth.getAuthorities();\n        authorizations.forEach(a -> {\n            Assert.assertTrue(\n                    a.getAuthority().equals(\"D\") || a.getAuthority().equals(\"E\") || a.getAuthority().equals(\"F\"));\n        });\n    }\n\n}", "prediction": "        X509Certificate clientCert = null;\n        String dn = AuthenticationService.extractDN(clientCert);\n        Assert.assertEquals(\"CN=test, OU=test, O=test, L=test, ST=test, C=test\", dn);\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "87849739_2058", "part": [1, 1], "seq": [1, 1], "prompt": "class PurgeNamespaceReason implements ShutdownReason {\n\n    @Override\n    public JsonObject toJson() {\n        return toJson(FieldType.REGULAR.and(FieldType.notHidden()));\n    }\n\n    private  PurgeNamespaceReason(final String namespaceToPurge);\n\n    public static PurgeNamespaceReason of(final CharSequence namespace);\n    static PurgeNamespaceReason fromJson(final JsonObject jsonObject);\n    @Override public ShutdownReasonType getType();\n    @Override public boolean isRelevantFor(final Object value);\n    @Override public JsonObject toJson(final JsonSchemaVersion schemaVersion, final Predicate<JsonField> predicate);\n    @Override public boolean equals(final Object o);\n    @Override public int hashCode();\n    @Override public String toString();\n\n    private static ShutdownReasonType purgeNamespaceType;\n    private static String knownNamespace;\n    private static JsonObject knownJsonRepresentation;\n    private PurgeNamespaceReason underTest;\n\n}\n\nclass PurgeNamespaceReasonTest {\n\n    private static ShutdownReasonType purgeNamespaceType;\n    private static String knownNamespace;\n    private static JsonObject knownJsonRepresentation;\n    private PurgeNamespaceReason underTest;\n\n    @Test\n    public void toJsonWithHiddenFieldsOnlyReturnsEmptyJsonObject() {\n", "reference": "        assertThat(underTest.toJson(FieldType.HIDDEN)).isEmpty();\n    }\n\n}", "prediction": "        final JsonObject result = underTest.toJson(FieldType.HIDDEN.and(FieldType.notRegular()));\n\n        assertThat(result).isEqualTo(new JsonObject());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "89129558_0", "part": [1, 1], "seq": [1, 1], "prompt": "class Token {\n\n    public static boolean isValid(String token) {\n        if (token == null || token.length() == 0) {\n            return false;\n        }\n\n        int len = token.length();\n\n        for (int i = 0; i < len; ++i) {\n            if (isSeparator(token.charAt(i))) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    public static boolean isSeparator(char ch);\n    public static String unquote(String text);\n    public static String unescape(String text);\n\n}\n\nclass TokenTest {\n\n    @Test\n    public void test004() {\n", "reference": "        isValid(\"abc\");\n    }\n\n}", "prediction": "        String token = \"\";\n        assertTrue(Token.isValid(token));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "89679757_8", "part": [1, 1], "seq": [1, 1], "prompt": "class Election {\n\n    @Override\n    public boolean equals(Object obj) {\n        if(obj instanceof Election) {\n            Election that = (Election) obj;\n            return this.getPlace().equals(that.getPlace()) &&\n                    this.getKind().equals(that.getKind()) &&\n                    this.getAsset().getName().equals(that.getAsset().getName());\n        } else {\n            return false;\n        }\n    }\n\n    public  Election(String kind, String place, Asset asset);\n\n    public String getKind();\n    public String getPlace();\n    public Asset getAsset();\n    public static Election parseElection(Asset a, Context context);\n    @Override public int hashCode();\n    @Override public String toString();\n\n    private Sha256Hash mockHash;\n\n}\n\nclass ElectionTest {\n\n    private Sha256Hash mockHash;\n\n    @Test\n    public void equalsNonEqualKind() throws Exception {\n", "reference": "        Election e1 = new Election(\"Delft\", \"Municipal election\", new Asset(\"G_Delft\", mockHash));\n        Election e2 = new Election(\"Delft\", \"Provincial election\", new Asset(\"G_Delft\", mockHash));\n        assertFalse(e1.equals(e2));\n    }\n\n}", "prediction": "        Election election = new Election(\"kind\", \"place\", new Asset(\"name\", mockHash));\n        Election other = new Election(\"otherKind\", \"place\", new Asset(\"name\", mockHash));\n        assertFalse(election.equals(other));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "89956253_0", "part": [1, 1], "seq": [1, 1], "prompt": "class DashboardSerializer {\n\n    public void write(Dashboard dashboard, Writer writer) throws IOException {\n        try {\n            mapper.writeValue(writer, dashboard);\n        } catch (JsonProcessingException e) {\n            throw new IllegalArgumentException(\"dashboard cannot be serialized to JSON.\" +\n                    \"It might contain non-serializable values.\", e);\n        }\n    }\n\n    public  DashboardSerializer();\n\n    public String toString(Dashboard dashboard);\n    public void write(Dashboard dashboard, OutputStream stream);\n\n    private DashboardSerializer serializer;\n\n}\n\nclass DashboardSerializerTest {\n\n    private DashboardSerializer serializer;\n\n    @Test\n    @Ignore\n    public void printTestDashboard() throws IOException {\n", "reference": "        //System.out.println(serializer.toString(testDashboard()));\n        serializer.write(testDashboard(), System.out);\n    }\n\n}", "prediction": "        Dashboard dashboard = new Dashboard();\n        dashboard.setName(\"test\");\n        dashboard.setWidgets(Arrays.asList(\n                new Widget(\"test1\", \"test1\", \"test1\"),\n                new Widget(\"test2\", \"test2\", \"test2\")\n        ));\n        serializer.write(dashboard, System.out);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "90016934_2", "part": [1, 1], "seq": [1, 1], "prompt": "class DataStoreManager extends DataStores {\n\n   @Deprecated\n   public DataStoreConf create(DataStoreConf dc, boolean save)\n   {\n      getDataStore().add(dc);\n      if (save)\n      {\n         save();\n      }\n      return dc;\n   }\n\n   public DataStoreConf get(String name);\n   public NamedDataStoreConf getNamed(String name);\n   public void createNamed(NamedDataStoreConf namedDsc);\n   public synchronized void delete(DataStoreConf ds);\n   public synchronized void update(final NamedDataStoreConf update);\n   public List<DataStoreConf> getAllDataStoreConfigurations();\n   public List<NamedDataStoreConf> getNamedDataStoreConfigurations();\n   public List<DataStoreConf> getUnnamedDataStoreConfigurations();\n   public synchronized long varyCurrentSize(String dataStoreName, long amount);\n   private void save();\n\n    DataStoreManager dsManager;\n\n}\n\nclass DataStoreManagerTest extends DataStores {\n\n    DataStoreManager dsManager;\n\n   @Test(dependsOnMethods = \"getDataStoresTest\")\n   public void createTest()\n   {\n", "reference": "      HfsDataStoreConf ds = (HfsDataStoreConf) dsManager.get(\"lambda\");\n      Assert.assertNull(ds);\n      HfsDataStoreConf ds2 = new HfsDataStoreConf();\n      ds2 = (HfsDataStoreConf) dsManager.create(ds2, false);\n      ds2.setName(\"lambda\");\n      ds = (HfsDataStoreConf) dsManager.get(\"lambda\");\n      Assert.assertNotNull(ds);\n      Assert.assertEquals(ds.getName(), \"lambda\");\n   }\n\n}", "prediction": "      DataStoreConf dc = new DataStoreConf();\n      dc.setName(\"test\");\n      dc.setPath(\"test\");\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType(DataStoreConf.StoreType.FILE);\n      dc.setStoreType", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "91779577_3", "part": [1, 1], "seq": [1, 1], "prompt": "class Camflake {\n\n    public long next() {\n\n        // elapsedTime\n        long elapsed = getElapsedTime();\n        // sequence\n        int sequence = getSequence(elapsed);\n        log.debug(\"sequence id: {}\", sequence);\n        // If sequence ID exceeded maximum value, it retries once to generate unique ID 2 milliseconds later.\n        if (sequence > SEQUENCE_MAX) {\n            sleep(TimeUnit.MILLISECONDS.toMillis(2L));\n\n            elapsed = getElapsedTime();\n            sequence = getSequence(elapsed);\n            if (sequence > SEQUENCE_MAX) {\n                throw new CamflakeException(\"Failed to issue sequence id.\");\n            }\n        }\n\n        long id = (elapsed << 22) | (sequence << 16) | machineId;\n        log.debug(\"unique id: {}\", id);\n\n        return id;\n    }\n\n    public  Camflake(MachineId machineId, Instant baseTime);\n    public  Camflake(MachineId machineId);\n    public  Camflake();\n\n    private long getElapsedTime();\n    private int getSequence(long elapsed);\n    private void sleep(long durationMillis);\n\n    private static final int SEQUENCE_MAX;\n\n}\n\nclass CamflakeTest {\n\n    private static final int SEQUENCE_MAX;\n\n    @Test\n    public void testNextReturnsExpectedValue() {\n", "reference": "        final Instant baseTime = ZonedDateTime\n            .of(2017, 6, 1, 0, 0, 0, 0, ZoneId.of(\"UTC\"))\n            .toInstant();\n        final Instant execTime = ZonedDateTime\n            .of(2017, 6, 1, 0, 0, 1, 0, ZoneId.of(\"UTC\"))\n            .toInstant();\n        new Expectations(Instant.class) {\n            {\n                Instant.now();\n                returns(\n                    baseTime, // at initialize\n                    execTime  // at runtime\n                );\n            }\n        };\n\n        Camflake camflake = new Camflake(new TestMachineId());\n\n        long id = camflake.next();\n        assertThat(id, is(4194304001L));\n\n    }\n\n}", "prediction": "        Camflake camflake = new Camflake(MachineId.of(1), Instant.now());\n        long id = camflake.next();\n        long expected = 1 << 22 | 1 << 16 | 1;\n        assertEquals(expected, id);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "91855299_92", "part": [1, 1], "seq": [1, 1], "prompt": "class ByteArrayAdapter extends TypeAdapter<byte[]> {\n\n  @Override\n  public byte[] deserialize(byte[] buffer, int bufferPosition) {\n    int length = Serialization.readInt(buffer, bufferPosition);\n    return Serialization.subArray(buffer, bufferPosition + SIZE_OF_INT, bufferPosition + SIZE_OF_INT + length);\n  }\n\n  public  ByteArrayAdapter();\n\n  @Override public byte[] serialize(byte[] data);\n  @Override public int getSerializedSize(byte[] value);\n\n  private final ByteArrayAdapter adapter;\n\n}\n\nclass ByteArrayAdapterTest {\n\n  private final ByteArrayAdapter adapter;\n\n  @Test\n  public void testDecodeEmptyArray() {\n", "reference": "    byte[] buffer = {0, 0, 0, 0};\n    byte[] expected = {};\n    assertArrayEquals(expected, adapter.deserialize(buffer, 0));\n  }\n\n}", "prediction": "    byte[] buffer = new byte[0];\n    byte[] decoded = adapter.deserialize(buffer, 0);\n    assertThat(decoded).isEmpty();\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "92798552_4", "part": [1, 1], "seq": [1, 1], "prompt": "class Kv78Parser {\n\n    public static Kv78Packet parseMessage(String input) {\n        Kv78Packet p = new Kv78Packet();\n        Kv78Table t = null;\n        String[] lines = input.split(CHAR_NEWLINE);\n        String[] headers = null;\n        for (String line : lines) {\n            if (line.startsWith(CHAR_CONTROL)) {\n                String[] columns = line.substring(2).split(\"\\\\|\");\n                switch (line.substring(1,2)) {\n                    case \"G\":\n                        p.setType(columns[0]);\n                        p.setComment(columns[2]);\n                        p.setEncoding(columns[5]);\n                        p.setVersion(columns[6]);\n                        p.setGenerated(ZonedDateTime.parse(columns[7]));\n                        break;\n                    case \"T\":\n                        if (t!= null) {\n                            p.addTable(t);\n                        }\n                        t = new Kv78Table();\n                        t.setTableName(columns[0]);\n                        t.setTableComment(columns[2]);\n                        break;\n                    case \"L\":\n                        headers = columns;\n                        break;\n                    default:\n                        break;\n                }\n            } else {\n                if (headers!= null) {\n                    Map<String, String> record = new HashMap<>();\n                    String[] cells = line.split(CHAR_SPLIT);\n                    for (int i = 0; i < cells.length; i++) {\n                        if (!CHAR_EMPTY.contentEquals(cells[i])) {\n                            record.put(headers[i], cells[i]);\n                        }\n                    }\n                    if (t == null) {\n                        t = new Kv78Table();\n                    }\n                    t.getRecords().add(record);\n                } else {\n                    // Invalid message!\n                    LOGGER.error(\"Failed to parse message\");\n                }\n            }\n        }\n        p.addTable(t);\n        return p;\n    }\n\n}\n\nclass Kv78ParserTest {\n\n    @Test\n    public void parseGeneralMessage() {\n", "reference": "        String data = \"\\\\GKV8turbo_generalmessages|KV8turbo_generalmessages|openOV RET|||UTF-8|0.1|2017-04-11T21:53:25+02:00|\\uFEFF\\r\\n\" +\n                \"\\\\TGENERALMESSAGEUPDATE|GENERALMESSAGEUPDATE|start object\\r\\n\" +\n                \"\\\\LDataOwnerCode|MessageCodeDate|MessageCodeNumber|TimingPointDataOwnerCode|TimingPointCode|MessageType|MessageDurationType|MessageStartTime|MessageEndTime|MessageContent|ReasonType|SubReasonType|ReasonContent|EffectType|SubEffectType|EffectContent|MeasureType|SubMeasureType|MeasureContent|AdviceType|SubAdviceType|AdviceContent|MessageTimeStamp\\r\\n\" +\n                \"RET|2017-04-11|27|ALGEMEEN|31001347|GENERAL|REMOVE|2017-04-11T21:51:08+02:00|\\\\0|Door defect materieel is er op tram 23 een rit uitgevallen. Houd rekening met een extra reistijd tot 15 min.|0|0|\\\\0|0|0|\\\\0|0|6|\\\\0|0|0|\\\\0|2017-04-11T21:53:24+02:00\\r\\n\";\n        Kv78Packet p = Kv78Parser.parseMessage(data);\n\n        Assert.assertEquals(\"KV8turbo_generalmessages\", p.getType());\n        Assert.assertEquals(\"openOV RET\", p.getComment());\n        Assert.assertEquals(\"UTF-8\", p.getEncoding());\n        Assert.assertEquals(\"0.1\", p.getVersion());\n        Assert.assertEquals(ZonedDateTime.parse(\"2017-04-11T21:53:25+02:00\"), p.getGenerated());\n\n        Assert.assertEquals(\"GENERALMESSAGEUPDATE\", p.getTables().get(0).getTableName());\n        Assert.assertEquals(\"start object\", p.getTables().get(0).getTableComment());\n\n        Assert.assertEquals(1, p.getTables().get(0).getRecords().size());\n        Map<String, String> record = p.getTables().get(0).getRecords().get(0);\n        Assert.assertEquals(18, record.size());\n        Assert.assertEquals(\"RET\", record.get(\"DataOwnerCode\"));\n        Assert.assertEquals(\"2017-04-11\", record.get(\"MessageCodeDate\"));\n        Assert.assertEquals(\"27\", record.get(\"MessageCodeNumber\"));\n        Assert.assertEquals(\"ALGEMEEN\", record.get(\"TimingPointDataOwnerCode\"));\n        Assert.assertEquals(\"31001347\", record.get(\"TimingPointCode\"));\n        Assert.assertEquals(\"GENERAL\", record.get(\"MessageType\"));\n        Assert.assertEquals(\"REMOVE\", record.get(\"MessageDurationType\"));\n        Assert.assertEquals(\"2017-04-11T21:51:08+02:00\", record.get(\"MessageStartTime\"));\n        Assert.assertEquals(\"Door defect materieel is er op tram 23 een rit uitgevallen. Houd rekening met een extra reistijd tot 15 min.\", record.get(\"MessageContent\"));\n        Assert.assertEquals(\"0\", record.get(\"ReasonType\"));\n        Assert.assertEquals(\"0\", record.get(\"SubReasonType\"));\n        Assert.assertEquals(\"0\", record.get(\"EffectType\"));\n        Assert.assertEquals(\"0\", record.get(\"SubEffectType\"));\n        Assert.assertEquals(\"0\", record.get(\"MeasureType\"));\n        Assert.assertEquals(\"6\", record.get(\"SubMeasureType\"));\n        Assert.assertEquals(\"0\", record.get(\"AdviceType\"));\n        Assert.assertEquals(\"0\", record.get(\"SubAdviceType\"));\n        Assert.assertEquals(\"2017-04-11T21:53:24+02:00\", record.get(\"MessageTimeStamp\"));\n\n\n    }\n\n}", "prediction": "        String input = \"G|1|Test|1|UTF-8|7.8|2018-01-01T00:00:00Z\";\n        Kv78Packet p = Kv78Parser.parseMessage(input);\n        assertEquals(p.getType(), \"1\");\n        assertEquals(p.getComment(), \"Test\");\n        assertEquals(p.getEncoding(), \"UTF-8\");\n        assertEquals(p.getVersion(), \"7.8\");\n        assertEquals(p.getGenerated(), ZonedDateTime.parse(\"2018-01-01T00:00:00Z\"));\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "93310060_33", "part": [1, 1], "seq": [1, 1], "prompt": "class SpelKeyGenerator extends CachedExpressionEvaluator implements KeyGenerator {\n\n  @Override\n  public List<String> resolveKeys(final String lockKeyPrefix, final String expression, final Object object, final Method method, final Object[] args) {\n    final Object expressionValue = evaluateExpression(expression, object, method, args);\n    final List<String> keys = convertResultToList(expressionValue);\n\n    if (keys.stream().anyMatch(Objects::isNull)) {\n      throw new EvaluationConvertException(\"null keys are not supported: \" + keys);\n    }\n\n    if (StringUtils.isEmpty(lockKeyPrefix)) {\n      return keys;\n    }\n\n    return keys.stream().map(key -> lockKeyPrefix + key).collect(Collectors.toList());\n  }\n\n  protected List<String> convertResultToList(final Object expressionValue);\n  private Object evaluateExpression(final String expression, final Object object, final Method method, final Object[] args);\n  private List<String> iterableToList(final Object expressionValue);\n  private List<String> arrayToList(final Object expressionValue);\n\n  private final KeyGenerator keyGenerator;\n  private final MessageService service;\n  private final Method sendMessageMethod;\n\n}\n\nclass SpelKeyGeneratorTest {\n\n  private final KeyGenerator keyGenerator;\n  private final MessageService service;\n  private final Method sendMessageMethod;\n\n  @Test\n  public void shouldGenerateMultipleKeysFromContextAndVariablesWithList() {\n", "reference": "    final String expression = \"T(com.github.alturkovic.lock.key.SpelKeyGeneratorTest).generateKeys(#message)\";\n    assertThat(keyGenerator.resolveKeys(\"lock_\", expression, service, sendMessageMethod, new Object[]{\"p_\"}))\n      .containsExactly(\"lock_p_first\", \"lock_p_second\");\n  }\n\n}", "prediction": "    final List<String> keys = keyGenerator.resolveKeys(\"prefix\", \"context.id + ':' + variable\", new Object(), null, new Object[] { \"value\" });\n\n    assertThat(keys).containsExactly(\"prefix1:value\", \"prefix2:value\");\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "94076429_1", "part": [1, 1], "seq": [1, 1], "prompt": "class CmdWsCaller {\n\n    public static void main(String[] args) {\n        Options opt = new Options();\n        opt.addOption(\"ak\", true, \"accessKey, \u53ef\u9009\");\n        opt.addOption(\"sk\", true, \"secretKey, \u53ef\u9009\");\n        opt.addOption(\"api\", true, \"\u670d\u52a1\u540d, \u53ef\u9009\");\n        opt.addOption(\"version\", true, \"\u670d\u52a1\u7248\u672c, \u53ef\u9009\");\n\t\topt.addOption(\"wa\", true, \"wsdl\u5730\u5740\uff0ce.g: http://broker-ip:9081/api/version/method?wsdl\");\n        opt.addOption(\"ea\", true, \"endpoint\u5730\u5740\uff0ce.g: http://broker-ip:9081/api/version/method\");\n        opt.addOption(\"ns\", true, \"\u5728wsdl\u4e2d\u5b9a\u4e49\u7684\u670d\u52a1\u7684target namespace\");\n        opt.addOption(\"sname\", \"serviceName\", true, \"\u5728wsdl\u4e2d\u5b9a\u4e49\u7684\u670d\u52a1\u540d\");\n        opt.addOption(\"pname\", \"portName\", true, \"\u5728wsdl\u4e2d\u5b9a\u4e49\u7684\u7aef\u53e3\u540d\");\n        opt.addOption(\"action\", \"SOAPAction\", true, \"SOAPAction\u503c\");\n        opt.addOption(\"soap12\", false, \"-soap12 \u4e3asoap12\u8c03\u7528, \u4e0d\u5b9a\u4e49\u4e3asoap11\");\n        opt.addOption(\"nonce\", false, \"-nonce \u662f\u5426\u505anonce\u9632\u91cd\u653e\u5904\u7406\uff0c\u4e0d\u5b9a\u4e49\u4e3a\u4e0d\u505anonce\u91cd\u653e\u5904\u7406\");\n        opt.addOption(\"skipTimestamp\", false, \"-skipTimestamp \u4e0d\u8bbe\u7f6e\u65f6\u95f4\u6233\uff0c\u9ed8\u8ba4\u662f\u8bbe\u7f6e\");\n        opt.addOption(\"fingerStr\", true, \"\u7b7e\u540d\u6307\u7eb9\u4e32, \u53ef\u9009\");\n        opt.addOption(\"H\", true, \"http header, \u683c\u5f0f: -H \\\"key:value\\\"\");\n        opt.addOption(\"h\", \"help\", false, \"\u6253\u5370\u5e2e\u52a9\u4fe1\u606f\");\n        opt.addOption(\"d\", \"debug\", false, \"\u6253\u5370\u8c03\u8bd5\u4fe1\u606f\");\n        opt.addOption(\"rf\", true, \"soap\u8bf7\u6c42\u6587\u4ef6\uff0c\u6587\u4ef6\u91cc\u5b58\u50a8soap\u8bf7\u6c42\u7684Message\u683c\u5f0f\u5185\u5bb9\");\n        opt.addOption(\"rd\", true, \"soap\u8bf7\u6c42\u5185\u5bb9(Message)\uff0c\u5982\u679c\u8bbe\u7f6e\u8be5\u9009\u9879\u65f6\uff0c-rf\u9009\u9879\u88ab\u5ffd\u7565\");\n        opt.addOption(\"sdkv\", \"sdk-version\", false, \"sdk\u7248\u672c\");\n        opt.addOption(\"bizIdKey\", true, \"\u4e1a\u52a1id Key\");\n        opt.addOption(\"bizId\", true, \"\u4e1a\u52a1id\");\n\n        CommandLineParser parser = new DefaultParser();\n\n        Boolean isDebug = false;\n        try {\n            CommandLine commandline = parser.parse(opt, args);\n            if (commandline.hasOption(\"h\") || commandline.getOptions().length == 0) {\n                usage(opt);\n                return;\n            }\n\n            String ak = commandline.getOptionValue(\"ak\");\n            String sk = commandline.getOptionValue(\"sk\");\n            String api = commandline.getOptionValue(\"api\");\n            String version = commandline.getOptionValue(\"version\");\n            Boolean sdkv = commandline.hasOption(\"sdkv\");\n            String ea = commandline.getOptionValue(\"ea\");\n            String ns = commandline.getOptionValue(\"ns\");\n            String sname = commandline.getOptionValue(\"sname\");\n            String pname = commandline.getOptionValue(\"pname\");\n            String action = commandline.getOptionValue(\"action\");\n            String rf = commandline.getOptionValue(\"rf\");\n            String rd = commandline.getOptionValue(\"rd\");\n            String fingerStr = commandline.getOptionValue(\"fingerStr\");\n            String[] headers = commandline.getOptionValues(\"H\");\n            boolean isSoap12 = commandline.hasOption(\"soap12\");\n            boolean nonce = commandline.hasOption(\"nonce\");\n            boolean skipTimestamp = commandline.hasOption(\"skipTimestamp\");\n            isDebug = commandline.hasOption(\"d\");\n            String bizIdKey = commandline.getOptionValue(\"bizIdKey\");\n            String bizId = commandline.getOptionValue(\"bizId\");\n\n            if (sdkv) {\n                Version.version();\n                return;\n            }\n\n            if (isDebug) {\n                // printParams();\n                System.out.println(\"ak=\" + ak);\n                System.out.println(\"sk=\" + sk);\n                System.out.println(\"api=\" + api);\n                System.out.println(\"version=\" + version);\n                System.out.println(\"bizIdKey=\" + bizIdKey);\n                System.out.println(\"bizId=\" + bizId);\n                System.out.println(\"isSoap12=\" + isSoap12);\n                System.out.println(\"nonce=\" + nonce);\n                System.out.println(\"ea=\" + ea);\n                System.out.println(\"ns=\" + ns);\n                System.out.println(\"sname=\" + sname);\n                System.out.println(\"pname=\" + pname);\n                System.out.println(\"action=\" + action);\n                System.out.println(\"headers=\" + Arrays.toString(headers));\n                System.out.println(\"rd=\" + rd);\n                if (isEmpty(rd)) {\n                    System.out.println(\"rf=\" + rf);\n                }\n                System.out.println(\"nonce=\" + nonce);\n                System.out.println(\"skipTimestamp=\" + skipTimestamp);\n                System.out.println(\"fingerStr=\" + fingerStr);\n            }\n\n            if (isEmpty1(ea, \"-ea endpoint\u5730\u5740\")) {\n                usage(opt);\n                return;\n            }\n\n            if (isEmpty1(ea, \"-ns namespace\")) {\n                usage(opt);\n                return;\n            }\n\n            if (isEmpty1(ea, \"-sname serviceName\")) {\n                usage(opt);\n                return;\n            }\n\n            if (isEmpty1(pname, \"-pname portName\")) {\n                usage(opt);\n                return;\n            }\n\n            if (isEmpty1(pname, \"-action SOAPAction\")) {\n                usage(opt);\n                return;\n            }\n\n            if (isEmpty(rf) && isEmpty(rd)) {\n                System.out.println(\"-rf \u6216 -rd \u53c2\u6570\u6ca1\u6709\u5b9a\u4e49\");\n                usage(opt);\n                return;\n            }\n\n            String reqData = (isEmpty(rd))? FileUtils.readFileToString(new File(rf)) : rd;\n            print(isDebug, \"-- \u8bf7\u6c42\u62a5\u6587: \\n%s\\n\", reqData);\n            if (isEmpty(reqData)) {\n                print(true, \"-- \u64cd\u4f5c\u5931\u8d25\uff1a\u6587\u4ef6%s\u8bf7\u6c42\u62a5\u6587\u4e3a\u7a7a\", rf);\n                return;\n            }\n            if (bizIdKey!= null &&!bizIdKey.trim().equals(\"\")) {\n                WSClientSDK.bizIdKey(bizIdKey);\n            }\n            WSParams params = WSParams.create().accessKey(ak).secretKey(sk).fingerPrinter(fingerStr)\n                   .api(api).bizId(bizId).version(version).nonce(nonce).timestamp(!skipTimestamp).debug(isDebug);\n\n            Map<String, String> httpHeaders = new HashMap<String, String>();\n\n            if (headers!= null) {\n                for (String header : headers) {\n                    String[] kv = header.split(\":\", 2);\n                    if (kv == null || kv.length!= 2) {\n                        System.out.println(\"\u9519\u8bef\u7684HTTP\u5934\u5b9a\u4e49 \u6b63\u786e\u683c\u5f0f: -H \\\"key:value\\\"!!\" + header);\n                        return;\n                    }\n                    httpHeaders.put(kv[0], kv[1]);\n                }\n            }\n\n            invokeWithDispath(params, ns, sname, pname, action, isSoap12, ea, reqData, httpHeaders);\n        } catch (Exception e) {\n            System.out.println(\"-- \u64cd\u4f5c\u5931\u8d25\uff1a\" + e.getMessage());\n            if (isDebug)\n                e.printStackTrace(System.out);\n        }\n    }\n\n    private static void usage(Options opt);\n    private static boolean isEmpty1(String str, String msg);\n    private static boolean isEmpty(String str);\n    private static void print(boolean debug, String format, Object args);\n    private static void invokeWithDispath(WSParams params, String ns, String sname,\n                                          String pname, String soapActionUri, boolean isSoap12, String ea, String reqSoap, Map<String, String> requestHeaders);\n\n    private static final String reqSoap;\n    private static final String reqSoap2;\n\n}\n\nclass CmdWsCallerTest {\n\n    private static final String reqSoap;\n    private static final String reqSoap2;\n\n    @Test\n    public void testCmdWsCaller2() {\n", "reference": "        String[] args = {\n                \"-ak\", \"ak\",\n                \"-sk\", \"sk\",\n                \"-api\", \"PING\",\n                \"-version\", \"vcsb\",\n                \"-ea\", \"http://localhost:9081/PING/vcsb/ws2restful\",\n                \"-ns\", \"http://webservices.amazon.com/AWSECommerceService/2011-08-01\",\n                \"-sname\", \"AWSECommerceService\",\n                \"-pname\", \"AWSECommerceServicePortType\",\n                \"-action\", \"http://soap.amazon.com/CartAdd\",\n                \"-d\",\n                \"-rd\", reqSoap2\n\n        };\n        CmdWsCaller.main(args);\n    }\n\n}", "prediction": "        CmdWsCaller.main(new String[] { \"-ak\", \"ak\", \"-sk\", \"sk\", \"-api\", \"api\", \"-version\", \"version\", \"-ea\",\n                \"http://127.0.0.1:9081/api/version/method\", \"-ns\", \"http://www.w3.org/2003/05/soap-envelope\", \"-sname\",\n                \"serviceName\", \"-pname\", \"portName\", \"-action\", \"http://www.w3.org/2003/05/soap-envelope/role/anonymous\",\n                \"-rf\", \"src/test/resources/soap.xml\" });\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "94255167_7", "part": [1, 1], "seq": [1, 1], "prompt": "class TextInstructions {\n\n  public String compile(LegStep step) {\n    if (step.getManeuver() == null) {\n      throw new RuntimeException(\"No step maneuver provided.\");\n    }\n\n    String type = step.getManeuver().getType();\n    String modifier = step.getManeuver().getModifier();\n    String mode = step.getMode();\n\n    if (TextUtils.isEmpty(type)) {\n      throw new RuntimeException(\"Missing step maneuver type.\");\n    }\n\n    if (!type.equals(\"depart\") &&!type.equals(\"arrive\") && TextUtils.isEmpty(modifier)) {\n      throw new RuntimeException(\"Missing step maneuver modifier.\");\n    }\n\n    if (getVersionObject().getAsJsonObject(type) == null) {\n      // Log for debugging\n      logger.log(Level.FINE, \"Encountered unknown instruction type: \" + type);\n\n      // OSRM specification assumes turn types can be added without\n      // major version changes. Unknown types are to be treated as\n      // type `turn` by clients\n      type = \"turn\";\n    }\n\n    // Use special instructions if available, otherwise `defaultinstruction`\n    JsonObject instructionObject;\n    JsonObject modeValue = getVersionObject().getAsJsonObject(\"modes\").getAsJsonObject(mode);\n    if (modeValue!= null) {\n      instructionObject = modeValue;\n    } else {\n      JsonObject modifierValue = getVersionObject().getAsJsonObject(type).getAsJsonObject(modifier);\n      instructionObject = modifierValue == null\n       ? getVersionObject().getAsJsonObject(type).getAsJsonObject(\"default\")\n        : modifierValue;\n    }\n\n    // Special case handling\n    JsonPrimitive laneInstruction = null;\n    switch (type) {\n      case \"use lane\":\n        laneInstruction = getVersionObject().getAsJsonObject(\"constants\")\n         .getAsJsonObject(\"lanes\").getAsJsonPrimitive(laneConfig(step));\n        if (laneInstruction == null) {\n          // If the lane combination is not found, default to continue straight\n          instructionObject = getVersionObject().getAsJsonObject(\"use lane\")\n           .getAsJsonObject(\"no_lanes\");\n        }\n        break;\n      case \"rotary\":\n      case \"roundabout\":\n        if (!TextUtils.isEmpty(step.getRotaryName())\n          && step.getManeuver().getExit()!= null\n          && instructionObject.getAsJsonObject(\"name_exit\")!= null) {\n          instructionObject = instructionObject.getAsJsonObject(\"name_exit\");\n        } else if (step.getRotaryName()!= null && instructionObject.getAsJsonObject(\"name\")!= null) {\n          instructionObject = instructionObject.getAsJsonObject(\"name\");\n        } else if (step.getManeuver().getExit()!= null && instructionObject.getAsJsonObject(\"exit\")!= null) {\n          instructionObject = instructionObject.getAsJsonObject(\"exit\");\n        } else {\n          instructionObject = instructionObject.getAsJsonObject(\"default\");\n        }\n        break;\n      default:\n        // NOOP, since no special logic for that type\n    }\n\n    // Decide way_name with special handling for name and ref\n    String wayName;\n    String name = TextUtils.isEmpty(step.getName())? \"\" : step.getName();\n    String ref = TextUtils.isEmpty(step.getRef())? \"\" : step.getRef().split(\";\")[0];\n\n    // Remove hacks from Mapbox Directions mixing ref into name\n    if (name.equals(step.getRef())) {\n      // if both are the same we assume that there used to be an empty name, with the ref being filled in for it\n      // we only need to retain the ref then\n      name = \"\";\n    }\n    name = name.replace(\" (\" + step.getRef() + \")\", \"\");\n\n    if (!TextUtils.isEmpty(name) &&!TextUtils.isEmpty(ref) &&!name.equals(ref)) {\n      wayName = name + \" (\" + ref + \")\";\n    } else if (TextUtils.isEmpty(name) &&!TextUtils.isEmpty(ref)) {\n      wayName = ref;\n    } else {\n      wayName = name;\n    }\n\n    // Decide which instruction string to use\n    // Destination takes precedence over name\n    String instruction;\n    if (!TextUtils.isEmpty(step.getDestinations())\n      && instructionObject.getAsJsonPrimitive(\"destination\")!= null) {\n      instruction = instructionObject.getAsJsonPrimitive(\"destination\").getAsString();\n    } else if (!TextUtils.isEmpty(wayName)\n      && instructionObject.getAsJsonPrimitive(\"name\")!= null) {\n      instruction = instructionObject.getAsJsonPrimitive(\"name\").getAsString();\n    } else {\n      instruction = instructionObject.getAsJsonPrimitive(\"default\").getAsString();\n    }\n\n    if (getTokenizedInstructionHook()!= null) {\n      instruction = getTokenizedInstructionHook().change(instruction);\n    }\n\n    // Replace tokens\n    // NOOP if they don't exist\n    String nthWaypoint = \"\"; // TODO, add correct waypoint counting\n    JsonPrimitive modifierValue =\n      getVersionObject().getAsJsonObject(\"constants\").getAsJsonObject(\"modifier\").getAsJsonPrimitive(modifier);\n    instruction = instruction\n     .replace(\"{way_name}\", wayName)\n     .replace(\"{destination}\", TextUtils.isEmpty(step.getDestinations())? \"\" : step.getDestinations().split(\",\")[0])\n     .replace(\"{exit_number}\",\n        step.getManeuver().getExit() == null? ordinalize(1) : ordinalize(step.getManeuver().getExit()))\n     .replace(\"{rotary_name}\", TextUtils.isEmpty(step.getRotaryName())? \"\" : step.getRotaryName())\n     .replace(\"{lane_instruction}\", laneInstruction == null? \"\" : laneInstruction.getAsString())\n     .replace(\"{modifier}\", modifierValue == null? \"\" : modifierValue.getAsString())\n     .replace(\"{direction}\", directionFromDegree(step.getManeuver().getBearingAfter()))\n     .replace(\"{nth}\", nthWaypoint)\n     .replaceAll(\"\\\\s+\", \" \"); // remove excess spaces\n\n    if (getRootObject().getAsJsonObject(\"meta\").getAsJsonPrimitive(\"capitalizeFirstLetter\").getAsBoolean()) {\n      instruction = capitalizeFirstLetter(instruction);\n    }\n\n    return instruction;\n  }\n\n  public  TextInstructions(String language, String version);\n\n  public TokenizedInstructionHook getTokenizedInstructionHook();\n  public void setTokenizedInstructionHook(TokenizedInstructionHook tokenizedInstructionHook);\n  public JsonObject getRootObject();\n  public JsonObject getVersionObject();\n  public static String capitalizeFirstLetter(String text);\n  public String ordinalize(Integer number);\n  public String directionFromDegree(Double degree);\n  public String laneConfig(LegStep step);\n\n  @Rule\n  public ExpectedException thrown;\n\n}\n\nclass TextInstructionsTest  {\n\n  @Rule\n  public ExpectedException thrown;\n\n  @Test\n  public void testFixturesMatchGeneratedInstructions() throws IOException {\n", "reference": "    for (String fixture : TextInstructionsFixtures.FIXTURES) {\n      String body = loadJsonFixture(fixture);\n      FixtureModel model = new Gson().fromJson(body, FixtureModel.class);\n      for (Object entry : model.getInstructions().entrySet()) {\n        Map.Entry pair = (Map.Entry) entry;\n        String language = (String) pair.getKey();\n        String compiled = (String) pair.getValue();\n        assertEquals(compiled, new TextInstructions(language, \"v5\").compile(model.getStep()));\n      }\n    }\n  }\n\n}", "prediction": "    String[] fixtureFiles = {\n      \"fixtures/v5/en/instructions/depart.json\",\n      \"fixtures/v5/en/instructions/arrive.json\",\n      \"fixtures/v5/en/instructions/turn.json\",\n      \"fixtures/v5/en/instructions/use_lane.json\",\n      \"fixtures/v5/en/instructions/rotary.json\",\n      \"fixtures/v5/en/instructions/roundabout.json\"\n    };\n\n    for (String fixtureFile : fixtureFiles) {\n      String fixture = loadFixture(fixtureFile);\n      JsonObject fixtureObject = new JsonParser().parse(fixture).getAsJsonObject();\n\n      String instruction = new TextInstructions(\"en\", \"5\").compile(fixtureObject.getAsJsonObject(\"step\"));\n\n      assertEquals(fixtureObject.getAsJsonObject(\"instruction\").getAsString(), instruction);\n    }\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "94549931_2", "part": [1, 1], "seq": [1, 1], "prompt": "class Main {\n\n    public static <T extends AbstractCommand> T parseCommandLine(String[] args) throws Exception {\n        CommandContext cm = new CommandContext();\n        JCommander jc = JCommander.newBuilder()\n               .programName(\"blobit.sh\")\n               .addObject(cm)\n               .addCommand(\"createbucket\", new CommandCreateBucket(cm))\n               .addCommand(\"deletebucket\", new CommandDeleteBucket(cm))\n               .addCommand(\"gcbucket\", new CommandGcBucket(cm))\n               .addCommand(\"listbuckets\", new CommandListBuckets(cm))\n               .addCommand(\"put\", new CommandPut(cm))\n               .addCommand(\"get\", new CommandGet(cm))\n               .addCommand(\"stat\", new CommandStat(cm))\n               .addCommand(\"ls\", new CommandLs(cm))\n               .addCommand(\"help\", new CommandHelp(cm))\n               .build();\n        cm.jCommander = jc;\n        try {\n            jc.parse(args);\n        } catch (ParameterException err) {\n            System.out.println(\"Error: \" + err.getMessage());\n            return (T) new CommandHelp(cm);\n        }\n        if (jc.getParsedCommand() == null) {\n            return (T) new CommandHelp(cm);\n        }\n        return (T) jc.getCommands().get(jc.getParsedCommand()).getObjects().get(0);\n    }\n\n    public static void main(String... args);\n\n}\n\nclass MainTest {\n\n    @Test\n    public void testNoCommand() throws Exception {\n", "reference": "        CommandHelp cl = Main.parseCommandLine(new String[]{});\n        System.out.println(\"res:\" + cl);\n        assertTrue(cl instanceof CommandHelp);\n    }\n\n}", "prediction": "        Main.parseCommandLine(new String[0]);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "95081481_1009", "part": [1, 1], "seq": [1, 1], "prompt": "class OspfConfigUtil {\n\n    public static List<OspfProcess> processes(JsonNode jsonNodes) {\n        List<OspfProcess> ospfProcesses = new ArrayList<>();\n        if (jsonNodes == null) {\n            return ospfProcesses;\n        }\n        //From each Process nodes, get area and related interface details.\n        jsonNodes.forEach(jsonNode -> {\n            List<OspfArea> areas = new ArrayList<>();\n            //Get configured areas for the process.\n            for (JsonNode areaNode : jsonNode.path(AREAS)) {\n                List<OspfInterface> interfaceList = new ArrayList<>();\n                for (JsonNode interfaceNode : areaNode.path(INTERFACE)) {\n                    OspfInterface ospfInterface = interfaceDetails(interfaceNode);\n                    if (ospfInterface!= null) {\n                        interfaceList.add(ospfInterface);\n                    }\n                }\n                //Get the area details\n                OspfArea area = areaDetails(areaNode);\n                if (area!= null) {\n                    area.setOspfInterfaceList(interfaceList);\n                    areas.add(area);\n                }\n            }\n            OspfProcess process = new OspfProcessImpl();\n            process.setProcessId(jsonNode.path(PROCESSID).asText());\n            process.setAreas(areas);\n            ospfProcesses.add(process);\n        });\n\n        return ospfProcesses;\n    }\n\n    private  OspfConfigUtil();\n\n    private static Ip4Address getInterfaceIp(int interfaceIndex);\n    private static String getInterfaceMask(int interfaceIndex);\n    private static boolean isValidDigit(String strInput);\n    private static boolean isPrimitive(String value);\n    private static boolean isBoolean(String value);\n    private static boolean isValidIpAddress(String value);\n    private static OspfArea areaDetails(JsonNode areaNode);\n    private static OspfInterface interfaceDetails(JsonNode interfaceNode);\n\n    private ObjectMapper mapper;\n    private JsonNode jsonNode;\n    private List<OspfProcess> ospfProcessList;\n    private String jsonString;\n\n}\n\nclass OspfConfigUtilTest {\n\n    private ObjectMapper mapper;\n    private JsonNode jsonNode;\n    private List<OspfProcess> ospfProcessList;\n    private String jsonString;\n\n    @Test\n    public void testProcesses() throws Exception {\n", "reference": "        jsonNode.path(\"areas\");\n        ospfProcessList = OspfConfigUtil.processes(jsonNode);\n        assertThat(ospfProcessList, is(notNullValue()));\n    }\n\n}", "prediction": "        List<OspfProcess> ospfProcesses = OspfConfigUtil.processes(jsonNode);\n        Assert.assertEquals(ospfProcesses.size(), 1);\n        Assert.assertEquals(ospfProcesses.get(0).getProcessId(), \"1\");\n        Assert.assertEquals(ospfProcesses.get(0).getAreas().size(), 1);\n        Assert.assertEquals(ospfProcesses.get(0).getAreas().get(0).getAreaId(), \"0.0.0.0\");\n        Assert.assertEquals(ospfProcesses.get(0).getAreas().get(0).getOspfInterfaceList().size(), 1);\n        Assert.assertEquals(ospfProcesses.get(0).getAreas().get(0).getOspfInterfaceList().get(0).getInterfaceId(), \"1\");\n        Assert.assertEquals(ospfProcesses.get(0).getAreas().get(0).getOspfInterfaceList().get(0).getInterfaceIp(), Ip4Address.valueOf(\"10.10.10.10\"));\n        Assert.assertEquals(ospfProcesses.get(0", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "95800582_12", "part": [1, 1], "seq": [1, 1], "prompt": "class ListUtils {\n\n    public static <Item> SparseIntArray getReorderings(List<? extends Item> oldList, List<? extends Item> newList){\n        List<Pair<Integer, Integer>> moveList = calculateMoves(oldList, newList);\n        List<Integer> netMoveScores = calculateNetMoveScores(moveList);\n        SparseIntArray reorderings = new SparseIntArray();\n        while(extractReordering(moveList, netMoveScores, reorderings));\n        return reorderings;\n    }\n\n    public static SparseBooleanArray getInsertions(@Nullable List<? extends Item> oldList, @NonNull List<? extends Item> newList);\n    public static SparseBooleanArray getDeletions(@Nullable List<? extends Item> oldList, @NonNull List<? extends Item> newList);\n    private static List<Pair<Integer, Integer>> calculateMoves(List<? extends Item> oldList, List<? extends Item> newList);\n    private static List<Integer> calculateNetMoveScores(List<Pair<Integer, Integer>> moveList);\n    private static boolean extractReordering(List<Pair<Integer, Integer>> moveList, List<Integer> netMoveScores, SparseIntArray reorderings);\n    private static String generateString(List<Pair<Integer, Integer>> moveList);\n    private static void cleanNetMoveList(List<Integer> netMoveScores, List<Pair<Integer, Integer>> moveList);\n    private static int indexOfHighestNetMove(List<Integer> netMoveScores);\n    private static List<Integer> getNewIndicesOfOldIndicesAboveIndex(Integer index, List<Pair<Integer, Integer>> moveList);\n\n    private static final List<Integer> list05;\n    private static final List<Integer> list15;\n    private static final List<Integer> list06;\n    private static final List<Integer> listFlip;\n    private static final List<Integer> listGap;\n    private static final List<Integer> listMultiReorder;\n    private static final List<Integer> listSwap;\n\n}\n\nclass ListUtilsTest {\n\n    private static final List<Integer> list05;\n    private static final List<Integer> list15;\n    private static final List<Integer> list06;\n    private static final List<Integer> listFlip;\n    private static final List<Integer> listGap;\n    private static final List<Integer> listMultiReorder;\n    private static final List<Integer> listSwap;\n\n    @Test\n    public void testReorderSwap() {\n", "reference": "        SparseIntArray reorderings = ListUtils.getReorderings(list05, listSwap);\n        assertThat(reorderings.size(), is(2));\n        assertThat(reorderings.get(5), is(0));\n        assertThat(reorderings.get(0), is(5));\n    }\n\n}", "prediction": "        SparseIntArray reorderings = ListUtils.getReorderings(listSwap, listSwap);\n        assertEquals(1, reorderings.size());\n        assertEquals(1, reorderings.get(0));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "96120606_68", "part": [1, 1], "seq": [1, 1], "prompt": "class Command implements Serializable {\n\n\tpublic void validate() {\n\t\tOptional.ofNullable(getAction())\n\t\t\t.orElseThrow(()->new InvalidConfigException(String.format(MISSING_COMMAND_ARGUMENTS_MSG, getAbsoluteUri(), \"Action\")));\n\t\t\n\t\tif(CollectionUtils.isEmpty(getBehaviors()))\n\t\t\tthrow new InvalidConfigException(String.format(MISSING_COMMAND_ARGUMENTS_MSG, getAbsoluteUri(), \"Behavior\"));\n\t\t\n\t\tvalidateCommandArgument(Type.ClientAlias);\n\t\tvalidateCommandArgument(Type.AppAlias);\n\t\tvalidateCommandArgument(Type.PlatformMarker);\n\t\tvalidateCommandArgument(Type.DomainAlias);\n\t}\n\n\tpublic  Command(String absoluteUri);\n\tpublic  Command(Command source);\n\n\tpublic CollectionsTemplate<List<Behavior>, Behavior> templateBehaviors();\n\tprivate void validateCommandArgument(Type type);\n\tprivate String getMissingArgumentErrorMsg(Type type);\n\tpublic boolean isRootDomainOnly();\n\tpublic CommandElementLinked root();\n\tpublic boolean isEvent();\n\tpublic Command createRootDomainCommand();\n\tpublic String getAliasUri(Type type);\n\tpublic RefId<?> getRefId(Type type);\n\tpublic String getAbsoluteUri(Type type);\n\tpublic String getAlias(Type type);\n\tpublic Optional<CommandElementLinked> getElement(Type type);\n\tpublic CommandElementLinked getElementSafely(Type type);\n\tpublic String getRelativeUri(String input);\n\tpublic boolean isView();\n\tpublic String getAppAlias();\n\tpublic String getRootClientAlias();\n\tpublic CommandElement getRootDomainElement();\n\tpublic String getRootDomainAlias();\n\tpublic String getRootDomainUri();\n\tpublic String getAbsoluteDomainAlias();\n\tpublic String getAbsoluteDomainUri();\n\tpublic String getProcessAlias();\n\tpublic String getProcessUri();\n\tpublic String getAbsoluteAlias();\n\tpublic String getAbsoluteAliasWithAction();\n\tpublic String getAbsoluteAliasTillRootDomain();\n\tpublic String buildAlias(CommandElementLinked startElem);\n\tpublic String buildAlias(Type endWhentype);\n\tpublic String buildAlias(CommandElementLinked startElem, Type endWhentype);\n\tpublic String buildUri(CommandElementLinked startElem);\n\tpublic String buildUri(Type endWhenType);\n\tpublic String buildUri(CommandElementLinked startElem, Type endWhenType);\n\tpublic String traverseElements(CommandElementLinked startElem, BiConsumer<CommandElement, StringBuilder> cb);\n\tpublic void traverseElements(CommandElementLinked startElem, Consumer<CommandElement> cb);\n\tpublic String traverseElements(CommandElementLinked startElem, Type type, BiConsumer<CommandElement, StringBuilder> cb);\n\tpublic void traverseElements(CommandElementLinked startElem, Type type, Consumer<CommandElement> cb);\n\tpublic CommandElementLinked createRoot(Type type, String uri);\n\tpublic String toUri();\n\tpublic String toRemoteUri(Type endWhenType, Action withAction, Behavior withBehavior);\n\tprivate void addRequestParamsToUri(StringBuilder sb);\n\tpublic String[] getParameterValue(String requestParameter);\n\tpublic String getFirstParameterValue(String requestParameter);\n\tpublic boolean hasRawPayload();\n\tpublic String getRawPayload();\n\tpublic boolean containsFunction();\n\n\t@Rule\n\tpublic ExpectedException expectedEx;\n\n}\n\nclass CommandTest {\n\n\t@Rule\n\tpublic ExpectedException expectedEx;\n\n\t@Test\n\tpublic void testInvalidCommandMissingBehavior() throws Exception {\n", "reference": "\t\texpectedEx.expect(InvalidConfigException.class);\n\t\texpectedEx.expectMessage(\"Command with URI: /anthem/org/fep/p/umcase_view:100/_get cannot have null Behavior.\");\n\t\tCommand cmd = CommandBuilder.withUri(\"/anthem/org/fep/p/umcase_view:100/_get\").getCommand();\n\t\tcmd.setBehaviors(null);\n\t\tcmd.validate();\n\t}\n\n}", "prediction": "\t\texpectedEx.expect(InvalidConfigException.class);\n\t\texpectedEx.expectMessage(\"Missing command arguments for uri: /test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test/test", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "96122408_14", "part": [1, 1], "seq": [1, 1], "prompt": "class UserUtil {\n\n  public static void setUserDefaultValueForV3(Map<String, Object> userMap) {\n    List<String> roles = new ArrayList<>();\n    roles.add(ProjectUtil.UserRole.PUBLIC.getValue());\n    userMap.put(JsonKey.ROLES, roles);\n    userMap.put(\n        JsonKey.COUNTRY_CODE, propertiesCache.getProperty(JsonKey.SUNBIRD_DEFAULT_COUNTRY_CODE));\n    // Since global settings are introduced, profile visibility map should be empty during user\n    // creation\n    userMap.put(JsonKey.PROFILE_VISIBILITY, new HashMap<String, String>());\n    userMap.put(JsonKey.IS_DELETED, false);\n    userMap.put(JsonKey.CREATED_DATE, ProjectUtil.getFormattedDate());\n    userMap.put(JsonKey.STATUS, ProjectUtil.Status.ACTIVE.getValue());\n\n    if (StringUtils.isBlank((String) userMap.get(JsonKey.USERNAME))) {\n      String firstName = (String) userMap.get(JsonKey.FIRST_NAME);\n      firstName = firstName.split(\" \")[0];\n      userMap.put(JsonKey.USERNAME, firstName + \"_\" + generateUniqueString(4));\n    } else {\n      if (!userService.checkUsernameUniqueness((String) userMap.get(JsonKey.USERNAME), false)) {\n        ProjectCommonException.throwClientErrorException(ResponseCode.userNameAlreadyExistError);\n      }\n    }\n  }\n\n  private  UserUtil();\n\n  @SuppressWarnings(\"unchecked\") public static void checkPhoneUniqueness(User user, String opType);\n  @SuppressWarnings(\"unchecked\") public static void checkPhoneUniqueness(String phone);\n  public static boolean identifierExists(String type, String value);\n  public static void checkEmailUniqueness(String email);\n  public static Map<String, Object> validateExternalIdsAndReturnActiveUser(\n      Map<String, Object> userMap);\n  @SuppressWarnings(\"unchecked\") public static Map<String, Object> getUserFromExternalId(Map<String, Object> userMap);\n  public static String getUserIdFromExternalId(Map<String, Object> userMap);\n  @SuppressWarnings(\"unchecked\") public static void checkEmailUniqueness(User user, String opType);\n  public static void validateUserPhoneEmailAndWebPages(User user, String operationType);\n  public static String getEncryptedData(String value);\n  public static List<Map<String, String>> copyAndConvertExternalIdsToLower(\n      List<Map<String, String>> externalIds);\n  public static void storeOriginalExternalIdsValue(List<Map<String, String>> externalIds);\n  public static List<Map<String, String>> convertExternalIdsValueToLowerCase(\n      List<Map<String, String>> externalIds);\n  @SuppressWarnings(\"unchecked\") public static void checkExternalIdUniqueness(User user, String operation);\n  private static void throwUserAlreadyExistsException(\n      String externalId, String idType, String provider);\n  private static void throwExternalIDNotFoundException(\n      String externalId, String idType, String provider);\n  public static String encryptData(String value);\n  public static boolean updatePassword(Map<String, Object> userMap);\n  public static void addMaskEmailAndPhone(Map<String, Object> userMap);\n  public static void addMaskEmailAndMaskPhone(Map<String, Object> userMap);\n  @SuppressWarnings(\"unchecked\") public static Map<String, Object> encryptUserData(Map<String, Object> userMap);\n  public static Map<String, Object> checkProfileCompleteness(Map<String, Object> userMap);\n  public static String generateUniqueString(int length);\n  private static String baseN(BigDecimal num, int base);\n  public static void setUserDefaultValue(Map<String, Object> userMap, String callerId);\n  private static String getUsername(String name);\n  public static void validateExternalIds(User user, String operationType);\n  public static void checkEmailSameOrDiff(\n      Map<String, Object> userRequestMap, Map<String, Object> userDbRecord);\n  private static Optional<Map<String, String>> checkExternalID(\n      List<Map<String, String>> dbResExternalIds, Map<String, String> extIdMap);\n  public static void validateUserExternalIds(User user);\n  @SuppressWarnings(\"unchecked\") private static List<Map<String, String>> getUserExternalIds(String userId);\n  public static List<Map<String, Object>> getActiveUserOrgDetails(String userId);\n  @SuppressWarnings(\"unchecked\") private static List<Map<String, Object>> getUserOrgDetails(boolean isdeleted, String userId);\n  public static List<Map<String, Object>> getAllUserOrgDetails(String userId);\n  public static void toLower(Map<String, Object> userMap);\n\n  private static Response response;\n  public static CassandraOperationImpl cassandraOperationImpl;\n\n}\n\nclass UserUtilTest {\n\n  private static Response response;\n  public static CassandraOperationImpl cassandraOperationImpl;\n\n  @Test\n  public void setUserDefaultValueForV3() {\n", "reference": "    Map<String, Object> userMap = new HashMap<String, Object>();\n    userMap.put(JsonKey.FIRST_NAME, \"Test User\");\n    UserUtil.setUserDefaultValueForV3(userMap);\n    assertNotNull(userMap.get(JsonKey.USERNAME));\n    assertNotNull(userMap.get(JsonKey.STATUS));\n    assertNotNull(userMap.get(JsonKey.ROLES));\n  }\n\n}", "prediction": "    Map<String, Object> userMap = new HashMap<>();\n    userMap.put(JsonKey.FIRST_NAME, \"Test\");\n    userMap.put(JsonKey.LAST_NAME, \"User\");\n    userMap.put(JsonKey.EMAIL, \"\");\n    userMap.put(JsonKey.PHONE, \"9876543210\");\n    userMap.put(JsonKey.USERNAME, \"testuser\");\n    userMap.put(JsonKey.PASSWORD, \"\");\n    userMap.put(JsonKey.ORG_ID, \"0123456789\");\n    userMap.put(JsonKey.USER_ID, \"0123456789\");\n    userMap.put(JsonKey.CREATED_BY, \"0123456789\");\n    userMap.put(JsonKey.CHANNEL, \"0123456789\");\n    userMap.put(JsonKey.PROVIDER, \"0123456789\");\n    userMap.put(JsonKey.EXTERNAL_ID, \"0123456789\");\n    userMap.put(JsonKey.EXTERNAL_ID_TYPE, \"0123456789\");\n    userMap.put(JsonKey.EXTERNAL_ID_PROVIDER, \"0123456789\");\n    userMap.put(JsonKey.IS_DELETED, false);\n    userMap.put(JsonKey.STATUS, ProjectUtil.Status.ACTIVE.getValue());\n    userMap.put(JsonKey.CREATED_DATE, ProjectUtil.getFormattedDate());\n    userMap.put(JsonKey.UPDATED_DATE, ProjectUtil.getFormattedDate());\n    userMap.put(JsonKey.LAST_LOGIN_TIME, ProjectUtil.getFormattedDate());\n    userMap.put(JsonKey.LAST_SYNC_TIME, ProjectUtil.getFormattedDate());\n    userMap.put(JsonKey.PROFILE_VISIBILITY, new HashMap<String, String>());\n    userMap.put(JsonKey.ROLES, new ArrayList<>());\n    userMap.put(JsonKey.COUNTRY_CODE, \"IN\");\n    userMap.put(JsonKey.ORG_NAME, \"Test Org\");\n    userMap.put(JsonKey.ORG_CODE, \"0123456789\");\n    userMap.put(JsonKey.ORG_EXTERNAL_ID, \"0123456789\");\n    userMap.put(JsonKey.ORG_EXTERNAL_ID_TYPE, \"0123456789\");\n    userMap.put(JsonKey.ORG_EXTERNAL_ID_PROVIDER, \"0123456789\");\n    userMap.put(JsonKey.ORG_IS_DELETED, false);\n    userMap.put(JsonKey.ORG_STATUS, ProjectUtil.Status.ACTIVE.getValue());\n    userMap.put(JsonKey.ORG_CREATED_DATE, ProjectUtil.getFormattedDate());\n    userMap.put(JsonKey.ORG_UPDATED_DATE, ProjectUtil.getFormattedDate());\n    userMap.put(JsonKey.ORG_LAST_LOGIN_TIME, ProjectUtil.getFormattedDate());\n    userMap.put(JsonKey.ORG_LAST_SYNC_TIME, ProjectUtil.getFormattedDate());\n    userMap.put(JsonKey.ORG_PROFILE_VISIBILITY, new HashMap<String, String>());\n    userMap.put(JsonKey.ORG_ROLES, new ArrayList<>());\n    userMap.put(JsonKey.ORG_COUNTRY_CODE, \"IN\");\n    userMap.put(JsonKey.ORG_ADDRESS, \"Test Address\");\n    userMap.put(JsonKey.ORG_PHONE, \"9876543210\");\n    userMap.put(JsonKey.ORG_EMAIL, \"\");\n    userMap.put(JsonKey.ORG_WEBSITE, \"www.test.com\");\n    userMap.put(JsonKey.ORG_LOGO_URL, \"www.test.com/logo.png\");\n    userMap.put(JsonKey.ORG_DESCRIPTION, \"Test Org Description\");\n    userMap.put(JsonKey.ORG_ORGANISATION_TYPE, \"School\");\n    userMap.put(JsonKey.ORG_CHANNEL, \"0123456789\");\n    userMap.put(JsonKey.ORG_PROVIDER, \"0123456789\");\n    userMap.put(JsonKey.ORG_EXTERNAL_ID, \"0123456789\");\n    userMap", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "96518561_0", "part": [1, 1], "seq": [1, 1], "prompt": "class Utils {\n\n  static float getDimenFromString(String value) {\n    int end = value.charAt(value.length() - 3) == 'd'? 3 : 2;\n    return Float.parseFloat(value.substring(0, value.length() - end));\n  }\n\n  static float dpToPixel(Context context, float dp);\n  static int getColorFromString(String value);\n\n}\n\nclass UtilsTest {\n\n    @Test\n    public void testGetDimenFromString() throws Exception {\n", "reference": "\n        assertEquals(22.0, Utils.getDimenFromString(\"22dip\"), 0);\n        assertEquals(1.5f, Utils.getDimenFromString(\"1.5dp\"), 0);\n        assertEquals(0.7f, Utils.getDimenFromString(\"0.7sp\"), 0);\n        assertEquals(2f, Utils.getDimenFromString(\"2in\"), 0);\n        assertEquals(22f, Utils.getDimenFromString(\"22px\"), 0);\n\n    }\n\n}", "prediction": "        assertEquals(100, Utils.getDimenFromString(\"100dp\"));\n        assertEquals(100, Utils.getDimenFromString(\"100d\"));\n        assertEquals(100, Utils.getDimenFromString(\"100\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "99149191_8", "part": [1, 1], "seq": [1, 1], "prompt": "class VClock {\n\n    public long lastUpdate() {\n        long last = 0;\n        for (Map.Entry<String, Long> clock : this.vc.entrySet()) {\n            if (clock.getValue() > last) {\n                last = clock.getValue();\n            }\n        }\n        return last;\n    }\n\n    public  VClock();\n\n    private TreeMap<String, Long> clockInit();\n    public void tick(String pid);\n    public void set(String pid, long ticks);\n    public VClock copy();\n    public long findTicks(String pid);\n    public void merge(VClock other);\n    public String returnVCString();\n    public void printVC();\n    public TreeMap<String, Long> getClockMap();\n\n     VClock testClock;\n\n}\n\nclass VClockTest {\n\n     VClock testClock;\n\n    @Test\n    public void lastUpdate() throws Exception {\n", "reference": "        testClock.set(\"Proc1\", 2);\n        testClock.set(\"Proc3\", 3);\n        testClock.set(\"Proc2\", 7);\n        long clockTicks = testClock.lastUpdate();\n        assertEquals(\"Copy failed! The clock values do not match.\", 7L, clockTicks);\n\n    }\n\n}", "prediction": "        testClock = new VClock();\n        testClock.tick(\"A\");\n        testClock.tick(\"B\");\n        testClock.tick(\"C\");\n        testClock.tick(\"D\");\n        testClock.tick(\"E\");\n        testClock.tick(\"F\");\n        testClock.tick(\"G\");\n        testClock.tick(\"H\");\n        testClock.tick(\"I\");\n        testClock.tick(\"J\");\n        testClock.tick(\"K\");\n        testClock.tick(\"L\");\n        testClock.tick(\"M\");\n        testClock.tick(\"N\");\n        testClock.tick(\"O\");\n        testClock.tick(\"P\");\n        testClock.tick(\"Q\");\n        testClock.tick(\"R\");\n        testClock.tick(\"S\");\n        testClock.tick(\"T\");\n        testClock.tick(\"U\");\n        testClock.tick(\"V\");\n        testClock.tick(\"W\");\n        testClock.tick(\"X\");\n        testClock.tick(\"Y\");\n        testClock.tick(\"Z\");\n        testClock.tick(\"AA\");\n        testClock.tick(\"AB\");\n        testClock.tick(\"AC\");\n        testClock.tick(\"AD\");\n        testClock.tick(\"AE\");\n        testClock.tick(\"AF\");\n        testClock.tick(\"AG\");\n        testClock.tick(\"AH\");\n        testClock.tick(\"AI\");\n        testClock.tick(\"AJ\");\n        testClock.tick(\"AK\");\n        testClock.tick(\"AL\");\n        testClock.tick(\"AM\");\n        testClock.tick(\"AN\");\n        testClock.tick(\"AO\");\n        testClock.tick(\"AP\");\n        testClock.tick(\"AQ\");\n        testClock.tick(\"AR\");\n        testClock.tick(\"AS\");\n        testClock.tick(\"AT\");\n        testClock.tick(\"AU\");\n        testClock.tick(\"AV\");\n        testClock.tick(\"AW\");\n        testClock.tick(\"AX\");\n        testClock.tick(\"AY\");\n        testClock.tick(\"AZ\");\n        testClock.tick(\"BA\");\n        testClock.tick(\"BB\");\n        testClock.tick(\"BC\");\n        testClock.tick(\"BD\");\n        testClock.tick(\"BE\");\n        testClock.tick(\"BF\");\n        testClock.tick(\"BG\");\n        testClock.tick(\"BH\");\n        testClock.tick(\"BI\");\n        testClock.tick(\"BJ\");\n        testClock.tick(\"BK\");\n        testClock.tick(\"BL\");\n        testClock.tick(\"BM\");\n        testClock.tick(\"BN\");\n        testClock.tick(\"BO\");\n        testClock.tick(\"BP\");\n        testClock.tick(\"BQ\");\n        testClock.tick(\"BR\");\n        testClock.tick(\"BS\");\n        testClock.tick(\"BT\");\n        testClock.tick(\"BU\");\n        testClock.tick(\"BV\");\n        testClock.tick(\"BW\");\n        testClock.tick(\"BX\");\n        testClock.tick(\"BY\");\n        testClock.tick(\"BZ\");\n        testClock.tick(\"CA\");\n        testClock.tick(\"CB\");\n        testClock.tick(\"CC\");\n        testClock.tick(\"CD\");\n        testClock.tick(\"CE\");\n        testClock.tick(\"CF\");\n        testClock.tick(\"CG\");\n        testClock.tick(\"CH\");\n        testClock.tick(\"CI\");\n        testClock.tick(\"CJ\");\n        testClock.tick(\"CK\");\n        testClock.tick(\"CL\");\n        testClock.tick(\"CM\");\n        testClock.tick(\"CN\");\n        testClock.tick(\"CO\");\n        testClock.tick(\"CP\");\n        testClock.tick(\"CQ\");\n        testClock.tick(\"CR\");\n        testClock.tick(\"CS\");\n        testClock.tick(\"CT\");\n        testClock.tick(\"CU\");\n        testClock.tick(\"CV\");\n        testClock.tick(\"CW\");\n        testClock.tick(\"CX\");\n        testClock.tick(\"CY\");\n        testClock.tick(\"CZ\");\n        testClock.tick(\"DA\");\n        testClock.tick(\"DB\");\n        testClock.tick(\"DC\");\n        testClock.tick(\"DD\");\n        testClock.tick(\"DE\");\n        testClock.tick(\"DF\");\n        testClock.tick(\"DG\");\n        testClock.tick(\"DH\");\n        testClock.tick(\"DI\");\n        testClock.tick(\"DJ\");\n        testClock.tick(\"DK\");\n        testClock.tick(\"DL\");\n        testClock.tick(\"DM\");\n        testClock.tick(\"DN\");\n        testClock.tick(\"DO\");\n        testClock.tick(\"DP\");\n        testClock.tick(\"DQ\");\n        testClock.tick(\"DR\");\n        testClock.tick(\"DS\");\n        testClock.tick(\"DT\");\n        testClock.tick(\"DU\");\n        testClock.tick(\"DV\");\n        testClock.tick(\"DW\");\n        testClock.tick(\"DX\");\n        testClock.tick(\"DY\");\n        testClock.tick(\"DZ\");\n        testClock.tick(\"EA\");\n        testClock.tick(\"EB\");\n        testClock.tick(\"EC\");\n        testClock.tick(\"ED\");\n        testClock.tick(\"EE\");\n        testClock.tick(\"EF\");\n        testClock.tick(\"EG\");\n        testClock.tick(\"EH\");\n        testClock.tick(\"EI\");\n        testClock.tick(\"EJ\");\n        testClock.tick(\"EK\");\n        testClock.tick(\"EL\");\n        testClock.tick(\"EM\");\n        testClock.tick(\"EN\");\n        testClock.tick(\"EO\");\n        testClock.tick(\"EP\");\n        testClock.tick(\"EQ\");\n        testClock.tick(\"ER\");\n        testClock.tick(\"ES\");\n        testClock.tick(\"ET\");\n        testClock.tick(\"EU\");\n        testClock.tick(\"EV\");\n        testClock.tick(\"EW\");\n        testClock.tick(\"EX\");\n        testClock.tick(\"EY\");\n        testClock.tick(\"EZ\");\n        testClock.tick(\"FA\");\n        testClock.tick(\"FB\");\n        testClock.tick(\"FC\");\n        testClock.tick(\"FD\");\n        testClock.tick(\"FE\");\n        testClock.tick(\"FF\");\n        testClock.tick(\"FG\");\n        testClock.tick(\"FH\");\n        testClock.tick(\"FI\");\n        testClock.tick(\"FJ\");\n        testClock.tick(\"FK\");\n        testClock.tick(\"FL\");\n        testClock.tick(\"FM\");\n        testClock.tick(\"FN\");\n        testClock.tick(\"FO\");\n        testClock.tick(\"FP\");\n        testClock.tick(\"FQ\");\n        testClock.tick(\"FR\");\n        testClock.tick(\"FS\");\n        testClock.tick(\"FT\");\n        testClock.tick(\"FU\");\n        testClock.tick(\"FV\");\n        testClock.tick(\"FW\");\n        testClock.tick(\"FX\");\n        testClock.tick(\"FY\");\n        testClock.tick(\"FZ\");\n        testClock.tick(\"GA\");\n        testClock.tick(\"GB\");\n        testClock.tick(\"GC\");\n        testClock.tick(\"GD\");\n        testClock.tick(\"GE\");\n        testClock.tick(\"GF\");\n        testClock.tick(\"GG\");\n        testClock.tick(\"GH\");\n        testClock.tick(\"GI\");\n        testClock.tick(\"GJ\");\n        testClock.tick(\"GK\");\n        testClock.tick(\"GL\");\n        testClock.tick(\"GM\");\n        testClock.tick(\"GN\");\n        testClock.tick(\"GO\");\n        testClock.tick(\"GP\");\n        testClock.tick(\"GQ\");\n        testClock.tick(\"GR\");\n        testClock.tick(\"GS\");\n        testClock.tick(\"GT\");\n        testClock.tick(\"GU\");\n        testClock.tick(\"GV\");\n        testClock.tick(\"GW\");\n        testClock.tick(\"GX\");\n        testClock.tick(\"GY\");\n        testClock.tick(\"GZ\");\n        testClock.tick(\"HA\");\n        testClock.tick(\"HB\");\n        testClock.tick(\"HC\");\n        testClock.tick(\"HD\");\n        testClock.tick(\"HE\");\n        testClock.tick(\"HF\");\n        testClock.tick(\"HG\");\n        testClock.tick(\"HH\");\n        testClock.tick(\"HI\");\n        testClock.tick(\"HJ\");\n        testClock.tick(\"HK\");\n        testClock.tick(\"HL\");\n        testClock.tick(\"HM\");\n        testClock.tick(\"HN\");\n        testClock", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "99569378_39", "part": [1, 1], "seq": [1, 1], "prompt": "class ActorsPackageDescriptionImpl implements ActorsPackageDescription {\n\n    @NotNull\n    @Override\n    public String getBuilderClassName() {\n        assert mElement!= null;\n        ActorsPackage annotation = mElement.getAnnotation(ActorsPackage.class);\n        return annotation.builderName();\n    }\n\n      ActorsPackageDescriptionImpl(@NotNull Element element);\n\n    @Override public boolean validate();\n    @Override public void describeProblems(@NotNull List<GenerationError> errors);\n    @NotNull @Override public String getPackageName();\n    @NotNull @Override public ActorsPackage.AccessLevel getAccessLevel();\n\n    private static final String PACKAGE_NAME;\n    private static final String BUILDER_CLASS_NAME;\n    @Mock\n    private PackageElement mElement;\n    @Mock\n    private ActorsPackage mAnnotation;\n\n}\n\nclass ActorsPackageDescriptionImplTest {\n\n    private static final String PACKAGE_NAME;\n    private static final String BUILDER_CLASS_NAME;\n    @Mock\n    private PackageElement mElement;\n    @Mock\n    private ActorsPackage mAnnotation;\n\n    @Test\n    public void getBuilderClassName_sameObject_provideConfiguredAnnotation() {\n", "reference": "        ActorsPackageDescriptionImpl impl = new ActorsPackageDescriptionImpl(mElement);\n        Assert.assertEquals(BUILDER_CLASS_NAME, impl.getBuilderClassName());\n    }\n\n}", "prediction": "        ActorsPackageDescription description = new ActorsPackageDescriptionImpl(mElement);\n        when(mElement.getAnnotation(ActorsPackage.class)).thenReturn(mAnnotation);\n        when(mAnnotation.builderName()).thenReturn(BUILDER_CLASS_NAME);\n\n        assertThat(description.getBuilderClassName()).isEqualTo(BUILDER_CLASS_NAME);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "99890719_56", "part": [1, 1], "seq": [1, 1], "prompt": "class AlternativePatternInstancePredicate {\n\n    public boolean test(Overlap violation, Collection<Overlap> instances) {\n        for (Overlap instance : instances) {\n            if (violation.isInTargetOverlap(instance)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n}\n\nclass AlternativePatternInstancePredicateTest {\n\n    @Test\n    public void keepsViolation_isInstanceOfRelatedPatternButViolationOverlapExtendsInstance() {\n", "reference": "        final TestAUGBuilder target = buildAUG().withActionNodes(\"a\", \"b\", \"c\");\n        final TestAUGBuilder violatedPattern = buildAUG().withActionNodes(\"a\", \"b\", \"d\");\n        final TestAUGBuilder satisfiedPattern = buildAUG().withActionNodes(\"a\", \"c\");\n        final Overlap violation = buildOverlap(violatedPattern, target).withNodes(\"a\", \"b\").build();\n        final Overlap instance = buildOverlap(satisfiedPattern, target).withNodes(\"a\", \"c\").build();\n        final AlternativePatternInstancePredicate filter = new AlternativePatternInstancePredicate();\n\n        assertFalse(filter.test(violation, Collections.singleton(instance)));\n    }\n\n}", "prediction": "        Overlap violation = new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Overlap(new Over", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "99997703_207", "part": [1, 1], "seq": [1, 1], "prompt": "class ConstantSpeedTraversalSection implements TraversalSection, Serializable {\n\n    @Override\n    public double getDuration() {\n        return time;\n    }\n\n      ConstantSpeedTraversalSection(double distance, double speed, double time);\n\n    @Override public double getTotalDistance();\n    @Override public double getDistanceAtTime(@Nonnegative double time);\n    @Override public double getTimeAtDistance(@Nonnegative double distance);\n    @Override public double getSpeedAtTime(@Nonnegative double time);\n    @Override public double getAccelerationAtDistance(@Nonnegative double distance);\n    @Override public double getAccelerationAtTime(@Nonnegative double time);\n    @Override public boolean isConstantSpeed();\n    @Override public String toString();\n    @Override public boolean equals(Object o);\n    @Override public int hashCode();\n\n    private static final double DURATION;\n    private static final double DISTANCE;\n    private static final double SPEED;\n    private final ConstantSpeedTraversalSection traversalSection;\n\n}\n\nclass ConstantSpeedTraversalSectionTest {\n\n    private static final double DURATION;\n    private static final double DISTANCE;\n    private static final double SPEED;\n    private final ConstantSpeedTraversalSection traversalSection;\n\n    @Test\n    @DisplayName(\"getDuration() method\")\n    void testGetDuration_returnsFullDuration() {\n", "reference": "        assertThat(traversalSection.getDuration()).isEqualTo(DURATION);\n    }\n\n}", "prediction": "        assertEquals(DURATION, traversalSection.getDuration());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "100679870_30", "part": [1, 1], "seq": [1, 1], "prompt": "class StoreImage implements ICachable<StoreImage> {\n\n  @Override\n  public long getByteSize() {\n    return data.length;\n  }\n\n  public  StoreImage(final long id, BufferedImage image, ImageSize size);\n  public  StoreImage(final long id, byte[] base64, ImageSize size);\n  public  StoreImage(StoreImage image);\n\n  private void setImageSize(ImageSize size);\n  public long getId();\n  private void setImage(BufferedImage image);\n  public BufferedImage getImage();\n  public ImageSize getSize();\n  public String getBase64();\n  public byte[] getByteArray();\n  @Override public String toString();\n  @Override public int hashCode();\n  @Override public boolean equals(Object obj);\n\n  private static final String IMG_STRING;\n  private static final String IMG_DATA;\n  private static final long IMG_ID0;\n  private static final long IMG_ID1;\n  private BufferedImage img;\n  @Mock\n  private StoreImage mockedImg0;\n  @Mock\n  private StoreImage mockedImg1;\n\n}\n\nclass TestStoreImage {\n\n  private static final String IMG_STRING;\n  private static final String IMG_DATA;\n  private static final long IMG_ID0;\n  private static final long IMG_ID1;\n  private BufferedImage img;\n  @Mock\n  private StoreImage mockedImg0;\n  @Mock\n  private StoreImage mockedImg1;\n\n  @Test\n  public void testGetByteSize() {\n", "reference": "    StoreImage uut = new StoreImage(IMG_ID1, IMG_DATA.getBytes(), ImageSizePreset.ICON.getSize());\n    assertEquals(IMG_DATA.getBytes().length, uut.getByteSize());\n  }\n\n}", "prediction": "    assertEquals(IMG_DATA.length(), mockedImg0.getByteSize());\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "101035547_0", "part": [1, 1], "seq": [1, 1], "prompt": "class VavrHammingEncoder implements HammingEncoder {\n\n    @Override\n    public EncodedString encode(BinaryString input) {\n        String result = helper.getHammingCodewordIndices(input.getValue().length())\n         .map(i -> toHammingCodeValue(i, input))\n         .reduce(String::concat);\n\n        return EncodedString.of(result);\n    }\n\n    private String toHammingCodeValue(int it, BinaryString input);\n\n    private HammingEncoder sut;\n\n}\n\nclass VavrHammingEncoderTest {\n\n    private HammingEncoder sut;\n\n    @Test\n    @DisplayName(\"should always encode zeros to zeros\")\n    void shouldEncodeZeros() {\n", "reference": "        Stream.iterate(\"0\", i -> i + \"0\")\n          .take(1000)\n          .map(it -> sut.encode(BinaryString.of(it)).getValue())\n          .forEach(msg -> assertThat(msg).doesNotContain(\"1\"));\n    }\n\n}", "prediction": "        assertThat(sut.encode(BinaryString.of(\"00000000000000000000000000000000\"))\n         .isEqualTo(EncodedString.of(\"00000000000000000000000000000000\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "101264271_1", "part": [1, 1], "seq": [1, 1], "prompt": "class DeviceListActivity extends AppCompatActivity implements DeviceListPresenter.View {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        RLog.d();\n        binding = DataBindingUtil.setContentView(this, R.layout.activity_device_list);\n\n        // setup scan recyclerView\n        setupScanRecyclerView();\n\n        // create presenter\n        createPresenter();\n\n        // setup rx event\n        setupConnectEvent();\n\n    }\n\n    @Override protected void onResume();\n    @Override protected void onPause();\n    @Override protected void onDestroy();\n    private void setupScanRecyclerView();\n    private void createPresenter();\n    @Override public void showToast(String s);\n    @Override public void checkPermission(String rationaleMessage, String... permissions);\n    @Override public void startActionRequestEnable();\n    @Override public void addBluetoothDevice(BluetoothItem item);\n    @Override protected void onActivityResult(int requestCode, int resultCode, Intent data);\n    private void setupConnectEvent();\n\n    private DeviceListPresenter presenter;\n\n}\n\nclass DeviceListActivityTest implements DeviceListPresenter.View {\n\n    private DeviceListPresenter presenter;\n\n    @Test\n    public void onCreate() throws Exception {\n", "reference": "        presenter.startBluetooth();\n    }\n\n}", "prediction": "        presenter = new DeviceListPresenter(this);\n        presenter.onCreate();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "102137829_24", "part": [1, 1], "seq": [1, 1], "prompt": "class KeyFileXmlParser implements KeyFileParser {\n\n    public KeyFile fromXml(byte[] inputBytes) {\n        try {\n            ByteArrayInputStream inputStream = new ByteArrayInputStream(inputBytes);\n            return parser.fromXml(inputStream, null, KeyFile.class);\n        } catch (KeePassDatabaseUnreadableException e) {\n            return new KeyFile(false);\n        }\n    }\n\n    public  KeyFileXmlParser(XmlParser parser);\n\n    @Override public KeyFileBytes readKeyFile(byte[] keyFile);\n    private byte[] getBytesFromKeyFile(KeyFile keyFile);\n\n}\n\nclass KeyFileXmlParserTest {\n\n    @Test\n    public void whenInputIsKeyFileShouldParseFileAndReturnCorrectData() throws IOException {\n", "reference": "        FileInputStream fileInputStream = new FileInputStream(ResourceUtils.getResource(\"DatabaseWithKeyfile.key\"));\n        byte[] keyFileContent = StreamUtils.toByteArray(fileInputStream);\n\n        SimpleXmlParser parser = new SimpleXmlParser();\n        KeyFile keyFile = new KeyFileXmlParser(parser).fromXml(keyFileContent);\n\n        Assert.assertEquals(\"RP+rYNZL4lrGtDMBPzOuctlh3NAutSG5KGsT38C+qPQ=\", keyFile.getKey().getData());\n    }\n\n}", "prediction": "        KeyFileXmlParser parser = new KeyFileXmlParser(new XmlParser());\n        KeyFile keyFile = parser.fromXml(readKeyFile());\n\n        assertThat(keyFile.isProtected(), is(true));\n        assertThat(keyFile.getProtectedKey(), is(\"\"));\n        assertThat(keyFile.getProtectedKeyLength(), is(32));\n        assertThat(keyFile.getProtectedKeyIterations(), is(1000));\n        assertThat(keyFile.getProtectedKeySalt(), is(\"\"));\n        assertThat(keyFile.getProtectedKeySaltLength(), is(16));\n        assertThat(keyFile.getProtectedKeyIV(), is(\"\"));\n        assertThat(keyFile.getProtectedKeyIVLength(), is(16));\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "103437385_44", "part": [1, 1], "seq": [1, 1], "prompt": "class MavenEmbedder {\n\n    public MavenProject readProject( final InputStream mavenProjectStream ) throws ProjectBuildingException, MavenEmbedderException {\n        ModelSource modelSource = new ModelSource() {\n            @Override\n            public InputStream getInputStream() {\n                return mavenProjectStream;\n            }\n\n            @Override\n            public String getLocation() {\n                return \"\";\n            }\n        };\n\n        ClassLoader originalCl = Thread.currentThread().getContextClassLoader();\n        try {\n            org.eclipse.aether.artifact.Artifact lastArtifact = null;\n            do {\n                Thread.currentThread().setContextClassLoader(componentProvider.getSystemClassLoader());\n                ProjectBuilder projectBuilder = componentProvider.lookup(ProjectBuilder.class);\n                // BZ-1007894: Check if added dependencies are resolvable.\n                ProjectBuildingResult result = projectBuilder.build(modelSource, getProjectBuildingRequest());\n                if (result!= null && result.getDependencyResolutionResult()!= null &&!result.getDependencyResolutionResult().getCollectionErrors().isEmpty()) {\n                    // A dependency resolution error has been produced. It can contains some error. Throw the first one to the client, so the user will fix every one sequentially.\n                    final Exception depedencyResolutionException = result.getDependencyResolutionResult().getCollectionErrors().get(0);\n                    if (depedencyResolutionException instanceof ArtifactDescriptorException) {\n                        final org.eclipse.aether.artifact.Artifact artifact = ((ArtifactDescriptorException) depedencyResolutionException).getResult().getArtifact();\n                        if (!artifact.equals(lastArtifact)) {\n                            tryRemoveLocalArtifact(artifact);\n                            lastArtifact = artifact;\n                            continue;\n                        }\n                    }\n                    if (depedencyResolutionException!= null) {\n                        throw new MavenEmbedderException(depedencyResolutionException.getMessage(), depedencyResolutionException);\n                    }\n                }\n                return (result == null || result.getProject() == null )? null : result.getProject();\n            } while (true);\n        } catch ( ComponentLookupException e ) {\n            throw new MavenEmbedderException( e.getMessage(), e );\n        } finally {\n            Thread.currentThread().setContextClassLoader( originalCl );\n            try {\n                mavenProjectStream.close();\n            } catch ( IOException e ) {\n            }\n        }\n    }\n\n    public  MavenEmbedder( MavenRequest mavenRequest );\n    public  MavenEmbedder( ClassLoader mavenClassLoader,\n                          ClassLoader parent,\n                          MavenRequest mavenRequest );\n    protected  MavenEmbedder( MavenRequest mavenRequest,\n                             ComponentProvider componentProvider );\n\n     void init();\n    protected MavenExecutionRequest buildMavenExecutionRequest( MavenRequest mavenRequest );\n    protected MavenRepositoryConfiguration getMavenRepositoryConfiguration();\n    private Properties getEnvVars();\n    public Settings getSettings();\n    public ArtifactRepository getLocalRepository();\n    public String getLocalRepositoryPath();\n     void tryRemoveLocalArtifact(Artifact artifact);\n    public MavenProject readProject( File mavenProject );\n    public List<MavenProject> readProjects( File mavenProject,\n                                            boolean recursive );\n    public List<ProjectBuildingResult> buildProjects( File mavenProject,\n                                                      boolean recursive );\n     ProjectBuildingRequest getProjectBuildingRequest();\n    public MavenSession getMavenSession();\n    public MavenExecutionRequest getMavenExecutionRequest();\n    public void dispose();\n    public MavenExecutionResult execute( final MavenRequest mavenRequest );\n\n    private final String EMPTY_SETTINGS;\n    final ComponentProvider componentProviderMocked;\n\n}\n\nclass MavenEmbedderTest {\n\n    private final String EMPTY_SETTINGS;\n    final ComponentProvider componentProviderMocked;\n\n    @Test\n    public void testInvalidLocalDependency() throws MavenEmbedderException, ProjectBuildingException, ComponentLookupException, SettingsBuildingException, InvalidRepositoryException {\n", "reference": "        final MavenExecutionRequestPopulator mavenExecutionRequestPopulator =  mock(MavenExecutionRequestPopulator.class);\n        final Logger logger =  mock(Logger.class);\n        final RepositorySystem repositorySystem = mock(RepositorySystem.class);\n        final ArtifactRepository artifactRepository = mock(ArtifactRepository.class);\n\n        final SettingsBuilder settingsBuilder =  mock(SettingsBuilder.class);\n        final SettingsBuildingResult settingsBuildingResult = mock(SettingsBuildingResult.class);\n        final ProjectBuilder projectBuilderMock =  mock(ProjectBuilder.class);\n        final DependencyResolutionResult drr = mock(DependencyResolutionResult.class);\n        final ProjectBuildingResult projectBuildingResult =  mock(ProjectBuildingResult.class);\n        final ArtifactDescriptorException exception = mock(ArtifactDescriptorException.class);\n        final ArtifactDescriptorRequest request = new ArtifactDescriptorRequest();\n\n        final ArtifactDescriptorResult result = new ArtifactDescriptorResult(request);\n        final Artifact artifactResult = mock(Artifact .class);\n\n        final List<Exception> list = singletonList(exception);\n\n        request.setArtifact(artifactResult);\n        result.setArtifact(artifactResult);\n\n        doReturn(settingsBuilder).when(componentProviderMocked).lookup(SettingsBuilder.class);\n        doReturn(settingsBuildingResult).when(settingsBuilder).build(any(SettingsBuildingRequest.class));\n        when(settingsBuildingResult.getEffectiveSettings()).thenReturn(mock(Settings.class));\n        when(componentProviderMocked.getSystemClassLoader()).thenReturn(getClass().getClassLoader());\n\n\n        doReturn(artifactRepository).when(repositorySystem).createLocalRepository(any(File.class));\n\n        doReturn(new File(\"\").toPath().toString()).when(artifactRepository).getBasedir();\n\n        doReturn(repositorySystem).when(componentProviderMocked).lookup(RepositorySystem.class);\n\n        doReturn(projectBuilderMock).when(componentProviderMocked).lookup(ProjectBuilder.class);\n\n        doReturn(logger).when(componentProviderMocked).lookup(Logger.class);\n        doReturn(mavenExecutionRequestPopulator).when(componentProviderMocked).lookup(MavenExecutionRequestPopulator.class);\n\n        doReturn(projectBuildingResult).when(projectBuilderMock).build(any(ModelSource.class), any(ProjectBuildingRequest.class));\n        when(projectBuildingResult.getDependencyResolutionResult()).thenReturn(drr);\n        when(projectBuildingResult.getDependencyResolutionResult()).thenReturn(drr);\n        when(drr.getCollectionErrors()).thenReturn(list);\n        when(exception.getResult()).thenReturn(result);\n\n        boolean[] didExecuteTryRemoveLocalArtifact = {false};\n        final MavenRequest mavenRequest = createMavenRequest(null);\n        final MavenEmbedder embedder = new MavenEmbedderMock2( mavenRequest, null ) {\n            void tryRemoveLocalArtifact(Artifact artifact) {\n                didExecuteTryRemoveLocalArtifact[0] = true;\n                assertEquals(artifact, artifactResult);\n            }\n        };\n\n        assertThatThrownBy(() -> embedder.readProject(mock(InputStream.class)))\n                .isInstanceOf(MavenEmbedderException.class);\n\n        assertTrue(didExecuteTryRemoveLocalArtifact[0]);\n    }\n\n}", "prediction": "        MavenEmbedder mavenEmbedder = new MavenEmbedder(mavenRequest);\n        mavenEmbedder.init();\n        InputStream mavenProjectStream = getClass().getResourceAsStream(\"/invalid-local-dependency.xml\");\n        MavenProject mavenProject = mavenEmbedder.readProject(mavenProjectStream);\n        assertNotNull(mavenProject);\n        mavenProjectStream.close();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "104025215_5", "part": [1, 1], "seq": [1, 1], "prompt": "class SafeIterableMap implements Iterable<Map.Entry<K, V>> {\n\n    @Override\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof SafeIterableMap)) {\n            return false;\n        }\n        SafeIterableMap map = (SafeIterableMap) obj;\n        if (this.size()!= map.size()) {\n            return false;\n        }\n        Iterator<Map.Entry<K, V>> iterator1 = iterator();\n        Iterator iterator2 = map.iterator();\n        while (iterator1.hasNext() && iterator2.hasNext()) {\n            Map.Entry<K, V> next1 = iterator1.next();\n            Object next2 = iterator2.next();\n            if ((next1 == null && next2!= null)\n                    || (next1!= null &&!next1.equals(next2))) {\n                return false;\n            }\n        }\n        return!iterator1.hasNext() &&!iterator2.hasNext();\n    }\n\n    protected Entry<K, V> get(K k);\n    public V putIfAbsent(@NonNull K key, @NonNull V v);\n    protected Entry<K, V> put(@NonNull K key, @NonNull V v);\n    public V remove(@NonNull K key);\n    public int size();\n    @NonNull @Override public Iterator<Map.Entry<K, V>> iterator();\n    public Iterator<Map.Entry<K, V>> descendingIterator();\n    public IteratorWithAdditions iteratorWithAdditions();\n    public Map.Entry<K, V> eldest();\n    public Map.Entry<K, V> newest();\n    @Override public String toString();\n\n}\n\nclass SafeIterableMapTest {\n\n    @Test\n    public void testEquality3() {\n", "reference": "        SafeIterableMap<Integer, Boolean> map = mapOf(1, 2, 3, 4);\n        //noinspection EqualsBetweenInconvertibleTypes\n        assertThat(map.equals(new ArrayList<>()), is(false));\n    }\n\n}", "prediction": "        SafeIterableMap<String, String> map1 = new SafeIterableMap<>();\n        map1.put(\"a\", \"b\");\n        map1.put(\"c\", \"d\");\n        SafeIterableMap<String, String> map2 = new SafeIterableMap<>();\n        map2.put(\"a\", \"b\");\n        map2.put(\"c\", \"d\");\n        assertEquals(map1, map2);\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "104078932_0", "part": [1, 1], "seq": [1, 1], "prompt": "class UserService {\n\n    @Transactional(\"slaveTransactionManager\")\n    public void inserUser(String username, String password) {\n        User user = new User(username, password);\n        userMapper.insert(user);\n        School school = new School(username, password);\n        schoolMapper.insert(school);\n    }\n\n    public User selectUser(int id);\n\n    @Autowired\n    private UserService userService;\n\n}\n\nclass UserServiceTest  {\n\n    @Autowired\n    private UserService userService;\n\n    @Test\n    public void addSchool() {\n", "reference": "\n        userService.inserUser(\"root2\", \"root2\");\n    }\n\n}", "prediction": "        userService.inserUser(\"test\", \"test\");\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "104141049_0", "part": [1, 1], "seq": [1, 1], "prompt": "class JdbcSessionRepository implements\n        SessionRepository<JdbcSessionRepository.JdbcSession> {\n\n    @Override\n    public void save(JdbcSession session) {\n        if (session.isNew()) {\n            try (final Connection connection = dataSource.getConnection()) {\n                connection.setAutoCommit(false);\n\n                PreparedStatement stmt = connection.prepareStatement(this.createSessionQuery);\n                stmt.setString(1, session.getId());\n                stmt.setLong(2, session.getCreationTime());\n                stmt.setLong(3, session.getLastAccessedTime());\n                stmt.setInt(4, session.getMaxInactiveInterval());\n                stmt.setLong(5, session.getExpiryTime());\n                stmt.setString(6, session.getPrincipalName());\n                int count = stmt.executeUpdate();\n                if (!session.getAttributeNames().isEmpty()) {\n                    final List<String> attributeNames = new ArrayList<>(session.getAttributeNames());\n                    try (PreparedStatement psAtt = connection.prepareStatement(this.createSessionAttributeQuery)) {\n                        for (String attributeName : attributeNames) {\n                            psAtt.setString(1, session.getId());\n                            psAtt.setString(2, attributeName);\n                            serialize(psAtt, 3, session.getAttribute(attributeName));\n                            psAtt.addBatch();\n                        }\n                        psAtt.executeBatch();\n                    }\n                }\n                connection.commit();\n\n                if (count!= 1) {\n                    logger.error(\"Failed to insert session: {}\", session.getId());\n                }\n            } catch (SQLException e) {\n                logger.error(\"SqlException:\", e);\n            }\n        } else {\n            try (final Connection connection = dataSource.getConnection()) {\n\n                connection.setAutoCommit(false);\n                PreparedStatement stmt = connection.prepareStatement(this.updateSessionQuery);\n                stmt.setString(1, session.getId());\n                stmt.setLong(2, session.getLastAccessedTime());\n                stmt.setInt(3, session.getMaxInactiveInterval());\n                stmt.setLong(4, session.getExpiryTime());\n                stmt.setString(5, session.getPrincipalName());\n                stmt.setString(6, session.getId());\n                int count = stmt.executeUpdate();\n\n                Map<String, Object> delta = session.getDelta();\n                if (!delta.isEmpty()) {\n                    for (final Map.Entry<String, Object> entry : delta.entrySet()) {\n                        if (entry.getValue() == null) {\n                            try (PreparedStatement psAtt = connection.prepareStatement(this.deleteSessionAttributeQuery)) {\n                                psAtt.setString(1, session.getId());\n                                psAtt.setString(2, entry.getKey());\n                                psAtt.executeUpdate();\n                            }\n                        } else {\n                            int updatedCount = 0;\n                            try (PreparedStatement psAtt = connection.prepareStatement(this.updateSessionAttributeQuery)) {\n                                serialize(psAtt, 1, entry.getValue());\n                                psAtt.setString(2, session.getId());\n                                psAtt.setString(3, entry.getKey());\n                                updatedCount = psAtt.executeUpdate();\n                            }\n                            if (updatedCount == 0) {\n                                try (PreparedStatement psAtt = connection.prepareStatement(this.createSessionAttributeQuery)) {\n                                    psAtt.setString(1, session.getId());\n                                    psAtt.setString(2, entry.getKey());\n                                    serialize(psAtt, 3, entry.getValue());\n\n                                    psAtt.executeUpdate();\n                                }\n                            }\n\n                        }\n                    }\n                }\n                connection.commit();\n            } catch (SQLException e) {\n                logger.error(\"SqlException:\", e);\n            }\n        }\n        session.clearChangeFlags();\n    }\n\n    public  JdbcSessionRepository(DataSource dataSource);\n\n    public void setDefaultMaxInactiveInterval(int defaultMaxInactiveInterval);\n    @Override public JdbcSession createSession();\n    public Map<String, Session> getSessions();\n    @Override public JdbcSession findById(final String id);\n    @Override public void deleteById(final String id);\n    public void cleanUpExpiredSessions();\n    public void updateSessionLastAccessTime(final String id);\n    private String getQuery(String base);\n    private void prepareQueries();\n    private void serialize(PreparedStatement ps, int paramIndex, Object attributeValue);\n    private Object deserialize(ResultSet rs, String columnName);\n    public List<JdbcSession> extractData(ResultSet rs);\n    private JdbcSession getLast(List<JdbcSession> sessions);\n\n    public static DataSource ds;\n    private static Session session;\n    private static SessionConfig sessionConfig;\n    private static SessionRepository sessionRepository;\n\n}\n\nclass JdbcSessionRepositoryTest {\n\n    public static DataSource ds;\n    private static Session session;\n    private static SessionConfig sessionConfig;\n    private static SessionRepository sessionRepository;\n\n    @Test\n    public void testSave() {\n", "reference": "        session = sessionRepository.createSession();\n\n    }\n\n}", "prediction": "        JdbcSession session = sessionRepository.createSession();\n        session.setAttribute(\"test\", \"test\");\n        sessionRepository.save(session);\n        sessionRepository.save(session);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "104787715_32", "part": [1, 1], "seq": [1, 1], "prompt": "class GitHubUtil {\n\n    public GHMyself getMyself() throws IOException {\n        return github.getMyself();\n    }\n\n    public  GitHubUtil(GitHub gitHub);\n\n    public GitHub getGithub();\n    public GHRepository getRepo(String repo);\n    public GHRepository createPublicRepo(String repoName);\n    public GHContentSearchBuilder startSearch();\n    public GHRepository createFork(GHRepository repo);\n    public void safeDeleteRepo(GHRepository repo);\n    public int createPullReq(GHRepository origRepo, String branch,\n                                 GHRepository forkRepo, String title, String body);\n    protected GHBranch tryRetrievingBranch(GHRepository repo, String branchName);\n    public GHRepository tryRetrievingRepository(String repoName);\n    public GHContent tryRetrievingContent(GHRepository repo, String path, String branch);\n    public List<GHRepository> getGHRepositories(Multimap<String, String> pathToDockerfileInParentRepo,\n                                                 GHMyself currentUser);\n    protected void waitFor(long millis);\n    public boolean repoHasBranch(GHRepository repo, String branchName);\n    public Map<String, GHRepository> getReposForUserAtCurrentInstant(GHMyself user);\n\n}\n\nclass GitHubUtilTest {\n\n    @Test\n    public void testGetMyself() throws Exception {\n", "reference": "        GitHub github = mock(GitHub.class);\n        GHMyself myself = mock(GHMyself.class);\n        when(github.getMyself()).thenReturn(myself);\n        GitHubUtil gitHubUtil = new GitHubUtil(github);\n        assertEquals(gitHubUtil.getMyself(), myself);\n    }\n\n}", "prediction": "        GitHubUtil githubUtil = new GitHubUtil(null);\n        GHMyself myself = githubUtil.getMyself();\n        assertNotNull(myself);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "105081364_2", "part": [1, 1], "seq": [1, 1], "prompt": "class LogCompilation extends DefaultHandler implements ErrorHandler {\n\n    public static void main(String[] args) throws Exception {\n        Comparator<LogEvent> sort = LogParser.sortByStart;\n        boolean statistics = false;\n        boolean printInlining = false;\n        boolean cleanup = false;\n        boolean trapHistory = false;\n        boolean printTimeStamps = false;\n        boolean printID = true;\n        int index = 0;\n\n        while (args.length > index) {\n            String a = args[index];\n            if (a.equals(\"-e\")) {\n                sort = LogParser.sortByElapsed;\n                index++;\n            } else if (a.equals(\"-n\")) {\n                sort = LogParser.sortByNameAndStart;\n                index++;\n            } else if (a.equals(\"-s\")) {\n                sort = LogParser.sortByStart;\n                index++;\n            } else if (a.equals(\"-t\")) {\n                printTimeStamps = true;\n                index++;\n            } else if (a.equals(\"-c\")) {\n                cleanup = true;\n                index++;\n            } else if (a.equals(\"-S\")) {\n                statistics = true;\n                index++;\n            } else if (a.equals(\"-U\")) {\n                trapHistory = true;\n                index++;\n            } else if (a.equals(\"-h\")) {\n                usage(0);\n            } else if (a.equals(\"-i\")) {\n                printInlining = true;\n                index++;\n            } else if (a.equals(\"-C\")) {\n                compare = true;\n                index++;\n            } else if (a.equals(\"-d\")) {\n                printID = false;\n                index++;\n            } else {\n                if (a.charAt(0) == '-') {\n                    System.out.println(\"Unknown option '\" + a + \"', assuming file name.\");\n                }\n                break;\n            }\n        }\n\n        if (index >= args.length) {\n            usage(1);\n        }\n\n        if (compare) {\n            compareLogs(index, args);\n            return;\n        }\n\n        while (index < args.length) {\n            ArrayList<LogEvent> events = null;\n            try {\n                events = LogParser.parse(args[index], cleanup);\n            } catch (FileNotFoundException fnfe) {\n                System.out.println(\"File not found: \" + args[index]);\n                System.exit(1);\n            }\n\n            Collections.sort(events, sort);\n\n            if (statistics) {\n                printStatistics(events, System.out);\n            } else if (trapHistory) {\n                printTrapHistory(events, System.out);\n            } else {\n                for (LogEvent c : events) {\n                    if (c instanceof NMethod) {\n                        // skip these\n                        continue;\n                    }\n                    if (printTimeStamps) {\n                        System.out.print(c.getStart() + \": \");\n                    }\n                    if (c instanceof Compilation) {\n                        Compilation comp = (Compilation) c;\n                        comp.print(System.out, printID, printInlining);\n                    } else {\n                        c.print(System.out, printID);\n                    }\n                }\n            }\n            index++;\n        }\n    }\n\n    public static void usage(int exitcode);\n    public static void printStatistics(ArrayList<LogEvent> events, PrintStream out);\n    @SuppressWarnings(\"unchecked\") static void compareLogs(int index, String[] args);\n    public static void printTrapHistory(ArrayList<LogEvent> events, PrintStream out);\n\n     String logFile;\n    static final String setupArgsTieredVersion;\n    static final String setupArgsTiered;\n    static final String setupArgsTieredBatch;\n    static final String setupArgsNoTiered;\n    static final String setupArgsNoTieredBatch;\n    static final String allSetupArgs;\n\n}\n\nclass TestLogCompilation {\n\n     String logFile;\n    static final String setupArgsTieredVersion;\n    static final String setupArgsTiered;\n    static final String setupArgsTieredBatch;\n    static final String setupArgsNoTiered;\n    static final String setupArgsNoTieredBatch;\n    static final String allSetupArgs;\n\n    @Test\n    public void testDefault() throws Exception {\n", "reference": "        String[] args = {\n            logFile\n        };\n\n        LogCompilation.main(args);\n    }\n\n}", "prediction": "        String[] args = {logFile};\n        LogCompilation.main(args);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "105284146_230", "part": [1, 1], "seq": [1, 1], "prompt": "class XMLImporter implements Importer {\n\n    @Override\n    public String getFormat() {\n        return \"XIIDM\";\n    }\n\n    public  XMLImporter();\n    public  XMLImporter(PlatformConfig platformConfig);\n\n    @Override public List<Parameter> getParameters();\n    @Override public String getComment();\n    private String findExtension(ReadOnlyDataSource dataSource);\n    @Override public boolean exists(ReadOnlyDataSource dataSource);\n    private boolean exists(ReadOnlyDataSource dataSource, String ext);\n    @Override public void copy(ReadOnlyDataSource fromDataSource, DataSource toDataSource);\n    @Override public Network importData(ReadOnlyDataSource dataSource, NetworkFactory networkFactory, Properties parameters);\n    private ImportOptions createImportOptions(Properties parameters);\n\n    private XMLImporter importer;\n\n}\n\nclass XMLImporterTest  {\n\n    private XMLImporter importer;\n\n    @Test\n    public void getFormat() {\n", "reference": "        assertEquals(\"XIIDM\", importer.getFormat());\n    }\n\n}", "prediction": "        assertEquals(\"XIIDM\", importer.getFormat());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "106042361_0", "part": [1, 1], "seq": [1, 1], "prompt": "class SPIDIntegrationUtil {\n\n\tpublic Element xmlStringToElement(String xmlData) throws SAXException, IOException, ParserConfigurationException {\n\t\tInputStream xmlByteArrayInputStream = new ByteArrayInputStream(xmlData.getBytes());\n\t\tElement node = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(xmlByteArrayInputStream).getDocumentElement();\n\n\t\treturn node;\n\t}\n\n\tpublic  SPIDIntegrationUtil();\n\n\tpublic String encodeAndPrintAuthnRequest(AuthnRequest authnRequest);\n\tpublic String printAuthnRequest(AuthnRequest authnRequest);\n\tpublic Credential getCredential();\n\tpublic KeyStore getKeyStore();\n\tpublic Signature getSignature();\n\n      @Autowired\n      private SPIDIntegrationUtil spidIntegrationUtil;\n\n}\n\nclass SPIDIntegrationUtilTest {\n\n      @Autowired\n      private SPIDIntegrationUtil spidIntegrationUtil;\n\n      @Test\n      public void xmlStringToXMLObjectTest() {\n", "reference": "\n            ClassLoader classLoader = getClass().getClassLoader();\n            File xmlFile = new File(classLoader.getResource(\"metadata/idp/telecom-metadata.xml\").getFile());\n            try (Scanner scanner = new Scanner(xmlFile)) {\n                  String xmlData = scanner.useDelimiter(\"\\\\Z\").next();\n                  Element node = spidIntegrationUtil.xmlStringToElement(xmlData);\n\n                  Assert.assertEquals(\"md:EntityDescriptor\", node.getNodeName());\n\n            } catch (SAXException | IOException | ParserConfigurationException e) {\n                  e.printStackTrace();\n                  Assert.fail();\n            }\n      }\n\n}", "prediction": "\ttry {\n\t\tString xmlData = \"<AuthnRequest xmlns=\\\"urn:oasis:names:tc:SAML:2.0:protocol\\\" ID=\\\"_0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "107370456_0", "part": [1, 1], "seq": [1, 1], "prompt": "class EmailUtil {\n\n\tpublic static boolean send(String receiverName, String receiverAccount, String subject, String content) {\n\t\tProperties props = System.getProperties();\n\t\tprops.setProperty(\"mail.transport.protocol\", \"smtp\");\n\t\tprops.setProperty(\"mail.smtp.host\", SENDER_SMTP_HOST);\n\t\tprops.setProperty(\"mail.smtp.auth\", \"true\");\n\n\t\tSession session = Session.getDefaultInstance(props);\n\t\t// \u8bbe\u7f6e\u4e3adebug\u6a21\u5f0f, \u53ef\u4ee5\u67e5\u770b\u8be6\u7ec6\u7684\u53d1\u9001log\n\t\tsession.setDebug(DEBUG);\n\n\t\tTransport transport = null;\n\t\ttry {\n\t\t\tMimeMessage message = createMimeMessage(session, receiverName, receiverAccount, subject, content);\n\t\t\ttransport = session.getTransport();\n\t\t\ttransport.connect(SENDER_ACCOUNT, SENDER_PASSWORD);\n\t\t\ttransport.sendMessage(message, message.getAllRecipients());\n\t\t} catch (UnsupportedEncodingException | MessagingException e) {\n\t\t\tlogger.error(EMAIL_SEND_ERROR, e);\n\t\t\treturn false;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (transport!= null) {\n\t\t\t\t\ttransport.close();\n\t\t\t\t}\n\t\t\t} catch (MessagingException e) {\n\t\t\t\tlogger.error(EMAIL_SEND_ERROR, e);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate static MimeMessage createMimeMessage(Session session, String receiverName, String receiverAccount, String subject, String content);\n\n}\n\nclass EmailUtilTest {\n\n\t@Test\n\tpublic void send() throws Exception {\n", "reference": "\t\tboolean success = EmailUtil.send(\"favorisites\u7528\u6237\", \"1203948298@qq.com\",\n\t\t\t\t\"123456\u662f\u60a8\u7684favorisites\u9a8c\u8bc1\u7801\", \"<div style=\\\"text-align: center;color:dodgerblue;\\\">\u6b22\u8fce\u6ce8\u518c\u4f7f\u7528favoristes\uff0c \u60a8\u7684\u9a8c\u8bc1\u7801\u662f123456</div>\");\n\t\tSystem.out.println(success);\n\t}\n\n}", "prediction": "\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "107740230_11", "part": [1, 1], "seq": [1, 1], "prompt": "class Table implements Comparable<Table> {\n\n    public final String getName()\n    {\n        return name;\n    }\n\n    public  Table(final DBSchema schema, final String name);\n    public  Table(final DBSchema schema, final DBTableInfo tableInfo);\n    public  Table(final String name, final Table toCopy);\n\n    @Override public boolean equals(Object tableObj);\n    public int compareTo(Table tbl);\n    public final Collection<Field> getFields();\n    public final Vector<Relationship> getRelationships();\n    public void addField(final Field field);\n    public Field getField(String fldName);\n    public Field getKey();\n    public final DBTableInfo getTableInfo();\n    public final DBSchema getSchema();\n\n\tprotected static Table testtable;\n\n}\n\nclass TableTest {\n\n\tprotected static Table testtable;\n\n\t@Test\n\tpublic void testGetName() {\n", "reference": "\t\tassertTrue(testtable.getName().equals(\"testtable\"));\n\t}\n\n}", "prediction": "\t\tassertEquals(\"testtable\", testtable.getName());\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "107872025_2", "part": [1, 1], "seq": [1, 1], "prompt": "class JaroWinkler {\n\n    public final double similarity(@NonNull final String s1, @NonNull final String s2) {\n        if (s1 == null) {\n            throw new NullPointerException(\"s1 must not be null\");\n        }\n\n        if (s2 == null) {\n            throw new NullPointerException(\"s2 must not be null\");\n        }\n\n        if (s1.equals(s2)) {\n            return 1;\n        }\n\n        int[] mtp = matches(s1, s2);\n        float m = mtp[0];\n        if (m == 0) {\n            return 0f;\n        }\n        double j = ((m / s1.length() + m / s2.length() + (m - mtp[1]) / m))\n                / THREE;\n        double jw = j;\n\n        if (j > getThreshold()) {\n            jw = j + Math.min(JW_COEF, 1.0 / mtp[THREE]) * mtp[2] * (1 - j);\n        }\n        return jw;\n    }\n\n    public  JaroWinkler();\n    public  JaroWinkler(final double threshold);\n\n    public final double getThreshold();\n    public final double distance(@NonNull final String s1, @NonNull final String s2);\n    private int[] matches(@NonNull final String s1, @NonNull final String s2);\n\n     JaroWinkler jw;\n\n}\n\nclass JaroWinklerTest {\n\n     JaroWinkler jw;\n\n    @Test\n    public void testShort() {\n", "reference": "        String s = \"sl\";\n        String s2 = \"s\";\n        assert(jw.similarity(s,s2) > .8);\n    }\n\n}", "prediction": "        assertEquals(1.0, jw.similarity(\"a\", \"a\"), 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "108101992_3", "part": [1, 1], "seq": [1, 1], "prompt": "class IRIBuilder {\n\n    public IRI buildCanvasIRI(final String canvasIdString) {\n        return rdf.createIRI(canvasIdString);\n    }\n\n    public  IRIBuilder(final Config config);\n    private  IRIBuilder();\n\n    public IRI buildResourceIRI(final String resourceIdString);\n    public IRI buildServiceIRI(final String imageServiceContext, final String resourceIdString);\n    public String buildImageServiceContext(final String viewId);\n    public String buildCanvasIRIfromPhysical(final String physical);\n    public String buildAnnotationId();\n\n}\n\nclass IRIBuilderTest {\n\n    @Test\n    void testBuildCanvasIRI() {\n", "reference": "        final Config config = new Config();\n        config.setBaseUrl(\"http://example.org/\");\n        config.setViewId(\"12345\");\n        config.setImageServiceBaseUrl(\"https://iiif.ub.uni-leipzig.de/iiif\");\n        config.setImageServiceImageDirPrefix(\"/j2k/\");\n        config.setCanvasContext(\"/canvas\");\n        final IRIBuilder iriBuilder = new IRIBuilder(config);\n        final String viewId = \"12345\";\n        final String resourceFileId = \"00000001\";\n        final String resourceIdString = config.getBaseUrl() + viewId + config.getCanvasContext() + \"/\" + resourceFileId;\n        final IRI canvasIRI = iriBuilder.buildCanvasIRI(resourceIdString);\n        assertEquals(\"http://example.org/12345/canvas/00000001\", canvasIRI.getIRIString());\n    }\n\n}", "prediction": "        final IRIBuilder iriBuilder = new IRIBuilder(new Config());\n        final IRI canvasIRI = iriBuilder.buildCanvasIRI(\"http://example.org/canvas/1\");\n        assertEquals(\"http://example.org/canvas/1\", canvasIRI.toString());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "109327955_12", "part": [1, 1], "seq": [1, 1], "prompt": "class QuickFixJTemplate implements QuickFixJOperations {\n\n\t@Override\n\tpublic boolean send(Message message) {\n\t\tAssert.notNull(message, \"'message' must not be null\");\n\n\t\tSessionID sessionID = QuickFixJSessionID.quickFixJSessionIDBuilder()\n\t\t\t\t.message(message)\n\t\t\t\t.build().toSessionID();\n\t\treturn doSend(message, sessionID);\n\t}\n\n\tpublic  QuickFixJTemplate();\n\tpublic  QuickFixJTemplate(SessionLookupHandler sessionLookupHandler);\n\n\tpublic void setSessionLookupHandler(SessionLookupHandler sessionLookupHandler);\n\tpublic void setDoValidation(boolean doValidation);\n\t@Override public boolean send(Message message, String qualifier);\n\t@Override public boolean send(Message message, String senderCompID, String targetCompID);\n\t@Override public boolean send(Message message, String senderCompID, String targetCompID, String qualifier);\n\t@Override public boolean send(Message message, SessionID sessionID);\n\tprotected boolean doSend(Message message, SessionID sessionID);\n\tprivate void validateMessage(Message message, SessionID sessionID, Session session);\n\tprivate static ApplVerID getApplicationVersionID(Message message, Session session);\n\tprivate static ApplVerID getDefaultApplVerID(Session session);\n\n\t@Rule\n\tpublic MockitoRule mockitoRule;\n\t@Mock\n\tprivate SessionLookupHandler sessionLookupHandler;\n\t@Mock\n\tprivate Session session;\n\t@Mock\n\tprivate Message message;\n\t@Mock\n\tprivate DataDictionary applicationDataDictionary;\n\t@Mock\n\tprivate DataDictionaryProvider dataDictionaryProvider;\n\tprivate QuickFixJTemplate quickFixJTemplate;\n\tprivate String expectedBeginString;\n\tprivate String expectedSender;\n\tprivate String expectedTarget;\n\tprivate String expectedQualifier;\n\n}\n\nclass QuickFixJTemplateTest {\n\n\t@Rule\n\tpublic MockitoRule mockitoRule;\n\t@Mock\n\tprivate SessionLookupHandler sessionLookupHandler;\n\t@Mock\n\tprivate Session session;\n\t@Mock\n\tprivate Message message;\n\t@Mock\n\tprivate DataDictionary applicationDataDictionary;\n\t@Mock\n\tprivate DataDictionaryProvider dataDictionaryProvider;\n\tprivate QuickFixJTemplate quickFixJTemplate;\n\tprivate String expectedBeginString;\n\tprivate String expectedSender;\n\tprivate String expectedTarget;\n\tprivate String expectedQualifier;\n\n\t@Test\n\tpublic void shouldSendMessageWithQualifier() throws FieldNotFound {\n", "reference": "\t\t// Given\n\t\tmockMessage(expectedBeginString, expectedSender, expectedTarget);\n\t\tmockSessionFound();\n\n\t\tSessionID expectedSessionID = new SessionID(expectedBeginString, expectedSender, expectedTarget, expectedQualifier);\n\t\tgiven(session.send(message)).willReturn(true);\n\n\t\t// When\n\t\tboolean sent = quickFixJTemplate.send(message, expectedQualifier);\n\n\t\t// Then\n\t\tassertThat(sent).isTrue();\n\t\tassertSessionID(expectedSessionID);\n\t\tassertMessageSent(expectedSender, expectedTarget);\n\t}\n\n}", "prediction": "\t\twhen(message.getHeader().getString(Tags.BeginString)).thenReturn(expectedBeginString);\n\t\twhen(message.getHeader().getString(Tags.SenderCompID)).thenReturn(expectedSender);\n\t\twhen(message.getHeader().getString(Tags.TargetCompID)).thenReturn(expectedTarget);\n\t\twhen(message.getHeader().getString(Tags.ApplVerID)).thenReturn(expectedQualifier);\n\t\twhen(sessionLookupHandler.lookupSession(expectedBeginString, expectedSender, expectedTarget, expectedQualifier)).thenReturn(session);\n\n\t\tquickFixJTemplate.send(message, expectedQualifier);\n\n\t\tverify(session).send(message);\n\t}", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "109554428_28", "part": [1, 1], "seq": [1, 1], "prompt": "class BrokerInterceptor implements Interceptor {\n\n    @Override\n    public void notifyClientConnected(final MqttConnectMessage msg) {\n        for (final InterceptHandler handler : this.handlers.get(InterceptConnectMessage.class)) {\n            LOG.debug(\"Sending MQTT CONNECT message to interceptor. CId={}, interceptorId={}\",\n                    msg.payload().clientIdentifier(), handler.getID());\n            executor.execute(() -> handler.onConnect(new InterceptConnectMessage(msg)));\n        }\n    }\n\n    private  BrokerInterceptor(int poolSize, List<InterceptHandler> handlers);\n      BrokerInterceptor(List<InterceptHandler> handlers);\n      BrokerInterceptor(IConfig props, List<InterceptHandler> handlers);\n\n     void stop();\n    @Override public void notifyClientDisconnected(final String clientID, final String username);\n    @Override public void notifyClientConnectionLost(final String clientID, final String username);\n    @Override public void notifyTopicPublished(final MqttPublishMessage msg, final String clientID, final String username);\n    @Override public void notifyTopicSubscribed(final Subscription sub, final String username);\n    @Override public void notifyTopicUnsubscribed(final String topic, final String clientID, final String username);\n    @Override public void notifyMessageAcknowledged(final InterceptAcknowledgedMessage msg);\n    @Override public void addInterceptHandler(InterceptHandler interceptHandler);\n    @Override public void removeInterceptHandler(InterceptHandler interceptHandler);\n    private static Class<?>[] getInterceptedMessageTypes(InterceptHandler interceptHandler);\n\n    private static final AtomicInteger n;\n    private static final BrokerInterceptor interceptor;\n\n}\n\nclass BrokerInterceptorTest {\n\n    private static final AtomicInteger n;\n    private static final BrokerInterceptor interceptor;\n\n    @Test\n    public void testNotifyClientConnected() throws Exception {\n", "reference": "        interceptor.notifyClientConnected(MqttMessageBuilders.connect().build());\n        interval();\n        assertEquals(40, n.get());\n    }\n\n}", "prediction": "        final MqttConnectMessage msg = new MqttConnectMessage(MqttConnectMessage.VERSION_3_1_1, false, 0, \"clientID\".getBytes());\n        interceptor.notifyClientConnected(msg);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "109667968_43", "part": [1, 1], "seq": [1, 1], "prompt": "class MBTilesHelper {\n\n    public void setMBTileLayers(Context context, BaseLayerSwitcherPlugin baseLayerSwitcherPlugin) {\n        if (mbtilesDir.exists() && mbtilesDir.exists() && mbtilesDir.listFiles()!= null) {\n            for (File mbTile : mbtilesDir.listFiles()) {\n                MBTilesLayer mbTilesLayer = new MBTilesLayer(context, mbTile, this);\n                if (!TextUtils.isEmpty(mbTilesLayer.getDisplayName())) {\n                    baseLayerSwitcherPlugin.addBaseLayer(mbTilesLayer, false);\n                }\n            }\n        }\n\n    }\n\n    private void init(List<File> offlineFiles);\n    public void initializeMbTileslayers(@NonNull Style style, List<File> offlineFiles);\n    public Pair<Set<Source>, Set<Layer>> initializeMbTileslayers(File offlineFile);\n    private void initializeMbTilesServer();\n    public void onDestroy();\n    private void addMbtiles(Style style, String id, File file);\n    private Pair<Source, List<Layer>> addMbtiles(String id, File file);\n    private TileSet createTileSet(MbtilesFile mbtiles, String urlTemplate);\n\n    @Rule\n    public MockitoRule rule;\n    private Context context;\n    @Mock\n    private Style style;\n    @Mock\n    private BaseLayerSwitcherPlugin switcherPlugin;\n    private MBTilesHelper mbTilesHelper;\n\n}\n\nclass MBTilesHelperTest  {\n\n    @Rule\n    public MockitoRule rule;\n    private Context context;\n    @Mock\n    private Style style;\n    @Mock\n    private BaseLayerSwitcherPlugin switcherPlugin;\n    private MBTilesHelper mbTilesHelper;\n\n    @Test\n    public void testSetMBTileLayers() {\n", "reference": "        ReflectionHelpers.setField(mbTilesHelper, \"mbtilesDir\", new File(\"src/test/resources/\"));\n        mbTilesHelper.setMBTileLayers(context, switcherPlugin);\n        verify(switcherPlugin, times(2)).addBaseLayer(any(MBTilesLayer.class), eq(false));\n    }\n\n}", "prediction": "        mbTilesHelper.setMBTileLayers(context, switcherPlugin);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "109986674_101", "part": [1, 1], "seq": [1, 1], "prompt": "class PropertyManager {\n\n    public void setCustomParametersFile(String customParametersFile) throws CluecumberPluginException {\n        this.customParametersFile = customParametersFile;\n        if (!isSet(customParametersFile)) {\n            return;\n        }\n        if (!fileIO.isExistingFile(customParametersFile)) {\n            throw new MissingFileException(customParametersFile + \" (customParametersFile)\");\n        }\n        Map<String, String> customParameters = propertiesFileLoader.loadPropertiesMap(customParametersFile);\n        this.customParameters.putAll(customParameters);\n    }\n\n    @Inject public  PropertyManager(\n            final CluecumberLogger logger,\n            FileIO fileIO,\n            final PropertiesFileLoader propertiesFileLoader\n    );\n\n    public String getSourceJsonReportDirectory();\n    public void setSourceJsonReportDirectory(final String sourceJsonReportDirectory);\n    public String getGeneratedHtmlReportDirectory();\n    public void setGeneratedHtmlReportDirectory(final String generatedHtmlReportDirectory);\n    public Map<String, String> getCustomParameters();\n    public void setCustomParameters(final Map<String, String> customParameters);\n     String getCustomParametersFile();\n    public boolean isFailScenariosOnPendingOrUndefinedSteps();\n    public void setFailScenariosOnPendingOrUndefinedSteps(final boolean failScenariosOnPendingOrUndefinedSteps);\n    public boolean isExpandBeforeAfterHooks();\n    public void setExpandBeforeAfterHooks(final boolean expandBeforeAfterHooks);\n    public boolean isExpandStepHooks();\n    public void setExpandStepHooks(final boolean expandStepHooks);\n    public boolean isExpandDocStrings();\n    public void setExpandDocStrings(final boolean expandDocStrings);\n    public String getCustomCssFile();\n    public void setCustomCssFile(final String customCssFile);\n    public String getCustomStatusColorPassed();\n    public void setCustomStatusColorPassed(final String customStatusColorPassed);\n    public String getCustomStatusColorFailed();\n    public void setCustomStatusColorFailed(final String customStatusColorFailed);\n    public String getCustomStatusColorSkipped();\n    public void setCustomStatusColorSkipped(final String customStatusColorSkipped);\n    public String getCustomPageTitle();\n    public void setCustomPageTitle(final String customPageTitle);\n    public void logProperties();\n    private boolean isSet(final String string);\n    private void checkHexColorValidity(String color, String colorPropertyName);\n    public PluginSettings.StartPage getStartPage();\n    public void setStartPage(final String startPage);\n\n    private PropertyManager propertyManager;\n    private CluecumberLogger logger;\n    private FileIO fileIO;\n\n}\n\nclass PropertyManagerTest {\n\n    private PropertyManager propertyManager;\n    private CluecumberLogger logger;\n    private FileIO fileIO;\n\n    @Test(expected = MissingFileException.class)\n    public void setCustomParametersFileNonExistingTest() throws CluecumberPluginException {\n", "reference": "        String customParametersFile = \"customParametersFile\";\n        when(fileIO.isExistingFile(customParametersFile)).thenReturn(false);\n        propertyManager.setCustomParametersFile(customParametersFile);\n    }\n\n}", "prediction": "        propertyManager.setCustomParametersFile(\"nonExistingFile\");\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "112947883_12", "part": [1, 1], "seq": [1, 1], "prompt": "class ValidateTor {\n\n  public boolean isPhoneNumber(String str) {\n    return regexMatcher.validate(str, RegexPresetPattern.PHONE);\n  }\n\n  public  ValidateTor();\n\n  public boolean containsSubstring(String str, String seed);\n  public boolean isAlpha(String str);\n  public boolean isAlphanumeric(String str);\n  public boolean isBoolean(String str);\n  public boolean isIPAddress(String str);\n  public boolean isEmail(String str);\n  public boolean isEmpty(String str);\n  public boolean isBase64(String str);\n  public boolean isDecimal(String str);\n  public boolean isAtleastLength(String str, int len);\n  public boolean isAtMostLength(String str, int len);\n  public boolean isLowercase(String str);\n  public boolean isUppercase(String str);\n  public boolean isValidMD5(String str);\n  public boolean isNumeric(String str);\n  public boolean isMACAddress(String str);\n  public boolean isJSON(String str);\n  public boolean isInteger(String str);\n  public boolean isIn(String str, String[] values);\n  public boolean isHexadecimal(String str);\n  public boolean isPinCode(String str);\n  public boolean isHexColor(String str);\n  public boolean hasAtleastOneDigit(String str);\n  public boolean hasAtleastOneLetter(String str);\n  public boolean hasAtleastOneLowercaseCharacter(String str);\n  public boolean hasAtleastOneUppercaseCharacter(String str);\n  public boolean hasAtleastOneSpecialCharacter(String str);\n  public boolean validateCreditCard(String str);\n  public CardInformation getCreditCardInfo(String str);\n\n  private ValidateTor validateTor;\n\n}\n\nclass ValidateTorTest {\n\n  private ValidateTor validateTor;\n\n  @Test\n  public void isPhoneNumber_shouldReturnFalse_whenStringIsInvalidPhoneNumber() throws Exception {\n", "reference": "    assertEquals(false, validateTor.isPhoneNumber(\"000-000-0000\"));\n    assertEquals(false, validateTor.isPhoneNumber(\"123-456-7890\"));\n    assertEquals(false, validateTor.isPhoneNumber(\"2126661234\"));\n\n  }\n\n}", "prediction": "    assertFalse(validateTor.isPhoneNumber(\"1234567890\"));\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "113878762_12", "part": [1, 1], "seq": [1, 1], "prompt": "class Volume {\n\nabstract public long getLong(final long offset)abstract public long getLong(final long offset);\n\nabstract public long getLong(final long offset)abstract public void ensureAvailable(final long offset);\nabstract public long getLong(final long offset)abstract public void putLong(final long offset, final long value);\nabstract public long getLong(final long offset)abstract public void putInt(long offset, int value);\nabstract public long getLong(final long offset)abstract public void putByte(final long offset, final byte value);\nabstract public long getLong(final long offset)abstract public void putData(final long offset, final byte[] value, int size);\nabstract public long getLong(final long offset)abstract public void putData(final long offset, final ByteBuffer buf);\nabstract public long getLong(final long offset)abstract public int getInt(long offset);\nabstract public long getLong(final long offset)abstract public byte getByte(final long offset);\nabstract public long getLong(final long offset)abstract public DataInput2 getDataInput(final long offset, final int size);\nabstract public long getLong(final long offset)abstract public void close();\nabstract public long getLong(final long offset)abstract public void sync();\nabstract public long getLong(final long offset)public abstract boolean isEmpty();\nabstract public long getLong(final long offset)public abstract void deleteFile();\nabstract public long getLong(final long offset)public abstract boolean isSliced();\nabstract public long getLong(final long offset)public final void putUnsignedShort(final long offset, final int value);\nabstract public long getLong(final long offset)public final int getUnsignedShort(long offset);\nabstract public long getLong(final long offset)public int getUnsignedByte(long offset);\nabstract public long getLong(final long offset)public void putUnsignedByte(long offset, int b);\nabstract public long getLong(final long offset)abstract public File getFile();\nabstract public long getLong(final long offset)public static Volume volumeForFile(File f, boolean useRandomAccessFile, boolean readOnly);\nabstract public long getLong(final long offset)public static Factory fileFactory(final boolean readOnly, final boolean RAF, final File indexFile);\nabstract public long getLong(final long offset)public static Factory fileFactory(final boolean readOnly,\n                                      final boolean RAF,\n                                      final File indexFile,\n                                      final File physFile,\n                                      final File transLogFile);\nabstract public long getLong(final long offset)public static Factory memoryFactory(final boolean useDirectBuffer);\n\n    final int beyondInc;\n     Volume b;\n\n}\n\nclass VolumeTest {\n\n    final int beyondInc;\n     Volume b;\n\n    @Test\n    public void read_beyond_end_raf_long(){\n", "reference": "        try{\n            Volume v = new Volume.RandomAccessFileVol(Utils.tempDbFile(), false);\n            v.getLong(1000000);\n            fail();\n        }catch(IOError e){\n            assertTrue(e.getCause() instanceof  EOFException);\n        }\n    }\n\n}", "prediction": "        final File f = File.createTempFile(\"test\", \".dat\");\n        try {\n            final RandomAccessFile raf = new RandomAccessFile(f, \"rw\");\n            raf.setLength(100);\n            raf.writeLong(100);\n            raf.close();\n            final Volume v = Volume.volumeForFile(f, true, false);\n            v.getLong(101);\n        } catch (IOException e) {\n            fail(e.getMessage());\n        }\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "114777829_217", "part": [1, 1], "seq": [1, 1], "prompt": "class HttpFilter extends GenericFilter {\n\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n            throws IOException, ServletException {\n        if (request instanceof HttpServletRequest && response instanceof HttpServletResponse) {\n            HttpServletRequest httpServletRequest = (HttpServletRequest) request;\n            HttpServletResponse httpServletResponse = (HttpServletResponse) response;\n            this.doFilter(httpServletRequest, httpServletResponse, chain);\n        } else {\n            throw new ServletException(\"not a HTTP request or a HTTP response\");\n        }\n\n    }\n\n    protected void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain);\n\n}\n\nclass HttpFilterTest {\n\n    @Test\n    void testDoFilter() throws Exception {\n", "reference": "        HttpServletRequest request = null;\n        HttpServletResponse response = null;\n        FilterChain chain = new TestFilterChain();\n        HttpFilter filter = new TestHttpFilter();\n        filter.doFilter(request, response, chain);\n    }\n\n}", "prediction": "        HttpServletRequest request = mock(HttpServletRequest.class);\n        HttpServletResponse response = mock(HttpServletResponse.class);\n        FilterChain chain = mock(FilterChain.class);\n\n        HttpFilter httpFilter = new HttpFilter() {\n            @Override\n            protected void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) {\n                // do nothing\n            }\n        };\n\n        httpFilter.doFilter(request, response, chain);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "115029573_1", "part": [1, 1], "seq": [1, 1], "prompt": "class IfcSpfReader {\n\n    public static String slurp(InputStream in) throws IOException {\n        StringBuilder out = new StringBuilder();\n        byte[] b = new byte[4096];\n        for (int n; (n = in.read(b))!= -1;) {\n            out.append(new String(b, 0, n));\n        }\n        return out.toString();\n    }\n\n    public static void main(String[] args);\n    public static List<String> showFiles(String dir);\n    private static String getExpressSchema(String ifcFile);\n    @SuppressWarnings(\"unchecked\") public void setup(String ifcFileIn);\n    public void convert(String ifcFile, String outputFile, String baseURI);\n    public void setRemoveDuplicates(boolean val);\n    public Map<String, EntityVO> getEntityMap();\n    public Map<String, TypeVO> getTypeMap();\n    public String getOntURI();\n\n    private IfcSpfReader reader;\n\n}\n\nclass TestIfcSpfReader {\n\n    private IfcSpfReader reader;\n\n    @Test\n    public final void testSlurp() {\n", "reference": "        // reader.slurp(in)\n    }\n\n}", "prediction": "        try {\n            InputStream in = new FileInputStream(\"src/test/resources/test.spf\");\n            String s = IfcSpfReader.slurp(in);\n            Assert.assertNotNull(s);\n            Assert.assertTrue(s.length() > 0);\n        } catch (IOException e) {\n            Assert.fail(e.getMessage());\n        }\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "117845334_2", "part": [1, 1], "seq": [1, 1], "prompt": "class TaskScheduer {\n\n    public void schedule(final IErrorHandler iErrorHandler, long timeout, ITimeoutHandler iTimeoutHandler, final ITasksFinishCallback iTasksFinishCallback) {\n        final AtomicInteger taskDoneCounter = new AtomicInteger(0);\n        final int taskCount = mTasks.size();\n        for (final LaunchTask task : mTasks) {\n            task.runOn().execute(new Worker(iErrorHandler, task, mTasks, new Worker.TaskDoneCallback() {\n                @Override\n                public void onTaskDone() {\n                    if (taskDoneCounter.addAndGet(1) == taskCount && iTasksFinishCallback!= null) {\n                        iTasksFinishCallback.onTasksFinished();\n                    }\n                }\n            }));\n        }\n        TaskDelayChecker.delayCheckTaskAlive(mTasks, timeout, iTimeoutHandler);\n    }\n\n    public  TaskScheduer(List<LaunchTask> originTasks);\n\n    private synchronized List<LaunchTask> topologicalSort(List<LaunchTask> originTasks);\n    private int getIndexOfTask(List<LaunchTask> originTasks, String taskName);\n\n}\n\nclass TaskScheduerTest {\n\n    @Test\n    public void schedule3() throws Exception {\n", "reference": "        final Executor executor = Executors.newCachedThreadPool();\n        final CountDownLatch downLatch = new CountDownLatch(3);\n        final long[] taskStartTime = {0, 0, 0};\n        final long[] taskEndTime = {0, 0, 0};\n        LaunchTask task0 = TaskFactory.create(\"task0\", 1000, new ArrayList<String>(), executor, new TestTaskCallback() {\n            @Override\n            public void taskStart() {\n                taskStartTime[0] = System.nanoTime();\n            }\n\n            @Override\n            public void taskEnd() {\n                taskEndTime[0] = System.nanoTime();\n                downLatch.countDown();\n            }\n        });\n        LaunchTask task1 = TaskFactory.create(\"task1\", 1000, Collections.singletonList(\"task0\"), executor, new TestTaskCallback() {\n            @Override\n            public void taskStart() {\n                taskStartTime[1] = System.nanoTime();\n            }\n\n            @Override\n            public void taskEnd() {\n                taskEndTime[1] = System.nanoTime();\n                downLatch.countDown();\n            }\n        });\n        LaunchTask task2 = TaskFactory.create(\"task2\", 1000, Arrays.asList(\"task0\", \"task1\"), executor, new TestTaskCallback() {\n            @Override\n            public void taskStart() {\n                taskStartTime[2] = System.nanoTime();\n            }\n\n            @Override\n            public void taskEnd() {\n                taskEndTime[2] = System.nanoTime();\n                downLatch.countDown();\n            }\n        });\n        new TaskScheduer(Arrays.asList(task2, task1, task0)).schedule(null, 0, null);\n        downLatch.await();\n        //1 \u4f9d\u8d56 0 ,2 \u4f9d\u8d56 1 ,2 \u4f9d\u8d560\n        Assert.assertTrue(taskEndTime[0] < taskStartTime[1]);\n        Assert.assertTrue(taskEndTime[1] < taskStartTime[2]);\n    }\n\n}", "prediction": "//        List<LaunchTask> tasks = new ArrayList<>();\n//        tasks.add(new LaunchTask(\"task1\", \"task2\"));\n//        tasks.add(new LaunchTask(\"task2\", \"task3\"));\n//        tasks.add(new LaunchTask(\"task3\", \"task4\"));\n//        tasks.add(new LaunchTask(\"task4\", \"task5\"));\n//        tasks.add(new LaunchTask(\"task5\", \"task6\"));\n//        tasks.add(new LaunchTask(\"task6\", \"task7\"));\n//        tasks.add(new LaunchTask(\"task7\", \"task8\"));\n//        tasks.add(new LaunchTask(\"task8\", \"task9\"));\n//        tasks.add(new LaunchTask(\"task9\", \"task10\"));\n//        tasks.add(new LaunchTask(\"task10\", \"task11\"));\n//        tasks.add(new LaunchTask(\"task11\", \"task12\"));\n//        tasks.add(new LaunchTask(\"task12\", \"task13\"));\n//        tasks.add(new LaunchTask(\"task13\", \"task14\"));\n//        tasks.add(new LaunchTask(\"task14\", \"task15\"));\n//        tasks.add(new LaunchTask(\"task15\", \"task16\"));\n//        tasks.add(new LaunchTask(\"task16\", \"task17\"));\n//        tasks.add(new LaunchTask(\"task17\", \"task18\"));\n//        tasks.add(new LaunchTask(\"task18\", \"task19\"));\n//        tasks.add(new LaunchTask(\"task19\", \"task20\"));\n//        tasks.add(new LaunchTask(\"task20\", \"task21\"));\n//        tasks.add(new LaunchTask(\"task21\", \"task22\"));\n//        tasks.add(new LaunchTask(\"task22\", \"task23\"));\n//        tasks.add(new LaunchTask(\"task23\", \"task24\"));\n//        tasks.add(new LaunchTask(\"task24\", \"task25\"));\n//        tasks.add(new LaunchTask(\"task25\", \"task26\"));\n//        tasks.add(new LaunchTask(\"task26\", \"task27\"));\n//        tasks.add(new LaunchTask(\"task27\", \"task28\"));\n//        tasks.add(new LaunchTask(\"task28\", \"task29\"));\n//        tasks.add(new LaunchTask(\"task29\", \"task30\"));\n//        tasks.add(new LaunchTask(\"task30\", \"task31\"));\n//        tasks.add(new LaunchTask(\"task31\", \"task32\"));\n//        tasks.add(new LaunchTask(\"task32\", \"task33\"));\n//        tasks.add(new LaunchTask(\"task33\", \"task34\"));\n//        tasks.add(new LaunchTask(\"task34\", \"task35\"));\n//        tasks.add(new LaunchTask(\"task35\", \"task36\"));\n//        tasks.add(new LaunchTask(\"task36\", \"task37\"));\n//        tasks.add(new LaunchTask(\"task37\", \"task38\"));\n//        tasks.add(new LaunchTask(\"task38\", \"task39\"));\n//        tasks.add(new LaunchTask(\"task39\", \"task40\"));\n//        tasks.add(new LaunchTask(\"task40\", \"task41\"));\n//        tasks.add(new LaunchTask(\"task41\", \"task42\"));\n//        tasks.add(new LaunchTask(\"task42\", \"task43\"));\n//        tasks.add(new LaunchTask(\"task43\", \"task44\"));\n//        tasks.add(new LaunchTask(\"task44\", \"task45\"));\n//        tasks.add(new LaunchTask(\"task45\", \"task46\"));\n//        tasks.add(new LaunchTask(\"task46\", \"task47\"));\n//        tasks.add(new LaunchTask(\"task47\", \"task48\"));\n//        tasks.add(new LaunchTask(\"task48\", \"task49\"));\n//        tasks.add(new LaunchTask(\"task49\", \"task50\"));\n//        tasks.add(new LaunchTask(\"task50\", \"task51\"));\n//        tasks.add(new LaunchTask(\"task51\", \"task52\"));\n//        tasks.add(new LaunchTask(\"task52\", \"task53\"));\n//        tasks.add(new LaunchTask(\"task53\", \"task54\"));\n//        tasks.add(new LaunchTask(\"task54\", \"task55\"));\n//        tasks.add(new LaunchTask(\"task55\", \"task56\"));\n//        tasks.add(new LaunchTask(\"task56\", \"task57\"));\n//        tasks.add(new LaunchTask(\"task57\", \"task58\"));\n//        tasks.add(new LaunchTask(\"task58\", \"task59\"));\n//        tasks.add(new LaunchTask(\"task59\", \"task60\"));\n//        tasks.add(new LaunchTask(\"task60\", \"task61\"));\n//        tasks.add(new LaunchTask(\"task61\", \"task62\"));\n//        tasks.add(new LaunchTask(\"task62\", \"task63\"));\n//        tasks.add(new LaunchTask(\"task63\", \"task64\"));\n//        tasks.add(new LaunchTask(\"task64\", \"task65\"));\n//        tasks.add(new LaunchTask(\"task65\", \"task66\"));\n//        tasks.add(new LaunchTask(\"task66\", \"task67\"));\n//        tasks.add(new LaunchTask(\"task67\", \"task68\"));\n//        tasks.add(new LaunchTask(\"task68\", \"task69\"));\n//        tasks.add(new LaunchTask(\"task69\", \"task70\"));\n//        tasks.add(new LaunchTask(\"task70\", \"task71\"));\n//        tasks.add(new LaunchTask(\"task71\", \"task72\"));\n//        tasks.add(new LaunchTask(\"task72\", \"task73\"));\n//        tasks.add(new LaunchTask(\"task73\", \"task74\"));\n//        tasks.add(new LaunchTask(\"task74\", \"task75\"));\n//        tasks.add(new LaunchTask(\"task75\", \"task76\"));\n//        tasks.add(new LaunchTask(\"task76\", \"task77\"));\n//        tasks.add(new LaunchTask(\"task77\", \"task78\"));\n//        tasks.add(new LaunchTask(\"task78\", \"task79\"));\n//        tasks.add(new LaunchTask(\"task79\", \"task80\"));\n//        tasks.add(new LaunchTask(\"task80\", \"task81\"));\n//        tasks.add(new LaunchTask(\"task81\", \"task82\"));\n//        tasks.add(new LaunchTask(\"task82\", \"task83\"));\n//        tasks.add(new LaunchTask(\"task83\", \"task84\"));\n//        tasks.add(new LaunchTask(\"task84\", \"task85\"));\n//        tasks.add(new LaunchTask(\"task85\", \"task86\"));\n//        tasks.add(new LaunchTask(\"task86\", \"task87\"));\n//        tasks.add(new LaunchTask(\"task87\", \"task88\"));\n//        tasks.add(new LaunchTask(\"task88\", \"task89\"));\n//        tasks.add(new LaunchTask(\"task89\", \"task90\"));\n//        tasks.add(new LaunchTask(\"task90", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "117949407_1", "part": [1, 1], "seq": [1, 1], "prompt": "class ZuulFiltersModule extends AbstractModule {\n\n    @VisibleForTesting\n    String[] findFilterLocations(AbstractConfiguration config) {\n        String[] locations = config.getStringArray(\"zuul.filters.locations\");\n        if (locations == null) {\n            locations = new String[]{\"inbound\",\"outbound\",\"endpoint\"};\n        }\n        String[] filterLocations = Arrays.stream(locations)\n               .map(String::trim)\n               .filter(blank.negate())\n               .toArray(String[]::new);\n\n        if (filterLocations.length!= 0) {\n            LOG.info(\"Using filter locations: \");\n            for (String location : filterLocations) {\n                LOG.info(\"  \" + location);\n            }\n        }\n        return filterLocations;\n    }\n\n    @Override protected void configure();\n    @Provides FilterFileManagerConfig provideFilterFileManagerConfig();\n    @VisibleForTesting String[] findClassNames(AbstractConfiguration config);\n\n    @Mock AbstractConfiguration configuration;\n     ZuulFiltersModule module;\n\n}\n\nclass ZuulFiltersModuleTest {\n\n    @Mock AbstractConfiguration configuration;\n     ZuulFiltersModule module;\n\n    @Test\n    public void testEmptyFilterLocations() {\n", "reference": "        when(configuration.getStringArray(eq(\"zuul.filters.locations\"))).thenReturn(new String[0]);\n\n        String[] filterLocations = module.findFilterLocations(configuration);\n\n        assertThat(filterLocations.length, equalTo(0));\n    }\n\n}", "prediction": "        when(configuration.getStringArray(\"zuul.filters.locations\")).thenReturn(null);\n        String[] locations = module.findFilterLocations(configuration);\n        assertThat(locations).containsExactly(\"inbound\",\"outbound\",\"endpoint\");\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "118006325_0", "part": [1, 1], "seq": [1, 1], "prompt": "class PlanetConverter {\n\n    public PlanetDTO convertPlanet(Planet planet) {\n        PlanetDTO dto = objectMapper.convertValue(planet, PlanetDTO.class);\n\n        dto.films = planet.filmsUrls.stream()\n               .map(filmUrl -> restTemplate.getForObject(filmUrl, FilmDTO.class))\n               .collect(Collectors.toList());\n\n        dto.residents = planet.residentsUrls.stream()\n               .map(filmUrl -> restTemplate.getForObject(filmUrl, PeopleDTO.class))\n               .collect(Collectors.toList());\n\n        return dto;\n    }\n\n    @Mock\n    private RestTemplate restTemplate;\n    @Autowired\n    @InjectMocks\n    private PlanetConverter converter;\n    private PeopleDTO lukeSkywalker;\n    private FilmDTO attackOfTheClones;\n    private Planet tatooine;\n\n}\n\nclass PlanetConverterTest {\n\n    @Mock\n    private RestTemplate restTemplate;\n    @Autowired\n    @InjectMocks\n    private PlanetConverter converter;\n    private PeopleDTO lukeSkywalker;\n    private FilmDTO attackOfTheClones;\n    private Planet tatooine;\n\n    @Test\n    public void converterTest() {\n", "reference": "        PlanetDTO planet = converter.convertPlanet(tatooine);\n\n        assertThat(planet, matchesSnapshot());\n    }\n\n}", "prediction": "        PlanetDTO dto = converter.convertPlanet(tatooine);\n\n        assertEquals(tatooine.name, dto.name);\n        assertEquals(tatooine.rotationPeriod, dto.rotationPeriod);\n        assertEquals(tatooine.orbitalPeriod, dto.orbitalPeriod);\n        assertEquals(tatooine.diameter, dto.diameter);\n        assertEquals(tatooine.climate, dto.climate);\n        assertEquals(tatooine.gravity, dto.gravity);\n        assertEquals(tatooine.terrain, dto.terrain);\n        assertEquals(tatooine.surfaceWater, dto.surfaceWater);\n        assertEquals(tatooine.population, dto.population);\n        assertEquals(tatooine.residentsUrls, dto.residents);\n        assertEquals(tatooine.filmsUrls, dto.films);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "118132535_73", "part": [1, 1], "seq": [1, 1], "prompt": "class MessageDispatcher implements Consumer<M>, Disposable {\n\n  @Override\n  public void accept(final M message) {\n    if (disposed) {\n      return;\n    }\n\n    runner.post(\n        () -> {\n          try {\n            consumer.accept(message);\n          } catch (Throwable throwable) {\n            MobiusHooks.handleError(\n                new RuntimeException(\n                    \"Consumer threw an exception when accepting message: \" + message, throwable));\n          }\n        });\n  }\n\n    MessageDispatcher(WorkRunner runner, Consumer<M> consumer);\n\n  @Override public void dispose();\n\n  private List<String> messages;\n\n}\n\nclass MessageDispatcherTest {\n\n  private List<String> messages;\n\n  @Test\n  public void shouldSendErrorsFromConsumerToMobiusHooks() throws Exception {\n", "reference": "    // given an error handler\n    TestErrorHandler errorHandler = new TestErrorHandler();\n\n    MobiusHooks.setErrorHandler(errorHandler);\n\n    final RuntimeException expected = new RuntimeException(\"boo\");\n\n    // and a message consumer that throws an exception,\n    // when a message is dispatched\n    new MessageDispatcher<String>(\n            WorkRunners.immediate(),\n            s -> {\n              throw expected;\n            })\n        .accept(\"here's an event that should be reported as the cause of failure\");\n\n    // then the exception gets sent to the error handler.\n    assertThat(errorHandler.handledErrors).extracting(Throwable::getCause).contains(expected);\n    assertThat(errorHandler.handledErrors)\n        .extracting(Throwable::getMessage)\n        .has(\n            matching(\n                containsString(\"here's an event that should be reported as the cause of failure\")),\n            atIndex(0));\n  }\n\n}", "prediction": "    final Consumer<String> consumer =\n        message -> {\n          throw new RuntimeException(\"Consumer threw an exception\");\n        };\n    final MessageDispatcher<String> dispatcher = new MessageDispatcher<>(null, consumer);\n    dispatcher.accept(\"message\");\n    dispatcher.dispose();\n\n    assertThat(MobiusHooks.getErrors()).hasSize(1);\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "119258092_1", "part": [1, 1], "seq": [1, 1], "prompt": "class ExternalService {\n\n    public String sendPostRequest(String body){\n        String accessCode=getToken();\n        String externalResponse=\"\";\n        if(accessCode==\"\"){\n            return \"Invalid Access code provided\";\n        }\n\n        try{\n            String externalUrl=\"https://graph.facebook.com/v2.6/me/messages?access_token=\"+accessCode;\n            HttpHeaders headers=new HttpHeaders();\n            headers.setContentType(MediaType.APPLICATION_JSON);\n\n            HttpEntity<String> httpEntity=new HttpEntity<String>(body,headers);\n            RestTemplate template=new RestTemplate();\n\n            System.out.println(httpEntity.getBody());\n            externalResponse=template.postForObject(externalUrl,httpEntity,String.class);\n        }\n        catch (Exception ex){\n            ex.printStackTrace();\n        }\n\n        return externalResponse;\n    }\n\n    public String sendGetRequest(String url);\n    public String getToken();\n    public String getLeagueStanding(int leagueID);\n    public String getLeagueFixture(int leagueID, int matchDay);\n\n}\n\nclass ExternalServiceTest {\n\n    @Test\n    public void sendPostRequest() {\n", "reference": "//        fail();\n    }\n\n}", "prediction": "//        ExternalService externalService=new ExternalService();\n//        String response=externalService.sendPostRequest(\"{\\\"recipient\\\":{\\\"id\\\":\\\"123456789\\\"},\\\"message\\\":{\\\"text\\\":\\\"This is a test message\\\"}}\");\n//        System.out.println(response);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "119930717_0", "part": [1, 1], "seq": [1, 1], "prompt": "class MergeSortedArraysChallenge {\n\n    void mergeSortedArrays(int[] src1, int[] src2, int[] dest){\n\n        // write your logic here\n\n    }\n\n    public static void main(String[] args);\n\n     MergeSortedArraysChallenge challenge;\n\n}\n\nclass MergeSortedArraysChallengeTest {\n\n     MergeSortedArraysChallenge challenge;\n\n    @Test\n    public void test(){\n", "reference": "        int[] src1 = new int[]{0, 2, 2, 6, 8, 8, 11};\n        int[] src2 = new int[]{ 0 ,3 ,6 ,7 ,10 ,11     };\n        int[] dest = new int[src1.length + src2.length];\n\n        challenge.mergeSortedArrays(src1, src2, dest);\n\n        assertThat(dest).containsExactly(0, 0, 2, 2, 3, 6, 6, 7, 8, 8, 10, 11, 11);\n    }\n\n}", "prediction": "        int[] src1 = {1, 3, 5, 7};\n        int[] src2 = {2, 4, 6, 8};\n        int[] dest = new int[src1.length + src2.length];\n        challenge.mergeSortedArrays(src1, src2, dest);\n        Assert.assertArrayEquals(new int[]{1, 2, 3, 4, 5, 6, 7, 8}, dest);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "120205336_2", "part": [1, 1], "seq": [1, 1], "prompt": "class SplitMap {\n\n  public long getCardinality() {\n    return index.reduceLong(0L, Container::getCardinality, (x, y) -> x + y);\n  }\n\n  public  SplitMap(PrefixIndex<Container> index, KeyInvolution involution);\n  public  SplitMap(PrefixIndex<Container> index);\n  public  SplitMap(KeyInvolution involution);\n\n  public void insert(short key, Container region);\n  public boolean contains(int value);\n  public boolean isEmpty();\n  public Stream<PrefixIndex<Container>> stream();\n   PrefixIndex<Container> getIndex();\n\n}\n\nclass SplitMapTest {\n\n  @Test\n  public void testCardinality() {\n", "reference": "    SplitMapPageWriter writer = new SplitMapPageWriter();\n    writer.add(1);\n    writer.add(1 << 14);\n    writer.add(1 << 16 | 1);\n    writer.add(1 << 17);\n    assertEquals(writer.toSplitMap().getCardinality(), 4);\n  }\n\n}", "prediction": "    PrefixIndex<Container> index = new PrefixIndex<>();\n    SplitMap map = new SplitMap(index);\n    map.insert((short) 1, new Container(1, 10));\n    map.insert((short) 2, new Container(11, 20));\n    map.insert((short) 3, new Container(21, 30));\n    map.insert((short) 4, new Container(31, 40));\n    map.insert((short) 5, new Container(41, 50));\n    map.insert((short) 6, new Container(51, 60));\n    map.insert((short) 7, new Container(61, 70));\n    map.insert((short) 8, new Container(71, 80));\n    map.insert((short) 9, new Container(81, 90));\n    map.insert((short) 10, new Container(91, 100));\n    assertEquals(10, map.getCardinality());\n  }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "120310124_1", "part": [1, 1], "seq": [1, 1], "prompt": "class Baz {\n\n    public int bazMethod() {\n        return i;\n    }\n\n    public String anotherBazMethod();\n\n}\n\nclass BazTest {\n\n    @Test\n    void testBazMethod() {\n", "reference": "        Baz testee = new Baz();\n        assertThat(testee.bazMethod(), is(6));\n    }\n\n}", "prediction": "        Baz baz = new Baz();\n        assertEquals(1, baz.bazMethod());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "122628585_1", "part": [1, 1], "seq": [1, 1], "prompt": "class PolyBase extends AbstractPoly {\n\n\t@Override\n\tpublic PolyBase add(AbstractPoly x) {\n\t\tBiFunction<BigFraction, BigFraction, BigFraction> add = (lhs,rhs) -> lhs.add(rhs);\n\t\treturn binaryOpGen(add,x);\n\t}\n\n\tpublic  PolyBase();\n\tpublic  PolyBase(VariableID x);\n\tpublic  PolyBase(BigFraction constant);\n\tpublic  PolyBase(BigFraction coeff, VariableID x);\n\tpublic  PolyBase(Map<VariableID,BigFraction> coefficientsIn);\n\tpublic  PolyBase(Map<VariableID,BigFraction> coefficientsIn, BigFraction constant);\n\n\tprivate static Map<VariableID,BigFraction> normalizeCoefficients(Map<VariableID,BigFraction> cIn);\n\t@Override public Iterator<VariableID> iterator();\n\t@Override public PolyBase solveFor(VariableID x);\n\t@Override public BigFraction getCoefficient(VariableID x);\n\t@Override public PolyBase negate();\n\t@Override public PolyBase add(BigFraction val);\n\t@Override public PolyBase subtract(AbstractPoly x);\n\t@Override public PolyBase subtract(BigFraction val);\n\t@Override public PolyBase multiply(BigFraction c);\n\t@Override public PolyBase divide(BigFraction v);\n\tprivate PolyBase unaryOpGen(Function<BigFraction, BigFraction> f);\n\tprivate PolyBase binaryOpGen(BiFunction<BigFraction, BigFraction, BigFraction> f, AbstractPoly x);\n\t@Override public boolean isConstant();\n\t@Override public BigFraction getConstant();\n\t@Override public VariableID leadingVariable();\n\t@Override public VariableID trailingVariable();\n\tprivate static BigFraction abs(BigFraction x);\n\tprivate static String spaceOp(boolean first, BigFraction coeff, String var);\n\t@Override public String toString();\n\t@Override public String cexString();\n\t@Override public boolean equals(Object obj);\n\t@Override public BigFraction evaluateCEX();\n\t@Override public RegionBounds polyBounds(Map<VariableID, RegionBounds> bounds);\n\t@Override public BigFraction evaluate(Map<VariableID, BigFraction> bounds);\n\t@Override public AbstractPoly div(BigInteger d);\n\t@Override public boolean divisible(BigInteger d);\n\tpublic static PolyBase qpoly(BigInteger Q, VariableID k, VariableID m);\n\t@Override public AbstractPoly rewrite(Map<VariableID, AbstractPoly> rw);\n\t@Override public String toACL2();\n\t@Override public Set<VariableID> updateVariableSet(Set<VariableID> in);\n\t@Override public BigInteger leastCommonDenominator();\n\t@Override public BigInteger constantLCDContribution();\n\t@Override public AbstractPoly remove(VariableID x);\n\t@Override public BigFraction dot(AbstractPoly arg);\n\t@Override public int compareTo(AbstractPoly arg);\n\t@Override public AbstractPoly remove(AbstractPoly x);\n\t@Override public Set<VariableID> getVariables();\n\n}\n\nclass PolyBaseTest {\n\n\t@Test\n\tpublic void testAdd() {\n", "reference": "\t\t//VariableID constant = new VariableID(\"\",0);\t\n\t\tVariableID y = VariableID.principleAlloc(\"Y\", NamedType.REAL,BigFraction.ONE);\n\t\tVariableID x = VariableID.principleAlloc(\"X\",NamedType.REAL,BigFraction.ZERO);\n\t\t//VariableID z = VariableID.preAlloc(\"Z\",NamedType.REAL,BigFraction.ZERO);\n\t\t\n//\t\tSystem.out.println(x.level);\n//\t\tSystem.out.println(y.level);\n//\t\tSystem.out.println(z.level);\n\t\t\n\t\tMap<VariableID,BigFraction> coefs = new HashMap<VariableID,BigFraction>();\n\t\t//coefs.put(constant, BigFraction.ONE);\n\t\tcoefs.put(x, BigFraction.valueOf(BigDecimal.valueOf(2)));\n\t\tPolyBase poly1 = new PolyBase(coefs,BigFraction.ONE);\t\n\t\tSystem.out.println(\"poly1: \" + poly1);\n\t\t\n\t\tMap<VariableID,BigFraction> coefs2 = new HashMap<VariableID,BigFraction>();\n\t\t//coefs2.put(constant, BigFraction.valueOf(BigDecimal.valueOf(40)));\n\t\tcoefs2.put(x, BigFraction.valueOf(BigDecimal.valueOf(5)));\n\t\tcoefs2.put(y, BigFraction.valueOf(BigDecimal.valueOf(4)));\n\t\t\n\t\tPolyBase poly2 = new PolyBase(coefs2,BigFraction.valueOf(BigDecimal.valueOf(40)));\n\t\tSystem.out.println(\"poly2: \" + poly2);\n\t\t\n\t\tAbstractPoly polyadd = poly1.add(poly2);\n\t\tSystem.out.println(\"poly1 + poly2: \" + polyadd);\n\t\t\n\t\tAbstractPoly polyaddsub = polyadd.subtract(poly2);\n\t\tSystem.out.println(\"poly1 + poly2 - poly2: \" + polyaddsub);\n\t\t\n\t\tAbstractPoly polysub = poly1.subtract(poly1);\n\t\tSystem.out.println(\"poly1 - poly1: \" + polysub);\n\t\t\n\t\tAbstractPoly polyaddneg = poly1.add(poly1.negate());\n\t\tSystem.out.println(\"poly1 + (-poly1): \" + polyaddneg);\n\t\t\n\t\tSystem.out.println(\"poly2 * 3: \" + poly2.multiply(BigFraction.valueOf(BigDecimal.valueOf(3))));\n\t\t\n\t\tPolyBase emptyPoly = new PolyBase();\n\t\t\n\t\tMap<VariableID,BigFraction> zerocoefs = new HashMap<VariableID,BigFraction>();\n\t\t//zerocoefs.put(constant, BigFraction.ZERO);\n\t\tPolyBase constZeroPoly = new PolyBase(zerocoefs,BigFraction.ZERO);\n\t\t\n\t\tMap<VariableID,BigFraction> constFourCoef = new HashMap<VariableID,BigFraction>();\n\t\t//constFourCoef.put(constant, BigFraction.valueOf(BigDecimal.valueOf(4)));\n\t\tPolyBase constFourPoly = new PolyBase(constFourCoef,BigFraction.valueOf(BigDecimal.valueOf(4)));\n\t\t\n\t\tMap<VariableID,BigFraction> negHalfCoef = new HashMap<VariableID,BigFraction>();\n\t\tBigFraction negHalf = new BigFraction(BigInteger.valueOf(-1),BigInteger.valueOf(2));\n\t\t//negHalfCoef.put(constant, negHalf);\n\t\tPolyBase constNegHalfPoly = new PolyBase(negHalfCoef,negHalf);\n\t\t\n\t\tSystem.out.println(\"poly1 - constFour: \" + poly1.subtract(constFourPoly));\n\t\t\n\t\tSystem.out.println(\"poly1 solved for x: \" + poly1.solveFor(x));\n\t\tSystem.out.println(\"poly2 solved for x: \" + poly2.solveFor(x));\n\t\tSystem.out.println(\"poly2 solved for y: \" + poly2.solveFor(y));\n\t\tSystem.out.println(\"(poly1 - constFour) solved for x: \" + poly1.subtract(constFourPoly).solveFor(x));\n\t\t\n\t\t\n\t\tSystem.out.println(\"evaluate poly1(x is ZERO by default): \" + poly1.evaluateCEX());\n\t\t\n\t\tMap<VariableID,BigFraction> coefsCex1 = new HashMap<VariableID,BigFraction>();\n\t\tcoefsCex1.put(y, BigFraction.valueOf(BigDecimal.valueOf(2)));\n\t\tPolyBase poly1Cex1 = new PolyBase(coefsCex1,BigFraction.ONE);\n\t\t\n\t\tSystem.out.println(\"evaluate poly1Cex1: \" + poly1Cex1.evaluateCEX());\n\t\t\n\t\tx.setCex(new BigFraction(BigInteger.valueOf(2)));\n\t\tSystem.out.println(\"evaluate poly2: \" + poly2.evaluateCEX());\n\t\t//System.out.println(constZeroPoly);\n\t\t//System.out.println(emptyPoly);\n\t\t\n\t\tassertEquals(poly1,polyaddsub);\n\t\tassertEquals(emptyPoly,polysub);\n\t\tassertEquals(emptyPoly,polyaddneg);\n\t\tassertEquals(emptyPoly,constZeroPoly);\n\t\tassertEquals(constNegHalfPoly, poly1.solveFor(x));\n\t\t\n\t\t\n\t}\n\n}", "prediction": "\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "122685352_1", "part": [1, 1], "seq": [1, 1], "prompt": "class PostViewModel extends ViewModel {\n\n    public Post getPost() {\n        Post post = new Post(name.get(), content.get(), category.get(), HttpUrl.parse(inReplyTo.get()));\n        if (!this.photo.get().equals(\"\")) {\n            post.setPhoto(this.photo.get());\n        }\n        if (!this.likeOf.get().equals(\"\")) {\n            post.setLikeOf(HttpUrl.parse(likeOf.get()));\n        }\n        if (!this.bookmarkOf.get().equals(\"\")) {\n            post.setBookmarkOf(HttpUrl.parse(bookmarkOf.get()));\n        }\n        if (!this.postStatus.get().equals(\"\")) {\n            post.setPostStatus((postStatus.get()));\n        }\n\n        int id = this.checkedVisibility.get();\n        switch (id) {\n            case R.id.radioButtonPublic:\n                this.visibility.set(\"public\");\n                break;\n\n            case R.id.radioButtonUnlisted:\n                this.visibility.set(\"unlisted\");\n                break;\n\n            case R.id.radioButtonProtected:\n                this.visibility.set(\"protected\");\n                break;\n\n            case R.id.radioButtonPrivate:\n                this.visibility.set(\"private\");\n                break;\n        }\n\n        if (!this.visibility.get().equals(\"\")) {\n            post.setVisibility((visibility.get()));\n        }\n        return post;\n    }\n\n    public  PostViewModel();\n\n    public void clear();\n    public void findReplyTo(String urlOrNote);\n    public void findLikeOf(String urlOrNote);\n    public void findBookmarkOf(String urlOrNote);\n    public void setPhoto(String url);\n    @BindingAdapter(\"android:visibility\") public static void setVisibility(View view, Boolean value);\n\n    private static final Pattern urlPattern;\n\n}\n\nclass PostViewModelTest {\n\n    private static final Pattern urlPattern;\n\n    @Test\n    public void postStatusSetToDraft() {\n", "reference": "        PostViewModel postModel = new PostViewModel();\n        postModel.postStatus.set(\"draft\");\n        Post post = postModel.getPost();\n        assertEquals(\"draft\", post.getPostStatus());\n    }\n\n}", "prediction": "        PostViewModel viewModel = new PostViewModel();\n        viewModel.postStatus.set(\"draft\");\n        Post post = viewModel.getPost();\n        assertEquals(\"draft\", post.getPostStatus());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "122696956_1", "part": [1, 1], "seq": [1, 1], "prompt": "class FileHttpDownload extends FileHttpHandler {\n\n\tpublic void download(String http, String savaPath, String fileName, FileAction<File> fileAction) {\n\t\tdownload(http, savaPath, fileName, false, fileAction);\n\t}\n\n\tpublic void download(String http, String savaPath, String fileName, boolean onlyReplaceName, FileAction<File> fileAction);\n\tpublic void download(String http, String method, String savaPath, String fileName, boolean onlyReplaceName, FileAction<File> fileAction);\n\tpublic void download(String http, String filePath, FileAction<File> fileAction);\n\tpublic void download(String http, File saveFile, FileAction<File> fileAction);\n\tpublic static String getFileNameFromUrl(String url);\n\tpublic String getFileName(String http, String disposition, String fileName, boolean onlyReplaceName);\n\tpublic String getFileNameO(String http, String disposition, String fileName, boolean onlyReplaceName);\n\tpublic static void main(String[] arg);\n\n}\n\nclass FileHttpDownloadTest {\n\n\t@Test\n\tpublic void testUpload() {\n", "reference": "\t\tMap<String, String> dataMap = new HashMap<String, String>();\n\t\tdataMap.put(\"userId\", \"110\");\n\n\t\tFileAction<File> action = new FileAction<File>() {\n\n\t\t\t@Override\n\t\t\tpublic void progress(long speed, long size, long finishSize, double progress) {\n\n\t\t\t\tString speedText = \"0MB/s\";\n\t\t\t\tif (speed < 1024) {\n\t\t\t\t\tspeedText = speed + \"B/s\";\n\t\t\t\t} else if (1024 <= speed && speed < (1024 * 1024)) {\n\t\t\t\t\tString s = OnlyNumberUtil.format(((double) speed / 1024d));\n\t\t\t\t\tspeedText = s + \"KB/s\";\n\t\t\t\t} else {\n\t\t\t\t\tString s = OnlyNumberUtil.format(((double) speed / (double) (1024 * 1024)));\n\t\t\t\t\tspeedText = s + \"MB/s\";\n\t\t\t\t}\n\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tsb.append(\"size:\" + size);\n\t\t\t\tsb.append(\" \");\n\t\t\t\tsb.append(\"finishSize:\" + finishSize);\n\t\t\t\tsb.append(\" \");\n\t\t\t\tsb.append(\"progress:\" + progress);\n\t\t\t\tsb.append(\" \");\n\t\t\t\tsb.append(\"speed:\");\n\t\t\t\tsb.append(speedText);\n\t\t\t\tsb.append(\" \");\n\t\t\t\tSystem.out.println(sb);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void success(File t) {\n\t\t\t\tSystem.out.println(t.getAbsolutePath());\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void lost(File t) {\n\t\t\t\t// TODO Auto-generated method stub\n\n\t\t\t}\n\t\t};\n\t\tString http = \"http://download.netbeans.org/netbeans/8.2/final/bundles/netbeans-8.2-windows.exe\";\n\t\tString savaPath = \"Temp/\";\n\t\tString fileName = \"\";\n\n\t\tboolean onlyReplaceName = false;\n\t\tFileHttpDownload fhd = new FileHttpDownload();\n\t\tfhd.download(http,\"\", savaPath, fileName, onlyReplaceName, action);\n\t}\n\n}", "prediction": "\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "122794079_3", "part": [1, 1], "seq": [1, 1], "prompt": "class KeyguardFeatures {\n\n    static int setFingerprintDisabled(\n            int currentDisabledFeatures,\n            boolean fingerprintDisabled) {\n                int keyguardDisabledFeatures;\n        if(fingerprintDisabled){\n            keyguardDisabledFeatures =\n                    currentDisabledFeatures | DevicePolicyManager.KEYGUARD_DISABLE_FINGERPRINT;\n        } else {\n            keyguardDisabledFeatures =\n                    currentDisabledFeatures & (~DevicePolicyManager.KEYGUARD_DISABLE_FINGERPRINT);\n        }\n        return keyguardDisabledFeatures;\n    }\n\n}\n\nclass KeyguardFeaturesTest {\n\n    @Test\n    public void test_changeOneKeyguardFeaturesDisabled() throws Exception {\n", "reference": "        int expected = DevicePolicyManager.KEYGUARD_DISABLE_TRUST_AGENTS\n                + DevicePolicyManager.KEYGUARD_DISABLE_FINGERPRINT;\n        int result = KeyguardFeatures.setFingerprintDisabled(\n                DevicePolicyManager.KEYGUARD_DISABLE_TRUST_AGENTS, true);\n        assertEquals(expected, result);\n    }\n\n}", "prediction": "        int currentDisabledFeatures = 0;\n        int expectedDisabledFeatures = DevicePolicyManager.KEYGUARD_DISABLE_FINGERPRINT;\n        int actualDisabledFeatures = KeyguardFeatures.setFingerprintDisabled(\n                currentDisabledFeatures, true);\n        assertEquals(expectedDisabledFeatures, actualDisabledFeatures);\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "125030262_0", "part": [1, 1], "seq": [1, 1], "prompt": "class DemoApplicationProperties {\n\n    public List<String> getEmailAddresses() {\n        return emailAddresses;\n    }\n\n    public Integer getNumber();\n    public void setNumber(Integer number);\n    public String getTelephoneNumber();\n    public void setTelephoneNumber(String telephoneNumber);\n    public void setEmailAddresses(List<String> emailAddresses);\n    public String getUsername();\n    public void setUsername(String username);\n    public String getFirstName();\n    public void setFirstName(String firstName);\n    public String getLastName();\n    public void setLastName(String lastName);\n    public Duration getWorkingTime();\n    public void setWorkingTime(Duration workingTime);\n\n    @Autowired\n    private DemoApplicationProperties demoApplicationProperties;\n\n}\n\nclass DemoApplicationPropertiesTest {\n\n    @Autowired\n    private DemoApplicationProperties demoApplicationProperties;\n\n    @Test\n    public void getEmailAddresses_DefaultValueMustBeOverwrittenByValuesInPropertiesFile() {\n", "reference": "        //When\n        List<String> emailAddresses = demoApplicationProperties.getEmailAddresses();\n        //Then\n        assertThat(emailAddresses).containsOnly(\"shazin.sadakath@gmail.com\", \"shazin.swe@gmail.com\");\n    }\n\n}", "prediction": "        assertThat(demoApplicationProperties.getEmailAddresses()).containsExactly(\"\", \"\");\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "125550262_32", "part": [1, 1], "seq": [1, 1], "prompt": "class Delete extends Operation {\n\n  @Override\n  public boolean equals(Object other) {\n    if (this == other) {\n      return true;\n    }\n    if (!(other instanceof Delete)) {\n      return false;\n    }\n    Delete that = (Delete) other;\n    return Objects.equals(table, that.getTable())\n        && Objects.equals(conditions, that.getWhere());\n  }\n\n  public  Delete(String table);\n  public  Delete(String table, List<Condition> conditions);\n\n  public Delete where(String column, Function function, Value value);\n  public Delete where(String column, Function function, String string);\n  public Delete where(String column, Function function, long integer);\n  public Delete where(String column, Function function, boolean bool);\n  public Delete where(String column, Function function, Uuid uuid);\n  public Delete where(String column, Function function, NamedUuid namedUuid);\n  public Delete where(\n      String column, Function function, java.util.Map<K, V> map\n  );\n  public Delete where(\n      String column, Function function, java.util.Set<T> set\n  );\n  public String getTable();\n  public List<Condition> getWhere();\n  @Override public int hashCode();\n  @Override public String toString();\n\n  private final UUID uuid;\n  private final Delete delete;\n\n}\n\nclass DeleteTest {\n\n  private final UUID uuid;\n  private final Delete delete;\n\n  @Test\n  public void testEquals() {\n", "reference": "    List<Condition> conditions = Stream.of(\n        new Condition(\"string_column\", Function.INCLUDES, Atom.string(\"A string\")),\n        new Condition(\"integer_column\", Function.LESS_THAN, Atom.integer(42)),\n        new Condition(\"bool_column\", Function.EQUALS, Atom.bool(true)),\n        new Condition(\"uuid_column\", Function.NOT_EQUALS, Atom.uuid(uuid)),\n        new Condition(\"named-uuid_column\", Function.EXCLUDES, Atom.namedUuid(\"uuid-name\")),\n        new Condition(\"map_column\", Function.GREATER_THAN_OR_EQUALS,\n            new Map<>(ImmutableList.of(new Pair<>(Atom.string(\"key\"), Atom.string(\"value\"))))\n        ),\n        new Condition(\"set_column\", Function.LESS_THAN_OR_EQUALS,\n            new Set(ImmutableSet.of(Atom.string(\"value1\"), Atom.string(\"value2\")))\n        )\n    ).collect(Collectors.toList());\n    new EqualsTester().addEqualityGroup(delete, new Delete(\"Logical_Switch\", conditions)).testEquals();\n  }\n\n}", "prediction": "    assertEquals(delete, delete);\n    assertEquals(delete, new Delete(delete.getTable(), delete.getWhere()));\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "125830136_6", "part": [1, 1], "seq": [1, 1], "prompt": "class InstanceTaskServiceImpl implements InstanceTaskService {\n\n\t@Override\n\tpublic int[] batchInsert(List<InstanceTaskDB> entityList) {\n\t\treturn instanceTaskDao.batchInsert(entityList);\n\t}\n\n\tpublic int cleanHistory(Date minKeepTime);\n\t@Override public List<InstanceTaskDB> getByQuery(InstanceTaskQuery query);\n\t@Override public InstanceTaskDB getById(String instanceFlowId, Integer fileId);\n\n\tprivate InstanceTaskService instanceTaskService;\n\n}\n\nclass InstanceTaskServiceImplTest  {\n\n\tprivate InstanceTaskService instanceTaskService;\n\n\t@Test\n\tpublic void testBatchInsert(){\n", "reference": "\t\tList<InstanceTaskDB> instanceTaskDBList = new ArrayList<InstanceTaskDB>();\n\t\tfor (int i=0; i<10; i++) {\n\t\t\tInstanceTaskDB instanceDB = new InstanceTaskDB();\n\t\t\tinstanceDB.setInstanceFlowId(UUID.randomUUID().toString().replace(\"-\", \"\"));\n\t\t\tinstanceDB.setFileId(100);\n\t\t\tinstanceDB.setFileBody(\"{xxxx}\");\n\t\t\tinstanceDB.setReadyTime(new Date());\n\t\t\tinstanceDB.setStartTime(new Date());\n\t\t\tinstanceDB.setEndTime(new Date());\n\t\t\tinstanceDB.setStatus(ExecStatus.Success.name());\n\t\t\tinstanceDB.setRetriedTimes(2);\n\t\t\tinstanceDB.setLog(null);\n\t\t\tinstanceDB.setPoolActiveCount(10);\n\t\t\tinstanceDB.setPoolQueueSize(10);\n\t\t\tinstanceTaskDBList.add(instanceDB);\n\t\t}\n\t\tinstanceTaskService.batchInsert(instanceTaskDBList);\n\t}\n\n}", "prediction": "\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "126354357_2", "part": [1, 1], "seq": [1, 1], "prompt": "class Member {\n\n    public void setCoupons(List<Coupon> coupons) {\n        this.coupons = coupons;\n    }\n\n    @Builder public  Member(String email, String name);\n\n}\n\nclass MemberTest {\n\n    @Test\n    public void test_01() {\n", "reference": "\n        final Member member = new Member(\"asd@asd.com\", \"name\");\n        final Coupon coupon = new Coupon(member);\n        final List<Coupon> coupons = new ArrayList<>();\n        coupons.add(coupon);\n        member.setCoupons(coupons);\n\n        System.out.println(member.toString());\n    }\n\n}", "prediction": "//        Member member = new Member(\"\", \"\ud64d\uae38\ub3d9\");\n//        member.setCoupons(Arrays.asList(new Coupon(\"\ucfe0\ud3f01\"), new Coupon(\"\ucfe0\ud3f02\")));\n//        System.out.println(member);\n\n        Member member = Member.builder()\n               .email(\"\")\n               .name(\"\ud64d\uae38\ub3d9\")\n               .coupons(Arrays.asList(new Coupon(\"\ucfe0\ud3f01\"), new Coupon(\"\ucfe0\ud3f02\")))\n               .build();\n        System.out.println(member);\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "128830029_7", "part": [1, 1], "seq": [1, 1], "prompt": "class PerPlayerMenuItem extends AbstractMenuItem {\n\n    @Override\n    public MenuIcon getIcon(IconRequest iconRequest) {\n        return iconRequestConsumer.apply(iconRequest);\n    }\n\n      PerPlayerMenuItem(Consumer<MenuItemClick> itemClickConsumer, Function<IconRequest, MenuIcon> iconRequestConsumer,\n                      Predicate<IconRequest> available);\n\n    @Mock\n    private MenuSession menuSession;\n    @Mock\n    private Player player;\n    @Mock\n    private MenuIcon icon;\n    @Spy Function<IconRequest, MenuIcon> iconRequestConsumer;\n    @Spy Predicate<IconRequest> availableListener;\n    private PerPlayerMenuItem menuItem;\n\n}\n\nclass PerPlayerMenuItemTest {\n\n    @Mock\n    private MenuSession menuSession;\n    @Mock\n    private Player player;\n    @Mock\n    private MenuIcon icon;\n    @Spy Function<IconRequest, MenuIcon> iconRequestConsumer;\n    @Spy Predicate<IconRequest> availableListener;\n    private PerPlayerMenuItem menuItem;\n\n    @Test\n    public void getIcon() {\n", "reference": "        IconRequest request = new IconRequest(player, menuSession);\n        MenuIcon icon = menuItem.getIcon(request);\n        assertEquals(this.icon, icon);\n    }\n\n}", "prediction": "        IconRequest iconRequest = new IconRequest(menuSession, player);\n        menuItem.getIcon(iconRequest);\n        verify(iconRequestConsumer).apply(iconRequest);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "128915122_0", "part": [1, 1], "seq": [1, 1], "prompt": "class CoffeeShop {\n\n    @Scheduled(every = \"2s\")\n    public void processUnfinishedOrders() {\n        entityManager.createNamedQuery(Order.FIND_UNFINISHED, Order.class)\n               .getResultList()\n               .forEach(orderProcessor::processOrder);\n    }\n\n    public Set<CoffeeType> getCoffeeTypes();\n    public Set<Origin> getOrigins(final CoffeeType type);\n    public Origin getOrigin(String name);\n    public void createOrder(Order order);\n    public Order getOrder(UUID id);\n    public List<Order> getOrders();\n    public void updateOrder(UUID id, Order order);\n\n    private CoffeeShop testObject;\n\n}\n\nclass CoffeeShopTest {\n\n    private CoffeeShop testObject;\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    void testProcessUnfinishedOrders() {\n", "reference": "        List<Order> desiredOrders = TestData.unfinishedOrders();\n\n        TypedQuery mockQuery = mock(TypedQuery.class);\n        when(testObject.entityManager.createNamedQuery(Order.FIND_UNFINISHED, Order.class)).thenReturn(mockQuery);\n        when(mockQuery.getResultList()).thenReturn(desiredOrders);\n        ArgumentCaptor<Order> orderCaptor = ArgumentCaptor.forClass(Order.class);\n\n        testObject.processUnfinishedOrders();\n\n        verify(testObject.entityManager).createNamedQuery(Order.FIND_UNFINISHED, Order.class);\n        verify(testObject.orderProcessor, times(desiredOrders.size())).processOrder(orderCaptor.capture());\n\n        assertThat(orderCaptor.getAllValues()).containsExactlyElementsOf(desiredOrders);\n\n        orderCaptor.getAllValues().forEach(o -> assertThat(o).isPreparing());\n    }\n\n}", "prediction": "        final OrderProcessor orderProcessor = mock(OrderProcessor.class);\n        testObject.processUnfinishedOrders();\n        verify(orderProcessor).processOrder(any(Order.class));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "129125498_46", "part": [1, 1], "seq": [1, 1], "prompt": "class AnomalyConsumer {\n\n    public boolean process(KafkaConsumer kafkaConsumer, boolean continueProcessing) {\n        try {\n            ConsumerRecords<String, MappedMetricData> metricRecords = kafkaConsumer.poll(POLL_INTERVAL);\n            log.trace(\"Read {} metric records from topic={}\", metricRecords.count(), consumerConfig.getString(TOPIC));\n            anomaliesProcessor.processMetrics(metricRecords, executorService);\n        } catch (WakeupException e) {\n            kafkaConsumer.close();\n            continueProcessing = false;\n        } catch (Exception e) {\n            log.error(e.getLocalizedMessage());\n            e.printStackTrace();\n        }\n\n        return continueProcessing;\n    }\n\n    public  AnomalyConsumer();\n\n    public void listen();\n    @VisibleForTesting public void setKafkaConsumer(KafkaConsumer<String, MappedMetricData> kafkaConsumer);\n    @VisibleForTesting public void setExecutorService(ExecutorService executorService);\n    public AnomaliesProcessor getAnomaliesProcessor();\n\n    private KafkaConsumer<String, MappedMetricData> kafkaConsumer;\n    private ExecutorService executorService;\n    private AnomalyConsumer anomalyConsumer;\n\n}\n\nclass AnomalyConsumerTest {\n\n    private KafkaConsumer<String, MappedMetricData> kafkaConsumer;\n    private ExecutorService executorService;\n    private AnomalyConsumer anomalyConsumer;\n\n    @Test\n    public void testProcessZeroMetrics() {\n", "reference": "        ConsumerRecords<String, MappedMetricData> metricRecords = AnomaliesProcessorTest.buildMetricRecords(0,\n                AnomalyLevel.STRONG);\n        when(kafkaConsumer.poll(anyLong())).thenReturn(metricRecords);\n        assertTrue(anomalyConsumer.process(kafkaConsumer, true));\n\n    }\n\n}", "prediction": "        ConsumerRecords<String, MappedMetricData> metricRecords = new ConsumerRecords<>(Collections.emptyList());\n        anomalyConsumer.process(kafkaConsumer, true);\n        verify(kafkaConsumer, times(1)).poll(POLL_INTERVAL);\n        verify(anomaliesProcessor, times(0)).processMetrics(metricRecords, executorService);\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "129255460_21", "part": [1, 1], "seq": [1, 1], "prompt": "class VoteCountJob {\n\n    @Scheduled(cron = \"00 00 23 * *?\")\n    public void executeVoteCount() {\n\n        System.err.println(\"begin to start Job\");\n        List<RunningRecordWithInfo> runningRecordWithInfos = runningRecordMapper.selectRunningRecordWithInfoScoreIn24hours();\n\n        List<MailBean> mailBeanList = new ArrayList();\n        for (RunningRecordWithInfo runningRecordWithInfo : runningRecordWithInfos) {\n            System.out.println(runningRecordWithInfo);\n\n            MailBean mailBean = new MailBean();\n            mailBean.setDistance(runningRecordWithInfo.getDistance());\n            mailBean.setUsername(runningRecordWithInfo.getUsername());\n            mailBean.setCreationTime(DateUtils.parseForFrontEnd2(runningRecordWithInfo.getCreationTime()));\n\n\n            RunningRecord runningRecord = runningRecordWithInfo;\n            runningRecord.setScore(runningRecordWithInfo.getFinalScore());\n            if (runningRecord.getScore() == null) {\n                runningRecord.setStatus(1);\n                mailBean.setStatus(\"Expired\");\n            } else if (runningRecord.getScore() <= 0) {\n                runningRecord.setStatus(2);\n                mailBean.setStatus(\"Rejected\");\n            } else if (runningRecord.getScore() > 0) {\n                runningRecord.setStatus(3);\n                mailBean.setStatus(\"Passed\");\n                mailBean.setEarnedCoins(runningRecordWithInfo.getEarnedCoins());\n            }\n\n            mailBeanList.add(mailBean);\n            runningRecordMapper.updateByPrimaryKey(runningRecord);\n        }\n\n\n        mostVotedJob.insertDailyVotedCount();\n\n\n        List<DailyVotedCountVo> dailyVotedCountVos = mostVotedRecordMapper.selectByVotedDate(new Date());\n\n        dailyVotedCountVos.stream().sorted((Comparator.comparing(DailyVotedCountVo::getVotedDate)));\n\n        ThisLocalizedWeek thisLocalizedWeek = new ThisLocalizedWeek(Locale.CHINA);\n        List<WeeklyAwardedReportVo> weeklyAwardedReportVos = dailyMostVotedRecordMapper.selectWeeklyAwardedRecord(thisLocalizedWeek.getFirstDay(), thisLocalizedWeek.getLastDay());\n\n        List<UserInfoBatchBean> userInfoBatchBeans = userInfoMapper.selectUserTotalInfo();\n        for (UserInfoBatchBean userInfoBatchBean : userInfoBatchBeans) {\n            UserInfo userInfo = userInfoMapper.selectByOpenId(userInfoBatchBean.getUserOpenId());\n            userInfo.setTotalDistance(userInfoBatchBean.getTotalDistance());\n            userInfo.setCoins(userInfoBatchBean.getTotalCoins());\n            userInfoMapper.updateByPrimaryKey(userInfo);\n        }\n        List<UserInfo> userInfos = userInfoMapper.selectAllUser();\n        try {\n            mailService.sendMessageMail(mailBeanList,userInfos,dailyVotedCountVos,weeklyAwardedReportVos, \"RunningClub Report\", \"message.ftl\");\n        }catch (Exception e){\n            e.printStackTrace();\n        }\n        System.err.println(\"send email finished\");\n    }\n\n    @Autowired\n    private VoteCountJob voteCountjob;\n\n}\n\nclass VoteCountjobTest {\n\n    @Autowired\n    private VoteCountJob voteCountjob;\n\n    @Test\n    public void executeVoteCount() {\n", "reference": "       voteCountjob.executeVoteCount();\n    }\n\n}", "prediction": "//        voteCountjob.executeVoteCount();\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "132102082_68", "part": [1, 1], "seq": [1, 1], "prompt": "class MethodAnalyzer {\n\n    public List<AnalyzedInstruction> getAnalyzedInstructions() {\n        return analyzedInstructions.getValues();\n    }\n\n    public  MethodAnalyzer(@Nonnull ClassPath classPath, @Nonnull Method method,\n                          @Nullable InlineMethodResolver inlineResolver, boolean normalizeVirtualMethods);\n\n    @Nonnull public ClassPath getClassPath();\n    private void analyze();\n    private void propagateParameterTypes(int parameterStartRegister);\n    public List<Instruction> getInstructions();\n    @Nullable public AnalysisException getAnalysisException();\n    public int getParamRegisterCount();\n    public int getInstructionAddress(@Nonnull AnalyzedInstruction instruction);\n    private void setDestinationRegisterTypeAndPropagateChanges(@Nonnull AnalyzedInstruction analyzedInstruction,\n                                                               @Nonnull RegisterType registerType);\n    private void propagateChanges(@Nonnull BitSet changedInstructions, int registerNumber, boolean override);\n    private void overridePredecessorRegisterTypeAndPropagateChanges(\n            @Nonnull AnalyzedInstruction analyzedInstruction, @Nonnull AnalyzedInstruction predecessor,\n            int registerNumber, @Nonnull RegisterType registerType);\n    private void setPostRegisterTypeAndPropagateChanges(@Nonnull AnalyzedInstruction analyzedInstruction,\n                                                        int registerNumber, @Nonnull RegisterType registerType);\n    private void propagateRegisterToSuccessors(@Nonnull AnalyzedInstruction instruction, int registerNumber,\n                                               @Nonnull BitSet changedInstructions, boolean override);\n    private void buildInstructionList();\n    private void addPredecessorSuccessor(@Nonnull AnalyzedInstruction predecessor,\n                                         @Nonnull AnalyzedInstruction successor,\n                                         @Nonnull AnalyzedInstruction[][] exceptionHandlers,\n                                         @Nonnull BitSet instructionsToProcess);\n    private void addPredecessorSuccessor(@Nonnull AnalyzedInstruction predecessor,\n                                         @Nonnull AnalyzedInstruction successor,\n                                         @Nonnull AnalyzedInstruction[][] exceptionHandlers,\n                                         @Nonnull BitSet instructionsToProcess, boolean allowMoveException);\n    @Nonnull private AnalyzedInstruction[] buildExceptionHandlerArray(@Nonnull TryBlock<? extends ExceptionHandler> tryBlock);\n    private boolean analyzeInstruction(@Nonnull AnalyzedInstruction analyzedInstruction);\n    private void analyzeMove(@Nonnull AnalyzedInstruction analyzedInstruction);\n    private void analyzeMoveResult(@Nonnull AnalyzedInstruction analyzedInstruction);\n    private void analyzeMoveException(@Nonnull AnalyzedInstruction analyzedInstruction);\n    private void analyzeOdexReturnVoid(AnalyzedInstruction analyzedInstruction);\n    private void analyzeOdexReturnVoid(@Nonnull AnalyzedInstruction analyzedInstruction, boolean analyzeResult);\n    private void analyzeConst(@Nonnull AnalyzedInstruction analyzedInstruction);\n    private void analyzeWideConst(@Nonnull AnalyzedInstruction analyzedInstruction);\n    private void analyzeConstString(@Nonnull AnalyzedInstruction analyzedInstruction);\n    private void analyzeConstClass(@Nonnull AnalyzedInstruction analyzedInstruction);\n    private void analyzeCheckCast(@Nonnull AnalyzedInstruction analyzedInstruction);\n    private static boolean isNotWideningConversion(RegisterType originalType, RegisterType newType);\n    static boolean canPropogateTypeAfterInstanceOf(AnalyzedInstruction analyzedInstanceOfInstruction,\n                                                   AnalyzedInstruction analyzedIfInstruction, ClassPath classPath);\n    private void analyzeIfEqzNez(@Nonnull AnalyzedInstruction analyzedInstruction);\n    private void analyzeInstanceOf(@Nonnull AnalyzedInstruction analyzedInstruction);\n    private void analyzeArrayLength(@Nonnull AnalyzedInstruction analyzedInstruction);\n    private void analyzeNewInstance(@Nonnull AnalyzedInstruction analyzedInstruction);\n    private void analyzeNewArray(@Nonnull AnalyzedInstruction analyzedInstruction);\n    private void analyzeFloatWideCmp(@Nonnull AnalyzedInstruction analyzedInstruction);\n    private void analyze32BitPrimitiveAget(@Nonnull AnalyzedInstruction analyzedInstruction,\n                                           @Nonnull RegisterType registerType);\n    private void analyzeAgetWide(@Nonnull AnalyzedInstruction analyzedInstruction);\n    private void analyzeAgetObject(@Nonnull AnalyzedInstruction analyzedInstruction);\n    private void analyze32BitPrimitiveIgetSget(@Nonnull AnalyzedInstruction analyzedInstruction,\n                                               @Nonnull RegisterType registerType);\n    private void analyzeIgetSgetWideObject(@Nonnull AnalyzedInstruction analyzedInstruction);\n    private void analyzeInvokeDirect(@Nonnull AnalyzedInstruction analyzedInstruction);\n    private void analyzeInvokeDirectRange(@Nonnull AnalyzedInstruction analyzedInstruction);\n    private void analyzeInvokeDirectCommon(@Nonnull AnalyzedInstruction analyzedInstruction, int objectRegister);\n    private void analyzeUnaryOp(@Nonnull AnalyzedInstruction analyzedInstruction,\n                                @Nonnull RegisterType destRegisterType);\n    private void analyzeBinaryOp(@Nonnull AnalyzedInstruction analyzedInstruction,\n                                 @Nonnull RegisterType destRegisterType, boolean checkForBoolean);\n    private void analyzeBinary2AddrOp(@Nonnull AnalyzedInstruction analyzedInstruction,\n                                      @Nonnull RegisterType destRegisterType, boolean checkForBoolean);\n    private void analyzeLiteralBinaryOp(@Nonnull AnalyzedInstruction analyzedInstruction,\n                                        @Nonnull RegisterType destRegisterType, boolean checkForBoolean);\n    private RegisterType getDestTypeForLiteralShiftRight(@Nonnull AnalyzedInstruction analyzedInstruction, boolean signedShift);\n    private void analyzeExecuteInline(@Nonnull AnalyzedInstruction analyzedInstruction);\n    private void analyzeExecuteInlineRange(@Nonnull AnalyzedInstruction analyzedInstruction);\n    private void analyzeInvokeDirectEmpty(@Nonnull AnalyzedInstruction analyzedInstruction);\n    private void analyzeInvokeDirectEmpty(@Nonnull AnalyzedInstruction analyzedInstruction, boolean analyzeResult);\n    private void analyzeInvokeObjectInitRange(@Nonnull AnalyzedInstruction analyzedInstruction);\n    private void analyzeInvokeObjectInitRange(@Nonnull AnalyzedInstruction analyzedInstruction, boolean analyzeResult);\n    private boolean analyzeIputIgetQuick(@Nonnull AnalyzedInstruction analyzedInstruction);\n    private boolean analyzeInvokeVirtual(@Nonnull AnalyzedInstruction analyzedInstruction, boolean isRange);\n    private boolean analyzeInvokeVirtualQuick(@Nonnull AnalyzedInstruction analyzedInstruction, boolean isSuper,\n                                              boolean isRange);\n    private boolean analyzePutGetVolatile(@Nonnull AnalyzedInstruction analyzedInstruction);\n    private boolean analyzePutGetVolatile(@Nonnull AnalyzedInstruction analyzedInstruction, boolean analyzeResult);\n    @Nonnull private static RegisterType getAndCheckSourceRegister(@Nonnull AnalyzedInstruction analyzedInstruction,\n                                                          int registerNumber, BitSet validCategories);\n    private static void checkRegister(RegisterType registerType, int registerNumber, BitSet validCategories);\n    private static void checkWidePair(int registerNumber, AnalyzedInstruction analyzedInstruction);\n    @Nullable private MethodReference normalizeMethodReference(@Nonnull MethodReference methodRef);\n\n}\n\nclass MethodAnalyzerTest {\n\n    @Test\n    public void testInstanceOfNarrowingAfterMove_art() throws IOException {\n", "reference": "        MethodImplementationBuilder builder = new MethodImplementationBuilder(3);\n\n        builder.addInstruction(new BuilderInstruction12x(Opcode.MOVE_OBJECT, 1, 2));\n        builder.addInstruction(new BuilderInstruction22c(Opcode.INSTANCE_OF, 0, 1,\n                new ImmutableTypeReference(\"Lmain;\")));\n        builder.addInstruction(new BuilderInstruction21t(Opcode.IF_EQZ, 0, builder.getLabel(\"not_instance_of\")));\n        builder.addInstruction(new BuilderInstruction10x(Opcode.RETURN_VOID));\n\n        builder.addLabel(\"not_instance_of\");\n        builder.addInstruction(new BuilderInstruction10x(Opcode.RETURN_VOID));\n\n        MethodImplementation methodImplementation = builder.getMethodImplementation();\n\n        Method method = new ImmutableMethod(\"Lmain;\", \"narrowing\",\n                Collections.singletonList(new ImmutableMethodParameter(\"Ljava/lang/Object;\", null, null)), \"V\",\n                AccessFlags.PUBLIC.getValue(), null, methodImplementation);\n        ClassDef classDef = new ImmutableClassDef(\"Lmain;\", AccessFlags.PUBLIC.getValue(), \"Ljava/lang/Object;\", null,\n                null, null, null, Collections.singletonList(method));\n        DexFile dexFile = new ImmutableDexFile(forArtVersion(56), Collections.singletonList(classDef));\n\n        ClassPath classPath = new ClassPath(Lists.newArrayList(new DexClassProvider(dexFile)), true, 56);\n        MethodAnalyzer methodAnalyzer = new MethodAnalyzer(classPath, method, null, false);\n\n        List<AnalyzedInstruction> analyzedInstructions = methodAnalyzer.getAnalyzedInstructions();\n        Assert.assertEquals(\"Lmain;\", analyzedInstructions.get(3).getPreInstructionRegisterType(1).type.getType());\n        Assert.assertEquals(\"Lmain;\", analyzedInstructions.get(3).getPreInstructionRegisterType(2).type.getType());\n\n        Assert.assertEquals(\"Ljava/lang/Object;\",\n                analyzedInstructions.get(4).getPreInstructionRegisterType(1).type.getType());\n        Assert.assertEquals(\"Ljava/lang/Object;\",\n                analyzedInstructions.get(4).getPreInstructionRegisterType(2).type.getType());\n    }\n\n}", "prediction": "        ClassPath classPath = new ClassPath(new File(\"src/test/resources/test-classes/\"));\n        Method method = classPath.getClass(\"com.example.Test\").getMethod(\"testInstanceOfNarrowingAfterMove\");\n        MethodAnalyzer methodAnalyzer = new MethodAnalyzer(classPath, method, null, false);\n        methodAnalyzer.analyze();\n        AnalyzedInstruction analyzedInstruction = methodAnalyzer.getAnalyzedInstructions().get(1);\n        assertTrue(canPropogateTypeAfterInstanceOf(analyzedInstruction, methodAnalyzer.getAnalyzedInstructions().get(2), classPath));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "132454935_45", "part": [1, 1], "seq": [1, 1], "prompt": "class AppContext implements Serializable {\n\n    public void setStrAddressMint(String strAddressMint) {\n        Util.check(!(strAddressMint==null || strAddressMint.isEmpty()), \"strAddressMint!=null\");\n        this.strAddressMint = strAddressMint;\n    }\n\n    public String getNodeName();\n    public void setNodeName(String nodeName);\n    public Integer getPort();\n    public void setPort(Integer port);\n    public String getMasterPeerIpAddress();\n    public void setMasterPeerIpAddress(String masterPeerIpAddress);\n    public Integer getMasterPeerPort();\n    public void setMasterPeerPort(Integer masterPeerPort);\n    public String getStorageBasePath();\n    public void setStorageBasePath(String storageBasePath);\n    public BootstrapType getBootstrapType();\n    public void setBootstrapType(BootstrapType bootstrapType);\n    public String getStrAddressMint();\n    public BigInteger getValueMint();\n    public void setPrivateKey(PrivateKey privateKey);\n    public PrivateKey getPrivateKey();\n    public List<String> getListNTPServers();\n\n     AppContext context;\n\n}\n\nclass AppContextTest {\n\n     AppContext context;\n\n    @Test\n    public void testSetStrAddressMint(){\n", "reference": "        String addressMint = \"path\";\n        context.setStrAddressMint(addressMint);\n        Assert.assertEquals(addressMint, context.getStrAddressMint());\n    }\n\n}", "prediction": "        context.setStrAddressMint(\"123\");\n        Assert.assertEquals(\"123\", context.getStrAddressMint());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "132660065_22", "part": [1, 1], "seq": [1, 1], "prompt": "class JsonNodeConverter implements NodeConverter {\n\n    @Override\n    public NormalizedNode<?,?> deserialize(final SchemaNode schemaNode, final Reader inputData)\n            throws SerializationException {\n        NormalizedNodeResult result = new NormalizedNodeResult();\n        JSONCodecFactory jsonCodecFactory =\n                JSONCodecFactorySupplier.DRAFT_LHOTKA_NETMOD_YANG_JSON_02.createLazy(schemaContext);\n        try (JsonReader reader = new JsonReader(inputData);\n                NormalizedNodeStreamWriter streamWriter = ImmutableNormalizedNodeStreamWriter.from(result);\n\n                JsonParserStream jsonParser = JsonParserStream.create(streamWriter, jsonCodecFactory, schemaNode)) {\n            jsonParser.parse(reader);\n        } catch (IOException e) {\n            throw new SerializationException(e);\n        }\n        return result.getResult();\n    }\n\n    public  JsonNodeConverter(final SchemaContext schemaContext);\n\n    @Override public Writer serializeData(final SchemaNode schemaNode, final NormalizedNode<?,?> normalizedNode);\n    @Override public Writer serializeRpc(final SchemaNode schemaNode, final NormalizedNode<?,?> normalizedNode);\n\n    private static final Logger LOG;\n    private final NodeConverter bindingSerializer;\n\n}\n\nclass JsonNodeConverterTest  {\n\n    private static final Logger LOG;\n    private final NodeConverter bindingSerializer;\n\n    @Test\n    public void testDeserialize_in() throws Exception {\n", "reference": "        Optional<RpcDefinition> loadRpc = ConverterUtils.loadRpc(schemaContext, SIMPLE_IO_RPC_QNAME);\n        String loadIoRpcIn = loadResourceAsString(\"input-output-rpc-in.json\");\n        NormalizedNode<?, ?> deserializeRpc =\n                bindingSerializer.deserialize(loadRpc.get(), new StringReader(loadIoRpcIn));\n        Assert.assertNotNull(deserializeRpc);\n        LOG.info(deserializeRpc.toString());\n    }\n\n}", "prediction": "        final SchemaContext schemaContext = SchemaContextBuilder.create().build();\n        final JsonNodeConverter converter = new JsonNodeConverter(schemaContext);\n        final NormalizedNode<?,?> result = converter.deserialize(schemaContext.getSchemaNode(TestSchema.class),\n                new StringReader(TEST_JSON));\n        assertNotNull(result);\n        assertEquals(1, result.size());\n        assertEquals(1, result.get(\"test\").size());\n        assertEquals(\"test\", result.get(\"test\").get(0).getName());\n        assertEquals(\"test\", result.get(\"test\").get(0).getValue());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "132759831_30", "part": [1, 1], "seq": [1, 1], "prompt": "class CinemaResponseToCinema {\n\n    public List<Cinema> map(CinemaResponse cinemaResponse) {\n        List<Cinema> cinemas = new ArrayList<>();\n        if (cinemaResponse.getCinemas()!= null){\n            for (int i = 0; i < cinemaResponse.getCinemas().size(); i++){\n                final Cinema cinema = new Cinema();\n                final CinemaNetwork response = cinemaResponse.getCinemas().get(i);\n                cinema.setPage(cinemaResponse.getPage());\n                cinema.setTotalPages(cinemaResponse.getTotalPages());\n                cinema.setTotalResults(cinemaResponse.getTotalResults());\n                cinema.setId(response.getId());\n                cinema.setVoteAverage(response.getVoteAverage());\n                cinema.setTitle(response.getTitle());\n                cinema.setAdult(response.isAdult());\n                cinema.setDescription(response.getDescription());\n                cinema.setPosterUrl(response.getPosterUrl());\n                cinema.setReleaseDate(response.getReleaseDate());\n                cinema.setPopularity(response.getPopularity());\n                cinema.setGenres(response.getGenreIds());\n                cinemas.add(cinema);\n            }\n        }\n        return cinemas;\n    }\n\n    public Cinema map(CinemaDetailResponse response);\n    private void setGenres(CinemaDetailResponse response, Cinema cinema);\n    private void setActors(CinemaDetailResponse response, Cinema cinema);\n    private void setDirectorName(CinemaDetailResponse response, Cinema cinema);\n    private void setPosters(CinemaDetailResponse response, Cinema cinema);\n\n    @Mock private CinemaDetailResponse cinemaDetailResponseMock;\n    @Mock private CinemaResponse cinemaResponseMock;\n    @Mock private List<CinemaNetwork> cinemaNetworkListMock;\n    @Mock private Iterator<CinemaNetwork> cinemaNetworkIteratorMock;\n    private CinemaResponseToCinema mapper;\n\n}\n\nclass CinemaResponseToCinemaTest  {\n\n    @Mock private CinemaDetailResponse cinemaDetailResponseMock;\n    @Mock private CinemaResponse cinemaResponseMock;\n    @Mock private List<CinemaNetwork> cinemaNetworkListMock;\n    @Mock private Iterator<CinemaNetwork> cinemaNetworkIteratorMock;\n    private CinemaResponseToCinema mapper;\n\n    @Test\n    public void shouldMapId(){\n", "reference": "        doReturn(77).when(cinemaDetailResponseMock).getId();\n\n        final Cinema cinema = mapper.map(cinemaDetailResponseMock);\n        assertThat(cinema.getId() , is(cinemaDetailResponseMock.getId()));\n    }\n\n}", "prediction": "        when(cinemaResponseMock.getCinemas()).thenReturn(cinemaNetworkListMock);\n        when(cinemaNetworkListMock.iterator()).thenReturn(cinemaNetworkIteratorMock);\n        when(cinemaNetworkIteratorMock.hasNext()).thenReturn(true, false);\n        when(cinemaNetworkIteratorMock.next()).thenReturn(cinemaDetailResponseMock);\n        when(cinemaDetailResponseMock.getId()).thenReturn(123L);\n\n        List<Cinema> cinemas = mapper.map(cinemaResponseMock);\n\n        assertThat(cinemas.get(0).getId()).isEqualTo(123L);\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "134164777_6", "part": [1, 1], "seq": [1, 1], "prompt": "class TrieTree {\n\n    public List<String> prefixSearch(String key) {\n        List<String> value = new ArrayList<String>();\n        if (StringUtil.isEmpty(key)) {\n            return value;\n        }\n\n        char k = key.charAt(0);\n        int index;\n        if (Character.isUpperCase(k)) {\n            index = k - UPPERCASE_STAR;\n        } else {\n            index = k - LOWERCASE_STAR;\n\n        }\n        if (root.children!= null && root.children[index]!= null) {\n            return query(root.children[index], value,\n                    key.substring(1), String.valueOf(k));\n        }\n        return value;\n    }\n\n    public  TrieTree();\n\n    public void insert(String data);\n    private void insert(Node root, String data);\n    private List<String> query(Node child, List<String> value, String key, String result);\n    public List<String> all();\n    public List<String> depth(Node node, List<String> list, char[] chars, int index);\n\n}\n\nclass TrieTreeTest {\n\n    @Test\n    public void prefixSearch8() throws Exception {\n", "reference": "        TrieTree trieTree = new TrieTree();\n\n        List<String> ab = trieTree.prefixSearch(\"\");\n        String result = \"\";\n        for (String s : ab) {\n            result += s + \",\";\n            System.out.println(s);\n        }\n        Assert.assertTrue(result.equals(\"\"));\n    }\n\n}", "prediction": "        TrieTree trieTree = new TrieTree();\n        trieTree.insert(\"a\");\n        trieTree.insert(\"ab\");\n        trieTree.insert(\"abc\");\n        trieTree.insert(\"abcd\");\n        trieTree.insert(\"abcde\");\n        trieTree.insert(\"abcdef\");\n        trieTree.insert(\"abcdefg\");\n        trieTree.insert(\"abcdefgh\");\n        trieTree.insert(\"abcdefghi\");\n        trieTree.insert(\"abcdefghij\");\n        trieTree.insert(\"abcdefghijk\");\n        trieTree.insert(\"abcdefghijkl\");\n        trieTree.insert(\"abcdefghijklm\");\n        trieTree.insert(\"abcdefghijklmn\");\n        trieTree.insert(\"abcdefghijklmno\");\n        trieTree.insert(\"abcdefghijklmnop\");\n        trieTree.insert(\"abcdefghijklmnopq\");\n        trieTree.insert(\"abcdefghijklmnopqr\");\n        trieTree.insert(\"abcdefghijklmnopqrs\");\n        trieTree.insert(\"abcdefghijklmnopqrst\");\n        trieTree.insert(\"abcdefghijklmnopqrstu\");\n        trieTree.insert(\"abcdefghijklmnopqrstuv\");\n        trieTree.insert(\"abcdefghijklmnopqrstuvw\");\n        trieTree.insert(\"abcdefghijklmnopqrstuvwx\");\n        trieTree.insert(\"abcdefghijklmnopqrstuvwxy\");\n        trieTree.insert(\"abcdefghijklmnopqrstuvwxyz\");\n        trieTree.insert(\"abcdefghijklmnopqrstuvwxyz0\");\n        trieTree.insert(\"abcdefghijklmnopqrstuvwxyz1\");\n        trieTree.insert(\"abcdefghijklmnopqrstuvwxyz2\");\n        trieTree.insert(\"abcdefghijklmnopqrstuvwxyz3\");\n        trieTree.insert(\"abcdefghijklmnopqrstuvwxyz4\");\n        trieTree.insert(\"abcdefghijklmnopqrstuvwxyz5\");\n        trieTree.insert(\"abcdefghijklmnopqrstuvwxyz6\");\n        trieTree.insert(\"abcdefghijklmnopqrstuvwxyz7\");\n        trieTree.insert(\"abcdefghijklmnopqrstuvwxyz8\");\n        trieTree.insert(\"abcdefghijklmnopqrstuvwxyz9\");\n        trieTree.insert(\"abcdefghijklmnopqrstuvwxyz01\");\n        trieTree.insert(\"abcdefghijklmnopqrstuvwxyz012\");\n        trieTree.insert(\"abcdefghijklmnopqrstuvwxyz0123\");\n        trieTree.insert(\"abcdefghijklmnopqrstuvwxyz01234\");\n        trieTree.insert(\"abcdefghijklmnopqrstuvwxyz012345\");\n        trieTree.insert(\"abcdefghijklmnopqrstuvwxyz0123456\");\n        trieTree.insert(\"abcdefghijklmnopqrstuvwxyz01234567\");\n        trieTree.insert(\"abcdefghijklmnopqrstuvwxyz012345678\");\n        trieTree.insert(\"abcdefghijklmnopqrstuvwxyz0123456789\");\n        trieTree.insert(\"abcdefghijklmnopqrstuvwxyz01234567890\");\n        trieTree.insert(\"abcdefghijklmnopqrstuvwxyz012345678901\");\n        trieTree.insert(\"abcdefghijklmnopqrstuvwxyz0123456789012\");\n        trieTree.insert(\"abcdefghijklmnopqrstuvwxyz01234567890123\");\n        trieTree.insert(\"abcdefghijklmnopqrstuvwxyz012345678901234\");\n        trieTree.insert(\"abcdefghijklmnopqrstuvwxyz0123456789012345\");\n        trieTree.insert(\"abcdefghijklmnopqrstuvwxyz01234567890123456\");\n        trieTree.insert(\"abcdefghijklmnopqrstuvwxyz012345678901234567\");\n        trieTree.insert(\"abcdefghijklmnopqrstuvwxyz0123456789012345678\");\n        trieTree.insert(\"abcdefghijklmnopqrstuvwxyz01234567890123456789\");\n        trieTree.insert(\"abcdefghijklmnopqrstuvwxyz012345678901234567890\");\n        trieTree.insert(\"abcdefghijklmnopqrstuvwxyz0123456789012345678901\");\n        trieTree.insert(\"abcdefghijklmnopqrstuvwxyz01234567890123456789012\");\n        trieTree.insert(\"abcdefghijklmnopqrstuvwxyz012345678901234567890123\");\n        trieTree.insert(\"abcdefghijklmnopqrstuvwxyz0123456789012345678901234\");\n        trieTree.insert(\"abcdefghijklmnopqrstuvwxyz01234567890123456789012345\");\n        trieTree.insert(\"abcdefghijklmnopqrstuvwxyz012345678901234567890123456\");\n        trieTree.insert(\"abcdefghijklmnopqrstuvwxyz0123456789012345678901234567\");\n        trieTree.insert(\"abcdefghijklmnopqrstuvwxyz01234567890123456789012345678\");\n        trieTree.insert(\"abcdefghijklmnopqrstuvwxyz012345678901234567890123456789\");\n        trieTree.insert(\"abcdefghijklmnopqrstuvwxyz0123456789012345678901234567890\");\n        trieTree.insert(\"abcdefghijklmnopqrstuvwxyz01234567890123456789012345678901\");\n        trieTree.insert(\"abcdefghijklmnopqrstuvwxyz012345678901234567890123456789012\");\n        trieTree.insert(\"abcdefghijklmnopqrstuvwxyz0123456789012345678901234567890123\");\n        trieTree.insert(\"abcdefghijklmnopqrstuvwxyz01234567890123456789012345678901234\");\n        trieTree.insert(\"abcdefghijklmnopqrstuvwxyz012345678901234567890123456789012345\");\n        trieTree.insert(\"abcdefghijklmnopqrstuvwxyz0123456789012345678901234567890123456\");\n        trieTree.insert(\"abcdefghijklmnopqrstuvwxyz01234567890123456789012345678901234567\");", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "134616422_1", "part": [1, 1], "seq": [1, 1], "prompt": "class CaseConverter {\n\n    public static String toCase(String name, Case targetCase) {\n        return nameCase(name).convertTo(name, targetCase);\n    }\n\n    private  CaseConverter();\n\n    private static Case nameCase(String name);\n\n}\n\nclass CaseConverterTest {\n\n    @Test\n    public void convertFromKebabCase() {\n", "reference": "        assertThat(CaseConverter.toCase(\"foo-bar-baz\", CaseConverter.Case.LOWER_CAMEL_CASE))\n                .isEqualTo(\"fooBarBaz\");\n        assertThat(CaseConverter.toCase(\"foo-bar-baz\", CaseConverter.Case.SNAKE_CASE))\n                .isEqualTo(\"foo_bar_baz\");\n    }\n\n}", "prediction": "        assertEquals(\"camelCase\", CaseConverter.toCase(\"camel-case\", Case.CAMEL));\n        assertEquals(\"PascalCase\", CaseConverter.toCase(\"pascal-case\", Case.PASCAL));\n        assertEquals(\"snake_case\", CaseConverter.toCase(\"snake-case\", Case.SNAKE));\n        assertEquals(\"kebab-case\", CaseConverter.toCase(\"kebab-case\", Case.KEBAB));\n        assertEquals(\"SCREAMING_SNAKE_CASE\", CaseConverter.toCase(\"screaming-snake-case\", Case.SCREAMING_SNAKE));\n        assertEquals(\"UPPER_CAMEL_CASE\", CaseConverter.toCase(\"upper-camel-case\", Case.UPPER_CAMEL));\n        assertEquals(\"lower-camel-case\", CaseConverter.toCase(\"lower-camel-case\", Case.LOWER_CAMEL));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "134901097_12", "part": [1, 1], "seq": [1, 1], "prompt": "class AbstractBearerTokenExtractor {\n\n    public String getBearerToken() {\n        final String tokenHeaderName = authContextInfo.getTokenHeader();\n        final boolean fallbackToHeader = authContextInfo.isAlwaysCheckAuthorization();\n        AuthLogging.log.tokenHeaderName(tokenHeaderName);\n\n        final String bearerValue;\n\n        if (COOKIE_HEADER.equals(tokenHeaderName)) {\n            String intermediateBearerValue = getBearerTokenCookie();\n            if (intermediateBearerValue == null && fallbackToHeader) {\n                bearerValue = getBearerTokenAuthHeader();\n            } else {\n                bearerValue = intermediateBearerValue;\n            }\n        } else if (AUTHORIZATION_HEADER.equals(tokenHeaderName)) {\n            bearerValue = getBearerTokenAuthHeader();\n        } else {\n            String customHeaderValue = getHeaderValue(tokenHeaderName);\n\n            if (customHeaderValue == null) {\n                AuthLogging.log.headerIsNull(tokenHeaderName);\n            } else {\n                String customHeaderSchemeValue = getTokenWithConfiguredScheme(customHeaderValue);\n                if (customHeaderSchemeValue!= null) {\n                    customHeaderValue = customHeaderSchemeValue;\n                }\n            }\n            bearerValue = customHeaderValue;\n        }\n\n        return bearerValue;\n    }\n\n    protected  AbstractBearerTokenExtractor(JWTAuthContextInfo authContextInfo);\n\n    private String getBearerTokenCookie();\n    private String getBearerTokenAuthHeader();\n    private String getTokenWithConfiguredScheme(String tokenHeader);\n    private static boolean isTokenScheme(String headerValue, String schemePrefix);\n    protected abstract String getHeaderValue(String headerName);\n    protected abstract String getCookieValue(String cookieName);\n\n    private static final String AUTHORIZATION;\n    private static final String COOKIE;\n    private static final List<String> BEARER_SCHEME;\n    @Mock JWTAuthContextInfo authContextInfo;\n     AbstractBearerTokenExtractor target;\n\n}\n\nclass AbstractBearerTokenExtractorTest {\n\n    private static final String AUTHORIZATION;\n    private static final String COOKIE;\n    private static final List<String> BEARER_SCHEME;\n    @Mock JWTAuthContextInfo authContextInfo;\n     AbstractBearerTokenExtractor target;\n\n    @Test\n    public void testGetBearerTokenFallbackToHeaderWithCookieHeader() {\n", "reference": "        when(authContextInfo.getTokenHeader()).thenReturn(COOKIE);\n        when(authContextInfo.isAlwaysCheckAuthorization()).thenReturn(true);\n        AbstractBearerTokenExtractor target = newTarget(h -> \"Bearer THE_HEADER_TOKEN\", c -> \"THE_COOKIE_TOKEN\");\n        String bearerToken = target.getBearerToken();\n        assertEquals(\"THE_COOKIE_TOKEN\", bearerToken);\n    }\n\n}", "prediction": "        when(authContextInfo.getTokenHeader()).thenReturn(COOKIE_HEADER);\n        when(authContextInfo.isAlwaysCheckAuthorization()).thenReturn(true);\n        when(target.getBearerTokenCookie()).thenReturn(null);\n        when(target.getBearerTokenAuthHeader()).thenReturn(\"Bearer 1234567890\");\n\n        String bearerToken = target.getBearerToken();\n\n        assertEquals(\"Bearer 1234567890\", bearerToken);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "135978112_8", "part": [1, 1], "seq": [1, 1], "prompt": "class JsonConverter implements Converter {\n\n    @Override\n    public SchemaAndValue toConnectData(String topic, byte[] value) {\n        JsonNode jsonValue;\n        try {\n            jsonValue = deserializer.deserialize(topic, value);\n        } catch (SerializationException e) {\n            throw new DataException(\"Converting byte[] to Kafka Connect data failed due to serialization error: \", e);\n        }\n\n        if (enableSchemas && (jsonValue == null ||!jsonValue.isObject() || jsonValue.size()!= 2 ||!jsonValue.has(\"schema\") ||!jsonValue.has(\"payload\")))\n            throw new DataException(\"JsonDeserializer with schemas.enable requires \\\"schema\\\" and \\\"payload\\\" fields and may not contain additional fields\");\n\n        // The deserialized data should either be an envelope object containing the schema and the payload or the schema\n        // was stripped during serialization and we need to fill in an all-encompassing schema.\n        if (!enableSchemas) {\n            ObjectNode envelope = JsonNodeFactory.instance.objectNode();\n            envelope.set(\"schema\", null);\n            envelope.set(\"payload\", jsonValue);\n            jsonValue = envelope;\n        }\n\n        return jsonToConnect(jsonValue);\n    }\n\n    private static Object checkOptionalAndDefault(Schema schema);\n    @Override public void configure(Map<String,?> configs, boolean isKey);\n    @Override public byte[] fromConnectData(String topic, Schema schema, Object value);\n    private SchemaAndValue jsonToConnect(JsonNode jsonValue);\n    private ObjectNode asJsonSchema(Schema schema);\n    private Schema asConnectSchema(JsonNode jsonSchema);\n    private JsonNode convertToJsonWithEnvelope(Schema schema, Object value);\n    private JsonNode convertToJsonWithoutEnvelope(Schema schema, Object value);\n    private static JsonNode convertToJson(Schema schema, Object logicalValue);\n    private static Object convertToConnect(Schema schema, JsonNode jsonValue);\n\n    private static final String TOPIC;\n     ObjectMapper objectMapper;\n     JsonConverter converter;\n\n}\n\nclass JsonConverterTest {\n\n    private static final String TOPIC;\n     ObjectMapper objectMapper;\n     JsonConverter converter;\n\n    @Test\n    public void bytesToConnect() throws UnsupportedEncodingException {\n", "reference": "        ByteBuffer reference = ByteBuffer.wrap(\"test-string\".getBytes(\"UTF-8\"));\n        String msg = \"{ \\\"schema\\\": { \\\"type\\\": \\\"bytes\\\" }, \\\"payload\\\": \\\"dGVzdC1zdHJpbmc=\\\" }\";\n        SchemaAndValue schemaAndValue = converter.toConnectData(TOPIC, msg.getBytes());\n        ByteBuffer converted = ByteBuffer.wrap((byte[]) schemaAndValue.value());\n        assertEquals(reference, converted);\n    }\n\n}", "prediction": "        SchemaAndValue result = converter.toConnectData(TOPIC, \"foo\".getBytes(\"UTF-8\"));\n        assertEquals(TOPIC, result.topic());\n        assertEquals(new byte[] { 123, 34, 115, 99, 104, 101, 109, 97, 34, 58, 123, 34, 116, 121, 112, 101, 34, 58, 34, 115, 116, 114, 105, 110, 103, 34, 125, 125 }, result.value());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "137522340_0", "part": [1, 1], "seq": [1, 1], "prompt": "class ContentUriModel {\n\n    @Override\n    public String toString() {\n        return PREFIX + server + \"/\" + mediaId;\n    }\n\n    public  ContentUriModel(String server, String mediaId);\n\n    public String getServer();\n    public String getMediaId();\n    public static ContentUriModel valueOf(String uri);\n\n}\n\nclass ContentUriModelTest {\n\n    @Test\n    public void toStringTest() {\n", "reference": "        ContentUriModel model = new ContentUriModel(\"ru-matrix.org\", \"123\");\n        assertEquals(\"mxc://ru-matrix.org/123\", model.toString());\n    }\n\n}", "prediction": "        ContentUriModel model = new ContentUriModel(\"server\", \"mediaId\");\n        assertEquals(\"content://server/mediaId\", model.toString());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "137736536_4", "part": [1, 1], "seq": [1, 1], "prompt": "class GetEidLpadWorker implements LpadWorker<LpadWorkerExchange<String>, String> {\n\n    public String run(final LpadWorkerExchange<String> lpadWorkerExchange) {\n\n        progress.setTotalSteps(3);\n        progress.stepExecuted(ProgressStep.GET_EID_RETRIEVING, \"getEID retrieving...\");\n\n        inputValidation(lpadWorkerExchange == null, \"Lpa dWorker Exchange must be provided\");\n        inputValidation(StringUtils.isBlank(lpadWorkerExchange.getBody()), \"EID APDU must be provided\");\n\n        logDebug(\"EID APDU: \" + lpadWorkerExchange);\n\n\n        String eidapduResponseStr = apduChannel.transmitAPDU(lpadWorkerExchange.getBody());\n\n        logDebug(\"Response: \" + eidapduResponseStr);\n\n        return convertGetEuiccData(eidapduResponseStr, progress);\n    }\n\n    public  GetEidLpadWorker(final Progress progress,\n                            final ApduChannel apduChannel);\n\n    private String convertGetEuiccData(final String eidapduResponseStr,\n                                       final Progress progress);\n    private void logDebug(final String errorMessage);\n    private void inputValidation(final boolean invalidCondition, final String errorMessage);\n\n    private GetEidLpadWorker getIdWorker;\n    @Mock\n    private Progress mockProgress;\n    @Mock\n    private ApduChannel mockApduChannel;\n\n}\n\nclass GetEidLpadWorkerTest {\n\n    private GetEidLpadWorker getIdWorker;\n    @Mock\n    private Progress mockProgress;\n    @Mock\n    private ApduChannel mockApduChannel;\n\n    @Test(expected = RuntimeException.class)\n    public void shouldThrowRuntimeExceptionWhenEidApduIsNull() {\n", "reference": "        getIdWorker.run(buildStringLpadWorkerExchange(null));\n    }\n\n}", "prediction": "        getIdWorker.run(null);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "139009007_65", "part": [1, 1], "seq": [1, 1], "prompt": "class FlatMapIterableStageFactory implements ProcessingStageFactory<Stage.FlatMapIterable> {\n\n    @Override\n    public <I, O> ProcessingStage<I, O> create(Engine engine, Stage.FlatMapIterable stage) {\n        Function<I, Iterable<O>> mapper = Casts.cast(stage.getMapper());\n        return new FlatMapIterable<>(mapper);\n    }\n\n    private final FlatMapIterableStageFactory factory;\n    private final ExecutorService executor;\n\n}\n\nclass FlatMapIterableStageFactoryTest  {\n\n    private final FlatMapIterableStageFactory factory;\n    private final ExecutorService executor;\n\n    @Test\n    public void create() throws ExecutionException, InterruptedException {\n", "reference": "        Flowable<Integer> flowable = Flowable.fromArray(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n                .subscribeOn(Schedulers.computation());\n\n        List<String> list = ReactiveStreams.fromPublisher(flowable)\n                .filter(i -> i < 4)\n                .flatMapIterable(this::duplicate)\n                .flatMapCompletionStage(this::asString)\n                .toList()\n                .run().toCompletableFuture().get();\n\n        assertThat(list).containsExactly(\"1\", \"1\", \"2\", \"2\", \"3\", \"3\");\n    }\n\n}", "prediction": "        final Stage.FlatMapIterable stage = new Stage.FlatMapIterable();\n        stage.setMapper(new Function<Integer, Iterable<Integer>>() {\n            @Override\n            public Iterable<Integer> apply(Integer input) {\n                return Arrays.asList(input, input + 1);\n            }\n        });\n        ProcessingStage<Integer, Integer> stageInstance = factory.create(null, stage);\n        assertThat(stageInstance).isInstanceOf(FlatMapIterable.class);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "139111229_0", "part": [1, 1], "seq": [1, 1], "prompt": "class CHexConvert {\n\n    public static byte[] hexStr2Bytes(String src){  \n        src = src.trim().replace(\" \", \"\").toUpperCase(Locale.US);  \n \n        int m=0,n=0;  \n        int iLen=src.length()/2;  \n        byte[] ret = new byte[iLen];  \n          \n        for (int i = 0; i < iLen; i++){  \n            m=i*2+1;  \n            n=m+1;  \n            ret[i] = (byte)(Integer.decode(\"0x\"+ src.substring(i*2, m) + src.substring(m,n)) & 0xFF);  \n        }  \n        return ret;  \n    }\n\n}\n\nclass CHexConvertTest  {\n\n    @Test\n    public void testCHextConvert(){\n", "reference": "        byte[] output = CHexConvert.hexStr2Bytes(\"3132333435363738393031323334353637383931\");\n        byte[] expect = {49, 50, 51, 52, 53, 54, 55, 56, 57, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 49};\n\n        assertEquals(expect.length, output.length);\n        for(int i=0; i<expect.length; i++)\n            assertEquals(expect[i], output[i]);\n    }\n\n}", "prediction": "//        String str = \"00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 10 11 12 13 14 15 16 17 18 19 1A 1B 1C 1D 1E 1F 20 21 22 23 24 25 26 27 28 29 2A 2B 2C 2D 2E 2F 30 31 32 33 34 35 36 37 38 39 3A 3B 3C 3D 3E 3F 40 41 42 43 44 45 46 47 48 49 4A 4B 4C 4D 4E 4F 50 51 52 53 54 55 56 57 58 59 5A 5B 5C 5D 5E 5F 60 61 62 63 64 65 66 67 68 69 6A 6B 6C 6D 6E 6F 70 71 72 73 74 75 76 77 78 79 7A 7B 7C 7D 7E 7F 80 81 82 83 84 85 86 87 88 89 8A 8B 8C 8D 8E 8F 90 91 92 93 94 95 96 97 98 99 9A 9B 9C 9D 9E 9F A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 AA AB AC AD AE AF B0 B1 B2 B3 B4 B5 B6 B7 B8 B9 BA BB BC BD BE BF C0 C1 C2 C3 C4 C5 C6 C7 C8 C9 CA CB CC CD CE CF D0 D1 D2 D3 D4 D5 D6 D7 D8 D9 DA DB DC DD DE DF E0 E1 E2 E3 E4 E5 E6 E7 E8 E9 EA EB EC ED EE EF F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF\";\n//        String str = \"00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 10 11 12 13 14 15 16 17 18 19 1A 1B 1C 1D 1E 1F 20 21 22 23 24 25 26 27 28 29 2A 2B 2C 2D 2E 2F 30 31 32 33 34 35 36 37 38 39 3A 3B 3C 3D 3E 3F 40 41 42 43 44 45 46 47 48 49 4A 4B 4C 4D 4E 4F 50 51 52 53 54 55 56 57 58 59 5A 5B 5C 5D 5E 5F 60 61 62 63 64 65 66 67 68 69 6A 6B 6C 6D 6E 6F 70 71 72 73 74 75 76 77 78 79 7A 7B 7C 7D 7E 7F 80 81 82 83 84 85 86 87 88 89 8A 8B 8C 8D 8E 8F 90 91 92 93 94 95 96 97 98 99 9A 9B 9C 9D 9E 9F A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 AA AB AC AD AE AF B0 B1 B2 B3 B4 B5 B6 B7 B8 B9 BA BB BC BD BE BF C0 C1 C2 C3 C4 C5 C6 C7 C8 C9 CA CB CC CD CE CF D0 D1 D2 D3 D4 D5 D6 D7 D8 D9 DA DB DC DD DE DF E0 E1 E2 E3 E4 E5 E6 E7 E8 E9 EA EB EC ED EE EF F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF\";\n        String str = \"00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 10 11 12 13 14 15 16 17 18 19 1A 1B 1C 1D 1E 1F 20 21 22 23 24 25 26 27 28 29 2A 2B 2C 2D 2E 2F 30 31 32 33 34 35 36 37 38 39 3A 3B 3C 3D 3E 3F 40 41 42 43 44 45 46 47 48 49 4A 4B 4C 4D 4E 4F 50 51 52 53 54 55 56 57 58 59 5A 5B 5C 5D 5E 5F 60 61 62 63 64 65 66 67 68 69 6A 6B 6C 6D 6E 6F 70 71 72 73 74 75 76 77 78 79 7A 7B 7C 7D 7E 7F 80 ", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "141492069_19", "part": [1, 1], "seq": [1, 1], "prompt": "class ExtensionWebSocketClient {\n\n    protected String validifyUrl(String url) {\n        if (url == null) {\n            throw new IllegalArgumentException(\"Must give a valid URL to connect to the websocket\");\n        }\n\n        boolean usesSSL = true;\n        // Ensure prepended by wss:// and not http:// or https://\n        if (url.startsWith(\"http://\")) {\n            url = url.substring(\"http://\".length());\n            usesSSL = false;\n        }\n        else if (url.startsWith(\"https://\")) {\n            url = url.substring(\"https://\".length());\n        }\n        if (!url.startsWith(\"ws://\") &&!url.startsWith(\"wss://\")) {\n            String prefix = \"wss://\";\n            if (!usesSSL) {\n                prefix = \"ws://\";\n            }\n            url = prefix + url;\n        }\n        \n        // Ensure it ends with /api/v{version number}/wsock/websocket\n        if (!url.matches(\".*/api/v[0-9]+/wsock/websocket\")) {\n         // Sometimes generic urls end with a '/' already, so we only want to add one if it does not already exist\n            if (!url.endsWith(\"/\")) { \n                url = url + \"/\";\n            }\n            url = url + \"api/v1/wsock/websocket\";\n        }\n        \n        return url;\n    }\n\n    public  ExtensionWebSocketClient(String sourceName);\n\n    public ExtensionWebSocketListener getListener();\n    public String getSourceName();\n    public CompletableFuture<Boolean> initiateFullConnection(String url, String token);\n    synchronized public CompletableFuture<Boolean> initiateWebsocketConnection(String url);\n    public CompletableFuture<Boolean> getWebsocketConnectionFuture();\n    public void sendNotification(Object data);\n     void acknowledgeNotification();\n    public void sendQueryResponseEmpty(String replyAddress);\n    public void sendQueryResponse(int httpCode, String replyAddress, Map body);\n    public void sendQueryResponse(int httpCode, String replyAddress, Map[] body);\n    public void sendQueryError(String replyAddress, String messageCode, String messageTemplate, Object[] parameters);\n    public void send(Object obj);\n    protected void doAuthentication();\n    synchronized public CompletableFuture<Boolean> authenticate(String user, String pass);\n    synchronized public CompletableFuture<Boolean> authenticate(String token);\n    public CompletableFuture<Boolean> getAuthenticationFuture();\n    protected void doConnectionToSource();\n    synchronized public CompletableFuture<Boolean> connectToSource();\n    public CompletableFuture<Boolean> getSourceConnectionFuture();\n    public void sourceHasDisconnected();\n    public void setAutoReconnect(boolean value);\n    public boolean isOpen();\n    public boolean isAuthed();\n    public boolean isConnected();\n    public void close();\n    public void stop();\n    public void useHandlersFrom(ExtensionWebSocketListener listener);\n    public void useHandlersFrom(ExtensionWebSocketClient client);\n    public void setCloseHandler(Handler<ExtensionWebSocketClient> closeHandler);\n    public void setHttpHandler(Handler<Response> httpHandler);\n    public void setPublishHandler(Handler<ExtensionServiceMessage> publishHandler);\n    public void setQueryHandler(Handler<ExtensionServiceMessage> queryHandler);\n    public void setConfigHandler(Handler<ExtensionServiceMessage> configHandler);\n    public void setAuthHandler(Handler<Response> authHandler);\n    public void setReconnectHandler(Handler<ExtensionServiceMessage> reconnectHandler);\n\n     OpenExtensionWebSocketClient client;\n     String srcName;\n     String queryAddress;\n     FalseWebSocket socket;\n\n}\n\nclass TestExtensionWebSocketClient  {\n\n     OpenExtensionWebSocketClient client;\n     String srcName;\n     String queryAddress;\n     FalseWebSocket socket;\n\n    @Test\n    public void testValidifyUrl() {\n", "reference": "        String url = \"ws://cba.com/api/v1/wsock/websocket\";\n        url = client.validifyUrl(url);\n        assert url.equals(\"ws://cba.com/api/v1/wsock/websocket\");\n        \n        url = \"http://prod.vantiq.com/api/v1/wsock/websocket\";\n        url = client.validifyUrl(url);\n        assert url.equals(\"ws://prod.vantiq.com/api/v1/wsock/websocket\");\n\n        url = \"http://prod.vantiq.com/\";\n        url = client.validifyUrl(url);\n        assert url.equals(\"ws://prod.vantiq.com/api/v1/wsock/websocket\");\n\n        url = \"http://prod.vantiq.com/api/v/wsock/websocket\";\n        url = client.validifyUrl(url);\n        assert url.equals(\"ws://prod.vantiq.com/api/v/wsock/websocket/api/v1/wsock/websocket\");\n\n        url = \"http://prod.vantiq.com/api/v47/wsock/websocket\";\n        url = client.validifyUrl(url);\n        assert url.equals(\"ws://prod.vantiq.com/api/v47/wsock/websocket\");\n        \n        url = \"https://dev.vantiq.com\";\n        url = client.validifyUrl(url);\n        assert url.equals(\"wss://dev.vantiq.com/api/v1/wsock/websocket\");\n        \n        url = \"https://dev.vantiq.com/\";\n        url = client.validifyUrl(url);\n        assert url.equals(\"wss://dev.vantiq.com/api/v1/wsock/websocket\");\n        \n        url = \"dev.vantiq.com\";\n        url = client.validifyUrl(url);\n        assert url.equals(\"wss://dev.vantiq.com/api/v1/wsock/websocket\");\n\n        url = \"https://prod.vantiq.com/api/v1/wsock/websocket\";\n        url = client.validifyUrl(url);\n        assert url.equals(\"wss://prod.vantiq.com/api/v1/wsock/websocket\");\n\n        url = \"https://prod.vantiq.com/\";\n        url = client.validifyUrl(url);\n        assert url.equals(\"wss://prod.vantiq.com/api/v1/wsock/websocket\");\n\n        url = \"https://prod.vantiq.com/api/v/wsock/websocket\";\n        url = client.validifyUrl(url);\n        assert url.equals(\"wss://prod.vantiq.com/api/v/wsock/websocket/api/v1/wsock/websocket\");\n\n        url = \"https://prod.vantiq.com/api/v47/wsock/websocket\";\n        url = client.validifyUrl(url);\n        assert url.equals(\"wss://prod.vantiq.com/api/v47/wsock/websocket\");\n    }\n\n}", "prediction": "        String url = \"http://localhost:8080/api/v1/wsock/websocket\";\n        String result = client.validifyUrl(url);\n        assertEquals(\"http://localhost:8080/api/v1/wsock/websocket\", result);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "141680627_89", "part": [1, 1], "seq": [1, 1], "prompt": "class SpeedFormatterUtil {\n\n    public static int format(final double metersPerSecond, final UnitSystem system) {\n        SpeedConverter speedConverter = new SpeedConverter();\n        Measurement speedMeterPerSecond = new Measurement(metersPerSecond,\n                MeasurementUnit.METERS_PER_SECOND);\n        double ret;\n        switch (system) {\n            case IMPERIAL_UK:\n            case IMPERIAL_US:\n                ret = speedConverter.convert(speedMeterPerSecond.getValue(),\n                        speedMeterPerSecond.getUnit(), MeasurementUnit.MILES_PER_HOUR).getValue();\n                break;\n            case METRIC:\n            default: // metric\n                ret = speedConverter.convert(speedMeterPerSecond.getValue(),\n                        speedMeterPerSecond.getUnit(), MeasurementUnit.KILOMETERS_PER_HOUR).getValue();\n                break;\n        }\n        return (int) Math.round(ret);\n    }\n\n    private  SpeedFormatterUtil();\n\n    public static String getUnitString(final Context context, final UnitSystem system);\n\n    private static final double METERS_PER_SECOND_SPEED;\n    private static final double KILOMETERS_PER_HOUR_SPEED;\n    private static final double MILES_PER_HOUR_SPEED;\n\n}\n\nclass SpeedFormatterUtilTest  {\n\n    private static final double METERS_PER_SECOND_SPEED;\n    private static final double KILOMETERS_PER_HOUR_SPEED;\n    private static final double MILES_PER_HOUR_SPEED;\n\n    @Test\n    public void testFormat() {\n", "reference": "        assertEquals(\n                SpeedFormatterUtil.format(METERS_PER_SECOND_SPEED, UnitSystem.METRIC),\n                (int) KILOMETERS_PER_HOUR_SPEED);\n        assertEquals(\n                SpeedFormatterUtil.format(METERS_PER_SECOND_SPEED, UnitSystem.IMPERIAL_UK),\n                (int) MILES_PER_HOUR_SPEED);\n        assertEquals(\n                SpeedFormatterUtil.format(METERS_PER_SECOND_SPEED, UnitSystem.IMPERIAL_US),\n                (int) MILES_PER_HOUR_SPEED);\n    }\n\n}", "prediction": "        assertEquals(10, SpeedFormatterUtil.format(METERS_PER_SECOND_SPEED, UnitSystem.METRIC));\n        assertEquals(10, SpeedFormatterUtil.format(METERS_PER_SECOND_SPEED, UnitSystem.IMPERIAL_US));\n        assertEquals(10, SpeedFormatterUtil.format(METERS_PER_SECOND_SPEED, UnitSystem.IMPERIAL_UK));\n\n        assertEquals(10, SpeedFormatterUtil.format(KILOMETERS_PER_HOUR_SPEED, UnitSystem.METRIC));\n        assertEquals(10, SpeedFormatterUtil.format(KILOMETERS_PER_HOUR_SPEED, UnitSystem.IMPERIAL_US));\n        assertEquals(10, SpeedFormatterUtil.format(KILOMETERS_PER_HOUR_SPEED, UnitSystem.IMPERIAL_UK));\n\n        assertEquals(10, SpeedFormatterUtil.format(MILES_PER_HOUR_SPEED, UnitSystem.METRIC));\n        assertEquals(10, SpeedFormatterUtil.format(MILES_PER_HOUR_SPEED, UnitSystem.IMPERIAL_US));\n        assertEquals(10, SpeedFormatterUtil.format(MILES_PER_HOUR_SPEED, UnitSystem.IMPERIAL_UK));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "141891951_11", "part": [1, 1], "seq": [1, 1], "prompt": "class DefaultMessageStore implements MessageStore {\n\n    public PutMessageResult putMessage(MessageExtBrokerInner msg) {\n        if (this.shutdown) {\n            log.warn(\"message store has shutdown, so putMessage is forbidden\");\n            return new PutMessageResult(PutMessageStatus.SERVICE_NOT_AVAILABLE, null);\n        }\n\n        if (BrokerRole.SLAVE == this.messageStoreConfig.getBrokerRole()) {\n            long value = this.printTimes.getAndIncrement();\n            if ((value % 50000) == 0) {\n                log.warn(\"message store is slave mode, so putMessage is forbidden \");\n            }\n\n            return new PutMessageResult(PutMessageStatus.SERVICE_NOT_AVAILABLE, null);\n        }\n\n        if (!this.runningFlags.isWriteable()) {\n            long value = this.printTimes.getAndIncrement();\n            if ((value % 50000) == 0) {\n                log.warn(\"message store is not writeable, so putMessage is forbidden \" + this.runningFlags.getFlagBits());\n            }\n\n            return new PutMessageResult(PutMessageStatus.SERVICE_NOT_AVAILABLE, null);\n        } else {\n            this.printTimes.set(0);\n        }\n\n        if (msg.getTopic().length() > Byte.MAX_VALUE) {\n            log.warn(\"putMessage message topic length too long \" + msg.getTopic().length());\n            return new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, null);\n        }\n\n        if (msg.getPropertiesString()!= null && msg.getPropertiesString().length() > Short.MAX_VALUE) {\n            log.warn(\"putMessage message properties length too long \" + msg.getPropertiesString().length());\n            return new PutMessageResult(PutMessageStatus.PROPERTIES_SIZE_EXCEEDED, null);\n        }\n\n        if (this.isOSPageCacheBusy()) {\n            return new PutMessageResult(PutMessageStatus.OS_PAGECACHE_BUSY, null);\n        }\n\n        long beginTime = this.getSystemClock().now();\n        PutMessageResult result = this.commitLog.putMessage(msg);\n\n        long eclipseTime = this.getSystemClock().now() - beginTime;\n        if (eclipseTime > 500) {\n            log.warn(\"putMessage not in lock eclipse time(ms)={}, bodyLength={}\", eclipseTime, msg.getBody().length);\n        }\n        this.storeStatsService.setPutMessageEntireTimeMax(eclipseTime);\n\n        if (null == result ||!result.isOk()) {\n            this.storeStatsService.getPutMessageFailedTimes().incrementAndGet();\n        }\n\n        return result;\n    }\n\n    public  DefaultMessageStore(final MessageStoreConfig messageStoreConfig, final BrokerStatsManager brokerStatsManager,\n        final MessageArrivingListener messageArrivingListener, final BrokerConfig brokerConfig);\n\n    public void truncateDirtyLogicFiles(long phyOffset);\n    public boolean load();\n    public void start();\n    public void shutdown();\n    public void destroy();\n    public void destroyLogics();\n    public PutMessageResult putMessages(MessageExtBatch messageExtBatch);\n    @Override public boolean isOSPageCacheBusy();\n    @Override public long lockTimeMills();\n    public SystemClock getSystemClock();\n    public CommitLog getCommitLog();\n    public GetMessageResult getMessage(final String group, final String topic, final int queueId, final long offset,\n        final int maxMsgNums,\n        final MessageFilter messageFilter);\n    public long getMaxOffsetInQueue(String topic, int queueId);\n    public long getMinOffsetInQueue(String topic, int queueId);\n    @Override public long getCommitLogOffsetInQueue(String topic, int queueId, long consumeQueueOffset);\n    public long getOffsetInQueueByTime(String topic, int queueId, long timestamp);\n    public MessageExt lookMessageByOffset(long commitLogOffset);\n    @Override public SelectMappedBufferResult selectOneMessageByOffset(long commitLogOffset);\n    @Override public SelectMappedBufferResult selectOneMessageByOffset(long commitLogOffset, int msgSize);\n    public String getRunningDataInfo();\n    @Override public HashMap<String, String> getRuntimeInfo();\n    @Override public long getMaxPhyOffset();\n    @Override public long getMinPhyOffset();\n    @Override public long getEarliestMessageTime(String topic, int queueId);\n    private long getStoreTime(SelectMappedBufferResult result);\n    @Override public long getEarliestMessageTime();\n    @Override public long getMessageStoreTimeStamp(String topic, int queueId, long consumeQueueOffset);\n    @Override public long getMessageTotalInQueue(String topic, int queueId);\n    @Override public SelectMappedBufferResult getCommitLogData(final long offset);\n    @Override public boolean appendToCommitLog(long startOffset, byte[] data);\n    @Override public void executeDeleteFilesManually();\n    @Override public QueryMessageResult queryMessage(String topic, String key, int maxNum, long begin, long end);\n    @Override public void updateHaMasterAddress(String newAddr);\n    @Override public long slaveFallBehindMuch();\n    @Override public long now();\n    @Override public int cleanUnusedTopic(Set<String> topics);\n    public void cleanExpiredConsumerQueue();\n    public Map<String, Long> getMessageIds(final String topic, final int queueId, long minOffset, long maxOffset,\n        SocketAddress storeHost);\n    @Override public boolean checkInDiskByConsumeOffset(final String topic, final int queueId, long consumeOffset);\n    public long dispatchBehindBytes();\n    @Override public long flush();\n    @Override public boolean resetWriteOffset(long phyOffset);\n    @Override public long getConfirmOffset();\n    @Override public void setConfirmOffset(long phyOffset);\n    public MessageExt lookMessageByOffset(long commitLogOffset, int size);\n    public ConsumeQueue findConsumeQueue(String topic, int queueId);\n    private long nextOffsetCorrection(long oldOffset, long newOffset);\n    private boolean checkInDiskByCommitOffset(long offsetPy, long maxOffsetPy);\n    private boolean isTheBatchFull(int sizePy, int maxMsgNums, int bufferTotal, int messageTotal, boolean isInDisk);\n    private void deleteFile(final String fileName);\n    private void createTempFile();\n    private void addScheduleTask();\n    private void cleanFilesPeriodically();\n    private void checkSelf();\n    private boolean isTempFileExist();\n    private boolean loadConsumeQueue();\n    private void recover(final boolean lastExitOK);\n    public MessageStoreConfig getMessageStoreConfig();\n    public TransientStorePool getTransientStorePool();\n    private void putConsumeQueue(final String topic, final int queueId, final ConsumeQueue consumeQueue);\n    private void recoverConsumeQueue();\n    private void recoverTopicQueueTable();\n    public AllocateMappedFileService getAllocateMappedFileService();\n    public StoreStatsService getStoreStatsService();\n    public RunningFlags getAccessRights();\n    public ConcurrentMap<String, ConcurrentMap<Integer, ConsumeQueue>> getConsumeQueueTable();\n    public StoreCheckpoint getStoreCheckpoint();\n    public HAService getHaService();\n    public ScheduleMessageService getScheduleMessageService();\n    public RunningFlags getRunningFlags();\n    public void doDispatch(DispatchRequest req);\n    public void putMessagePositionInfo(DispatchRequest dispatchRequest);\n    public BrokerStatsManager getBrokerStatsManager();\n    public int remainTransientStoreBufferNumbs();\n    @Override public boolean isTransientStorePoolDeficient();\n    @Override public LinkedList<CommitLogDispatcher> getDispatcherList();\n    @Override public ConsumeQueue getConsumeQueue(String topic, int queueId);\n    public void unlockMappedFile(final MappedFile mappedFile);\n\n    private final String StoreMessage;\n    private int QUEUE_TOTAL;\n    private AtomicInteger QueueId;\n    private SocketAddress BornHost;\n    private SocketAddress StoreHost;\n    private byte[] MessageBody;\n    private MessageStore messageStore;\n\n}\n\nclass DefaultMessageStoreTest {\n\n    private final String StoreMessage;\n    private int QUEUE_TOTAL;\n    private AtomicInteger QueueId;\n    private SocketAddress BornHost;\n    private SocketAddress StoreHost;\n    private byte[] MessageBody;\n    private MessageStore messageStore;\n\n    @Test\n    public void testWriteScheduleMsg() throws Exception {\n", "reference": "        long totalMsgs = 60000;\n        QUEUE_TOTAL = 10;\n        MessageBody = StoreMessage.getBytes();\n        for (long i = 0; i < totalMsgs; i++) {\n        \t\tMessageExtBrokerInner msgInner=buildScheduleMessage(i);\n            messageStore.putMessage(msgInner);\n        }\n        System.err.println(System.currentTimeMillis());\n        Thread.sleep(200000);\n        \n    }\n\n}", "prediction": "        MessageExtBrokerInner msg = new MessageExtBrokerInner();\n        msg.setTopic(\"test\");\n        msg.setBody(new byte[1024]);\n        msg.setQueueId(0);\n        msg.setStoreHost(this.StoreHost);\n        msg.setBornHost(this.BornHost);\n        msg.setFlag(MessageConst.FLAG_COMMIT_LOG);\n        msg.setQueueOffset(0);\n        msg.setSysFlag(MessageConst.PROPERTY_REAL_TIME);\n        msg.setBornTimestamp(System.currentTimeMillis());\n        msg.setStoreTimestamp(System.currentTimeMillis());\n        msg.setCommitLogOffset(0);\n        msg.setBodyCRC(0);\n        msg.setReconsumeTimes(0);\n        msg.setPreparedTransactionOffset(0);\n        msg.setPropertiesString(null);\n        msg.setProperties(null);\n        msg.setBornHostString(null);\n        msg.setStoreHostString(null);\n        msg.setStoreTimestampString(null);\n        msg.setBornTimestampString(null);\n        msg.setPreparedTransactionOffsetString(null);\n        msg.setQueueOffsetString(null);\n        msg.setCommitLogOffsetString(null);\n        msg.setBodyCRCString(null);\n        msg.setReconsumeTimesString(null);", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "142194679_0", "part": [1, 1], "seq": [1, 1], "prompt": "class SharedUtilities {\n\n  static boolean compareReferenceToId(String reference, String id) {\n    String[] refParts = reference.split(\"/\");\n    String[] idParts = id.split(\"/\");\n    if (refParts.length > idParts.length) {\n      return refParts[1].equals(idParts[0]);\n    } else if (refParts.length < idParts.length) {\n      return refParts[0].equals(idParts[1]);\n    } else { // same length\n      if (refParts.length == 1) {\n        return refParts[0].equals(idParts[0]);\n      } else {\n        return refParts[0].equals(idParts[0]) && refParts[1].equals(idParts[1]);\n      }\n    }\n  }\n\n  public static int calculateAge(Date birthDate);\n\n}\n\nclass SharedUtilitiesTest {\n\n  @Test\n  public void testCompareReferenceToId() {\n", "reference": "    assertTrue(SharedUtilities.compareReferenceToId(\"Patient/1234\", \"1234\"));\n    assertTrue(SharedUtilities.compareReferenceToId(\"1234\", \"Patient/1234\"));\n    assertTrue(SharedUtilities.compareReferenceToId(\"1234\", \"1234\"));\n    assertTrue(SharedUtilities.compareReferenceToId(\"Patient/1234\", \"Patient/1234\"));\n\n    assertFalse(SharedUtilities.compareReferenceToId(\"Patient/1234\", \"4321\"));\n    assertFalse(SharedUtilities.compareReferenceToId(\"1234\", \"Patient/4321\"));\n    assertFalse(SharedUtilities.compareReferenceToId(\"1234\", \"4321\"));\n    assertFalse(SharedUtilities.compareReferenceToId(\"Patient/1234\", \"Patient/4321\"));\n\n    assertFalse(SharedUtilities.compareReferenceToId(\"Patient/1234\", \"Practitioner/1234\"));\n    assertFalse(SharedUtilities.compareReferenceToId(\"Patient/1234\", \"Practitioner/4321\"));\n  }\n\n}", "prediction": "    assertTrue(SharedUtilities.compareReferenceToId(\"http://localhost:8080/fhir/Patient/123\", \"123\"));\n    assertTrue(SharedUtilities.compareReferenceToId(\"http://localhost:8080/fhir/Patient/123\", \"Patient/123\"));\n    assertTrue(SharedUtilities.compareReferenceToId(\"http://localhost:8080/fhir/Patient/123\", \"Patient/123/identifier/123\"));\n    assertTrue(SharedUtilities.compareReferenceToId(\"http://localhost:8080/fhir/Patient/123\", \"Patient/123/identifier/123/value/123\"));\n    assertTrue(SharedUtilities.compareReferenceToId(\"http://localhost:8080/fhir/Patient/123\", \"Patient/123/identifier/123/value/123/system/123\"));\n    assertTrue(SharedUtilities.compareReferenceToId(\"http://localhost:8080/fhir/Patient/123\", \"Patient/123/identifier/123/value/123/system/123/type/123\"));\n    assertTrue(SharedUtilities.compareReferenceToId(\"http://localhost:8", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "143824400_1", "part": [1, 1], "seq": [1, 1], "prompt": "class MenuService {\n\n    public List<MenuTreeDto> getUserMenu(String uuid){\n        Assert.notNull(uuid,\"uuid is not null\");\n\n        // \u5224\u65ad\u662f\u5426\u662f\u8d85\u7ea7\u7ba1\u7406\u5458\n        List<SysRole> roles = roleService.selectByUuid(uuid);\n        boolean isAdmin = roles.stream().anyMatch(role -> \"ROLE_ADMIN\".equals(role.getRoleKey()));\n        if(isAdmin) {\n            return getMenuTreeEnabled();\n        }\n\n        List<SysPermission> permissions = permissionService.selectByUuidAndType(uuid, TYPE_MENU);\n        List<Menu> collect = permissions.stream().map(this::toMenu).collect(Collectors.toList());\n        return buildMenuTree(collect,-1);\n    }\n\n    private List<Menu> allMenus();\n    private List<Menu> allMenuEnabled();\n    private List<Menu> toMenus(List<SysPermission> permissions);\n    private List<MenuTreeDto> buildMenuTree(List<Menu> menus,Integer pid);\n    public List<MenuTreeDto> getMenuTree();\n    public List<MenuTreeDto> getMenuTreeEnabled();\n    @Transactional(rollbackFor = Exception.class) public void addMenu(Menu menu);\n    @Transactional(rollbackFor = Exception.class) public void updateMenu(Menu menu);\n    @Transactional(rollbackFor = Exception.class) public boolean deleteById(Integer id);\n    public boolean hasChildren(Integer menuId);\n    public Menu getMenu(Integer id);\n    private Menu toMenu(SysPermission permission);\n\n    @Autowired\n    private MenuService menuService;\n    @Autowired\n    private UserService userService;\n\n}\n\nclass MenuServiceTest  {\n\n    @Autowired\n    private MenuService menuService;\n    @Autowired\n    private UserService userService;\n\n    @Test\n    public void getUserMenu() {\n", "reference": "\n        SysUser admin = userService.findByUsername(\"admin\");\n        String uuid = admin.getUuid();\n\n        List<MenuTreeDto> menus = menuService.getUserMenu(uuid);\n        System.out.println(menus);\n\n    }\n\n}", "prediction": "//        List<MenuTreeDto> userMenu = menuService.getUserMenu(\"1\");\n//        System.out.println(userMenu);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "143926791_39", "part": [1, 1], "seq": [1, 1], "prompt": "class AccountService {\n\n\tpublic Integer saveAccount(Account accountRequest) {\n\n\t\tlogger.debug(\"AccountService.saveAccount:\" + accountRequest.toString());\n\t\t// need to set some stuff that cannot be null!\n\t\t\n\n\t\tAccount account = accounts.save(accountRequest);\n\t\tlogger.info(\"AccountService.saveAccount: account saved: \" + account);\n\t\treturn account.getId();\n\t}\n\n\tpublic Account findAccount(Integer id);\n\tpublic List<Account> findAccounts(String user);\n\tpublic List<Account> findAccountsByType(String id, AccountType type);\n\n\t MockMvc mockMvc;\n\t@InjectMocks AccountService service;\n\t@Mock AccountRepository repo;\n\n}\n\nclass AccountServiceTest {\n\n\t MockMvc mockMvc;\n\t@InjectMocks AccountService service;\n\t@Mock AccountRepository repo;\n\n\t@Test\n\tpublic void saveAccount() {\n", "reference": "\t\tAccount acc = ServiceTestConfiguration.account();\n\t\twhen(repo.save(acc)).thenReturn(acc);\n\t\tassertEquals(service.saveAccount(acc),acc.getId());\n\t}\n\n}", "prediction": "\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "144251992_258", "part": [1, 1], "seq": [1, 1], "prompt": "class HibernateSimpleQueryUtils {\n\n    static List<Pair<Integer, Integer>> getReplaceableTermsOfQuery(String simpleQuery) {\n        var termIndexPairs = new ArrayList<Pair<Integer, Integer>>();\n        var queryCharCount = simpleQuery.length();\n\n        var index = 0;\n        while(index >= 0 && index < queryCharCount) {\n            var currentChar = simpleQuery.charAt(index);\n\n            // skip term delimiters\n            if(TERM_DELIMITER.contains(currentChar)) {\n                index++;\n                continue;\n            }\n\n            // ignore phrase terms and near operators\n            if(currentChar == '\"') {\n                index = getIndexAfterPhraseTerm(index, simpleQuery);\n                continue;\n            }\n\n            var nextSpecialCharIndex = getIndexOfFirstAppearanceOfAny(index, SPECIAL_CHARACTERS, simpleQuery);\n            var nextTermDelimiterIndex = getIndexOfFirstAppearanceOfAny(index, TERM_DELIMITER, simpleQuery);\n\n            // no term delimiter found after the current term\n            if(nextTermDelimiterIndex < 0) {\n                nextTermDelimiterIndex = queryCharCount;\n            }\n            var termEndIndex = nextTermDelimiterIndex - 1;\n\n            // when a term delimiter is present and the term is not a fuzzy or prefix term add\n            // the pair -> ignore fuzzy and prefix terms\n            var isSimpleTerm = nextSpecialCharIndex < 0 || nextTermDelimiterIndex < nextSpecialCharIndex;\n            if(isSimpleTerm) {\n                termIndexPairs.add(Pair.of(index, termEndIndex));\n\n                index = nextTermDelimiterIndex + 1;\n            } else {\n                // skip this term\n                index = getIndexAfterFirstAppearanceOfAny(nextSpecialCharIndex, TERM_DELIMITER, simpleQuery);\n            }\n        }\n\n        return termIndexPairs;\n    }\n\n    public static String makeQueryPrefixAndFuzzy(@NonNull String simpleQuery);\n    static String replaceTermWithFuzzyAndPrefixDisjunction(Pair<Integer, Integer> startEndIndexPair, String simpleQuery);\n    static String replaceSubstring(Pair<Integer, Integer> startEndIndexPair, String stringToReplaceIn, String replacement);\n    static int getIndexAfterFirstAppearanceOfAny(int startIndex, Set<Character> characters, String searchedString);\n    static int getIndexAfterFirstAppearanceOf(int startIndex, char character, String searchedString);\n    static int getIndexOfFirstAppearanceOfAny(int startIndex, Set<Character> characters, String searchedString);\n    static int getIndexAfterPhraseTerm(int startIndex, String simpleQuery);\n    public static String createLuceneQueryString(Collection<String> values, String operator,\n                                                  Function<String, String> function);\n    public static String createLuceneQueryString(Collection<String> values, String operator);\n\n}\n\nclass HibernateSimpleQueryUtilsTest {\n\n    @Test\n    public void getReplaceableTermsOfQueryIgnoresNearOperatorOfPhraseTerms() {\n", "reference": "        // given\n        var simpleQuery = \"\\\"test\\\"~10\";\n\n        // when\n        var actualPairs = HibernateSimpleQueryUtils.getReplaceableTermsOfQuery(simpleQuery);\n\n        // then\n        assertThat(actualPairs).isEmpty();\n    }\n\n}", "prediction": "        var simpleQuery = \"a \\\"b c\\\" d\";\n        var replaceableTerms = HibernateSimpleQueryUtils.getReplaceableTermsOfQuery(simpleQuery);\n\n        assertThat(replaceableTerms).hasSize(2);\n        assertThat(replaceableTerms.get(0)).isEqualTo(Pair.of(0, 0));\n        assertThat(replaceableTerms.get(1)).isEqualTo(Pair.of(4, 7));\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "144309611_105", "part": [1, 1], "seq": [1, 1], "prompt": "class ServerViewController extends ViewController {\n\n\tpublic TOMMessage[] clearUpdates() {\n\t\tTOMMessage[] ret = new TOMMessage[updates.size()];\n\t\tfor (int i = 0; i < updates.size(); i++) {\n\t\t\tret[i] = updates.get(i);\n\t\t}\n\t\tupdates.clear();\n\t\treturn ret;\n\t}\n\n\tpublic  ServerViewController(int procId);\n\tpublic  ServerViewController(int procId, String configHome);\n\n\tprivate InetSocketAddress[] getInitAdddresses();\n\tpublic void setTomLayer(TOMLayer tomLayer);\n\tpublic boolean isInCurrentView();\n\tpublic int[] getCurrentViewOtherAcceptors();\n\tpublic int[] getCurrentViewAcceptors();\n\tpublic boolean hasUpdates();\n\tpublic void enqueueUpdate(TOMMessage up);\n\tpublic byte[] executeUpdates(int cid);\n\tprivate boolean contains(int id, List<Integer> list);\n\tprivate byte[] reconfigure(List<String> jSetInfo, List<Integer> jSet, List<Integer> rSet, int f, int cid);\n\tpublic boolean isInLastJoinSet(int id);\n\tpublic void processJoinResult(ReconfigureReply r);\n\t@Override public final void reconfigureTo(View newView);\n\tpublic int getQuorum();\n\n}\n\nclass ServerViewControllerTest {\n\n\t@Test\n\tpublic void testClearUpdates() {\n", "reference": "\t\tfail(\"Not yet implemented\");\n\t}\n\n}", "prediction": "\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "146177746_35", "part": [1, 1], "seq": [1, 1], "prompt": "class SwaggerBasePathRewritingFilter extends SendResponseFilter {\n\n    @Override\n    public boolean shouldFilter() {\n        return RequestContext.getCurrentContext().getRequest().getRequestURI().endsWith(Swagger2Controller.DEFAULT_URL);\n    }\n\n    public  SwaggerBasePathRewritingFilter();\n\n    @Override public String filterType();\n    @Override public int filterOrder();\n    @Override public Object run();\n    @SuppressWarnings(\"unchecked\") private String rewriteBasePath(RequestContext context);\n\n    private SwaggerBasePathRewritingFilter filter;\n\n}\n\nclass SwaggerBasePathRewritingFilterTest {\n\n    private SwaggerBasePathRewritingFilter filter;\n\n    @Test\n    public void shouldNotFilter_on_wrong_url() {\n", "reference": "\n        MockHttpServletRequest request = new MockHttpServletRequest(\"GET\", \"/management/info\");\n        RequestContext.getCurrentContext().setRequest(request);\n\n        assertFalse(filter.shouldFilter());\n    }\n\n}", "prediction": "        RequestContext context = mock(RequestContext.class);\n        when(context.getRequest().getRequestURI()).thenReturn(\"/swagger.json\");\n\n        boolean result = filter.shouldFilter();\n\n        assertFalse(result);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "147378679_2", "part": [1, 1], "seq": [1, 1], "prompt": "class MathUtil {\n\n    public static double[] powerSumsToChebyMoments(\n            double min,\n            double max,\n            double[] powerSums\n    ) {\n        int k = powerSums.length - 1;\n        double r = (max - min) / 2;\n        double xc = (max + min) / 2;\n        // First rescale the variables so that they lie in [-1,1]\n        double[] scaledPowerSums = MathUtil.shiftPowerSum(\n                powerSums,r,xc\n        );\n\n        double count = powerSums[0];\n        int[][] cCoeffs = MathUtil.getChebyCoefficients(k);\n        // Then convert from power sums to chebyshev moments\n        double[] scaledChebyMoments = new double[k+1];\n        for (int i = 0; i <=k; i++) {\n            double sum = 0.0;\n            for (int j = 0; j <= i; j++) {\n                sum += cCoeffs[i][j]*scaledPowerSums[j];\n            }\n            scaledChebyMoments[i] = sum / count;\n        }\n\n        return scaledChebyMoments;\n    }\n\n    public static long[][] getBinomials(int m);\n    public static int[][] getChebyCoefficients(int k);\n    public static double[] shiftPowerSum(\n            double[] powerSums,\n            double r,\n            double xc\n    );\n    public static double[] powerSumsToZerodMoments(\n            double[] powerSums,\n            double min,\n            double max\n    );\n    public static double arrayMean(double[] xs);\n    public static void calcPowers(double x, double[] powers);\n    public static double entropy(double[] ps);\n    public static double getMSE(double[] error);\n\n}\n\nclass MathUtilTest {\n\n    @Test\n    public void testConvertMoments() {\n", "reference": "        // integers from 0...1000\n        double[] uniformPowerSums = {1001,500500,333833500,250500250000L};\n        double[] convertedChebyshevMoments = MathUtil.powerSumsToChebyMoments(0, 1000, uniformPowerSums);\n\n        double[] expectedChebyshevMoments = {1.0, 0, -.332, 0};\n        assertArrayEquals(expectedChebyshevMoments, convertedChebyshevMoments, 1e-14);\n    }\n\n}", "prediction": "//        double[] powerSums = {1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, ", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "147606002_1", "part": [1, 1], "seq": [1, 1], "prompt": "class MailUtil {\n\n\tpublic static String sendMail() {\n\t\t// to do something about send email\n\t\treturn \"send email\";\n\t}\n\n}\n\nclass MailUtilTest {\n\n\t@Test\n\tpublic void testSendMail() {\n", "reference": "\t\tassertEquals(MailUtil.sendMail(), \"send email\");\n\t}\n\n}", "prediction": "\t\tString result = MailUtil.sendMail();\n\t\tAssert.assertEquals(\"send email\", result);\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "147673645_2", "part": [1, 1], "seq": [1, 1], "prompt": "class S3File {\n\n\tpublic String getBucket() {\n\t\treturn bucket;\n\t}\n\n\tpublic  S3File(String fullPath);\n\n\tpublic static void initClient();\n\tpublic static void setAmazonClient(AmazonS3 s3);\n\tprivate InputStream open(int retry);\n\tpublic InputStream open();\n\tpublic OutputStream create();\n\tpublic OutputStream append();\n\tpublic void delete();\n\tpublic void rename(S3File dstKey);\n\tpublic void save();\n\tprivate static void showStats();\n\n}\n\nclass S3FileTest {\n\n\t@Test\n\tpublic void testWithProtocol() {\n", "reference": "\t\tS3File file = new S3File(\"s3a://root/folder\");\n\t\tAssert.assertEquals(\"root\", file.getBucket());\n\t}\n\n}", "prediction": "\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "150668624_2", "part": [1, 1], "seq": [1, 1], "prompt": "class StorageJetCache extends SimpleJpaRepository<E,PK> implements IStorage<PK,E> {\n\n    @Override\n    @Transactional(rollbackFor = Exception.class)\n    public void update(E entity) {\n        PK id = entity.getId();\n        Preconditions.checkNotNull(id,\"id\u4e0d\u80fd\u4e3anull\");\n        CacheGetResult<E> cacheGetResult = cache.GET(id);\n        if (cacheGetResult.isSuccess()){\n            E entityFromCache = cacheGetResult.getValue();\n            // \u7f13\u5b58\u4e2d\u7f13\u5b58\u4e86\u5176null\u503c\uff0c\u8bf4\u660e\u6570\u636e\u5e93\u4e2d\u6ca1\u6709\n            if (entityFromCache == null) {\n                throw new EntityNotFoundException(\"\u6570\u636e\u5e93\u4e2d\u4e0d\u5b58\u5728\u8be5\u5b9e\u4f53\uff0c\u5148create\u4e00\u4e0b\uff1f\");\n            }\n            // \u7f13\u5b58\u4e2d\u6709\uff0c\u8bf4\u660e\u6570\u636e\u5e93\u4e2d\u4e5f\u6709\n            else {\n                executeUpdate(entity);\n            }\n        }else {\n            if (exists(entity.getId())){\n                executeUpdate(entity);\n            }else {\n                throw new EntityNotFoundException(\"\u6570\u636e\u5e93\u4e2d\u4e0d\u5b58\u5728\u8be5\u5b9e\u4f53\uff0c\u5148create\u4e00\u4e0b\uff1f\");\n            }\n        }\n    }\n\n    public  StorageJetCache(JpaEntityInformation<E,?> entityInformation, EntityManager entityManager);\n\n    @Override @Transactional(rollbackFor = Exception.class) public E create(E entity);\n    private E doInsert(E entity);\n    private void doUpdate(E entity);\n    private void executeUpdate(E entity);\n    @Override public void mergeUpdate(E entity);\n    @Override public E get(PK id);\n    @Override @Transactional(rollbackFor = Exception.class) public E getOrCreate(PK id, EntityCreator<PK, E> entityCreator);\n    @Override @Transactional(rollbackFor = Exception.class) public E remove(PK id);\n    public void setDelay(int delay);\n    public void setProxy(IStorage<PK, E> proxy);\n    public void setCache(Cache<PK, E> cache);\n\n    private static final Logger logger;\n    @Autowired IStorage<String, AccountEntity> iStorage;\n    @Autowired\n    private IStorage<Long, ContainerEntity> containerEntityIStorage;\n    @Test void entity;\n     Container packContainer;\n     entity.getType2ContainerMap().put PACK;\n     containerEntityIStorage.create entity;\n     containerEntityIStorage.update entity;\n\n}\n\nclass StorageJetCacheTest extends SimpleJpaRepository<E,PK> {\n\n    private static final Logger logger;\n    @Autowired IStorage<String, AccountEntity> iStorage;\n    @Autowired\n    private IStorage<Long, ContainerEntity> containerEntityIStorage;\n    @Test void entity;\n     Container packContainer;\n     entity.getType2ContainerMap().put PACK;\n     containerEntityIStorage.create entity;\n     containerEntityIStorage.update entity;\n\n    @Test\n    void update() {\n", "reference": "        AccountEntity accountEntity = createNotExists();\n        accountEntity.setPassword(\"passWordUpdate\");\n        iStorage.update(accountEntity);\n        iStorage.remove(accountEntity.getId());\n        Assertions.assertEquals(\"passWordUpdate\",iStorage.get(accountEntity.getAccount()).getPassword());\n    }\n\n}", "prediction": "//        AccountEntity accountEntity = new AccountEntity();\n//        accountEntity.setId(\"1\");\n//        accountEntity.setBalance(10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "150938406_239", "part": [1, 1], "seq": [1, 1], "prompt": "class SparseVector extends Vector {\n\n    @Override\n    public double get(int i) {\n        int pos = Arrays.binarySearch(indices, i);\n        if (pos >= 0) {\n            return values[pos];\n        }\n        return 0.;\n    }\n\n    public  SparseVector();\n    public  SparseVector(int n);\n    public  SparseVector(int n, int[] indices, double[] values);\n    public  SparseVector(int n, Map<Integer, Double> kv);\n\n    private void checkSizeAndIndicesRange();\n    private static void sortImpl(int[] indices, double[] values, int low, int high);\n    private void sortIndices();\n    @Override public SparseVector clone();\n    @Override public SparseVector prefix(double d);\n    @Override public SparseVector append(double d);\n    public int[] getIndices();\n    public double[] getValues();\n    @Override public int size();\n    public void setSize(int n);\n    public int numberOfValues();\n    @Override public void set(int i, double val);\n    @Override public void add(int i, double val);\n    private void insert(int pos, int index, double val);\n    @Override public String toString();\n    @Override public double normL2();\n    @Override public double normL1();\n    @Override public double normInf();\n    @Override public double normL2Square();\n    @Override public SparseVector slice(int[] indices);\n    @Override public Vector plus(Vector vec);\n    @Override public Vector minus(Vector vec);\n    @Override public SparseVector scale(double d);\n    @Override public void scaleEqual(double d);\n    public void removeZeroValues();\n    private double dot(SparseVector other);\n    private double dot(DenseVector other);\n    @Override public double dot(Vector other);\n    @Override public DenseMatrix outer();\n    public DenseMatrix outer(SparseVector other);\n    public DenseVector toDenseVector();\n    @Override public void standardizeEqual(double mean, double stdvar);\n    @Override public void normalizeEqual(double p);\n    @Override public boolean equals(Object o);\n    @Override public int hashCode();\n    public void forEach(BiConsumer<Integer, Double> action);\n    @Override public VectorIterator iterator();\n\n    private static final double TOL;\n    private SparseVector v1;\n    private SparseVector v2;\n\n}\n\nclass SparseVectorTest {\n\n    private static final double TOL;\n    private SparseVector v1;\n    private SparseVector v2;\n\n    @Test\n    public void testGet() throws Exception {\n", "reference": "        Assert.assertEquals(v1.get(5), 2.0, TOL);\n        Assert.assertEquals(v1.get(6), 0.0, TOL);\n    }\n\n}", "prediction": "        assertEquals(v1.get(0), 1., TOL);\n        assertEquals(v1.get(1), 2., TOL);\n        assertEquals(v1.get(2), 3., TOL);\n        assertEquals(v1.get(3), 4., TOL);\n        assertEquals(v1.get(4), 5., TOL);\n        assertEquals(v1.get(5), 6., TOL);\n        assertEquals(v1.get(6), 7., TOL);\n        assertEquals(v1.get(7), 8., TOL);\n        assertEquals(v1.get(8), 9., TOL);\n        assertEquals(v1.get(9), 10., TOL);\n        assertEquals(v1.get(10), 11., TOL);\n        assertEquals(v1.get(11), 12., TOL);\n        assertEquals(v1.get(12), 13., TOL);\n        assertEquals(v1.get(13), 14., TOL);\n        assertEquals(v1.get(14), 15., TOL);\n        assertEquals(v1.get(15), 16., TOL);\n        assertEquals(v1.get(16), 17., TOL);\n        assertEquals(v1.get(17), 18., TOL);\n        assertEquals(v1.get(18), 19., TOL);\n        assertEquals(v1.get(19), 20., TOL);\n        assertEquals(v1.get(20), 21., TOL);\n        assertEquals(v1.get(21), 22., TOL);\n        assertEquals(v1.get(22), 23., TOL);\n        assertEquals(v1.get(23), 24., TOL);\n        assertEquals(v1.get(24), 25., TOL);\n        assertEquals(v1.get(25), 26., TOL);\n        assertEquals(v1.get(26), 27., TOL);\n        assertEquals(v1.get(27), 28., TOL);\n        assertEquals(v1.get(28), 29., TOL);\n        assertEquals(v1.get(29), 30., TOL);\n        assertEquals(v1.get(30), 31., TOL);\n        assertEquals(v1.get(31), 32., TOL);\n        assertEquals(v1.get(32), 33., TOL);\n        assertEquals(v1.get(33), 34., TOL);\n        assertEquals(v1.get(34), 35., TOL);\n        assertEquals(v1.get(35), 36., TOL);\n        assertEquals(v1.get(36), 37., TOL);\n        assertEquals(v1.get(37), 38., TOL);\n        assertEquals(v1.get(38), 39., TOL);\n        assertEquals(v1.get(39), 40., TOL);\n        assertEquals(v1.get(40), 41., TOL);\n        assertEquals(v1.get(41), 42., TOL);\n        assertEquals(v1.get(42), 43., TOL);\n        assertEquals(v1.get(43), 44., TOL);\n        assertEquals(v1.get(44), 45., TOL);\n        assertEquals(v1.get(45), 46., TOL);\n        assertEquals(v1.get(46), 47., TOL);\n        assertEquals(v1.get(47), 48., TOL);\n        assertEquals(v1.get(48), 49., TOL);\n        assertEquals(v1.get(49), 50., TOL);\n        assertEquals(v1.get(50), 51., TOL);\n        assertEquals(v1.get(51), 52., TOL);\n        assertEquals(v1.get(52), 53., TOL);\n        assertEquals(v1.get(53), 54., TOL);\n        assertEquals(v1.get(54), 55., TOL);\n        assertEquals(v1.get(55), 56., TOL);\n        assertEquals(v1.get(56), 57., TOL);\n        assertEquals(v1.get(57), 58., TOL);\n        assertEquals(v1.get(58), 59., TOL);\n        assertEquals(v1.get(59), 60., TOL);\n        assertEquals(v1.get(60), 61., TOL);\n        assertEquals(v1.get(61), 62., TOL);\n        assertEquals(v1.get(62), 63., TOL);\n        assertEquals(v1.get(63), 64., TOL);\n        assertEquals(v1.get(64), 65., TOL);\n        assertEquals(v1.get(65), 66., TOL);\n        assertEquals(v1.get(66), 67., TOL);\n        assertEquals(v1.get(67), 68., TOL);\n        assertEquals(v1.get(68), 69., TOL);\n        assertEquals(v1.get(69), 70., TOL);\n        assertEquals(v1.get(70), 71., TOL);\n        assertEquals(v1.get(71), 72., TOL);\n        assertEquals(v1.get(72), 73., TOL);\n        assertEquals(v1.get(73), 74., TOL);\n        assertEquals(v1.get(74), 75., TOL);\n        assertEquals(v1.get(75), 76., TOL);\n        assertEquals(v1.get(76), 77., TOL);\n        assertEquals(v1.get(77), 78., TOL);\n        assertEquals(v1.get(78), 79., TOL);\n        assertEquals(v1.get(79), 80., TOL);\n        assertEquals(v1.get(80), 81., TOL);\n        assertEquals(v1.get(81), 82., TOL);\n        assertEquals(v1.get(82), ", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "151625754_0", "part": [1, 1], "seq": [1, 1], "prompt": "class RSACoder extends Coder {\n\n    public static String sign(byte[] data, String privateKey) throws Exception {\n        // \u89e3\u5bc6\u7531base64\u7f16\u7801\u7684\u79c1\u94a5\n        byte[] keyBytes = decryptBASE64(privateKey);\n\n        // \u6784\u9020PKCS8EncodedKeySpec\u5bf9\u8c61\n        PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes);\n\n        // KEY_ALGORITHM \u6307\u5b9a\u7684\u52a0\u5bc6\u7b97\u6cd5\n        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);\n\n        // \u53d6\u79c1\u94a5\u5319\u5bf9\u8c61\n        PrivateKey priKey = keyFactory.generatePrivate(pkcs8KeySpec);\n\n        // \u7528\u79c1\u94a5\u5bf9\u4fe1\u606f\u751f\u6210\u6570\u5b57\u7b7e\u540d\n        Signature signature = Signature.getInstance(SIGNATURE_ALGORITHM);\n        signature.initSign(priKey);\n        signature.update(data);\n\n        return encryptBASE64(signature.sign());\n    }\n\n    public static boolean verify(byte[] data, String publicKey, String sign);\n    public static byte[] decryptByPrivateKey(byte[] data, String key);\n    public static byte[] decryptByPublicKey(byte[] data, String key);\n    public static byte[] encryptByPublicKey(byte[] data, String key);\n    public static byte[] encryptByPrivateKey(byte[] data, String key);\n    public static String getPrivateKey(Map<String, Object> keyMap);\n    public static String getPublicKey(Map<String, Object> keyMap);\n    public static Map<String, Object> initKey();\n\n    private String publicKey;\n    private String privateKey;\n\n}\n\nclass RSACoderTest {\n\n    private String publicKey;\n    private String privateKey;\n\n    @Test\n    public void testSign() throws Exception {\n", "reference": "        System.out.println(\"\u79c1\u94a5\u52a0\u5bc6\u2014\u2014\u516c\u94a5\u89e3\u5bc6\");\n        String inputStr = \"sign\";\n        byte[] data = inputStr.getBytes();\n\n        byte[] encodedData = RSACoder.encryptByPrivateKey(data, privateKey);\n\n        byte[] decodedData = RSACoder.decryptByPublicKey(encodedData, publicKey);\n\n        String outputStr = new String(decodedData);\n        System.out.println(\"\u52a0\u5bc6\u524d: \" + inputStr + \"\\n\\r\" + \"\u89e3\u5bc6\u540e: \" + outputStr);\n        assertEquals(inputStr, outputStr);\n\n        System.out.println(\"\u79c1\u94a5\u7b7e\u540d\u2014\u2014\u516c\u94a5\u9a8c\u8bc1\u7b7e\u540d\");\n        // \u4ea7\u751f\u7b7e\u540d\n        String sign = RSACoder.sign(encodedData, privateKey);\n        System.out.println(\"\u7b7e\u540d:\" + sign);\n\n        // \u9a8c\u8bc1\u7b7e\u540d\n        boolean status = RSACoder.verify(encodedData, publicKey, sign);\n        System.out.println(\"\u72b6\u6001:\" + status);\n        assertTrue(status);\n\n    }\n\n}", "prediction": "//        String data = \"123456\";\n//        String sign = RSACoder.sign(data.getBytes(), privateKey);\n//        System.out.println(sign);\n//        System.out.println(RSACoder.verify(data.getBytes(), publicKey, sign));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "152217753_8", "part": [1, 1], "seq": [1, 1], "prompt": "class MyController {\n\n    @GetMapping(\"/hello/{name}\")\n    public @ResponseBody\n    String helloName(@PathVariable String name) {\n        return \"hello \" + name;\n    }\n\n    @GetMapping(\"/hello\") public String hello(Model model);\n    @GetMapping(\"/hello/{name1}/{name2}\") public @ResponseBody String helloName(@PathVariable(name = \"name1\") String name1, @PathVariable(name = \"name2\") String name2);\n\n    @Autowired\n    private MockMvc mockMvc;\n\n}\n\nclass MyControllerTest {\n\n    @Autowired\n    private MockMvc mockMvc;\n\n    @Test\n    public void helloNameTest() throws Exception {\n", "reference": "        String name = \"siyoon\";\n\n        mockMvc.perform(get(\"/hello/{name}\", name).accept(MediaType.TEXT_HTML))\n                .andExpect(status().isOk())\n                .andDo(print());\n    }\n\n}", "prediction": "        mockMvc.perform(get(\"/hello/test\"))\n               .andExpect(status().isOk())\n               .andExpect(content().string(\"hello test\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "154253610_0", "part": [1, 1], "seq": [1, 1], "prompt": "class FastSharedPreferences implements EnhancedSharedPreferences {\n\n    public static FastSharedPreferences get(String name) {\n        if (name == null || name.length() == 0) {\n            return null;\n        }\n        synchronized (FastSharedPreferences.class) {\n            return FSP_CACHE.get(name);\n        }\n    }\n\n    private  FastSharedPreferences(String name);\n\n    public static void init(Context context);\n    public static void setMaxSize(int maxSize);\n    @Override public Map<String,?> getAll();\n    @Nullable @Override public String getString(String s, @Nullable String s1);\n    @Override public Serializable getSerializable(String key, @Nullable Serializable defValue);\n    @Nullable @Override public Set<String> getStringSet(String s, @Nullable Set<String> set);\n    @Override public int getInt(String s, int i);\n    @Override public long getLong(String s, long l);\n    @Override public float getFloat(String s, float v);\n    @Override public boolean getBoolean(String s, boolean b);\n    @Override public boolean contains(String s);\n    @Override public EnhancedEditor edit();\n    @Override public void registerOnSharedPreferenceChangeListener(OnSharedPreferenceChangeListener onSharedPreferenceChangeListener);\n    @Override public void unregisterOnSharedPreferenceChangeListener(OnSharedPreferenceChangeListener onSharedPreferenceChangeListener);\n    private void reload();\n    private int sizeOf();\n\n    @Mock Context context;\n    @Mock Context appContext;\n\n}\n\nclass FastSharedPreferencesTest {\n\n    @Mock Context context;\n    @Mock Context appContext;\n\n    @Test\n    public void testLoad() {\n", "reference": "        FastSharedPreferences sharedPreferences = FastSharedPreferences.get(\"test_load\");\n        assertNotNull(sharedPreferences);\n    }\n\n}", "prediction": "        FastSharedPreferences.init(context);\n        FastSharedPreferences.get(\"test\");\n        verify(context).getSharedPreferences(\"test\", Context.MODE_PRIVATE);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "154302277_67", "part": [1, 1], "seq": [1, 1], "prompt": "class TimestampMeasurementElement implements MeasurementElement, Serializable {\n\n    public ZonedDateTime asZonedDateTime() {\n        return ZonedDateTime.ofInstant(Instant.ofEpochMilli(this.value), ZoneOffset.UTC);\n    }\n\n    public  TimestampMeasurementElement(final long value);\n    public  TimestampMeasurementElement(final ZonedDateTime zonedDateTime);\n\n    public Long getValue();\n    @Override public boolean equals(final Object obj);\n    @Override public int hashCode();\n    @Override public String toString();\n\n}\n\nclass TimestampMeasurementElementTest {\n\n    @Test\n    public void AsZonedDateTimeShouldReturnCorrectZonedDateTimeWhenConstructedUsingZonedDateTime() {\n", "reference": "        // Arrange\n        final ZonedDateTime expected = ZonedDateTime.of(2020, 2, 20, 21, 59, 59, 0, ZoneOffset.UTC);\n\n        // Act\n        final TimestampMeasurementElement element = new TimestampMeasurementElement(expected);\n        final ZonedDateTime actual = element.asZonedDateTime();\n\n        // Assert\n        assertThat(actual).isEqualTo(expected);\n    }\n\n}", "prediction": "        final ZonedDateTime zonedDateTime = ZonedDateTime.of(2016, 1, 1, 0, 0, 0, 0, ZoneOffset.UTC);\n        final TimestampMeasurementElement timestampMeasurementElement = new TimestampMeasurementElement(zonedDateTime);\n\n        assertThat(timestampMeasurementElement.asZonedDateTime(), is(zonedDateTime));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "155277206_0", "part": [1, 1], "seq": [1, 1], "prompt": "class AgentRuleUtil {\n\n  @SuppressWarnings(\"unchecked\")\n  public static <T>T[] subArray(final T[] array, final int beginIndex, final int endIndex) {\n    if (endIndex < beginIndex)\n      throw new IllegalArgumentException(\"endIndex (\" + endIndex + \") < beginIndex (\" + beginIndex + \")\");\n\n    final Class<?> componentType = array.getClass().getComponentType();\n    final T[] subArray = (T[])Array.newInstance(componentType, endIndex - beginIndex);\n    if (beginIndex == endIndex)\n      return subArray;\n\n    System.arraycopy(array, beginIndex, subArray, 0, endIndex - beginIndex);\n    return subArray;\n  }\n\n  private  AgentRuleUtil();\n\n  public static String getNameId(final Object obj);\n  public static String getSimpleNameId(final Object obj);\n  public static T[] subArray(final T[] array, final int beginIndex);\n  public static Class<?>[] getExecutionStack();\n  public static StackTraceElement[] getCallStack();\n  public static boolean callerEquals(int frameIndex, final String name);\n  public static boolean callerEquals(int startFrame, int endFrame, final String name);\n  public static boolean callerEquals(int frameIndex, final String... names);\n  public static boolean callerEquals(int startFrame, int endFrame, final String...  names);\n  public static boolean hasMethodNamed(TypeDefinition typeDefinition, final String methodName);\n  @SuppressWarnings(\"unchecked\") public static T getFieldInBootstrapClass(final Class<?> cls, final String fieldName);\n  public static boolean isFromClassLoader(final Class<?>[] callStack, final ClassLoader classLoader);\n  public static URL[] classPathToURLs(final String classpath);\n\n}\n\nclass AgentRuleUtilTest {\n\n  @Test\n  public void testSubArray() {\n", "reference": "    try {\n      AgentRuleUtil.subArray(null, 0);\n      fail(\"Expected NullPointerException\");\n    }\n    catch (final NullPointerException e) {\n    }\n\n    try {\n      AgentRuleUtil.subArray(new String[] {\"\"}, 0, -1);\n      fail(\"Expected IllegalArgumentException\");\n    }\n    catch (final IllegalArgumentException e) {\n    }\n\n    final Integer[] array = {0, 1, 2, 3, 4, 5, 6, 7, 8};\n    assertArrayEquals(new Integer[] {2, 3}, AgentRuleUtil.subArray(array, 2, 4));\n    assertArrayEquals(new Integer[] {6, 7, 8}, AgentRuleUtil.subArray(array, 6));\n  }\n\n}", "prediction": "    final String[] array = new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"};\n    final String[] subArray = AgentRuleUtil.subArray(array, 1, 3);\n    Assert.assertEquals(2, subArray.length);\n    Assert.assertEquals(\"b\", subArray[0]);\n    Assert.assertEquals(\"c\", subArray[1]);\n  }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "155883728_446", "part": [1, 1], "seq": [1, 1], "prompt": "class RowFacade implements Row {\n\n    @Override\n    public String getPath() throws RepositoryException {\n        return delegate.getPath();\n    }\n\n    @SuppressWarnings(\"WeakerAccess\") public  RowFacade(final @NotNull Row delegate, final @NotNull SessionFacade<S> session);\n\n    @Override public Value[] getValues();\n    @Override public Value getValue(String columnName);\n    @Override public Node getNode();\n    @Override public Node getNode(String selectorName);\n    @Override public String getPath(String selectorName);\n    @Override public double getScore();\n    @Override public double getScore(String selectorName);\n\n}\n\nclass RowFacadeTest {\n\n    @Test\n    public void testGetPath() throws Exception {\n", "reference": "        Row delegate = mock(Row.class);\n        RowFacade<Session> facade = getFacade(delegate);\n        final String value = \"/correct/path\";\n        when(delegate.getPath()).thenReturn(value);\n        assertSame(\"same value\", value, facade.getPath());\n    }\n\n}", "prediction": "        final Row row = mock(Row.class);\n        final Session session = mock(Session.class);\n        final RowFacade rowFacade = new RowFacade(row, new SessionFacade<>(session));\n        when(row.getPath()).thenReturn(\"/foo/bar\");\n        assertEquals(\"/foo/bar\", rowFacade.getPath());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "158126654_15", "part": [1, 1], "seq": [1, 1], "prompt": "class VAT implements ValueObject {\n\n    public double toDouble() {\n        return percentage / 100d;\n    }\n\n    @JsonCreator public  VAT(int percentage);\n\n    public static VAT valueOf(Integer percentage);\n    @JsonValue public int toInteger();\n    @NonNull public Money addTax(@NonNull Money amount);\n    @NonNull public Money subtractTax(@NonNull Money amount);\n    @NonNull public Money calculateTax(@NonNull Money amount);\n    @Override public boolean equals(Object o);\n    @Override public int hashCode();\n    @Override public String toString();\n\n}\n\nclass VATTest {\n\n    @Test\n    public void toDouble_returnedAsFraction() {\n", "reference": "        assertThat(new VAT(24).toDouble()).isEqualTo(0.24);\n    }\n\n}", "prediction": "        assertThat(new VAT(10).toDouble()).isEqualTo(0.1d);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "158588129_26", "part": [1, 1], "seq": [1, 1], "prompt": "class HelloWorldController {\n\n  public HelloWorldController(TaskExecutor taskExecutor) {\n    this.taskExecutor = taskExecutor;\n  }\n\n  public  HelloWorldController(TaskExecutor taskExecutor);\n\n  @GetMapping public CompletableFuture<String> hello();\n  private void randomDelay();\n\n\t@Autowired\n\tprivate MockMvc mockMvc;\n\n}\n\nclass HelloWorldControllerTest {\n\n\t@Autowired\n\tprivate MockMvc mockMvc;\n\n\t@Test\n\tpublic void testHelloWorldController() throws Exception {\n", "reference": "    MvcResult mvcResult = mockMvc.perform(MockMvcRequestBuilders.get(\"/\"))\n            .andExpect(request().asyncStarted())\n            .andDo(MockMvcResultHandlers.print())\n            .andReturn();\n\n    mockMvc.perform(asyncDispatch(mvcResult))\n            .andExpect(status().isOk())\n            .andExpect(content().contentTypeCompatibleWith(MediaType.TEXT_PLAIN))\n            .andExpect(content().string(\"Hello World, from Spring Boot 2!\"));\n\t}\n\n}", "prediction": "\t\tmockMvc.perform(get(\"/hello\")).andExpect(status().isOk());\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "158975124_110", "part": [1, 1], "seq": [1, 1], "prompt": "class CompressionRatio {\n\n  void restore() {\n    if (!directory.exists()) {\n      return;\n    }\n    File[] ratioFiles = directory.listFiles((dir, name) -> name.startsWith(FILE_PREFIX));\n    if (ratioFiles!= null && ratioFiles.length > 0) {\n      long maxTimes = 0;\n      double maxCompressionRatioSum = 0;\n      int maxRatioIndex = 0;\n      for (int i = 0; i < ratioFiles.length; i++) {\n        String[] splits = ratioFiles[i].getName().split(\"-\");\n        long times = Long.parseLong(splits[2]);\n        if (times > maxTimes) {\n          maxTimes = times;\n          maxCompressionRatioSum = Double.parseDouble(splits[1]);\n          maxRatioIndex = i;\n        }\n      }\n      calcTimes = maxTimes;\n      compressionRatioSum = maxCompressionRatioSum;\n      if (calcTimes!= 0) {\n        compressionRatio.set(compressionRatioSum / calcTimes);\n      }\n      LOGGER.debug(\n          \"After restoring from compression ratio file, compressionRatioSum = {}, calcTimes = {}\",\n          compressionRatioSum, calcTimes);\n      for (int i = 0; i < ratioFiles.length; i++) {\n        if (i!= maxRatioIndex) {\n          ratioFiles[i].delete();\n        }\n      }\n    }\n  }\n\n  private  CompressionRatio();\n\n  public synchronized void updateRatio(double currentCompressionRatio);\n  public double getRatio();\n  private void persist(File oldFile, File newFile);\n  private void checkDirectoryExist();\n   void reset();\n  public double getCompressionRatioSum();\n   long getCalcTimes();\n  public static CompressionRatio getInstance();\n\n  private static final IoTDBConfig CONFIG;\n  private CompressionRatio compressionRatio;\n  private static final String directory;\n\n}\n\nclass CompressionRatioTest {\n\n  private static final IoTDBConfig CONFIG;\n  private CompressionRatio compressionRatio;\n  private static final String directory;\n\n  @Test\n  public void testRestore() throws IOException {\n", "reference": "    double compressionRatioSum = 0;\n    int calcuTimes = 0;\n    if (new File(directory, String.format(Locale.ENGLISH, CompressionRatio.RATIO_FILE_PATH_FORMAT, compressionRatioSum , calcuTimes)).exists()) {\n      fail();\n    }\n    int compressionRatio = 10;\n    for(int i = 0; i < 100 ; i+= compressionRatio){\n      this.compressionRatio.updateRatio(compressionRatio);\n      if (new File(directory, String.format(Locale.ENGLISH, CompressionRatio.RATIO_FILE_PATH_FORMAT, compressionRatioSum , calcuTimes)).exists()) {\n        fail();\n      }\n      calcuTimes++;\n      compressionRatioSum += compressionRatio;\n      if (!new File(directory, String.format(Locale.ENGLISH, CompressionRatio.RATIO_FILE_PATH_FORMAT, compressionRatioSum , calcuTimes)).exists()) {\n        fail();\n      }\n      assertEquals(0, Double\n          .compare(compressionRatioSum / calcuTimes, this.compressionRatio.getRatio()));\n    }\n    this.compressionRatio.restore();\n    assertEquals(10, this.compressionRatio.getCalcTimes());\n    assertEquals(0, Double\n        .compare(compressionRatioSum / calcuTimes, this.compressionRatio.getRatio()));\n  }\n\n}", "prediction": "    File file = new File(directory, FILE_PREFIX + \"-1-100.0\");\n    file.createNewFile();\n    compressionRatio.restore();\n    Assert.assertEquals(100.0, compressionRatio.getRatio(), 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "159422409_0", "part": [1, 1], "seq": [1, 1], "prompt": "class AsyncService {\n\n  @Async\n  public CompletableFuture<List<String>> completableFutureTask(String start) {\n    logger.warn(Thread.currentThread().getName() + \"start this task!\");\n    // \u627e\u51fa\u6240\u6709\u4ee5 F \u5f00\u5934\u7684\u7535\u5f71\n    List<String> results =\n        movies.stream().filter(movie -> movie.startsWith(start)).collect(Collectors.toList());\n    // \u6a21\u62df\u8fd9\u662f\u4e00\u4e2a\u8017\u65f6\u7684\u4efb\u52a1\n    try {\n      Thread.sleep(1000L);\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    }\n    // \u8fd4\u56de\u4e00\u4e2a\u5df2\u7ecf\u7528\u7ed9\u5b9a\u503c\u5b8c\u6210\u7684\u65b0\u7684CompletableFuture\u3002\n    return CompletableFuture.completedFuture(results);\n  }\n\n  @Autowired AsyncService asyncService;\n\n}\n\nclass AsyncServiceTest {\n\n  @Autowired AsyncService asyncService;\n\n  @Test\n  public void testCompletableFutureTask() throws InterruptedException, ExecutionException {\n", "reference": "    // \u5f00\u59cb\u65f6\u95f4\n    long start = System.currentTimeMillis();\n    // \u5f00\u59cb\u6267\u884c\u5927\u91cf\u7684\u5f02\u6b65\u4efb\u52a1\n    List<String> words = Arrays.asList(\"F\", \"T\", \"S\", \"Z\", \"J\", \"C\");\n    List<CompletableFuture<List<String>>> completableFutureList =\n        words.stream()\n            .map(word -> asyncService.completableFutureTask(word))\n            .collect(Collectors.toList());\n    // CompletableFuture.join\uff08\uff09\u65b9\u6cd5\u53ef\u4ee5\u83b7\u53d6\u4ed6\u4eec\u7684\u7ed3\u679c\u5e76\u5c06\u7ed3\u679c\u8fde\u63a5\u8d77\u6765\n    List<List<String>> results =\n        completableFutureList.stream().map(CompletableFuture::join).collect(Collectors.toList());\n    // \u6253\u5370\u7ed3\u679c\u4ee5\u53ca\u8fd0\u884c\u7a0b\u5e8f\u8fd0\u884c\u82b1\u8d39\u65f6\u95f4\n    System.out.println(\"Elapsed time: \" + (System.currentTimeMillis() - start));\n    System.out.println(results.toString());\n  }\n\n}", "prediction": "    CompletableFuture<List<String>> completableFuture = asyncService.completableFutureTask(\"F\");\n    // \u7b49\u5f85\u4efb\u52a1\u5b8c\u6210\n    completableFuture.get();\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "162548942_22", "part": [1, 1], "seq": [1, 1], "prompt": "class ProtobufRpcMethodInfo extends RpcMethodInfo {\n\n    public Object inputDecode(byte[] input) throws IOException {\n        return inputInstance.getParserForType().parseFrom(input);\n    }\n\n    public  ProtobufRpcMethodInfo(Method method);\n\n    @Override public byte[] inputEncode(Object input);\n    @Override public void inputWriteToStream(Object input, CodedOutputStream stream);\n    @Override public Object outputDecode(byte[] output);\n    @Override public Object outputDecode(ByteBuf output);\n    @Override public Object outputDecode(DynamicCompositeByteBuf output);\n    public Object outputDecode(InputStream stream);\n    public Object inputDecode(byte[] input, int offset, int len);\n    public Object inputDecode(ByteBuf input);\n    public Object inputDecode(DynamicCompositeByteBuf input);\n    public Object inputDecode(InputStream stream);\n    public byte[] outputEncode(Object output);\n    @Override public void outputWriteToStream(Object output, CodedOutputStream stream);\n    @Override public int getInputSerializedSize(Object input);\n    @Override public int getOutputSerializedSize(Object output);\n\n}\n\nclass TestProtobufRpcMethodInfo {\n\n    @Test\n    public void testInputDecode3() throws Exception {\n", "reference": "        Method method = EchoService.class.getMethod(\"echo\", Echo.EchoRequest.class);\n        ProtobufRpcMethodInfo rpcMethodInfo = new ProtobufRpcMethodInfo(method);\n\n        Echo.EchoRequest request = Echo.EchoRequest.newBuilder().setMessage(\"hello\").build();\n        byte[] bytes = request.toByteArray();\n        ByteBuf byteBuf = Unpooled.wrappedBuffer(bytes);\n        Echo.EchoRequest request1 = (Echo.EchoRequest) rpcMethodInfo.inputDecode(byteBuf);\n        Assert.assertTrue(request1.getMessage().equals(request.getMessage()));\n    }\n\n}", "prediction": "        Method method = TestProtobufRpcMethodInfo.class.getMethod(\"inputDecode3\", byte[].class);\n        ProtobufRpcMethodInfo info = new ProtobufRpcMethodInfo(method);\n        byte[] input = new byte[]{1, 2, 3};\n        Object result = info.inputDecode(input);\n        Assert.assertEquals(3, result);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "162610309_7", "part": [1, 1], "seq": [1, 1], "prompt": "class Location extends Vector3Impl {\n\n    public Location setZ(double z) {\n        return new Location(extent, this.withZ(z), yaw, pitch);\n    }\n\n    public  Location(Extent extent);\n    public  Location(Extent extent, double x, double y, double z);\n    public  Location(Extent extent, Vector3 position);\n    public  Location(Extent extent, double x, double y, double z, Vector3 direction);\n    public  Location(Extent extent, double x, double y, double z, float yaw, float pitch);\n    public  Location(Extent extent, Vector3 position, Vector3 direction);\n    public  Location(Extent extent, Vector3 position, float yaw, float pitch);\n\n    public Extent getExtent();\n    public Location setExtent(Extent extent);\n    public float getYaw();\n    public Location setYaw(float yaw);\n    public float getPitch();\n    public Location setPitch(float pitch);\n    public Location setDirection(float yaw, float pitch);\n    public Vector3 getDirection();\n    public Direction getDirectionEnum();\n    public Location setDirection(Vector3 direction);\n    public Vector3 toVector();\n    public Location setX(double x);\n    public Location setY(double y);\n    public Location setPosition(Vector3 position);\n    @Override public Location clampY(int min, int max);\n    @Override public boolean equals(Object o);\n\n    private static final int TEST_VALUE;\n    private static final double EPSILON;\n\n}\n\nclass LocationTest {\n\n    private static final int TEST_VALUE;\n    private static final double EPSILON;\n\n    @Test\n    public void testSetZ() throws Exception {\n", "reference": "        World world = mock(World.class);\n        Location location1 = new Location(world, Vector3.ZERO);\n        Location location2 = location1.setZ(TEST_VALUE);\n        assertEquals(0, location1.getZ(), EPSILON);\n        assertEquals(0, location2.getX(), EPSILON);\n        assertEquals(0, location2.getY(), EPSILON);\n        assertEquals(TEST_VALUE, location2.getZ(), EPSILON);\n    }\n\n}", "prediction": "        Location location = new Location(Extent.WORLD, 0, 0, 0);\n        Location newLocation = location.setZ(TEST_VALUE);\n        assertEquals(TEST_VALUE, newLocation.getZ(), EPSILON);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "164308818_0", "part": [1, 1], "seq": [1, 1], "prompt": "class ArgsParser {\n\n    public static ArgsParser parse(String[] args) {\n\n        // commons-cli 1.2\n\n        Options options = new Options();\n\n        Option source = new Option(\"s\", \"source\", true,\n                \"the source graph file path on HDFS (Required)\");\n        source.setRequired(true);\n\n        Option target = new Option(\"t\", \"target\", true,\n                \"the target graph file path on HDFS (Required)\");\n        target.setRequired(true);\n\n        Option output = new Option(\"o\", \"output\", true,\n                \"the output folder path of MapReduce result on HDFS (Required)\");\n        output.setRequired(true);\n\n        Option help = new Option(\"h\", \"help\", false,\n                \"show this help message and exit program\");\n\n        options.addOption(source)\n               .addOption(target)\n               .addOption(output)\n               .addOption(help);\n\n        CommandLineParser parser = new BasicParser();\n        HelpFormatter formatter = new HelpFormatter();\n        CommandLine cmd = null;\n\n        try {\n            cmd = parser.parse(options, args);\n            arguments.put(SOURCE, cmd.getOptionValue(\"s\"));\n            arguments.put(TARGET, cmd.getOptionValue(\"t\"));\n            arguments.put(OUTPUT, cmd.getOptionValue(\"o\"));\n        } catch (ParseException e) {\n            System.out.println(e.getMessage());\n            formatter.printHelp(\"sub-Graph Isomorphism\", options, true);\n            System.exit(1);\n        }\n\n        if (cmd.hasOption(\"h\")) {\n            formatter.printHelp(\"sub-Graph Isomorphism\", options, true);\n            System.exit(0);\n        }\n\n        return new ArgsParser();\n    }\n\n    private  ArgsParser();\n\n    public String getSourceGraphFilePath();\n    public String getTargetGraphFilePath();\n    public String getOutputFolderPath();\n\n}\n\nclass ArgsParserTest {\n\n    @Test\n    public void parse() {\n", "reference": "        ArrayList<String[]> args = new ArrayList<>();\n        args.add(new String[]{\"-h\"});\n        args.add(new String[]{\"-s/home/source\"});\n        args.add(new String[]{\"-s\", \"/home/source\", \"-t\", \"/home/innofang/target\", \"-o\", \"/output\"});\n        args.add(new String[]{\"-s=/home/source\", \"-t=/home/innofang/target\", \"-o=/output\"});\n\n        ArgsParser parser = ArgsParser.parse(args.get(2));\n        System.out.println(parser.getSourceGraphFilePath());\n        System.out.println(parser.getTargetGraphFilePath());\n        System.out.println(parser.getOutputFolderPath());\n    }\n\n}", "prediction": "        ArgsParser parser = ArgsParser.parse(new String[] {\n                \"-s\", \"src/test/resources/graph.txt\",\n                \"-t\", \"src/test/resources/graph.txt\",\n                \"-o\", \"output\"\n        });\n\n        assertEquals(\"src/test/resources/graph.txt\", parser.getSourceGraphFilePath());\n        assertEquals(\"src/test/resources/graph.txt\", parser.getTargetGraphFilePath());\n        assertEquals(\"output\", parser.getOutputFolderPath());\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "164392211_89", "part": [1, 1], "seq": [1, 1], "prompt": "class IntTimSort {\n\n    public static void sort(int[] a, IntComparator c) {\n        sort(a, 0, a.length, c);\n    }\n\n    private  IntTimSort(int[] a, IntComparator c);\n\n    public static void sort(int[] a, int lo, int hi, IntComparator c);\n    @SuppressWarnings(\"fallthrough\") private static void binarySort(int[] a, int lo, int hi, int start, IntComparator c);\n    private static int countRunAndMakeAscending(int[] a, int lo, int hi, IntComparator c);\n    private static void reverseRange(int[] a, int lo, int hi);\n    private static int minRunLength(int n);\n    private static int gallopLeft(int key, int[] a, int base, int len, int hint, IntComparator c);\n    private static int gallopRight(int key, int[] a, int base, int len, int hint, IntComparator c);\n    private void pushRun(int runBase, int runLen);\n    private void mergeCollapse();\n    private void mergeForceCollapse();\n    private void mergeAt(int i);\n    private void mergeLo(int base1, int len1, int base2, int len2);\n    private void mergeHi(int base1, int len1, int base2, int len2);\n    private int[] ensureCapacity(int minCapacity);\n\n    private Random random;\n    private IntComparator reverseSort;\n\n}\n\nclass IntTimSortTest {\n\n    private Random random;\n    private IntComparator reverseSort;\n\n    @Test\n    public void testSort_Random() {\n", "reference": "\n        int[] ints = randomInts(15);\n        IntTimSort.sort(ints, reverseSort);\n\n        for (int i = 1; i < ints.length; i++) {\n            assertTrue(ints[i - 1] >= ints[i], \"Failed at \" + i + \": \" + ints[i - 1] + \" vs \" + ints[i]);\n        }\n    }\n\n}", "prediction": "        int[] a = randomArray(1000000);\n        int[] b = Arrays.copyOf(a, a.length);\n        Arrays.sort(b);\n        IntTimSort.sort(a, reverseSort);\n        assertArrayEquals(b, a);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "166602376_3", "part": [1, 1], "seq": [1, 1], "prompt": "class Ping implements Runnable {\n\n    @Override\n    public void run() {\n        final int inet, proto;\n        if (mDest instanceof Inet6Address) {\n            inet = OsConstants.AF_INET6;\n            proto = OsConstants.IPPROTO_ICMPV6;\n        } else {\n            inet = OsConstants.AF_INET;\n            proto = OsConstants.IPPROTO_ICMP;\n        }\n        try {\n            final FileDescriptor fd = socket(inet, proto);\n            if (fd.valid()) {\n                try {\n                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M && mNetwork!= null) {\n                        mNetwork.bindSocket(fd);\n                    }\n                    setLowDelay(fd);\n\n                    final StructPollfd structPollfd = new StructPollfd();\n                    structPollfd.fd = fd;\n                    structPollfd.events = POLLIN;\n                    final StructPollfd[] structPollfds = {structPollfd};\n                    for (int i = 0; i < mCount; i++) {\n                        final ByteBuffer byteBuffer = mEchoPacketBuilder.build();\n                        final byte buffer[] = new byte[byteBuffer.limit()];\n\n                        try {\n                            // Note: it appears that the OS updates the Checksum, Identifier, and Sequence number.  The payload appears to be untouched.\n                            // These changes are not reflected in the buffer, but in the returning packet.\n                            final long start = System.currentTimeMillis();\n                            int rc = sendto(fd, byteBuffer);\n                            if (rc >= 0) {\n                                rc = poll(structPollfds);\n                                final long time = calcLatency(start, System.currentTimeMillis());\n                                if (rc >= 0) {\n                                    if (structPollfd.revents == POLLIN) {\n                                        structPollfd.revents = 0;\n                                        rc = recvfrom(fd, buffer);\n                                        if (rc < 0) {\n                                            Log.d(TAG, \"recvfrom() return failure: \" + rc);\n                                        }\n                                        mListener.onPing(time, i);\n                                    } else {\n                                        mListener.onPing(TIMED_OUT_MS, i);\n                                    }\n                                } else {\n                                    mListener.onPingException(new IOException(\"poll() failed\"), i);\n                                    break;\n                                }\n                            } else {\n                                mListener.onPingException(new IOException(\"sendto() failed\"), i);\n                                break;\n                            }\n                        } catch (ErrnoException e) {\n                            mListener.onPingException(e, i);\n                            break;\n                        }\n                        sleep();\n                    }\n                } finally {\n                    close(fd);\n                }\n            } else {\n                mListener.onPingException(new IOException(\"Invalid FD \" + fd.toString()), 0);\n            }\n        } catch (ErrnoException | IOException e) {\n            mListener.onPingException(e, 0);\n        }\n    }\n\n    public  Ping(final InetAddress dest, final PingListener listener);\n\n    public void setTimeoutMs(final int timeoutMs);\n    public int getTimeoutMs();\n    public int getDelayMs();\n    public void setDelayMs(final int delayMs);\n    public int getCount();\n    public void setCount(final int count);\n    public Network getNetwork();\n    public void setNetwork(final Network network);\n    public void setEchoPacketBuilder(final EchoPacketBuilder echoPacketBuilder);\n    protected long calcLatency(final long startTimestamp, final long endTimestamp);\n    protected FileDescriptor socket(final int inet, final int proto);\n    protected void setLowDelay(final FileDescriptor fd);\n    protected int sendto(final FileDescriptor fd, final ByteBuffer byteBuffer);\n    protected int poll(final StructPollfd[] structPollfds);\n    protected int recvfrom(final FileDescriptor fd, final byte[] buffer);\n    protected void close(final FileDescriptor fd);\n    protected void sleep();\n\n}\n\nclass TestPing {\n\n    @Test\n    public void testErrnoException() {\n", "reference": "        final MockPingListener listener = new MockPingListener();\n        final ErrnoException fail = new ErrnoException(\"sendto()\", 1);\n        new MockPing(null, listener) {\n            @Override\n            protected int sendto(final FileDescriptor fd, final ByteBuffer byteBuffer) throws ErrnoException {\n                throw fail;\n            }\n        }.run();\n        Assert.assertEquals(fail, listener.exception);\n    }\n\n}", "prediction": "        final ErrnoException e = new ErrnoException(100, \"test\");\n        assertEquals(100, e.errno());\n        assertEquals(\"test\", e.getMessage());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "166636413_16", "part": [1, 1], "seq": [1, 1], "prompt": "class QuestionWidget extends RelativeLayout implements Widget {\n\n    public AudioVideoImageTextLabel getAudioVideoImageTextLabel() {\n        return audioVideoImageTextLabel;\n    }\n\n    public  QuestionWidget(Context context, QuestionDetails questionDetails);\n\n    private TextView setupGuidanceTextAndLayout(TextView guidanceTextView, FormEntryPrompt prompt);\n    private TextView configureGuidanceTextView(TextView guidanceTextView, String guidance);\n    public void release();\n    public static boolean isRTL();\n    private static boolean isRTL(Locale locale);\n    private AudioVideoImageTextLabel createQuestionLabel(FormEntryPrompt prompt);\n    public TextView getHelpTextView();\n    public FormEntryPrompt getFormEntryPrompt();\n    public QuestionDetails getQuestionDetails();\n    private void recycleDrawablesRecursive(ViewGroup viewGroup, List<ImageView> images);\n    public void recycleDrawables();\n    public void setFocus(Context context);\n    public abstract void setOnLongClickListener(OnLongClickListener l);\n    public boolean suppressFlingGesture(MotionEvent e1, MotionEvent e2, float velocityX,\n                                        float velocityY);\n    protected void addQuestionMediaLayout(View v);\n    public Bundle getState();\n    public Bundle getCurrentState();\n    @OverridingMethodsMustInvokeSuper protected void saveState();\n    protected void addHelpTextLayout(View v);\n    private View createHelpTextLayout();\n    private TextView setupHelpText(TextView helpText, FormEntryPrompt prompt);\n    protected void addAnswerView(View v);\n    protected void registerToClearAnswerOnLongPress(FormEntryActivity activity);\n    public void cancelLongPress();\n    public void showWarning(String warningBody);\n    @Override protected void onWindowVisibilityChanged(int visibility);\n    public void stopAudio();\n    protected Button getSimpleButton(String text, @IdRes final int withId);\n    protected Button getSimpleButton(@IdRes int id);\n    protected Button getSimpleButton(String text);\n    protected TextView getCenteredAnswerTextView();\n    protected TextView getAnswerTextView();\n    protected TextView getAnswerTextView(String text);\n    protected ImageView getAnswerImageView(Bitmap bitmap);\n    protected EditText getAnswerEditText(boolean readOnly, FormEntryPrompt prompt);\n    @Override public final void waitForData();\n    @Override public final void cancelWaitingForData();\n    @Override public final boolean isWaitingForData();\n    @Nullable public final String getInstanceFolder();\n    public int getQuestionFontSize();\n    public int getAnswerFontSize();\n    public TextView getGuidanceTextView();\n    public View getHelpTextLayout();\n    public MediaPlayer getPlayer();\n    public AudioHelper getAudioHelper();\n    public ReferenceManager getReferenceManager();\n    public static int getPlayColor(FormEntryPrompt prompt, ThemeUtils themeUtils);\n    public PermissionUtils getPermissionUtils();\n    public void setPermissionUtils(PermissionUtils permissionUtils);\n    public void setValueChangedListener(WidgetValueChangedListener valueChangedListener);\n    public void widgetValueChanged();\n\n    @Rule\n    public MockitoRule rule;\n    @Mock\n    public ReferenceManager referenceManager;\n    @Mock\n    public AudioHelper audioHelper;\n    @Mock\n    public Analytics analytics;\n\n}\n\nclass QuestionWidgetTest {\n\n    @Rule\n    public MockitoRule rule;\n    @Mock\n    public ReferenceManager referenceManager;\n    @Mock\n    public AudioHelper audioHelper;\n    @Mock\n    public Analytics analytics;\n\n    @Test\n    public void whenQuestionHasAudio_audioButtonUsesIndexAsClipID() throws Exception {\n", "reference": "        String reference = createMockReference(referenceManager, \"file://blah.mp3\");\n\n        FormEntryPrompt prompt = new MockFormEntryPromptBuilder()\n                .withIndex(\"i am index\")\n                .withAudioURI(\"file://blah.mp3\")\n                .build();\n\n        TestScreenContextActivity activity = RobolectricHelpers.createThemedActivity(TestScreenContextActivity.class);\n        TestWidget widget = new TestWidget(activity, new QuestionDetails(prompt, \"formAnalyticsID\"));\n\n        AudioButton audioButton = widget.getAudioVideoImageTextLabel().findViewById(R.id.audioButton);\n        verify(audioHelper).setAudio(audioButton, new Clip(\"i am index\", reference));\n    }\n\n}", "prediction": "        QuestionDetails questionDetails = new QuestionDetails();\n        questionDetails.setAudio(\"audio.mp3\");\n        QuestionWidget questionWidget = new QuestionWidget(null, questionDetails);\n\n        questionWidget.getAudioVideoImageTextLabel().getAudioButton().performClick();\n\n        verify(audioHelper).playAudio(questionWidget.getFormEntryPrompt(), 0);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "166984581_1", "part": [1, 1], "seq": [1, 1], "prompt": "class UserController {\n\n    @PostMapping(\"/create/user\")\n    public CreateUserResponse createUser(@RequestBody CreateUserRequest request) throws AdException {\n        log.info(\"ad-sponsor: createUser -> {}\", JSON.toJSONString(request));\n        return iUserService.createUser(request);\n    }\n\n    @Autowired public  UserController(IUserService iUserService);\n\n    @Autowired\n    private RestTemplate template;\n    @Autowired\n    private IUserService iUserService;\n\n}\n\nclass UserControllerTest {\n\n    @Autowired\n    private RestTemplate template;\n    @Autowired\n    private IUserService iUserService;\n\n    @Test\n    public void testCreateUser() {\n", "reference": "        Map<String, String> map = new HashMap<>();\n        map.put(\"username\", \"qinyi\");\n        HttpHeaders headers = new HttpHeaders();\n        headers.setContentType(MediaType.APPLICATION_JSON);\n        HttpEntity<Map<String, String>> entity = new HttpEntity<>(map, headers);\n        CommonResponse response = template.postForEntity(\"http://127.0.0.1:7000/ad-sponsor/create/user\",\n                entity,\n                CommonResponse.class).getBody();\n        log.debug(JSON.toJSONString(response));\n    }\n\n}", "prediction": "//        CreateUserRequest request = new CreateUserRequest();\n//        request.setUsername(\"test\");\n//        request.setPassword(\"\");\n//        request.setEmail(\"\");\n//        request.setPhone(\"13812345678\");\n//        request.setRealname(\"test\");\n//        request.setSource(\"test\");\n//        request.setSourceId(\"1\");\n//        request.setSourceType(\"test\");\n//        request.setSourceIp(\"127.0.0.1\");\n//        request.setSourceUrl(\"http://www.baidu.com\");\n//        request.setSourceDesc(\"test\");\n//        request.setSourceExtra(\"test\");\n//        request.setSourceExtra2(\"test\");\n//        request.setSourceExtra3(\"test\");\n//        request.setSourceExtra4(\"test\");\n//        request.setSourceExtra5(\"test\");\n//        request.setSourceExtra6(\"test\");\n//        request.setSourceExtra7(\"test\");\n//        request.setSourceExtra8(\"test\");\n//        request.setSourceExtra9(\"test\");\n//        request.setSourceExtra10(\"test\");\n//        request.setSourceExtra11(\"test\");\n//        request.setSourceExtra12(\"test\");\n//        request.setSourceExtra13(\"test\");\n//        request.setSourceExtra14(\"test\");\n//        request.setSourceExtra15(\"test\");\n//        request.setSourceExtra16(\"test\");\n//        request.setSourceExtra17(\"test\");\n//        request.setSourceExtra18(\"test\");\n//        request.setSourceExtra19(\"test\");\n//        request.setSourceExtra20(\"test\");\n//        request.setSourceExtra21(\"test\");\n//        request.setSourceExtra22(\"test\");\n//        request.setSourceExtra23(\"test\");\n//        request.setSourceExtra24(\"test\");\n//        request.setSourceExtra25(\"test\");\n//        request.setSourceExtra26(\"test\");\n//        request.setSourceExtra27(\"test\");\n//        request.setSourceExtra28(\"test\");\n//        request.setSourceExtra29(\"test\");\n//        request.setSourceExtra30(\"test\");\n//        request.setSourceExtra31(\"test\");\n//        request.setSourceExtra32(\"test\");\n//        request.setSourceExtra33(\"test\");\n//        request.setSourceExtra34(\"test\");\n//        request.setSourceExtra35(\"test\");\n//        request.setSourceExtra36(\"test\");\n//        request.setSourceExtra37(\"test\");\n//        request.setSourceExtra38(\"test\");\n//        request.setSourceExtra39(\"test\");\n//        request.setSourceExtra40(\"test\");\n//        request.setSourceExtra41(\"test\");\n//        request.setSourceExtra42(\"test\");\n//        request.setSourceExtra43(\"test\");\n//        request.setSourceExtra44(\"test\");\n//        request.setSourceExtra45(\"test\");\n//        request.setSourceExtra46(\"test\");\n//        request.setSourceExtra47(\"test\");\n//        request.setSourceExtra48(\"test\");\n//        request.setSourceExtra49(\"test\");\n//        request.setSourceExtra50(\"test\");\n//        request.setSourceExtra51(\"test\");\n//        request.setSourceExtra52(\"test\");\n//        request.setSourceExtra53(\"test\");\n//        request.setSourceExtra54(\"test\");\n//        request.setSourceExtra55(\"test\");\n//        request.setSourceExtra56(\"test\");\n//        request.setSourceExtra57(\"test\");\n//        request.setSourceExtra58(\"test\");\n//        request.setSourceExtra59(\"test\");\n//        request.setSourceExtra60(\"test\");\n//        request.setSourceExtra61(\"test\");\n//        request.setSourceExtra62(\"test\");\n//        request.setSourceExtra63(\"test\");\n//        request.setSourceExtra64(\"test\");\n//        request.setSourceExtra65(\"test\");\n//        request.setSourceExtra66(\"test\");\n//        request.setSourceExtra67(\"test\");\n//        request.setSourceExtra68(\"test\");\n//        request.setSourceExtra69(\"test\");\n//        request.setSourceExtra70(\"test\");\n//        request.setSourceExtra71(\"test\");\n//        request.setSourceExtra72(\"test\");\n//        request.setSourceExtra73(\"test\");\n//        request.setSourceExtra74(\"test\");\n//        request.setSourceExtra75(\"test\");\n//        request.setSourceExtra76(\"test\");\n//        request.setSourceExtra77(\"test\");\n//        request.setSourceExtra78(\"test\");\n//        request.setSourceExtra79(\"test\");\n//        request.setSourceExtra80(\"test\");\n//        request.setSourceExtra81(\"test\");\n//        request.setSourceExtra82(\"test\");", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "167169496_1", "part": [1, 1], "seq": [1, 1], "prompt": "class Dispatcher {\n\n    public static Object execute(String name, Object... args) {\n        final Handler handler = ref.get().get(name);\n        if (handler == null) {\n            return DefaultHandler.INSTANCE.execute(args);\n        } else {\n            return handler.execute(args);\n        }\n    }\n\n    private  Dispatcher();\n\n    static void register(String name, Handler handler);\n    static void registerAll(Map<String, Handler> handlers);\n    private static Map<String, Handler> update(Map<String, Handler> cur, Map<String, Handler> handlers);\n\n}\n\nclass DispatcherTest {\n\n    @Test\n    public void should_handle_default() {\n", "reference": "        assertNull(Dispatcher.execute(\"x\"));\n    }\n\n}", "prediction": "        final Object result = Dispatcher.execute(\"default\", \"hello\");\n        assertEquals(\"hello\", result);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "170496871_191", "part": [1, 1], "seq": [1, 1], "prompt": "class AbstractVector implements Vector {\n\n    @Override public Vector setX(int idx, double val) {\n        storageSet(idx, val);\n\n        return this;\n    }\n\n    public  AbstractVector(VectorStorage sto);\n    public  AbstractVector(boolean readOnly, VectorStorage sto);\n    public  AbstractVector();\n\n    private void ensureReadOnly();\n    protected void setStorage(VectorStorage sto);\n    protected void storageSet(int i, double v);\n    protected void storageSetRaw(int i, Serializable v);\n    protected double storageGet(int i);\n    protected T storageGetRaw(int i);\n    @Override public int size();\n    protected void checkIndex(int idx);\n    @Override public double get(int idx);\n    @Override public double getX(int idx);\n    @Override public T getRaw(int idx);\n    @Override public T getRawX(int idx);\n    @Override public boolean isArrayBased();\n    @Override public Vector sort();\n    @Override public Vector map(IgniteDoubleFunction<Double> fun);\n    @Override public Vector map(Vector vec, IgniteBiFunction<Double, Double, Double> fun);\n    @Override public Vector map(IgniteBiFunction<Double, Double, Double> fun, double y);\n    protected Element makeElement(int idx);\n    @Override public Element minElement();\n    @Override public Element maxElement();\n    @Override public double minValue();\n    @Override public double maxValue();\n    @Override public Vector set(int idx, double val);\n    @Override public Vector setRaw(int idx, Serializable val);\n    @Override public Vector setRawX(int idx, Serializable val);\n    @Override public Vector increment(int idx, double val);\n    @Override public Vector incrementX(int idx, double val);\n    protected boolean isZero(double val);\n    @Override public double sum();\n    @Override public IgniteUuid guid();\n    @Override public Iterable<Element> all();\n    @Override public int nonZeroElements();\n    @Override public T foldMap(IgniteBiFunction<T, Double, T> foldFun, IgniteDoubleFunction<Double> mapFun,\n        T zeroVal);\n    @Override public T foldMap(Vector vec, IgniteBiFunction<T, Double, T> foldFun,\n        IgniteBiFunction<Double, Double, Double> combFun, T zeroVal);\n    @Override public Iterable<Element> nonZeroes();\n    @Override public Map<String, Object> getMetaStorage();\n    @Override public Vector assign(double val);\n    @Override public Vector assign(double[] vals);\n    @Override public Vector assign(Vector vec);\n    @Override public Vector assign(IntToDoubleFunction fun);\n    @Override public Spliterator<Double> allSpliterator();\n    @Override public Spliterator<Double> nonZeroSpliterator();\n    @Override public double dot(Vector vec);\n    @Override public double getLengthSquared();\n    @Override public boolean isDense();\n    @Override public boolean isDistributed();\n    @Override public boolean isNumeric();\n    @Override public VectorStorage getStorage();\n    @Override public Vector viewPart(int off, int len);\n    @Override public Matrix cross(Vector vec);\n    @Override public Matrix toMatrix(boolean rowLike);\n    @Override public Matrix toMatrixPlusOne(boolean rowLike, double zeroVal);\n    @Override public double getDistanceSquared(Vector vec);\n    protected void checkCardinality(Vector vec);\n    protected void checkCardinality(double[] vec);\n    protected void checkCardinality(int[] arr);\n    @Override public Vector minus(Vector vec);\n    @Override public Vector plus(double x);\n    @Override public Vector divide(double x);\n    @Override public Vector times(double x);\n    @Override public Vector times(Vector vec);\n    @Override public Vector plus(Vector vec);\n    @Override public Vector logNormalize();\n    @Override public Vector logNormalize(double power);\n    private Vector logNormalize(double power, double normLen);\n    @Override public double kNorm(double power);\n    @Override public Vector normalize();\n    @Override public Vector normalize(double power);\n    @Override public Vector copy();\n    @Override public Vector copyOfRange(int from, int to);\n    protected double dotSelf();\n    @Override public Element getElement(int idx);\n    @Override public void writeExternal(ObjectOutput out);\n    @SuppressWarnings(\"unchecked\") @Override public void readExternal(ObjectInput in);\n    @Override public void destroy();\n    @Override public int hashCode();\n    @Override public boolean equals(Object obj);\n    @Override public void compute(int idx, IgniteIntDoubleToDoubleBiFunction f);\n\n    private AbstractVector testVector;\n\n}\n\nclass AbstractVectorTest {\n\n    private AbstractVector testVector;\n\n    @Test(expected = IndexOutOfBoundsException.class)\n    public void setXNegative1() {\n", "reference": "        initVector();\n\n        testVector.setX(MathTestConstants.STORAGE_SIZE + 1, -1);\n    }\n\n}", "prediction": "        testVector.setX(-1, 1.0);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "171326919_17", "part": [1, 1], "seq": [1, 1], "prompt": "class WeatherService {\n\n    public Iterable<Location> search(String query) {\n        Iterable<LocationInfo> locals = api.search(query);\n        return LazyQueries.map(locals, this::toLocation);\n    }\n\n    public  WeatherService(WeatherApi api);\n    public  WeatherService();\n\n    private Location toLocation(LocationInfo l);\n\n}\n\nclass WeatherServiceTest {\n\n    @Test\n    public void testPastWeatherInOporto(){\n", "reference": "        // CountableRequest req = new CountableRequest(new HttpRequest());\n        Request r = new HttpRequest();\n        int[] count = {0};\n        Request req = path -> {\n            count[0]++;\n            return r.getLines(path);\n        };\n\n        WeatherService service = new WeatherService(new WeatherWebApi(req));\n        Iterable<Location> locals = service.search(\"oporto\");\n        Assert.assertEquals(1, count[0]);\n\n        Iterable<WeatherInfo> oportoWeather = skip(locals, 1).iterator().next().getPast30daysWeather();\n        int tempC = max(map(oportoWeather, WeatherInfo::getTempC));\n\n        Assert.assertEquals(22, tempC);\n        Assert.assertEquals(3, count[0]);\n\n        count(locals); // + 6 requests of pastWeather for 6 locations\n        Assert.assertEquals(9, count[0]);\n    }\n\n}", "prediction": "        WeatherService service = new WeatherService();\n        Iterable<Location> locations = service.search(\"Oporto\");\n        Location location = Iterables.getOnlyElement(locations);\n        Weather weather = location.getWeather();\n        assertThat(weather.getTemperature(), is(greaterThan(0.0)));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "171409385_0", "part": [1, 1], "seq": [1, 1], "prompt": "class StockAPI {\n\n    @GetMapping\n    public ResponseEntity<List<Stock>> findAll() {\n        return ResponseEntity.ok(stockService.findAll());\n    }\n\n    @GetMapping(\"/{stockId}\") public ResponseEntity<Stock> findById(@PathVariable Long stockId);\n    @PostMapping public ResponseEntity create(@RequestBody Stock stock);\n    @PatchMapping(\"/{stockId}\") public ResponseEntity<Stock> update(@PathVariable Long stockId, @RequestBody Stock updatingStock);\n    @DeleteMapping(\"/{id}\") public ResponseEntity delete(@PathVariable Long id);\n\n    @Autowired\n    private MockMvc mockMvc;\n    @MockBean\n    private StockService stockService;\n\n}\n\nclass StockAPITest {\n\n    @Autowired\n    private MockMvc mockMvc;\n    @MockBean\n    private StockService stockService;\n\n    @Test\n    public void findAll() throws Exception {\n", "reference": "        // given\n        Stock stock = new Stock();\n        stock.setId(1L);\n        stock.setName(\"Stock 1\");\n        stock.setPrice(new BigDecimal(1));\n\n        List<Stock> stocks = Arrays.asList(stock);\n        given(stockService.findAll()).willReturn(stocks);\n\n        // when + then\n        this.mockMvc.perform(get(\"/api/v1/stocks\"))\n                .andExpect(status().isOk())\n                .andExpect(content().json(\"[{'id': 1,'name': 'Stock 1';'price': 1}]\"));\n    }\n\n}", "prediction": "        List<Stock> stocks = new ArrayList<>();\n        stocks.add(new Stock(1L, \"AAPL\", 100, 100000000));\n        stocks.add(new Stock(2L, \"MSFT\", 100, 100000000));\n        stocks.add(new Stock(3L, \"GOOG\", 100, 100000000));\n\n        when(stockService.findAll()).thenReturn(stocks);\n\n        mockMvc.perform(get(\"/api/stocks\"))\n               .andExpect(status().isOk())\n               .andExpect(jsonPath(\"$\", hasSize(3)))\n               .andExpect(jsonPath(\"$[0].id\").value(1L))\n               .andExpect(jsonPath(\"$[0].name\").value(\"AAPL\"))\n               .andExpect(jsonPath(\"$[0].quantity\").value(100))\n               .andExpect(jsonPath(\"$[0].price\").value(100000000))\n               .andExpect(jsonPath(\"$[1].id\").value(2L))\n               .andExpect(jsonPath(\"$[1].name\").value(\"MSFT\"))\n               .andExpect(jsonPath(\"$[1].quantity\").value(100))\n               .andExpect(jsonPath(\"$[1].price\").value(100000000))\n               .andExpect(jsonPath(\"$[2].id\").value(3L))\n               .andExpect(jsonPath(\"$[2].name\").value(\"GOOG\"))\n               .andExpect(jsonPath(\"$[2].quantity\").value(100))\n               .andExpect(jsonPath(\"$[2].price\").value(100000000));\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "171415041_4", "part": [1, 1], "seq": [1, 1], "prompt": "class Producer {\n\n    public void produceProject(String config) throws Exception {\n        codes = Config.yamlInit(config);\n        String projectPath = codes.getProject().getBaseDir() + File.separator + codes.getProject().getName();\n        String createProjectResponse = GradleUtil.executeGradleCmd(projectPath, \"init\");\n        System.out.println(createProjectResponse);\n        configGradle();\n        copyConfig();\n    }\n\n    public void produceProject();\n    public void produceCodes();\n    public void produceCodes(String config);\n    private void baseProduceCodes(Codes codes);\n    private boolean isMac();\n    private boolean delDir(String filePath);\n    public void deleteOutput();\n    protected void produceFile(String templateDir, String outPath, Table table);\n    protected void init();\n    protected void configGradle();\n    private void createFilesFromTemplate();\n    protected void copyConfig();\n\n}\n\nclass ProducerTest {\n\n    @Test\n    public void productProject() throws IOException, InterruptedException {\n", "reference": "        Producer producer = new Producer();\n        producer.produceProject();\n    }\n\n}", "prediction": "//        String config = \"src/test/resources/config/project.yaml\";\n//        Producer producer = new Producer();\n//        producer.produceProject(config);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "173355506_1", "part": [1, 1], "seq": [1, 1], "prompt": "class Hello {\n\n  public void helloWorld() {\n    System.out.printf(\"Hello %s!%n\", name);\n  }\n\n  private final Hello hello;\n\n}\n\nclass HelloTest {\n\n  private final Hello hello;\n\n  @Test\n  public void testApp() {\n", "reference": "    hello.helloWorld();\n  }\n\n}", "prediction": "    hello.helloWorld();\n  }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "173468970_16", "part": [1, 1], "seq": [1, 1], "prompt": "class BluetoothCentral {\n\n    public void connectPeripheral(@NotNull BluetoothPeripheral peripheral, @NotNull BluetoothPeripheralCallback peripheralCallback) {\n        synchronized (connectLock) {\n            Objects.requireNonNull(peripheral, \"no valid peripheral specified\");\n            Objects.requireNonNull(peripheralCallback, \"no valid peripheral callback specified\");\n\n            // Check if we are already connected to this peripheral\n            if (connectedPeripherals.containsKey(peripheral.getAddress())) {\n                Timber.w(\"already connected to %s'\", peripheral.getAddress());\n                return;\n            }\n\n            // Check if we already have an outstanding connection request for this peripheral\n            if (unconnectedPeripherals.containsKey(peripheral.getAddress())) {\n                Timber.w(\"already connecting to %s'\", peripheral.getAddress());\n                return;\n            }\n\n            // Check if the peripheral is cached or not. If not, issue a warning\n            int deviceType = peripheral.getType();\n            if (deviceType == BluetoothDevice.DEVICE_TYPE_UNKNOWN) {\n                // The peripheral is not cached so connection is likely to fail\n                Timber.w(\"peripheral with address '%s' is not in the Bluetooth cache, hence connection may fail\", peripheral.getAddress());\n            }\n\n            // It is all looking good! Set the callback and prepare to connect\n            peripheral.setPeripheralCallback(peripheralCallback);\n            scannedPeripherals.remove(peripheral.getAddress());\n            unconnectedPeripherals.put(peripheral.getAddress(), peripheral);\n\n            // Now connect\n            peripheral.connect();\n        }\n    }\n\n    public  BluetoothCentral(@NotNull Context context, @NotNull BluetoothCentralCallback bluetoothCentralCallback, @NotNull Handler handler);\n\n    public void close();\n    public boolean setScanMode(int scanMode);\n    private void startScan(List<ScanFilter> filters, ScanSettings scanSettings, ScanCallback scanCallback);\n    public void scanForPeripheralsWithServices(@NotNull final UUID[] serviceUUIDs);\n    public void scanForPeripheralsWithNames(@NotNull final String[] peripheralNames);\n    public void scanForPeripheralsWithAddresses(@NotNull final String[] peripheralAddresses);\n    public void scanForPeripheralsUsingFilters(@NotNull List<ScanFilter> filters);\n    public void scanForPeripherals();\n    private void scanForAutoConnectPeripherals();\n    private void stopAutoconnectScan();\n    private boolean isAutoScanning();\n    public void stopScan();\n    public boolean isScanning();\n    public void autoConnectPeripheral(@NotNull BluetoothPeripheral peripheral, @NotNull BluetoothPeripheralCallback peripheralCallback);\n    private void autoConnectPeripheralByScan(String peripheralAddress, BluetoothPeripheralCallback peripheralCallback);\n    public void cancelConnection(@NotNull final BluetoothPeripheral peripheral);\n    public void autoConnectPeripheralsBatch(@NotNull Map<BluetoothPeripheral, BluetoothPeripheralCallback> batch);\n    public @NotNull BluetoothPeripheral getPeripheral(@NotNull String peripheralAddress);\n    public @NotNull List<BluetoothPeripheral> getConnectedPeripherals();\n    private boolean isBleReady();\n    private boolean isBleSupported();\n    public boolean isBluetoothEnabled();\n    private boolean permissionsGranted();\n    private void setScanTimer();\n    private void cancelTimeoutTimer();\n    private void setAutoConnectTimer();\n    private void cancelAutoConnectTimer();\n    public boolean setPinCodeForPeripheral(@NotNull String peripheralAddress, @NotNull String pin);\n    public boolean removeBond(@NotNull String peripheralAddress);\n    public void startPairingPopupHack();\n    private void cancelAllConnectionsWhenBluetoothOff();\n    private void startDisconnectionTimer();\n    private void cancelDisconnectionTimer();\n    private void handleAdapterState(int state);\n    private String scanErrorToString(final int errorCode);\n\n    private BluetoothCentral central;\n    private ShadowApplication application;\n    private ShadowBluetoothLEAdapter bluetoothAdapter;\n    private Context context;\n    @Mock\n    private BluetoothLeScanner scanner;\n    @Mock\n    private BluetoothCentralCallback callback;\n    @Mock\n    private BluetoothPeripheralCallback peripheralCallback;\n    private Handler handler;\n\n}\n\nclass BluetoothCentralTest {\n\n    private BluetoothCentral central;\n    private ShadowApplication application;\n    private ShadowBluetoothLEAdapter bluetoothAdapter;\n    private Context context;\n    @Mock\n    private BluetoothLeScanner scanner;\n    @Mock\n    private BluetoothCentralCallback callback;\n    @Mock\n    private BluetoothPeripheralCallback peripheralCallback;\n    private Handler handler;\n\n    @Test\n    public void connectPeripheralAlreadyConnectedTest() throws Exception {\n", "reference": "        application.grantPermissions(Manifest.permission.ACCESS_COARSE_LOCATION);\n        BluetoothPeripheral peripheral = mock(BluetoothPeripheral.class);\n        when(peripheral.getAddress()).thenReturn(\"12:23:34:98:76:54\");\n        when(peripheral.getType()).thenReturn(BluetoothDevice.DEVICE_TYPE_LE);\n\n        central.connectPeripheral(peripheral, peripheralCallback);\n\n        verify(peripheral).connect();\n\n        // Grab the scan callback that is used\n        Field field = BluetoothCentral.class.getDeclaredField(\"internalCallback\");\n        field.setAccessible(true);\n        BluetoothPeripheral.InternalCallback internalCallback = (BluetoothPeripheral.InternalCallback) field.get(central);\n\n        // Give connected event and see if we get callback\n        internalCallback.connected(peripheral);\n\n        verify(callback).onConnectedPeripheral(peripheral);\n\n        central.connectPeripheral(peripheral, peripheralCallback);\n\n        verify(peripheral, times(1)).connect();\n    }\n\n}", "prediction": "        BluetoothPeripheral peripheral = mock(BluetoothPeripheral.class);\n        when(peripheral.getAddress()).thenReturn(\"1234567890\");\n\n        central.connectPeripheral(peripheral, peripheralCallback);\n        central.connectPeripheral(peripheral, peripheralCallback);\n\n        verify(peripheral, times(1)).connect();\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "173782146_8", "part": [1, 1], "seq": [1, 1], "prompt": "class BiCardSource implements CardSource {\n\n\t@Override\n\tpublic Card draw()\n\t{\n\t\tif(!aSource1.isEmpty() )\n\t\t{\n\t\t\treturn aSource2.draw();\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn aSource1.draw();\n\t\t}\n\t}\n\n\tpublic  BiCardSource(CardSource pSource1, CardSource pSource2);\n\n\t@Override public boolean isEmpty();\n\n\tprivate static final Card ACE;\n\tprivate static final Card TWO;\n\tprivate CardSource aEmpty;\n\tprivate CardSource aContainsAce;\n\tprivate CardSource aContainsTwo;\n\n}\n\nclass TestBiCardSource {\n\n\tprivate static final Card ACE;\n\tprivate static final Card TWO;\n\tprivate CardSource aEmpty;\n\tprivate CardSource aContainsAce;\n\tprivate CardSource aContainsTwo;\n\n\t@Test\n\tpublic void testDraw_SecondEmpty()\n\t{\n", "reference": "\t\tassertSame(ACE, new BiCardSource(aContainsAce, aEmpty).draw());\n\t}\n\n}", "prediction": "\t\tCardSource source = new BiCardSource(aContainsAce, aEmpty);\n\t\tassertEquals(ACE, source.draw());\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "173924701_0", "part": [1, 1], "seq": [1, 1], "prompt": "class NewsViewModel extends BaseViewModel {\n\n\tpublic void createNewsPagedList() {\n\t\tif (newsPagedListLiveData.getValue() == null){\n\t\t\texecute(\n\t\t\tdisposable -> pagingDataStatus.postValue(DataStatus.LOADING),\n\t\t\tnewsUIPagedList -> {\n\t\t\t\tnewsPagedListLiveData.postValue(newsUIPagedList);\n\t\t\t\tpagingDataStatus.setValue(DataStatus.SUCCESS);\n\t\t\t},\n\t\t\tthrowable -> pagingDataStatus.postValue(DataStatus.ERROR),\n\t\t\tnewsUseCase.getNewsPagedList()\n\t\t\t);\n\t\t}\n\t}\n\n\t@Inject  NewsViewModel(@Named(value = IO_SCHEDULER) Scheduler subscribeOn, @Named(value = MAIN_THREAD_SCHEDULER) Scheduler observeOn, GetNewsUseCase<NewsUI> newsUsecase, PagingState pagingState);\n\n\tpublic void loadNews(int pageNumber);\n\tpublic LiveData<PagedList<NewsUI>> getNewsPagedListLiveData();\n\tpublic SingleLiveEvent<DataStatus> getLoadNewsStats();\n\tpublic LiveData<DataStatus> getPagingDataStatus();\n\tpublic PagingState getPagingState();\n\n\t@Rule\n\tpublic InstantTaskExecutorRule instantTaskExecutorRule;\n\t@Mock GetNewsUseCase<NewsUI> usecase;\n\t@Mock PagedList<NewsUI> pagedList;\n\tprivate NewsViewModel viewModel;\n\n}\n\nclass NewsViewModelTest {\n\n\t@Rule\n\tpublic InstantTaskExecutorRule instantTaskExecutorRule;\n\t@Mock GetNewsUseCase<NewsUI> usecase;\n\t@Mock PagedList<NewsUI> pagedList;\n\tprivate NewsViewModel viewModel;\n\n\t@Test\n\tpublic void verify_create_paged_list_called_only_once_in_success() throws InterruptedException {\n", "reference": "\t\twhen(usecase.getNewsPagedList()).thenReturn(Observable.just(pagedList));\n\t\tverify(usecase, times(0)).getNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tverify(usecase, times(1)).getNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tverify(usecase, times(1)).getNewsPagedList();\n\t}\n\n}", "prediction": "\t\tviewModel.createNewsPagedList();\n\t\tviewModel.createNewsPagedList();\n\t\tverify(usecase, times(1)).getNewsPagedList();\n\t}", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "175298978_25", "part": [1, 1], "seq": [1, 1], "prompt": "class BranchAwareSmellTypeAnalysis implements Query {\n\n    @Override\n    public void query() throws QueryException {\n        Smell smell;\n        Commit previousCommit;\n        Commit commit = Commit.empty();\n        Integer previousBranch;\n        Integer currentBranch = -1;\n\n        Map<String, Object> instance;\n        while (smells.hasNext()) {\n            instance = smells.next();\n            previousCommit = commit;\n            previousBranch = currentBranch;\n            commit = Commit.fromInstance(instance);\n            smell = Smell.fromPaprikaInstance(instance, smellType);\n            try {\n                currentBranch = fetchCommitBranch(commit);\n            } catch (BranchNotFoundException e) {\n                logger.warn(\"[\" + projectId + \"] ==> Unable to guess branch for commit (\" + commit.sha + \"), skipping\", e.getMessage());\n                continue;\n            }\n\n            // We create the new BranchAnalyzer if needed.\n            if (!branchAnalyzers.containsKey(currentBranch)) {\n                logger.debug(\"[\" + projectId + \"] => Initializing new branch: \" + currentBranch);\n                initializeBranch(currentBranch);\n            }\n\n            // We set the commit ordinal, branch-wise to enable our BranchAnalyzer\n            // to correctly handle gaps.\n            commit.setBranchOrdinal(fetchCommitOrdinal(currentBranch, commit));\n            branchAnalyzers.get(currentBranch).notifyCommit(commit);\n\n            // On commit change, we ensure to merge SmellPresence from the merged commit if necessary.\n            if (!previousCommit.equals(commit)) {\n                synchronizeMergeSmells(commit, currentBranch);\n            }\n\n            // Once the previous Smells are all set, notify our newly found smell.\n            branchAnalyzers.get(currentBranch).notifySmell(smell);\n\n            // When we are sure that we passed the last branch commit, we will finalize the branch analysis,\n            // i.e. setting introductions and refactoring for the last branch commit.\n            if (!previousCommit.equals(commit) && isLastBranchCommit(previousCommit, previousBranch)) {\n                finalizeBranch(previousBranch);\n                branchAnalyzers.remove(previousBranch);\n            }\n        }\n\n        // We should only perform operations for branch 0 since all other commits are looped around.\n        // On top of that, we may have missed some branch finalization because of lost commits.\n        for (int branchId : branchAnalyzers.keySet()) {\n            finalizeBranch(branchId);\n        }\n    }\n\n      BranchAwareSmellTypeAnalysis(int projectId, Persistence persistence, Iterator<Map<String, Object>> smells,\n                                 String smellType, SmellDuplicationChecker duplicationChecker,\n                                 CommitQueries commitQueries, SmellQueries smellQueries, BranchQueries branchQueries);\n\n    private void synchronizeMergeSmells(Commit commit, Integer currentBranch);\n    private int fetchCommitOrdinal(int branchId, Commit commit);\n    private void addSmellsToMergeCommit(int mergedCommitId, int currentBranch);\n    private void initializeBranch(int currentBranch);\n    private String retrieveBranchParentSha(int currentBranch);\n    private String getLastBranchCommit(int branchId);\n    private void finalizeBranch(int branchId);\n    private List<Smell> retrieveBranchParentSmells(int branchId);\n    private List<Smell> retrieveMergedCommitSmells(int mergedCommitId);\n    private static List<Smell> toSmells(List<Map<String, Object>> results);\n    private Integer getMergedCommitId(Commit commit);\n    private boolean isLastBranchCommit(Commit commit, int currentBranch);\n    private int fetchCommitBranch(Commit commit);\n\n}\n\nclass BranchAwareSmellTypeAnalysisTest  {\n\n    @Test\n    public void testHandleRenamedSmellMultipleCommits() throws QueryException {\n", "reference": "        ArgumentCaptor<Smell> smellCaptor = ArgumentCaptor.forClass(Smell.class);\n        addSmell(firstCommit, firstSmell);\n        addSmell(secondCommit, secondSmell);\n        addSmell(thirdCommit, secondSmell);\n        mockCommitBranch(firstCommit, 0, 0);\n        mockCommitBranch(secondCommit, 0, 1);\n        mockCommitBranch(thirdCommit, 0, 2);\n\n        // This means that the firstSmell instance has been renamed to second smell in the secondCommit\n        Smell expectedSecondSmell = mockSmellRenamed(secondCommit, secondSmell, firstSmell);\n        mockSmellId(expectedSecondSmell);\n        mockSmellRenamed(thirdCommit, secondSmell, firstSmell);\n        mockLastBranchCommit(0, thirdCommit.sha);\n\n        getAnalysis().query();\n        debugSmellInsertions();\n\n        verify(persistence, times(2)).execute(any());\n        verify(smellQueries).smellInsertionStatement(projectId, firstSmell);\n        // We introduce the new smell instance definition with renamed_from filled in.\n        // Since we use a captor we have to check all invocations of smellInsertionStatement...\n        verify(smellQueries, times(2)).smellInsertionStatement(eq(projectId), smellCaptor.capture());\n        // Check that the renamed commit has a set parent\n        Smell renamed = smellCaptor.getAllValues().get(1);\n        assertEquals(expectedSecondSmell, renamed);\n        assertEquals(firstSmell, renamed.parent);\n\n        verify(persistence, times(4)).addStatements(any());\n        verify(smellQueries).smellCategoryInsertionStatement(projectId, firstCommit.sha, firstSmell, SmellCategory.PRESENCE);\n        verify(smellQueries).smellCategoryInsertionStatement(projectId, firstCommit.sha, firstSmell, SmellCategory.INTRODUCTION);\n\n        verify(smellQueries).smellCategoryInsertionStatement(projectId, secondCommit.sha, expectedSecondSmell, SmellCategory.PRESENCE);\n        verify(smellQueries).smellCategoryInsertionStatement(projectId, thirdCommit.sha, expectedSecondSmell, SmellCategory.PRESENCE);\n    }\n\n}", "prediction": "        // Given\n        int projectId = 1;\n        Persistence persistence = mock(Persistence.class);\n        Iterator<Map<String, Object>> smells = mock(Iterator.class);\n        String smellType = \"smellType\";\n        SmellDuplicationChecker duplicationChecker = mock(SmellDuplicationChecker.class);\n        CommitQueries commitQueries = mock(CommitQueries.class);\n        SmellQueries smellQueries = mock(SmellQueries.class);\n        BranchQueries branchQueries = mock(BranchQueries.class);\n\n        // When\n        BranchAwareSmellTypeAnalysis branchAwareSmellTypeAnalysis = new BranchAwareSmellTypeAnalysis(projectId, persistence, smells, smellType, duplicationChecker, commitQueries, smellQueries, branchQueries);\n        branchAwareSmellTypeAnalysis.query();\n\n        // Then\n        verify(smellQueries, times(1)).fetchSmells(projectId, smellType);\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "175358739_4", "part": [1, 1], "seq": [1, 1], "prompt": "class Calculator {\n\n\t@Cacheable(\"sum\")\n\tpublic int sum(int a, int b) {\n\t\ttry {\n\t\t\tThread.sleep(3000);\n\t\t}\n\t\tcatch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\treturn a + b;\n\t}\n\n     private Calculator calculator;\n\n}\n\nclass CalculatorTest {\n\n     private Calculator calculator;\n\n     @Test\n     public void testSum() {\n", "reference": "          assertEquals(5, calculator.sum(2, 3));\n     }\n\n}", "prediction": "          int result = calculator.sum(1, 2);\n          assertEquals(3, result);\n     }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "175769409_0", "part": [1, 1], "seq": [1, 1], "prompt": "class Application {\n\n    public static void main(String[] args) {\n        Integer serverPort = PORT;\n        try {\n            if (args.length > 0) {\n                serverPort = Integer.valueOf(args[0]);\n            }\n        } catch (NumberFormatException e) {\n            LOGGER.error(\"Error in input parameters\");\n        }\n        // \u521d\u59cb\u5316\u91c7\u96c6\u5668\u914d\u7f6e\u6587\u4ef6\n        EngineContext.applicationInitialization();\n        // \u91c7\u96c6\u5668\u5185\u7f6e\u89e3\u6790\u89c4\u5219\u7b49\u521d\u59cb\u5316\n        EngineContext.componentsInitialization();\n        // \u751f\u6210source\u3001channel\u3001sink\uff0c\n        // \u6301\u6709\u6240\u6709\u7ec4\u4ef6\u751f\u547d\u5468\u671f\n        AgentComponent.init();\n        // \u542f\u52a8Server\n        HttpServerManager.start(serverPort);\n\n    }\n\n}\n\nclass ApplicationTest {\n\n    @Test\n    public void applicationTest() throws InterruptedException {\n", "reference": "        String[] args = new String[]{\"F:\\\\github\\\\dcsec-collector-engine\\\\engine-bootstrap\\\\src\\\\test\\\\resources\\\\application.properties\"};\n\n        Application.main(args);\n        Thread.sleep(1000000000);\n    }\n\n}", "prediction": "//        Application.main(new String[]{\"8080\"});\n        Thread.sleep(1000000000);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "176837289_44", "part": [1, 1], "seq": [1, 1], "prompt": "class SessionCacheFetcher extends CacheFetcher {\n\n    @Override\n    protected Object computeResult() {\n        return SessionTokenUtils.getSessionFromRawToken(rawToken);\n    }\n\n    public  SessionCacheFetcher(String rawToken);\n\n    @Override protected String getCacheKey();\n    @Override protected int getLocalCacheTime();\n    @Override protected int getRemoteCacheTime();\n    @Override protected Object fromJson(String json);\n\n    private static final String GCS;\n    private static final String BIGQUERY;\n    private static final String ALICE;\n    private static final String MOCK_BUCKET;\n    private static final Long SESSION_RENEW_PERIOD;\n    private static final Long SESSION_MAXIMUM_LIFETIME;\n    @ClassRule\n    public static SettingsOverride settingsOverride;\n\n}\n\nclass SessionCacheFetcherTest {\n\n    private static final String GCS;\n    private static final String BIGQUERY;\n    private static final String ALICE;\n    private static final String MOCK_BUCKET;\n    private static final Long SESSION_RENEW_PERIOD;\n    private static final Long SESSION_MAXIMUM_LIFETIME;\n    @ClassRule\n    public static SettingsOverride settingsOverride;\n\n    @Test\n    public void testComputeResult() {\n", "reference": "        Session session = createSession();\n        String rawToken = SessionTokenUtils.marshallSessionToken(session);\n        SessionCacheFetcher fetcher = new SessionCacheFetcher(rawToken);\n        Session computed = (Session) fetcher.computeResult();\n        assertEquals(session.getId(), computed.getId());\n    }\n\n}", "prediction": "        SessionCacheFetcher fetcher = new SessionCacheFetcher(rawToken);\n        Session session = (Session) fetcher.getResult();\n        assertEquals(session.getSubject(), \"alice\");\n        assertEquals(session.getExpiresAt(), 1500000000000L);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "181976854_0", "part": [1, 1], "seq": [1, 1], "prompt": "class PaginatingListComponent extends ListComponent<P, T> {\n\n    @Override\n    public int getCount() {\n        return super.getCount() + (mShouldShowFooter? 1 : 0);\n    }\n\n    public  PaginatingListComponent(\n            @NonNull P presenter,\n            @NonNull Class<? extends ComponentViewHolder<P, T>> listItemViewHolder);\n\n    @Nullable @Override public P getPresenter(int position);\n    @Nullable @Override public Object getItem(int position);\n    @NonNull @Override public Class<? extends ComponentViewHolder> getHolderType(int position);\n    @Override @CallSuper protected void onGetListItem(int position);\n    @NonNull public Observable<Integer> getFurthestObservable();\n    public void toggleLoadingFooter(boolean shouldShowFooter);\n    public void setLoadingFooter(@NonNull Class<? extends LoadingFooterViewHolder> loadingFooter);\n\n    private PaginatingListComponent<Void, Object> mPaginatingListComponent;\n\n}\n\nclass PaginatingListComponentTest {\n\n    private PaginatingListComponent<Void, Object> mPaginatingListComponent;\n\n    @Test\n    public void addSomeItems() {\n", "reference": "        addItems(5);\n\n        assertEquals(9, mPaginatingListComponent.getCount()); // 5 items, 4 dividers\n    }\n\n}", "prediction": "        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        mPaginatingListComponent.add(new Object());\n        m", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "183214896_1", "part": [1, 1], "seq": [1, 1], "prompt": "class BaseAuthFilter extends ModalityFilter {\n\n    protected void processProtectedRequest(USER logged, HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws IOException, ServletException\n    {\n        if (logger.isDebugEnabled())\n        {\n            // CB TODO - other uris logging should decode uris\n            String characterEncoding = Optional.ofNullable(request.getCharacterEncoding()).orElse(\"utf-8\");\n            logger.debug(\"user '{}' going towards {}\", displayUser(logged), URLDecoder.decode(request.getRequestURI(), characterEncoding));\n        }\n        filterChain.doFilter(request, response);\n    }\n\n    protected boolean isProtectedURI(String uri);\n    protected void processPublicRequest(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain);\n    protected USER getAuthentifiedUser(HttpServletRequest request);\n    protected abstract USER authenticate(HttpServletRequest request);\n    protected void processForbiddenRequest(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain);\n    @Override public void init(FilterConfig filterConfig);\n    @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain chain);\n    @Override public void destroy();\n    protected String displayUser(USER user);\n    protected final String getRealm();\n\n    private AuthFilter authFilter;\n\n}\n\nclass BaseAuthFilterTest extends ModalityFilter {\n\n    private AuthFilter authFilter;\n\n    @Test\n    public void processProtectedRequest() throws Exception\n    {\n", "reference": "        recordConfig();\n        expect(request.getRequestURI()).andAnswer(eval(\"/some-uri\"));\n        expect(request.getParameter(\"Good-Login\")).andAnswer(eval(\"Nestor\"));\n        expect(request.getCharacterEncoding()).andAnswer(eval(\"utf-8\"));\n        expect(request.getRequestURI()).andAnswer(eval(\"/some-uri\"));\n        filterChain.doFilter(request, response);\n        replayAll();\n        authFilter = new AuthFilter();\n        authFilter.init(filterConfig);\n        authFilter.doFilter(request, response, filterChain);\n    }\n\n}", "prediction": "        HttpServletRequest request = mock(HttpServletRequest.class);\n        HttpServletResponse response = mock(HttpServletResponse.class);\n        FilterChain filterChain = mock(FilterChain.class);\n\n        authFilter.processProtectedRequest(null, request, response, filterChain);\n\n        verify(filterChain).doFilter(request, response);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "183382310_0", "part": [1, 1], "seq": [1, 1], "prompt": "class StringUtil {\n\n    public static boolean isAscii(@NonNull String text) {\n        Objects.requireNonNull(text, \"text is null\");\n        return StandardCharsets.US_ASCII.newEncoder().canEncode(text);\n    }\n\n}\n\nclass StringUtilTest {\n\n    @Test\n    public void asciiTest() {\n", "reference": "        assertFalse(StringUtil.isAscii(\"R\u00e9al\"));\n        assertTrue(StringUtil.isAscii(\"Real\"));\n    }\n\n}", "prediction": "        assertTrue(StringUtil.isAscii(\"abc\"));\n        assertTrue(StringUtil.isAscii(\"abc123\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\\\\\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\\\\\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\\\\\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\\\\\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\\\\\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\\\\\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\\\\\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\\\\\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\\\\\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\\\\\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\\\\\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\\\\\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\\\\\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\\\\\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\\\\\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\\\\\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\\\\\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\\\\\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\\\\\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\\\\\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\\\\\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\\\\\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\\\\\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\\\\\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\\\\\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\\\\\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\\\\\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\\\\\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\\\\\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\\\\\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\\\\\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\\\\\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\\\\\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\\\\\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\\\\\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\\\\\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\\\\\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\\\\\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\\\\\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\\\\\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\\\\\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\\\\\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\\\\\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\\\\\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\\\\\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\\\\\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\\\\\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\\\\\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\\\\\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\\\\\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\\\\\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\\\\\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\\\\\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]{}-_=+,.?/\\\\\"));\n        assertTrue(StringUtil.isAscii(\"abc123!@#$%^&*()[]", "finish_reason": "length", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "183540010_2", "part": [1, 1], "seq": [1, 1], "prompt": "class CircularQueue {\n\n    public void put(Object item) {\n        precondition(item!= null, \"put() null item\");\n        precondition(!full(),\n                \"put() into full CircularQueue\");\n        assert invariant();\n        data[in++] = item;\n        if (in >= data.length) {\n            in = 0;\n            wrapped = true;\n        }\n        assert invariant();\n    }\n\n    public  CircularQueue(int size);\n\n    public boolean empty();\n    public boolean full();\n    public boolean isWrapped();\n    public Object get();\n    private static void precondition(boolean cond, String msg);\n    private static boolean postcondition(boolean cond, String msg);\n    private boolean invariant();\n    public String dump();\n\n    private CircularQueue queue;\n    private int i;\n\n}\n\nclass CircularQueueTest {\n\n    private CircularQueue queue;\n    private int i;\n\n    @Test\n    public void nullPut() {\n", "reference": "        System.out.println(\"testNullPut\");\n        String msg = \"\";\n        try {\n            queue.put(null);\n        } catch (CircularQueueException e) {\n            msg = e.getMessage();\n            System.out.println(msg);\n        }\n        assertEquals(msg, \"put() null item\");\n    }\n\n}", "prediction": "        queue = new CircularQueue(10);\n        try {\n            queue.put(null);\n            fail(\"put() null item\");\n        } catch (IllegalArgumentException e) {\n            // expected\n        }\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "188705852_2", "part": [1, 1], "seq": [1, 1], "prompt": "class AuthenticationService {\n\n    public LoginToken authenticate(String username, String password) {\n        // TODO use REST template to communicate the backend\n        RestTemplate restTemplate = new RestTemplate();\n\n        MultiValueMap<String, String> multiValueMap = new LinkedMultiValueMap<>();\n        multiValueMap.add(\"username\", username);\n        multiValueMap.add(\"password\", password);\n        LoginToken loginToken = restTemplate.postForObject(authUrl, multiValueMap, LoginToken.class);\n\n        return loginToken;\n    }\n\n    @Autowired\n    private AuthenticationService authenticationService;\n\n}\n\nclass AuthenticationServiceTest {\n\n    @Autowired\n    private AuthenticationService authenticationService;\n\n    @Test\n    public void authenticate_incorrect() {\n", "reference": "        LoginToken loginToken = authenticationService.authenticate(\"kmh\", \"abcd1234xx\");\n        assertNull(loginToken.getUsername());\n        assertNull(loginToken.getFullname());\n        assertEquals(\"norole\", loginToken.getRole());\n    }\n\n}", "prediction": "        LoginToken loginToken = authenticationService.authenticate(\"user\", \"\");\n        Assert.assertNull(loginToken);\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "189453445_70", "part": [1, 1], "seq": [1, 1], "prompt": "class RDSRaiderImpl implements RDSRaider {\n\n    @Override\n    public void startInstances(List<String> dbNames) {\n        if (dbNames.isEmpty()) {\n            throw new InvalidInputDataException(\"Empty dbNames list\");\n        }\n\n        for (String dbName : dbNames) {\n            DBInstance dbInstance = rdsDelegator.getAmazonRds().startDBInstance(\n                    new StartDBInstanceRequest().withDBInstanceIdentifier(dbName));\n            if (dbInstance == null) {\n                throw new com.intuit.cloudraider.exceptions.ResourceNotFoundException(\"Unable to start DB instance: \" + dbName);\n            }\n\n        }\n    }\n\n    public  RDSRaiderImpl();\n\n    @Override public List<DBInstance> getAllDbInstances();\n    @Override public List<DBInstance> getInstanceIdsForAvailabilityZone(String availabilityZone, List<String> dbInstanceIdsToIgnore);\n    @Override public List<DBStatus> getInstancesStatus(List<String> dbInstanceIds);\n    @Override public void stopInstances(List<String> dbNames);\n    @Override public List<String> getAllDbInstanceNames();\n    @Override public List<String> getDBInstancesStatus();\n    @Override public String getDBInstanceStatus(String dbName);\n    @Override public void rebootDbInstances(List<String> dbNames);\n    @Override public void rebootDbInstance(String dbName);\n    @Override public void rebootDbInstanceWithForceFailover(String dbName);\n    @Deprecated public void detachSecurityGroup(String dbName, String securityGroup);\n    @Deprecated public void attachSecurityGroup(String dbName, String securityGroup);\n    @Override public List<String> getSecurityGroups(String dbName);\n    @Override public List<String> getSubnetIds(String dbName);\n    @Override public void detachSecurityGroups(String dbName, String... securityGroups);\n    @Override public void attachSecurityGroups(String dbName, String... securityGroups);\n    @Override public void detachSubnet(String dbName, String subnetId);\n    @Override public void attachSubnet(String dbName, String subnetId);\n    @Override public void restoreDBInstanceFromSnapshot(String dbName, String snapshotId);\n    @Override public void modifyDbStorageSize(String dbName, int newSize);\n    @Override public void modifyDbInstanceClass(String dbName, String dbInstanceClass);\n    @Override public void modifyDbIops(String dbName, Integer iops);\n    @Override public String getDBInstanceClass(String dbName);\n    @Override public Integer getDBStorageSize(String dbName);\n    @Override public Integer getIops(String dbName);\n    @Override public void generateSnapshot(String dbName, String snapshotName);\n    private String getSubnetGroupName(String dbName);\n\n    @Autowired\n    private RDSRaider rdsRaider;\n    @Autowired\n    private RDSDelegator rdsDelegator;\n    private static AmazonRDS amazonRDS;\n    private DBInstance dbInstance;\n\n}\n\nclass RDSRaiderImplTest {\n\n    @Autowired\n    private RDSRaider rdsRaider;\n    @Autowired\n    private RDSDelegator rdsDelegator;\n    private static AmazonRDS amazonRDS;\n    private DBInstance dbInstance;\n\n    @Test (expected = ResourceNotFoundException.class)\n    public void testStartInvalidDbInstances() {\n", "reference": "        PowerMockito.when(amazonRDS.startDBInstance(Mockito.anyObject())).thenReturn(null);\n        rdsRaider.startInstances(Arrays.asList(\"blah\"));\n\n    }\n\n}", "prediction": "        rdsRaider.startInstances(new ArrayList<String>());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "189562861_265", "part": [1, 1], "seq": [1, 1], "prompt": "class ClassHelper {\n\n    public static Class<?> forNameWithCallerClassLoader(String name, Class<?> caller)\n            throws ClassNotFoundException {\n        return forName(name, caller.getClassLoader());\n    }\n\n    public static Class<?> forNameWithThreadContextClassLoader(String name);\n    public static ClassLoader getCallerClassLoader(Class<?> caller);\n    public static ClassLoader getClassLoader(Class<?> cls);\n    public static ClassLoader getClassLoader();\n    public static Class<?> forName(String name);\n    public static Class<?> forName(String name, ClassLoader classLoader);\n    public static Class<?> resolvePrimitiveClassName(String name);\n    public static String toShortString(Object obj);\n\n}\n\nclass ClassHelperTest {\n\n    @Test\n    public void tetForNameWithCallerClassLoader() throws Exception {\n", "reference": "        Class c = ClassHelper.forNameWithCallerClassLoader(ClassHelper.class.getName(), ClassHelperTest.class);\n        assertThat(c == ClassHelper.class, is(true));\n    }\n\n}", "prediction": "        Class<?> cls = ClassHelper.forNameWithCallerClassLoader(\"java.lang.String\", ClassHelperTest.class);\n        Assert.assertEquals(String.class, cls);\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "190938308_0", "part": [1, 1], "seq": [1, 1], "prompt": "class ShowMessageLogic {\n\n    public boolean shouldShowMessage() {\n        return counterPreferences.getCounter() >= 42;\n    }\n\n    public  ShowMessageLogic(final CounterPreferences counterPreferences);\n\n    private final SPMockBuilder spMockBuilder;\n    private CounterPreferences counterPreferences;\n    private ShowMessageLogic showMessageLogic;\n\n}\n\nclass ShowMessageLogicTest {\n\n    private final SPMockBuilder spMockBuilder;\n    private CounterPreferences counterPreferences;\n    private ShowMessageLogic showMessageLogic;\n\n    @Test\n    public void on42CounterItShouldShowMessage() {\n", "reference": "        counterPreferences.setCounter(42);\n\n        Assert.assertTrue(showMessageLogic.shouldShowMessage());\n    }\n\n}", "prediction": "        counterPreferences.setCounter(42);\n        assertTrue(showMessageLogic.shouldShowMessage());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "196205406_0", "part": [1, 1], "seq": [1, 1], "prompt": "class MyService {\n\n    public String message(){\n        return \"this is module for helloworld.service method message\";\n    }\n\n    @Autowired\n    private MyService myService;\n\n}\n\nclass MyServiceTest {\n\n    @Autowired\n    private MyService myService;\n\n    @Test\n    public void contextLoads(){\n", "reference": "        assertThat(myService.message()).isNotNull();\n    }\n\n}", "prediction": "        System.out.println(myService.message());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "198884888_0", "part": [1, 1], "seq": [1, 1], "prompt": "class APIController {\n\n    @GetMapping(value = \"/public\")\n    public Message publicEndpoint() {\n        return new Message(\"All good. You DO NOT need to be authenticated to call /api/public.\");\n    }\n\n    @GetMapping(value = \"/private\") public Message privateEndpoint();\n    @GetMapping(value = \"/private-scoped\") public Message privateScopedEndpoint();\n\n    @Autowired\n    private MockMvc mockMvc;\n    @MockBean\n    @SuppressWarnings(\"unused\")\n    private JwtDecoder jwtDecoder;\n\n}\n\nclass APIControllerTest {\n\n    @Autowired\n    private MockMvc mockMvc;\n    @MockBean\n    @SuppressWarnings(\"unused\")\n    private JwtDecoder jwtDecoder;\n\n    @Test\n    public void testPublicEndpoint() throws Exception {\n", "reference": "        MvcResult mvcResult = mockMvc.perform(get(\"/api/public\"))\n                .andDo(print())\n                .andExpect(status().isOk())\n                .andReturn();\n        \n        assertNotNull(mvcResult.getResponse().getContentAsString());\n    }\n\n}", "prediction": "        mockMvc.perform(get(\"/api/public\"))\n               .andExpect(status().isOk())\n               .andExpect(content().string(\"All good. You DO NOT need to be authenticated to call /api/public.\"));\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "201050057_2", "part": [1, 1], "seq": [1, 1], "prompt": "class TaskServiceImpl implements TaskService {\n\n    @Override\n    public void addOrUpdate(Task task) {\n        if (task.getId() == null) {\n            throw new IllegalArgumentException(\"Id property must be set\");\n        }\n        tasks.put(task.getId(), task);\n    }\n\n    public  TaskServiceImpl();\n\n    @Override public Task getById(Integer id);\n    @Override public Collection<Task> getAll();\n    @Override public void delete(Integer id);\n\n    private TaskService taskService;\n\n}\n\nclass TaskServiceImplTest {\n\n    private TaskService taskService;\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testAddIllegal() {\n", "reference": "        Task task = new Task();\n        taskService.addOrUpdate(task);\n    }\n\n}", "prediction": "        taskService.addOrUpdate(new Task());\n    }", "finish_reason": "stop", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
{"id": "201420026_6", "part": [1, 1], "seq": [1, 1], "prompt": "class LideaLogDAO {\n\n    public LideaLogResp scan(LideaLogReq req) {\n\n        Scan scan = createScan(req);\n\n        ResultsExtractor<List<LideaLogBO>> extractor = new LideaLogResultsExtractor();\n        List<LideaLogBO> list = hbaseTemplate.find(Const.LIDEA_LOG_TABLE, scan, extractor);\n\n        LideaLogResp resp = new LideaLogResp();\n        resp.setData(list);\n        resp.setAppName(req.getAppName());\n        resp.setServiceName(req.getServiceName());\n        resp.setMethodName(req.getMethodName());\n\n        return resp;\n    }\n\n    public void put(LideaLogBO bo);\n    private Scan createScan(LideaLogReq bo);\n    public LideaLogResp get(LideaLogReq req);\n\n    @Resource\n    private LideaLogDAO lideaLogDAO;\n\n}\n\nclass LideaLogDAOTest {\n\n    @Resource\n    private LideaLogDAO lideaLogDAO;\n\n    @Test\n    public void testScan() {\n", "reference": "\n        LideaLogReq req = new LideaLogReq();\n\n        req.setAppName(\"cabinet-base-server\");\n        req.setServiceName(\"com.fcbox.edms.terminal.api.CabinetServiceFacade\");\n        req.setMethodName(\"getCabinetInfo\");\n\n        req.setFrom(TimeUtil.stringToLong(\"2019-07-20 00:00:00\"));\n        req.setTo(TimeUtil.stringToLong(\"2019-08-29 23:00:00\"));\n\n        LideaLogResp resp = lideaLogDAO.scan(req);\n        System.out.println(\"==========================================================================================\");\n        System.out.println(JSON.toJSONString(resp));\n    }\n\n}", "prediction": "//        LideaLogReq req = new LideaLogReq();\n//        req.setAppName(\"test\");\n//        req.setServiceName(\"test\");\n//        req.setMethodName(\"test\");\n//        req.setStartTime(\"2018-01-01 00:00:00\");\n//        req.setEndTime(\"2018-01-01 00:00:00\");\n//        LideaLogResp resp = lideaLogDAO.scan(req);\n//        System.out.println(resp);\n    }", "finish_reason": "brace_matching", "meta": {"subset": "fm+fc+c+m+f+t+tc"}}
